er.Socket, sizeof (Svb->SocketVal));
		SetAsnInteger (&Svb->mipxStaticServHopCount, Svp->Server.HopCount);
		MprAdminMIBBufferFree (Svp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
											actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_STATICSERVERS,
			("MIPX-static servers: End of table reached on GETFIRST/GETNEXT request"
					" for service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_STATICSERVERS,
			("MIPX-static servers: Get request for service %.4x-%.48s"
					" on if %ld failed with error %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex,
				rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Svb
}

UINT
set_mipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Svb	((sav_mipxStaticServEntry *)objectArray)
	PIPX_SERVICE			Svp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}
	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
						Svb->mipxStaticServIfIndex.asnType
						&&Svb->mipxStaticServType.asnType
						&&Svb->mipxStaticServName.asnType);
		MibGetInputData.TableId = IPX_STATIC_SERV_TABLE;
		MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex
			= (ULONG)GetAsnInteger (&Svb->mipxStaticServIfIndex,
				INVALID_INTERFACE_INDEX);
		MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType
			= GetAsnServType (&Svb->mipxStaticServType, INVALID_SERVER_TYPE);
		GetAsnDispString (
			MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
			&Svb->mipxStaticServName,
			INVALID_SERVER_NAME);
		Svb->ActionFlag
			= (BOOLEAN)GetAsnInteger (&Svb->mipxStaticServEntryStatus,
			MIPX_EXIST_STATE_NOACTION);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
        if (rc == NO_ERROR && Svp == NULL)
        {
            return MIB_S_ENTRY_NOT_FOUND;
        }
									
		if (rc==NO_ERROR) {
			Svb->MibSetInputData.MibRow.Service = *Svp;
			if (Svb->ActionFlag == MIPX_EXIST_STATE_CREATED)
				Svb->ActionFlag = MIPX_EXIST_STATE_NOACTION;
			MprAdminMIBBufferFree (Svp);
			DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Validated"
					" service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
		}
		else if (Svb->ActionFlag == MIPX_EXIST_STATE_CREATED) {
			DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Prepared to add"
					" service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
			Svb->MibSetInputData.MibRow.Service.InterfaceIndex
				= (ULONG) GetAsnInteger (&Svb->mipxStaticServIfIndex,
					INVALID_INTERFACE_INDEX);
			Svb->MibSetInputData.MibRow.Service.Protocol = IPX_PROTOCOL_STATIC;
			Svb->MibSetInputData.MibRow.Service.Server.Type
				= GetAsnServType (&Svb->mipxStaticServType,
					INVALID_SERVER_TYPE);
			GetAsnDispString (
				Svb->MibSetInputData.MibRow.Service.Server.Name,
				&Svb->mipxStaticServName,
				INVALID_SERVER_NAME);
			memset (Svb->MibSetInputData.MibRow.Service.Server.Network, 0,
					sizeof (Svb->MibSetInputData.MibRow.Service.Server.Network));
			memset (Svb->MibSetInputData.MibRow.Service.Server.Node, 0,
					sizeof (Svb->MibSetInputData.MibRow.Service.Server.Node));
			memset (Svb->MibSetInputData.MibRow.Service.Server.Socket, 0,
					sizeof (Svb->MibSetInputData.MibRow.Service.Server.Socket));
			Svb->MibSetInputData.MibRow.Service.Server.HopCount = 15;
		}
		else {
			DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Validate failed"
					" for service %.4x-%.48s on if %ld with error %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex,
				rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
		GetAsnOctetString (Svb->MibSetInputData.MibRow.Service.Server.Network,
			&Svb->mipxStaticServNetNum,
			sizeof (Svb->MibSetInputData.MibRow.Service.Server.Network),
			NULL);
		GetAsnOctetString (Svb->MibSetInputData.MibRow.Service.Server.Node,
			&Svb->mipxStaticServNode,
			sizeof (Svb->MibSetInputData.MibRow.Service.Server.Node),
			NULL);
		GetAsnOctetString (Svb->MibSetInputData.MibRow.Service.Server.Socket,
			&Svb->mipxStaticServSocket,
			sizeof (Svb->MibSetInputData.MibRow.Service.Server.Socket),
			NULL);
		Svb->MibSetInputData.MibRow.Service.Server.HopCount =
			(USHORT)GetAsnInteger (&Svb->mipxStaticServHopCount,
			Svb->MibSetInputData.MibRow.Service.Server.HopCount);
		return MIB_S_SUCCESS;
	case MIB_ACTION_SET:
		switch (Svb->ActionFlag) {
		case MIPX_EXIST_STATE_NOACTION:
			rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Svb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case MIPX_EXIST_STATE_DELETED:
			rc = MprAdminMIBEntryDelete (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Svb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case MIPX_EXIST_STATE_CREATED:
			rc = MprAdminMIBEntryCreate (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Svb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		}

		if (rc==NO_ERROR) {
			DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Set succeded"
					" for service %.4x-%.48s on if %ld.\n",
				Svb->MibSetInputData.MibRow.Service.Server.Type,
				Svb->MibSetInputData.MibRow.Service.Server.Name,
				Svb->MibSetInputData.MibRow.Service.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Set failed for"
					" for service %.4x-%.48s on if %ld with error %ld.\n",
				Svb->MibSetInputData.MibRow.Service.Server.Type,
				Svb->MibSetInputData.MibRow.Service.Server.Name,
				Svb->MibSetInputData.MibRow.Service.InterfaceIndex,
				rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Svb
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ipx\snmp\nipxe.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nipxe.h

Abstract:

    Novell-ipx mib entry indeces

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/


#ifndef _SNMP_NIPXE_
#define _SNMP_NIPXE_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry indices                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define mi_nipxSystem						0

#define mi_nipxBasicSysTable				mi_nipxSystem+1
#define mi_nipxBasicSysEntry				mi_nipxBasicSysTable+1

#define mi_nipxBasicSysInstance				mi_nipxBasicSysEntry+1
#define mi_nipxBasicSysExistState			mi_nipxBasicSysInstance+1
#define mi_nipxBasicSysNetNumber			mi_nipxBasicSysExistState+1
#define mi_nipxBasicSysNode					mi_nipxBasicSysNetNumber+1
#define mi_nipxBasicSysName					mi_nipxBasicSysNode+1
#define mi_nipxBasicSysInReceives			mi_nipxBasicSysName+1
#define mi_nipxBasicSysInHdrErrors			mi_nipxBasicSysInReceives+1
#define mi_nipxBasicSysInUnknownSockets		mi_nipxBasicSysInHdrErrors+1
#define mi_nipxBasicSysInDiscards			mi_nipxBasicSysInUnknownSockets+1
#define mi_nipxBasicSysInBadChecksums		mi_nipxBasicSysInDiscards+1
#define mi_nipxBasicSysInDelivers			mi_nipxBasicSysInBadChecksums+1
#define mi_nipxBasicSysNoRoutes				mi_nipxBasicSysInDelivers+1
#define mi_nipxBasicSysOutRequests			mi_nipxBasicSysNoRoutes+1
#define mi_nipxBasicSysOutMalformedRequests	mi_nipxBasicSysOutRequests+1
#define mi_nipxBasicSysOutDiscards			mi_nipxBasicSysOutMalformedRequests+1
#define mi_nipxBasicSysOutPackets			mi_nipxBasicSysOutDiscards+1
#define mi_nipxBasicSysConfigSockets		mi_nipxBasicSysOutPackets+1
#define mi_nipxBasicSysOpenSocketFails		mi_nipxBasicSysConfigSockets+1

#define mi_nipxAdvSysTable					mi_nipxBasicSysOpenSocketFails+1
#define mi_nipxAdvSysEntry					mi_nipxAdvSysTable+1

#define mi_nipxAdvSysInstance				mi_nipxAdvSysEntry+1
#define mi_nipxAdvSysMaxPathSplits			mi_nipxAdvSysInstance+1
#define mi_nipxAdvSysMaxHops				mi_nipxAdvSysMaxPathSplits+1
#define mi_nipxAdvSysInTooManyHops			mi_nipxAdvSysMaxHops+1
#define mi_nipxAdvSysInFiltered				mi_nipxAdvSysInTooManyHops+1
#define mi_nipxAdvSysInCompressDiscards		mi_nipxAdvSysInFiltered+1
#define mi_nipxAdvSysNETBIOSPackets			mi_nipxAdvSysInCompressDiscards+1
#define mi_nipxAdvSysForwPackets			mi_nipxAdvSysNETBIOSPackets+1
#define mi_nipxAdvSysOutFiltered			mi_nipxAdvSysForwPackets+1
#define mi_nipxAdvSysOutCompressDiscards	mi_nipxAdvSysOutFiltered+1
#define mi_nipxAdvSysCircCount				mi_nipxAdvSysOutCompressDiscards+1
#define mi_nipxAdvSysDestCount				mi_nipxAdvSysCircCount+1
#define mi_nipxAdvSysServCount				mi_nipxAdvSysDestCount+1


#define mi_nipxCircuit						mi_nipxAdvSysServCount+1

#define mi_nipxCircTable					mi_nipxCircuit+1
#define mi_nipxCircEntry					mi_nipxCircTable+1

#define mi_nipxCircSysInstance				mi_nipxCircEntry+1
#define mi_nipxCircIndex					mi_nipxCircSysInstance+1
#define mi_nipxCircExistState				mi_nipxCircIndex+1
#define mi_nipxCircOperState				mi_nipxCircExistState+1
#define mi_nipxCircIfIndex					mi_nipxCircOperState+1
#define mi_nipxCircName						mi_nipxCircIfIndex+1
#define mi_nipxCircType						mi_nipxCircName+1
#define mi_nipxCircDialName					mi_nipxCircType+1
#define mi_nipxCircLocalMaxPacketSize		mi_nipxCircDialName+1
#define mi_nipxCircCompressState			mi_nipxCircLocalMaxPacketSize+1
#define mi_nipxCircCompressSlots			mi_nipxCircCompressState+1
#define mi_nipxCircStaticStatus				mi_nipxCircCompressSlots+1
#define mi_nipxCircCompressedSent			mi_nipxCircStaticStatus+1
#define mi_nipxCircCompressedInitSent		mi_nipxCircCompressedSent+1
#define mi_nipxCircCompressedRejectsSent	mi_nipxCircCompressedInitSent+1
#define mi_nipxCircUncompressedSent			mi_nipxCircCompressedRejectsSent+1
#define mi_nipxCircCompressedReceived		mi_nipxCircUncompressedSent+1
#define mi_nipxCircCompressedInitReceived	mi_nipxCircCompressedReceived+1
#define mi_nipxCircCompressedRejectsReceived mi_nipxCircCompressedInitReceived+1
#define mi_nipxCircUncompressedReceived		mi_nipxCircCompressedRejectsReceived+1
#define mi_nipxCircMediaType				mi_nipxCircUncompressedReceived+1
#define mi_nipxCircNetNumber				mi_nipxCircMediaType+1
#define mi_nipxCircStateChanges				mi_nipxCircNetNumber+1
#define mi_nipxCircInitFails				mi_nipxCircStateChanges+1
#define mi_nipxCircDelay					mi_nipxCircInitFails+1
#define mi_nipxCircThroughput				mi_nipxCircDelay+1
#define mi_nipxCircNeighRouterName			mi_nipxCircThroughput+1
#define mi_nipxCircNeighInternalNetNum		mi_nipxCircNeighRouterName+1


#define mi_nipxForwarding					mi_nipxCircNeighInternalNetNum+1

#define mi_nipxDestTable					mi_nipxForwarding+1
#define mi_nipxDestEntry					mi_nipxDestTable+1

#define mi_nipxDestSysInstance				mi_nipxDestEntry+1
#define mi_nipxDestNetNum					mi_nipxDestSysInstance+1
#define mi_nipxDestProtocol					mi_nipxDestNetNum+1
#define mi_nipxDestTicks					mi_nipxDestProtocol+1
#define mi_nipxDestHopCount					mi_nipxDestTicks+1
#define mi_nipxDestNextHopCircIndex			mi_nipxDestHopCount+1
#define mi_nipxDestNextHopNICAddress		mi_nipxDestNextHopCircIndex+1
#define mi_nipxDestNextHopNetNum			mi_nipxDestNextHopNICAddress+1

#define mi_nipxStaticRouteTable				mi_nipxDestNextHopNetNum+1
#define mi_nipxStaticRouteEntry				mi_nipxStaticRouteTable+1

#define mi_nipxStaticRouteSysInstance		mi_nipxStaticRouteEntry+1
#define mi_nipxStaticRouteCircIndex			mi_nipxStaticRouteSysInstance+1
#define mi_nipxStaticRouteNetNum			mi_nipxStaticRouteCircIndex+1
#define mi_nipxStaticRouteExistState		mi_nipxStaticRouteNetNum+1
#define mi_nipxStaticRouteTicks				mi_nipxStaticRouteExistState+1
#define mi_nipxStaticRouteHopCount			mi_nipxStaticRouteTicks+1


#define mi_nipxServices						mi_nipxStaticRouteHopCount+1

#define mi_nipxServTable					mi_nipxServices+1
#define mi_nipxServEntry					mi_nipxServTable+1

#define mi_nipxServSysInstance				mi_nipxServEntry+1
#define mi_nipxServType						mi_nipxServSysInstance+1
#define mi_nipxServName						mi_nipxServType+1
#define mi_nipxServProtocol					mi_nipxServName+1
#define mi_nipxServNetNum					mi_nipxServProtocol+1
#define mi_nipxServNode						mi_nipxServNetNum+1
#define mi_nipxServSocket					mi_nipxServNode+1
#define mi_nipxServHopCount					mi_nipxServSocket+1

#define mi_nipxDestServTable				mi_nipxServHopCount+1
#define mi_nipxDestServEntry				mi_nipxDestServTable+1

#define mi_nipxDestServSysInstance			mi_nipxDestServEntry+1
#define mi_nipxDestServNetNum				mi_nipxDestServSysInstance+1
#define mi_nipxDestServNode					mi_nipxDestServNetNum+1
#define mi_nipxDestServSocket				mi_nipxDestServNode+1
#define mi_nipxDestServName					mi_nipxDestServSocket+1
#define mi_nipxDestServType					mi_nipxDestServName+1
#define mi_nipxDestServProtocol				mi_nipxDestServType+1
#define mi_nipxDestServHopCount				mi_nipxDestServProtocol+1

#define mi_nipxStaticServTable				mi_nipxDestServHopCount+1
#define mi_nipxStaticServEntry				mi_nipxStaticServTable+1

#define mi_nipxStaticServSysInstance		mi_nipxStaticServEntry+1
#define mi_nipxStaticServCircIndex			mi_nipxStaticServSysInstance+1
#define mi_nipxStaticServType				mi_nipxStaticServCircIndex+1
#define mi_nipxStaticServName				mi_nipxStaticServType+1
#define mi_nipxStaticServExistState			mi_nipxStaticServName+1
#define mi_nipxStaticServNetNum				mi_nipxStaticServExistState+1
#define mi_nipxStaticServNode				mi_nipxStaticServNetNum+1
#define mi_nipxStaticServSocket				mi_nipxStaticServNode+1
#define mi_nipxStaticServHopCount			mi_nipxStaticServSocket+1

//nipxTraps		


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxBasicSysEntry table (1.3.6.1.4.1.23.2.5.1.1.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxBasicSysEntry                18
#define ni_nipxBasicSysEntry                1


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxAdvSysEntry table (1.3.6.1.4.1.23.2.5.1.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxAdvSysEntry                  13
#define ni_nipxAdvSysEntry                  1


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxCircEntry table (1.3.6.1.4.1.23.2.5.2.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxCircEntry                    28
#define ni_nipxCircEntry                    2


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxDestEntry table (1.3.6.1.4.1.23.2.5.3.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxDestEntry                    8
#define ni_nipxDestEntry                    2


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxStaticRouteEntry table (1.3.6.1.4.1.23.2.5.3.2.1)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxStaticRouteEntry             6
#define ni_nipxStaticRouteEntry             3


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxServEntry table (1.3.6.1.4.1.23.2.5.4.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxServEntry                    8
#define ni_nipxServEntry                    3


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxDestServEntry table (1.3.6.1.4.1.23.2.5.4.2.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxDestServEntry                8
#define ni_nipxDestServEntry                6


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxStaticServEntry table (1.3.6.1.4.1.23.2.5.4.3.1)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxStaticServEntry              9
#define ni_nipxStaticServEntry              4


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ipx\snmp\mripsapf.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mripsap.c

Abstract:

    ms-ripsap instrumentation callbacks.

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/

#include "precomp.h"




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripsapBase group (1.3.6.1.4.1.311.1.9.1)                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mripsapBase(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Beb	((buf_mripsapBase *)objectArray)
	RIP_MIB_GET_INPUT_DATA	RipMibGetInputData;
	SAP_MIB_GET_INPUT_DATA	SapMibGetInputData;
	PRIPMIB_BASE			RipBep = NULL;
	PSAP_MIB_BASE			SapBep = NULL;
	DWORD					rc;
	ULONG					BeSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	switch (actionId) {
	case MIB_ACTION_GET:
		RipMibGetInputData.TableId = RIP_BASE_ENTRY;
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_RIP,
								&RipMibGetInputData,
								sizeof(RIP_MIB_GET_INPUT_DATA),
								&RipBep,
								&BeSize);
								
        if (rc == NO_ERROR && RipBep == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
        }
        								
		if (rc==NO_ERROR) {
			SetAsnInteger (&Beb->mripsapBaseRipOperState, RipBep->RIPOperState);
			MprAdminMIBBufferFree (RipBep);
			SapMibGetInputData.TableId = SAP_BASE_ENTRY;
			rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_SAP,
									&SapMibGetInputData,
									sizeof(SAP_MIB_GET_INPUT_DATA),
									&SapBep,
									&BeSize);
			if (rc==NO_ERROR && SapBep) {
				SetAsnInteger (&Beb->mripsapBaseSapOperState, SapBep->SapOperState);
				MprAdminMIBBufferFree (SapBep);
				DbgTrace (DBG_RIPSAPBASE,
					("MRIPSAP-Base: Get request succeded.\n"));
				return MIB_S_SUCCESS;
			}
			else {
				*errorIndex = 1;
				DbgTrace (DBG_RIPSAPBASE,
					("MRIPSAP-Base: Get SapOperState failed with error %ld.\n", rc));
				return MIB_S_ENTRY_NOT_FOUND;
			}
		}
		else {
			*errorIndex = 0;
			DbgTrace (DBG_RIPSAPBASE,
				("MRIPSAP-Base: Get RipOperState failed with error %ld.\n", rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
	case MIB_ACTION_GETNEXT:
		DbgTrace (DBG_IPXBASE,
				("MRIPSAP-Base:Get called with GET_FIRST/GET_NEXT for scalar.\n"));
		return MIB_S_INVALID_PARAMETER;

	default:
		DbgTrace (DBG_RIPSAPBASE,
				("MRIPSAP-Base: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Beb
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripsapInterface group (1.3.6.1.4.1.311.1.9.2)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripIfEntry table (1.3.6.1.4.1.311.1.9.2.1.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mripIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ifb	((buf_mripIfEntry *)objectArray)
	PRIP_INTERFACE			Ifp;
	RIP_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = RIP_INTERFACE_TABLE;
	MibGetInputData.InterfaceIndex 
				= (ULONG)GetAsnInteger (&Ifb->mripIfIndex, ZERO_INTERFACE_INDEX);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
											Ifb->mripIfIndex.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_RIP,
									&MibGetInputData,
									sizeof(RIP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Ifb->mripIfIndex.asnType)
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_RIP,
									&MibGetInputData,
									sizeof(RIP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		else
			rc = MprAdminMIBEntryGetFirst(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_RIP,
									&MibGetInputData,
									sizeof(RIP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		
		break;
	default:
		DbgTrace (DBG_RIPINTERFACES,
				("MRIPSAP-mripIf:Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}

    if (rc == NO_ERROR && Ifp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }
	
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_RIPINTERFACES,
					("MRIPSAP-mripIf: Get(%d) request succeded for if %ld->%ld.\n",
					 actionId,
					MibGetInputData.InterfaceIndex,
					Ifp->InterfaceIndex));
		ForceAsnInteger (&Ifb->mripIfIndex, Ifp->InterfaceIndex);
		SetAsnInteger (&Ifb->mripIfAdminState, Ifp->RipIfInfo.AdminState);
		SetAsnInteger (&Ifb->mripIfOperState, Ifp->RipIfStats.RipIfOperState);
		SetAsnInteger (&Ifb->mripIfUpdateMode, Ifp->RipIfInfo.UpdateMode);
		SetAsnInteger (&Ifb->mripIfUpdateInterval, Ifp->RipIfInfo.PeriodicUpdateInterval);
		SetAsnInteger (&Ifb->mripIfAgeMultiplier, Ifp->RipIfInfo.AgeIntervalMultiplier);
		SetAsnInteger (&Ifb->mripIfSupply, Ifp->RipIfInfo.Supply);
		SetAsnInteger (&Ifb->mripIfListen, Ifp->RipIfInfo.Listen);
		SetAsnCounter (&Ifb->mripIfInPackets, Ifp->RipIfStats.RipIfInputPackets);
		SetAsnCounter (&Ifb->mripIfOutPackets, Ifp->RipIfStats.RipIfOutputPackets);
		MprAdminMIBBufferFree (Ifp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_RIPINTERFACES,
			("MRIPSAP-mripIf: End of table reached on GETNEXT request for if %ld.\n",
				MibGetInputData.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_RIPINTERFACES,
			("MRIPSAP-mripIf: Get request for if %ld failed with error %ld.\n", 
			MibGetInputData.InterfaceIndex, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Ifb
}

UINT
set_mripIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ifb	((sav_mripIfEntry *)objectArray)
	PRIP_INTERFACE			Ifp;
	RIP_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}
	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
											Ifb->mripIfIndex.asnType);
		MibGetInputData.TableId = RIP_INTERFACE_TABLE;
		MibGetInputData.InterfaceIndex
				=  (ULONG)GetAsnInteger (&Ifb->mripIfIndex, INVALID_INTERFACE_INDEX);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_RIP,
									&MibGetInputData,
									sizeof(RIP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
									
        if (rc == NO_ERROR && Ifp == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
        }
									
		if (rc==NO_ERROR) {
			Ifb->MibSetInputData.RipInterface = *Ifp;
			Ifb->MibSetInputData.RipInterface.RipIfInfo.AdminState
				= (ULONG)GetAsnInteger(&Ifb->mripIfAdminState,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.AdminState);
			Ifb->MibSetInputData.RipInterface.RipIfInfo.UpdateMode
				= (ULONG)GetAsnInteger(&Ifb->mripIfUpdateMode,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.UpdateMode);
			Ifb->MibSetInputData.RipInterface.RipIfInfo.PeriodicUpdateInterval
				= (ULONG)GetAsnInteger(&Ifb->mripIfUpdateInterval,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.PeriodicUpdateInterval);
			Ifb->MibSetInputData.RipInterface.RipIfInfo.AgeIntervalMultiplier
				= (ULONG)GetAsnInteger(&Ifb->mripIfAgeMultiplier,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.AgeIntervalMultiplier);
			Ifb->MibSetInputData.RipInterface.RipIfInfo.Supply
				= (ULONG)GetAsnInteger(&Ifb->mripIfSupply,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.Supply);
			Ifb->MibSetInputData.RipInterface.RipIfInfo.Listen
				= (ULONG)GetAsnInteger(&Ifb->mripIfListen,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.Listen);
			MprAdminMIBBufferFree (Ifp);
			DbgTrace (DBG_RIPINTERFACES, ("MRIPSAP-mripIf: Validated if %ld\n",
						MibGetInputData.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_RIPINTERFACES,
				("MRIPSAP-mripIf: Validate failed on if %ld with error %ld\n",
				MibGetInputData.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
	case MIB_ACTION_SET:
		rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_RIP,
								&Ifb->MibSetInputData,
								sizeof(RIP_MIB_SET_INPUT_DATA));
		if (rc==NO_ERROR) {
			DbgTrace (DBG_RIPINTERFACES, ("MRIPSAP-mripIf: Set succeded on if %ld\n",
					Ifb->MibSetInputData.RipInterface.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_RIPINTERFACES,
				("MRIPSAP-mripIf: Set failed on if %ld with error %ld\n",
					Ifb->MibSetInputData.RipInterface.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_RIPINTERFACES,
				("MMRIPSAP-mripIf: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Ifb
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// msapIfEntry table (1.3.6.1.4.1.311.1.9.2.2.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_msapIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ifb	((buf_msapIfEntry *)objectArray)
	PSAP_INTERFACE			Ifp;
	SAP_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = SAP_INTERFACE_TABLE;
	MibGetInputData.InterfaceIndex 
				= (ULONG)GetAsnInteger (&Ifb->msapIfIndex, ZERO_INTERFACE_INDEX);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
											Ifb->msapIfIndex.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_SAP,
									&MibGetInputData,
									sizeof(SAP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Ifb->msapIfIndex.asnType)
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_SAP,
									&MibGetInputData,
									sizeof(SAP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		else
			rc = MprAdminMIBEntryGetFirst(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_SAP,
									&MibGetInputData,
									sizeof(SAP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		
		break;
	default:
		DbgTrace (DBG_SAPINTERFACES,
				("MRIPSAP-msapIf:Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}

    if (rc == NO_ERROR && Ifp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }
	
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_SAPINTERFACES,
					("MRIPSAP-msapIf: Get(%d) request succeded for if %ld->%ld.\n",
					actionId,
					MibGetInputData.InterfaceIndex,
					Ifp->InterfaceIndex));
		ForceAsnInteger (&Ifb->msapIfIndex, Ifp->InterfaceIndex);
		SetAsnInteger (&Ifb->msapIfAdminState, Ifp->SapIfInfo.AdminState);
		SetAsnInteger (&Ifb->msapIfOperState, Ifp->SapIfStats.SapIfOperState);
		SetAsnInteger (&Ifb->msapIfUpdateMode, Ifp->SapIfInfo.UpdateMode);
		SetAsnInteger (&Ifb->msapIfUpdateInterval, Ifp->SapIfInfo.PeriodicUpdateInterval);
		SetAsnInteger (&Ifb->msapIfAgeMultiplier, Ifp->SapIfInfo.AgeIntervalMultiplier);
		SetAsnInteger (&Ifb->msapIfSupply, Ifp->SapIfInfo.Supply);
		SetAsnInteger (&Ifb->msapIfListen, Ifp->SapIfInfo.Listen);
		SetAsnInteger (&Ifb->msapIfGetNearestServerReply,
										Ifp->SapIfInfo.GetNearestServerReply);
		SetAsnCounter (&Ifb->msapIfInPackets, Ifp->SapIfStats.SapIfInputPackets);
		SetAsnCounter (&Ifb->msapIfOutPackets, Ifp->SapIfStats.SapIfOutputPackets);
		MprAdminMIBBufferFree (Ifp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_SAPINTERFACES,
			("MRIPSAP-msapIf: End of table reached on GETNEXT request for if %ld.\n",
				MibGetInputData.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_SAPINTERFACES,
			("MRIPSAP-msapIf: Get request for if %ld failed with error %ld.\n", 
			MibGetInputData.InterfaceIndex, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Ifb
}

UINT
set_msapIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ifb	((sav_msapIfEntry *)objectArray)
	PSAP_INTERFACE			Ifp;
	SAP_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}
	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
											Ifb->msapIfIndex.asnType);
		MibGetInputData.TableId = SAP_INTERFACE_TABLE;
		MibGetInputData.InterfaceIndex
				=  (ULONG)GetAsnInteger (&Ifb->msapIfIndex, INVALID_INTERFACE_INDEX);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_SAP,
									&MibGetInputData,
									sizeof(SAP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
									
        if (rc == NO_ERROR && Ifp == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
        }
        
		if (rc==NO_ERROR) {
			Ifb->MibSetInputData.SapInterface = *Ifp;
			Ifb->MibSetInputData.SapInterface.SapIfInfo.AdminState
				= (ULONG)GetAsnInteger(&Ifb->msapIfAdminState,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.AdminState);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.UpdateMode
				= (ULONG)GetAsnInteger(&Ifb->msapIfUpdateMode,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.UpdateMode);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.PeriodicUpdateInterval
				= (ULONG)GetAsnInteger(&Ifb->msapIfUpdateInterval,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.PeriodicUpdateInterval);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.AgeIntervalMultiplier
				= (ULONG)GetAsnInteger(&Ifb->msapIfAgeMultiplier,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.AgeIntervalMultiplier);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.Supply
				= (ULONG)GetAsnInteger(&Ifb->msapIfSupply,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.Supply);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.Listen
				= (ULONG)GetAsnInteger(&Ifb->msapIfListen,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.Listen);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.GetNearestServerReply
				= (ULONG)GetAsnInteger(&Ifb->msapIfGetNearestServerReply,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.GetNearestServerReply);
			MprAdminMIBBufferFree (Ifp);
			DbgTrace (DBG_SAPINTERFACES, ("MRIPSAP-msapIf: Validated if %ld\n",
						MibGetInputData.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_SAPINTERFACES,
				("MRIPSAP-msapIf: Validate failed on if %ld with error %ld\n",
				MibGetInputData.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
	case MIB_ACTION_SET:
		rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_SAP,
								&Ifb->MibSetInputData,
								sizeof(SAP_MIB_SET_INPUT_DATA));
		if (rc==NO_ERROR) {
			DbgTrace (DBG_SAPINTERFACES, ("MRIPSAP-msapIf: Set succeded on if %ld\n",
					Ifb->MibSetInputData.SapInterface.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_SAPINTERFACES,
				("MRIPSAP-msapIf: Set failed on if %ld with error %ld\n",
					Ifb->MibSetInputData.SapInterface.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_SAPINTERFACES,
				("MMRIPSAP-msapIf: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Ifb
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ipx\snmp\nipxf.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nipxf.c

Abstract:

    Novell-ipx instrumentation callbacks.

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/

#include "precomp.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxSystem group (1.3.6.1.4.1.23.2.5.1)                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxBasicSysEntry table (1.3.6.1.4.1.23.2.5.1.1.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxBasicSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Bseb	((buf_nipxBasicSysEntry *)objectArray)
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	PIPXMIB_BASE			Bep;
	DWORD					rc;
	ULONG					BeSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Bseb->nipxBasicSysInstance,NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXBASICSYSENTRY, ("NIPX-BSE: ipxBasicSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	switch (actionId) {
	case MIB_ACTION_GETNEXT:
		if (!Bseb->nipxBasicSysInstance.asnType) {
			ForceAsnInteger (&Bseb->nipxBasicSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
			rc = MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_NIPXBASICSYSENTRY,
				("NIPX-BSE: End of table reached on GETFIRST/GETNEXT request for instance %ld.\n",
									GetAsnInteger (&Bseb->nipxBasicSysInstance,NIPX_INVALID_SYS_INSTANCE)));
			rc = MIB_S_NO_MORE_ENTRIES;
			break;
		}

	case MIB_ACTION_GET:
		MibGetInputData.TableId = IPX_BASE_ENTRY;
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&Bep,
								&BeSize);
		if (rc==NO_ERROR) {
			SetAsnInteger (&Bseb->nipxBasicSysExistState, NIPX_STATE_ON);
			SetAsnOctetString (&Bseb->nipxBasicSysNetNumber, Bseb->NetNumberVal,
						Bep->PrimaryNetNumber, sizeof (Bseb->NetNumberVal));
			SetAsnOctetString (&Bseb->nipxBasicSysNode, Bseb->NodeVal,
						Bep->Node, sizeof (Bseb->NodeVal));
			SetAsnDispString (&Bseb->nipxBasicSysName, Bseb->NameVal,
						Bep->SysName, sizeof (Bseb->NameVal));
			SetAsnCounter (&Bseb->nipxBasicSysInReceives, 0);
			SetAsnCounter (&Bseb->nipxBasicSysInHdrErrors, 0);
			SetAsnCounter (&Bseb->nipxBasicSysInUnknownSockets, 0);
			SetAsnCounter (&Bseb->nipxBasicSysInDiscards, 0);
			SetAsnCounter (&Bseb->nipxBasicSysInBadChecksums, 0);
			SetAsnCounter (&Bseb->nipxBasicSysInDelivers, 0);
			SetAsnCounter (&Bseb->nipxBasicSysNoRoutes, 0);
			SetAsnCounter (&Bseb->nipxBasicSysOutRequests, 0);
			SetAsnCounter (&Bseb->nipxBasicSysOutMalformedRequests, 0);
			SetAsnCounter (&Bseb->nipxBasicSysOutDiscards, 0);
			SetAsnCounter (&Bseb->nipxBasicSysOutPackets, 0);
			SetAsnCounter (&Bseb->nipxBasicSysConfigSockets, 0);
			SetAsnCounter (&Bseb->nipxBasicSysOpenSocketFails, 0);
			MprAdminMIBBufferFree (Bep);
			DbgTrace (DBG_NIPXBASICSYSENTRY, ("NIPX-BSE: Get request succeded.\n"));
			rc = MIB_S_SUCCESS;
		}
		else {
		    // 
		    // pmay.  Added this so mib walk wouldn't fail with
		    // GENERR.
		    //
		    rc = MIB_S_NO_MORE_ENTRIES;
		}
		break;
	default:
		DbgTrace (DBG_NIPXBASICSYSENTRY, 
				("NIPX-BSE: Get called with unsupported action code %d.\n",
				actionId));
		rc = MIB_S_INVALID_PARAMETER;
		break;
	}

	return rc;
#undef Bseb
}


/*
	All values in nipxBasicSysEntry are implemented as read-only
UINT
set_nipxBasicSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
	return MIB_S_ENTRY_NOT_FOUND;
}
*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxAdvSysEntry table (1.3.6.1.4.1.23.2.5.1.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxAdvSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Aseb	((buf_nipxAdvSysEntry *)objectArray)
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	PIPXMIB_BASE			Bep;
	DWORD					rc;
	ULONG					BeSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Aseb->nipxAdvSysInstance,NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXADVSYSENTRY, ("NIPX-ASE: nipxAdvSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	switch (actionId) {
	case MIB_ACTION_GETNEXT:
		if (!Aseb->nipxAdvSysInstance.asnType) {
			ForceAsnInteger (&Aseb->nipxAdvSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		}
		else {
			DbgTrace (DBG_NIPXADVSYSENTRY,
				("NIPX-ASE: End of table reached on GETFIRST/GETNEXT request for instance %ld.\n",
									GetAsnInteger (&Aseb->nipxAdvSysInstance,NIPX_INVALID_SYS_INSTANCE)));
			rc = MIB_S_NO_MORE_ENTRIES;
			break;
		}

	case MIB_ACTION_GET:
		MibGetInputData.TableId = IPX_BASE_ENTRY;
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&Bep,
								&BeSize);
		if (rc == NO_ERROR && Bep != NULL) {
			SetAsnInteger (&Aseb->nipxAdvSysMaxPathSplits, Bep->MaxPathSplits);
			SetAsnInteger (&Aseb->nipxAdvSysMaxHops, 16);
			SetAsnCounter (&Aseb->nipxAdvSysInTooManyHops, 0);
			SetAsnCounter (&Aseb->nipxAdvSysInFiltered, 0);
			SetAsnCounter (&Aseb->nipxAdvSysInCompressDiscards, 0);
			SetAsnCounter (&Aseb->nipxAdvSysNETBIOSPackets, 0);
			SetAsnCounter (&Aseb->nipxAdvSysForwPackets, 0);
			SetAsnCounter (&Aseb->nipxAdvSysOutFiltered, 0);
			SetAsnCounter (&Aseb->nipxAdvSysOutCompressDiscards, 0);
			SetAsnCounter (&Aseb->nipxAdvSysCircCount, Bep->IfCount);
			SetAsnCounter (&Aseb->nipxAdvSysDestCount, Bep->DestCount);
			SetAsnCounter (&Aseb->nipxAdvSysServCount, Bep->ServCount);
			MprAdminMIBBufferFree (Bep);
			DbgTrace (DBG_NIPXADVSYSENTRY, ("NIPX-ASE: Get request succeded.\n"));
		}
		else {
		    // 
		    // pmay.  Added this so mib walk wouldn't fail with
		    // GENERR.
		    //
		    rc = MIB_S_NO_MORE_ENTRIES;
		}
		break;
	default:
		DbgTrace (DBG_NIPXADVSYSENTRY, 
				("NIPX-ASE: Get called with unsupported action code %d.\n",
				actionId));
		rc = MIB_S_INVALID_PARAMETER;
		break;
	}
	return rc;
#undef Aseb
}

/*
	All values in nipxAdvSysEntry are implemented as read-only
UINT
set_nipxAdvSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
	return MIB_S_ENTRY_NOT_FOUND;
}
*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircuit group (1.3.6.1.4.1.23.2.5.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircEntry table (1.3.6.1.4.1.23.2.5.2.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxCircEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ceb	((buf_nipxCircEntry *)objectArray)
	PIPX_INTERFACE			Ifp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_INTERFACE_TABLE;
	if (GetAsnInteger (&Ceb->nipxCircSysInstance, NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXCIRCENTRY, ("NIPX-Circ: nipxCircSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex 
				= (ULONG)GetAsnInteger (&Ceb->nipxCircIndex, ZERO_INTERFACE_INDEX);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
							Ceb->nipxCircSysInstance.asnType
							&&Ceb->nipxCircIndex.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Ceb->nipxCircIndex.asnType) {
			ASSERTMSG ("Second index is present but first is not ",
								Ceb->nipxCircSysInstance.asnType);
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		}
		else
			rc = MprAdminMIBEntryGetFirst(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		
		break;
	default:
		DbgTrace (DBG_NIPXCIRCENTRY,
				("NIPX-Circ: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}

    if (rc == NO_ERROR && Ifp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }
	
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_NIPXCIRCENTRY, ("NIPX-Circ: Get(%d) request succeded for if %ld->%ld.\n",
				actionId,
				MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex,
				Ifp->InterfaceIndex));
		ForceAsnInteger (&Ceb->nipxCircSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		ForceAsnInteger (&Ceb->nipxCircIndex, Ifp->InterfaceIndex);
		SetAsnInteger (&Ceb->nipxCircExistState, NIPX_STATE_ON);
		SetAsnInteger (&Ceb->nipxCircOperState, Ifp->IfStats.IfOperState);
		SetAsnInteger (&Ceb->nipxCircIfIndex, Ifp->AdapterIndex);
		SetAsnDispString (&Ceb->nipxCircName, Ceb->NameVal,
						Ifp->InterfaceName, sizeof (Ceb->NameVal));
		switch (Ifp->InterfaceType) {
		case IF_TYPE_OTHER:
		case IF_TYPE_INTERNAL:
			SetAsnInteger (&Ceb->nipxCircType, NIPX_CIRCTYPE_OTHER);
			SetAsnDispString (&Ceb->nipxCircDialName, Ceb->DialNameVal,
						"", sizeof (Ceb->DialNameVal));
			break;
		case IF_TYPE_LAN:
			SetAsnInteger (&Ceb->nipxCircType, NIPX_CIRCTYPE_BCAST);
			SetAsnDispString (&Ceb->nipxCircDialName, Ceb->DialNameVal,
						"", sizeof (Ceb->DialNameVal));
			SetAsnDispString (&Ceb->nipxCircNeighRouterName, Ceb->NeighRouterNameVal,
						"", sizeof (Ceb->NeighRouterNameVal));
			break;
		case IF_TYPE_WAN_ROUTER:
		case IF_TYPE_PERSONAL_WAN_ROUTER:
			SetAsnInteger (&Ceb->nipxCircType, NIPX_CIRCTYPE_DYNAMIC);
			SetAsnDispString (&Ceb->nipxCircDialName, Ceb->DialNameVal,
						Ifp->InterfaceName, sizeof (Ceb->DialNameVal));
			SetAsnDispString (&Ceb->nipxCircNeighRouterName, Ceb->NeighRouterNameVal,
						Ifp->InterfaceName, sizeof (Ceb->NeighRouterNameVal));
						
			break;

		case IF_TYPE_WAN_WORKSTATION:
		case IF_TYPE_ROUTER_WORKSTATION_DIALOUT:
		case IF_TYPE_STANDALONE_WORKSTATION_DIALOUT:
			SetAsnInteger (&Ceb->nipxCircType, NIPX_CIRCTYPE_WANWS);
			SetAsnDispString (&Ceb->nipxCircDialName, Ceb->DialNameVal,
						Ifp->InterfaceName, sizeof (Ceb->DialNameVal));
			SetAsnDispString (&Ceb->nipxCircNeighRouterName, Ceb->NeighRouterNameVal,
						"", sizeof (Ceb->NeighRouterNameVal));
			break;
		}

		SetAsnInteger (&Ceb->nipxCircLocalMaxPacketSize, Ifp->IfStats.MaxPacketSize);
		SetAsnInteger (&Ceb->nipxCircCompressState, NIPX_STATE_OFF);
		SetAsnInteger (&Ceb->nipxCircCompressSlots, 16);
		SetAsnInteger (&Ceb->nipxCircStaticStatus, NIPX_STATIC_STATUS_UNKNOWN);
		SetAsnCounter (&Ceb->nipxCircCompressedSent, 0);
		SetAsnCounter (&Ceb->nipxCircCompressedInitSent, 0);
		SetAsnCounter (&Ceb->nipxCircCompressedRejectsSent, 0);
		SetAsnCounter (&Ceb->nipxCircUncompressedSent, 0);
		SetAsnCounter (&Ceb->nipxCircCompressedReceived, 0);
		SetAsnCounter (&Ceb->nipxCircCompressedInitReceived, 0);
		SetAsnCounter (&Ceb->nipxCircCompressedRejectsReceived, 0);
		SetAsnCounter (&Ceb->nipxCircUncompressedReceived, 0);
		SetAsnMediaType (&Ceb->nipxCircMediaType, Ceb->MediaTypeVal, Ifp->MediaType);
		SetAsnOctetString (&Ceb->nipxCircNetNumber, Ceb->NetNumberVal,
						Ifp->NetNumber, sizeof (Ceb->NetNumberVal));
		SetAsnCounter (&Ceb->nipxCircStateChanges, 0);
		SetAsnCounter (&Ceb->nipxCircInitFails, 0);
		SetAsnInteger (&Ceb->nipxCircDelay, Ifp->Delay);
		SetAsnInteger (&Ceb->nipxCircThroughput, Ifp->Throughput);
		SetAsnOctetString (&Ceb->nipxCircNeighInternalNetNum, Ceb->NeighInternalNetNumVal,
						ZERO_NET_NUM, sizeof (Ceb->NeighInternalNetNumVal));
					
		MprAdminMIBBufferFree (Ifp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_NIPXCIRCENTRY,
			("NIPX-Circ: End of table reached on GETFIRST/GETNEXT request for if %ld.\n",
								MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 1;
		DbgTrace (DBG_NIPXCIRCENTRY,
			("NIPX-Circ: Get request for if %ld failed with error %ld.\n", 
			MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Ceb
}

UINT
set_nipxCircEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ceb	((sav_nipxCircEntry *)objectArray)
	PIPX_INTERFACE			Ifp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Ceb->nipxCircSysInstance, NIPX_INVALID_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXCIRCENTRY, ("NIPX-Circ: nipxCircSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	
	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
							Ceb->nipxCircSysInstance.asnType
							&&Ceb->nipxCircIndex.asnType);
		MibGetInputData.TableId = IPX_INTERFACE_TABLE;
		MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex
				=  (ULONG)GetAsnInteger (&Ceb->nipxCircIndex, INVALID_INTERFACE_INDEX);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		if (rc==NO_ERROR) {
			Ceb->MibSetInputData.MibRow.Interface = *Ifp;
			MprAdminMIBBufferFree (Ifp);
			if (Ceb->nipxCircOperState.asnType) {
				switch (GetAsnInteger(&Ceb->nipxCircOperState, OPER_STATE_SLEEPING)) {
				case OPER_STATE_DOWN:
					Ceb->MibSetInputData.MibRow.Interface.AdminState = ADMIN_STATE_DISABLED;
					break;
				case OPER_STATE_UP:
					Ceb->MibSetInputData.MibRow.Interface.AdminState = ADMIN_STATE_ENABLED;
					break;
				default:
					DbgTrace (DBG_NIPXCIRCENTRY,
						("NIPX-Circ: Validate failed: invalid oper state: %d.\n",
						GetAsnInteger(&Ceb->nipxCircOperState, OPER_STATE_SLEEPING)));
					return MIB_S_INVALID_PARAMETER;
				}
			}
			DbgTrace (DBG_NIPXCIRCENTRY, ("NIPX-Circ: Validated if %ld.\n",
						MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_NIPXCIRCENTRY,
				("NIPX-Circ: Validate failed on if %ld with error %ld.\n",
				MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
	case MIB_ACTION_SET:
		rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Ceb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
		if (rc==NO_ERROR) {
			DbgTrace (DBG_NIPXCIRCENTRY, ("NIPX-Circ: Set succeded on if %ld\n",
					Ceb->MibSetInputData.MibRow.Interface.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_NIPXCIRCENTRY,
				("NIPX-Circ: Set failed on if %ld with error %ld\n",
					Ceb->MibSetInputData.MibRow.Interface.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_NIPXCIRCENTRY,
				("NIPX-Circ: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Ceb
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxForwarding group (1.3.6.1.4.1.23.2.5.3)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestEntry table (1.3.6.1.4.1.23.2.5.3.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxDestEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Deb	((buf_nipxDestEntry *)objectArray)
	PIPX_ROUTE				Rtp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					RtSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Deb->nipxDestSysInstance, NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXDESTENTRY, ("NIPX-Dest: nipxDestSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_DEST_TABLE;
	GetAsnOctetString (MibGetInputData.MibIndex.RoutingTableIndex.Network,
				&Deb->nipxDestNetNum,
				sizeof (MibGetInputData.MibIndex.RoutingTableIndex.Network),
				ZERO_NET_NUM);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
						Deb->nipxDestSysInstance.asnType
						&&Deb->nipxDestNetNum.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&Rtp,
								&RtSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Deb->nipxDestNetNum.asnType) {
			ASSERTMSG ("Second index is present but first is not ",
								Deb->nipxDestSysInstance.asnType);
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Rtp,
										&RtSize);
			if (rc==NO_ERROR) {
				FreeAsnString (&Deb->nipxDestNetNum);
			}
		}
		else
			rc = MprAdminMIBEntryGetFirst (g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Rtp,
										&RtSize);
		break;
	default:
		DbgTrace (DBG_NIPXDESTENTRY,
			("NIPX-Dest: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_NIPXDESTENTRY,
				("NIPX-Dest: Get(%d) request succeded for net"
					" %.2x%.2x%.2x%.2x -> %.2x%.2x%.2x%.2x.\n", actionId,
				MibGetInputData.MibIndex.RoutingTableIndex.Network[0],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[1],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[2],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[3],
				Rtp->Network[0],
				Rtp->Network[1],
				Rtp->Network[2],
				Rtp->Network[3]));
		ForceAsnInteger (&Deb->nipxDestSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		ForceAsnOctetString (&Deb->nipxDestNetNum, Deb->NetNumVal,
							Rtp->Network, sizeof (Deb->NetNumVal));
        switch (Rtp->Protocol) {
        case IPX_PROTOCOL_LOCAL:
	    	SetAsnInteger (&Deb->nipxDestProtocol, 2);
            break;
        case IPX_PROTOCOL_STATIC:
    		SetAsnInteger (&Deb->nipxDestProtocol, 5);
            break;
        case IPX_PROTOCOL_RIP:
		    SetAsnInteger (&Deb->nipxDestProtocol, 3);
            break;
        case IPX_PROTOCOL_NLSP:
		    SetAsnInteger (&Deb->nipxDestProtocol, 4);
            break;
        default:
    		SetAsnInteger (&Deb->nipxDestProtocol, 1);  // other
            break;
        }
		SetAsnInteger (&Deb->nipxDestTicks, Rtp->TickCount);          
		SetAsnInteger (&Deb->nipxDestHopCount, Rtp->HopCount);
		SetAsnInteger (&Deb->nipxDestNextHopCircIndex, Rtp->InterfaceIndex);
		SetAsnOctetString (&Deb->nipxDestNextHopNICAddress, Deb->NextHopNICAddressVal,
							Rtp->NextHopMacAddress, sizeof (Deb->NextHopNICAddressVal));
		SetAsnOctetString (&Deb->nipxDestNextHopNetNum, Deb->NextHopNetNumVal,
							ZERO_NET_NUM, sizeof (Deb->NextHopNetNumVal));
		MprAdminMIBBufferFree (Rtp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_NIPXDESTENTRY,
				("NIPX-Dest: End of table reached on GETFIRST/GETNEXT request"
					" for network %.2x%.2x%.2x%.2x.\n",
				MibGetInputData.MibIndex.RoutingTableIndex.Network[0],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[1],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[2],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[3]));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 1;
		DbgTrace (DBG_NIPXDESTENTRY,
				("NIPX-Dest: Get request for network %.2x%.2x%.2x%.2x"
					" failed with error %ld.\n", 
				MibGetInputData.MibIndex.RoutingTableIndex.Network[0],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[1],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[2],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[3], rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Deb
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxStaticRouteEntry table (1.3.6.1.4.1.23.2.5.3.1.2)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Sreb	((buf_nipxStaticRouteEntry *)objectArray)
	PIPX_ROUTE				Rtp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					RtSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Sreb->nipxStaticRouteSysInstance, NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSTATICRTENTRY,
					("NIPX-staticRoutes: nipxStaticRouteSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_STATIC_ROUTE_TABLE;
	MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex
		= (ULONG)GetAsnInteger (&Sreb->nipxStaticRouteCircIndex, ZERO_INTERFACE_INDEX);
	GetAsnOctetString (
		MibGetInputData.MibIndex.StaticRoutesTableIndex.Network,
		&Sreb->nipxStaticRouteNetNum,
		sizeof (MibGetInputData.MibIndex.StaticRoutesTableIndex.Network),
		ZERO_NET_NUM);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
							Sreb->nipxStaticRouteSysInstance.asnType
							&&Sreb->nipxStaticRouteCircIndex.asnType
							&&Sreb->nipxStaticRouteNetNum.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Rtp,
									&RtSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Sreb->nipxStaticRouteCircIndex.asnType) {
			ASSERTMSG ("Second index is present but first is not ",
								Sreb->nipxStaticRouteSysInstance.asnType);
			if (!Sreb->nipxStaticRouteNetNum.asnType) {
				rc = MprAdminMIBEntryGet(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Rtp,
											&RtSize);
				if (rc==NO_ERROR)
					break;
			}

			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Rtp,
										&RtSize);
			if (rc==NO_ERROR) {
				if (Sreb->nipxStaticRouteNetNum.asnType) {
					FreeAsnString (&Sreb->nipxStaticRouteNetNum);
				}
			}
		}
		else {
			ASSERTMSG ("Third index is present but second is not ",
								!Sreb->nipxStaticRouteNetNum.asnType);
			rc = MprAdminMIBEntryGetFirst (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&Rtp,
								&RtSize);
		}
		break;
	default:
		DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}

    if (rc == NO_ERROR && Rtp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }

	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Get(%d) request succeded for net"
					" %.2x%.2x%.2x%.2x -> %.2x%.2x%.2x%.2x on if %ld\n", actionId,
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				Rtp->Network[0],
				Rtp->Network[1],
				Rtp->Network[2],
				Rtp->Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
		ForceAsnInteger (&Sreb->nipxStaticRouteSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		ForceAsnInteger (&Sreb->nipxStaticRouteCircIndex, Rtp->InterfaceIndex);
		ForceAsnOctetString (&Sreb->nipxStaticRouteNetNum, Sreb->NetNumVal,
							Rtp->Network, sizeof (Sreb->NetNumVal));
		SetAsnInteger (&Sreb->nipxStaticRouteExistState, NIPX_STATE_ON);
		SetAsnInteger (&Sreb->nipxStaticRouteTicks, Rtp->TickCount);          
		SetAsnInteger (&Sreb->nipxStaticRouteHopCount, Rtp->HopCount);
		MprAdminMIBBufferFree (Rtp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
										actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: End of table reached on GETFIRST/GETNEXT request for network"
					" %.2x%.2x%.2x%.2x on if %ld.\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 1;
		DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Get request for network %.2x%.2x%.2x%.2x."
					" on if %ld failed with error %ld.\n", 
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Sreb
}

UINT
set_nipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Sreb	((sav_nipxStaticRouteEntry *)objectArray)
	PIPX_ROUTE				Rtp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					RtSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Sreb->nipxStaticRouteSysInstance, NIPX_INVALID_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSTATICRTENTRY,
					("NIPX-staticRoutes: nipxStaticRouteSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
						Sreb->nipxStaticRouteCircIndex.asnType
						&&Sreb->nipxStaticRouteNetNum.asnType);
		MibGetInputData.TableId = IPX_STATIC_ROUTE_TABLE;
		MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex
			= (ULONG)GetAsnInteger (&Sreb->nipxStaticRouteCircIndex,INVALID_INTERFACE_INDEX);
		GetAsnOctetString (
			MibGetInputData.MibIndex.StaticRoutesTableIndex.Network,
			&Sreb->nipxStaticRouteNetNum,
			sizeof (MibGetInputData.MibIndex.StaticRoutesTableIndex.Network),
			INVALID_NET_NUM);
		Sreb->ActionFlag
			= (BOOLEAN)GetAsnInteger (&Sreb->nipxStaticRouteExistState,
			NIPX_STATE_NOACTION);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Rtp,
									&RtSize);
        if (rc == NO_ERROR && Rtp == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
			DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Validate failed"
					" for network %.2x.2x.2x.2x on if %ld with error %ld\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex,rc));
			return MIB_S_ENTRY_NOT_FOUND;
        }
		if (rc==NO_ERROR) {
			Sreb->MibSetInputData.MibRow.Route = *Rtp;
			if (Sreb->ActionFlag == NIPX_STATE_ON)
				Sreb->ActionFlag = NIPX_STATE_NOACTION;
			MprAdminMIBBufferFree (Rtp);
			DbgTrace (DBG_NIPXSTATICRTENTRY,
					("NIPX-staticRoutes: Validated"
					" network %.2x.2x.2x.2x on if %ld\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
		}
		else if (Sreb->ActionFlag == MIPX_EXIST_STATE_CREATED) {
			DbgTrace (DBG_NIPXSTATICRTENTRY,
					("NIPX-staticRoutes: Prepared to add"
					" network %.2x.2x.2x.2x on if %ld\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
			Sreb->MibSetInputData.MibRow.Route.InterfaceIndex
				= (ULONG)GetAsnInteger (&Sreb->nipxStaticRouteCircIndex,
					INVALID_INTERFACE_INDEX);
			GetAsnOctetString (Sreb->MibSetInputData.MibRow.Route.Network,
					&Sreb->nipxStaticRouteNetNum,
					sizeof (Sreb->MibSetInputData.MibRow.Route.Network),
					NULL);
			Sreb->MibSetInputData.MibRow.Route.Protocol = IPX_PROTOCOL_STATIC;
			Sreb->MibSetInputData.MibRow.Route.Flags = 0;
			Sreb->MibSetInputData.MibRow.Route.TickCount = MAXSHORT;
			Sreb->MibSetInputData.MibRow.Route.HopCount = 15;
			memset (Sreb->MibSetInputData.MibRow.Route.NextHopMacAddress,
					0xFF,
					sizeof (Sreb->MibSetInputData.MibRow.Route.NextHopMacAddress));
		}
		else {
			DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Validate failed"
					" for network %.2x.2x.2x.2x on if %ld with error %ld\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex,rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
		Sreb->MibSetInputData.MibRow.Route.TickCount
			= (USHORT)GetAsnInteger (&Sreb->nipxStaticRouteTicks,
				Sreb->MibSetInputData.MibRow.Route.TickCount);
		Sreb->MibSetInputData.MibRow.Route.HopCount
			= (USHORT)GetAsnInteger (&Sreb->nipxStaticRouteHopCount,
				Sreb->MibSetInputData.MibRow.Route.HopCount);
		return MIB_S_SUCCESS;
	case MIB_ACTION_SET:
		switch (Sreb->ActionFlag) {
		case MIPX_EXIST_STATE_NOACTION:
			rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sreb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case MIPX_EXIST_STATE_DELETED:
			rc = MprAdminMIBEntryDelete (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sreb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case MIPX_EXIST_STATE_CREATED:
			rc = MprAdminMIBEntryCreate (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sreb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		}
		if (rc==NO_ERROR) {
			DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Set succeded for"
					" network %.2x.2x.2x.2x on if %ld\n",
				Sreb->MibSetInputData.MibRow.Route.Network[0],
				Sreb->MibSetInputData.MibRow.Route.Network[1],
				Sreb->MibSetInputData.MibRow.Route.Network[2],
				Sreb->MibSetInputData.MibRow.Route.Network[3],
				Sreb->MibSetInputData.MibRow.Route.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Set failed for"
					" network %.2x.2x.2x.2x on if %ld with error %ld\n",
				Sreb->MibSetInputData.MibRow.Route.Network[0],
				Sreb->MibSetInputData.MibRow.Route.Network[1],
				Sreb->MibSetInputData.MibRow.Route.Network[2],
				Sreb->MibSetInputData.MibRow.Route.Network[3],
				Sreb->MibSetInputData.MibRow.Route.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Sreb
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServices group (1.3.6.1.4.1.23.2.5.4)                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServEntry table (1.3.6.1.4.1.23.2.5.4.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Seb	((buf_nipxServEntry *)objectArray)
	PIPX_SERVICE			Svp, SvpCur;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;
	INT						lenPrev, lenNext, lenCur;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Seb->nipxServSysInstance, NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSERVENTRY, ("NIPX-Serv: nipxServSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_SERV_TABLE;
	MibGetInputData.MibIndex.ServicesTableIndex.ServiceType
		= GetAsnServType (&Seb->nipxServType, ZERO_SERVER_TYPE);
	GetAsnDispString (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
			&Seb->nipxServName, ZERO_SERVER_NAME);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
					Seb->nipxServSysInstance.asnType
					&&Seb->nipxServType.asnType
					&& Seb->nipxServName.asnType);
			
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Seb->nipxServType.asnType) {
			ASSERTMSG ("Second index is present but first is not ",
								Seb->nipxServSysInstance.asnType);

			if (!Seb->nipxServName.asnType) {
				rc = MprAdminMIBEntryGet(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
				if (rc==NO_ERROR) {
					FreeAsnString (&Seb->nipxServType);
					break;
				}
			}
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
			if (rc==NO_ERROR) {
				FreeAsnString (&Seb->nipxServType);
				if (Seb->nipxServName.asnType) {
					FreeAsnString (&Seb->nipxServName);
				}
			}
		}
		else {
			ASSERTMSG ("Third index is present but second is not ",
									!Seb->nipxServName.asnType);
			rc = MprAdminMIBEntryGetFirst(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
		}
		break;
	default:
		DbgTrace (DBG_NIPXSERVENTRY,
			("NIPX-Serv: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_NIPXSERVENTRY,
				("NIPX-Serv: Get(%d) request succeded for service"
					" %.4x-%.48s -> %.4x-%.48s.\n", actionId,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
				Svp->Server.Type, Svp->Server.Name));
		ForceAsnInteger (&Seb->nipxServSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		ForceAsnServType (&Seb->nipxServType, Seb->TypeVal, Svp->Server.Type);
		ForceAsnDispString (&Seb->nipxServName, Seb->NameVal,
					Svp->Server.Name, sizeof (Seb->NameVal));
        switch (Svp->Protocol) {
        case IPX_PROTOCOL_LOCAL:
	    	SetAsnInteger (&Seb->nipxServProtocol, 2);
            break;
        case IPX_PROTOCOL_STATIC:
    		SetAsnInteger (&Seb->nipxServProtocol, 5);
            break;
        case IPX_PROTOCOL_SAP:
		    SetAsnInteger (&Seb->nipxServProtocol, 6);
            break;
        case IPX_PROTOCOL_NLSP:
		    SetAsnInteger (&Seb->nipxServProtocol, 4);
            break;
        default:
    		SetAsnInteger (&Seb->nipxServProtocol, 1);  // other
            break;
        }
		SetAsnOctetString (&Seb->nipxServNetNum, Seb->NetNumVal,
					Svp->Server.Network, sizeof (Seb->NetNumVal));
		SetAsnOctetString (&Seb->nipxServNode, Seb->NodeVal,
					Svp->Server.Node, sizeof (Seb->NodeVal));
		SetAsnOctetString (&Seb->nipxServSocket, Seb->SocketVal,
					Svp->Server.Socket, sizeof (Seb->SocketVal));
		SetAsnInteger (&Seb->nipxServHopCount, Svp->Server.HopCount);
		MprAdminMIBBufferFree (Svp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_NIPXSERVENTRY,
				("NIPX-Serv: End of table reached on GETFIRST/GETNEXT request"
					" for service %.4x-%.48s.\n",
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceName));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSERVENTRY,
				("NIPX-Serv: Get request for service %.4x-%.48s"
					" failed with error %ld.\n", 
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceName, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Seb
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestServEntry table (1.3.6.1.4.1.23.2.5.4.2.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxDestServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
	switch (actionId) {
	case MIB_ACTION_GET:
		return MIB_S_ENTRY_NOT_FOUND;
	case MIB_ACTION_GETNEXT:
		return MIB_S_NO_MORE_ENTRIES;
	default:
		return MIB_S_INVALID_PARAMETER;
	}
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxStaticServEntry table (1.3.6.1.4.1.23.2.5.4.3.1)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Sseb	((buf_nipxStaticServEntry *)objectArray)
	PIPX_SERVICE			Svp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Sseb->nipxStaticServSysInstance, NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSTATICSERVENTRY, ("NIPX-StaticServ: nipxStaticServSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_STATIC_SERV_TABLE;
	MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex
		= (ULONG)GetAsnInteger (&Sseb->nipxStaticServCircIndex,
			ZERO_INTERFACE_INDEX);
	MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType
		= GetAsnServType (&Sseb->nipxStaticServType, ZERO_SERVER_TYPE);
	GetAsnDispString (
		MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
		&Sseb->nipxStaticServName, ZERO_SERVER_NAME);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
							Sseb->nipxStaticServSysInstance.asnType
							&&Sseb->nipxStaticServCircIndex.asnType
							&&Sseb->nipxStaticServType.asnType
							&&Sseb->nipxStaticServName.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Sseb->nipxStaticServCircIndex.asnType) {
			if (!Sseb->nipxStaticServType.asnType
					|| !Sseb->nipxStaticServName.asnType) {
				rc = MprAdminMIBEntryGet(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
				if (rc==NO_ERROR) {
					if (Sseb->nipxStaticServType.asnType) {
						FreeAsnString (&Sseb->nipxStaticServType);
					}
					if (Sseb->nipxStaticServName.asnType) {
						FreeAsnString (&Sseb->nipxStaticServName);
					}
					break;
				}
			}
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Svp,
										&SvSize);
			if (rc==NO_ERROR) {
				if (Sseb->nipxStaticServType.asnType) {
					FreeAsnString (&Sseb->nipxStaticServType);
				}
				if (Sseb->nipxStaticServName.asnType) {
					FreeAsnString (&Sseb->nipxStaticServName);
				}
			}
		}
		else {
			ASSERTMSG ("Third or fourth indeces present but first is not ",
							!Sseb->nipxStaticServType.asnType
							&&!Sseb->nipxStaticServName.asnType);
			rc = MprAdminMIBEntryGetFirst (g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Svp,
										&SvSize);
		}
		break;
	default:
		DbgTrace (DBG_NIPXSTATICSERVENTRY,
			("NIPX-StaticServ: Get called with unsupported action code %d.\n",
			actionId));
		return MIB_S_INVALID_PARAMETER;
	}
    if (rc == NO_ERROR && Svp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_NIPXSTATICSERVENTRY,
			("NIPX-StaticServ: Get (%d) request succeded for service"
					" %.4x-%.48s -> %.4x-%.48s on if %ld.\n", actionId,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				Svp->Server.Type, Svp->Server.Name,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
		ForceAsnInteger (&Sseb->nipxStaticServSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		ForceAsnInteger (&Sseb->nipxStaticServCircIndex, Svp->InterfaceIndex);
		ForceAsnServType (&Sseb->nipxStaticServType, Sseb->TypeVal, Svp->Server.Type);
		ForceAsnDispString (&Sseb->nipxStaticServName, Sseb->NameVal,
							Svp->Server.Name, sizeof (Sseb->NameVal));
		SetAsnInteger (&Sseb->nipxStaticServExistState, NIPX_STATE_ON);
		SetAsnOctetString (&Sseb->nipxStaticServNetNum, Sseb->NetNumVal,
							Svp->Server.Network, sizeof (Sseb->NetNumVal));
		SetAsnOctetString (&Sseb->nipxStaticServNode, Sseb->NodeVal,
							Svp->Server.Node, sizeof (Sseb->NodeVal));
		SetAsnOctetString (&Sseb->nipxStaticServSocket, Sseb->SocketVal,
							Svp->Server.Socket, sizeof (Sseb->SocketVal));
		SetAsnInteger (&Sseb->nipxStaticServHopCount, Svp->Server.HopCount);
		MprAdminMIBBufferFree (Svp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
											actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_NIPXSTATICSERVENTRY,
			("NIPX-StaticServ: End of table reached on GETFIRST/GETNEXT request"
					" for service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSTATICSERVENTRY,
			("NIPX-StaticServ: Get request for service %.4x-%.48s"
					" on if %ld failed with error %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex,
				rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Sseb

}

UINT
set_nipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Sseb	((sav_nipxStaticServEntry *)objectArray)
	PIPX_SERVICE			Svp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}
	if (GetAsnInteger (&Sseb->nipxStaticServSysInstance, NIPX_INVALID_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSTATICSERVENTRY, ("NIPX-StaticServ: nipxStaticServSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}


	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
							Sseb->nipxStaticServSysInstance.asnType
							&&Sseb->nipxStaticServCircIndex.asnType
							&&Sseb->nipxStaticServType.asnType
							&&Sseb->nipxStaticServName.asnType);
		MibGetInputData.TableId = IPX_STATIC_SERV_TABLE;
		MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex
			= (ULONG)GetAsnInteger (&Sseb->nipxStaticServCircIndex,
				INVALID_INTERFACE_INDEX);
		MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType
			= GetAsnServType (&Sseb->nipxStaticServType, INVALID_SERVER_TYPE);
		GetAsnDispString (
			MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
			&Sseb->nipxStaticServName,
			INVALID_SERVER_NAME);
		Sseb->ActionFlag
			= (BOOLEAN)GetAsnInteger (&Sseb->nipxStaticServExistState,
			NIPX_STATE_NOACTION);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
        if (rc == NO_ERROR && Svp == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Validate failed"
					" for service %.4x-%.48s on if %ld with error %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex,
				rc));
			return MIB_S_ENTRY_NOT_FOUND;
        }			
		if (rc==NO_ERROR) {
			Sseb->MibSetInputData.MibRow.Service = *Svp;
			if (Sseb->ActionFlag == NIPX_STATE_ON)
				Sseb->ActionFlag = NIPX_STATE_NOACTION;
			MprAdminMIBBufferFree (Svp);
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Validated"
					" service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
		}
		else if (Sseb->ActionFlag == NIPX_STATE_ON) {
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Prepared to add"
					" service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
			Sseb->MibSetInputData.MibRow.Service.InterfaceIndex
				= (ULONG) GetAsnInteger (&Sseb->nipxStaticServCircIndex,
					INVALID_INTERFACE_INDEX);
			Sseb->MibSetInputData.MibRow.Service.Protocol = IPX_PROTOCOL_STATIC;
			Sseb->MibSetInputData.MibRow.Service.Server.Type
				= GetAsnServType (&Sseb->nipxStaticServType,
					INVALID_SERVER_TYPE);
			GetAsnDispString (
				Sseb->MibSetInputData.MibRow.Service.Server.Name,
				&Sseb->nipxStaticServName,
				INVALID_SERVER_NAME);
			memset (Sseb->MibSetInputData.MibRow.Service.Server.Network, 0,
					sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Network));
			memset (Sseb->MibSetInputData.MibRow.Service.Server.Node, 0,
					sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Node));
			memset (Sseb->MibSetInputData.MibRow.Service.Server.Socket, 0,
					sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Socket));
			Sseb->MibSetInputData.MibRow.Service.Server.HopCount = 15;
		}
		else {
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Validate failed"
					" for service %.4x-%.48s on if %ld with error %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex,
				rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
		GetAsnOctetString (Sseb->MibSetInputData.MibRow.Service.Server.Network,
			&Sseb->nipxStaticServNetNum,
			sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Network),
			NULL);
		GetAsnOctetString (Sseb->MibSetInputData.MibRow.Service.Server.Node,
			&Sseb->nipxStaticServNode,
			sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Node),
			NULL);
		GetAsnOctetString (Sseb->MibSetInputData.MibRow.Service.Server.Socket,
			&Sseb->nipxStaticServSocket,
			sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Socket),
			NULL);
		Sseb->MibSetInputData.MibRow.Service.Server.HopCount =
			(USHORT)GetAsnInteger (&Sseb->nipxStaticServHopCount,
			Sseb->MibSetInputData.MibRow.Service.Server.HopCount);
		return MIB_S_SUCCESS;
	case MIB_ACTION_SET:
		switch (Sseb->ActionFlag) {
		case NIPX_STATE_NOACTION:
			rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sseb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case NIPX_STATE_OFF:
			rc = MprAdminMIBEntryDelete (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sseb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case NIPX_STATE_ON:
			rc = MprAdminMIBEntryCreate (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sseb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		}

		if (rc==NO_ERROR) {
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Set succeded"
					" for service %.4x-%.48s on if %ld.\n",
				Sseb->MibSetInputData.MibRow.Service.Server.Type,
				Sseb->MibSetInputData.MibRow.Service.Server.Name,
				Sseb->MibSetInputData.MibRow.Service.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Set failed for"
					" for service %.4x-%.48s on if %ld with error %ld.\n",
				Sseb->MibSetInputData.MibRow.Service.Server.Type,
				Sseb->MibSetInputData.MibRow.Service.Server.Name,
				Sseb->MibSetInputData.MibRow.Service.InterfaceIndex,
				rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Sseb
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ipx\snmp\nipxf.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nipx.h

Abstract:

    Header for Novell-ipx instrumentation callbacks and associated data structures

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/

#ifndef _SNMP_NIPXF_
#define _SNMP_NIPXF_




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxSystem group (1.3.6.1.4.1.23.2.5.1)                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxBasicSysEntry table (1.3.6.1.4.1.23.2.5.1.1.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxBasicSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxBasicSysEntry {
	AsnAny	nipxBasicSysInstance;
	AsnAny	nipxBasicSysExistState;
	AsnAny	nipxBasicSysNetNumber;
	AsnAny	nipxBasicSysNode;
	AsnAny	nipxBasicSysName;
	AsnAny	nipxBasicSysInReceives;
	AsnAny	nipxBasicSysInHdrErrors;
	AsnAny	nipxBasicSysInUnknownSockets;
	AsnAny	nipxBasicSysInDiscards;
	AsnAny	nipxBasicSysInBadChecksums;
	AsnAny	nipxBasicSysInDelivers;
	AsnAny	nipxBasicSysNoRoutes;
	AsnAny	nipxBasicSysOutRequests;
	AsnAny	nipxBasicSysOutMalformedRequests;
	AsnAny	nipxBasicSysOutDiscards;
	AsnAny	nipxBasicSysOutPackets;
	AsnAny	nipxBasicSysConfigSockets;
	AsnAny	nipxBasicSysOpenSocketFails;
	BYTE	NetNumberVal[4];
	BYTE	NodeVal[6];
	BYTE	NameVal[48];
} buf_nipxBasicSysEntry;

#define gf_nipxBasicSysInstance				get_nipxBasicSysEntry
#define gf_nipxBasicSysExistState			get_nipxBasicSysEntry
#define gf_nipxBasicSysNetNumber			get_nipxBasicSysEntry
#define gf_nipxBasicSysNode					get_nipxBasicSysEntry
#define gf_nipxBasicSysName					get_nipxBasicSysEntry
#define gf_nipxBasicSysInReceives			get_nipxBasicSysEntry
#define gf_nipxBasicSysInHdrErrors			get_nipxBasicSysEntry
#define gf_nipxBasicSysInUnknownSockets		get_nipxBasicSysEntry
#define gf_nipxBasicSysInDiscards			get_nipxBasicSysEntry
#define gf_nipxBasicSysInBadChecksums		get_nipxBasicSysEntry
#define gf_nipxBasicSysInDelivers			get_nipxBasicSysEntry
#define gf_nipxBasicSysNoRoutes				get_nipxBasicSysEntry
#define gf_nipxBasicSysOutRequests			get_nipxBasicSysEntry
#define gf_nipxBasicSysOutMalformedRequests	get_nipxBasicSysEntry
#define gf_nipxBasicSysOutDiscards			get_nipxBasicSysEntry
#define gf_nipxBasicSysOutPackets			get_nipxBasicSysEntry
#define gf_nipxBasicSysConfigSockets		get_nipxBasicSysEntry
#define gf_nipxBasicSysOpenSocketFails		get_nipxBasicSysEntry

#define gb_nipxBasicSysInstance				buf_nipxBasicSysEntry
#define gb_nipxBasicSysExistState			buf_nipxBasicSysEntry
#define gb_nipxBasicSysNetNumber			buf_nipxBasicSysEntry
#define gb_nipxBasicSysNode					buf_nipxBasicSysEntry
#define gb_nipxBasicSysName					buf_nipxBasicSysEntry
#define gb_nipxBasicSysInReceives			buf_nipxBasicSysEntry
#define gb_nipxBasicSysInHdrErrors			buf_nipxBasicSysEntry
#define gb_nipxBasicSysInUnknownSockets		buf_nipxBasicSysEntry
#define gb_nipxBasicSysInDiscards			buf_nipxBasicSysEntry
#define gb_nipxBasicSysInBadChecksums		buf_nipxBasicSysEntry
#define gb_nipxBasicSysInDelivers			buf_nipxBasicSysEntry
#define gb_nipxBasicSysNoRoutes				buf_nipxBasicSysEntry
#define gb_nipxBasicSysOutRequests			buf_nipxBasicSysEntry
#define gb_nipxBasicSysOutMalformedRequests	buf_nipxBasicSysEntry
#define gb_nipxBasicSysOutDiscards			buf_nipxBasicSysEntry
#define gb_nipxBasicSysOutPackets			buf_nipxBasicSysEntry
#define gb_nipxBasicSysConfigSockets		buf_nipxBasicSysEntry
#define gb_nipxBasicSysOpenSocketFails		buf_nipxBasicSysEntry

/*
	All values in nipxBasicSysEntry are implemented as read-only
UINT
set_nipxBasicSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_nipxBasicSysEntry {
	AsnAny	nipxBasicSysInstance;
	AsnAny	nipxBasicSysExistState;
	AsnAny	nipxBasicSysNetNumber;
	AsnAny	nipxBasicSysNode;
	AsnAny	nipxBasicSysName;
} sav_nipxBasicSysEntry;

#define sf_nipxBasicSysInstance				set_nipxBasicSysEntry
#define sf_nipxBasicSysExistState			set_nipxBasicSysEntry
#define sf_nipxBasicSysNetNumber			set_nipxBasicSysEntry
#define sf_nipxBasicSysNode					set_nipxBasicSysEntry
#define sf_nipxBasicSysName					set_nipxBasicSysEntry

#define sb_nipxBasicSysInstance				sav_nipxBasicSysEntry
#define sb_nipxBasicSysExistState			sav_nipxBasicSysEntry
#define sb_nipxBasicSysNetNumber			sav_nipxBasicSysEntry
#define sb_nipxBasicSysNode					sav_nipxBasicSysEntry
#define sb_nipxBasicSysName					sav_nipxBasicSysEntry
*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxAdvSysEntry table (1.3.6.1.4.1.23.2.5.1.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxAdvSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxAdvSysEntry {
	AsnAny	nipxAdvSysInstance;
	AsnAny	nipxAdvSysMaxPathSplits;
	AsnAny	nipxAdvSysMaxHops;
	AsnAny	nipxAdvSysInTooManyHops;
	AsnAny	nipxAdvSysInFiltered;
	AsnAny	nipxAdvSysInCompressDiscards;
	AsnAny	nipxAdvSysNETBIOSPackets;
	AsnAny	nipxAdvSysForwPackets;
	AsnAny	nipxAdvSysOutFiltered;
	AsnAny	nipxAdvSysOutCompressDiscards;
	AsnAny	nipxAdvSysCircCount;
	AsnAny	nipxAdvSysDestCount;
	AsnAny	nipxAdvSysServCount;
} buf_nipxAdvSysEntry;

#define gf_nipxAdvSysInstance				get_nipxAdvSysEntry
#define gf_nipxAdvSysMaxPathSplits			get_nipxAdvSysEntry
#define gf_nipxAdvSysMaxHops				get_nipxAdvSysEntry
#define gf_nipxAdvSysInTooManyHops			get_nipxAdvSysEntry
#define gf_nipxAdvSysInFiltered				get_nipxAdvSysEntry
#define gf_nipxAdvSysInCompressDiscards		get_nipxAdvSysEntry
#define gf_nipxAdvSysNETBIOSPackets			get_nipxAdvSysEntry
#define gf_nipxAdvSysForwPackets			get_nipxAdvSysEntry
#define gf_nipxAdvSysOutFiltered			get_nipxAdvSysEntry
#define gf_nipxAdvSysOutCompressDiscards	get_nipxAdvSysEntry
#define gf_nipxAdvSysCircCount				get_nipxAdvSysEntry
#define gf_nipxAdvSysDestCount				get_nipxAdvSysEntry
#define gf_nipxAdvSysServCount				get_nipxAdvSysEntry

#define gb_nipxAdvSysInstance				buf_nipxAdvSysEntry
#define gb_nipxAdvSysMaxPathSplits			buf_nipxAdvSysEntry
#define gb_nipxAdvSysMaxHops				buf_nipxAdvSysEntry
#define gb_nipxAdvSysInTooManyHops			buf_nipxAdvSysEntry
#define gb_nipxAdvSysInFiltered				buf_nipxAdvSysEntry
#define gb_nipxAdvSysInCompressDiscards		buf_nipxAdvSysEntry
#define gb_nipxAdvSysNETBIOSPackets			buf_nipxAdvSysEntry
#define gb_nipxAdvSysForwPackets			buf_nipxAdvSysEntry
#define gb_nipxAdvSysOutFiltered			buf_nipxAdvSysEntry
#define gb_nipxAdvSysOutCompressDiscards	buf_nipxAdvSysEntry
#define gb_nipxAdvSysCircCount				buf_nipxAdvSysEntry
#define gb_nipxAdvSysDestCount				buf_nipxAdvSysEntry
#define gb_nipxAdvSysServCount				buf_nipxAdvSysEntry

/*
	All values in nipxAdvSysEntry are implemented as read-only
UINT
set_nipxAdvSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_nipxAdvSysEntry {
	AsnAny	nipxAdvSysInstance;
	AsnAny	nipxAdvSysMaxPathSplits;
	AsnAny	nipxAdvSysMaxHops;
} sav_nipxAdvSysEntry;

#define sf_nipxAdvSysInstance				set_nipxAdvSysEntry
#define sf_nipxAdvSysMaxPathSplits			set_nipxAdvSysEntry
#define sf_nipxAdvSysMaxHops				set_nipxAdvSysEntry

#define sb_nipxAdvSysInstance				sav_nipxAdvSysEntry
#define sb_nipxAdvSysMaxPathSplits			sav_nipxAdvSysEntry
#define sb_nipxAdvSysMaxHops				sav_nipxAdvSysEntry
*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircuit group (1.3.6.1.4.1.23.2.5.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircEntry table (1.3.6.1.4.1.23.2.5.2.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxCircEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxCircEntry {
	AsnAny	nipxCircSysInstance;
	AsnAny	nipxCircIndex;
	AsnAny	nipxCircExistState;
	AsnAny	nipxCircOperState;
	AsnAny	nipxCircIfIndex;
	AsnAny	nipxCircName;
	AsnAny	nipxCircType;
	AsnAny	nipxCircDialName;
	AsnAny	nipxCircLocalMaxPacketSize;
	AsnAny	nipxCircCompressState;
	AsnAny	nipxCircCompressSlots;
	AsnAny	nipxCircStaticStatus;
	AsnAny	nipxCircCompressedSent;
	AsnAny	nipxCircCompressedInitSent;
	AsnAny	nipxCircCompressedRejectsSent;
	AsnAny	nipxCircUncompressedSent;
	AsnAny	nipxCircCompressedReceived;
	AsnAny	nipxCircCompressedInitReceived;
	AsnAny	nipxCircCompressedRejectsReceived;
	AsnAny	nipxCircUncompressedReceived;
	AsnAny	nipxCircMediaType;
	AsnAny	nipxCircNetNumber;
	AsnAny	nipxCircStateChanges;
	AsnAny	nipxCircInitFails;
	AsnAny	nipxCircDelay;
	AsnAny	nipxCircThroughput;
	AsnAny	nipxCircNeighRouterName;
	AsnAny	nipxCircNeighInternalNetNum;
	BYTE	NameVal[48];
	BYTE	DialNameVal[48];
	BYTE	MediaTypeVal[2];
	BYTE	NetNumberVal[4];
	BYTE	NeighRouterNameVal[48];
	BYTE	NeighInternalNetNumVal[4];
} buf_nipxCircEntry;

#define gf_nipxCircSysInstance				get_nipxCircEntry
#define gf_nipxCircIndex					get_nipxCircEntry
#define gf_nipxCircExistState				get_nipxCircEntry
#define gf_nipxCircOperState				get_nipxCircEntry
#define gf_nipxCircIfIndex					get_nipxCircEntry
#define gf_nipxCircName						get_nipxCircEntry
#define gf_nipxCircType						get_nipxCircEntry
#define gf_nipxCircDialName					get_nipxCircEntry
#define gf_nipxCircLocalMaxPacketSize		get_nipxCircEntry
#define gf_nipxCircCompressState			get_nipxCircEntry
#define gf_nipxCircCompressSlots			get_nipxCircEntry
#define gf_nipxCircStaticStatus				get_nipxCircEntry
#define gf_nipxCircCompressedSent			get_nipxCircEntry
#define gf_nipxCircCompressedInitSent		get_nipxCircEntry
#define gf_nipxCircCompressedRejectsSent	get_nipxCircEntry
#define gf_nipxCircUncompressedSent			get_nipxCircEntry
#define gf_nipxCircCompressedReceived		get_nipxCircEntry
#define gf_nipxCircCompressedInitReceived	get_nipxCircEntry
#define gf_nipxCircCompressedRejectsReceived get_nipxCircEntry
#define gf_nipxCircUncompressedReceived		get_nipxCircEntry
#define gf_nipxCircMediaType				get_nipxCircEntry
#define gf_nipxCircNetNumber				get_nipxCircEntry
#define gf_nipxCircStateChanges				get_nipxCircEntry
#define gf_nipxCircInitFails				get_nipxCircEntry
#define gf_nipxCircDelay					get_nipxCircEntry
#define gf_nipxCircThroughput				get_nipxCircEntry
#define gf_nipxCircNeighRouterName			get_nipxCircEntry
#define gf_nipxCircNeighInternalNetNum		get_nipxCircEntry

#define gb_nipxCircSysInstance				buf_nipxCircEntry
#define gb_nipxCircIndex					buf_nipxCircEntry
#define gb_nipxCircExistState				buf_nipxCircEntry
#define gb_nipxCircOperState				buf_nipxCircEntry
#define gb_nipxCircIfIndex					buf_nipxCircEntry
#define gb_nipxCircName						buf_nipxCircEntry
#define gb_nipxCircType						buf_nipxCircEntry
#define gb_nipxCircDialName					buf_nipxCircEntry
#define gb_nipxCircLocalMaxPacketSize		buf_nipxCircEntry
#define gb_nipxCircCompressState			buf_nipxCircEntry
#define gb_nipxCircCompressSlots			buf_nipxCircEntry
#define gb_nipxCircStaticStatus				buf_nipxCircEntry
#define gb_nipxCircCompressedSent			buf_nipxCircEntry
#define gb_nipxCircCompressedInitSent		buf_nipxCircEntry
#define gb_nipxCircCompressedRejectsSent	buf_nipxCircEntry
#define gb_nipxCircUncompressedSent			buf_nipxCircEntry
#define gb_nipxCircCompressedReceived		buf_nipxCircEntry
#define gb_nipxCircCompressedInitReceived	buf_nipxCircEntry
#define gb_nipxCircCompressedRejectsReceived buf_nipxCircEntry
#define gb_nipxCircUncompressedReceived		buf_nipxCircEntry
#define gb_nipxCircMediaType				buf_nipxCircEntry
#define gb_nipxCircNetNumber				buf_nipxCircEntry
#define gb_nipxCircStateChanges				buf_nipxCircEntry
#define gb_nipxCircInitFails				buf_nipxCircEntry
#define gb_nipxCircDelay					buf_nipxCircEntry
#define gb_nipxCircThroughput				buf_nipxCircEntry
#define gb_nipxCircNeighRouterName			buf_nipxCircEntry
#define gb_nipxCircNeighInternalNetNum		buf_nipxCircEntry

UINT
set_nipxCircEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_nipxCircEntry {
	AsnAny	nipxCircSysInstance;		// implemented as read-only
	AsnAny	nipxCircIndex;				// implemented as read-only
//	AsnAny	nipxCircExistState;			// implemented as read-only
	AsnAny	nipxCircOperState;
//	AsnAny	nipxCircIfIndex;			// implemented as read-only
//	AsnAny	nipxCircName;				// implemented as read-only
//	AsnAny	nipxCircType;				// implemented as read-only
//	AsnAny	nipxCircDialName;			// implemented as read-only
//	AsnAny	nipxCircLocalMaxPacketSize;	// implemented as read-only
//	AsnAny	nipxCircCompressState;		// implemented as read-only
//	AsnAny	nipxCircCompressSlots;		// implemented as read-only
//	AsnAny	nipxCircStaticStatus;		// implemented as read-only
	IPX_MIB_SET_INPUT_DATA	MibSetInputData;
} sav_nipxCircEntry;

#define sf_nipxCircSysInstance				set_nipxCircEntry
#define sf_nipxCircIndex					set_nipxCircEntry
//#define sf_nipxCircExistState				set_nipxCircEntry
#define sf_nipxCircOperState				set_nipxCircEntry
//#define sf_nipxCircIfIndex				set_nipxCircEntry
//#define sf_nipxCircName					set_nipxCircEntry
//#define sf_nipxCircType					set_nipxCircEntry
//#define sf_nipxCircDialName				set_nipxCircEntry
//#define sf_nipxCircLocalMaxPacketSize		set_nipxCircEntry
//#define sf_nipxCircCompressState			set_nipxCircEntry
//#define sf_nipxCircCompressSlots			set_nipxCircEntry
//#define sf_nipxCircStaticStatus			set_nipxCircEntry

#define sb_nipxCircSysInstance				sav_nipxCircEntry
#define sb_nipxCircIndex					sav_nipxCircEntry
//#define sb_nipxCircExistState				sav_nipxCircEntry
#define sb_nipxCircOperState				sav_nipxCircEntry
//#define sb_nipxCircIfIndex				sav_nipxCircEntry
//#define sb_nipxCircName					sav_nipxCircEntry
//#define sb_nipxCircType					sav_nipxCircEntry
//#define sb_nipxCircDialName				sav_nipxCircEntry
//#define sb_nipxCircLocalMaxPacketSize		sav_nipxCircEntry
//#define sb_nipxCircCompressState			sav_nipxCircEntry
//#define sb_nipxCircCompressSlots			sav_nipxCircEntry
//#define sb_nipxCircStaticStatus			sav_nipxCircEntry


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxForwarding group (1.3.6.1.4.1.23.2.5.3)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestEntry table (1.3.6.1.4.1.23.2.5.3.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxDestEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxDestEntry {
	AsnAny	nipxDestSysInstance;
	AsnAny	nipxDestNetNum;
	AsnAny	nipxDestProtocol;
	AsnAny	nipxDestTicks;
	AsnAny	nipxDestHopCount;
	AsnAny	nipxDestNextHopCircIndex;
	AsnAny	nipxDestNextHopNICAddress;
	AsnAny	nipxDestNextHopNetNum;
	BYTE	NetNumVal[4];
	BYTE	NextHopNICAddressVal[6];
	BYTE	NextHopNetNumVal[4];
} buf_nipxDestEntry;

#define gf_nipxDestSysInstance				get_nipxDestEntry
#define gf_nipxDestNetNum					get_nipxDestEntry
#define gf_nipxDestProtocol					get_nipxDestEntry
#define gf_nipxDestTicks					get_nipxDestEntry
#define gf_nipxDestHopCount					get_nipxDestEntry
#define gf_nipxDestNextHopCircIndex			get_nipxDestEntry
#define gf_nipxDestNextHopNICAddress		get_nipxDestEntry
#define gf_nipxDestNextHopNetNum			get_nipxDestEntry

#define gb_nipxDestSysInstance				buf_nipxDestEntry
#define gb_nipxDestNetNum					buf_nipxDestEntry
#define gb_nipxDestProtocol					buf_nipxDestEntry
#define gb_nipxDestTicks					buf_nipxDestEntry
#define gb_nipxDestHopCount					buf_nipxDestEntry
#define gb_nipxDestNextHopCircIndex			buf_nipxDestEntry
#define gb_nipxDestNextHopNICAddress		buf_nipxDestEntry
#define gb_nipxDestNextHopNetNum			buf_nipxDestEntry


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxStaticRouteEntry table (1.3.6.1.4.1.23.2.5.3.1.2)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxStaticRouteEntry {
	AsnAny	nipxStaticRouteSysInstance;
	AsnAny	nipxStaticRouteCircIndex;
	AsnAny	nipxStaticRouteNetNum;
	AsnAny	nipxStaticRouteExistState;
	AsnAny	nipxStaticRouteTicks;
	AsnAny	nipxStaticRouteHopCount;
	BYTE	NetNumVal[4];
} buf_nipxStaticRouteEntry;

#define gf_nipxStaticRouteSysInstance		get_nipxStaticRouteEntry
#define gf_nipxStaticRouteCircIndex			get_nipxStaticRouteEntry
#define gf_nipxStaticRouteNetNum			get_nipxStaticRouteEntry
#define gf_nipxStaticRouteExistState		get_nipxStaticRouteEntry
#define gf_nipxStaticRouteTicks				get_nipxStaticRouteEntry
#define gf_nipxStaticRouteHopCount			get_nipxStaticRouteEntry

#define gb_nipxStaticRouteSysInstance		buf_nipxStaticRouteEntry
#define gb_nipxStaticRouteCircIndex			buf_nipxStaticRouteEntry
#define gb_nipxStaticRouteNetNum			buf_nipxStaticRouteEntry
#define gb_nipxStaticRouteExistState		buf_nipxStaticRouteEntry
#define gb_nipxStaticRouteTicks				buf_nipxStaticRouteEntry
#define gb_nipxStaticRouteHopCount			buf_nipxStaticRouteEntry

UINT
set_nipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_nipxStaticRouteEntry {
	AsnAny	nipxStaticRouteSysInstance;
	AsnAny	nipxStaticRouteCircIndex;
	AsnAny	nipxStaticRouteNetNum;
	AsnAny	nipxStaticRouteExistState;
	AsnAny	nipxStaticRouteTicks;
	AsnAny	nipxStaticRouteHopCount;
	IPX_MIB_SET_INPUT_DATA	MibSetInputData;
	BOOLEAN	ActionFlag;
} sav_nipxStaticRouteEntry;

#define sf_nipxStaticRouteSysInstance		set_nipxStaticRouteEntry
#define sf_nipxStaticRouteCircIndex			set_nipxStaticRouteEntry
#define sf_nipxStaticRouteNetNum			set_nipxStaticRouteEntry
#define sf_nipxStaticRouteExistState		set_nipxStaticRouteEntry
#define sf_nipxStaticRouteTicks				set_nipxStaticRouteEntry
#define sf_nipxStaticRouteHopCount			set_nipxStaticRouteEntry

#define sb_nipxStaticRouteSysInstance		sav_nipxStaticRouteEntry
#define sb_nipxStaticRouteCircIndex			sav_nipxStaticRouteEntry
#define sb_nipxStaticRouteNetNum			sav_nipxStaticRouteEntry
#define sb_nipxStaticRouteExistState		sav_nipxStaticRouteEntry
#define sb_nipxStaticRouteTicks				sav_nipxStaticRouteEntry
#define sb_nipxStaticRouteHopCount			sav_nipxStaticRouteEntry


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServices group (1.3.6.1.4.1.23.2.5.4)                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServEntry table (1.3.6.1.4.1.23.2.5.4.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxServEntry {
	AsnAny	nipxServSysInstance;
	AsnAny	nipxServType;
	AsnAny	nipxServName;
	AsnAny	nipxServProtocol;
	AsnAny	nipxServNetNum;
	AsnAny	nipxServNode;
	AsnAny	nipxServSocket;
	AsnAny	nipxServHopCount;
	BYTE	TypeVal[2];
	BYTE	NameVal[48];
	BYTE	NetNumVal[4];
	BYTE	NodeVal[6];
	BYTE	SocketVal[2];
} buf_nipxServEntry;

#define gf_nipxServSysInstance				get_nipxServEntry
#define gf_nipxServType						get_nipxServEntry
#define gf_nipxServName						get_nipxServEntry
#define gf_nipxServProtocol					get_nipxServEntry
#define gf_nipxServNetNum					get_nipxServEntry
#define gf_nipxServNode						get_nipxServEntry
#define gf_nipxServSocket					get_nipxServEntry
#define gf_nipxServHopCount					get_nipxServEntry

#define gb_nipxServSysInstance				buf_nipxServEntry
#define gb_nipxServType						buf_nipxServEntry
#define gb_nipxServName						buf_nipxServEntry
#define gb_nipxServProtocol					buf_nipxServEntry
#define gb_nipxServNetNum					buf_nipxServEntry
#define gb_nipxServNode						buf_nipxServEntry
#define gb_nipxServSocket					buf_nipxServEntry
#define gb_nipxServHopCount					buf_nipxServEntry


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestServEntry table (1.3.6.1.4.1.23.2.5.4.2.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxDestServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxDestServEntry {
	AsnAny	nipxDestServSysInstance;
	AsnAny	nipxDestServNetNum;
	AsnAny	nipxDestServNode;
	AsnAny	nipxDestServSocket;
	AsnAny	nipxDestServName;
	AsnAny	nipxDestServType;
	AsnAny	nipxDestServProtocol;
	AsnAny	nipxDestServHopCount;
	BYTE	NetNumVal[4];
	BYTE	NodeVal[6];
	BYTE	SocketVal[2];
	BYTE	NameVal[48];
	BYTE	TypeVal[2];
} buf_nipxDestServEntry;

#define gf_nipxDestServSysInstance			get_nipxDestServEntry
#define gf_nipxDestServNetNum				get_nipxDestServEntry
#define gf_nipxDestServNode					get_nipxDestServEntry
#define gf_nipxDestServSocket				get_nipxDestServEntry
#define gf_nipxDestServName					get_nipxDestServEntry
#define gf_nipxDestServType					get_nipxDestServEntry
#define gf_nipxDestServProtocol				get_nipxDestServEntry
#define gf_nipxDestServHopCount				get_nipxDestServEntry

#define gb_nipxDestServSysInstance			buf_nipxDestServEntry
#define gb_nipxDestServNetNum				buf_nipxDestServEntry
#define gb_nipxDestServNode					buf_nipxDestServEntry
#define gb_nipxDestServSocket				buf_nipxDestServEntry
#define gb_nipxDestServName					buf_nipxDestServEntry
#define gb_nipxDestServType					buf_nipxDestServEntry
#define gb_nipxDestServProtocol				buf_nipxDestServEntry
#define gb_nipxDestServHopCount				buf_nipxDestServEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxStaticServEntry table (1.3.6.1.4.1.23.2.5.4.3.1)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxStaticServEntry {
	AsnAny	nipxStaticServSysInstance;
	AsnAny	nipxStaticServCircIndex;
	AsnAny	nipxStaticServType;
	AsnAny	nipxStaticServName;
	AsnAny	nipxStaticServExistState;
	AsnAny	nipxStaticServNetNum;
	AsnAny	nipxStaticServNode;
	AsnAny	nipxStaticServSocket;
	AsnAny	nipxStaticServHopCount;
	BYTE	NameVal[48];
	BYTE	TypeVal[2];
	BYTE	NetNumVal[4];
	BYTE	NodeVal[6];
	BYTE	SocketVal[2];
} buf_nipxStaticServEntry;

#define gf_nipxStaticServSysInstance		get_nipxStaticServEntry
#define gf_nipxStaticServCircIndex			get_nipxStaticServEntry
#define gf_nipxStaticServType				get_nipxStaticServEntry
#define gf_nipxStaticServName				get_nipxStaticServEntry
#define gf_nipxStaticServExistState			get_nipxStaticServEntry
#define gf_nipxStaticServNetNum				get_nipxStaticServEntry
#define gf_nipxStaticServNode				get_nipxStaticServEntry
#define gf_nipxStaticServSocket				get_nipxStaticServEntry
#define gf_nipxStaticServHopCount			get_nipxStaticServEntry

#define gb_nipxStaticServSysInstance		buf_nipxStaticServEntry
#define gb_nipxStaticServCircIndex			buf_nipxStaticServEntry
#define gb_nipxStaticServType				buf_nipxStaticServEntry
#define gb_nipxStaticServName				buf_nipxStaticServEntry
#define gb_nipxStaticServExistState			buf_nipxStaticServEntry
#define gb_nipxStaticServNetNum				buf_nipxStaticServEntry
#define gb_nipxStaticServNode				buf_nipxStaticServEntry
#define gb_nipxStaticServSocket				buf_nipxStaticServEntry
#define gb_nipxStaticServHopCount			buf_nipxStaticServEntry

UINT
set_nipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_nipxStaticServEntry {
	AsnAny	nipxStaticServSysInstance;
	AsnAny	nipxStaticServCircIndex;
	AsnAny	nipxStaticServType;
	AsnAny	nipxStaticServName;
	AsnAny	nipxStaticServExistState;
	AsnAny	nipxStaticServNetNum;
	AsnAny	nipxStaticServNode;
	AsnAny	nipxStaticServSocket;
	AsnAny	nipxStaticServHopCount;
	IPX_MIB_SET_INPUT_DATA	MibSetInputData;
	BOOLEAN	ActionFlag;
} sav_nipxStaticServEntry;

#define sf_nipxStaticServSysInstance		set_nipxStaticServEntry
#define sf_nipxStaticServCircIndex			set_nipxStaticServEntry
#define sf_nipxStaticServType				set_nipxStaticServEntry
#define sf_nipxStaticServName				set_nipxStaticServEntry
#define sf_nipxStaticServExistState			set_nipxStaticServEntry
#define sf_nipxStaticServNetNum				set_nipxStaticServEntry
#define sf_nipxStaticServNode				set_nipxStaticServEntry
#define sf_nipxStaticServSocket				set_nipxStaticServEntry
#define sf_nipxStaticServHopCount			set_nipxStaticServEntry

#define sb_nipxStaticServSysInstance		sav_nipxStaticServEntry
#define sb_nipxStaticServCircIndex			sav_nipxStaticServEntry
#define sb_nipxStaticServType				sav_nipxStaticServEntry
#define sb_nipxStaticServName				sav_nipxStaticServEntry
#define sb_nipxStaticServExistState			sav_nipxStaticServEntry
#define sb_nipxStaticServNetNum				sav_nipxStaticServEntry
#define sb_nipxStaticServNode				sav_nipxStaticServEntry
#define sb_nipxStaticServSocket				sav_nipxStaticServEntry
#define sb_nipxStaticServHopCount			sav_nipxStaticServEntry


#endif // _MIBFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ipx\snmp\precomp.h ===
#ifdef UNICODE
#define _UNICODE
#include <stdlib.h>
#endif

#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <malloc.h>
#include <snmp.h>
#include <snmpexts.h>

#include "mprapi.h"
#include "dim.h"
#include "ipxrtprt.h"
#include "ipxrtdef.h"

#include "mipxe.h"
#include "mipxf.h"
#include "mripsape.h"
#include "mripsapf.h"
#include "nipxe.h"
#include "nipxf.h"
#include "rtipxmib.h"

#include "debug.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\defs.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: ipmgm.h
//
// History:
//      V Raman Aug-6-1997  Created.
//
// Contains type definitions and declarations for IP MGM.
//============================================================================

#ifndef _MGMDEFS_H_
#define _MGMDEFS_H_


#define MGM_CLIENT_HANDLE_TAG       ('MGMc' << 8)

#define MGM_ENUM_HANDLE_TAG         ('MGMe' << 8)

//----------------------------------------------------------------------------
// Protocol constants
//----------------------------------------------------------------------------

#define INVALID_PROTOCOL_ID         0xffffffff
#define INVALID_COMPONENT_ID        0xffffffff

#define IS_VALID_PROTOCOL( a, b ) \
        (a) != INVALID_PROTOCOL_ID && (b) != INVALID_COMPONENT_ID

#define IS_PROTOCOL_IGMP( p )  \
        ( (p)-> dwProtocolId == PROTO_IP_IGMP )

#define IS_ROUTING_PROTOCOL( p )  \
        !IS_PROTOCOL_IGMP( p )

#define IS_PROTOCOL_ID_IGMP( i ) \
        (i) == PROTO_IP_IGMP

//----------------------------------------------------------------------------
// Interface constants
//----------------------------------------------------------------------------

#define INVALID_INTERFACE_INDEX     0x0
#define INVALID_NEXT_HOP_ADDR       0x0

#define IS_VALID_INTERFACE( a, b )  \
        (a) != INVALID_INTERFACE_INDEX


//----------------------------------------------------------------------------
// Wildcard source/group macros
//----------------------------------------------------------------------------

#define WILDCARD_GROUP              0x0
#define WILDCARD_GROUP_MASK         0x0

#define WILDCARD_SOURCE             0x0
#define WILDCARD_SOURCE_MASK        0x0


#define IS_WILDCARD_GROUP( a, b )   (a) == WILDCARD_GROUP

#define IS_WILDCARD_SOURCE( a, b )  (a) == WILDCARD_SOURCE


//----------------------------------------------------------------------------
// Time conversion constants and macros
//----------------------------------------------------------------------------

#define SYSTIME_UNITS_PER_MSEC      (1000 * 10)
#define SYSTIME_UNITS_PER_SEC       (1000 * SYSTIME_UNITS_PER_MSEC)
#define SYSTIME_UNITS_PER_MINUTE    (60 * SYSTIME_UNITS_PER_SEC)

#define EXPIRY_INTERVAL             15 * 60 * 1000

#define ROUTE_CHECK_INTERVAL        \
        SYSTIME_UNITS_PER_MINUTE / SYSTIME_UNITS_PER_MSEC


#define MgmQuerySystemTime(p)   NtQuerySystemTime((p))

#define MgmSetExpiryTime(p, i)                                              \
{                                                                           \
    LARGE_INTEGER __li = { i };                                             \
    *(p) = RtlLargeIntegerAdd( *(p), __li );                                \
}


#define MgmElapsedTime( p, q, u )                                           \
{                                                                           \
    LARGE_INTEGER __li1, __li2;                                             \
    ULONG         __rem;                                                    \
    MgmQuerySystemTime( &__li1);                                            \
    __li2 = RtlLargeIntegerSubtract( __li1, *(p) );                         \
    __li1 = RtlExtendedLargeIntegerDivide( __li2, u, &__rem );              \
    *(q) = __li1.LowPart;                                                   \
}

#define MgmElapsedSecs( p, q )      \
        MgmElapsedTime( p, q, SYSTIME_UNITS_PER_SEC )


#define TIMER_TABLE_MAX_SIZE        16


//----------------------------------------------------------------------------
// IP address manipulation macros
//  Bolade's macro.
//----------------------------------------------------------------------------

//
// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument.
//

#define INET_CMP(a,b,c)                                                     \
            (((c) = (((a) & 0x000000ff) - ((b) & 0x000000ff))) ? (c) :      \
            (((c) = (((a) & 0x0000ff00) - ((b) & 0x0000ff00))) ? (c) :      \
            (((c) = (((a) & 0x00ff0000) - ((b) & 0x00ff0000))) ? (c) :      \
            (((c) = ((((a)>>8) & 0x00ff0000) - (((b)>>8) & 0x00ff0000)))))))

//
// IP address conversion macro:
//  calls inet_ntoa directly on a DWORD, by casting it as an IN_ADDR.
//

#define INET_NTOA(dw) inet_ntoa( *(PIN_ADDR)&(dw) )


//
// IPv4 mask len
//

#define IPv4_ADDR_LEN            32

#endif // _MGMDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ipx\snmp\svccache.c ===
#include "precomp.h"

typedef struct _SERVICE_CACHE_ENTRY SERVICE_CACHE_ENTRY, *PSERVICE_CACHE_ENTRY;
struct _SERVICE_CACHE_ENTRY {
	PIPX_SERVICE			svc;
	PSERVICE_CACHE_ENTRY	next;
};



#define NUM_SERVICE_CACHES	2
#define CACHE_VALID_TIME		1800000000i64
PSERVICE_CACHE_ENTRY	ServiceCache[NUM_SERVICE_CACHES][48];
LONGLONG				ServiceCacheTimeStamp[NUM_SERVICE_CACHES] = {
									-CACHE_VALID_TIME,
									-CACHE_VALID_TIME};

USHORT					ServiceCacheType[NUM_SERVICE_CACHES];
INT						LastServiceCache = 0;


DWORD
GetNextServiceSorted (
	USHORT			type,
	PUCHAR			name,
	PIPX_SERVICE	*pSvp
	) {
	INT						idx = strlen (name);
	LONGLONG				CurTime;
	PIPX_SERVICE			Svp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;
	INT						i,j;

	MibGetInputData.TableId = IPX_SERV_TABLE;
	GetSystemTimeAsFileTime ((LPFILETIME)&CurTime);

	while (TRUE) {
		j = LastServiceCache;
		while (CurTime-ServiceCacheTimeStamp[j]<=CACHE_VALID_TIME) {
			INT		j1;
			if (type==ServiceCacheType[j]) {
				for (i=idx; i<sizeof (ServiceCache[0])/sizeof (ServiceCache[0][0]); i++) {
					PSERVICE_CACHE_ENTRY	cur=ServiceCache[j][i];
					while ((cur!=NULL) && (idx==i) && (strcmp (name,cur->svc->Server.Name)>=0))
						cur = cur->next;
					if (cur!=NULL) {
						*pSvp = cur->svc;
						return NO_ERROR;
					}
				}
			
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = type;
				memset (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
						0xFF,
						sizeof (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName)-1);
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceName[
					sizeof (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName)-1] = 0;
				rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Svp,
										&SvSize);
				if (rc==NO_ERROR) {
					j = LastServiceCache;
					type = Svp->Server.Type;
					name = (PUCHAR)"\0";
					idx = 0;
					MprAdminMIBBufferFree (Svp);
					continue;
				}
				else
					return rc;
			}
			j1=(j+1)%NUM_SERVICE_CACHES;
			if (j1!=LastServiceCache)
				j = j1;
			else
				break;
		}

		MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = type;
		MibGetInputData.MibIndex.ServicesTableIndex.ServiceName[0] = 1;
		MibGetInputData.MibIndex.ServicesTableIndex.ServiceName[1] = 0;
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		if (rc!=NO_ERROR)
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		if (rc!=NO_ERROR)
			return rc;
		do {
			for (i=0; i<sizeof (ServiceCache[0])/sizeof (ServiceCache[0][0]); i++) {
				PSERVICE_CACHE_ENTRY	cur;
				while (ServiceCache[j][i]!=NULL) {
					cur = ServiceCache[j][i];
					MprAdminMIBBufferFree (cur->svc);
					ServiceCache[j][i] = cur->next;
					free (cur);
				}
			}
			ServiceCacheTimeStamp[j] = CurTime-CACHE_VALID_TIME;
			j = (j+1)%NUM_SERVICE_CACHES;
			if (j==LastServiceCache)
				break;
		}
		while (CurTime-ServiceCacheTimeStamp[j]>CACHE_VALID_TIME);

		j = (j+(NUM_SERVICE_CACHES-1))%NUM_SERVICE_CACHES;

		MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = Svp->Server.Type;
		do {
			PSERVICE_CACHE_ENTRY	cur;
			cur = (PSERVICE_CACHE_ENTRY)malloc (sizeof (SERVICE_CACHE_ENTRY));
			if (cur!=NULL) {
				i = strlen ((PCHAR)Svp->Server.Name);
				cur->svc = Svp;
				cur->next = ServiceCache[j][i];
				ServiceCache[j][i] = cur;
			}
			else {
				MprAdminMIBBufferFree (Svp);
				return ERROR_NOT_ENOUGH_MEMORY;
			}

			strcpy (
				(PCHAR)MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
				(PCHAR)Svp->Server.Name);

			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		}
		while ((rc==NO_ERROR)
			&& (Svp->Server.Type==MibGetInputData.MibIndex.ServicesTableIndex.ServiceType));

		if (rc==NO_ERROR)
			MprAdminMIBBufferFree (Svp);
		Svp = NULL;
		for (i=0; i<sizeof (ServiceCache[0])/sizeof (ServiceCache[0][0]); i++) {
			PSERVICE_CACHE_ENTRY	cur,prev=ServiceCache[j][i];
			ServiceCache[j][i] = NULL;
			while (prev!=NULL) {
				cur = prev;
				prev = cur->next;
				cur->next = ServiceCache[j][i];
				ServiceCache[j][i] = cur;
			}
			if ((type<MibGetInputData.MibIndex.ServicesTableIndex.ServiceType)
					&& (Svp==NULL) && (ServiceCache[j][i]!=NULL))
				Svp = ServiceCache[j][i]->svc;
		}

		GetSystemTimeAsFileTime ((LPFILETIME)&CurTime);
		ServiceCacheTimeStamp[j] = CurTime;
		ServiceCacheType[j] = MibGetInputData.MibIndex.ServicesTableIndex.ServiceType;
		LastServiceCache = j;
		
		if (Svp!=NULL) {
			*pSvp = Svp;
			return NO_ERROR;
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ipx\snmp\rtipxmib.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rtipxmib.h

Abstract:

    Common include file for all IPX MIB instrumentations support by router

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/



#ifndef _SNMP_RTIPXMIB_
#define _SNMP_RTIPXMIB_


// Macros for converting MIB fields from SNMP master agent format
// to router structures 
#define GetAsnInteger(srcBuf,defVal)\
    (((srcBuf)->asnType)			\
		? (srcBuf)->asnValue.number	\
		: defVal)

#define SetAsnInteger(dstBuf,val)						\
	if ((dstBuf)->asnType) {                            \
		ASSERT((dstBuf)->asnType==ASN_INTEGER);			\
		(dstBuf)->asnValue.number = (AsnInteger)(val);	\
	}

#define ForceAsnInteger(dstBuf,val) {				\
	(dstBuf)->asnType = ASN_INTEGER;				\
	(dstBuf)->asnValue.number = (AsnInteger)(val);	\
	}



#define GetAsnCounter(srcBuf,defVal)\
    (((srcBuf)->asnType)			\
		? (srcBuf)->asnValue.counter\
		: defVal)

#define SetAsnCounter(dstBuf,val)						\
    if ((dstBuf)->asnType) {                            \
		ASSERT((dstBuf)->asnType==ASN_RFC1155_COUNTER);	\
		(dstBuf)->asnValue.counter = (AsnCounter)(val);	\
	}

#define ForceAsnCounter(dstBuf,val) {				\
	(dstBuf)->asnType = ASN_RFC1155_COUNTER;		\
	(dstBuf)->asnValue.counter = (AsnCounter)(val);	\
	}




#define GetAsnServType(srcBuf,defVal)						\
    (USHORT)(((srcBuf)->asnType)							\
		? ((((srcBuf)->asnValue.string.length>0)			\
			? (srcBuf)->asnValue.string.stream[1]			\
			: 0)											\
			+ (((srcBuf)->asnValue.string.length>1)			\
				? (((srcBuf)->asnValue.string.stream[0])<<8)\
				: 0))										\
		: defVal)

#define SetAsnServType(dstBuf,buffer,val)						\
    if ((dstBuf)->asnType) {                                \
		ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);			\
		(dstBuf)->asnValue.string.length = 2;				\
		(buffer)[1] = (BYTE)(val&0xFF);						\
		(buffer)[0] = (BYTE)((val>>8)&0xFF);				\
		(dstBuf)->asnValue.string.stream = (BYTE *)buffer;	\
		(dstBuf)->asnValue.string.dynamic = FALSE;			\
	}

#define ForceAsnServType(dstBuf,buffer,val) {				\
	(dstBuf)->asnType = ASN_OCTETSTRING;				\
	(dstBuf)->asnValue.string.length = 2;				\
	(buffer)[1] = (BYTE)(val&0xFF);						\
	(buffer)[0] = (BYTE)((val>>8)&0xFF);				\
	(dstBuf)->asnValue.string.stream = (BYTE *)buffer;	\
	(dstBuf)->asnValue.string.dynamic = FALSE;			\
	}



#define GetAsnMediaType(srcBuf,defVal)						\
    (USHORT)(((srcBuf)->asnType)							\
		? ((((srcBuf)->asnValue.string.length>0)			\
			? (srcBuf)->asnValue.string.stream[0]			\
			: 0)											\
			+ (((srcBuf)->asnValue.string.length>1)			\
				? (((srcBuf)->asnValue.string.stream[1])<<8)\
				: 0))										\
		: defVal)

#define SetAsnMediaType(dstBuf,buffer,val)						\
    if ((dstBuf)->asnType) {                                \
		ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);			\
		(dstBuf)->asnValue.string.length = 2;				\
		(buffer)[0] = (BYTE)(val&0xFF);						\
		(buffer)[1] = (BYTE)((val>>8)&0xFF);				\
		(dstBuf)->asnValue.string.stream = (BYTE *)buffer;	\
		(dstBuf)->asnValue.string.dynamic = FALSE;			\
	}

#define ForceAsnMediaType(dstBuf,buffer,val) {				\
	(dstBuf)->asnType = ASN_OCTETSTRING;				\
	(dstBuf)->asnValue.string.length = 2;				\
	(buffer)[0] = (BYTE)(val&0xFF);						\
	(buffer)[1] = (BYTE)((val>>8)&0xFF);				\
	(dstBuf)->asnValue.string.stream = (BYTE *)buffer;	\
	(dstBuf)->asnValue.string.dynamic = FALSE;			\
	}



#define GetAsnOctetString(dst,srcBuf,maxlen,defVal)			\
	(((srcBuf)->asnType)									\
		? (memset (&(dst)[(srcBuf)->asnValue.string.length],\
				0, maxlen-(srcBuf)->asnValue.string.length),\
			memcpy (dst,(srcBuf)->asnValue.string.stream,	\
				(srcBuf)->asnValue.string.length))			\
		: (defVal ? memcpy (dst, defVal, maxlen) : NULL))

#define SetAsnOctetString(dstBuf,buffer,src,len)							\
    if ((dstBuf)->asnType) {												\
		ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);							\
		(dstBuf)->asnValue.string.length = len;								\
		(dstBuf)->asnValue.string.stream = (BYTE *)memcpy (buffer,src,len);	\
		(dstBuf)->asnValue.string.dynamic = FALSE;							\
	}

#define ForceAsnOctetString(dstBuf,buffer,src,len) {					\
	(dstBuf)->asnType = ASN_OCTETSTRING;								\
	(dstBuf)->asnValue.string.length = len;								\
	(dstBuf)->asnValue.string.stream = (BYTE *)memcpy (buffer,src,len);	\
	(dstBuf)->asnValue.string.dynamic = FALSE;							\
	}




#define GetAsnDispString(dst,srcBuf,defVal)					\
	(((srcBuf)->asnType)									\
		? ((dst)[(srcBuf)->asnValue.string.length] = 0,		\
			strncpy (dst,(srcBuf)->asnValue.string.stream,	\
						(srcBuf)->asnValue.string.length))	\
		: (defVal ? strcpy (dst,defVal) : ((dst)[0] = 0, NULL)))

#define SetAsnDispString(dstBuf,buffer,src,len)								\
    if ((dstBuf)->asnType) {                                                \
		ASSERT((dstBuf)->asnType==ASN_RFC1213_DISPSTRING);					\
		(dstBuf)->asnValue.string.length = strlen(src);						\
		if ((dstBuf)->asnValue.string.length>len)							\
			(dstBuf)->asnValue.string.length = len;							\
		(dstBuf)->asnValue.string.stream = (BYTE *)strncpy (buffer,src,		\
										(dstBuf)->asnValue.string.length);	\
		(dstBuf)->asnValue.string.dynamic = FALSE;							\
	}

#define ForceAsnDispString(dstBuf,buffer,src,len) {						\
	(dstBuf)->asnType = ASN_RFC1213_DISPSTRING;							\
	(dstBuf)->asnValue.string.length = strlen(src);						\
	if ((dstBuf)->asnValue.string.length>len)							\
		(dstBuf)->asnValue.string.length = len;							\
	(dstBuf)->asnValue.string.stream = (BYTE *)strncpy (buffer,src,		\
									(dstBuf)->asnValue.string.length);	\
	(dstBuf)->asnValue.string.dynamic = FALSE;							\
	}



#define FreeAsnString(buf)	{								\
	if ((buf)->asnValue.string.dynamic)						\
		SNMP_free ((buf)->asnValue.string.stream);			\
	}


// Constants shared by several MIB instrumetnations
#define ZERO_INTERFACE_INDEX			0
#define INVALID_INTERFACE_INDEX			0xFFFFFFFF

extern UCHAR	ZERO_NET_NUM[4];
#define INVALID_NET_NUM					ZERO_NET_NUM

#define ZERO_SERVER_TYPE				0x0000
#define INVALID_SERVER_TYPE				0xFFFF

extern UCHAR	ZERO_SERVER_NAME[1];
#define INVALID_SERVER_NAME				ZERO_SERVER_NAME


#define MIPX_EXIST_STATE_NOACTION		0
#define MIPX_EXIST_STATE_DELETED		1
#define MIPX_EXIST_STATE_CREATED		2

#define NIPX_INVALID_SYS_INSTANCE		0xFFFFFFFF
#define NIPX_DEFAULT_SYS_INSTANCE		0

#define NIPX_STATE_NOACTION				0
#define NIPX_STATE_OFF					1
#define NIPX_STATE_ON					2

#define NIPX_CIRCTYPE_OTHER				1
#define NIPX_CIRCTYPE_BCAST				2
#define NIPX_CIRCTYPE_PTTOPT			3
#define NIPX_CIRCTYPE_WANRIP			4
#define NIPX_CIRCTYPE_UNNUMBEREDRIP		5
#define NIPX_CIRCTYPE_DYNAMIC			6
#define NIPX_CIRCTYPE_WANWS				7

#define NIPX_STATIC_STATUS_UNKNOWN		1
#define NIPX_STATIC_STATUS_CURRENT		2
#define NIPX_STATIC_STATUS_CHANGED		3
#define NIPX_STATIC_STATUS_READ			4
#define NIPX_STATIC_STATUS_READING		5
#define NIPX_STATIC_STATUS_WRITE		6
#define NIPX_STATIC_STATUS_WRITING		7


extern MIB_SERVER_HANDLE		g_MibServerHandle;
DWORD
ConnectToRouter (
    VOID
    );

BOOL EnsureRouterConnection();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ipx\snmp\svccache.h ===
#ifndef _SNMP_SVCCACHE_
#define _SNMP_SVCCACHE_


DWORD
GetNextServiceSorted (
	USHORT			type,
	PUCHAR			name,
	PIPX_SERVICE	*pSvp
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ipx\snmp\rtipxmib.c ===
#include "precomp.h"

DWORD					g_uptimeReference;
MIB_SERVER_HANDLE		g_MibServerHandle = 0;
CRITICAL_SECTION        g_ConnectionLock;
UCHAR	ZERO_NET_NUM[4] = {0,0,0,0};
UCHAR	ZERO_SERVER_NAME[1] = {0};

#if DBG
// DWORD					DbgLevel=DEF_DBGLEVEL;
DWORD DbgLevel=0xffffffff;
#endif




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// root oid                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ms_mipx[]                   = {1,3,6,1,4,1,311,1,8};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxBase group (1.3.6.1.4.1.311.1.8.1)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxBase[]                  = {1};
static UINT ids_mipxBaseOperState[]         = {1,1,0};
static UINT ids_mipxBasePrimaryNetNumber[]  = {1,2,0};
static UINT ids_mipxBaseNode[]              = {1,3,0};
static UINT ids_mipxBaseSysName[]           = {1,4,0};
static UINT ids_mipxBaseMaxPathSplits[]     = {1,5,0};
static UINT ids_mipxBaseIfCount[]           = {1,6,0};
static UINT ids_mipxBaseDestCount[]         = {1,7,0};
static UINT ids_mipxBaseServCount[]         = {1,8,0};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxInterface group (1.3.6.1.4.1.311.1.8.2)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxInterface[]             = {2};
static UINT ids_mipxIfTable[]               = {2,1};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxIfEntry table (1.3.6.1.4.1.311.1.8.2.1.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxIfEntry[]               = {2,1,1};
static UINT ids_mipxIfIndex[]               = {2,1,1,1};
static UINT ids_mipxIfAdminState[]          = {2,1,1,2};
static UINT ids_mipxIfOperState[]           = {2,1,1,3};
static UINT ids_mipxIfAdapterIndex[]        = {2,1,1,4};
static UINT ids_mipxIfName[]                = {2,1,1,5};
static UINT ids_mipxIfType[]                = {2,1,1,6};
static UINT ids_mipxIfLocalMaxPacketSize[]  = {2,1,1,7};
static UINT ids_mipxIfMediaType[]           = {2,1,1,8};
static UINT ids_mipxIfNetNumber[]           = {2,1,1,9};
static UINT ids_mipxIfMacAddress[]          = {2,1,1,10};
static UINT ids_mipxIfDelay[]               = {2,1,1,11};
static UINT ids_mipxIfThroughput[]          = {2,1,1,12};
static UINT ids_mipxIfIpxWanEnable[]	    = {2,1,1,13};
static UINT ids_mipxIfNetbiosAccept[]       = {2,1,1,14};
static UINT ids_mipxIfNetbiosDeliver[]      = {2,1,1,15};
static UINT ids_mipxIfInHdrErrors[]         = {2,1,1,16};
static UINT ids_mipxIfInFilterDrops[]       = {2,1,1,17};
static UINT ids_mipxIfInNoRoutes[]          = {2,1,1,18};
static UINT ids_mipxIfInDiscards[]          = {2,1,1,19};
static UINT ids_mipxIfInDelivers[]          = {2,1,1,20};
static UINT ids_mipxIfOutFilterDrops[]      = {2,1,1,21};
static UINT ids_mipxIfOutDiscards[]         = {2,1,1,22};
static UINT ids_mipxIfOutDelivers[]         = {2,1,1,23};
static UINT ids_mipxIfInNetbiosPackets[]    = {2,1,1,24};
static UINT ids_mipxIfOutNetbiosPackets[]   = {2,1,1,25};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxForwarding group (1.3.6.1.4.1.311.1.8.3)                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxForwarding[]            = {3};
static UINT ids_mipxDestTable[]             = {3,1};
static UINT ids_mipxStaticRouteTable[]      = {3,2};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxDestEntry table (1.3.6.1.4.1.311.1.8.3.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxDestEntry[]             = {3,1,1};
static UINT ids_mipxDestNetNum[]            = {3,1,1,1};
static UINT ids_mipxDestProtocol[]          = {3,1,1,2};
static UINT ids_mipxDestTicks[]             = {3,1,1,3};
static UINT ids_mipxDestHopCount[]          = {3,1,1,4};
static UINT ids_mipxDestNextHopIfIndex[]    = {3,1,1,5};
static UINT ids_mipxDestNextHopMacAddress[] = {3,1,1,6};
static UINT ids_mipxDestFlags[]             = {3,1,1,7};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxStaticRouteEntry table (1.3.6.1.4.1.311.1.8.3.2.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxStaticRouteEntry[]      = {3,2,1};
static UINT ids_mipxStaticRouteIfIndex[]    = {3,2,1,1};
static UINT ids_mipxStaticRouteNetNum[]     = {3,2,1,2};
static UINT ids_mipxStaticRouteEntryStatus[]= {3,2,1,3};
static UINT ids_mipxStaticRouteTicks[]      = {3,2,1,4};
static UINT ids_mipxStaticRouteHopCount[]   = {3,2,1,5};
static UINT ids_mipxStaticRouteNextHopMacAddress[]= {3,2,1,6};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxServices group (1.3.6.1.4.1.311.1.8.4)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxServices[]              = {4};
static UINT ids_mipxServTable[]             = {4,1};
static UINT ids_mipxStaticServTable[]       = {4,2};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxServEntry table (1.3.6.1.4.1.311.1.8.4.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxServEntry[]             = {4,1,1};
static UINT ids_mipxServType[]              = {4,1,1,1};
static UINT ids_mipxServName[]              = {4,1,1,2};
static UINT ids_mipxServProtocol[]          = {4,1,1,3};
static UINT ids_mipxServNetNum[]            = {4,1,1,4};
static UINT ids_mipxServNode[]              = {4,1,1,5};
static UINT ids_mipxServSocket[]            = {4,1,1,6};
static UINT ids_mipxServHopCount[]          = {4,1,1,7};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxStaticServEntry table (1.3.6.1.4.1.311.1.8.4.2.1)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxStaticServEntry[]       = {4,2,1};
static UINT ids_mipxStaticServIfIndex[]     = {4,2,1,1};
static UINT ids_mipxStaticServType[]        = {4,2,1,2};
static UINT ids_mipxStaticServName[]        = {4,2,1,3};
static UINT ids_mipxStaticServEntryStatus[] = {4,2,1,4};
static UINT ids_mipxStaticServNetNum[]      = {4,2,1,5};
static UINT ids_mipxStaticServNode[]        = {4,2,1,6};
static UINT ids_mipxStaticServSocket[]      = {4,2,1,7};
static UINT ids_mipxStaticServHopCount[]    = {4,2,1,8};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibEntry mib_ms_mipx[] = {
    MIB_GROUP(mipxBase),
        MIB_INTEGER(mipxBaseOperState),
        MIB_OCTETSTRING_L(mipxBasePrimaryNetNumber,4,4),
        MIB_OCTETSTRING_L(mipxBaseNode,6,6),
        MIB_OCTETSTRING_L(mipxBaseSysName,0,48),
        MIB_INTEGER_L(mipxBaseMaxPathSplits,1,32),
        MIB_INTEGER(mipxBaseIfCount),
        MIB_INTEGER(mipxBaseDestCount),
        MIB_INTEGER(mipxBaseServCount),
    MIB_GROUP(mipxInterface),
        MIB_TABLE_ROOT(mipxIfTable),
            MIB_TABLE_ENTRY(mipxIfEntry),
                MIB_INTEGER(mipxIfIndex),
                MIB_INTEGER_RW(mipxIfAdminState),
                MIB_INTEGER(mipxIfOperState),
                MIB_INTEGER(mipxIfAdapterIndex),
                MIB_OCTETSTRING_L(mipxIfName,0,48),
                MIB_INTEGER(mipxIfType),
                MIB_INTEGER(mipxIfLocalMaxPacketSize),
                MIB_INTEGER(mipxIfMediaType),
                MIB_OCTETSTRING_L(mipxIfNetNumber,4,4),
                MIB_OCTETSTRING_L(mipxIfMacAddress,6,6),
                MIB_INTEGER(mipxIfDelay),
                MIB_INTEGER(mipxIfThroughput),
                MIB_INTEGER_RW(mipxIfIpxWanEnable),
                MIB_INTEGER_RW(mipxIfNetbiosAccept),
                MIB_INTEGER_RW(mipxIfNetbiosDeliver),
                MIB_COUNTER(mipxIfInHdrErrors),
                MIB_COUNTER(mipxIfInFilterDrops),
                MIB_COUNTER(mipxIfInNoRoutes),
                MIB_COUNTER(mipxIfInDiscards),
                MIB_COUNTER(mipxIfInDelivers),
                MIB_COUNTER(mipxIfOutFilterDrops),
                MIB_COUNTER(mipxIfOutDiscards),
                MIB_COUNTER(mipxIfOutDelivers),
                MIB_COUNTER(mipxIfInNetbiosPackets),
                MIB_COUNTER(mipxIfOutNetbiosPackets),
    MIB_GROUP(mipxForwarding),
        MIB_TABLE_ROOT(mipxDestTable),
            MIB_TABLE_ENTRY(mipxDestEntry),
                MIB_OCTETSTRING_L(mipxDestNetNum,4,4),
                MIB_INTEGER(mipxDestProtocol),
                MIB_INTEGER(mipxDestTicks),
                MIB_INTEGER(mipxDestHopCount),
                MIB_INTEGER(mipxDestNextHopIfIndex),
                MIB_OCTETSTRING_L(mipxDestNextHopMacAddress,6,6),
                MIB_INTEGER_L(mipxDestFlags,0,3),
        MIB_TABLE_ROOT(mipxStaticRouteTable),
            MIB_TABLE_ENTRY(mipxStaticRouteEntry),
                MIB_INTEGER(mipxStaticRouteIfIndex),
                MIB_OCTETSTRING_L(mipxStaticRouteNetNum,4,4),
                MIB_INTEGER_RW(mipxStaticRouteEntryStatus),
                MIB_INTEGER_RW(mipxStaticRouteTicks),
                MIB_INTEGER_RW(mipxStaticRouteHopCount),
                MIB_OCTETSTRING_RW_L(mipxStaticRouteNextHopMacAddress,6,6),
    MIB_GROUP(mipxServices),
        MIB_TABLE_ROOT(mipxServTable),
            MIB_TABLE_ENTRY(mipxServEntry),
                MIB_OCTETSTRING_L(mipxServType,2,2),
                MIB_OCTETSTRING_L(mipxServName,1,48),
                MIB_INTEGER(mipxServProtocol),
                MIB_OCTETSTRING_L(mipxServNetNum,4,4),
                MIB_OCTETSTRING_L(mipxServNode,6,6),
                MIB_OCTETSTRING_L(mipxServSocket,2,2),
                MIB_INTEGER(mipxServHopCount),
        MIB_TABLE_ROOT(mipxStaticServTable),
            MIB_TABLE_ENTRY(mipxStaticServEntry),
                MIB_INTEGER(mipxStaticServIfIndex),
                MIB_OCTETSTRING_L(mipxStaticServType,2,2),
                MIB_OCTETSTRING_L(mipxStaticServName,1,48),
                MIB_INTEGER_RW(mipxStaticServEntryStatus),
                MIB_OCTETSTRING_RW_L(mipxStaticServNetNum,4,4),
                MIB_OCTETSTRING_RW_L(mipxStaticServNode,6,6),
                MIB_OCTETSTRING_RW_L(mipxStaticServSocket,2,2),
                MIB_INTEGER_RW(mipxStaticServHopCount),
    MIB_END()
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib table list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibTable tbl_ms_mipx[] = {
    MIB_TABLE(ms_mipx,mipxIfEntry,NULL),
    MIB_TABLE(ms_mipx,mipxDestEntry,NULL),
    MIB_TABLE(ms_mipx,mipxStaticRouteEntry,NULL),
    MIB_TABLE(ms_mipx,mipxServEntry,NULL),
    MIB_TABLE(ms_mipx,mipxStaticServEntry,NULL)
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// root oid                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ms_mripsap[]                = {1,3,6,1,4,1,311,1,9};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripsapBase group (1.3.6.1.4.1.311.1.9.1)                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
static UINT ids_mripsapBase[]               = {1};
static UINT ids_mripsapBaseRipOperState[]   = {1,1,0};
static UINT ids_mripsapBaseSapOperState[]   = {1,2,0};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripsapInterface group (1.3.6.1.4.1.311.1.9.2)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mripsapInterface[]          = {2};

static UINT ids_mripIfTable[]               = {2,1};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripIfEntry table (1.3.6.1.4.1.311.1.9.2.1.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mripIfEntry[]               = {2,1,1};
static UINT ids_mripIfIndex[]               = {2,1,1,1};
static UINT ids_mripIfAdminState[]          = {2,1,1,2};
static UINT ids_mripIfOperState[]           = {2,1,1,3};
static UINT ids_mripIfUpdateMode[]          = {2,1,1,4};
static UINT ids_mripIfUpdateInterval[]      = {2,1,1,5};
static UINT ids_mripIfAgeMultiplier[]       = {2,1,1,6};
static UINT ids_mripIfSupply[]				= {2,1,1,7};
static UINT ids_mripIfListen[]              = {2,1,1,8};
static UINT ids_mripIfOutPackets[]          = {2,1,1,9};
static UINT ids_mripIfInPackets[]           = {2,1,1,10};


static UINT ids_msapIfTable[]               = {2,2};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// msapIfEntry table (1.3.6.1.4.1.311.1.9.2.2.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_msapIfEntry[]               = {2,2,1};
static UINT ids_msapIfIndex[]               = {2,2,1,1};
static UINT ids_msapIfAdminState[]          = {2,2,1,2};
static UINT ids_msapIfOperState[]           = {2,2,1,3};
static UINT ids_msapIfUpdateMode[]          = {2,2,1,4};
static UINT ids_msapIfUpdateInterval[]      = {2,2,1,5};
static UINT ids_msapIfAgeMultiplier[]       = {2,2,1,6};
static UINT ids_msapIfSupply[]				= {2,2,1,7};
static UINT ids_msapIfListen[]              = {2,2,1,8};
static UINT ids_msapIfGetNearestServerReply[]= {2,2,1,9};
static UINT ids_msapIfOutPackets[]          = {2,2,1,10};
static UINT ids_msapIfInPackets[]           = {2,2,1,11};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibEntry mib_ms_mripsap[] = {
    MIB_GROUP(mripsapBase),
        MIB_INTEGER(mripsapBaseRipOperState),
        MIB_INTEGER(mripsapBaseSapOperState),
    MIB_GROUP(mripsapInterface),
        MIB_TABLE_ROOT(mripIfTable),
            MIB_TABLE_ENTRY(mripIfEntry),
                MIB_INTEGER(mripIfIndex),
                MIB_INTEGER_RW(mripIfAdminState),
                MIB_INTEGER(mripIfOperState),
                MIB_INTEGER_RW(mripIfUpdateMode),
                MIB_INTEGER_RW(mripIfUpdateInterval),
                MIB_INTEGER_RW(mripIfAgeMultiplier),
                MIB_INTEGER_RW(mripIfSupply),
                MIB_INTEGER_RW(mripIfListen),
                MIB_COUNTER(mripIfOutPackets),
                MIB_COUNTER(mripIfInPackets),
        MIB_TABLE_ROOT(msapIfTable),
            MIB_TABLE_ENTRY(msapIfEntry),
                MIB_INTEGER(msapIfIndex),
                MIB_INTEGER_RW(msapIfAdminState),
                MIB_INTEGER(msapIfOperState),
                MIB_INTEGER_RW(msapIfUpdateMode),
                MIB_INTEGER_RW(msapIfUpdateInterval),
                MIB_INTEGER_RW(msapIfAgeMultiplier),
                MIB_INTEGER_RW(msapIfSupply),
                MIB_INTEGER_RW(msapIfListen),
                MIB_INTEGER_RW(msapIfGetNearestServerReply),
                MIB_COUNTER(msapIfOutPackets),
                MIB_COUNTER(msapIfInPackets),
    MIB_END()
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib table list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibTable tbl_ms_mripsap[] = {
    MIB_TABLE(ms_mripsap,mripIfEntry,NULL),
    MIB_TABLE(ms_mripsap,msapIfEntry,NULL)
};



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// root oid                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nv_nipx[]                    = {1,3,6,1,4,1,23,2,5};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxSystem group (1.3.6.1.4.1.23.2.5.1)                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxSystem[]                 = {1};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxBasicSysEntry table (1.3.6.1.4.1.23.2.5.1.1.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
static UINT ids_nipxBasicSysTable[]			={1,1};
static UINT ids_nipxBasicSysEntry[]			={1,1,1};
static UINT ids_nipxBasicSysInstance[]		={1,1,1,1};
static UINT ids_nipxBasicSysExistState[]	={1,1,1,2};
static UINT ids_nipxBasicSysNetNumber[]		={1,1,1,3};
static UINT ids_nipxBasicSysNode[]			={1,1,1,4};
static UINT ids_nipxBasicSysName[]			={1,1,1,5};
static UINT ids_nipxBasicSysInReceives[]	={1,1,1,6};
static UINT ids_nipxBasicSysInHdrErrors[]	={1,1,1,7};
static UINT ids_nipxBasicSysInUnknownSockets[]={1,1,1,8};
static UINT ids_nipxBasicSysInDiscards[]	={1,1,1,9};
static UINT ids_nipxBasicSysInBadChecksums[]={1,1,1,10};
static UINT ids_nipxBasicSysInDelivers[]	={1,1,1,11};
static UINT ids_nipxBasicSysNoRoutes[]		={1,1,1,12};
static UINT ids_nipxBasicSysOutRequests[]	={1,1,1,13};
static UINT ids_nipxBasicSysOutMalformedRequests[]={1,1,1,14};
static UINT ids_nipxBasicSysOutDiscards[]	={1,1,1,15};
static UINT ids_nipxBasicSysOutPackets[]	={1,1,1,16};
static UINT ids_nipxBasicSysConfigSockets[]	={1,1,1,17};
static UINT ids_nipxBasicSysOpenSocketFails[]={1,1,1,18};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxAdvSysEntry table (1.3.6.1.4.1.23.2.5.1.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxAdvSysTable[]			={1,2};
static UINT ids_nipxAdvSysEntry[]			={1,2,1};
static UINT ids_nipxAdvSysInstance[]		={1,2,1,1};
static UINT ids_nipxAdvSysMaxPathSplits[]	={1,2,1,2};
static UINT ids_nipxAdvSysMaxHops[]			={1,2,1,3};
static UINT ids_nipxAdvSysInTooManyHops[]	={1,2,1,4};
static UINT ids_nipxAdvSysInFiltered[]		={1,2,1,5};
static UINT ids_nipxAdvSysInCompressDiscards[]={1,2,1,6};
static UINT ids_nipxAdvSysNETBIOSPackets[]	={1,2,1,7};
static UINT ids_nipxAdvSysForwPackets[]		={1,2,1,8};
static UINT ids_nipxAdvSysOutFiltered[]		={1,2,1,9};
static UINT ids_nipxAdvSysOutCompressDiscards[]={1,2,1,10};
static UINT ids_nipxAdvSysCircCount[]		={1,2,1,11};
static UINT ids_nipxAdvSysDestCount[]		={1,2,1,12};
static UINT ids_nipxAdvSysServCount[]		={1,2,1,13};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircuit group (1.3.6.1.4.1.23.2.5.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxCircuit[]					={2};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircEntry table (1.3.6.1.4.1.23.2.5.2.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxCircTable[]				={2,1};
static UINT ids_nipxCircEntry[]				={2,1,1};
static UINT ids_nipxCircSysInstance[]		={2,1,1,1};
static UINT ids_nipxCircIndex[]				={2,1,1,2};
static UINT ids_nipxCircExistState[]		={2,1,1,3};
static UINT ids_nipxCircOperState[]			={2,1,1,4};
static UINT ids_nipxCircIfIndex[]			={2,1,1,5};
static UINT ids_nipxCircName[]				={2,1,1,6};
static UINT ids_nipxCircType[]				={2,1,1,7};
static UINT ids_nipxCircDialName[]			={2,1,1,8};
static UINT ids_nipxCircLocalMaxPacketSize[]={2,1,1,9};
static UINT ids_nipxCircCompressState[]		={2,1,1,10};
static UINT ids_nipxCircCompressSlots[]		={2,1,1,11};
static UINT ids_nipxCircStaticStatus[]		={2,1,1,12};
static UINT ids_nipxCircCompressedSent[]	={2,1,1,13};
static UINT ids_nipxCircCompressedInitSent[]={2,1,1,14};
static UINT ids_nipxCircCompressedRejectsSent[]={2,1,1,15};
static UINT ids_nipxCircUncompressedSent[]	={2,1,1,16};
static UINT ids_nipxCircCompressedReceived[]={2,1,1,17};
static UINT ids_nipxCircCompressedInitReceived[]={2,1,1,18};
static UINT ids_nipxCircCompressedRejectsReceived[]={2,1,1,19};
static UINT ids_nipxCircUncompressedReceived[]={2,1,1,20};
static UINT ids_nipxCircMediaType[]			={2,1,1,21};
static UINT ids_nipxCircNetNumber[]			={2,1,1,22};
static UINT ids_nipxCircStateChanges[]		={2,1,1,23};
static UINT ids_nipxCircInitFails[]			={2,1,1,24};
static UINT ids_nipxCircDelay[]				={2,1,1,25};
static UINT ids_nipxCircThroughput[]		={2,1,1,26};
static UINT ids_nipxCircNeighRouterName[]	={2,1,1,27};
static UINT ids_nipxCircNeighInternalNetNum[]={2,1,1,28};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxForwarding group (1.3.6.1.4.1.23.2.5.3)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxForwarding[]			={3};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestEntry table (1.3.6.1.4.1.23.2.5.3.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxDestTable[]				={3,1};
static UINT ids_nipxDestEntry[]				={3,1,1};
static UINT ids_nipxDestSysInstance[]		={3,1,1,1};
static UINT ids_nipxDestNetNum[]			={3,1,1,2};
static UINT ids_nipxDestProtocol[]			={3,1,1,3};
static UINT ids_nipxDestTicks[]				={3,1,1,4};
static UINT ids_nipxDestHopCount[]			={3,1,1,5};
static UINT ids_nipxDestNextHopCircIndex[]	={3,1,1,6};
static UINT ids_nipxDestNextHopNICAddress[]	={3,1,1,7};
static UINT ids_nipxDestNextHopNetNum[]		={3,1,1,8};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ids_nipxStaticRouteEntry table (1.3.6.1.4.1.23.2.5.3.1.2)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxStaticRouteTable[]		={3,2};
static UINT ids_nipxStaticRouteEntry[]		={3,2,1};
static UINT ids_nipxStaticRouteSysInstance[]={3,2,1,1};
static UINT ids_nipxStaticRouteCircIndex[]	={3,2,1,2};
static UINT ids_nipxStaticRouteNetNum[]		={3,2,1,3};
static UINT ids_nipxStaticRouteExistState[]	={3,2,1,4};
static UINT ids_nipxStaticRouteTicks[]		={3,2,1,5};
static UINT ids_nipxStaticRouteHopCount[]	={3,2,1,6};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServices group (1.3.6.1.4.1.23.2.5.4)                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxServices[]				={4};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServEntry table (1.3.6.1.4.1.23.2.5.4.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxServTable[]				={4,1};
static UINT ids_nipxServEntry[]				={4,1,1};
static UINT ids_nipxServSysInstance[]		={4,1,1,1};
static UINT ids_nipxServType[]				={4,1,1,2};
static UINT ids_nipxServName[]				={4,1,1,3};
static UINT ids_nipxServProtocol[]			={4,1,1,4};
static UINT ids_nipxServNetNum[]			={4,1,1,5};
static UINT ids_nipxServNode[]				={4,1,1,6};
static UINT ids_nipxServSocket[]			={4,1,1,7};
static UINT ids_nipxServHopCount[]			={4,1,1,8};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestServEntry table (1.3.6.1.4.1.23.2.5.4.2.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxDestServTable[]			={4,2};
static UINT ids_nipxDestServEntry[]			={4,2,1};
static UINT ids_nipxDestServSysInstance[]	={4,2,1,1};
static UINT ids_nipxDestServNetNum[]		={4,2,1,2};
static UINT ids_nipxDestServNode[]			={4,2,1,3};
static UINT ids_nipxDestServSocket[]		={4,2,1,4};
static UINT ids_nipxDestServName[]			={4,2,1,5};
static UINT ids_nipxDestServType[]			={4,2,1,6};
static UINT ids_nipxDestServProtocol[]		={4,2,1,7};
static UINT ids_nipxDestServHopCount[]		={4,2,1,8};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxStaticServEntry table (1.3.6.1.4.1.23.2.5.4.3.1)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxStaticServTable[]		={4,3};
static UINT ids_nipxStaticServEntry[]		={4,3,1};
static UINT ids_nipxStaticServSysInstance[]	={4,3,1,1};
static UINT ids_nipxStaticServCircIndex[]	={4,3,1,2};
static UINT ids_nipxStaticServType[]		={4,3,1,3};
static UINT ids_nipxStaticServName[]		={4,3,1,4};
static UINT ids_nipxStaticServExistState[]	={4,3,1,5};
static UINT ids_nipxStaticServNetNum[]		={4,3,1,6};
static UINT ids_nipxStaticServNode[]		={4,3,1,7};
static UINT ids_nipxStaticServSocket[]		={4,3,1,8};
static UINT ids_nipxStaticServHopCount[]	={4,3,1,9};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibEntry mib_nv_nipx[] = {
	MIB_GROUP(nipxSystem),
		MIB_TABLE_ROOT(nipxBasicSysTable),
			MIB_TABLE_ENTRY(nipxBasicSysEntry),
				MIB_INTEGER(nipxBasicSysInstance),
				MIB_INTEGER(nipxBasicSysExistState),
				MIB_OCTETSTRING_L(nipxBasicSysNetNumber,4,4),
				MIB_OCTETSTRING_L(nipxBasicSysNode,6,6),
				MIB_OCTETSTRING_L(nipxBasicSysName,0,48),
				MIB_COUNTER(nipxBasicSysInReceives),
				MIB_COUNTER(nipxBasicSysInHdrErrors),
				MIB_COUNTER(nipxBasicSysInUnknownSockets),
				MIB_COUNTER(nipxBasicSysInDiscards),
				MIB_COUNTER(nipxBasicSysInBadChecksums),
				MIB_COUNTER(nipxBasicSysInDelivers),
				MIB_COUNTER(nipxBasicSysNoRoutes),
				MIB_COUNTER(nipxBasicSysOutRequests),
				MIB_COUNTER(nipxBasicSysOutMalformedRequests),
				MIB_COUNTER(nipxBasicSysOutDiscards),
				MIB_COUNTER(nipxBasicSysOutPackets),
				MIB_COUNTER(nipxBasicSysConfigSockets),
				MIB_COUNTER(nipxBasicSysOpenSocketFails),
		MIB_TABLE_ROOT(nipxAdvSysTable),
			MIB_TABLE_ENTRY(nipxAdvSysEntry),
				MIB_INTEGER(nipxAdvSysInstance),
				MIB_INTEGER(nipxAdvSysMaxPathSplits),
				MIB_INTEGER(nipxAdvSysMaxHops),
				MIB_COUNTER(nipxAdvSysInTooManyHops),
				MIB_COUNTER(nipxAdvSysInFiltered),
				MIB_COUNTER(nipxAdvSysInCompressDiscards),
				MIB_COUNTER(nipxAdvSysNETBIOSPackets),
				MIB_COUNTER(nipxAdvSysForwPackets),
				MIB_COUNTER(nipxAdvSysOutFiltered),
				MIB_COUNTER(nipxAdvSysOutCompressDiscards),
				MIB_COUNTER(nipxAdvSysCircCount),
				MIB_COUNTER(nipxAdvSysDestCount),
				MIB_COUNTER(nipxAdvSysServCount),
	MIB_GROUP(nipxCircuit),
		MIB_TABLE_ROOT(nipxCircTable),
			MIB_TABLE_ENTRY(nipxCircEntry),
				MIB_INTEGER(nipxCircSysInstance),
				MIB_INTEGER(nipxCircIndex),
				MIB_INTEGER(nipxCircExistState),
				MIB_INTEGER_RW(nipxCircOperState),
				MIB_INTEGER(nipxCircIfIndex),
				MIB_OCTETSTRING_L(nipxCircName,0,48),
				MIB_INTEGER(nipxCircType),
				MIB_OCTETSTRING_L(nipxCircDialName,0,48),
				MIB_INTEGER(nipxCircLocalMaxPacketSize),
				MIB_INTEGER(nipxCircCompressState),
				MIB_INTEGER(nipxCircCompressSlots),
				MIB_INTEGER(nipxCircStaticStatus),
				MIB_COUNTER(nipxCircCompressedSent),
				MIB_COUNTER(nipxCircCompressedInitSent),
				MIB_COUNTER(nipxCircCompressedRejectsSent),
				MIB_COUNTER(nipxCircUncompressedSent),
				MIB_COUNTER(nipxCircCompressedReceived),
				MIB_COUNTER(nipxCircCompressedInitReceived),
				MIB_COUNTER(nipxCircCompressedRejectsReceived),
				MIB_COUNTER(nipxCircUncompressedReceived),
				MIB_OCTETSTRING_L(nipxCircMediaType,2,2),
				MIB_OCTETSTRING_L(nipxCircNetNumber,4,4),
				MIB_COUNTER(nipxCircStateChanges),
				MIB_COUNTER(nipxCircInitFails),
				MIB_INTEGER(nipxCircDelay),
				MIB_INTEGER(nipxCircThroughput),
				MIB_OCTETSTRING_L(nipxCircNeighRouterName,0,48),
				MIB_OCTETSTRING_L(nipxCircNeighInternalNetNum,4,4),
	MIB_GROUP(nipxForwarding),
		MIB_TABLE_ROOT(nipxDestTable),
			MIB_TABLE_ENTRY(nipxDestEntry),
				MIB_INTEGER(nipxDestSysInstance),
				MIB_OCTETSTRING_L(nipxDestNetNum,4,4),
				MIB_INTEGER(nipxDestProtocol),
				MIB_INTEGER(nipxDestTicks),
				MIB_INTEGER(nipxDestHopCount),
				MIB_INTEGER(nipxDestNextHopCircIndex),
				MIB_OCTETSTRING_L(nipxDestNextHopNICAddress,6,6),
				MIB_OCTETSTRING_L(nipxDestNextHopNetNum,4,4),
		MIB_TABLE_ROOT(nipxStaticRouteTable),
			MIB_TABLE_ENTRY(nipxStaticRouteEntry),
				MIB_INTEGER(nipxStaticRouteSysInstance),
				MIB_INTEGER(nipxStaticRouteCircIndex),
				MIB_OCTETSTRING_RW_L(nipxStaticRouteNetNum,4,4),
				MIB_INTEGER_RW(nipxStaticRouteExistState),
				MIB_INTEGER_RW(nipxStaticRouteTicks),
				MIB_INTEGER_RW(nipxStaticRouteHopCount),
	MIB_GROUP(nipxServices),
		MIB_TABLE_ROOT(nipxServTable),
			MIB_TABLE_ENTRY(nipxServEntry),
				MIB_INTEGER(nipxServSysInstance),
				MIB_OCTETSTRING_L(nipxServType,2,2),
				MIB_OCTETSTRING_L(nipxServName,1,48),
				MIB_INTEGER(nipxServProtocol),
				MIB_OCTETSTRING_L(nipxServNetNum,4,4),
				MIB_OCTETSTRING_L(nipxServNode,6,6),
				MIB_OCTETSTRING_L(nipxServSocket,2,2),
				MIB_INTEGER(nipxServHopCount),
		MIB_TABLE_ROOT(nipxDestServTable),
			MIB_TABLE_ENTRY(nipxDestServEntry),
				MIB_INTEGER(nipxDestServSysInstance),
				MIB_OCTETSTRING_L(nipxDestServNetNum,4,4),
				MIB_OCTETSTRING_L(nipxDestServNode,6,6),
				MIB_OCTETSTRING_L(nipxDestServSocket,2,2),
				MIB_OCTETSTRING_L(nipxDestServName,1,48),
				MIB_OCTETSTRING_L(nipxDestServType,2,2),
				MIB_INTEGER(nipxDestServProtocol),
				MIB_INTEGER(nipxDestServHopCount),
		MIB_TABLE_ROOT(nipxStaticServTable),
			MIB_TABLE_ENTRY(nipxStaticServEntry),
				MIB_INTEGER(nipxStaticServSysInstance),
				MIB_INTEGER(nipxStaticServCircIndex),
				MIB_OCTETSTRING_RW_L(nipxStaticServType,2,2),
				MIB_OCTETSTRING_RW_L(nipxStaticServName,1,48),
				MIB_INTEGER_RW(nipxStaticServExistState),
				MIB_OCTETSTRING_RW_L(nipxStaticServNetNum,4,4),
				MIB_OCTETSTRING_RW_L(nipxStaticServNode,6,6),
				MIB_OCTETSTRING_RW_L(nipxStaticServSocket,2,2),
				MIB_INTEGER_RW(nipxStaticServHopCount),
	MIB_END()
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib table list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibTable tbl_nv_nipx[] = {
    MIB_TABLE(nv_nipx,nipxBasicSysEntry,NULL),
    MIB_TABLE(nv_nipx,nipxAdvSysEntry,NULL),
    MIB_TABLE(nv_nipx,nipxCircEntry,NULL),
    MIB_TABLE(nv_nipx,nipxDestEntry,NULL),
	MIB_TABLE(nv_nipx,nipxStaticRouteEntry,NULL),
    MIB_TABLE(nv_nipx,nipxServEntry,NULL),
    MIB_TABLE(nv_nipx,nipxDestServEntry,NULL),
    MIB_TABLE(nv_nipx,nipxStaticServEntry,NULL)
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib view                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// [pmay] This array must have its elements ordered lexigraphically or else
// snmp service will get confused.  This may be a bug on snmp's part.
SnmpMibView v_rtipx[3] =	{
	MIB_VIEW(nv_nipx),
	MIB_VIEW(ms_mipx),
	MIB_VIEW(ms_mripsap)
};

UINT viewIndex = 0;    
SnmpTfxHandle tfxHandle;

#define NUM_VIEWS (sizeof(v_rtipx)/sizeof(SnmpMibView))

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// snmp extension entry points                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL 
SnmpExtensionInit(
    IN     DWORD                 uptimeReference,
       OUT HANDLE *              lpPollForTrapEvent,
       OUT AsnObjectIdentifier * lpFirstSupportedView
    )
{
    DbgTrace (DBG_LOAD, ("\nMIPX: SnmpExtensionInit: entered, nv= %d vi= %d\n", NUM_VIEWS, viewIndex));
     
    // save uptime reference
    g_uptimeReference = uptimeReference;

    // obtain handle to subagent framework
    tfxHandle = SnmpTfxOpen(3,v_rtipx);

    // validate handle
    if (tfxHandle == NULL) {
        DbgTrace (DBG_LOAD, ("MIPX: TfxOpen, result: %ld", GetLastError()));
        return FALSE;
    }

    // pass back first view identifier to master
    *lpFirstSupportedView = v_rtipx[viewIndex++].viewOid;

    // traps not supported yet
    *lpPollForTrapEvent = NULL;

    return TRUE;    
}


BOOL 
SnmpExtensionInitEx(
    OUT AsnObjectIdentifier * lpNextSupportedView
    )
{
    // check if there are views to register
    BOOL fMoreViews = (viewIndex < NUM_VIEWS);

    DbgTrace (DBG_LOAD, ("MIPX: SnmpExtensionInitEx: entered, nv= %d, vi= %d, fm=%d\n", NUM_VIEWS, viewIndex, fMoreViews));

    if (fMoreViews) {

        // pass back next supported view to master 
        *lpNextSupportedView = v_rtipx[viewIndex++].viewOid;
    } 

    // report status
    return fMoreViews;
}


BOOL 
SnmpExtensionQuery(
    IN     BYTE                 requestType,
    IN OUT RFC1157VarBindList * variableBindings,
       OUT AsnInteger *         errorStatus,
       OUT AsnInteger *         errorIndex
    )
{
    // forward to framework
    return SnmpTfxQuery(
                tfxHandle,
                requestType,
                variableBindings,
                errorStatus,
                errorIndex
                );
}


BOOL 
SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger *genericTrap,
    OUT AsnInteger *specificTrap,
    OUT AsnTimeticks *timeStamp,
    OUT RFC1157VarBindList *variableBindings
    )
{
    // no traps
    return FALSE;
}


/*++
*******************************************************************
		D l l M a i n
Routine Description:
	Dll entry point to be called from CRTstartup dll entry point (it
		will be actually an entry point for this dll)
Arguments:
	hinstDLL - handle of DLL module 
	fdwReason - reason for calling function 
	lpvReserved - reserved 
Return Value:
	TRUE - process initialization was performed OK
	FALSE - intialization failed
	
*******************************************************************
--*/
BOOL WINAPI DllMain(
    HINSTANCE  	hinstDLL,
    DWORD  		fdwReason,
    LPVOID  	lpvReserved 
    ) {
	switch (fdwReason) {
	case DLL_PROCESS_ATTACH:	// We are being attached to a new process
		InitializeCriticalSection (&g_ConnectionLock);
        ConnectToRouter ();
		DbgTrace (DBG_LOAD, ("MIPX: Loaded %x", g_MibServerHandle));
		return TRUE;

	case DLL_PROCESS_DETACH:	// The process is exiting
		if (g_MibServerHandle!=0)
			MprAdminMIBServerDisconnect (g_MibServerHandle);
		DeleteCriticalSection (&g_ConnectionLock);
		DbgTrace (DBG_LOAD, ("MIPX: Unloaded\n"));
	default:					// Not interested in all other cases
		return TRUE;
	}
}

//
// Tests whether the remoteaccess service is running.
//
DWORD IsServiceRunning (
        IN PBOOL pbIsRunning)
{
    *pbIsRunning = MprAdminIsServiceRunning(NULL);
    return NO_ERROR;
}

DWORD
ConnectToRouter (
    VOID
    ) {
    DWORD rc;
    BOOL bServiceRunning; 

    // Check to see if the service is running
    //
    if ((rc = IsServiceRunning (&bServiceRunning)) != NO_ERROR)
        return NO_ERROR;

    // If not, return an error
    if (!bServiceRunning) {
        EnterCriticalSection (&g_ConnectionLock);
        g_MibServerHandle = 0;
        LeaveCriticalSection (&g_ConnectionLock);
        return ERROR_SERVICE_DEPENDENCY_FAIL;
    }

    // If we're already connected, return
    else if (g_MibServerHandle)
        return NO_ERROR;
    
    EnterCriticalSection (&g_ConnectionLock);
    if (g_MibServerHandle==0) {
        rc = MprAdminMIBServerConnect (NULL, &g_MibServerHandle);
    	if (rc!=NO_ERROR)
	    	g_MibServerHandle = 0;	// Indicates that we are not connected
        DbgTrace (DBG_LOAD, ("MIPX: Connect to router, result: %ld", rc));
    }
    else
        rc = NO_ERROR;
    LeaveCriticalSection (&g_ConnectionLock);
    
    return rc;
}

//
// Returns TRUE if the router connection is stable, false
// otherwise.
//
BOOL EnsureRouterConnection() {
    return (ConnectToRouter() == NO_ERROR);
    // If we haven't connected, attempt to do so
    //if (g_MibServerHandle == NULL) {
    //    if (ConnectToRouter() == NO_ERROR)
    //        return TRUE;
    //    return FALSE;
    // }

    // If we have a valid handle, m
    //
    //    ? TRUE                                  
    //    : (ConnectToRouter ()==NO_ERROR)        
    // )
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\enum.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: enum.h
//
// History:
//      V Raman	June-25-1997  Created.
//
// Enumeration functions.
//============================================================================


#ifndef _ENUM_H_
#define _ENUM_H_

//----------------------------------------------------------------------------
//
// GROUP_ENUMERATOR
//
//  dwLastGroup         Last group returned by this enumeration.
//
//  dwLastGroupMask     Mask associated with the group in dwLastGroup.
//
//  dwLastSource        Last source returned by this enumeration.
//
//  dwLastSourceMask    Mask associated with the group in dwLastSource.
//
//  dwSignature         Signature to mark this as a valid enumerator
//
//----------------------------------------------------------------------------


typedef struct _GROUP_ENUMERATOR
{
    DWORD           dwLastGroup;

    DWORD           dwLastGroupMask;

    DWORD           dwLastSource;

    DWORD           dwLastSourceMask;

    BOOL            bEnumBegun;

    DWORD           dwSignature;

} GROUP_ENUMERATOR, *PGROUP_ENUMERATOR;


#define MGM_ENUM_SIGNATURE      'ESig'


//----------------------------------------------------------------------------
// GetNextMfe
//
//----------------------------------------------------------------------------

DWORD
GetMfe(
    IN              PMIB_IPMCAST_MFE        pmimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN              DWORD                   dwFlags
);


//----------------------------------------------------------------------------
// GetNextMfe
//
//----------------------------------------------------------------------------

DWORD
GetNextMfe(
    IN              PMIB_IPMCAST_MFE        pmimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries,
    IN              BOOL                    bIncludeFirst,
    IN              DWORD                   dwFlags
);


//----------------------------------------------------------------------------
// VerifyEnumeratorHandle
//
//----------------------------------------------------------------------------

PGROUP_ENUMERATOR
VerifyEnumeratorHandle(
    IN              HANDLE                  hEnum
);


//----------------------------------------------------------------------------
// GetNextGroupMemberships
//
//----------------------------------------------------------------------------

DWORD
GetNextGroupMemberships(
    IN              PGROUP_ENUMERATOR       pgeEnum,
    IN OUT          PDWORD                  pdwBufferSize,
    IN OUT          PBYTE                   pbBuffer,
    IN OUT          PDWORD                  pdwNumEntries
);


//----------------------------------------------------------------------------
// GetNextMembershipsForThisGroup
//
//----------------------------------------------------------------------------

DWORD
GetNextMembershipsForThisGroup(
    IN              PGROUP_ENTRY            pge,
    IN OUT          PGROUP_ENUMERATOR       pgeEnum,
    IN              BOOL                    bIncludeFirst,
    IN OUT          PBYTE                   pbBuffer,
    IN OUT          PDWORD                  pdwNumEntries,
    IN              DWORD                   dwMaxEntries
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\forward.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: forward.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// Wrapper functions for callbacks into IP Router Manager.
//============================================================================

#include "pchmgm.h"
#pragma hdrstop


VOID
GetMfeFromForwarder(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
)
{
    BOOL                        bFound;
    
    DWORD                       dwErr = NO_ERROR, dwInd;

    PLIST_ENTRY                 ple, pleHead;
    
    POUT_IF_ENTRY               poie = NULL;
    
    PIPMCAST_MFE_STATS          pimms = NULL;

    
    TRACEFORWARD4(
        FORWARD, "ENTERED GetMfeFromForwarder : Group : %x, %x : Source : "
        "%x, %x : ", pge-> dwGroupAddr, pge-> dwGroupMask, pse-> dwSourceAddr,
        pse-> dwSourceMask
        );

    
    do
    {
        //
        // if MFE is not in forwarder, do not get it
        //

        if ( !pse-> bInForwarder )
        {
            break;    
        }

        
        //
        // Allocate large enough buffer and set up query
        //

        pimms = MGM_ALLOC( SIZEOF_MFE_STATS( pse-> dwMfeIfCount ) );

        if ( pimms == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "GetMfeFromForwarder : Failed to create MFE of size : %x",
                SIZEOF_MFE_STATS( pse-> dwMfeIfCount )
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pimms, SIZEOF_MFE_STATS( pse-> dwMfeIfCount ) );

        pimms-> dwGroup     = pge-> dwGroupAddr;

        pimms-> dwSource    = pse-> dwSourceAddr;
        
        pimms-> dwSrcMask   = pse-> dwSourceMask;

        pimms-> ulNumOutIf  = pse-> dwMfeIfCount;


        //
        // Get MFE
        //

        dwErr = GET_MFE_CALLBACK()( pimms );
        
        if ( dwErr != NO_ERROR )
        {
            TRACE1(
                ANY, "GetMfeFromForwarder : Failed to get MFE from forwarder"
                ": %x", dwErr
                );

            break;            
        }


        //
        // Update base MFE statistics
        //

        RtlCopyMemory( &pse-> imsStatistics, pimms, SIZEOF_BASIC_MFE_STATS );


    TRACEFORWARD4( 
        FORWARD, "Group : %x, Source : %x, In Interface : %x, #out if : %x",
        pimms-> dwGroup, pimms-> dwSource, pimms-> dwInIfIndex, pimms-> ulNumOutIf
        );

    TRACEFORWARD4( 
        FORWARD, "In Packets : %d, In Bytes : %d, Diff i/f : %d, Q overflow : %d",
        pimms-> ulInPkts, pimms-> ulInOctets, pimms-> ulPktsDifferentIf, 
        pimms-> ulQueueOverflow
        );
            
        
        //
        // Update statistics for each outgoing interface
        //

        pleHead = &pse-> leMfeIfList;
        

        //
        // for each outgoing interface in the MFE present in the KMF
        //
        
        for ( dwInd = 0; dwInd < pimms-> ulNumOutIf; dwInd++ )
        {
            //
            // find the outgoing interface in the MFE maintained
            // by MGM and update the statistics based on what is
            // retrieved by the kernel mode forwarder
            //

            bFound  = FALSE;

            ple     = pleHead-> Flink;

            
            while ( ple != pleHead )
            {
                poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

                //
                // Check if interface has a valid next hop address (non zero)
                // - if it does then assume RAS client interface and do 
                //   the interface matching based on (Interface index +
                //   Next Hop )
                //
                // - otherwise just do it based on the Interface Index
                //
                
                bFound = ( poie-> dwIfIndex == 
                           pimms-> rgiosOutStats[ dwInd ].dwOutIfIndex );
                
                if ( poie-> dwIfNextHopAddr )
                {
                    bFound = bFound &&
                             ( poie-> dwIfNextHopAddr ==
                               pimms-> rgiosOutStats[ dwInd ].dwNextHopAddr );
                }


                if ( bFound )
                {
                    //
                    // Outgoing Interface found in MFE in MGM
                    //
                    
                    break;
                }

                ple = ple-> Flink;
            }


            if ( bFound )
            {
                //
                // Update outgoing interface statistics in MGM
                //

                poie-> imosIfStats.dwOutIfIndex = 
                    pimms-> rgiosOutStats[ dwInd ].dwOutIfIndex;

                poie-> imosIfStats.dwNextHopAddr = 
                    pimms-> rgiosOutStats[ dwInd ].dwNextHopAddr;

                    
                poie-> imosIfStats.ulTtlTooLow   = 
                    pimms-> rgiosOutStats[ dwInd ].ulTtlTooLow;

                poie-> imosIfStats.ulFragNeeded  = 
                    pimms-> rgiosOutStats[ dwInd ].ulFragNeeded;
                    
                poie-> imosIfStats.ulOutPackets  = 
                    pimms-> rgiosOutStats[ dwInd ].ulOutPackets;
                    
                poie-> imosIfStats.ulOutDiscards = 
                    pimms-> rgiosOutStats[ dwInd ].ulOutDiscards;

                TRACEFORWARD4( 
                    FORWARD, "Out If : %d, Frag : %d, Out packets : %d, Out discards : %d",
                    pimms-> rgiosOutStats[ dwInd ].dwOutIfIndex,
                    pimms-> rgiosOutStats[ dwInd ].ulFragNeeded,
                    pimms-> rgiosOutStats[ dwInd ].ulOutPackets,
                    pimms-> rgiosOutStats[ dwInd ].ulOutDiscards
                    );
            }
        }

    } while ( FALSE );


    if ( pimms != NULL )
    {
        MGM_FREE( pimms );
    }

    
    TRACEFORWARD0( FORWARD, "LEAVING GetMfeFromForwarder" );
}


//----------------------------------------------------------------------------
// AddMfeToForwarder
//
//
//----------------------------------------------------------------------------

VOID
AddMfeToForwarder( 
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse, 
    DWORD                       dwTimeout
)
{

    DWORD                       dwErr = NO_ERROR, dwInd = 0;

    PIPMCAST_MFE                pimm = NULL;

    POUT_IF_ENTRY               poie = NULL;

    PLIST_ENTRY                 ple = NULL, pleHead = NULL;

    

    TRACEFORWARD6(
        FORWARD, "ENTERED AddMfeToForwarder : source : %x, %x : Group : "
        "%x, %x : #(out if) : %d : Timeout : %x", pge-> dwGroupAddr, 
        pge-> dwGroupMask, pse-> dwSourceAddr, pse-> dwSourceMask, 
        pse-> dwMfeIfCount, dwTimeout
        );


    do
    {
        //
        // Allocate appropriate sized MFE.
        //

        pimm = MGM_ALLOC( SIZEOF_MFE( pse-> dwMfeIfCount ) );

        if ( pimm == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "AddMfeToForwarder : Failed to create MFE of size : %x",
                SIZEOF_MFE( pse-> dwMfeIfCount )
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pimm, SIZEOF_MFE( pse-> dwMfeIfCount ) );
    

        //
        // fill it up
        //

        pimm-> dwGroup          = pge-> dwGroupAddr;

        pimm-> dwSource         = pse-> dwSourceAddr;

        pimm-> dwSrcMask        = pse-> dwSourceMask;

        pimm-> dwInIfIndex      = (pse-> dwMfeIfCount) ? pse-> dwInIfIndex : 0;

        pimm-> ulNumOutIf       = pse-> dwMfeIfCount;

        pimm-> ulTimeOut        = ( pse-> dwMfeIfCount ) ? 0 : dwTimeout;


        //
        // populate the outgoing interface list
        //

        pleHead = &pse-> leMfeIfList;
        
        for ( ple = pleHead-> Flink ; ple != pleHead; ple = ple-> Flink )
        {
            poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );
            
            pimm-> rgioOutInfo[ dwInd ].dwOutIfIndex = poie-> dwIfIndex;


            if ( poie-> dwIfNextHopAddr )
            {
                pimm-> rgioOutInfo[ dwInd ].dwNextHopAddr = 
                    poie-> dwIfNextHopAddr;
            }

            else
            {
                pimm-> rgioOutInfo[ dwInd ].dwNextHopAddr = pimm-> dwGroup;
            }

            TRACEFORWARD2( 
                FORWARD, "AddMfeToForwarder : Out interface %x, next hop %x", 
                pimm-> rgioOutInfo[ dwInd ].dwOutIfIndex,
                pimm-> rgioOutInfo[ dwInd ].dwNextHopAddr
                );

            pimm-> rgioOutInfo[ dwInd++ ].dwDialContext = 0;
            
        }


        //
        // invoke callback into the IP router manager
        //

        if ( IS_ADD_MFE_CALLBACK() )
        {
            ADD_MFE_CALLBACK() ( pimm );
        }

        MGM_FREE( pimm );
        
    } while ( FALSE );
    

    TRACEFORWARD1( FORWARD, "LEAVING AddMfeToForwarder %x", dwErr );
    
    return;
}



//----------------------------------------------------------------------------
// DeleteMfeFromForwarder
//
//
//----------------------------------------------------------------------------

VOID
DeleteMfeFromForwarder(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
)
{
    DWORD                       dwErr = NO_ERROR;

    PIPMCAST_DELETE_MFE         pimdm = NULL;
    


    TRACEFORWARD4(
        FORWARD, "ENTERED DeleteMfeToForwarder : source : %x, %x : Group : "
        "%x, %x : Timeout : %x", pge-> dwGroupAddr, pge-> dwGroupMask, 
        pse-> dwSourceAddr, pse-> dwSourceMask
        );
        
    do
    {

        //
        // Allocate appropriate sized MFE.
        //

        pimdm = MGM_ALLOC( sizeof( IPMCAST_DELETE_MFE ) );

        if ( pimdm == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "DeleteMfeFromForwarder : Failed to create MFE of size :"
                " %x", sizeof( IPMCAST_DELETE_MFE )
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pimdm, sizeof( IPMCAST_DELETE_MFE ) );

        
        //
        // fill it up
        //

        pimdm-> dwGroup         = pge-> dwGroupAddr;

        pimdm-> dwSource        = pse-> dwSourceAddr;

        pimdm-> dwSrcMask       = pse-> dwSourceMask;


        //
        // invoke callback into the IP router manager
        //

        if ( IS_DELETE_MFE_CALLBACK() )
        {
            DELETE_MFE_CALLBACK() ( pimdm );
        }

        MGM_FREE( pimdm );


    } while ( FALSE );

    
    TRACEFORWARD1( FORWARD, "LEAVING DeleteMfeToForwarder %x", dwErr );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\enum.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: enum.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// Enumeration functions exported to IP Router Manager.
//============================================================================


#include "pchmgm.h"
#pragma hdrstop


DWORD
GetGroupMfes(
    IN              PGROUP_ENTRY            pge,
    IN              DWORD                   dwStartSource,
    IN OUT          PBYTE                   pbBuffer,
    IN              DWORD                   dwBufferSize,
    IN OUT          PDWORD                  pdwSize,
    IN OUT          PDWORD                  pdwNumEntries,
    IN              BOOL                    bIncludeFirst,
    IN              DWORD                   dwFlags
);


VOID
CopyMfe(
    IN              PGROUP_ENTRY            pge,
    IN              PSOURCE_ENTRY           pse,
    IN  OUT         PBYTE                   pb,
    IN              DWORD                   dwFlags
);



//
// MFE enumeration
//

//----------------------------------------------------------------------------
// GetNextMfe
//
//----------------------------------------------------------------------------

DWORD
GetMfe(
    IN              PMIB_IPMCAST_MFE        pmimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN              DWORD                   dwFlags
)
{

    BOOL                bGrpLock = FALSE, bGrpEntryLock = FALSE;
    
    DWORD               dwErr = NO_ERROR, dwGrpBucket, dwSrcBucket, dwSizeReqd,
                        dwInd;

    PGROUP_ENTRY        pge;

    PSOURCE_ENTRY       pse;

    POUT_IF_ENTRY       poie;

    PLIST_ENTRY         ple, pleHead;



    TRACEENUM3( 
        ENUM, "ENTERED GetMfe : %x, %x, Stats : %x", pmimm-> dwGroup, 
        pmimm-> dwSource, dwFlags
        );
    
    do
    {
        //
        // Find group entry
        //

        dwGrpBucket = GROUP_TABLE_HASH( pmimm-> dwGroup, 0 );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );
        bGrpLock = TRUE;
        
        pleHead = GROUP_BUCKET_HEAD( dwGrpBucket );

        pge = GetGroupEntry( pleHead, pmimm-> dwGroup, 0 );

        if ( pge == NULL )
        {
            //
            // group entry not found, quit 
            //

            dwErr = ERROR_NOT_FOUND;

            break;
        }


        //
        // acquire group entry lock and release group bucket lock
        //
        
        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        bGrpEntryLock = TRUE;


        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
        bGrpLock = FALSE;

        
        //
        // Find Source entry
        //

        dwSrcBucket = SOURCE_TABLE_HASH( pmimm-> dwSource, pmimm-> dwSrcMask );

        pleHead = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

        pse = GetSourceEntry( pleHead, pmimm-> dwSource, pmimm-> dwSrcMask );

        if ( pse == NULL )
        {
            //
            // Source entry not found, quit
            //

            dwErr = ERROR_NOT_FOUND;

            break;
        }
        
        
        //
        // check buffersize requirements 
        //

        dwSizeReqd = ( dwFlags ) ?
                        ( (dwFlags == MGM_MFE_STATS_0) ?
                           SIZEOF_MIB_MFE_STATS( pse-> dwMfeIfCount ) :
                           SIZEOF_MIB_MFE_STATS_EX( 
                            pse-> dwMfeIfCount ) ) :
                        SIZEOF_MIB_MFE( pse-> dwMfeIfCount );

        if ( *pdwBufferSize < dwSizeReqd )
        {
            //
            // buffer supplied is too small to fit the MFE
            //
            
            *pdwBufferSize = dwSizeReqd;

            dwErr = ERROR_INSUFFICIENT_BUFFER;

            break;
        }

        
        //
        // if mfe statistics have been requested and
        //    mfe is in the kernel 
        //      get it 
        //

        if ( dwFlags && pse-> bInForwarder )
        {
            GetMfeFromForwarder( pge, pse );
        }

#if 1
        CopyMfe( pge, pse, pbBuffer, dwFlags );
#else        
        //
        // copy base MFE into user supplied buffer
        //

        pmimms = ( PMIB_IPMCAST_MFE_STATS ) pbBuffer;

        pmimms-> dwGroup            = pge-> dwGroupAddr;
        pmimms-> dwSource           = pse-> dwSourceAddr;
        pmimms-> dwSrcMask          = pse-> dwSourceMask;

        pmimms-> dwInIfIndex        = pse-> dwInIfIndex;
        pmimms-> dwUpStrmNgbr       = pse-> dwUpstreamNeighbor;
        pmimms-> dwInIfProtocol     = pse-> dwInProtocolId;

        pmimms-> dwRouteProtocol    = pse-> dwRouteProtocol;
        pmimms-> dwRouteNetwork     = pse-> dwRouteNetwork;
        pmimms-> dwRouteMask        = pse-> dwRouteMask;
        
        pmimms-> ulNumOutIf         = pse-> imsStatistics.ulNumOutIf;
        pmimms-> ulInPkts           = pse-> imsStatistics.ulInPkts;
        pmimms-> ulInOctets         = pse-> imsStatistics.ulInOctets;
        pmimms-> ulPktsDifferentIf  = pse-> imsStatistics.ulPktsDifferentIf;
        pmimms-> ulQueueOverflow    = pse-> imsStatistics.ulQueueOverflow;

        
        MgmElapsedSecs( &pse-> liCreationTime, &pmimms-> ulUpTime );
                                        
        pmimms-> ulExpiryTime = pse-> dwTimeOut - pmimms-> ulUpTime;


        //
        // copy all the OIL entries
        //

        pleHead = &pse-> leMfeIfList;
        
        for ( ple = pleHead-> Flink, dwInd = 0; 
              ple != pleHead; 
              ple = ple-> Flink, dwInd++ )
        {
            poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

            pmimms-> rgmiosOutStats[ dwInd ].dwOutIfIndex = 
                poie-> imosIfStats.dwOutIfIndex;
                
            pmimms-> rgmiosOutStats[ dwInd ].dwNextHopAddr = 
                poie-> imosIfStats.dwNextHopAddr;
                
            pmimms-> rgmiosOutStats[ dwInd ].ulTtlTooLow = 
                poie-> imosIfStats.ulTtlTooLow;
                
            pmimms-> rgmiosOutStats[ dwInd ].ulFragNeeded = 
                poie-> imosIfStats.ulFragNeeded;
                
            pmimms-> rgmiosOutStats[ dwInd ].ulOutPackets = 
                poie-> imosIfStats.ulOutPackets;
                
            pmimms-> rgmiosOutStats[ dwInd ].ulOutDiscards = 
                poie-> imosIfStats.ulOutDiscards;
        }
#endif

    } while ( FALSE );


    //
    // release locks are appropriate
    //
    
    if ( bGrpEntryLock )
    {
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }

    if ( bGrpLock )
    {
        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
    }


    TRACEENUM1( ENUM, "LEAVING GetMfe :: %x", dwErr );
    
    return dwErr;
}



//----------------------------------------------------------------------------
// GetNextMfe
//
//----------------------------------------------------------------------------

DWORD
GetNextMfe(
    IN              PMIB_IPMCAST_MFE        pmimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries,
    IN              BOOL                    bIncludeFirst,
    IN              DWORD                   dwFlags
)
{

    BOOL            bFound, bgeLock = FALSE;
    
    DWORD           dwGrpBucket, dwErr = NO_ERROR, dwBufferLeft, 
                    dwStartSource, dwSize;

    PBYTE           pbStart;
    
    PGROUP_ENTRY    pge;
    
    PLIST_ENTRY     ple, pleMasterHead, pleGrpBucket;

    

    TRACEENUM2( 
        ENUM, "ENTERED GetNextMfe (G, S) = (%x, %x)", pmimmStart-> dwGroup, 
        pmimmStart-> dwSource 
        );


    do
    {
        //
        // 1. Lock group hash bucket.
        //

        dwGrpBucket = GROUP_TABLE_HASH( pmimmStart-> dwGroup, 0 );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

                
        //
        // 2. merge temp and master lists
        //      - Lock temp list
        //      - merge temp with master list
        //      - unlock temp list
        //

        ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE();

        MergeTempAndMasterGroupLists( TEMP_GROUP_LIST_HEAD() );

        ACQUIRE_MASTER_GROUP_LOCK_SHARED();

        RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE();


        pleMasterHead = MASTER_GROUP_LIST_HEAD();

        ple = pleMasterHead-> Flink;

        //
        // To retrieve the next set of group entries in lexicographic order, 
        // given a group entry (in this case specified by pmimmStart-> dwGroup)
        // the master group list must be walked from the head until either 
        // the group entry specified is found or the next "higher" group entry 
        // is found.  This is expensive.
        //
        // As an optimization the group specified (pmimmStart-> dwGroup) is
        // looked up in the group hash table.  If an entry is found, then the
        // group entry contains links into the master (lexicographic) group
        // list. These links can the used to determine the next entries in 
        // the group list.  This way we can quickly find an group entry in
        // the master list rather than walk the master group list from the
        // beginning.
        //
        // It should be noted that in case the group entry specified in not
        // present in the group hash table, it will be necessary to walk the
        // master group list from the start.
        //
        // Each group entry is present in two lists, the hash bucket list 
        // and either temp group list or the master group list.
        //
        // For this optimization to "work", it must be ensured that an entry
        // present in the hash table is also present in the master
        // group list.  To ensure this the temp group list is merged into
        // the master group list before searching the group hash table for
        // the specified entry.
        //

        
        //
        // At this point the group under consideration (pmimmStart-> dwGroup),
        // cannot be added to either the hash bucket or master group list
        // if it is not already present because both the group hash bucket lock
        // and the master list lock have been acquired.
        //

        //
        // 3. find group entry in the hash list
        //

        pleGrpBucket = GROUP_BUCKET_HEAD( dwGrpBucket );
        
        pge = GetGroupEntry( pleGrpBucket, pmimmStart-> dwGroup, 0 );

        if ( pge != NULL )
        {
            //
            // group entry for pmimmStart-> dwGroup is present. lock the entry.
            //

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            bgeLock = TRUE;

            //
            // release group hash bucket lock
            //

            RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
        }
        
        else
        {
            
            //
            // group entry is not present in the hash table, which implies
            // that the group entry is not present at all.
            //

            //
            // release group hash bucket lock
            //

            RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
            
            //
            // 3.1 Walk master list from the start to determine the next 
            //     highest group entry.
            //

            bFound = FindGroupEntry( 
                        pleMasterHead, pmimmStart-> dwGroup, 0,
                        &pge, FALSE
                        );

            if ( !bFound && pge == NULL )
            {
                //
                // No more group entries left to enumerate
                //

                dwErr = ERROR_NO_MORE_ITEMS;

                RELEASE_MASTER_GROUP_LOCK_SHARED();

                break;
            }


            //
            // Next group entry found.  lock it
            //

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            bgeLock = TRUE;

            bIncludeFirst = TRUE;
        }


        //
        // At this point we have the group entry we want which is
        // either the one for pmimmStart-> dwGroup OR the next higher
        // one (if there is no group entry for pmimmStart-> Group).
        //

        //
        // 4. Now get as many source entries as will fit into 
        //    the buffer provided.
        //

        dwBufferLeft    = *pdwBufferSize;

        pbStart         = pbBuffer;

        *pdwNumEntries  = 0;

        dwStartSource   = ( bIncludeFirst ) ? 0 : pmimmStart-> dwSource;

        dwSize          = 0;

        
        while ( ( dwErr = GetGroupMfes( pge, dwStartSource, pbStart, 
                              dwBufferLeft, &dwSize, pdwNumEntries, 
                              bIncludeFirst, dwFlags ) ) 
                == ERROR_MORE_DATA )
        {
            //
            // more data items will fit into this buffer, but no more 
            // source entries available in this group entry
            //
            // 4.1 Move forward to next group entry.
            //

            pbStart         += dwSize;

            dwBufferLeft    -= dwSize;

            dwSize          = 0;

            dwStartSource   = 0;

            
            //
            // 4.1.1 Release this group entry lock
            //
            
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );


            //
            // 4.1.2 get next entry lock
            //

            ple = pge-> leGrpList.Flink;

            if ( ple == pleMasterHead )
            {
                //
                // No more group entries in the master group list.
                // All MFEs have been exhausted. So quit.
                //
                
                dwErr = ERROR_NO_MORE_ITEMS;

                bgeLock = FALSE;
                
                break;
            }

            pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpList );

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

            dwStartSource = 0;

            bIncludeFirst = TRUE;
        }


        //
        // 5. you have packed as much as possible into the buffer
        //
        //  Clean up and return the correct error code.
        //
        
        if ( bgeLock )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }


        if ( dwErr == ERROR_INSUFFICIENT_BUFFER )
        {
            //
            // ran out of buffer.  If there is at least one Mfe
            // packed into the buffer provided then it is ok.
            //

            if ( *pdwNumEntries != 0 )
            {
                dwErr = ERROR_MORE_DATA;
            }

            else
            {
                //
                // not even one entry could be packed into the buffer
                // return the size required for this so that an
                // appropriately sized buffer can be allocated for the
                // next call.
                //

                *pdwBufferSize = dwSize;
            }
        }

        RELEASE_MASTER_GROUP_LOCK_SHARED();
        
    } while ( FALSE );


    TRACEENUM1( ENUM, "LEAVING GetNextMfe : %x", dwErr );

    return dwErr;
}



//----------------------------------------------------------------------------
//
// GetGroupMfes
//
// Retrieves as many MFEs for a group starting at the specified source.
// Assumes that the group entry is locked.
//----------------------------------------------------------------------------

DWORD
GetGroupMfes(
    IN              PGROUP_ENTRY            pge,
    IN              DWORD                   dwStartSource,
    IN OUT          PBYTE                   pbBuffer,
    IN              DWORD                   dwBufferSize,
    IN OUT          PDWORD                  pdwSize,
    IN OUT          PDWORD                  pdwNumEntries,
    IN              BOOL                    bIncludeFirst,
    IN              DWORD                   dwFlags
)
{

    BOOL            bFound;
    
    DWORD           dwErr = ERROR_MORE_DATA, dwSrcBucket,
                    dwSizeReqd, dwInd;

    PSOURCE_ENTRY   pse = NULL;

    PLIST_ENTRY     pleMasterHead, pleSrcBucket, ple = NULL,
                    pleSrc;
    
    POUT_IF_ENTRY   poie = NULL;


    TRACEENUM2( 
        ENUM, "ENTERED GetGroupMfes : %x, %x", 
        pge-> dwGroupAddr, dwStartSource
        );

    do
    {
        //
        // merge temp and group source lists
        //

        MergeTempAndMasterSourceLists( pge );

        
        //
        // similar to the group lookup, optimize the source lookup
        // by first trying to find the source entry in the source
        // hash table.  
        //
        // If found in the hash table then use the entry's links 
        // the into master source list to find next entry.
        //
        // if not found in the hash table walk the master list from
        // the beginning to determine the next entry.
        //

        pleMasterHead   = MASTER_SOURCE_LIST_HEAD( pge );

        dwSrcBucket     = SOURCE_TABLE_HASH( dwStartSource, 0 );

        pleSrcBucket    = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );


        bFound = FindSourceEntry( pleSrcBucket, dwStartSource, 0, &pse, TRUE );

        if ( !bFound )
        {
            //
            // source entry is not present in the hash table
            // Walk the master source list from the start.
            //

            pse = NULL;
            
            FindSourceEntry( pleMasterHead, 0, 0, &pse, FALSE );


            //
            // No next entry found in the master list.  Implies
            // no more sources in the master source list for this group.
            //
            
            if ( pse == NULL )
            {
                break;
            }
        }

        else
        {
            //
            // Entry for starting source found in hash table.
            // Use its links into the master list to get next entry.
            //

            if ( !bIncludeFirst )
            {
                ple = pse-> leSrcList.Flink;

                pse = CONTAINING_RECORD( ple, SOURCE_ENTRY, leSrcList );
            }
        }


        //
        // At this point the entry pointed to by pse is the first entry
        // the needs to be packed into the buffer supplied.  Starting
        // with this source entry keep packing MFEs into the
        // buffer till there are no more MFEs for this group.
        //
        
        pleSrc = &pse-> leSrcList;

        //
        // while there are source entries for this group entry
        //
        
        while ( pleSrc != pleMasterHead )
        {
            pse = CONTAINING_RECORD( pleSrc, SOURCE_ENTRY, leSrcList );


            //
            // Is this source entry an MFE
            //
            
            if ( !IS_VALID_INTERFACE( pse-> dwInIfIndex, 
                    pse-> dwInIfNextHopAddr ) )
            {
                pleSrc = pleSrc-> Flink;

                continue;
            }


            //
            // This source entry is an MFE also.
            //

            //
            // Check if enough space left in the buffer to fit this MFE.
            //
            // If not and not a single MFE is present in the buffer then
            // return the size required to fit this MFE.
            //
            
            dwSizeReqd = ( dwFlags ) ? 
                            ( ( dwFlags == MGM_MFE_STATS_0 ) ?
                                SIZEOF_MIB_MFE_STATS( pse-> dwMfeIfCount ) :
                                SIZEOF_MIB_MFE_STATS_EX( 
                                    pse-> dwMfeIfCount 
                                ) ) :
                            SIZEOF_MIB_MFE( pse-> dwMfeIfCount );

            if ( dwBufferSize < dwSizeReqd )
            {
                dwErr = ERROR_INSUFFICIENT_BUFFER;

                if ( *pdwNumEntries == 0 )
                {
                    *pdwSize = dwSizeReqd;
                }

                break;
            }


            //
            // If MFE stats have been requested and
            //    MFE is present in the forwarder
            //      get them.
            //

            if ( dwFlags && pse-> bInForwarder )
            {
                //
                // MFE is currently in the forwarder.  Query it and update
                // stats user mode.
                //

                GetMfeFromForwarder( pge, pse );
            }

            
            //
            // copy base MFE into user supplied buffer
            //


            CopyMfe( pge, pse, pbBuffer, dwFlags );

            pbBuffer        += dwSizeReqd;

            dwBufferSize    -= dwSizeReqd;

            *pdwSize        += dwSizeReqd;

            (*pdwNumEntries)++;

            pleSrc           = pleSrc-> Flink;
        }
        
    } while ( FALSE );


    TRACEENUM2( ENUM, "LEAVING GetGroupsMfes : %d %d", *pdwNumEntries, dwErr );

    return dwErr;
}


//============================================================================
// Group Enumeration
//
//============================================================================


PGROUP_ENUMERATOR
VerifyEnumeratorHandle(
    IN              HANDLE                  hEnum
)
{

    DWORD                       dwErr;
    
    PGROUP_ENUMERATOR           pgeEnum;


    
    pgeEnum = (PGROUP_ENUMERATOR) 
                        ( ( (ULONG_PTR) hEnum ) 
                                ^ (ULONG_PTR) MGM_ENUM_HANDLE_TAG );

    try
    {
        if ( pgeEnum-> dwSignature != MGM_ENUM_SIGNATURE )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            TRACE0( ANY, "Invalid Enumeration handle" );

            pgeEnum = NULL;
        }
    }
    
    except ( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? 
                                   EXCEPTION_EXECUTE_HANDLER :
                                   EXCEPTION_CONTINUE_SEARCH )
    {
        dwErr = ERROR_INVALID_PARAMETER;

        TRACE0( ANY, "Invalid enumeration handle" );
        
        pgeEnum = NULL;
    }

    return pgeEnum;
}


//
// Get Memberships for buckets
//

DWORD
GetNextGroupMemberships(
    IN              PGROUP_ENUMERATOR       pgeEnum,
    IN OUT          PDWORD                  pdwBufferSize,
    IN OUT          PBYTE                   pbBuffer,
    IN OUT          PDWORD                  pdwNumEntries
)
{

    BOOL            bIncludeFirst = TRUE, bFound;

    DWORD           dwMaxEntries, dwGrpBucket, dwErr = ERROR_NO_MORE_ITEMS;

    PGROUP_ENTRY    pge = NULL;

    PSOURCE_GROUP_ENTRY psge;
    
    PLIST_ENTRY     ple, pleGrpHead;


    
    do
    {
        //
        // Compute the number of entries that will fit into the buffer
        //

        dwMaxEntries = (*pdwBufferSize) / sizeof( SOURCE_GROUP_ENTRY );


        //
        // STEP I :
        //

        //
        // position the start of the GetNext to the group entry that was
        // the last enumerated by the previous GetNext operation
        //

        //
        // Find the last group entry retrieved by the previous get operation. 
        //

        dwGrpBucket = GROUP_TABLE_HASH( 
                        pgeEnum-> dwLastGroup, pgeEnum-> dwLastGroupMask 
                        );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

        pleGrpHead = GROUP_BUCKET_HEAD( dwGrpBucket );
        
        bFound = FindGroupEntry( 
                    pleGrpHead, pgeEnum-> dwLastGroup, 
                    pgeEnum-> dwLastGroupMask, &pge, TRUE
                    );

        if ( bFound )
        {
            //
            // group entry found
            //
            
            bIncludeFirst = !pgeEnum-> bEnumBegun;
        }

        

        //
        // last group entry retrieved by previous getnext is no 
        // longer present
        //

        //
        // check if there are any more group entries present in 
        // the same bucket
        //

        else if ( pge != NULL )
        {
            //
            // Next group entry in the same group bucket.  
            // For a new group start from the first source bucket, 
            // first source entry. 
            //

            pgeEnum-> dwLastSource      = 0;
            pgeEnum-> dwLastSourceMask  = 0;
        }

        
        else // ( pge == NULL )
        {
            //
            // no more entries in this group bucket, move to next
            // non-empty group bucket entry.
            //

            //
            // skip empty buckets in the group hash table
            //
            
            do
            {
                RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );

                dwGrpBucket++;

                if ( dwGrpBucket >= GROUP_TABLE_SIZE ) 
                {
                    //
                    // Entire hash table has been traversed, quit
                    //

                    break;
                }

                //
                // Move to next group bucket
                //
                
                ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

                pleGrpHead = GROUP_BUCKET_HEAD( dwGrpBucket );


                //
                // Check if any group entries present
                //
                
                if ( !IsListEmpty( pleGrpHead ) )
                {
                    //
                    // group bucket has at least on group entry
                    //
                    
                    pge = CONTAINING_RECORD( 
                            pleGrpHead-> Flink, GROUP_ENTRY, leGrpHashList
                            );

                    //
                    // For a new group start from the first source bucket, 
                    // first source entry. 
                    //

                    pgeEnum-> dwLastSource      = 0;
                    pgeEnum-> dwLastSourceMask  = 0;

                    break;
                }

                //
                // Empty group bucket, move to next one
                //
                
            } while ( TRUE );
        }
        

        //
        // if all hash buckets have been traversed, quit.
        //
        
        if ( dwGrpBucket >= GROUP_TABLE_SIZE )
        {
            break;
        }
        

        //
        // STEP II:
        //

        //
        // start retrieving group membership entries
        //
        
        ple = &pge-> leGrpHashList;
        

        //
        // Walk each hash bucket starting from dwGrpBucket to GROUP_TABLE_SIZE
        //

        while ( dwGrpBucket < GROUP_TABLE_SIZE )
        {
            //
            // For each group hash table bucket
            //
            
            while ( ple != pleGrpHead )
            {
                //
                // For each group entry in the bucket
                //

                pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpHashList );

                ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pge );
                
                dwErr = GetNextMembershipsForThisGroup( 
                            pge, pgeEnum, bIncludeFirst, pbBuffer,
                            pdwNumEntries, dwMaxEntries
                            );

                RELEASE_GROUP_ENTRY_LOCK_SHARED( pge );
                
                if ( dwErr == ERROR_MORE_DATA )
                {
                    //
                    // User supplied buffer is full.
                    //

                    break;
                }
                

                //
                // Move to next entry
                //
                
                ple = ple-> Flink;

                //
                // Next group entry in the same group bucket.  
                // For a new group start from the first source bucket, 
                // first source entry. 
                //
                
                pgeEnum-> dwLastSource = 0;
                
                pgeEnum-> dwLastSourceMask = 0;

                bIncludeFirst = TRUE;
            }

            RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );

            if ( dwErr == ERROR_MORE_DATA )
            {
                break;
            }


            //
            // Move to next group bucket
            //
            
            dwGrpBucket++;

            //
            // skip empty group hash buckets
            //
            
            while ( dwGrpBucket < GROUP_TABLE_SIZE )
            {
                ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

                pleGrpHead = GROUP_BUCKET_HEAD( dwGrpBucket );

                if ( !IsListEmpty( pleGrpHead ) )
                {
                    break;
                }

                RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );

                dwGrpBucket++;
            } 

            
            if ( dwGrpBucket >= GROUP_TABLE_SIZE )
            {
                //
                // All group buckets have traversed.  End of enumeration
                //
                
                dwErr = ERROR_NO_MORE_ITEMS;
            }

            else
            {
                //
                // New group hash bucket, start from source entry 0.
                //
                
                ple = pleGrpHead-> Flink;
                
                pgeEnum-> dwLastSource      = 0;
                pgeEnum-> dwLastSourceMask  = 0;
                bIncludeFirst               = TRUE;
            }            
        }
        
    } while ( FALSE );

    pgeEnum-> bEnumBegun    = TRUE;


    //
    // Store the position where the enumeration ended
    //
    
    psge = (PSOURCE_GROUP_ENTRY) pbBuffer;

    if ( *pdwNumEntries )
    {
        pgeEnum-> dwLastSource      = psge[ *pdwNumEntries - 1 ].dwSourceAddr;
        
        pgeEnum-> dwLastSourceMask  = psge[ *pdwNumEntries - 1 ].dwSourceMask;
        
        pgeEnum-> dwLastGroup       = psge[ *pdwNumEntries - 1 ].dwGroupAddr;
        
        pgeEnum-> dwLastGroupMask   = psge[ *pdwNumEntries - 1 ].dwGroupMask;
    }

    else
    {
        pgeEnum-> dwLastSource      = 0xFFFFFFFF;
        
        pgeEnum-> dwLastSourceMask  = 0xFFFFFFFF;
        
        pgeEnum-> dwLastGroup       = 0xFFFFFFFF;
        
        pgeEnum-> dwLastGroupMask   = 0xFFFFFFFF;
    }
    
    return dwErr;
}


//----------------------------------------------------------------------------
// GetMemberships for Group
//
//----------------------------------------------------------------------------

DWORD
GetNextMembershipsForThisGroup(
    IN              PGROUP_ENTRY            pge,
    IN OUT          PGROUP_ENUMERATOR       pgeEnum,
    IN              BOOL                    bIncludeFirst,
    IN OUT          PBYTE                   pbBuffer,
    IN OUT          PDWORD                  pdwNumEntries,
    IN              DWORD                   dwMaxEntries
)
{

    BOOL                    bFound;
    
    DWORD                   dwErr = ERROR_NO_MORE_ITEMS, dwSrcBucket;

    PSOURCE_GROUP_ENTRY     psgBuffer;
    
    PSOURCE_ENTRY           pse = NULL;
    
    PLIST_ENTRY             pleSrcHead, ple;

    
    
    do
    {

        if ( *pdwNumEntries >= dwMaxEntries )
        {
            //
            // quit here.
            //

            dwErr = ERROR_MORE_DATA;

            break;
        }

        
        psgBuffer = (PSOURCE_GROUP_ENTRY) pbBuffer;
        

        //
        // STEP I:
        // Position start of enumeration  
        //

        dwSrcBucket = SOURCE_TABLE_HASH( 
                        pgeEnum-> dwLastSource, pgeEnum-> dwLastSourceMask 
                        );
                        
        pleSrcHead = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

        bFound = FindSourceEntry(
                    pleSrcHead, pgeEnum-> dwLastSource, 
                    pgeEnum-> dwLastSourceMask, &pse, TRUE
                    );

        if ( bFound )
        {
            if ( ( bIncludeFirst ) && !IsListEmpty( &pse-> leOutIfList ) )
            {
                //
                // the first group membership found.
                //

                psgBuffer[ *pdwNumEntries ].dwSourceAddr = pse-> dwSourceAddr;
                
                psgBuffer[ *pdwNumEntries ].dwSourceMask = pse-> dwSourceMask;

                psgBuffer[ *pdwNumEntries ].dwGroupAddr   = pge-> dwGroupAddr;

                psgBuffer[ (*pdwNumEntries)++ ].dwGroupMask  = pge-> dwGroupMask;
                
                if ( *pdwNumEntries >= dwMaxEntries )
                {
                    //
                    // buffer full. quit here.
                    //

                    dwErr = ERROR_MORE_DATA;

                    break;
                }

                //
                // move to next source
                //

                ple = pse-> leSrcHashList.Flink;
            }

            else
            {
                ple = pse-> leSrcHashList.Flink;
            }
        }

        else if ( pse != NULL )
        {
            ple = &pse-> leSrcHashList;
        }

        else
        {
            ple = pleSrcHead-> Flink;
        }

        
        //
        // STEP II:
        //
        // enumerate group memberships
        //

        while ( *pdwNumEntries < dwMaxEntries ) 
        {
            //
            // for each source bucket
            //
            
            while ( ( ple != pleSrcHead ) && 
                    ( *pdwNumEntries < dwMaxEntries ) )
            {
                //
                // for each source entry in the bucket
                //

                //
                // if group membership exists for this source
                //

                pse = CONTAINING_RECORD( ple, SOURCE_ENTRY, leSrcHashList );
                
                if ( !IsListEmpty( &pse-> leOutIfList ) )
                {
                    psgBuffer[ *pdwNumEntries ].dwSourceAddr = 
                        pse-> dwSourceAddr;
                    
                    psgBuffer[ *pdwNumEntries ].dwSourceMask = 
                        pse-> dwSourceMask;

                    psgBuffer[ *pdwNumEntries ].dwGroupAddr   = 
                        pge-> dwGroupAddr;

                    psgBuffer[ (*pdwNumEntries)++ ].dwGroupMask  = 
                        pge-> dwGroupMask;
                    
                    if ( *pdwNumEntries >= dwMaxEntries )
                    {
                        dwErr = ERROR_MORE_DATA;
                    }
                }

                ple = ple-> Flink;
            }

            dwSrcBucket++;

            if ( dwSrcBucket < SOURCE_TABLE_SIZE )
            {
                pleSrcHead = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

                ple = pleSrcHead-> Flink;
            }

            else
            {
                //
                // all source buckets for this group have been 
                // traversed.  quit this group entry
                //
                
                break;
            }
        }
        
    } while ( FALSE );

    return dwErr;
}


//----------------------------------------------------------------------------
// Copy the MFE (optionally with stats) 
//
//----------------------------------------------------------------------------

VOID
CopyMfe(
    IN              PGROUP_ENTRY            pge,
    IN              PSOURCE_ENTRY           pse,
    IN  OUT         PBYTE                   pb,
    IN              DWORD                   dwFlags
)
{
    DWORD                   dwInd;
    
    PLIST_ENTRY             ple, pleHead;
    
    POUT_IF_ENTRY           poie;
    
    PMIB_IPMCAST_MFE        pmimm = NULL;

    PMIB_IPMCAST_MFE_STATS  pmimms = NULL;

    PMIB_IPMCAST_OIF_STATS  pmimos = NULL;
   
    //
    // copy base MFE into user supplied buffer
    //

    if ( dwFlags )
    {
        //
        // Need to base MFE
        //

        pmimms = ( PMIB_IPMCAST_MFE_STATS ) pb;

        pmimms-> dwGroup            = pge-> dwGroupAddr;
        pmimms-> dwSource           = pse-> dwSourceAddr;
        pmimms-> dwSrcMask          = pse-> dwSourceMask;

        pmimms-> dwInIfIndex        = pse-> dwInIfIndex;
        pmimms-> dwUpStrmNgbr       = pse-> dwUpstreamNeighbor;
        pmimms-> dwInIfProtocol     = pse-> dwInProtocolId;
        
        pmimms-> dwRouteProtocol    = pse-> dwRouteProtocol;
        pmimms-> dwRouteNetwork     = pse-> dwRouteNetwork;
        pmimms-> dwRouteMask        = pse-> dwRouteMask;
        
        MgmElapsedSecs( &pse-> liCreationTime, &pmimms-> ulUpTime );

        pmimms-> ulExpiryTime = pse-> dwTimeOut - pmimms-> ulUpTime;
        

        //
        // Copy incoming stats
        //
        
        pmimms-> ulNumOutIf         = pse-> dwMfeIfCount;
        pmimms-> ulInPkts           = pse-> imsStatistics.ulInPkts;
        pmimms-> ulInOctets         = pse-> imsStatistics.ulInOctets;
        pmimms-> ulPktsDifferentIf  = pse-> imsStatistics.ulPktsDifferentIf;
        pmimms-> ulQueueOverflow    = pse-> imsStatistics.ulQueueOverflow;

        if ( dwFlags & MGM_MFE_STATS_1 )
        {
            PMIB_IPMCAST_MFE_STATS_EX  pmimmsex = 
                ( PMIB_IPMCAST_MFE_STATS_EX ) pb;

            pmimmsex-> ulUninitMfe      = pse-> imsStatistics.ulUninitMfe;
            pmimmsex-> ulNegativeMfe    = pse-> imsStatistics.ulNegativeMfe;
            pmimmsex-> ulInDiscards     = pse-> imsStatistics.ulInDiscards;
            pmimmsex-> ulInHdrErrors    = pse-> imsStatistics.ulInHdrErrors;
            pmimmsex-> ulTotalOutPackets= pse-> imsStatistics.ulTotalOutPackets;

            pmimos = pmimmsex-> rgmiosOutStats;
        }

        else
        {
            pmimos = pmimms-> rgmiosOutStats;
        }

        //
        // copy all the OIL entries
        //

        pleHead = &pse-> leMfeIfList;
        
        for ( ple = pleHead-> Flink, dwInd = 0; 
              ple != pleHead; 
              ple = ple-> Flink, dwInd++ )
        {
            poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

            pmimos[ dwInd ].dwOutIfIndex = poie-> dwIfIndex;
            pmimos[ dwInd ].dwNextHopAddr = poie-> dwIfNextHopAddr;

            //
            // Copy outgoing stats
            //
            
            pmimos[ dwInd ].ulTtlTooLow = poie-> imosIfStats.ulTtlTooLow;
            pmimos[ dwInd ].ulFragNeeded = poie-> imosIfStats.ulFragNeeded;
            pmimos[ dwInd ].ulOutPackets = poie-> imosIfStats.ulOutPackets;
            pmimos[ dwInd ].ulOutDiscards = poie-> imosIfStats.ulOutDiscards;
        }
    }

    else
    {
        //
        // Need to copy non-stats MFE structure only
        //

        pmimm = (PMIB_IPMCAST_MFE) pb;

        pmimm-> dwGroup             = pge-> dwGroupAddr;
        pmimm-> dwSource            = pse-> dwSourceAddr;
        pmimm-> dwSrcMask           = pse-> dwSourceMask;

        pmimm-> dwInIfIndex         = pse-> dwInIfIndex;
        pmimm-> dwUpStrmNgbr        = pse-> dwUpstreamNeighbor;
        pmimm-> dwInIfProtocol      = pse-> dwInProtocolId;

        pmimm-> dwRouteProtocol     = pse-> dwRouteProtocol;
        pmimm-> dwRouteNetwork      = pse-> dwRouteNetwork;
        pmimm-> dwRouteMask         = pse-> dwRouteMask;
        
        pmimm-> ulNumOutIf          = pse-> dwMfeIfCount;

        MgmElapsedSecs( &pse-> liCreationTime, &pmimm-> ulUpTime );

        pmimm-> ulExpiryTime = pse-> dwTimeOut - pmimm-> ulUpTime;


        //
        // copy all the OIL entries minus the stats
        //

        pleHead = &pse-> leMfeIfList;
        
        for ( ple = pleHead-> Flink, dwInd = 0; 
              ple != pleHead; 
              ple = ple-> Flink, dwInd++ )
        {
            poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

            pmimm-> rgmioOutInfo[ dwInd ].dwOutIfIndex = 
                poie-> dwIfIndex;
                
            pmimm-> rgmioOutInfo[ dwInd ].dwNextHopAddr = 
                poie-> dwIfNextHopAddr;
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\group.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: group.h
//
// History:
//      V Raman	July-11-1997  Created.
//
// Data structures for and declarations for routines that manipulate 
// group and sources entries
//============================================================================


#ifndef _GROUP_H_
#define _GROUP_H_


//----------------------------------------------------------------------------
// OUT_IF_ENTRY
//
// Each OUT_IF_ENTRY stores information about an outgoing interface in an
// MFE.  The fields in the structure are :
//
//  leIfList        -           link to next entry in the outgoing interface
//                              list.
//  dwIfIndex       -           Index of interface 
//
//  dwNextHopIfAddr -           For interfaces with same index the next hop
//                              address is used to distinguish them
//
//  dwProtocolId    -           Protocol id of the routing protocol component
//                              that owns dwIfIndex
//
//  dwComponentId   -           Component id of the routing protocol component
//                              that owns dwIfIndex
//
//  wCreatedForFlag -           Indicates if the interface entry was created
//                              explicitly by a protocol or implicitly by
//                              MGM (as a consequence of the interface being
//                              being present in the Outgoing Interface list
//                              of the corresponding (*, G) or (*, *) entry.
//
//  dwAddedByFlag   -           if the interface entry is created by a 
//                              routing protocol then it could have been 
//                              created by both IGMP or by a full fledged 
//                              routing protocol (or both).  This flag is 
//                              used to distinguish both.
//
//  wNumAddsByIGMP  -           Count of number of times this interface has 
//                              been added to the OIL by IGMP.  Can be at most
//                              2, once for a (*, G) addition and once for an
//                              (S, G) addition.
//
//  wNumAddsByRP    -           Count of number of times this interface has 
//                              been added to the OIL by the RP on this 
//                              interface.  Can be at most
//                              3, once for a (*, *) addition, once for a 
//                              (*, G) addition and once for an (S, G) 
//                              addition.
//
//  misIfStats      -           Statistics for this outgoing interface.
//
//----------------------------------------------------------------------------

typedef struct _OUT_IF_ENTRY
{
    LIST_ENTRY                  leIfList;

    DWORD                       dwIfIndex;

    DWORD                       dwIfNextHopAddr;

    DWORD                       dwProtocolId;

    DWORD                       dwComponentId;

    WORD                        wForward;
    
    WORD                        wAddedByFlag;

    WORD                        wNumAddsByIGMP;

    WORD                        wNumAddsByRP;

    IPMCAST_OIF_STATS           imosIfStats;

} OUT_IF_ENTRY, *POUT_IF_ENTRY;


//
// Macros to manipulate bit flags in OUT_IF_ENTRY
// 

#define     ADDED_BY_IGMP                   (DWORD) 0x8000
#define     ADDED_BY_ROUTING_PROTOCOL       (DWORD) 0x4000


#define     SET_ADDED_BY_IGMP( p ) \
            (p)-> wAddedByFlag |= ADDED_BY_IGMP

#define     CLEAR_ADDED_BY_IGMP( p ) \
            (p)-> wAddedByFlag &= ~ADDED_BY_IGMP

#define     IS_ADDED_BY_IGMP( p ) \
            ( (p)-> wAddedByFlag & ADDED_BY_IGMP )


#define     SET_ADDED_BY_PROTOCOL( p ) \
            (p)-> wAddedByFlag |= ADDED_BY_ROUTING_PROTOCOL

#define     CLEAR_ADDED_BY_PROTOCOL( p ) \
            (p)-> wAddedByFlag &= ~ADDED_BY_ROUTING_PROTOCOL

#define     IS_ADDED_BY_PROTOCOL( p ) \
            ( (p)-> wAddedByFlag & ADDED_BY_ROUTING_PROTOCOL )


//----------------------------------------------------------------------------
// SOURCE_ENTRY
//
// Each SOURCE_ENTRY represents information about a specific source for a
// specific group.  The source can also be the wildcard source created by a
// (*, G) join for a group.  A source entry is either explicitly created by 
// a source specific (S, G) join or implicitly by MGM when creating an MFE
// in response to packet arrival.
//
// leSrcList        -           Links along the lexicographically ordered
//                              source list
//
// leSrcHashList    -           Links along the source hash table.
//
// leScopedIfList   -           List of interfaces that have been joined
//                              but administratively scoped out.
//
// leOutIfList      -           Outgoing interface list.  Entries in this
//                              list are created as a result of explicit
//                              (S, G) joins by a protocol
//
// leMfeIfList      -           Outgoing interface list created when an MFE
//                              for this source, for this group is created
//                              by MGM.  This list is created by MGM
//                              when a new packet for this (source, group)
//                              and respresents the merge of the outgoing
//                              interface lists of the (*, *) entry, (*, G)
//                              entry and the (S,G) entry.
//
// dwOutIfCount     -           Count of number of entries in leOutIfList.
//                              Used to determine callback order.
//
// dwOutIfCompCount -           Count of number of protocol components that 
//                              have added interfaces to the outgoing list.
//                              Used to determine the order of callbacks to
//                              routing protocols
//
// dwSourceAddr     -           IP Address of source.
//
// dwSourceMask     -           IP mask corresponding to dwSourceAddr
//
// dwInIfIndex      -           Interface index of the incmoing interface.
//                              A source entry is considered to be an MFE
//                              if it has a valid incoming interface.
//
// dwInIfNextHopAddr    -       next hop address for dwInIfIndex
//
// dwInProtocolId   -           Protocol Id of the protocol owning dwInIfIndex
//
// dwInComponentId  -           Component Id of the protocol component owning
//                              dwIfInIndex
//
// bInForwarder     -           Flag indicating if the MFE is present in the
//                              kernel mode forwarder.
//
// liExpiryTime     -           Expiration time of the source entry.
//
// mgmGrpStatistics -           Statistics associated with this (S, G) entry
//
//----------------------------------------------------------------------------

typedef struct _SOURCE_ENTRY
{
    LIST_ENTRY                  leSrcList;
    
    LIST_ENTRY                  leSrcHashList;

    DWORD                       dwInUse;
    
    DWORD                       dwOutIfCount;
    
    DWORD                       dwOutCompCount;
    
    LIST_ENTRY                  leOutIfList;

    LIST_ENTRY                  leScopedIfList;

    DWORD                       dwMfeIfCount;
    
    LIST_ENTRY                  leMfeIfList;

    DWORD                       dwSourceAddr;

    DWORD                       dwSourceMask;

    DWORD                       dwInIfIndex;

    DWORD                       dwInIfNextHopAddr;

    DWORD                       dwUpstreamNeighbor;

    DWORD                       dwRouteProtocol;

    DWORD                       dwRouteNetwork;

    DWORD                       dwRouteMask;
    
    DWORD                       dwInProtocolId;

    DWORD                       dwInComponentId;

    BOOL                        bInForwarder;

    HANDLE                      hTimer;

    DWORD                       dwTimeOut;
    
    LARGE_INTEGER               liCreationTime;

    IPMCAST_MFE_STATS           imsStatistics;

} SOURCE_ENTRY, *PSOURCE_ENTRY;


#define MGM_SOURCE_ENUM_SIGNATURE   'sMGM'


//----------------------------------------------------------------------------
// GROUP_ENTRY
//
// Each group entry contains information for a specific group that has been
// explicitly added by a protocol (or implicitly by MGM).  The group can 
// a wildcard group created by a (*, *) join.
//
// leGrpList        -           Links along the lexicographically ordered 
//                              group list.
//
// leGrpHashList    -           Links along the group hash bucket.
//
// dwGroupAddr      -           Group address of entry.
//
// dwGroupMask      -           Mask corresponding to the group address
//
// leSourceList     -           Head of lexicographically ordered source list
//
// pleSrcHashTable  -           hash table of source entries for this group
//
//----------------------------------------------------------------------------

typedef struct _GROUP_ENTRY
{
    LIST_ENTRY                  leGrpList;
    
    LIST_ENTRY                  leGrpHashList;

    DWORD                       dwGroupAddr;

    DWORD                       dwGroupMask;

    PMGM_READ_WRITE_LOCK        pmrwlLock;


    DWORD                       dwSourceCount;


    DWORD                       dwNumTempEntries;

    LIST_ENTRY                  leTempSrcList;
    
    LIST_ENTRY                  leSourceList;
    
    LIST_ENTRY                  pleSrcHashTable[1];
    
} GROUP_ENTRY, *PGROUP_ENTRY;


#define MGM_GROUP_ENUM_SIGNATURE    'gMGM'



DWORD
CreateGroupEntry(
    PLIST_ENTRY                 pleHashList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PGROUP_ENTRY *              ppge
);


PGROUP_ENTRY
GetGroupEntry(
    PLIST_ENTRY                 pleGroupList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask
);


VOID
DeleteGroupEntry(
    PGROUP_ENTRY                pge
);


BOOL
FindGroupEntry(
    PLIST_ENTRY                 pleGroupList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PGROUP_ENTRY *              ppge,
    BOOL                        bHashList
);


DWORD
CreateSourceEntry(
    PGROUP_ENTRY                pge,
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    PSOURCE_ENTRY *             ppse
);


PSOURCE_ENTRY
GetSourceEntry(
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask
);


VOID
DeleteSourceEntry(
    PSOURCE_ENTRY               pse
);


BOOL
FindSourceEntry(
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    PSOURCE_ENTRY *             ppse,
    BOOL                        bHashList
);


DWORD
CreateOutInterfaceEntry(
    PLIST_ENTRY                 pleOutIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    POUT_IF_ENTRY *             ppoie
);


POUT_IF_ENTRY
GetOutInterfaceEntry(
    PLIST_ENTRY                 pleOutIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId
);


VOID
DeleteOutInterfaceEntry(
    POUT_IF_ENTRY               poie
);


BOOL
FindOutInterfaceEntry(
    PLIST_ENTRY                 pleOutIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    PBOOL                       pbNewComponent,   
    POUT_IF_ENTRY *             ppoie
);


DWORD
AddInterfaceToSourceEntry(
    PPROTOCOL_ENTRY             ppe,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    BOOL                        bIGMP,
    PBOOL                       pbUpdateMfe,
    PLIST_ENTRY                 pleSourceList
);


VOID
AddInterfaceToAllMfeInGroupBucket(
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    DWORD                       dwInd,
    BOOL                        bIGMP,
    BOOL                        bAdd,
    PLIST_ENTRY                 pleSourceList
);


VOID
AddInterfaceToGroupMfe(
    PGROUP_ENTRY                pge,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    BOOL                        bAdd,
    PLIST_ENTRY                    pleSourceList
);


VOID
AddInterfaceToSourceMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    POUT_IF_ENTRY *             ppoie
);


VOID
DeleteInterfaceFromSourceEntry(
    PPROTOCOL_ENTRY             ppe,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    BOOL                        bIGMP
);


VOID
DeleteInterfaceFromAllMfe(
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP
    
);


VOID
DeleteInterfaceFromGroupMfe(
    PGROUP_ENTRY                pge,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP
    
);


VOID
DeleteInterfaceFromSourceMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    BOOL                        bDel
);


VOID
LookupAndDeleteYourMfe(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bDeleteTimer,
    PDWORD                      pdwInIfIndex            OPTIONAL,
    PDWORD                      pdwInIfNextHopAddr      OPTIONAL
    
);


VOID
DeleteMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
);



VOID
MergeTempAndMasterGroupLists(
    PLIST_ENTRY                 pleTempList
);


VOID
MergeTempAndMasterSourceLists(
    PGROUP_ENTRY                pge
);

#endif // _GROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\forward.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: forward.h
//
// History:
//      V Raman	June-25-1997  Created.
//
// Declarations for wrapper functions for callbacks into IP Router Manager.
// These functions represent the interface for MGM to the kernel mode
// forwarder.
//============================================================================


#ifndef _FORWARD_H_
#define _FORWARD_H_

VOID
GetMfeFromForwarder(
);


VOID
AddMfeToForwarder( 
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse, 
    DWORD                       dwTimeout
);


VOID
DeleteMfeFromForwarder(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
);

//
// New Packet recevied API.  Used to notify MGM of packet arrival.
// MGM creates an MFE in response to this.
//

DWORD
MgmNewPacketReceived(
    IN              DWORD                   dwSourceAddr,
    IN              DWORD                   dwGroupAddr,
    IN              DWORD                   dwInIfIndex,
    IN              DWORD                   dwInIfNextHopAddr,
    IN              DWORD                   dwHdrSize,
    IN              PBYTE                   pbPacketHdr
);


DWORD 
WrongIfFromForwarder(
    IN              DWORD               dwSourceAddr,
    IN              DWORD               dwGroupAddr,
    IN              DWORD               dwInIfIndex,
    IN              DWORD               dwInIfNextHopAddr,
    IN              DWORD               dwHdrSize,
    IN              PBYTE               pbPacketHdr
);


#endif // _FORWARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\if.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: if.c
//
// History:
//      V Raman    June-25-1997  Created.
//
// routines that manipulate interface entries
//============================================================================

#include "pchmgm.h"
#pragma hdrstop


//----------------------------------------------------------------------------
// CreateIfEntry
//
// This function creates a new interface entry. Duh
// Assumes that the interface list is locked.
//----------------------------------------------------------------------------

DWORD
CreateIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId
)
{

    DWORD                       dwErr = NO_ERROR;

    PIF_ENTRY                   pie = NULL, pieEntry = NULL;


    TRACEIF4( 
        IF, 
        "ENTERED CreateIfEntry : Interface %x, %x : Protocol %x, %x",
        dwIfIndex, dwIfNextHopAddr, dwProtocolId, dwComponentId
        );

        
    do
    {
        //
        // allocate an interface entry.
        //

        pie = MGM_ALLOC( sizeof( IF_ENTRY ) );

        if ( pie == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "CreateIfEntry : Failed to allocate entry %x", dwErr 
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pie, sizeof( IF_ENTRY ) );

        
        //
        // init. i/f structure
        //
        
        pie-> dwIfIndex             = dwIfIndex;

        pie-> dwIfNextHopAddr       = dwIfNextHopAddr;

        pie-> dwOwningProtocol      = dwProtocolId;

        pie-> dwOwningComponent     = dwComponentId;

        pie-> wAddedByFlag          = 0;

        
        if ( IS_PROTOCOL_ID_IGMP( dwProtocolId ) )
        {
            SET_ADDED_BY_IGMP( pie );
        }

        else
        {
            SET_ADDED_BY_PROTOCOL( pie );
        }


        InitializeListHead( &pie-> leInIfList );

        InitializeListHead( &pie-> leOutIfList );

        
        //
        // insert in protocol list
        //

        InitializeListHead( &pie-> leIfHashList );
        
        InsertTailList( pleIfList, &pie-> leIfHashList );

        
    } while ( FALSE );


    TRACEIF1( IF, "LEAVING CreateIfEntry : %x", dwErr );
    
    return dwErr;
}



//----------------------------------------------------------------------------
// DeleteIfEntry
//
// This function deletes an interface entry. Duh
// Assumes that the interface list is locked.
//----------------------------------------------------------------------------

VOID
DeleteIfEntry(
    PIF_ENTRY                   pieEntry
)
{
    TRACEIF0( IF, "ENTERED DeleteIfEntry" );
    
    RemoveEntryList( &pieEntry-> leIfHashList );

    MGM_FREE( pieEntry );

    TRACEIF0( IF, "LEAVING DeleteIfEntry" );
}



//----------------------------------------------------------------------------
// GetIfEntry
//
// This function retrieves an interface entry. Duh
//
// Assumes that the interface list is locked.
//----------------------------------------------------------------------------

PIF_ENTRY
GetIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr
)
{
    PIF_ENTRY                   pie;

    if ( FindIfEntry( pleIfList, dwIfIndex, dwIfNextHopAddr, &pie ) )
    {
        return pie;
    }

    return NULL;
}

//----------------------------------------------------------------------------
// FindIfEntry
//
// This function retrieves an interface entry. Duh
//
// Assumes that the interface list is locked.
//----------------------------------------------------------------------------

BOOL
FindIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    PIF_ENTRY *                 ppie
)
{
    BOOL                        bFound = FALSE;

    INT                         iCmp = 0;
    
    PIF_ENTRY                   pie = NULL;

    PLIST_ENTRY                 ple = NULL;


    TRACEIF2( IF, "ENTERED FindIfEntry : %x, %x", dwIfIndex, dwIfNextHopAddr );

    //
    // Scan interface list.  Interface list is ordered by 
    // interface index, next hop address
    //

    *ppie = NULL;

    
    for ( ple = pleIfList-> Flink; ple != pleIfList; ple = ple-> Flink )
    {
        pie = CONTAINING_RECORD( ple, IF_ENTRY, leIfHashList );

        if ( pie-> dwIfIndex < dwIfIndex )
        {
            continue;
        }

        else if ( pie-> dwIfIndex > dwIfIndex )
        {
            //
            // Entry not present
            //

            *ppie = pie;

            break;
        }

        
        if ( INET_CMP( pie-> dwIfNextHopAddr, dwIfNextHopAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            *ppie = pie;
            
            break;
        }

        *ppie = pie;

        bFound = TRUE;

        break;
    }

    TRACEIF1( IF, "LEAVING FindIfEntry : %x", bFound );
    
    return bFound;
}


//----------------------------------------------------------------------------
// AddSourceToOutList
//
// Each interface entry maintains a list of (source, group) entries that
// reference this interface in their outgoing interface list.  Each time
// membership entry is added the (source, group) to the reference list.
// When this interface is eventually deleted these (source, group) entries
// need to be updated to reflect the deletion of this interface.
//
// Assumes that the interface entry is locked.
//----------------------------------------------------------------------------

VOID
AddSourceToRefList(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bIGMP
)
{
    BOOL                        bFound = FALSE; 

    DWORD                       dwErr = NO_ERROR;
    
    PIF_REFERENCE_ENTRY         pire = NULL, pireNew = NULL;


    TRACEIF5( 
        IF, 
        "ENTERED AddSourceToIfEntry : Source %x, %x : Group %x, %x"
        " : IGMP %x",
        dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask, bIGMP
        );

    do
    {
        //
        // Check if reference already present
        //


        bFound = FindRefEntry( 
                    pleRefList, dwSourceAddr, dwSourceMask, 
                    dwGroupAddr, dwGroupMask, &pire
                    );
                    

        if ( !bFound )
        {
            //
            // no previous reference for this (source, group) was found
            // create a new one.
            //

            pireNew = MGM_ALLOC( sizeof( IF_REFERENCE_ENTRY ) );

            if ( pireNew == NULL )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                TRACE1( 
                    ANY, 
                    "AddSourceToOutList : Failed to allocate reference entry %x",
                    dwErr
                    );

                LOGERR0( HEAP_ALLOC_FAILED, dwErr );

                break;
            }

            ZeroMemory( pireNew, sizeof( IF_REFERENCE_ENTRY ) );
            

            pireNew-> dwSourceAddr  = dwSourceAddr;

            pireNew-> dwSourceMask  = dwSourceMask;

            pireNew-> dwGroupAddr   = dwGroupAddr;

            pireNew-> dwGroupMask   = dwGroupMask;

            pireNew-> wAddedByFlag  = 0;

            
            //
            // set the appropriate bit for the protocol
            //
            
            if ( bIGMP )
            {
                SET_ADDED_BY_IGMP( pireNew );
            }
            
            else
            {
                SET_ADDED_BY_PROTOCOL( pireNew );
            }


            //
            // insert into ref list
            //
            
            if ( pire == NULL )
            {
                InsertTailList( pleRefList, &pireNew-> leRefList );
            }

            else
            {
                InsertTailList( &pire-> leRefList, &pireNew-> leRefList );
            }
        }

        else
        {
            //
            // set the appropriate bit for the protocol
            //
            
            if ( bIGMP )
            {
                SET_ADDED_BY_IGMP( pire );
            }
            
            else
            {
                SET_ADDED_BY_PROTOCOL( pire );
            }
        }
                
    } while ( FALSE );


    TRACEIF1( IF, "LEAVING AddSourceToRefList : %x", bFound );
    
    return;
}



//----------------------------------------------------------------------------
// DeleeSourceFomrRefList
//
// Delete a reference to a (source, group).
//----------------------------------------------------------------------------

VOID
DeleteSourceFromRefList(
    PLIST_ENTRY                 pleIfRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bIGMP
)
{
    BOOL                    bFound = FALSE; 

    PIF_REFERENCE_ENTRY     pire = NULL, pireEntry = NULL;


    TRACEIF5( 
        IF, 
        "ENTERED DeleteSourceFromIfEntry : Source %x %x, Group : %x, %x"
        " : IGMP %x",
        dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask, bIGMP
        );
    

    //
    // find the entry is already present.
    // list is arranged in descending order in terms of
    // Group address, source address
    //

    bFound = FindRefEntry( 
                pleIfRefList, dwSourceAddr, dwSourceMask, 
                dwGroupAddr, dwGroupMask, &pire
                );
                    
    //
    // if entry was not found
    //

    if ( !bFound )
    {
        TRACE1( IF, "LEAVING DeleteSourceFromRefList : %x", FALSE );

        return;
    }


    //
    // reset the appropriate bit for the protocol
    //
            
    if ( bIGMP )
    {
        CLEAR_ADDED_BY_IGMP( pire );
    }
            
    else
    {
        CLEAR_ADDED_BY_PROTOCOL( pire );
    }


    //
    // if no more references left, remove this entry
    //

    if ( !IS_ADDED_BY_IGMP( pire ) &&
         !IS_ADDED_BY_PROTOCOL( pire ) )
    {
        RemoveEntryList( &pire-> leRefList );

        MGM_FREE( pire );
    }

    TRACEIF1( IF, "LEAVING DeleteSourceFromRefList : %x", TRUE );

    return;
}



//----------------------------------------------------------------------------
// FindRefEntry
//
// Locate a reference entry.  If not found return the expected location in 
// the list.
//----------------------------------------------------------------------------

BOOL
FindRefEntry(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PIF_REFERENCE_ENTRY *       ppire
)
{
    INT                         iCmp;
    
    PLIST_ENTRY                 ple = NULL;

    PIF_REFERENCE_ENTRY         pire = NULL;

    BOOL                        bFound = FALSE;
    

    TRACEIF4( 
        IF, 
        "ENTERED FindRefEntry : Source %x, %x : Group %x, %x",
        dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask
        );
    

    *ppire = NULL;
    

    for ( ple = pleRefList-> Flink; ple != pleRefList; ple = ple-> Flink )
    {
        pire = CONTAINING_RECORD( ple, IF_REFERENCE_ENTRY, leRefList );

        if ( INET_CMP( pire-> dwGroupAddr, dwGroupAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            *ppire = pire;

            break;
        }
        
        if ( INET_CMP( pire-> dwSourceAddr, dwSourceAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            *ppire = pire;

            break;
        }
        
        //
        // entry found
        //

        *ppire = pire;

        bFound = TRUE;
        
        break;
    }

    TRACEIF1( IF, "LEAVING FindRefEntry : %x", bFound );

    return bFound;
}



//----------------------------------------------------------------------------
// DeleteOutInterfaceRefs
//
// When a interface is deleted by a protocol (or IGMP) all (source, group)
// entries that use this interface in their outgoing interface lists have to
// be updated to reflect ththe deletion.  
//
//----------------------------------------------------------------------------

VOID
DeleteOutInterfaceRefs(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie,
    BOOL                        bIGMP
)
{
    PLIST_ENTRY                 ple = NULL, pleRefList = NULL, pleNext = NULL;

    PIF_REFERENCE_ENTRY         pire = NULL;



    TRACEIF1( IF, "ENTERED DeleteOutInterfaceRefs: IGMP %x", bIGMP );
    
    do
    {
        //
        // No references for this interface in any outgoing 
        // interface lists of source entries
        //

        pleRefList = &pie-> leOutIfList;
        
        if ( IsListEmpty( pleRefList ) )
        {
            break;
        }


        //
        // walk the reference list and remove the (source, group) entries
        // for each reference
        //

        for ( ple = pleRefList-> Flink; ple != pleRefList; )
        {
            pire = CONTAINING_RECORD( ple, IF_REFERENCE_ENTRY, leRefList );

            
            //
            // was this reference added by this protocol
            //

            if ( ( bIGMP && !IS_ADDED_BY_IGMP( pire ) ) ||
                 ( !bIGMP && !IS_ADDED_BY_PROTOCOL( pire ) ) )
            {
                //
                // no, skip it
                //

                ple = ple-> Flink;
                
                continue;
            }

            
            //
            // Delete this interface from the (source, group) entry. 
            //

            DeleteInterfaceFromSourceEntry(
                ppe,
                pire-> dwGroupAddr, pire-> dwGroupMask,
                pire-> dwSourceAddr, pire-> dwSourceMask,
                pie-> dwIfIndex, pie-> dwIfNextHopAddr,
                bIGMP
                );


            if ( bIGMP )
            {
                CLEAR_ADDED_BY_IGMP( pire );
            }

            else
            {
                CLEAR_ADDED_BY_PROTOCOL( pire );
            }


            //
            // remove reference entry.
            //
            
            if ( !IS_ADDED_BY_IGMP( pire ) &&
                 !IS_ADDED_BY_PROTOCOL( pire ) )
            {
                //
                // no more references to interface for IGMP
                // or for routing protocol.
                // remove this reference entry altogether.
                //

                pleNext = ple-> Flink;
                
                RemoveEntryList( ple );

                MGM_FREE ( pire );

                ple = pleNext;
            }

            else
            {
                ple = ple-> Flink;
            }
        }
        
    } while ( FALSE );

    TRACEIF0( IF, "LEAVING DeleteOutInterfaceRefs:" );

    return;
}



//----------------------------------------------------------------------------
// DeleteInInterfaceRefs
//
// When a interface is deleted by a protocol (or IGMP) all (source, group)
// entries that use this interface as their incoming interface have to
// be updated to reflect the deletion.   
//----------------------------------------------------------------------------

VOID
DeleteInInterfaceRefs(
    PLIST_ENTRY                 pleRefList
)
{
    PLIST_ENTRY                 ple = NULL;

    PIF_REFERENCE_ENTRY         pire = NULL;


    TRACEIF0( IF, "Entering DeleteInInterfaceRefs" );

    
    while ( !IsListEmpty( pleRefList ) )
    {
        ple = RemoveHeadList( pleRefList );
        
        pire = CONTAINING_RECORD( ple, IF_REFERENCE_ENTRY, leRefList );


        //
        // A Zappaesque function call here
        //
        
        LookupAndDeleteYourMfe( 
            pire-> dwSourceAddr, pire-> dwSourceMask,
            pire-> dwGroupAddr, pire-> dwGroupMask,
            TRUE, NULL, NULL
            );

        MGM_FREE( pire );
    }

    TRACEIF0( IF, "LEAVING DeleteInInterfaceRefs" );
}


//----------------------------------------------------------------------------
// TransferInterfaceOwnershipToProtocol
//
//
//----------------------------------------------------------------------------

DWORD
TransferInterfaceOwnershipToProtocol(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie
)
{
    
    DWORD               dwErr = NO_ERROR;

    PPROTOCOL_ENTRY     ppeIgmp;

    
    do
    {
        //
        // get protocol entry for IGMP
        //

        ppeIgmp = GetProtocolEntry( 
                    PROTOCOL_LIST_HEAD(), pie-> dwOwningProtocol,
                    pie-> dwOwningComponent
                    );

        if ( ppeIgmp == NULL )
        {
            //
            // interface is owned by IGMP, but protocol entry is not
            // present for IGMP.  MGM data is in an inconsistent state
            //

            dwErr = ERROR_UNKNOWN;

            TRACE2( 
                ANY, "TransferInterfaceOwnershipToProtocol : Could not find"
                " IGMP protocol entry", pie-> dwIfIndex,
                pie-> dwIfNextHopAddr
                );

            break;
        }

        
        //
        // indicate to IGMP that interface has been disabled.  This should
        // stop IGMP from adding state to this interface while it is being
        // transferred to the protocol
        //

        IGMP_DISABLE_CALLBACK( ppeIgmp ) (
                pie-> dwIfIndex, pie-> dwIfNextHopAddr
            );

        
        //
        // delete all IGMP references in and out
        //

        DeleteInInterfaceRefs( &pie-> leInIfList );

        DeleteOutInterfaceRefs( ppeIgmp, pie, TRUE );

        
        //
        // mark interface as added by Routing protocol
        //

        SET_ADDED_BY_PROTOCOL( pie );

        pie-> dwOwningProtocol   = ppe-> dwProtocolId;
        
        pie-> dwOwningComponent  = ppe-> dwComponentId;


        //
        // indicate to IGMP that interface has been enabled.
        //
        
        IGMP_ENABLE_CALLBACK( ppeIgmp ) (
                pie-> dwIfIndex, pie-> dwIfNextHopAddr
            );


    } while ( FALSE );

    return dwErr;
}



//----------------------------------------------------------------------------
// TransferInterfaceOwnershipToIGMP
//
//
//----------------------------------------------------------------------------

DWORD
TransferInterfaceOwnershipToIGMP(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie
)
{
    DWORD               dwErr = NO_ERROR;

    PPROTOCOL_ENTRY     ppeIgmp;


    do
    {
        //
        // get IGMP protocol entry
        //

        ppeIgmp = GetIgmpProtocolEntry( PROTOCOL_LIST_HEAD() );

        if ( ppeIgmp == NULL )
        {
            //
            // interface is has IGMP enabled on it, but a protocol entry is not
            // present for IGMP.  MGM data is in an inconsistent state
            //

            dwErr = ERROR_UNKNOWN;

            TRACE2( 
                ANY, "TransferInterfaceOwnershipToProtocol : Could not find"
                " IGMP protocol entry", pie-> dwIfIndex,
                pie-> dwIfNextHopAddr
                );

            break;
        }


        //
        // indicate to IGMP that interface has been disabled.  This should
        // stop IGMP from adding state to this interface while it is being
        // transferred to IGMP
        //

        IGMP_DISABLE_CALLBACK( ppeIgmp ) (
                pie-> dwIfIndex, pie-> dwIfNextHopAddr
            );

        
        //
        // delete all protocol references (in and out)
        //

        DeleteInInterfaceRefs( &pie-> leInIfList );

        DeleteOutInterfaceRefs( ppe, pie, FALSE );

        CLEAR_ADDED_BY_PROTOCOL( pie );

        
        //
        // delete all IGMP references, these will get added back by
        // IGMP when is enabled on this interface.  This is done
        // below.
        //

        DeleteOutInterfaceRefs( ppe, pie, TRUE );
        

        //
        // Mark interface as being owned by IGMP
        //

        pie-> dwOwningProtocol  = ppeIgmp-> dwProtocolId;

        pie-> dwOwningComponent = ppeIgmp-> dwComponentId;

        
        //
        // enable IGMP on the interface
        //

        IGMP_ENABLE_CALLBACK( ppeIgmp ) (
            pie-> dwIfIndex, pie-> dwIfNextHopAddr
            );


    } while ( FALSE );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\if.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: if.h
//
// History:
//      V Raman	July-11-1997  Created.
//
// Declarations for routines that manipulate interface entries
//============================================================================


#ifndef _IF_H_
#define _IF_H_

#include <mgm.h>

//----------------------------------------------------------------------------
// IF_ENTRY
//
// For each interface owned by a routing protocol an interface entry 
// is created in the interface table.
//
// dwIfIndex            -       Interface index
//
// dwNextHopAddr        -       Next hop IP address, used to distinguish
//                              dial-in interfaces that are all connected
//                              on the same RAS Server Interface.
//
// dwOwningProtocol     -       Protocol id of routing protocol that
//                              owns this interface.
//
// dwOwningComponent    -       Component of protocol.
//
// wAddedByFlag         -       Flag indicating if the interface entry was
//                              added by the routing protocol / IGMP / both.
//
// leOutIfList          -       list of (source, group) entries that reference
//                              this interface in their outgoing interface list
//
// leInIfList           -       list of (source, group) entries that reference
//                              this interface as their incoming interface
//----------------------------------------------------------------------------

typedef struct _IF_ENTRY
{
    LIST_ENTRY                  leIfHashList;

    DWORD                       dwIfIndex;

    DWORD                       dwIfNextHopAddr;

    DWORD                       dwOwningProtocol;

    DWORD                       dwOwningComponent;

    WORD                        wAddedByFlag;

    LIST_ENTRY                  leOutIfList;

    LIST_ENTRY                  leInIfList;

} IF_ENTRY, *PIF_ENTRY;



//----------------------------------------------------------------------------
// IF_REFERENCE_ENTRY
//
// Each interface maintains a list of (source, group) entries that refer 
// to this interface.  Each entry in this reference list stores the
// source, group info and a flag to determine what protocol caused this 
// reference.  Protocol could be IGMP/some routing protocol or both.
//
// Fields descriptions are left as an exercise to the reader.
//
//----------------------------------------------------------------------------

typedef struct _IF_REFERENCE_ENTRY
{
    LIST_ENTRY                  leRefList;

    DWORD                       dwGroupAddr;

    DWORD                       dwGroupMask;

    DWORD                       dwSourceAddr;

    DWORD                       dwSourceMask;

    WORD                        wAddedByFlag;
    
} IF_REFERENCE_ENTRY, *PIF_REFERENCE_ENTRY;


DWORD
CreateIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId
);


VOID
DeleteIfEntry(
    PIF_ENTRY                   pieEntry
);


PIF_ENTRY
GetIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr
);


BOOL
FindIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    PIF_ENTRY *                 ppie
);

DWORD
AddSourceToOutList(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bIGMP
);


VOID
AddSourceToRefList(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bIGMP
);


VOID
DeleteSourceFromRefList(
    PLIST_ENTRY                 pleIfRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bIGMP
);



BOOL
FindRefEntry(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PIF_REFERENCE_ENTRY *       ppire
);



VOID
DeleteOutInterfaceRefs(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie,
    BOOL                        bIGMP
);


VOID
DeleteInInterfaceRefs(
    PLIST_ENTRY                 pleRefList
);


DWORD
TransferInterfaceOwnershipToIGMP(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie
);


DWORD
TransferInterfaceOwnershipToProtocol(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie
);


#endif // _IF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\ipmgm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: ipmgm.h
//
// History:
//      V Raman Aug-6-1997  Created.
//
// Contains type definitions and declarations for IP MGM.
//============================================================================

#ifndef _IPMGM_H_
#define _IPMGM_H_



//
// various codes describing states of IPMGM.
//

typedef enum _IPMGM_STATUS_CODE {
    IPMGM_STATUS_STARTING   = 100,
    IPMGM_STATUS_RUNNING    = 101,
    IPMGM_STATUS_STOPPING   = 102,
    IPMGM_STATUS_STOPPED    = 103
} IPMGM_STATUS_CODE, *PIPMGM_STATUS_CODE;


//
// Structure of global information maintained by MGM.
//
//

typedef struct _IPMGM_GLOBALS
{
    //------------------------------------------------------------------------
    // global stuff.
    //------------------------------------------------------------------------
    
    CRITICAL_SECTION            csGlobal;

    IPMGM_STATUS_CODE           imscStatus;

    HANDLE                      hIpMgmGlobalHeap;

    LONG                        lActivityCount;

    HANDLE                      hActivitySemaphore;

    ROUTER_MANAGER_CONFIG       rmcRmConfig;
    

    //------------------------------------------------------------------------
    // hash table sizes
    //------------------------------------------------------------------------

    DWORD                       dwRouteTableSize;

    DWORD                       dwTimerQTableSize;
    

    //------------------------------------------------------------------------
    // Timer handles
    //------------------------------------------------------------------------

    HANDLE                      hRouteCheckTimer;

    
    //------------------------------------------------------------------------
    // lists and tables
    //------------------------------------------------------------------------

    LOCK_LIST                   llStackOfLocks;
    
    DWORD                       dwNumProtocols;
    
    MGM_LOCKED_LIST             mllProtocolList;
    
    MGM_LOCKED_LIST             mllOutstandingJoinList;
    
    PMGM_LOCKED_LIST            pmllIfHashTable;

    PMGM_LOCKED_LIST            pmllRouteHashTable;
    

    DWORD                       dwNumTempEntries;

    MGM_LOCKED_LIST             mllTempGrpList;
    
    MGM_LOCKED_LIST             mllGrpList;

    PMGM_LOCKED_LIST            pmllGrpHashTable;

    PHANDLE                     phTimerQHandleTable;


    //------------------------------------------------------------------------
    // trace stuff.
    //------------------------------------------------------------------------

    DWORD                       dwTraceID;

    DWORD                       dwLogLevel;
    
    HANDLE                      hLogHandle;
    
} IPMGM_GLOBALS, *PIPMGM_GLOBALS;




//============================================================================
// external declaration of the global IPMGM struct
//============================================================================

extern IPMGM_GLOBALS ig;


//============================================================================
// Macros to access hash functions and hash table sizes
//============================================================================

#define IF_TABLE_SIZE           ig.rmcRmConfig.dwIfTableSize

#define IF_TABLE_HASH( Index )     \
        ( ( Index ) % IF_TABLE_SIZE )


#define ROUTE_TABLE_SIZE           ig.dwRouteTableSize

#define ROUTE_TABLE_HASH( p )     \
        ( ( (p)-> RR_Network.N_NetNumber ) % ROUTE_TABLE_SIZE )


#define GROUP_TABLE_SIZE        ig.rmcRmConfig.dwGrpTableSize

#define GROUP_TABLE_HASH( Group, Mask )     \
        ( Group ? ( Group % ( GROUP_TABLE_SIZE - 1 ) + 1 ) : 0 ) 


#define SOURCE_TABLE_SIZE       ig.rmcRmConfig.dwSrcTableSize

#define SOURCE_TABLE_HASH( Source, Mask )   \
        ( Source ? ( Source % ( SOURCE_TABLE_SIZE - 1 ) + 1 ) : 0 ) 


#define TIMER_TABLE_SIZE        ig.dwTimerQTableSize

#define TIMER_TABLE_HASH( Group )           \
        ( ( Group ) % TIMER_TABLE_SIZE )


//============================================================================
// Max number of entries in the temp group list.
// if more entries are added to the temp group list then
// the temp group list is merged with the master group list
//============================================================================

#define TEMP_GROUP_LIST_MAXSIZE     16

#define TEMP_SOURCE_LIST_MAXSIZE    16


//============================================================================
// macros to access list heads
//============================================================================

#define PROTOCOL_LIST_HEAD()        &ig.mllProtocolList.leHead

#define JOIN_LIST_HEAD()            &ig.mllOutstandingJoinList.leHead

#define IF_BUCKET_HEAD( i )         &ig.pmllIfHashTable[ (i) ].leHead

#define ROUTE_BUCKET_HEAD( i )      &ig.pmllRouteHashTable[ (i) ].leHead


#define GROUP_BUCKET_HEAD( i )      &ig.pmllGrpHashTable[ (i) ].leHead

#define TEMP_GROUP_LIST_HEAD()      &ig.mllTempGrpList.leHead

#define MASTER_GROUP_LIST_HEAD()    &ig.mllGrpList.leHead


#define SOURCE_BUCKET_HEAD( a, b )  &(a)-> pleSrcHashTable[ (b) ]

#define MASTER_SOURCE_LIST_HEAD(a)  &(a)-> leSourceList

#define TEMP_SOURCE_LIST_HEAD( a )  &(a)-> leTempSrcList

#define TIMER_QUEUE_HANDLE( i )     ig.phTimerQHandleTable[ i ]


//============================================================================
// Macros to access router manager callback for kernel mode forwarder
//============================================================================

#define IS_ADD_MFE_CALLBACK()   \
        ig.rmcRmConfig.pfnAddMfeCallback != NULL

#define ADD_MFE_CALLBACK()      \
        ( *(ig.rmcRmConfig.pfnAddMfeCallback) )

#define IS_DELETE_MFE_CALLBACK()\
        ig.rmcRmConfig.pfnDeleteMfeCallback != NULL

#define DELETE_MFE_CALLBACK()   \
        ( *(ig.rmcRmConfig.pfnDeleteMfeCallback) )

#define IS_GET_MFE_CALLBACK()      \
        ig.rmcRmConfig.pfnGetMfeCallback != NULL

#define GET_MFE_CALLBACK()      \
        ( *(ig.rmcRmConfig.pfnGetMfeCallback) )

#define IS_HAS_BOUNDARY_CALLBACK()      \
        ig.rmcRmConfig.pfnHasBoundaryCallback != NULL

#define HAS_BOUNDARY_CALLBACK() \
        ( *(ig.rmcRmConfig.pfnHasBoundaryCallback) )


//============================================================================
// memory-allocation constants and macros
//============================================================================

#define GLOBAL_HEAP     ig.hIpMgmGlobalHeap
#define MGM_ALLOC(size) HeapAlloc(GLOBAL_HEAP, 0, size)
#define MGM_FREE(ptr)   HeapFree(GLOBAL_HEAP, 0, ptr)



//============================================================================
// macros invoked when entering API or worker functions
//============================================================================

#define ENTER_MGM_API()         EnterMgmAPI()
#define ENTER_MGM_WORKER()      EnterMgmWorker()


//----------------------------------------------------------------------------
// macro invoked when leaving API or worker functions
//----------------------------------------------------------------------------

#define LEAVE_MGM_API()         LeaveMgmWorker()
#define LEAVE_MGM_WORKER()      LeaveMgmWorker()


//============================================================================
// constants used for tracing 
//============================================================================

#define IPMGM_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define IPMGM_TRACE_ENTER           ((DWORD)0x00010000 | TRACE_USE_MASK)
#define IPMGM_TRACE_LEAVE           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPMGM_TRACE_TIMER           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IPMGM_TRACE_IF              ((DWORD)0x00080000 | TRACE_USE_MASK)
#define IPMGM_TRACE_GROUP           ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IPMGM_TRACE_PROTOCOL        ((DWORD)0x00200000 | TRACE_USE_MASK)
#define IPMGM_TRACE_LOCK            ((DWORD)0x00400000 | TRACE_USE_MASK)
#define IPMGM_TRACE_LOCK_COUNT      ((DWORD)0x00800000 | TRACE_USE_MASK)
#define IPMGM_TRACE_START           ((DWORD)0x01000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_STOP            ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_PACKET          ((DWORD)0x04000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_FORWARD         ((DWORD)0x08000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_CALLBACK        ((DWORD)0x10000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_ENUM            ((DWORD)0x20000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_ROUTE           ((DWORD)0x40000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_SCOPE           ((DWORD)0x80000000 | TRACE_USE_MASK)


//============================================================================
//
// macros used for locking and unlocking protected structures
//
//============================================================================

#ifdef LOCK_DEBUG


//
// Sync functions/lock creation-deletion tracing
//

#define TRACELOCK0(a)           \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK, a)

#define TRACELOCK1(a, b)        \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK, a, b)

#define TRACELOCK2(a, b, c)     \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK, a, b, c)

#define TRACELOCK3(a, b, c, d)     \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK, a, b, c, d)


#define TRACECOUNT0(a)          \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK_COUNT, a)

#define TRACECOUNT1(a, b)       \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK_COUNT, a, b)

#define TRACECOUNT2(a, b, c)     \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK_COUNT, a, b, c)

#else

#define TRACELOCK0(a)

#define TRACELOCK1(a, b)

#define TRACELOCK2(a, b, c)

#define TRACELOCK3(a, b, c, d)

#define TRACECOUNT0(a)

#define TRACECOUNT1(a, b)

#define TRACECOUNT2(a, b, c)

#endif


//
// Protocol locks
//

#define ACQUIRE_PROTOCOL_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Acquiring protocol lock exclusive" );                  \
        AcquireWriteLock(&ig.mllProtocolList.pmrwlLock);                    \
        TRACELOCK0( "Acquired protocol lock exclusive" );                   \
}

#define RELEASE_PROTOCOL_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Releasing protocol lock exclusive" );                  \
        ReleaseWriteLock(&ig.mllProtocolList.pmrwlLock);                    \
        TRACELOCK0( "Released protocol lock exclusive" );                   \
}

#define ACQUIRE_PROTOCOL_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Acquiring protocol lock shared" );                     \
        AcquireReadLock(&ig.mllProtocolList.pmrwlLock);                     \
        TRACELOCK0( "Acquired protocol lock shared" );                      \
}

#define RELEASE_PROTOCOL_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Releasing protocol lock shared" );                     \
        ReleaseReadLock(&ig.mllProtocolList.pmrwlLock);                     \
        TRACELOCK0( "Released protocol lock shared" );                      \
}


//
// scope boundaries lock
//

#define ACQUIRE_JOIN_LIST_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Acquiring Join list lock exclusive" );                 \
        AcquireWriteLock(&ig.mllOutstandingJoinList.pmrwlLock);             \
        TRACELOCK0( "Acquired Join list lock exclusive" );                  \
}

#define RELEASE_JOIN_LIST_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Releasing join list lock exclusive" );                 \
        ReleaseWriteLock(&ig.mllOutstandingJoinList.pmrwlLock);             \
        TRACELOCK0( "Released join list lock exclusive" );                  \
}

#define ACQUIRE_JOIN_LIST_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Acquiring join list lock shared" );                    \
        AcquireReadLock(&ig.mllOutstandingJoinList.pmrwlLock);              \
        TRACELOCK0( "Acquired join list lock shared" );                     \
}

#define RELEASE_JOIN_LIST_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Releasing join list lock shared" );                    \
        ReleaseReadLock(&ig.mllOutstandingJoinList.pmrwlLock);              \
        TRACELOCK0( "Released join list lock shared" );                     \
}


//
// Interfaces locking
//

#define ACQUIRE_IF_LOCK_EXCLUSIVE( i ) \
{                                                                           \
        TRACELOCK1( "Acquiring interface lock exclusive : %d", i );         \
        AcquireWriteLock(&ig.pmllIfHashTable[ i ].pmrwlLock);               \
        TRACELOCK1( "Acquired interface lock exclusive : %d", i );          \
}

#define RELEASE_IF_LOCK_EXCLUSIVE( i ) \
{                                                                           \
        TRACELOCK1( "Releasing interface lock exclusive : %d", i );         \
        ReleaseWriteLock(&ig.pmllIfHashTable[ i ].pmrwlLock);               \
        TRACELOCK1( "Released interface lock exclusive : %d", i );          \
}

#define ACQUIRE_IF_LOCK_SHARED( i ) \
{                                                                           \
        TRACELOCK1( "Acquiring interface lock shared : %d", i );            \
        AcquireReadLock(&ig.pmllIfHashTable[ i ].pmrwlLock);                \
        TRACELOCK1( "Acquired interface lock shared : %d", i );             \
}

#define RELEASE_IF_LOCK_SHARED( i ) \
{                                                                           \
        TRACELOCK1( "Releasing interface lock shared : %d", i );            \
        ReleaseReadLock(&ig.pmllIfHashTable[ i ].pmrwlLock);                \
        TRACELOCK1( "Released interface lock shared : %d", i );             \
}


//
// Route references lock
//

#define ACQUIRE_ROUTE_LOCK_EXCLUSIVE( p ) \
{                                                                           \
        TRACELOCK0( "Acquiring route lock exclusive" );                     \
        AcquireWriteLock(&(p)->pmrwlLock);                                  \
        TRACELOCK0( "Acquired route lock exclusive");                       \
}

#define RELEASE_ROUTE_LOCK_EXCLUSIVE( p ) \
{                                                                           \
        TRACELOCK0( "Releasing route lock exclusive");                      \
        ReleaseWriteLock(&(p)->pmrwlLock);                                  \
        TRACELOCK0( "Released route lock exclusive" );                      \
}

#define ACQUIRE_ROUTE_LOCK_SHARED( p ) \
{                                                                           \
        TRACELOCK0( "Acquiring route lock shared : %x");                    \
        AcquireReadLock(&(p)->pmrwlLock);                                   \
        TRACELOCK0( "Acquired route lock shared : %x");                     \
}

#define RELEASE_ROUTE_LOCK_SHARED( p ) \
{                                                                           \
        TRACELOCK0( "Releasing route lock shared : %x");                    \
        ReleaseReadLock(&(p)->pmrwlLock);                                   \
        TRACELOCK0( "Released route lock shared : %x");                     \
}


//
// Group table locks
//

#define ACQUIRE_GROUP_LOCK_EXCLUSIVE( i ) \
{                                                                           \
        TRACELOCK1( "Acquiring group lock exclusive : %d", i );             \
        AcquireWriteLock(&ig.pmllGrpHashTable[ i ].pmrwlLock);              \
        TRACELOCK1( "Acquired group lock exclusive : %d", i );              \
}

#define RELEASE_GROUP_LOCK_EXCLUSIVE( i ) \
{                                                                           \
        TRACELOCK1( "Releasing group lock exclusive : %d", i );             \
        ReleaseWriteLock(&ig.pmllGrpHashTable[ i ].pmrwlLock);              \
        TRACELOCK1( "Released group lock exclusive : %d", i );              \
}

#define ACQUIRE_GROUP_LOCK_SHARED( i ) \
{                                                                           \
        TRACELOCK1( "Acquiring group lock shared : %d", i );                \
        AcquireReadLock(&ig.pmllGrpHashTable[ i ].pmrwlLock);               \
        TRACELOCK1( "Acquired group lock shared : %d", i );                 \
}

#define RELEASE_GROUP_LOCK_SHARED( i ) \
{                                                                           \
        TRACELOCK1( "Releasing group lock shared : %d", i );                \
        ReleaseReadLock(&ig.pmllGrpHashTable[ i ].pmrwlLock);               \
        TRACELOCK1( "Released group lock shared : %d", i );                 \
}


//
// Master group list locks
//

#define ACQUIRE_MASTER_GROUP_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Acquiring master group lock exclusive" );              \
        AcquireWriteLock(&ig.mllGrpList.pmrwlLock);                         \
        TRACELOCK0( "Acquired master group lock exclusive" );               \
}

#define RELEASE_MASTER_GROUP_LOCK_EXCLUSIVE()   \
{                                                                           \
        TRACELOCK0( "Releasing master group lock exclusive" );              \
        ReleaseWriteLock(&ig.mllGrpList.pmrwlLock);                         \
        TRACELOCK0( "Released  master group lock exclusive" );              \
}

#define ACQUIRE_MASTER_GROUP_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Acquiring master group lock shared" );                 \
        AcquireReadLock(&ig.mllGrpList.pmrwlLock);                          \
        TRACELOCK0( "Acquired master group lock shared" );                  \
}

#define RELEASE_MASTER_GROUP_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Releasing master group lock shared" );                 \
        ReleaseReadLock(&ig.mllGrpList.pmrwlLock);                          \
        TRACELOCK0( "Released master group lock shared" );                  \
}


//
// Temp group list locks
//

#define ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Acquiring temp group lock exclusive" );                \
        AcquireWriteLock(&ig.mllTempGrpList.pmrwlLock);                     \
        TRACELOCK0( "Acquired temp group lock exclusive" );                 \
}

#define RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Releasing temp group lock exclusive" );                \
        ReleaseWriteLock(&ig.mllTempGrpList.pmrwlLock);                     \
        TRACELOCK0( "Released temp group lock exclusive" );                 \
}

#define ACQUIRE_TEMP_GROUP_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Acquiring temp group lock shared" );                   \
        AcquireReadLock(&ig.mllTempGrpList.pmrwlLock);                      \
        TRACELOCK0( "Acquired temp group lock shared" );                    \
}

#define RELEASE_TEMP_GROUP_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Releasing temp group lock shared" );                   \
        ReleaseReadLock(&ig.mllTempGrpList.pmrwlLock);                      \
        TRACELOCK0( "Released temp group lock shared" );                    \
}


//
// Group entry locks
//

#define ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( p ) \
{                                                                           \
        TRACELOCK3( "Acquiring group entry lock exclusive : %x, %d, %s", (p)-> dwGroupAddr, __LINE__, __FILE__ );   \
        AcquireWriteLock(&(p)->pmrwlLock);                                 \
        TRACELOCK1( "Acquired group entry lock exclusive : %x", (p)-> dwGroupAddr );    \
}

#define RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( p ) \
{                                                                           \
        TRACELOCK3( "Releasing group entry lock exclusive : %x, %d, %s", (p)-> dwGroupAddr,, __LINE__, __FILE__ );   \
        ReleaseWriteLock(&(p)->pmrwlLock);                                 \
        TRACELOCK1( "Released group entry lock exclusive : %x", (p)-> dwGroupAddr );    \
}

#define ACQUIRE_GROUP_ENTRY_LOCK_SHARED( p ) \
{                                                                           \
        TRACELOCK3( "Acquiring group entry lock shared : %x, %d, %s", (p)-> dwGroupAddr, __LINE__, __FILE__  );      \
        AcquireReadLock(&(p)->pmrwlLock);                                  \
        TRACELOCK1( "Acquired group entry lock shared : %x", (p)-> dwGroupAddr );       \
}

#define RELEASE_GROUP_ENTRY_LOCK_SHARED( p ) \
{                                                                           \
        TRACELOCK3( "Releasing group entry lock shared : %x, %d, %s", (p)-> dwGroupAddr, __LINE__, __FILE__  );      \
        ReleaseReadLock(&(p)->pmrwlLock);                                  \
        TRACELOCK1( "Released group entry lock shared : %x", (p)-> dwGroupAddr );       \
}


#define ENTER_GLOBAL_SECTION() \
        EnterCriticalSection(&ig.csGlobal)

#define LEAVE_GLOBAL_SECTION() \
        LeaveCriticalSection(&ig.csGlobal)


#define ENTER_GLOBAL_LOCK_LIST_SECTION() \
        EnterCriticalSection(&ig.llStackOfLocks.csListLock)

#define LEAVE_GLOBAL_LOCK_LIST_SECTION() \
        LeaveCriticalSection(&ig.llStackOfLocks.csListLock)



//============================================================================
// macros used for tracing 
//============================================================================

#define TRACEID                     ig.dwTraceID


#define TRACESTART()            \
            TRACEID = TraceRegister("IPMGM")
#define TRACESTOP()             \
            TraceDeregister(TRACEID)
#define TRACE0(l,a)             \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a)
#define TRACE1(l,a,b)           \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b)
#define TRACE2(l,a,b,c)         \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b, c)
#define TRACE3(l,a,b,c,d)       \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b, c, d)
#define TRACE4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b, c, d, e)
#define TRACE5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b, c, d, e, f)
#define TRACE6(l,a,b,c,d,e,f,g)   \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b, c, d, e, f, g)

#define TRACEDUMP(l,a,b,c)      \
            TraceDumpEx(TRACEID,l,a,b,c,TRUE)


//============================================================================
// macros for debug trace only
//============================================================================

//
// enum trace
//

#if ENUM_DBG

#define TRACEENUM0      TRACE0

#define TRACEENUM1      TRACE1

#define TRACEENUM2      TRACE2

#define TRACEENUM3      TRACE3

#define TRACEENUM4      TRACE4

#else

#define TRACEENUM0(l,a)

#define TRACEENUM1(l,a,b)

#define TRACEENUM2(l,a,b,c)

#define TRACEENUM3(l,a,b,c,d)

#define TRACEENUM4(l,a,b,c,d,e)

#endif


//
// forward trace
//

#if FORWARD_DBG

#define TRACEFORWARD0   TRACE0

#define TRACEFORWARD1   TRACE1

#define TRACEFORWARD2   TRACE2

#define TRACEFORWARD3   TRACE3

#define TRACEFORWARD4   TRACE4

#define TRACEFORWARD5   TRACE5

#define TRACEFORWARD6   TRACE6


#else

#define TRACEFORWARD0(l,a)

#define TRACEFORWARD1(l,a,b)

#define TRACEFORWARD2(l,a,b,c)

#define TRACEFORWARD3(l,a,b,c,d)

#define TRACEFORWARD4(l,a,b,c,d,e)

#define TRACEFORWARD5(l,a,b,c,d,e,f)

#define TRACEFORWARD6(l,a,b,c,d,e,f,g)

#endif


//
// group trace
//

#if GROUP_DBG

#define TRACEGROUP0     TRACE0

#define TRACEGROUP1     TRACE1

#define TRACEGROUP2     TRACE2

#define TRACEGROUP3     TRACE3

#define TRACEGROUP4     TRACE4

#define TRACEGROUP5     TRACE5

#define TRACEGROUP6     TRACE6


#else

#define TRACEGROUP0(l,a)

#define TRACEGROUP1(l,a,b)

#define TRACEGROUP2(l,a,b,c)

#define TRACEGROUP3(l,a,b,c,d)

#define TRACEGROUP4(l,a,b,c,d,e)

#define TRACEGROUP5(l,a,b,c,d,e,f)

#define TRACEGROUP6(l,a,b,c,d,e,f,g)

#endif


//
// Interface trace
//

#if IF_DBG

#define TRACEIF0        TRACE0

#define TRACEIF1        TRACE1

#define TRACEIF2        TRACE2

#define TRACEIF3        TRACE3

#define TRACEIF4        TRACE4

#define TRACEIF5        TRACE5

#define TRACEIF6        TRACE6


#else

#define TRACEIF0(l,a)

#define TRACEIF1(l,a,b)

#define TRACEIF2(l,a,b,c)

#define TRACEIF3(l,a,b,c,d)

#define TRACEIF4(l,a,b,c,d,e)

#define TRACEIF5(l,a,b,c,d,e,f)

#define TRACEIF6(l,a,b,c,d,e,f,g)

#endif


//
// packet trace
//

#if PACKET_DBG

#define TRACEPACKET0    TRACE0

#define TRACEPACKET1    TRACE1

#define TRACEPACKET2    TRACE2

#define TRACEPACKET3    TRACE3

#define TRACEPACKET4    TRACE4

#define TRACEPACKET5    TRACE5

#define TRACEPACKET6    TRACE6


#else

#define TRACEPACKET0(l,a)

#define TRACEPACKET1(l,a,b)

#define TRACEPACKET2(l,a,b,c)

#define TRACEPACKET3(l,a,b,c,d)

#define TRACEPACKET4(l,a,b,c,d,e)

#define TRACEPACKET5(l,a,b,c,d,e,f)

#define TRACEPACKET6(l,a,b,c,d,e,f,g)

#endif


//
// route trace
//

#if ROUTE_DBG

#define TRACEROUTE0     TRACE0

#define TRACEROUTE1     TRACE1

#define TRACEROUTE2     TRACE2

#define TRACEROUTE3     TRACE3

#define TRACEROUTE4     TRACE4

#define TRACEROUTE5     TRACE5

#define TRACEROUTE6     TRACE6


#else

#define TRACEROUTE0(l,a)

#define TRACEROUTE1(l,a,b)

#define TRACEROUTE2(l,a,b,c)

#define TRACEROUTE3(l,a,b,c,d)

#define TRACEROUTE4(l,a,b,c,d,e)

#define TRACEROUTE5(l,a,b,c,d,e,f)

#define TRACEROUTE6(l,a,b,c,d,e,f,g)

#endif


//
// scope trace
//

#if SCOPE_DBG

#define TRACESCOPE0     TRACE0

#define TRACESCOPE1     TRACE1

#define TRACESCOPE2     TRACE2

#define TRACESCOPE3     TRACE3

#define TRACESCOPE4     TRACE4

#define TRACESCOPE5     TRACE5

#define TRACESCOPE6     TRACE6


#else

#define TRACESCOPE0(l,a)

#define TRACESCOPE1(l,a,b)

#define TRACESCOPE2(l,a,b,c)

#define TRACESCOPE3(l,a,b,c,d)

#define TRACESCOPE4(l,a,b,c,d,e)

#define TRACESCOPE5(l,a,b,c,d,e,f)

#define TRACESCOPE6(l,a,b,c,d,e,f,g)

#endif


//============================================================================
// Event logging macros
//============================================================================

#define LOGLEVEL        ig.dwLogLevel
#define LOGHANDLE       ig.hLogHandle
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData


//
// Error logging
//

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,IPMGMLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,IPMGMLOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,IPMGMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,IPMGMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,IPMGMLOG_ ## msg,4,_asz,(err)); \
        }


//
// Warning logging
//

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,IPMGMLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,IPMGMLOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,IPMGMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,IPMGMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,IPMGMLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,IPMGMLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


//
// Information logging
//

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,IPMGMLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,IPMGMLOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,IPMGMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,IPMGMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,IPMGMLOG_ ## msg,4,_asz,(err)); \
        }


//============================================================================
// Macros to access routing protocol callbacks
//============================================================================

#define IS_JOIN_ALERT( p ) \
        (p)-> rpcProtocolConfig.pfnJoinAlertCallback != NULL

#define IS_PRUNE_ALERT( p ) \
        (p)-> rpcProtocolConfig.pfnPruneAlertCallback != NULL

#define IS_LOCAL_JOIN_ALERT( p ) \
        (p)-> rpcProtocolConfig.pfnLocalJoinCallback != NULL

#define IS_LOCAL_LEAVE_ALERT( p ) \
        (p)-> rpcProtocolConfig.pfnLocalLeaveCallback != NULL

#define IS_RPF_CALLBACK( p ) \
        (p)-> rpcProtocolConfig.pfnRpfCallback != NULL

#define IS_CREATION_ALERT( p ) \
        (p)-> rpcProtocolConfig.pfnCreationAlertCallback != NULL


#define RPF_CALLBACK( p ) \
    ( *( (p)-> rpcProtocolConfig.pfnRpfCallback ) )


#if CALLBACK_DEBUG

#define JOIN_ALERT( p )   \
    {                                                                       \
        TRACE2(                                                             \
            CALLBACK, "Invoked Join Alert for protocol %x, %x",             \
            (p)-> dwProtocolId, (p)-> dwComponentId                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnJoinAlertCallback ) )


#define PRUNE_ALERT( p ) \
    {                                                                       \
        TRACE2(                                                             \
            CALLBACK, "Invoked Prune Alert for protocol %x, %x",            \
            (p)-> dwProtocolId, (p)-> dwComponentId                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnPruneAlertCallback ) )


#define LOCAL_JOIN_ALERT( p )   \
    {                                                                       \
        TRACE2(                                                             \
            CALLBACK, "Invoked Local Join Alert for protocol %x, %x",        \
            (p)-> dwProtocolId, (p)-> dwComponentId                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnLocalJoinCallback ) )


#define LOCAL_LEAVE_ALERT( p )  \
    {                                                                       \
        TRACE2(                                                             \
            CALLBACK, "Invoked Local Leave Alert for protocol %x, %x",       \
            (p)-> dwProtocolId, (p)-> dwComponentId                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnLocalLeaveCallback ) )



#define CREATION_ALERT( p )     \
    {                                                                       \
        TRACE2(                                                             \
            CALLBACK, "Invoked Creation Alert for protocol %x, %x",         \
            (p)-> dwProtocolId, (p)-> dwComponentId                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnCreationAlertCallback ) )


#define IGMP_DISABLE_CALLBACK( p ) \
    {                                                                       \
        TRACE0(                                                             \
            CALLBACK, "Invoked Disable IGMP Alert ",                        \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnDisableIgmpCallback ) )

#define IGMP_ENABLE_CALLBACK( p ) \
    {                                                                       \
        TRACE0(                                                             \
            CALLBACK, "Invoked Enable IGMP Alert ",                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnEnableIgmpCallback ) )


#else

#define JOIN_ALERT( p ) \
        ( *( (p)-> rpcProtocolConfig.pfnJoinAlertCallback ) )

#define PRUNE_ALERT( p ) \
    ( *( (p)-> rpcProtocolConfig.pfnPruneAlertCallback ) )

#define LOCAL_JOIN_ALERT( p ) \
        ( *( (p)-> rpcProtocolConfig.pfnLocalJoinCallback ) )

#define LOCAL_LEAVE_ALERT( p ) \
    ( *( (p)-> rpcProtocolConfig.pfnLocalLeaveCallback ) )

#define CREATION_ALERT( p ) \
        ( *( (p)-> rpcProtocolConfig.pfnCreationAlertCallback ) )

#define IGMP_DISABLE_CALLBACK( p ) \
        ( *( (p)-> rpcProtocolConfig.pfnDisableIgmpCallback ) )

#define IGMP_ENABLE_CALLBACK( p ) \
        ( *( (p)-> rpcProtocolConfig.pfnEnableIgmpCallback ) )

#endif



//============================================================================
// Client count and worker thread related stuff.
//============================================================================

DWORD
QueueMgmWorker(
    WORKERFUNCTION pFunction,
    PVOID pContext
    );

BOOL
EnterMgmAPI(
    );

BOOL
EnterMgmWorker(
    );

VOID
LeaveMgmWorker(
    );

VOID
DisplayGroupTable(
);



extern RTM_ENTITY_INFO         g_reiRtmEntity;

extern RTM_REGN_PROFILE        g_rrpRtmProfile;

extern RTM_ENTITY_HANDLE       g_hRtmHandle;

extern RTM_NOTIFY_HANDLE       g_hNotificationHandle;

extern RTM_REGN_PROFILE        g_rrpRtmProfile;

#endif // _IPMGM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\group.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: group.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// routines that manipulate (source, group) entries
//============================================================================

#include "pchmgm.h"
#pragma hdrstop


DWORD
AddToGroupList(
    PGROUP_ENTRY                pge
);


DWORD
AddToSourceList(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
);


//----------------------------------------------------------------------------
// CreateGroupEntry
//
// Creates a new group entry and inserts it into the appropriate location. 
//
// Assumes that the group bucket is locked.
//----------------------------------------------------------------------------

DWORD
CreateGroupEntry(
    PLIST_ENTRY                 pleHashList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PGROUP_ENTRY *              ppge
)
{
    PGROUP_ENTRY                pge = NULL;

    DWORD                       dwErr = NO_ERROR, dwInd, dwSize;



    TRACEGROUP2( 
        GROUP, "ENTERED CreateGroupEntry : %x, %x", 
        dwGroupAddr, dwGroupMask 
        );


    do
    {
        //
        // Allocate and initialize a new entry
        //

        dwSize = sizeof( GROUP_ENTRY ) + 
                 ( SOURCE_TABLE_SIZE - 1) * sizeof( LIST_ENTRY );

        pge = MGM_ALLOC( dwSize );
        
        if ( pge == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "CreateGroupEntry : failed to allocate group entry %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pge, dwSize );


        pge-> dwGroupAddr       = dwGroupAddr;

        pge-> dwGroupMask       = dwGroupMask;

        pge-> dwSourceCount     = 0;

        pge-> dwNumTempEntries  = 0;

        pge-> pmrwlLock         = NULL;
        

        //
        // Initialize all source lists
        //
        
        for ( dwInd = 0; dwInd < SOURCE_TABLE_SIZE; dwInd++ )
        {
            InitializeListHead( &( pge-> pleSrcHashTable[ dwInd ] ) );
        }

        InitializeListHead( &( pge-> leSourceList ) );

        InitializeListHead( &( pge-> leTempSrcList ) );


        //
        // Insert into the group hash list
        //

        InitializeListHead( &(pge-> leGrpHashList ) );

        InsertTailList( pleHashList, &( pge-> leGrpHashList ) );


        //--------------------------------------------------------------------
        // Insert group entry into the lexicographically sorted list 
        //--------------------------------------------------------------------
        
        InitializeListHead( &( pge-> leGrpList ) );


        //
        // Insert into temp list. 
        //

        AddToGroupList( pge );
        

        *ppge = pge;
        
    } while( FALSE );


    TRACEGROUP1( GROUP, "LEAVING CreateGroupEntry : %x", dwErr );
        
    return dwErr;
}


//----------------------------------------------------------------------------
// GetGroupEntry
//
// retrieves specified entry.  NULL if not present.
// Assumes that the group bucket is locked.
//----------------------------------------------------------------------------

PGROUP_ENTRY
GetGroupEntry(
    PLIST_ENTRY                 pleGroupList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask
)
{
    PGROUP_ENTRY                pge = NULL;
    
    if ( FindGroupEntry( pleGroupList, dwGroupAddr, dwGroupMask, &pge, TRUE ) )
    {
        return pge;
    }
    
    return NULL;
}


//----------------------------------------------------------------------------
// DeleteGroupEntry
//
// Assumes all sources for this group have been deleted.
//----------------------------------------------------------------------------

VOID
DeleteGroupEntry(
    PGROUP_ENTRY                pge
)
{

    TRACEGROUP2( 
        GROUP, "ENTERED DeleteGroupEntry : %x, %x", 
        pge-> dwGroupAddr, pge-> dwGroupMask 
        );
        
    RemoveEntryList( &pge-> leGrpHashList );


    //
    // remove from lex. list
    //
    
    ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE();

    ACQUIRE_MASTER_GROUP_LOCK_EXCLUSIVE();

    ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );


    RemoveEntryList( &pge-> leGrpList );

    
    RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

    RELEASE_MASTER_GROUP_LOCK_EXCLUSIVE();

    RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE();

    
    MGM_FREE( pge );
    
    TRACEGROUP0( GROUP, "LEAVING DeleteGroupEntry" );
}



//----------------------------------------------------------------------------
// FindGroupEntry
//
// Finds the entry for the specified group.  
//
// If entry is found the ppge parameter returns a pointer to the 
// specified group entry.  
//
// If entry is not found the ppge parameter is set to the "following" entry.
// This serves as an insertion spot in case a new entry is to inserted when
// none is found.
// 
// if the group list specified by pleGroupList is empty then ppge is set
// to NULL.
//
// Assumes that the group bucket is locked.
//----------------------------------------------------------------------------

BOOL
FindGroupEntry(
    PLIST_ENTRY                 pleGroupList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PGROUP_ENTRY *              ppge,
    BOOL                        bHashList
)
{

    PLIST_ENTRY                 ple = NULL;
    
    PGROUP_ENTRY                pge = NULL;

    BOOL                        bFound = FALSE;

    INT                         iCmp;
    

    TRACEGROUP2( 
        GROUP, "ENTERED FindGroupEntry : %x, %x", dwGroupAddr, dwGroupMask 
        );


    *ppge = NULL;

    
    //
    // scan group bucket.  Group entries are arranged in increasing order
    // of group addr.
    //

    for ( ple = pleGroupList-> Flink; 
          ple != pleGroupList; 
          ple = ple-> Flink )
    {
        if ( bHashList )
        {
            pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpHashList );
        }

        else
        {
            pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpList );
        }
        

        if ( INET_CMP( pge-> dwGroupAddr, dwGroupAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            bFound = FALSE;
        }

        else
        {
            bFound = TRUE;
        }
        
        *ppge = pge;

        break;
        
    } while ( FALSE );


    TRACEGROUP1( GROUP, "LEAVING FindGroupEntry : %x", bFound );

    return bFound;
}



//----------------------------------------------------------------------------
// CreateSourceEntry
//
// Creates a new source entry and inserts it into its appropriate location.
//----------------------------------------------------------------------------

DWORD
CreateSourceEntry(
    PGROUP_ENTRY                pge,
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    PSOURCE_ENTRY *             ppse
)
{

    DWORD                       dwErr = NO_ERROR;

    PSOURCE_ENTRY               pse = NULL;

    
    TRACEGROUP2( 
        GROUP, "ENTERED CreateSourceEntry : %x %x", 
        dwSourceAddr, dwSourceMask 
        );


    do
    {
        //
        // allocate group entry.
        //

        pse = MGM_ALLOC( sizeof( SOURCE_ENTRY ) );

        if ( pse == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, 
                "CreateSourceEntry : failed to allocate source entry %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pse, sizeof( SOURCE_ENTRY ) );

        
        //
        // Init. fields
        //

        pse-> dwSourceAddr          = dwSourceAddr;
        pse-> dwSourceMask          = dwSourceMask;

        pse-> dwInIfIndex           = INVALID_INTERFACE_INDEX;
        pse-> dwInIfNextHopAddr     = INVALID_NEXT_HOP_ADDR;
        pse-> dwUpstreamNeighbor    = 0;

        pse-> dwInProtocolId        = INVALID_PROTOCOL_ID;
        pse-> dwInComponentId       = INVALID_COMPONENT_ID;

        pse-> bInForwarder          = FALSE;
        pse-> dwInUse               = 0;

        pse-> dwTimeOut             = 0;
        pse-> liCreationTime.QuadPart = 0;

        RtlZeroMemory( 
            &pse-> imsStatistics, sizeof( IPMCAST_MFE_STATS ) 
            );

            
        //
        // Outgoing interface list, mfe list are empty.
        //

        pse-> dwOutIfCount = 0;

        pse-> dwOutCompCount = 0;
        
        InitializeListHead( &pse-> leOutIfList );

        InitializeListHead( &pse-> leScopedIfList );


        pse-> dwMfeIfCount = 0;

        InitializeListHead( &pse-> leMfeIfList );
        

        //
        // Insert entry into appropriate source lists 
        //

        InitializeListHead( &pse-> leSrcHashList );

        InsertTailList( pleSrcList, &pse-> leSrcHashList );


        //--------------------------------------------------------------------
        // Insert source entry into the lexicographically sorted list 
        //--------------------------------------------------------------------

        InitializeListHead( &pse-> leSrcList );
        
        AddToSourceList( pge, pse );


        *ppse = pse;

        dwErr = NO_ERROR;
        
    } while ( FALSE );


    TRACEGROUP1( GROUP, "LEAVING CreateSourceEntry : %x", dwErr );

    return dwErr;
}


//----------------------------------------------------------------------------
// GetSourceEntry
//
//
//----------------------------------------------------------------------------

PSOURCE_ENTRY
GetSourceEntry(
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask
)
{
    PSOURCE_ENTRY               pse = NULL;
    
    if ( FindSourceEntry( pleSrcList, dwSourceAddr, dwSourceMask, &pse, TRUE ) )
    {
        return pse;
    }

    return NULL;
}


//----------------------------------------------------------------------------
// DeleteSourceEntry
//
//
//----------------------------------------------------------------------------

VOID
DeleteSourceEntry(
    PSOURCE_ENTRY               pse
)
{
    TRACEGROUP2( 
        GROUP, "ENTERED DeleteSourceEntry : %x, %x", 
        pse-> dwSourceAddr, pse-> dwSourceMask 
        );
    
    RemoveEntryList( &pse-> leSrcHashList );

    RemoveEntryList( &pse-> leSrcList );
    
    MGM_FREE( pse );

    TRACEGROUP0( GROUP, "LEAVING DeleteSourceEntry" );
}


//----------------------------------------------------------------------------
// FindSourceEntry
//
// Find specified source entry in the bucket.  
//
// If entry is found the ppse parameter returns a pointer to the 
// specified source entry.  
//
// If entry is not found the ppse parameter is set to the "following" entry.
// This serves as an insertion spot in case a new entry is to inserted when
// none is found.
// 
// if the source list specified by pleSrcList is empty then ppse is set
// to NULL.
//
//----------------------------------------------------------------------------

BOOL
FindSourceEntry(
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    PSOURCE_ENTRY *             ppse,
    BOOL                        bHashList
)
{

    BOOL            bFound = FALSE;

    INT             iCmp;

    PLIST_ENTRY     ple = NULL;
    
    PSOURCE_ENTRY   pse = NULL;


    TRACEGROUP3( 
        GROUP, "ENTERED FindSourceEntry : %x, %x, %x", 
        dwSourceAddr, dwSourceMask, bHashList
        );



    *ppse = NULL;


    //
    // walk the source list and find the specified source entry
    //

    for ( ple = pleSrcList-> Flink; ple != pleSrcList; ple = ple-> Flink )
    {
        if ( bHashList )
        {
            pse = CONTAINING_RECORD( ple, SOURCE_ENTRY, leSrcHashList );
        }

        else
        {
            pse = CONTAINING_RECORD( ple, SOURCE_ENTRY, leSrcList );
        }
        

        if ( INET_CMP( pse-> dwSourceAddr, dwSourceAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            bFound = FALSE;
        }
        
        else
        {
            bFound = TRUE;
        }

        *ppse = pse;
        
        break;
        
    } while ( FALSE );


    TRACEGROUP1( GROUP, "LEAVING FindSourceEntry : %x", bFound );

    return bFound;
}



//----------------------------------------------------------------------------
// CreateOutInterfaceEntry
//
// This function creates an outgoing interface entry for source.
//----------------------------------------------------------------------------

DWORD
CreateOutInterfaceEntry(
    PLIST_ENTRY                 pleOutIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    POUT_IF_ENTRY *             ppoie
)
{

    POUT_IF_ENTRY               poie = NULL;

    DWORD                       dwErr = NO_ERROR;


    TRACEGROUP5(
        GROUP, "ENTERED CreateOutInterfaceEntry : Interface : %x, %x : "
        "Protocol : %x, %x, IGMP : %x", dwIfIndex, dwIfNextHopAddr,
        dwProtocolId, dwComponentId, bIGMP
        );

        
    do
    {
        *ppoie = NULL;

        
        //
        // allocate out interface entry
        //
        
        poie = MGM_ALLOC( sizeof( OUT_IF_ENTRY ) );

        if ( poie == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( ANY, "CreateOutInterfaceEntry : Could not allocate"
                         "out interface entry %x", dwErr );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }


        //
        // initialize entry
        //

        ZeroMemory( poie, sizeof( OUT_IF_ENTRY ) );
        

        poie-> dwIfIndex        = dwIfIndex;

        poie-> dwIfNextHopAddr  = dwIfNextHopAddr;

        poie-> dwProtocolId     = dwProtocolId;

        poie-> dwComponentId    = dwComponentId;

        poie-> wForward         = 1;


        if ( bIGMP )
        {
            SET_ADDED_BY_IGMP( poie );
            poie-> wNumAddsByIGMP = 1;
        }

        else
        {
            SET_ADDED_BY_PROTOCOL( poie );
            poie-> wNumAddsByRP = 1;
        }


        //
        // insert into the out interface list
        //
        
        InsertTailList( pleOutIfList, &poie-> leIfList );

        *ppoie = poie;

        
    } while ( FALSE );


    TRACEGROUP1( GROUP, "LEAVING CreateOutInterfaceEntry : %x", dwErr );

    return dwErr;
}


//----------------------------------------------------------------------------
//
//
//
//----------------------------------------------------------------------------

POUT_IF_ENTRY
GetOutInterfaceEntry(
    PLIST_ENTRY                 pleOutIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId
)
{
    POUT_IF_ENTRY               poie = NULL;
    BOOL                        bNewComp = FALSE;

    
    if ( FindOutInterfaceEntry( 
            pleOutIfList, dwIfIndex, dwIfNextHopAddr, dwProtocolId,
            dwComponentId, &bNewComp, &poie ) )
    {
        return poie;
    }

    return NULL;
    
}


//----------------------------------------------------------------------------
// DeleteOutInterfaceEntry
//
// Deletes an outgoing interface entry from the OIL of a source entry.
//----------------------------------------------------------------------------

VOID
DeleteOutInterfaceEntry(
    POUT_IF_ENTRY               poie
)
{
    TRACEGROUP2( 
        GROUP, "ENTERED DeleteOutInterfaceEntry : Interface %x, %x",
        poie-> dwIfIndex, poie-> dwIfNextHopAddr
        );
        
    RemoveEntryList( &poie-> leIfList );

    MGM_FREE( poie );

    TRACEGROUP0( GROUP, "LEAVING DeleteOutInterfaceEntry" );
}


//----------------------------------------------------------------------------
// FindOutInterfaceEntry
//
// If entry is found the ppoie parameter returns a pointer to the 
// specified interface entry.  
//
// If entry is not found the ppoie parameter is set to the "following" entry.
// This serves as an insertion spot in case a new entry is to inserted when
// none is found.
// 
// if the interface list specified by pleOutIfList is empty then ppoie is set
// to NULL.
//
//----------------------------------------------------------------------------

BOOL
FindOutInterfaceEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    PBOOL                       pbNewComponent,   
    POUT_IF_ENTRY *             ppoie
)
{

    BOOL                        bFound = FALSE;

    INT                         iCmp = 0;

    PLIST_ENTRY                 ple = NULL;
    
    POUT_IF_ENTRY               poie = NULL;



    TRACEGROUP4( 
        GROUP, "ENTERED FindOutInterfaceEntry : %x %x, Protocol %x %x", 
        dwIfIndex, dwIfNextHopAddr, dwProtocolId, dwComponentId
        );

        
    *ppoie = NULL;
    *pbNewComponent = TRUE;

    //
    // Scan the out going interface list.
    // The outgoing interface list is ordered by ( protocol, component) Id
    // and within each protocol component by (interface id, next hop addr)
    //

    for ( ple = pleIfList-> Flink; ple != pleIfList; ple = ple-> Flink )
    {
        poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

        //
        // is same protocol
        //

        if ( poie-> dwProtocolId < dwProtocolId )
        {
            continue;
        }

        else if ( poie-> dwProtocolId > dwProtocolId )
        {
            //
            // Interface entry not found
            //

            *ppoie = poie;
            break;
        }


        //
        // same protocol
        //
            
        //
        // is same component
        //

        if ( poie-> dwComponentId < dwComponentId ) 
        {
            continue;
        }

        else if ( poie-> dwComponentId > dwComponentId )
        {
            //
            // Interface entry not found
            //

            *ppoie = poie;
            break;
        }


        //
        // same component
        //

        *pbNewComponent = FALSE;
        

        //
        // is same interface
        //

        if ( poie-> dwIfIndex < dwIfIndex )
        {
            continue;
        }

        else if ( poie-> dwIfIndex > dwIfIndex )
        {
            //
            // interface not found
            //

            *ppoie = poie;
            break;
        }


        //
        // is same next hop addr
        // to do IP address comparison function.
        //

        if ( INET_CMP( poie-> dwIfNextHopAddr, dwIfNextHopAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // interface not found
            //
                
            *ppoie = poie;
            break;
        }


        //
        // at last, got the interface
        //

        *ppoie = poie;
        bFound = TRUE;
        break;
    }


    TRACEGROUP1( GROUP, "LEAVING FindOutInterfaceEntry : %x", bFound );
    
    return bFound;
}



//----------------------------------------------------------------------------
// AddInterfaceToSourceEntry
//
// This function adds an interface to the outgoing interface list of a 
// (source, group) entry.  For an (S, G) entry the corresponding mfe outgoing
// interface list is also updated to reflect this addition.  For a (*, G) enry, 
// the mfe outgoing interface list for all source entries is updated,
// and for a (*, *) entry mfes for all sources, for all groups are updated.
//
//----------------------------------------------------------------------------

DWORD
AddInterfaceToSourceEntry(
    PPROTOCOL_ENTRY             ppe,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    BOOL                        bIGMP,
    PBOOL                       pbUpdateMfe,
    PLIST_ENTRY                 pleSourceList
)
{
    DWORD                       dwGrpBucket, dwSrcBucket;

    DWORD                       dwErr = NO_ERROR;
    
    BOOL                        bFound = FALSE, bNewGrp = FALSE, 
                                bNewSrc = FALSE, bNewComp = FALSE,
                                bUpdateMfe = TRUE, bgeLock = FALSE;

    PPROTOCOL_ENTRY             ppeEntry = NULL;
    
    PGROUP_ENTRY                pge = NULL, pgeNew = NULL;

    PSOURCE_ENTRY               pse = NULL, pseNew = NULL;

    POUT_IF_ENTRY               poie = NULL, poiePrev = NULL;

    PLIST_ENTRY                 pleGrpList = NULL, pleSrcList = NULL, 
                                ple = NULL;

    
    TRACEGROUP2(
        GROUP, "ENTERED AddInterfaceToSourceEntry : Group %x, %x",
        dwGroupAddr, dwGroupMask
        );

    TRACEGROUP2( GROUP, "Source : %x, %x", dwSourceAddr, dwSourceMask );

    TRACEGROUP2( GROUP, "Interface : %x, %x", dwIfIndex, dwIfNextHopAddr );
    

    do
    {
        *pbUpdateMfe = FALSE;
        
        //
        // Lock group bucket
        //
        
        dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );

        ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );


        //
        // find group entry
        //

        pleGrpList = GROUP_BUCKET_HEAD( dwGrpBucket );
        
        bFound = FindGroupEntry( 
                    pleGrpList, dwGroupAddr, dwGroupMask, &pge, TRUE 
                    );

        if ( !bFound )
        {
            //
            // No existing entry for this group
            // create a group entry.
            //

            if ( pge == NULL )
            {
                //
                // group bucket is null
                //
                
                dwErr = CreateGroupEntry( 
                            pleGrpList, dwGroupAddr, dwGroupMask, 
                            &pgeNew
                            );
            }

            else
            {
                dwErr = CreateGroupEntry( 
                            &pge-> leGrpHashList, dwGroupAddr, dwGroupMask, 
                            &pgeNew
                            );
            }

            
            if ( dwErr != NO_ERROR )
            {
                break;
            }
            
            pge = pgeNew;

            bNewGrp = TRUE;
        }


        //
        // find source entry
        //

        //
        // lock the group entry first
        //

        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        bgeLock = TRUE;
        
        dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

        pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

        bFound = FindSourceEntry( 
                    pleSrcList, dwSourceAddr, dwSourceMask, &pse, TRUE
                    );

        if ( !bFound )
        {
            //
            // create the source entry
            //

            if ( pse == NULL )
            {
                //
                // source bucket is null
                //
                
                dwErr = CreateSourceEntry( 
                            pge, pleSrcList, dwSourceAddr, dwSourceMask, 
                            &pseNew
                        );
            }

            else
            {
                dwErr = CreateSourceEntry( 
                            pge, &pse-> leSrcHashList, dwSourceAddr, 
                            dwSourceMask, &pseNew
                        );
            }

            if ( dwErr != NO_ERROR )
            {
                break;
            }

            pse = pseNew;

            pge-> dwSourceCount++;

            bNewSrc = TRUE;
        }


        //
        // Check if the group been added falls with a scoped boundary
        // on this interface
        //

        if ( IS_HAS_BOUNDARY_CALLBACK() &&
             HAS_BOUNDARY_CALLBACK() ( dwIfIndex, dwGroupAddr ) )
        {
            //
            // Group is administratively scoped on this interface
            // Insert the interface into the list of scoped interfaces
            //

            bFound = FindOutInterfaceEntry( 
                        &pse-> leScopedIfList, dwIfIndex, dwIfNextHopAddr, 
                        ppe-> dwProtocolId, ppe-> dwComponentId, &bNewComp,
                        &poie 
                        );

            if ( !bFound )
            {
                //
                // Interface not present in scoped interfaces list.
                // add it.
                //

                TRACEGROUP0( GROUP, "Group entry scoped & added" );

                ple = ( poie == NULL ) ? &pse-> leScopedIfList :
                                         &poie-> leIfList;

                dwErr = CreateOutInterfaceEntry(
                            ple, dwIfIndex, dwIfNextHopAddr,
                            ppe-> dwProtocolId, ppe-> dwComponentId, 
                            bIGMP, &poie
                            );

                if ( dwErr == NO_ERROR )
                {
                    //
                    // increment the out i/f count
                    //

                    pse-> dwOutIfCount++;
                }
            }

            else
            {
                //
                // Interface already present in scoped interface list.
                // Since IGMP and a Routing protocol could be running
                // on this interface, it is possibly that this interface
                // was added by IGMP and is now being added by the routing
                // protocol or vice versa.  Make sure to set the right
                // flags and update join counts.
                //

                TRACEGROUP0( GROUP, "Group entry scoped & updated" );
                
                if ( bIGMP )
                {
                    SET_ADDED_BY_IGMP( poie );
                    poie-> wNumAddsByIGMP = 1;
                }

                else
                {
                    SET_ADDED_BY_PROTOCOL( poie );
                    poie-> wNumAddsByRP = 1;
                }

                dwErr = NO_ERROR;
            }

            TRACEGROUP1( GROUP, "Group entry scoped : %lx", dwErr );

            break;
        }


        //
        // Find interface entry in OIL
        //

        bFound = FindOutInterfaceEntry( 
                    &pse-> leOutIfList, dwIfIndex, dwIfNextHopAddr, 
                    ppe-> dwProtocolId, ppe-> dwComponentId, &bNewComp, &poie
                    );

        if ( !bFound )
        {
            //
            // Create interface entry 
            //

            if ( poie == NULL )
            {
                dwErr = CreateOutInterfaceEntry( 
                            &pse-> leOutIfList, dwIfIndex, dwIfNextHopAddr,
                            ppe-> dwProtocolId, ppe-> dwComponentId, 
                            bIGMP, &poie
                            );
            }
            
            else
            {
                dwErr = CreateOutInterfaceEntry( 
                            &poie-> leIfList, dwIfIndex, dwIfNextHopAddr,
                            ppe-> dwProtocolId, ppe-> dwComponentId,
                            bIGMP, &poie
                            );
            }

            
            if ( dwErr != NO_ERROR )
            {
                break;
            }


            //
            // update count of number of outgoing interfaces and
            // count of number of routing protocol components that
            // have added interfaces to the out going i/f list
            //
            
            pse-> dwOutIfCount++;


            if ( bNewComp )
            {
                pse-> dwOutCompCount++;

                InvokeJoinAlertCallbacks( pge, pse, poie, bIGMP, ppe );
            }

            
        }
        
        else
        {
            //
            // interface entry found in the out interface list
            //

            if ( bIGMP )
            {
                //
                // interface entry is being added by IGMP
                //
                
                //
                // if interface entry was previously added by
                // IGMP, no further processing is necessary (no mfe updates)
                //
                
                if ( IS_ADDED_BY_IGMP( poie ) )
                {
                    bUpdateMfe = FALSE;
                }

                else
                {
                    //
                    // flag interface as added by IGMP
                    //
                    
                    SET_ADDED_BY_IGMP( poie );
                    
                    poie-> wNumAddsByIGMP = 1;


                    //
                    // inform routing protocol (if any) that co-exists with IGMP
                    // on this interface
                    //

                    if ( IS_ROUTING_PROTOCOL( ppe )  &&
                         IS_LOCAL_JOIN_ALERT( ppe ) )
                    {
                        LOCAL_JOIN_ALERT( ppe )(
                                dwSourceAddr, dwSourceMask, dwGroupAddr, 
                                dwGroupMask, dwIfIndex, dwIfNextHopAddr
                            );
                    }
                }
            }

            else
            {
                //
                // Interface is being added by routing protocol
                //
                
                //
                // if interface entry was previously added by the 
                // routing protocol, no further processing is necessary.
                // 
                
                if ( IS_ADDED_BY_PROTOCOL( poie ) )
                {
                    bUpdateMfe = FALSE;
                }


                //
                // flag interface as added by routing protocol
                //
                
                SET_ADDED_BY_PROTOCOL( poie );

                poie-> wNumAddsByRP = 1;
            }
        }

    } while ( FALSE );


    //
    // error finding/creating the entry
    //

    if ( dwErr != NO_ERROR )
    {
        if ( bNewSrc )
        {
            DeleteSourceEntry( pse );
        }

        if ( bgeLock )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }
        
        if ( bNewGrp )
        {
            DeleteGroupEntry( pge );
        }

        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
        
        return dwErr;
    }
    

    //------------------------------------------------------------------------
    //
    // MFE Update
    //
    //------------------------------------------------------------------------

    if ( !bUpdateMfe )
    {
        if ( bgeLock )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }
        
        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );

        return dwErr;
    }
    
    //
    // Is the source entry that was updated an MFE ?
    // 
    // If so update the OIL for the MFE.
    //

    if ( IS_VALID_INTERFACE( pse-> dwInIfIndex, pse-> dwInIfNextHopAddr )  )
    {
        //
        // TO BE DONE :
        //  Invoke CREATION_ALERT for MFE.
        //
        
        AddInterfaceToSourceMfe( 
            pge, pse, dwIfIndex, dwIfNextHopAddr, 
            ppe-> dwProtocolId, ppe-> dwComponentId, bIGMP, NULL
            );
    }

    //
    //  Is this a wildcard (source, group) entry, if so you
    //  need update the OIL of all (source, group) with this
    //  interface.
    //

    if ( IS_WILDCARD_GROUP( dwGroupAddr, dwGroupMask ) )
    {
        //
        // you are in for the big kahuna
        //

        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );

        *pbUpdateMfe = TRUE;
    }

    else if ( IS_WILDCARD_SOURCE( dwSourceAddr, dwSourceMask ) )
    {
        //
        // you 're in for a kahuna all right. But big nahh.
        //

        *pbUpdateMfe = TRUE;

        AddInterfaceToGroupMfe (
            pge, dwIfIndex, dwIfNextHopAddr,
            ppe-> dwProtocolId, ppe-> dwComponentId, bIGMP,
            FALSE, pleSourceList
        );

        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
    }

    else
    {
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        
        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
    }

    TRACEGROUP1( GROUP, "LEAVING AddInterfaceToSourceEntry %x", dwErr );

    return dwErr;
}


//----------------------------------------------------------------------------
// AddInterfaceToAllMfe
//
// This functions adds an interface the outgoing interface of a MFE. Duh 
//----------------------------------------------------------------------------

VOID
AddInterfaceToAllMfeInGroupBucket(
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    DWORD                       dwInd,
    BOOL                        bIGMP,
    BOOL                        bAdd,
    PLIST_ENTRY                 pleSourceList
)
{
    PLIST_ENTRY                 ple = NULL, pleGrpList = NULL;

    PGROUP_ENTRY                pge = NULL;

    
    TRACEGROUP3(
        GROUP, "ENTERED (%d) AddInterfaceToAllMfeInGroupBucket : %x, %x",
        dwInd, dwIfIndex, dwIfNextHopAddr
        );

    //
    // lock the group bucket
    //

    ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwInd );


    //
    // for each group entry in the bucket
    //

    pleGrpList = GROUP_BUCKET_HEAD( dwInd );
    
    for ( ple = pleGrpList-> Flink;
          ple != pleGrpList;
          ple = ple-> Flink )
    {
        pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpHashList );

        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

        AddInterfaceToGroupMfe(
            pge, dwIfIndex, dwIfNextHopAddr,
            dwProtocolId, dwComponentId, bIGMP,
            bAdd, pleSourceList
            );
            
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }

    //
    // release group lock
    //
    
    RELEASE_GROUP_LOCK_EXCLUSIVE( dwInd );

    TRACEGROUP0( GROUP, "LEAVING AddInterfaceToAllMfeInGroupBucket" );

    return;
}



//----------------------------------------------------------------------------
// AddInterfaceToAllGroupMfe
//
// This functions adds an interface the outgoing interface of a MFE. Duh 
//
// Assumes that the group bucket is locked.
//----------------------------------------------------------------------------

VOID
AddInterfaceToGroupMfe(
    PGROUP_ENTRY                pge,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    BOOL                        bAdd,
    PLIST_ENTRY                 pleSourceList
)
{
    PLIST_ENTRY                 pleSource, pleSrcHead;

    PSOURCE_ENTRY               pse = NULL;

    
    TRACEGROUP2(
        GROUP, "ENTERED AddInterfaceToGroupMfe : Group %x, %x",
        pge-> dwGroupAddr, pge-> dwGroupMask
        );


    MergeTempAndMasterSourceLists( pge );

    //
    // For each source in this bucket
    //

    pleSrcHead = MASTER_SOURCE_LIST_HEAD( pge );
    
    for ( pleSource = pleSrcHead-> Flink;
          pleSource != pleSrcHead;
          pleSource = pleSource-> Flink )
    {
        pse = CONTAINING_RECORD( 
                pleSource, SOURCE_ENTRY, leSrcList
                );

        //
        // check for valid incoming interface ==> this 
        // is an MFE too.
        //

        if ( !IS_VALID_INTERFACE( 
                pse-> dwInIfIndex, pse-> dwInIfNextHopAddr ) )
        {
            continue;
        }

        if ( bAdd ) 
        {
            if ( IsForwardingEnabled(
                    pge-> dwGroupAddr, pge-> dwGroupMask,
                    pse-> dwSourceAddr, pse-> dwSourceMask,
                    pleSourceList
                    ) )
            {
                AddInterfaceToSourceMfe(
                    pge, pse, dwIfIndex, dwIfNextHopAddr,
                    dwProtocolId, dwComponentId, bIGMP, NULL
                    );
            }
        }
        
        else
        {
            AddToCheckForCreationAlertList(
                pge-> dwGroupAddr, pge-> dwGroupMask,
                pse-> dwSourceAddr, pse-> dwSourceMask,
                pse-> dwInIfIndex, pse-> dwInIfNextHopAddr,
                pleSourceList
                );
        }
    }

    TRACEGROUP0( GROUP, "LEAVING AddInterfaceToGroupMfe" );

    return;
}


//----------------------------------------------------------------------------
// AddInterfaceToSourceMfe
//
// This functions adds an interface the outgoing interface of a MFE. Duh 
//----------------------------------------------------------------------------

VOID
AddInterfaceToSourceMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    POUT_IF_ENTRY *             ppoie
)
{
    BOOL                        bFound = FALSE, bNegativeEntry = FALSE,
                                bNewComp = FALSE;

    DWORD                       dwErr = NO_ERROR;
                                
    PPROTOCOL_ENTRY             ppe = NULL;

    POUT_IF_ENTRY               poie = NULL, poieNew = NULL;
    
    PLIST_ENTRY                 pleOutList = NULL;

    MGM_IF_ENTRY                mie;
    

    TRACEGROUP2(
        GROUP, "ENTERED AddInterfaceToSourecMfe : Source : %x, %x",
        pse-> dwSourceAddr, pse-> dwSourceMask
        );

    do
    {
        //
        // check if the interface being added to the MFE is the same
        // as the incoming interface.  If so quit.
        //

        if ( ( pse-> dwInIfIndex == dwIfIndex ) &&
             ( pse-> dwInIfNextHopAddr == dwIfNextHopAddr ) )
        {
            break;
        }


        //
        // Check if the incoming interface has a scoped boundary on it.
        // If it is, then this is a negative MFE that should remain
        // negative, even if outgoing interfaces are present for this
        // group.  This ensures that group traffic is not forwarded from
        // outside the scope into the scope.
        //

        if ( IS_HAS_BOUNDARY_CALLBACK() &&
             HAS_BOUNDARY_CALLBACK()( pse-> dwInIfIndex, pge-> dwGroupAddr ) )
        {
            TRACE2( 
                GROUP, "Group %lx scoped on incoming i/f %lx", 
                pge-> dwGroupAddr, pse-> dwInIfIndex
                );
                
            break;
        }
        

#if 0        
        //
        // invoke creation alert to the protocol on the interface (being
        // added to the MFE) to make sure that we should be adding this 
        // interface to the OIL of the MFE)
        //

        ppe = GetProtocolEntry( 
                PROTOCOL_LIST_HEAD(), dwProtocolId, dwComponentId
                );

        if ( ppe == NULL )
        {
            break;
        }


        mie.dwIfIndex           = dwIfIndex;
        
        mie.dwIfNextHopAddr     = dwIfNextHopAddr;
        
        mie.bIsEnabled          = TRUE;

        if ( IS_CREATION_ALERT( ppe ) )
        {
            CREATION_ALERT( ppe ) (
                pse-> dwSourceAddr, pse-> dwSourceMask,
                pge-> dwGroupAddr, pge-> dwGroupMask,
                pse-> dwInIfIndex, pse-> dwInIfNextHopAddr,
                1, &mie
                );

            if ( !mie.bIsEnabled )
            {
                TRACE2( 
                    GROUP, "Interface %x, %x pruned by protocol",
                    pse-> dwInIfIndex, pse-> dwInIfNextHopAddr
                    );

                break;
            }
        }
        
#endif
        //
        // check if interface already exists in OIL
        //
        
        pleOutList = &pse-> leMfeIfList;

        bFound = FindOutInterfaceEntry( 
                    pleOutList, dwIfIndex, dwIfNextHopAddr, 
                    dwProtocolId, dwComponentId, &bNewComp, &poie
                    );

        if ( !bFound )
        {
            //
            // create a new entry
            //

            if ( poie == NULL )
            {
                //
                // This is the first interface in the outgoing list.
                // This implies that the entry was previously a NEGATIVE mfe
                //

                bNegativeEntry = TRUE;
                
                dwErr = CreateOutInterfaceEntry(
                            pleOutList, dwIfIndex, dwIfNextHopAddr,
                            dwProtocolId, dwComponentId, bIGMP, &poieNew
                            );
            }

            else
            {
                dwErr = CreateOutInterfaceEntry(
                            &poie-> leIfList, dwIfIndex, dwIfNextHopAddr, 
                            dwProtocolId, dwComponentId, bIGMP, &poieNew
                            );
            }
            
            if ( dwErr != NO_ERROR )
            {
                break;
            }

            pse-> dwMfeIfCount++;
        }

        else
        {
            //
            // Interface entry already exists in the outgoing interface
            // list of the mfe.
            //
            // update reference counts
            //

            if ( bIGMP )
            {
                //
                // Interface added by IGMP
                //
                
                SET_ADDED_BY_IGMP( poie );
                poie-> wNumAddsByIGMP++;
            }

            else
            {
                SET_ADDED_BY_PROTOCOL( poie );
                poie-> wNumAddsByRP++;
            }

            break;
        }


        //
        // If the outgoing interface list was empty before this interface 
        // entry was added implying a negative mfe, send JOIN_ALERT callback
        // to the protocol owning the incoming interface
        //

        if ( bNegativeEntry )
        {
            TRACEGROUP0( GROUP, "MFE was preivously a negative mfe" );

            //
            // get the protocol component owning the incoming interface
            //

            ppe = GetProtocolEntry(
                    &ig.mllProtocolList.leHead,
                    pse-> dwInProtocolId, pse-> dwInComponentId 
                    );

            if ( ppe == NULL )
            {
                TRACE2( 
                    ANY, 
                    "AddInterfaceToSourceMfe : cannot find protocol component :"
                    " %x, %x", pse-> dwInProtocolId, pse-> dwInComponentId
                    );

                LOGERR0( 
                    PROTOCOL_NOT_FOUND, ERROR_NOT_FOUND 
                    );
                    
                break;
            }


            //
            // invoke the new member alert
            //
            
            if ( IS_JOIN_ALERT( ppe ) )
            {
                JOIN_ALERT( ppe )(
                    pse-> dwSourceAddr, pse-> dwSourceMask,
                    pge-> dwGroupAddr, pge-> dwGroupMask, FALSE
                );
            }
        }


        //
        // If a new interface was added to the OIL of the MFE &&
        // if MFE is present in the forwarder, 
        //      update the forwarder entry
        //

        if ( !bFound && pse-> bInForwarder )
        {
            AddMfeToForwarder( pge, pse, 0 );
        }
        
    } while ( FALSE );


    if ( ppoie != NULL )
    {
        *ppoie = poieNew;
    }

    
    TRACEGROUP0( GROUP, "LEAVING AddInterfacetoSourceMfe" );


    return;
}


//----------------------------------------------------------------------------
// DeleteInterfaceFromSource
//
//
// This function deletes an interface from the outgoing interface list of a 
// (source, group) entry.  For an (S, G) entry the corresponding mfe outgoing
// interface list is also updated to reflect this deletion.  For a (*, G) enry,
// the mfe outgoing interface list for all source entries is updated,
// and for a (*, *) entry mfes for all sources, for all groups are updated.
//----------------------------------------------------------------------------

VOID
DeleteInterfaceFromSourceEntry(
    PPROTOCOL_ENTRY             ppe,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    BOOL                        bIGMP
)
{

    DWORD                       dwGrpBucket, dwSrcBucket;
    
    BOOL                        bFound = FALSE, bNewComp = FALSE,
                                bUpdateMfe = FALSE, bGrpLock = FALSE,
                                bGrpEntryLock = FALSE;

    PPROTOCOL_ENTRY             ppeEntry = NULL;
    
    PGROUP_ENTRY                pge = NULL;

    PSOURCE_ENTRY               pse = NULL;

    POUT_IF_ENTRY               poie = NULL;

    PLIST_ENTRY                 pleGrpList = NULL, pleSrcList = NULL, 
                                ple = NULL, pleProtocol = NULL;

    
    TRACEGROUP2(
        GROUP, "ENTERED DeleteInterfaceFromSourceEntry : Group %x, %x",
        dwGroupAddr, dwGroupMask
        );

    TRACEGROUP2( GROUP, "Source : %x, %x", dwSourceAddr, dwSourceMask );

    TRACEGROUP2( GROUP, "Interface : %x, %x", dwIfIndex, dwIfNextHopAddr );
    

    do
    {
        //--------------------------------------------------------------------
        // Interface deletion from source entry
        //--------------------------------------------------------------------
        
        //
        // Lock group bucket
        //

        dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );

        ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
        bGrpLock = TRUE;
        

        //
        // Find group entry
        //
        
        pleGrpList = GROUP_BUCKET_HEAD( dwGrpBucket );

        bFound = FindGroupEntry( 
                    pleGrpList, dwGroupAddr, dwGroupMask, &pge, TRUE
                    );

        if ( !bFound )
        {
            break;
        }

        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        bGrpEntryLock = TRUE;
        
                    
        //
        // Found group entry, find source entry
        //

        dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );
        
        pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );
        
        bFound = FindSourceEntry(
                    pleSrcList, dwSourceAddr, dwSourceMask, &pse, TRUE
                    );

        if ( !bFound )
        {
            break;
        }
                    

        //
        // Found source entry, find interface entry in the 
        // outgoing list
        //

        bFound = FindOutInterfaceEntry( 
                    &pse-> leOutIfList, dwIfIndex, dwIfNextHopAddr, 
                    ppe-> dwProtocolId, ppe-> dwComponentId, &bNewComp, 
                    &poie
                    );

        if ( !bFound )
        {
            //
            // Interface not found in OIL.  Check if this interface
            // has a scoped boundary for this group.  If so delete it
            // from the scoped list and quit.
            //

            bFound = FindOutInterfaceEntry( 
                        &pse-> leScopedIfList, dwIfIndex, dwIfNextHopAddr, 
                        ppe-> dwProtocolId, ppe-> dwComponentId, &bNewComp, 
                        &poie
                        );

            if ( bFound )
            {
                //
                // clear appropriate counts/flags on the interface
                //
                
                TRACEGROUP0( GROUP, "Scoped interface" );

                if ( bIGMP )
                {
                    poie-> wNumAddsByIGMP = 0;
                    CLEAR_ADDED_BY_IGMP( poie );
                }

                else
                {
                    poie-> wNumAddsByRP = 0;
                    CLEAR_ADDED_BY_PROTOCOL( poie );
                }


                //
                // Delete this interface if counts are zero
                //

                if ( !IS_ADDED_BY_IGMP( poie ) &&
                     !IS_ADDED_BY_PROTOCOL( poie ) )
                {
                    TRACEGROUP0( GROUP, "Scoped interface deleted" );

                    DeleteOutInterfaceEntry( poie );
                    poie = NULL;


                    //
                    // Decrement OIF count.  If count is 0, and this
                    // source is not an MFE, delete the source entry
                    //
                    
                    pse-> dwOutIfCount--;

                    if ( ( pse-> dwOutIfCount == 0 ) &&
                         !IS_VALID_INTERFACE( 
                            pse-> dwInIfIndex, pse-> dwInIfNextHopAddr ) )
                    {
                        DeleteSourceEntry( pse );

                        pse = NULL;

                        pge-> dwSourceCount--;
                    }


                    //
                    // if there are no more sources for this group, remove 
                    // group entry
                    //
                    
                    if ( pge-> dwSourceCount == 0 )
                    {
                        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                        bGrpEntryLock = FALSE;
                        
                        DeleteGroupEntry( pge );
                        pge = NULL;
                    }
                }
            }
            
            break;
        }


        //
        // Outgoing interface found.  decrement ref counts.
        //

        if ( bIGMP && IS_ADDED_BY_IGMP( poie ) )
        {
            poie-> wNumAddsByIGMP = 0;

            CLEAR_ADDED_BY_IGMP( poie );

            bUpdateMfe = TRUE;

            if ( IS_LOCAL_LEAVE_ALERT( ppe ) )
            {
                LOCAL_LEAVE_ALERT( ppe )(
                    dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask,
                    dwIfIndex, dwIfNextHopAddr
                    );
            }
        }

        else if ( !bIGMP && IS_ADDED_BY_PROTOCOL( poie ) )
        {
            poie-> wNumAddsByRP = 0;
            
            CLEAR_ADDED_BY_PROTOCOL( poie );

            bUpdateMfe = TRUE;
        }

    } while( FALSE );


    //
    // if interface was not found in the outgoing interface list
    //      of specified (source, group) entry   OR
    // No interface was deleted
    // return right here.
    //
    
    if ( !bFound || !bUpdateMfe )
    {
        if ( bGrpEntryLock )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }
        
        if ( bGrpLock )
        {
            RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
        }

        return;
    }



    do
    {
        //
        // if no more reference to this interface entry, delete it.
        //

        if ( !IS_ADDED_BY_IGMP( poie ) &&
             !IS_ADDED_BY_PROTOCOL( poie ) )
        {
            DeleteOutInterfaceEntry( poie );

            poie = NULL;
            

            //
            // Update interface and component counts
            //
            
            pse-> dwOutIfCount--;


            //
            // check if this interface deletion has resulted in decreasing
            // the number of protocol components that have added interfaces
            // to the OIL.
            //
            // To do this try to find the interface we just deleted again, in
            // the OIL and see if bNewComp is set to TRUE.
            //
            // if bNewComp == TRUE, then the interface just deleted was
            // the last interface in the OIL for the protocol component.
            //

            bNewComp = FALSE;
            
            FindOutInterfaceEntry(
                    &pse-> leOutIfList, dwIfIndex, dwIfNextHopAddr, 
                    ppe-> dwProtocolId, ppe-> dwComponentId, &bNewComp, 
                    &poie
                );


            if ( bNewComp )
            {
                pse-> dwOutCompCount--;

                InvokePruneAlertCallbacks( 
                    pge, pse, dwIfIndex, dwIfNextHopAddr, ppe 
                    );
            }
        }


        //--------------------------------------------------------------------
        // source/group entry deletion
        //--------------------------------------------------------------------

        //
        // If there are no more interfaces in the OIL and this source
        // is not an MFE, the source entry can be deleted
        //

        if ( ( pse-> dwOutIfCount == 0 ) &&
             !IS_VALID_INTERFACE( 
                pse-> dwInIfIndex, pse-> dwInIfNextHopAddr ) )
        {
            DeleteSourceEntry( pse );

            pse = NULL;

            pge-> dwSourceCount--;
        }


        //
        // if there are no more sources for this group, remove group entry
        //
        
        if ( pge-> dwSourceCount == 0 )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            
            DeleteGroupEntry( pge );
            pge = NULL;
        }


        //--------------------------------------------------------------------
        // MFE update 
        //--------------------------------------------------------------------
        
        if ( IS_WILDCARD_GROUP( dwGroupAddr, dwGroupMask ) )
        {
            //
            // (*, *) entry
            //

            if ( pge != NULL )
            {
                RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            }
            
            RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );

            DeleteInterfaceFromAllMfe(
                dwIfIndex, dwIfNextHopAddr,
                ppe-> dwProtocolId, ppe-> dwComponentId, bIGMP
                );
        }

        else if ( IS_WILDCARD_SOURCE( dwSourceAddr, dwSourceMask ) )
        {
            //
            // (*, G) entry
            //

            if ( pge != NULL )
            {
                DeleteInterfaceFromGroupMfe(
                    pge, dwIfIndex, dwIfNextHopAddr, ppe-> dwProtocolId,
                    ppe-> dwComponentId, bIGMP
                    );

                RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            }
            
            RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
        }

        else
        {
            //
            // (S, G) entry.
            //

            //
            // Does this (S, G) entry have a corresponding MFE ?
            // Check to see if it has a valid incoming interface
            //

            if ( pse != NULL &&
                 IS_VALID_INTERFACE( 
                    pse-> dwInIfIndex, pse-> dwInIfNextHopAddr ) )
            {
                DeleteInterfaceFromSourceMfe( 
                    pge, pse, dwIfIndex, dwIfNextHopAddr, ppe-> dwProtocolId,
                    ppe-> dwComponentId, bIGMP, FALSE
                    );
            }

            if ( pge != NULL )
            {
                RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            }
            
            RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
        }

    } while ( FALSE );


    TRACEGROUP0( GROUP, "LEAVING DeleteInterfaceFromSourceEntry" );


    return;
}


//----------------------------------------------------------------------------
// DeleteInterfaceFromAllMfe
//
// This function is invoked when an interface is deleted from the outgoing
// list of a (*, *) entry.  It walks the entire group table and updates
// every mfe for every source to reflect the deletion of this interface.
//----------------------------------------------------------------------------


VOID
DeleteInterfaceFromAllMfe(
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP
    
)
{
    DWORD                       dwInd;

    PGROUP_ENTRY                pge = NULL;

    PLIST_ENTRY                 ple = NULL;
    
    
    TRACEGROUP2(
        GROUP, "ENTERED DeleteInterfaceFromAllMfe : %x, %x",
        dwIfIndex, dwIfNextHopAddr
        );

    //
    // for each group bucket
    //

    for ( dwInd = 0; dwInd < GROUP_TABLE_SIZE; dwInd++ )
    {
        //
        // for each group
        //

        ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwInd );


        for ( ple = ig.pmllGrpHashTable[ dwInd ].leHead.Flink;
              ple != &ig.pmllGrpHashTable[ dwInd ].leHead;
              ple = ple-> Flink )
        {
            pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpHashList );

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            
            DeleteInterfaceFromGroupMfe(
                pge, dwIfIndex, dwIfNextHopAddr, dwProtocolId, 
                dwComponentId, bIGMP
                );

            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }

        
        RELEASE_GROUP_LOCK_EXCLUSIVE( dwInd );
    }
    
    TRACEGROUP0( GROUP, "LEAVING DeleteInterfaceFromAllMfe" );
}


//----------------------------------------------------------------------------
// DeleteInterfaceFromGroupMfe
//
// This function is invoked when an interface is deleted from the outgoing
// list of a (*, G) or (*, *) entry.  It walks all the sources for a group
// and updates every mfe to reflect the deletion of this interface.
//----------------------------------------------------------------------------


VOID
DeleteInterfaceFromGroupMfe(
    PGROUP_ENTRY                pge,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP
    
)
{
    DWORD                       dwInd = 0;

    PLIST_ENTRY                 ple = NULL;

    PSOURCE_ENTRY               pse = NULL;

    
    TRACEGROUP2(
        GROUP, "ENTERED DeleteInterfaceFromGroupMfe : Group : %x, %x",
        pge-> dwGroupAddr, pge-> dwGroupMask 
        );


    //
    // for each bucket
    //

    for ( dwInd = 0; dwInd < SOURCE_TABLE_SIZE; dwInd++ )
    {
        //
        // for each source entry.
        //

        for ( ple = pge-> pleSrcHashTable[ dwInd ].Flink;
              ple != &pge-> pleSrcHashTable[ dwInd ];
              ple = ple-> Flink )
        {
            pse = CONTAINING_RECORD( ple, SOURCE_ENTRY, leSrcHashList );

            if ( !IS_VALID_INTERFACE( 
                    pse-> dwInIfIndex, pse-> dwInIfNextHopAddr ) )
            {
                continue;
            }

            DeleteInterfaceFromSourceMfe(
                pge, pse, dwIfIndex, dwIfNextHopAddr, 
                dwProtocolId, dwComponentId, bIGMP, FALSE
                );
        }
    }

    TRACEGROUP0( GROUP, "LEAVING DeleteInterfaceFromGroupMfe" );
}


//----------------------------------------------------------------------------
// DeleteInterfaceFromSourceMfe
//
// This function deletes an interface from the mfe outgoing list
//----------------------------------------------------------------------------

VOID
DeleteInterfaceFromSourceMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    BOOL                        bDel
)
{
    BOOL                        bFound, bNewComp, bUpdateForwarder = FALSE;

    DWORD                       dwTimeOut = 0, dwTimerQ;
    
    POUT_IF_ENTRY               poie = NULL;

    PPROTOCOL_ENTRY             ppe = NULL;

    
    TRACEGROUP4(
        GROUP, "ENTERED DeleteInterfaceFromSourceMfe : Source %x, %x"
        "Interface %x, %x",
        pse-> dwSourceAddr, pse-> dwSourceMask, dwIfIndex, dwIfNextHopAddr
        );

    
    //
    // delete interface from the mfe outgoing interface list
    //
        
    bFound = FindOutInterfaceEntry( 
                &pse-> leMfeIfList, dwIfIndex, dwIfNextHopAddr, 
                dwProtocolId, dwComponentId, &bNewComp, &poie
                );

    if ( bFound )
    {
        //
        // decrement the reference counts
        //

        if ( bIGMP && IS_ADDED_BY_IGMP( poie ) )
        {
            poie-> wNumAddsByIGMP--;

            if ( poie-> wNumAddsByIGMP == 0 )
            {
                CLEAR_ADDED_BY_IGMP( poie );
            }
        }

        else if ( !bIGMP && IS_ADDED_BY_PROTOCOL( poie ) )
        {
            poie-> wNumAddsByRP--;

            if ( poie-> wNumAddsByRP == 0 )
            {
                CLEAR_ADDED_BY_PROTOCOL( poie );
            }
        }


        //
        // This interface is not required by either IGMP or the 
        // routing protocol on the interface, delete it
        //
        
        if ( bDel ||
             ( !IS_ADDED_BY_IGMP( poie ) && !IS_ADDED_BY_PROTOCOL( poie ) ) )
            
        {
            DeleteOutInterfaceEntry( poie );

            poie = NULL;

            bUpdateForwarder = pse-> bInForwarder;

            pse-> dwMfeIfCount--;
        }

        
        //--------------------------------------------------------------------
        // NEGATIVE mfe check
        // if mfe out interface list is empty
        //--------------------------------------------------------------------

        if ( IsListEmpty( &pse-> leMfeIfList ) )
        {
            TRACEGROUP0( GROUP, "MFE OIL is empty ==> Negative Mfe" );

            
            //
            // Invoke delete member callback for component that
            // owns the incoming interface.
            //

            ppe = GetProtocolEntry( 
                    &ig.mllProtocolList.leHead, pse-> dwInProtocolId, 
                    pse-> dwInComponentId
                    );

            if ( ppe == NULL )
            {
                TRACE2( 
                    ANY, 
                    "DeleteInterfaceFromSourceMfe : Protocol not found"
                    "%x, %x",
                    pse-> dwInProtocolId, pse-> dwInComponentId
                    );
            }

            else if ( IS_PRUNE_ALERT( ppe ) )
            {
                PRUNE_ALERT( ppe ) (
                    pse-> dwSourceAddr, pse-> dwSourceMask, 
                    pge-> dwGroupAddr, pge-> dwGroupMask,
                    pse-> dwInIfIndex, pse-> dwInIfNextHopAddr,
                    FALSE, &dwTimeOut
                    );

                //
                // Reset the timerout value for this MFE to reflect
                // the timer value for the negative MFE
                //

                dwTimerQ = TIMER_TABLE_HASH( pge-> dwGroupAddr );
                                
                RtlUpdateTimer( 
                    TIMER_QUEUE_HANDLE( dwTimerQ ), pse-> hTimer,
                    dwTimeOut, 0
                    );
            }
        }


        //--------------------------------------------------------------------
        // Forwarder update
        //--------------------------------------------------------------------
        
        if ( bUpdateForwarder )
        {
            //
            // router manager callback to set updated mfe to forwarder
            //

            AddMfeToForwarder( pge, pse, dwTimeOut );
        }
    }

    TRACEGROUP0( GROUP, "LEAVING DeleteInterfaceFromSourceMfe" );
}



//----------------------------------------------------------------------------
// LookupAndDeleteYourMfe
//
// 
//----------------------------------------------------------------------------

VOID
LookupAndDeleteYourMfe(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bDeleteTimer,
    PDWORD                      pdwInIfIndex            OPTIONAL,
    PDWORD                      pdwInIfNextHopAddr      OPTIONAL
)
{

    BOOL                        bGrpEntryLock = FALSE;
    
    DWORD                       dwGrpBucket, dwSrcBucket, dwTimerQ;

    PLIST_ENTRY                 pleBucket = NULL;
    
    PGROUP_ENTRY                pge = NULL;

    PSOURCE_ENTRY               pse = NULL;


    TRACEGROUP4(
        GROUP, "ENTERED LookupAndDeleteYourMfe : "
        "Group %x, %x, Source %x, %x", 
        dwGroupAddr, dwGroupMask, dwSourceAddr, dwSourceMask
        );

        
    do
    {
        //
        // lock group bucket
        //
        
        dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );
        
        ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );

        pleBucket = GROUP_BUCKET_HEAD( dwGrpBucket );


        //
        // get group entry
        //
        
        pge = GetGroupEntry( pleBucket, dwGroupAddr, dwGroupMask );

        if ( pge == NULL )
        {
            TRACE2( 
                ANY, "LookupAndDeleteYourMfe : Could not find group entry"
                "%x, %x", dwGroupAddr, dwGroupMask
                );
                
            break;                
        }


        //
        // get source entry
        //

        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        bGrpEntryLock = TRUE;
        
        
        dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

        pleBucket = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );
        
        pse = GetSourceEntry( pleBucket, dwSourceAddr, dwSourceMask );

        if ( pse == NULL )
        {
            TRACE2( 
                ANY, "LookupAndDeleteYourMfe : Could not find source entry"
                "%x, %x", dwGroupAddr, dwGroupMask
                );
                
            break;                
        }


        //
        // save in i/f index/nhop addr if required
        //

        if ( pdwInIfIndex != NULL )
        {
            *pdwInIfIndex = pse-> dwInIfIndex;
        }

        if ( pdwInIfIndex != NULL )
        {
            *pdwInIfNextHopAddr = pse-> dwInIfNextHopAddr;
        }

        
        //
        // remove Mfe
        //
        
        DeleteMfe( pge, pse );


        //
        // Cancel the expiry timer for the MFE is required
        //
        
        if ( bDeleteTimer && ( pse-> hTimer != NULL ) )
        {
            dwTimerQ = TIMER_TABLE_HASH( dwGroupAddr );
            
            RtlDeleteTimer( TIMER_QUEUE_HANDLE( dwTimerQ ), pse-> hTimer, NULL );

            pse-> hTimer = NULL;
        }

        
        //
        // if there are no source specific joins for this source,
        // the this source entry is no longer required.
        //

        if ( IsListEmpty( &pse-> leOutIfList ) )
        {
            DeleteSourceEntry( pse );

            pge-> dwSourceCount--;
        }

    
        //
        // if there are no sources remaining for this group
        // delete the group entry
        //
        
        if ( pge-> dwSourceCount == 0 )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            bGrpEntryLock = FALSE;

            DeleteGroupEntry( pge );

        }
        
    } while ( FALSE );


    if ( bGrpEntryLock )
    {
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }
    
    RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );

    TRACEGROUP0( GROUP, "LEAVING LookupAndDeleteYourMfe" );
}



//----------------------------------------------------------------------------
// DeleteMfe
//
// 
//----------------------------------------------------------------------------

VOID
DeleteMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
)
{
    PLIST_ENTRY                 ple = NULL;

    POUT_IF_ENTRY               poie = NULL;

    
    //
    // Delete all outgoing interfaces from the MFE outgoing list
    //

    while ( !IsListEmpty( &pse-> leMfeIfList ) )
    {
        ple = RemoveHeadList( &pse-> leMfeIfList );

        poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

        DeleteOutInterfaceEntry( poie );
    }


    //
    // reset incoming interface and protocol component
    //
    
    pse-> dwInIfIndex = INVALID_INTERFACE_INDEX;

    pse-> dwInIfNextHopAddr = INVALID_NEXT_HOP_ADDR;

    pse-> dwInProtocolId = INVALID_PROTOCOL_ID;

    pse-> dwInComponentId = INVALID_COMPONENT_ID;


    //
    // Update mfe
    //
    
    if ( pse-> bInForwarder )
    {
        DeleteMfeFromForwarder( pge, pse );
    }
}


//----------------------------------------------------------------------------
// AddToGroupList
//
// 
//----------------------------------------------------------------------------

DWORD
AddToGroupList(
    PGROUP_ENTRY                pge
)
{

    DWORD                       dwErr = NO_ERROR;

    PGROUP_ENTRY                pgeNext = NULL;

    PLIST_ENTRY                 pleTempGrpList = NULL;



    TRACEGROUP2(
        GROUP, "ENTERED AddToGroupList : %x, %x", pge-> dwGroupAddr, 
        pge-> dwGroupMask
        );

        
    //
    // Lock Temp List
    //

    ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE();

    
    do
    {
        //
        // Find appropriate place to insert new entry. 
        //

        pleTempGrpList = TEMP_GROUP_LIST_HEAD();
    
        if ( FindGroupEntry( 
                pleTempGrpList, pge-> dwGroupAddr, pge-> dwGroupMask,
                &pgeNext, FALSE
                ) )
        {
            dwErr = ERROR_ALREADY_EXISTS;
            
            TRACE2( 
                GROUP, "AddToGroupList Group Entry already exists for : %x, %x",
                pge-> dwGroupAddr, pge-> dwGroupMask
                );

            break;
        }


        //
        // Insert new group entry into temp list
        //

        if ( pgeNext != NULL )
        {
            InsertTailList( &pgeNext-> leGrpList, &pge-> leGrpList );
        }
        else
        {
            InsertTailList( pleTempGrpList, &pge-> leGrpList );
        }

        ig.dwNumTempEntries++;


        //
        // if temp list size exceeds thresholds
        // - merge temp list with master group list
        //

        if ( ig.dwNumTempEntries > TEMP_GROUP_LIST_MAXSIZE )
        {
            MergeTempAndMasterGroupLists( pleTempGrpList );
        }

    } while ( FALSE );

    
    //
    // Unlock temp list
    //

    RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE();


    TRACEGROUP1( GROUP, "LEAVING AddToGroupList %d", dwErr );
    
    return dwErr;
}



//----------------------------------------------------------------------------
// MergeWithMasterGroupList
//
// Assumes the temp list is exclusively locked 
//----------------------------------------------------------------------------

VOID
MergeTempAndMasterGroupLists(
    PLIST_ENTRY                 pleTempList
)
{

    PLIST_ENTRY                 pleMasterHead = NULL, pleMaster = NULL,
                                pleTempHead = NULL;

    PGROUP_ENTRY                pgeMaster = NULL, pgeTemp = NULL;

    
    INT                         iCmp;

    
    TRACEGROUP0( GROUP, "ENTERED MergeTempAndMasterGroupLists" );

    
    //
    // Lock Master Group List
    //

    ACQUIRE_MASTER_GROUP_LOCK_EXCLUSIVE();


    do
    {
        //
        // Merge temp list
        //

        if ( IsListEmpty( pleTempList ) )
        {
            break;
        }


        pleMasterHead = MASTER_GROUP_LIST_HEAD();

        pleMaster = pleMasterHead-> Flink;


        //
        // for each entry in the temp list
        //

        while ( !IsListEmpty( pleTempList ) )
        {
            //
            // Remove entry from the temp list
            //

            pleTempHead = RemoveHeadList( pleTempList );
            

            //
            // Insert entry from temp list into the master list
            //

            pgeTemp = CONTAINING_RECORD( 
                    pleTempHead, GROUP_ENTRY, leGrpList 
                    );


            //
            // find its location in the master list
            //
            
            if ( IsListEmpty( pleMasterHead ) )
            {
                //
                // first element in master list, insert w/o searching
                //
                
                InsertTailList( pleMasterHead, pleTempHead );

                pleMaster = pleMasterHead-> Flink;

                continue;
            }

            //
            // At least one element present in the Master list
            //
            
            while ( pleMaster != pleMasterHead )
            {
                pgeMaster = CONTAINING_RECORD(
                            pleMaster, GROUP_ENTRY, leGrpList
                            );

                if ( INET_CMP( 
                        pgeTemp-> dwGroupAddr, pgeMaster-> dwGroupAddr, iCmp
                        ) < 0 )
                {
                    break;
                }

                pleMaster = pleMaster-> Flink;
            }

            
            InsertTailList( pleMaster, pleTempHead );
        }

        ig.dwNumTempEntries = 0;

    } while ( FALSE );


    //
    // Unlock master list
    //

    RELEASE_MASTER_GROUP_LOCK_EXCLUSIVE();

    TRACEGROUP0( GROUP, "LEAVING MergeTempAndMasterGroupLists" );
}


//----------------------------------------------------------------------------
// AddToSourceList
//
// Assumes the group entry is exclusively locked 
//----------------------------------------------------------------------------

DWORD
AddToSourceList(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
)
{

    DWORD           dwErr = NO_ERROR;

    PLIST_ENTRY     pleTempSrcList;

    PSOURCE_ENTRY   pseTemp = NULL;
    

    
    TRACEGROUP2( 
        GROUP, "ENTERED AddToSourceList : %x, %x",
        pse-> dwSourceAddr, pse-> dwSourceMask
        );

    do
    {
        //
        // Insert source entry into temp list
        //

        pleTempSrcList = TEMP_SOURCE_LIST_HEAD( pge );

        if ( FindSourceEntry( pleTempSrcList, pse-> dwSourceAddr,
                              pse-> dwSourceMask, &pseTemp, FALSE ) )
        {
            dwErr = ERROR_ALREADY_EXISTS;
            
            TRACE2( 
                GROUP, "AddToGroupList Source Entry already exists for : %x, %x",
                pse-> dwSourceAddr, pse-> dwSourceMask
                );

            break;
        }


        if ( pseTemp != NULL )
        {
            InsertTailList( &pseTemp-> leSrcList, &pse-> leSrcList );
        }

        else
        {
            InsertTailList( &pge-> leTempSrcList, &pse-> leSrcList );
        }


        //
        // if temp source list size if larger than the threshold
        //

        pge-> dwNumTempEntries++;

        if ( pge-> dwNumTempEntries > TEMP_SOURCE_LIST_MAXSIZE )
        {
            MergeTempAndMasterSourceLists( pge );
        }
        
    } while ( FALSE );


    TRACEGROUP1( GROUP, "LEAVING AddToSourceList : %d", dwErr );

    return dwErr;
}



//----------------------------------------------------------------------------
// MergeWithMasterSourceList
//
// Assumes the group entry is exclusively locked 
//----------------------------------------------------------------------------

VOID
MergeTempAndMasterSourceLists(
    PGROUP_ENTRY                pge
)
{
    INT                         iCmp;
    
    PSOURCE_ENTRY               pseTemp = NULL, pseMaster = NULL;

    PLIST_ENTRY                 pleTemp, pleSrcHead, pleSrc, pleHead;
    

    TRACEGROUP2( 
        GROUP, "ENTERED MergeWithMasterSourceList : %x, %x",
        pge-> dwGroupAddr, pge-> dwGroupMask
        );

        
    do
    {
        //
        // if temp list is entry, quit.
        //

        pleTemp = TEMP_SOURCE_LIST_HEAD( pge );

        if ( pge-> dwNumTempEntries == 0 )
        {
            break;
        }

        
        //
        // Remove each entry from the temp list and
        // insert it into the master list in order
        //

        pleSrcHead = MASTER_SOURCE_LIST_HEAD( pge );

        pleSrc = pleSrcHead-> Flink;
        

        while ( !IsListEmpty( pleTemp ) )
        {
            pleHead = RemoveHeadList( pleTemp );

            pseTemp = CONTAINING_RECORD( 
                        pleHead, SOURCE_ENTRY, leSrcList
                        );

            if ( IsListEmpty( pleSrcHead ) )
            {
                //
                // first element in source master list
                //

                InsertTailList( pleSrcHead, pleHead );

                pleSrc = pleSrcHead-> Flink;

                continue;
            }


            //
            // at least one source present in master source list
            //
            
            while ( pleSrc != pleSrcHead )
            {

                pseMaster = CONTAINING_RECORD( 
                                pleSrc, SOURCE_ENTRY, leSrcList
                                );

                if ( INET_CMP( pseTemp-> dwSourceAddr, 
                               pseMaster-> dwSourceAddr, iCmp ) < 0 )
                {
                    break;  
                }

                pleSrc = pleSrc-> Flink;
            }

            InsertTailList( pleSrc, pleHead );
        }

        pge-> dwNumTempEntries = 0;
        
    } while ( TRUE );


    TRACEGROUP0( GROUP, "LEAVING MergeWithMasterSourceList" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\pchmgm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: pchmgm.h
//
// History:
//      V Raman	Oct-14-1997  Created.
//
// Pre compiled header for MGM
//============================================================================


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <winsock.h>
#include <rtmv2.h>
#include <routprot.h>
#include <raserror.h>
#include <mprerror.h>
#include <rtutils.h>
#include <ddipmcst.h>
#include <iprtrmib.h>
#include "rmrtm.h"
#include "mgmrtm.h"
#include "rmmgm.h"
#include "mgm.h"
#include "defs.h"
#include "sync.h"
#include "ipmgm.h"
#include "protocol.h"
#include "group.h"
#include "if.h"
#include "forward.h"
#include "timer.h"
#include "enum.h"
#include "log.h"
#include "route.h"
#include "scope.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\packet.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: packet.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// New packet processing.
//============================================================================


#include "pchmgm.h"
#pragma hdrstop


BOOL
IsMFEPresent(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bAddToForwarder
);

DWORD
InvokeRPFCallbacks(
    PPROTOCOL_ENTRY *           pppe,
    PIF_ENTRY *                 ppieInIf,
    PDWORD                      pdwIfBucket,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PDWORD                      pdwInIfIndex,
    PDWORD                      pdwInIfNextHopAddr,
    PDWORD                      pdwUpstreamNbr,
    DWORD                       dwHdrSize,
    PBYTE                       pbPacketHdr,
    PHANDLE                     phNextHop,
    PBYTE                       pbBuffer
);


VOID
CopyAndMergeIfLists(
    PLIST_ENTRY                 pleMfeOutIfList,
    PLIST_ENTRY                 pleOutIfList
);


VOID
CopyAndAppendIfList(
    PLIST_ENTRY                 pleMfeIfList,
    PLIST_ENTRY                 pleOutIfList,
    PLIST_ENTRY                 pleOutIfHead
);


VOID
CopyAndAppendIfList(
    PLIST_ENTRY                 pleMfeIfList,
    PLIST_ENTRY                 pleOutIfList,
    PLIST_ENTRY                 pleOutIfHead
);

VOID
InvokeCreationAlert(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwInIfIndex,
    DWORD                       dwInIfNextHopAddr,
    PLIST_ENTRY                 pleMfeOutIfList,
    PDWORD                      pdwMfeOutIfCount
);

BOOL
IsListSame(
    IN          PLIST_ENTRY             pleHead1,
    IN          PLIST_ENTRY             pleHead2
);

VOID
FreeList (
    IN          PLIST_ENTRY             pleHead
);


//----------------------------------------------------------------------------
// MgmNewPacketReceived
//
//----------------------------------------------------------------------------

DWORD
MgmNewPacketReceived(
    DWORD                       dwSourceAddr,
    DWORD                       dwGroupAddr,
    DWORD                       dwInIfIndex,
    DWORD                       dwInIfNextHopAddr,
    DWORD                       dwHdrSize,
    PBYTE                       pbPacketHdr
)
{

    BOOL                        bGrpEntryLock = FALSE,
                                bGrpLock = FALSE,
                                bWCGrpEntryLock = FALSE,
                                bWCGrpLock = FALSE,

                                bGrpFound = FALSE,
                                bSrcFound = FALSE,

                                bIfLock = FALSE;

                                
    DWORD                       dwErr = NO_ERROR,
                                dwIfBucket, 
                                dwUpStreamNbr = 0,
                                dwGroupMask = 0, dwGrpBucket, dwWCGrpBucket,
                                dwSrcBucket, dwWCSrcBucket, 
                                dwSourceMask = 0xFFFFFFFF,
                                dwTimeOut = EXPIRY_INTERVAL, dwTimerQ, 
                                dwOutIfCount = 0;
    

    PPROTOCOL_ENTRY             ppe = NULL;
    

    PIF_ENTRY                   pieInIf = NULL;


    PGROUP_ENTRY                pge = NULL, pgeWC = NULL, pgeNew = NULL;


    PSOURCE_ENTRY               pse = NULL, pseWC = NULL, pseNew = NULL;

    POUT_IF_ENTRY               poie;
    
    PLIST_ENTRY                 pleGrpList = NULL, pleSrcList = NULL,
                                pleWCGrpList = NULL, pleWCSrcList = NULL,
                                ple, pleTemp;


    PTIMER_CONTEXT              ptwc = NULL;
    
    LIST_ENTRY                  leMfeOutIfList, lePrevMfeOutIfList;

    NTSTATUS                    ntStatus;

    RTM_ENTITY_INFO             reiEntityInfo;
    RTM_DEST_INFO               rdiDestInfo;
    HANDLE                      hNextHop;
    BOOL                        bRelDest = FALSE;


    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE6( 
        ENTER, "ENTERED MgmNewPacketReceived : Source %x, %x : "
        "Group %x, %x : In Interface : %x, %x", dwSourceAddr, dwSourceMask,
        dwGroupAddr, dwGroupMask, dwInIfIndex, dwInIfNextHopAddr
        );
    

    //--------------------------------------------------------------------
    // Check if Mfe is already present for this ( source, group ).
    // If so add it to the Kernel mode forwarder.
    //--------------------------------------------------------------------


    if ( IsMFEPresent( 
            dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask, TRUE ) )
    {
        TRACE1( ENTER, "LEAVING MgmNewPacketReceived %x\n", dwErr );

        LEAVE_MGM_API();

        return dwErr;
    }


    //--------------------------------------------------------------------
    // No Mfe is present for this ( source, group )
    //--------------------------------------------------------------------


    ACQUIRE_PROTOCOL_LOCK_SHARED();

    do
    {
        //
        // Perform RPF check on the incoming interface.
        //

        RtlZeroMemory( &rdiDestInfo, sizeof( RTM_DEST_INFO ) );
        
        dwErr = InvokeRPFCallbacks( 
                    &ppe, &pieInIf, &dwIfBucket,
                    dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask,
                    &dwInIfIndex, &dwInIfNextHopAddr, &dwUpStreamNbr,
                    dwHdrSize, pbPacketHdr,  &hNextHop, (PBYTE) &rdiDestInfo
                    );

        //
        // Something is hosed here.
        //
        
        if ( dwErr != NO_ERROR )
        {
            break;
        }

        bRelDest = TRUE;
        bIfLock = TRUE;


        //--------------------------------------------------------------------
        // In one of the most dramatic events in the multicast world
        // scattered membership entries now morph into an MFE, capable of 
        // sustaining traffic and bringing multicast applications to life.
        // 
        // Gag-gag-gag-uggggghh.  Ok enough bad poetic license.  
        // Just create the MFE asap. (and get a life please)
        //--------------------------------------------------------------------

        InitializeListHead( &leMfeOutIfList );
        InitializeListHead( &lePrevMfeOutIfList );


        //
        // Check if there is administrative-scoped boundary for this
        // group on the incoming interface
        //

        if ( IS_HAS_BOUNDARY_CALLBACK() &&
             HAS_BOUNDARY_CALLBACK()( dwInIfIndex, dwGroupAddr ) )
        {
            //
            // Admin-scoped bounday exists on incoming interface.
            // Create a negative MFE to prevent forwarding of
            // traffic for this (S, G)
            //
            
            TRACEPACKET2( 
                GROUP, "Admin-scope on for group %lx, incoming interface",
                dwInIfIndex, dwGroupAddr
                );

            //
            // find the group entry
            //

            dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );
            
            ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
            bGrpLock = TRUE;
            

            //
            // acquire group lock and find group entry in the hash bucket again
            //

            pleGrpList = GROUP_BUCKET_HEAD( dwGrpBucket );
            
            bGrpFound = FindGroupEntry( 
                            pleGrpList, dwGroupAddr, dwGroupMask, &pge, TRUE
                            );

            if ( bGrpFound )
            {
                //
                // Found group, look up source entry
                //

                ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                bGrpEntryLock = TRUE;


                dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

                pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );


                bSrcFound = FindSourceEntry( 
                                pleSrcList, dwSourceAddr, dwSourceMask, 
                                &pse, TRUE 
                                );
            }
        }

        else
        {
            do
            {
                //
                // No admin-scope on incoming interface.  Proceed to create 
                // the OIF list for this MFE.
                //
                
                //
                // 1. check if (*, *) entry is present
                //

                dwWCGrpBucket = GROUP_TABLE_HASH( 0, 0 );

                ACQUIRE_GROUP_LOCK_SHARED( dwWCGrpBucket );
                bWCGrpLock = TRUE;

                pleWCGrpList = GROUP_BUCKET_HEAD( dwWCGrpBucket );


                if ( FindGroupEntry( pleWCGrpList, 0, 0, &pgeWC, TRUE ) )
                {
                    //
                    // ok wildcard group entry exists.
                    // find the wildcard source entry.
                    //

                    ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
                    bWCGrpEntryLock = TRUE;
                    
                    dwWCSrcBucket = SOURCE_TABLE_HASH( 0, 0 );

                    pleWCSrcList = SOURCE_BUCKET_HEAD( pgeWC, dwWCSrcBucket );
                    

                    if ( FindSourceEntry( pleWCSrcList, 0, 0, &pseWC, TRUE ) )
                    {
                        //
                        // Copy the outgoing interface list for the (*, *) entry
                        //

                        InterlockedExchange( &pseWC-> dwInUse, 1 );
                        
                        CopyAndMergeIfLists( &leMfeOutIfList, &pseWC-> leOutIfList );
                    }
                }


                //
                // 2. check if a (*, G) entry is present.
                //

                dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );
                
                ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
                bGrpLock = TRUE;
                

                //
                // acquire group lock and find group entry in the hash bucket again
                //

                pleGrpList = GROUP_BUCKET_HEAD( dwGrpBucket );
                
                bGrpFound = FindGroupEntry( 
                                pleGrpList, dwGroupAddr, dwGroupMask, &pge, TRUE
                                );
                
                if ( bGrpFound )
                {
                    pseWC = NULL;
                    
                    //
                    // group entry present, check if wildcard source is present
                    //

                    ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                    bGrpEntryLock = TRUE;
                    

                    dwWCSrcBucket = SOURCE_TABLE_HASH( 0, 0 );

                    pleWCSrcList = SOURCE_BUCKET_HEAD( pge, dwWCSrcBucket );


                    if ( FindSourceEntry( pleWCSrcList, 0, 0, &pseWC, TRUE ) )
                    {
                        //
                        // Merge the OIL of the (*, G) entry with the OIL of
                        // the (*, *) entry
                        //

                        pseWC-> dwInUse = 1;
                        
                        CopyAndMergeIfLists( &leMfeOutIfList, &pseWC-> leOutIfList );
                    }


                    //
                    // 3. Check if (S, G) entry is present 
                    //

                    dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

                    pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

                    bSrcFound = FindSourceEntry( 
                                    pleSrcList, dwSourceAddr, dwSourceMask, &pse, TRUE 
                                    );

                    if ( bSrcFound )
                    {
                        //
                        // Source Entry present.  Merge with source OIL
                        //

                        pse-> dwInUse = 1;
                        
                        CopyAndMergeIfLists( &leMfeOutIfList, &pse-> leOutIfList );
                    }
                }
                
            
                //
                // If OIF list is empty, no CREATION_ALERTs required.
                //

                if ( IsListEmpty( &leMfeOutIfList ) )
                {
                    FreeList( &lePrevMfeOutIfList );
                    InitializeListHead( &lePrevMfeOutIfList );
                    break;
                }

                //
                // Check if OIF list is the same as previous iteration
                //

                if ( IsListSame( &lePrevMfeOutIfList, &leMfeOutIfList ) )
                {
                    FreeList( &leMfeOutIfList );
                    break;
                }

                
                //--------------------------------------------------------------------
                // It's callback time
                //--------------------------------------------------------------------

                //
                // release all locks before invoking the CREATION_ALERT callback
                //

                if ( bGrpEntryLock )
                {
                    RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                    bGrpEntryLock = FALSE;
                }

                if ( bGrpLock )
                {
                    RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
                    bGrpLock = FALSE;
                }

                if ( bWCGrpEntryLock  )
                {
                    RELEASE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
                    bWCGrpEntryLock = FALSE;
                }
                
                if ( bWCGrpLock )
                {
                    RELEASE_GROUP_LOCK_SHARED( dwWCGrpBucket );
                    bWCGrpLock = FALSE;
                }

                RELEASE_IF_LOCK_SHARED( dwIfBucket );

                bGrpFound = FALSE;
                bSrcFound = FALSE;
                
                //
                // invoked creation alert for each protocol component that
                // has an interface in the OIL.
                //

                InvokeCreationAlert(
                    dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask,
                    dwInIfIndex, dwInIfNextHopAddr, &leMfeOutIfList, &dwOutIfCount
                    );


                //
                // Save list from previous iteration
                //

                FreeList( &lePrevMfeOutIfList );

                lePrevMfeOutIfList = leMfeOutIfList;

                leMfeOutIfList.Flink-> Blink = &lePrevMfeOutIfList;

                leMfeOutIfList.Blink-> Flink = &lePrevMfeOutIfList;

                InitializeListHead( &leMfeOutIfList );

                ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

            } while (TRUE);
        }
        
        //
        // if OIL is empty, invoke deletion alert for the protocol component
        // on the incoming interface interface
        //

        if ( IsListEmpty( &lePrevMfeOutIfList ) )
        {
            //
            // Outgoing interface list is empty for this MFE
            // Invoke deleteion alert on the protocol component on the 
            // incoming interface
            //

            if ( IS_PRUNE_ALERT( ppe ) )
            {
                PRUNE_ALERT( ppe ) (
                    dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask,
                    dwInIfIndex, dwInIfNextHopAddr, FALSE, &dwTimeOut
                    );
            }
        }


        //
        // if there was no group entry, create one
        //
        
        if ( !bGrpFound )
        {
            if ( pge != NULL )
            {
                dwErr = CreateGroupEntry(
                            &pge-> leGrpHashList, dwGroupAddr, dwGroupMask, 
                            &pgeNew
                            );
            }

            else
            {
                dwErr = CreateGroupEntry(
                            pleGrpList, dwGroupAddr, dwGroupMask, &pgeNew
                            );
            }
            
            if ( dwErr != NO_ERROR )
            {
                break;
            }

            pge = pgeNew;

            
            //
            // find source hash bucket
            //

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            bGrpEntryLock = TRUE;
            
            dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

            pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );
        }


        //
        // if there was no source entry
        //

        if ( !bSrcFound )
        {
            if ( pse != NULL )
            {
                dwErr = CreateSourceEntry(
                            pge, &pse-> leSrcHashList, dwSourceAddr, dwSourceMask,
                            &pseNew
                            );
            }

            else
            {
                dwErr = CreateSourceEntry(
                            pge, pleSrcList, dwSourceAddr, dwSourceMask,
                            &pseNew
                            );
            }

            if ( dwErr != NO_ERROR )
            {
                break;
            }

            pse = pseNew;

            pge-> dwSourceCount++;
        }


        //
        // Set incoming interface
        //

        pse-> dwInIfIndex           = dwInIfIndex;

        pse-> dwInIfNextHopAddr     = dwInIfNextHopAddr;

        pse-> dwUpstreamNeighbor    = dwUpStreamNbr;

        pse-> dwInProtocolId        = ppe-> dwProtocolId;

        pse-> dwInComponentId       = ppe-> dwComponentId;
        

        //
        // Set route information
        //

        dwErr = RtmGetEntityInfo(
                    g_hRtmHandle, rdiDestInfo.ViewInfo[ 0 ].Owner,
                    &reiEntityInfo
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACEPACKET1( ANY, "failed to get entity info : %x", dwErr );

            pse-> dwRouteProtocol   = 0;
        }
        else
        {
            pse-> dwRouteProtocol   = reiEntityInfo.EntityId.EntityProtocolId;
        }

        pse-> dwRouteNetwork        = 
            *( (PDWORD) rdiDestInfo.DestAddress.AddrBits );
            
        pse-> dwRouteMask =
            RTM_IPV4_MASK_FROM_LEN( rdiDestInfo.DestAddress.NumBits );
        
        pse-> bInForwarder          = TRUE;
        
        //
        // save timeout in seconds and creation time
        //
        
        pse-> dwTimeOut             = dwTimeOut / 1000;
        
        NtQuerySystemTime( &pse-> liCreationTime );


        //
        // save the MFE OIL
        //

        if ( !IsListEmpty( &lePrevMfeOutIfList ) )
        {
            pse-> dwMfeIfCount           = dwOutIfCount;

            pse-> leMfeIfList            = lePrevMfeOutIfList;

            lePrevMfeOutIfList.Flink-> Blink = &pse-> leMfeIfList;

            lePrevMfeOutIfList.Blink-> Flink = &pse-> leMfeIfList;

            //
            // Free OIF entries on which forwarding is disabled
            //

            ple = pse-> leMfeIfList.Flink;

            while ( ple != &pse-> leMfeIfList )
            {
                poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

                pleTemp = ple-> Flink;
                
                if ( !poie-> wForward )
                {
                    RemoveEntryList( ple );

                    MGM_FREE( poie );
                }

                ple = pleTemp;
            }
        }


        //
        // add a reference for the incoming interface
        //

        AddSourceToRefList( 
            &pieInIf-> leInIfList, dwSourceAddr, dwSourceMask, 
            dwGroupAddr, dwGroupMask, IS_PROTOCOL_IGMP( ppe )
            );
        
        //
        // Set the MFE in the forwarder.
        //

        AddMfeToForwarder( pge, pse, dwTimeOut );


        //
        // create timer entry and store timer object
        //
        
        //
        // allocate a timer context structure
        //

        ptwc = MGM_ALLOC( sizeof( TIMER_CONTEXT ) );

        if ( ptwc == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "Failed to allocate timer context of size : %d", 
                sizeof( TIMER_CONTEXT )
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ptwc-> dwSourceAddr     = pse-> dwSourceAddr;
        ptwc-> dwSourceMask     = pse-> dwSourceMask;

        ptwc-> dwGroupAddr      = pge-> dwGroupAddr;
        ptwc-> dwGroupMask      = pge-> dwGroupMask;

        ptwc-> dwIfIndex        = pse-> dwInIfIndex;

        ptwc-> dwIfNextHopAddr  = pse-> dwInIfNextHopAddr;
        

        //
        // Add timer to appropriate timer Q
        //
        
        dwTimerQ = TIMER_TABLE_HASH( pge-> dwGroupAddr );
        
        ntStatus = RtlCreateTimer(
                        TIMER_QUEUE_HANDLE( dwTimerQ ), &pse-> hTimer,
                        MFETimerProc, ptwc, dwTimeOut, 0, 0
                        );

        if ( !NT_SUCCESS( ntStatus ) )
        {
            TRACE1( ANY, "Timer set failed with status %lx", ntStatus );

            LOGERR0( INVALID_TIMER_HANDLE, ntStatus );
        }

    } while ( FALSE );



    //
    // Release locks and quit 
    //
    
    if ( bGrpEntryLock ) 
    {
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }

    if ( bGrpLock )
    {
        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
    }
    
    if ( bWCGrpEntryLock )
    {
        RELEASE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
    }
        
    if ( bWCGrpLock )
    {
        RELEASE_GROUP_LOCK_SHARED( dwWCGrpBucket );
    }

    if ( bIfLock )
    {
        RELEASE_IF_LOCK_SHARED( dwIfBucket );
    }


    //
    // Add route retuned by RPF check to route table.
    //

    if ( dwErr == NO_ERROR )
    {
        AddSourceGroupToRouteRefList( 
            dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask, hNextHop,
            (PBYTE) &rdiDestInfo
            );
    }
    

    if ( bRelDest )
    {
        RtmReleaseDestInfo( g_hRtmHandle, &rdiDestInfo );
    }

    RELEASE_PROTOCOL_LOCK_SHARED();
    

    TRACE1( ENTER, "LEAVING MgmNewPacketReceived %x\n", dwErr );

    LEAVE_MGM_API();

    
    return dwErr;
    
}


//----------------------------------------------------------------------------
// IsMFEPresent
//
// Check if MFE is present for a given (source, group).  If it is add it to
// to the kernel mode forwarder.
//----------------------------------------------------------------------------

BOOL
IsMFEPresent(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bAddToForwarder
)
{

    BOOL                        bMfeFound = FALSE;

    DWORD                       dwGrpBucket, dwSrcBucket;

    PLIST_ENTRY                 pleGrpList, pleSrcList;

    PGROUP_ENTRY                pge = NULL;

    PSOURCE_ENTRY               pse = NULL;

    

    //
    // check MFE is present for the specified (source, group)
    //

    dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );

    ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
    

    pleGrpList = GROUP_BUCKET_HEAD( dwGrpBucket );
    
    if ( FindGroupEntry( 
            pleGrpList, dwGroupAddr, dwGroupMask, &pge, TRUE 
            ) )
    {
        //
        // group entry exists, find source entry
        //

        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        

        dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

        pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

        if ( FindSourceEntry( 
                pleSrcList, dwSourceAddr, dwSourceMask, &pse, TRUE
                ) )
        {
            //
            // Source entry exists, Is this source entry an MFE ?
            //

            if ( IS_VALID_INTERFACE( pse-> dwInIfIndex, 
                                     pse-> dwInIfNextHopAddr ) )
            {
                if ( bAddToForwarder )
                {

                    //
                    // MFE exists, set it to the forwarder
                    //
                    
                    AddMfeToForwarder( pge, pse, 0 );

                    pse-> bInForwarder = TRUE;
                }
                
                bMfeFound = TRUE;

            }                
        }

        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }

    RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );


    return bMfeFound;
}


//----------------------------------------------------------------------------
// InvokeRPFCallbacks
//
// Assumes that the protocol list and the interface bucket are read locked 
//----------------------------------------------------------------------------

DWORD
InvokeRPFCallbacks(
    PPROTOCOL_ENTRY *           pppe,
    PIF_ENTRY *                 ppieInIf,
    PDWORD                      pdwIfBucket,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PDWORD                      pdwInIfIndex,
    PDWORD                      pdwInIfNextHopAddr,
    PDWORD                      pdwUpStreamNbr,
    DWORD                       dwHdrSize,
    PBYTE                       pbPacketHdr,
    PHANDLE                     phNextHop,
    PBYTE                       pbBuffer
)
{
    BOOL                        bFound = FALSE, bIfLock = FALSE;
    
    DWORD                       dwErr, dwCount = 0,
                                dwNewIfBucket;
    
    PPROTOCOL_ENTRY             ppe = NULL;

    PLIST_ENTRY                 pleIfList;
    
    BOOL                        bRelNextHop = FALSE;
    
    RTM_NET_ADDRESS             rnaSource;

    PRTM_DEST_INFO              prdiDestInfo = (PRTM_DEST_INFO) pbBuffer;

    RTM_NEXTHOP_INFO            rniNextHopInfo;



    TRACEPACKET2(
        PACKET, "ENTERED InvokeRPFCallbacks : In interface : %x, %x",
        *pdwInIfIndex, *pdwInIfNextHopAddr
        );
        
    *pppe = NULL;
    
    do
    {
        //
        // format the address
        //
        
        RTM_IPV4_MAKE_NET_ADDRESS( 
            &rnaSource, dwSourceAddr, IPv4_ADDR_LEN
            );


        //
        // lookup route
        //

        dwErr = RtmGetMostSpecificDestination(
                    g_hRtmHandle, &rnaSource, RTM_BEST_PROTOCOL,
                    RTM_VIEW_MASK_MCAST, prdiDestInfo
                    );
                    
        if ( dwErr != NO_ERROR )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;

            TRACE1( ANY, "No Route to source %x", dwSourceAddr );

            break;
        }

        
        //
        // Pick NHOP
        //

        *phNextHop = SelectNextHop( prdiDestInfo );

        if ( *phNextHop == NULL )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;

            TRACE1( ANY, "No NextHop to source %x", dwSourceAddr );

            break;
        }
        

        //
        // Get NHOP info
        //
        
        dwErr = RtmGetNextHopInfo( g_hRtmHandle, *phNextHop, &rniNextHopInfo );

        if ( ( dwErr != NO_ERROR ) || 
             ( rniNextHopInfo.State != RTM_NEXTHOP_STATE_CREATED ) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;

            TRACE1( ANY, "No Nexthop info to source %x", dwSourceAddr );

            break;
        }

        bRelNextHop = TRUE;


        //
        // Set the incoming interface as per the route table
        //
        
        *pdwInIfIndex = rniNextHopInfo.InterfaceIndex;

        //
        // The next hop is set to zero by default.  This is fine for
        // Ethernet and P2P interfaces where this value is 0 for the
        // the corresponding IF entries in the IF table.
        // But for Point to Multi Point interfaces such
        // as the RAS server (internal) interface or NBMA interfaces,
        // the NHOP field is used to distinguish interfaces that 
        // share an IF index.  e.g. RAS clients all connect on the 
        // same interface and are distinguished by different NHOP
        // values.  Consequently to find an entry in the IF hash 
        // table we need the (IF index, NHOP) pair.
        //
        // Here we run into a special case.  The new interface as
        // determined by the route lookup above gives just an IF 
        // index.  So we have an IF index.  
        // How do we get a NHOP on this interface ?
        //
        // (The reason for looking up an interface here is that we
        // would like to determine the protocol component that owns
        // it and then invoke the RPF callback of that protocol
        // component).
        //
        // The solution to this is based on two assumptions.  
        // One is
        // that only one protocol runs on an interface (single IF 
        // index).  This is true for P2MP interfaces too.  So to 
        // determine the protocol on an interface all one needs to 
        // do is to find any IF entry that has the same IF index 
        // (immaterial of the NEXT HOP).
        //
        // Second is that, all interfaces with the same IF index
        // hash to the same bucket in the IF table.  
        // So all the NHOP on a P2MP will be present in the same
        // hash bucket.  Also if the route lookup yields say 
        // IF index X, then looking up (X, (NHOP) 0) in the IF hash 
        // table will result in finding either IF entry (X, 0) for 
        // ethernet or P2P interfaces OR IF entry (X, Y) for P2MP
        // interfaces where Y is the first among the multiple NHOPs
        // that share the same IF index.  If neither exists then
        // we assume that no entry exits for an interface with 
        // IF index X and we report an error and quit.
        //
        // On success we can determine the protocol on IF index X.
        //
        // All this since we have a hash table index of (IF index,
        // NHOP) and we need to look having only a partial key.
        //
        
        *pdwInIfNextHopAddr = 0;

        TRACEPACKET2(
            PACKET, "New incoming interface : %d, %d", *pdwInIfIndex,
            *pdwInIfNextHopAddr
            );
            
        //
        // get the new incoming interface entry
        //
        
        dwNewIfBucket = IF_TABLE_HASH( *pdwInIfIndex );

        ACQUIRE_IF_LOCK_SHARED( dwNewIfBucket );
        bIfLock = TRUE;

        *pdwIfBucket = dwNewIfBucket;

        bFound = FindIfEntry( 
                    IF_BUCKET_HEAD( dwNewIfBucket), *pdwInIfIndex, 
                    *pdwInIfNextHopAddr, ppieInIf
                    );

        //
        // Check if the interface index of this interface is the same
        // as that of the incoming interface.  Since we are looking 
        // up the interface purely on IF index and not on 
        // IF index/NEXTHOP,
        // there is a chance for point to multipoint interface e.g.
        // RAS server interface, that we could have found a different
        // interface
        //

        if ( ( *ppieInIf == NULL )    ||
             ( (*ppieInIf)-> dwIfIndex != *pdwInIfIndex ) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
    
            TRACE3( 
                ANY, "InvokeRPFCallbacks : New incoming Interface not"
                " found : %x, %x, %x", *pdwInIfIndex, 
                *pdwInIfNextHopAddr, *ppieInIf
                );

            LOGINFO0( IF_NOT_FOUND, dwErr );

            break;
        }

        //
        // The incoming interface is now correct as per the route table
        // Look up the protocol on this interface.
        //

        ppe = GetProtocolEntry( 
                PROTOCOL_LIST_HEAD(), (*ppieInIf)-> dwOwningProtocol,
                (*ppieInIf)-> dwOwningComponent
                );

        if ( ppe == NULL )
        {
            //
            // Internal MGM inconsistency.  Interface exists
            // but the protocol on it does not.  Should not
            // happen.
            //
            
            dwErr = ERROR_CAN_NOT_COMPLETE;

            TRACE2( 
                ANY, "InvokeRPFCallbacks : No protocol entry for"
                "incoming interface : %x, %x",
                (*ppieInIf)-> dwOwningProtocol, 
                (*ppieInIf)-> dwOwningComponent
                );

            break;
        }


        TRACEPACKET2(
            PACKET, "ProtocolEntry for packet %x, %x", 
            ppe-> dwProtocolId, ppe-> dwComponentId
            );
            
        //
        // Protocol entry found.  Invoke its RPF callback
        //

        if ( !( IS_RPF_CALLBACK( ppe ) ) )
        {
            //
            // No RPF callback provided by the protocol on the 
            // incoming interface.
            //
            
            dwErr = NO_ERROR;

            TRACEPACKET4( 
                ANY, "InvokeRPFCallbacks : No RPF callback for "
                "protocol %x, %x on incoming interface %x, %x",
                (*ppieInIf)-> dwOwningProtocol, 
                (*ppieInIf)-> dwOwningComponent,
                (*ppieInIf)-> dwIfIndex,
                (*ppieInIf)-> dwIfNextHopAddr
                );

            break;
        }

        dwErr = RPF_CALLBACK( ppe )(
                    dwSourceAddr, dwSourceMask, dwGroupAddr, 
                    dwGroupMask, pdwInIfIndex, pdwInIfNextHopAddr,
                    pdwUpStreamNbr, dwHdrSize, pbPacketHdr, pbBuffer 
                    );

        if ( dwErr == ERROR_INVALID_PARAMETER )
        {
            //
            // In the RPF callback the protocol component has
            // changed the incoming interface again.  Make sure
            // to set the IF bucket value correctly
            //

            dwNewIfBucket = IF_TABLE_HASH( *pdwInIfIndex );

            //
            // if this interface is in another hash bucket
            //

            if ( *pdwIfBucket != dwNewIfBucket )
            {
                RELEASE_IF_LOCK_SHARED( *pdwIfBucket );
                
                ACQUIRE_IF_LOCK_SHARED( dwNewIfBucket );

                *pdwIfBucket = dwNewIfBucket;
            }

            //
            // Find the interface entry corresp. to the
            // IF/NHOP as per the protocol
            //
            
            TRACEPACKET2(
                PACKET, "RPF check returned interface : %x, %x", *pdwInIfIndex,
                *pdwInIfNextHopAddr
                );
            
            if ( FindIfEntry( 
                    IF_BUCKET_HEAD( dwNewIfBucket ), *pdwInIfIndex,
                    *pdwInIfNextHopAddr, ppieInIf ) )
            {                        
                dwErr = NO_ERROR;
            }
            else
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
            }
        }
        
    } while ( FALSE );


    //
    // Clean up
    //
    
    if ( bRelNextHop )
    {
        if ( RtmReleaseNextHopInfo( g_hRtmHandle, &rniNextHopInfo ) != 
             NO_ERROR )
        {
            TRACE1( ANY, "Failed to release next hop : %x", dwErr );
        }
    }


    if ( ( dwErr != NO_ERROR ) && ( bIfLock ) )
    {
        RELEASE_IF_LOCK_SHARED( dwNewIfBucket );
    }
    

    //
    // set up the return parameters
    //

    //
    // TDB : in that we need to set a negative MFE if the RPF callback fails
    // without generating a route
    
    *pppe = ppe;

    TRACE1( PACKET, "LEAVING RPF Callback : %d", dwErr );
    
    return dwErr;
}



//----------------------------------------------------------------------------
// CopyAndMergeIfLists
//
//----------------------------------------------------------------------------

VOID
CopyAndMergeIfLists(
    PLIST_ENTRY                 pleMfeOutIfList,
    PLIST_ENTRY                 pleOutIfList
)
{
    BOOL                        bFound = FALSE;

    INT                         iCmp = 0;
    
    DWORD                       dwErr = NO_ERROR;
    
    POUT_IF_ENTRY               poieOut = NULL, poieMfe = NULL, poie = NULL;
    
    PLIST_ENTRY                 pleMfe = NULL, pleOut = NULL;

    

    do
    {
        if ( IsListEmpty( pleOutIfList ) )
        {
            break;
        }

        if ( IsListEmpty( pleMfeOutIfList ) )
        {
            CopyAndAppendIfList( 
                pleMfeOutIfList, pleOutIfList->Flink, pleOutIfList 
                );

            break;
        }


        pleMfe = pleMfeOutIfList-> Flink;

        pleOut = pleOutIfList-> Flink;

        while ( pleMfe != pleMfeOutIfList && 
                pleOut != pleOutIfList    && 
                dwErr == NO_ERROR )
        {
            poieOut  = CONTAINING_RECORD( pleOut, OUT_IF_ENTRY, leIfList );


            //
            // find location to insert new entry
            //

            bFound = FALSE;
            
            for ( ; pleMfe != pleMfeOutIfList; pleMfe = pleMfe-> Flink )
            {
                
                poieMfe = CONTAINING_RECORD( pleMfe, OUT_IF_ENTRY, leIfList );
                
                if ( poieMfe-> dwProtocolId < poieOut-> dwProtocolId )
                {
                    continue;
                }

                else if ( poieMfe-> dwProtocolId > poieOut-> dwProtocolId )
                {
                    //
                    // Interface entry not found
                    //

                    break;
                }


                //
                // same protocol
                //
            
                //
                // is same component
                //

                if ( poieMfe-> dwComponentId < poieOut-> dwComponentId ) 
                {
                    continue;
                }

                else if ( poieMfe-> dwComponentId > poieOut-> dwComponentId )
                {
                    //
                    // Interface entry not found
                    //

                    break;
                }


                //
                // same component
                //

                //
                // is same interface
                //

                if ( poieMfe-> dwIfIndex < poieOut-> dwIfIndex )
                {
                    continue;
                }

                else if ( poieMfe-> dwIfIndex > poieOut-> dwIfIndex )
                {
                    //
                    // interface not found
                    //

                    break;
                }


                //
                // is same next hop addr
                // to do IP address comparison function.
                //

                if ( INET_CMP( 
                        poieMfe-> dwIfNextHopAddr, poieOut-> dwIfNextHopAddr, iCmp 
                        ) < 0 )
                {
                    continue;
                }

                else if ( iCmp > 0 )
                {
                    //
                    // interface not found
                    //
                
                    break;
                }

                //
                // Interface found
                //

                bFound = TRUE;
                break;
            }


            if ( bFound )
            {
                //
                // Update entry in the Mfe out list
                //

                if ( IS_ADDED_BY_IGMP( poieOut ) )
                {
                    SET_ADDED_BY_IGMP( poieMfe );

                    poieMfe-> wNumAddsByIGMP += poieOut-> wNumAddsByIGMP;
                }

                if ( IS_ADDED_BY_PROTOCOL( poieOut ) )
                {
                    SET_ADDED_BY_PROTOCOL( poieMfe );

                    poieMfe-> wNumAddsByRP += poieOut-> wNumAddsByRP;
                }

                pleMfe = pleMfe-> Flink;
            }

            else
            {
                //
                // no matching entry in the mfe list
                //

                poie = MGM_ALLOC( sizeof( OUT_IF_ENTRY ) );

                if ( poie == NULL )
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;

                    TRACE1( 
                        ANY, "CreateOutInterfaceEntry : Could not allocate"
                        "out interface entry %x", dwErr 
                        );

                    LOGERR0( HEAP_ALLOC_FAILED, dwErr );

                    break;
                }

                CopyMemory( poie, poieOut, sizeof( OUT_IF_ENTRY ) );

                InsertTailList( pleMfe, &poie-> leIfList );
            }

            pleOut = pleOut-> Flink;
        }

        if ( dwErr != NO_ERROR )
        {
            break;
        }


        //
        // if entries remain in the out list
        //

        if ( pleOut != pleOutIfList )
        {
            CopyAndAppendIfList( pleMfeOutIfList, pleOut, pleOutIfList );
        }
        
    } while ( FALSE );

    return;
}


//----------------------------------------------------------------------------
// CopyAndAppendIfList
//
//----------------------------------------------------------------------------

VOID
CopyAndAppendIfList(
    PLIST_ENTRY                 pleMfeIfList,
    PLIST_ENTRY                 pleOutIfList,
    PLIST_ENTRY                 pleOutIfHead
)
{
    DWORD                       dwErr = NO_ERROR;
    
    POUT_IF_ENTRY               poieOut = NULL, poie = NULL;

    
        
    for ( ;pleOutIfList != pleOutIfHead; pleOutIfList = pleOutIfList-> Flink )
    {
        poieOut = CONTAINING_RECORD( pleOutIfList, OUT_IF_ENTRY, leIfList );

        poie = MGM_ALLOC( sizeof( OUT_IF_ENTRY ) );

        if ( poie == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "CopyAndAppendIfList : Could not allocate"
                "out interface entry %x", dwErr 
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        CopyMemory( poie, poieOut, sizeof( OUT_IF_ENTRY ) );

        InsertTailList( pleMfeIfList, &poie-> leIfList );
    }
}



//----------------------------------------------------------------------------
// InvokeCreationAlert
//
//----------------------------------------------------------------------------

VOID
InvokeCreationAlert(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwInIfIndex,
    DWORD                       dwInIfNextHopAddr,
    PLIST_ENTRY                 pleMfeOutIfList,
    PDWORD                      pdwMfeOutIfCount
)
{
    DWORD                       dwCount = 0, dwErr = NO_ERROR, dwInd;

    PPROTOCOL_ENTRY             ppe = NULL;
    
    POUT_IF_ENTRY               poieFirst, poieNext, poieTemp;

    PMGM_IF_ENTRY               pmie = NULL;
    
    PLIST_ENTRY                 ple = NULL, pleFirst = NULL, pleTemp = NULL;

    
    

    TRACEPACKET6(
        PACKET, "ENTERED InvokeCreationAlert : Source %x, %x : Group : %x, %x"
        " : Interface %x, %x", dwSourceAddr, dwSourceMask, dwGroupAddr, 
        dwGroupMask, dwInIfIndex, dwInIfNextHopAddr
        );


    //
    // remove the incoming interface from the list of outgoing interfaces.
    // remove all interfaces that have have an scope-boundary for this group.
    //
    
    ple = pleMfeOutIfList-> Flink;

    while ( ple != pleMfeOutIfList )
    {
        poieTemp = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

        ple = ple-> Flink;
            
        //
        // Check if this is the incoming interface or
        // if this interface has a scope-boundary for this group
        //
        
        if ( ( ( poieTemp-> dwIfIndex       == dwInIfIndex ) &&
               ( poieTemp-> dwIfNextHopAddr == dwInIfNextHopAddr ) ) ||
             ( IS_HAS_BOUNDARY_CALLBACK() &&
               HAS_BOUNDARY_CALLBACK()( poieTemp-> dwIfIndex, dwGroupAddr ) ) )
        {
#if 1
            poieTemp-> wForward = 0;
#else
            RemoveEntryList( &poieTemp-> leIfList );

            MGM_FREE( poieTemp );
#endif
        }
    }
    

    //
    // invoke creation alerts for all components with interfaces in the OIL
    //

    ple = pleMfeOutIfList-> Flink;
    
    while ( ple != pleMfeOutIfList )
    {
        //
        // The OIL is sorted by components i.e. all interfaces for
        // a component are bunched together.
        //
        // Save the start of the interfaces for current component
        //
        
        pleFirst = ple;

        poieFirst = CONTAINING_RECORD( pleFirst, OUT_IF_ENTRY, leIfList );


        //
        // Count all interfaces for same component
        //

        dwCount = 0;

        while ( ple != pleMfeOutIfList )
        {
            poieNext = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

#if 1
            if ( !poieNext-> wForward )
            {
                ple = ple-> Flink;
                
                continue;
            }
#endif
            if ( poieNext-> dwProtocolId != poieFirst-> dwProtocolId    ||
                 poieNext-> dwComponentId != poieFirst-> dwComponentId )
            {
                break;
            }


            //
            // another outgoing interface for the same protocol
            //

            dwCount++;

            ple = ple-> Flink;
        }


        //
        // check if we have atleast one out interface entry
        // If not move to next protocol component in the OIL
        //
        
        if ( dwCount == 0 )
        {
            continue;
        }


        TRACEPACKET3( 
            PACKET, "Out If count %d for component %x %x", dwCount,
            poieFirst-> dwProtocolId, poieFirst-> dwComponentId
            );
        

        pmie = MGM_ALLOC( sizeof( MGM_IF_ENTRY ) * dwCount );

        if ( pmie == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "CopyAndAppendIfList : Could not allocate"
                "out interface entry %x", dwErr 
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }


        //
        // fill up buffer with list of interfaces for the 
        // the protocol component and invoke its creation alert.
        //
        
        pleTemp = pleFirst;
        
        for ( dwInd = 0; dwInd < dwCount; dwInd++ )
        {
            poieTemp = CONTAINING_RECORD( pleTemp, OUT_IF_ENTRY, leIfList );

#if 1
            if ( !poieTemp-> wForward )
            {
                pleTemp = pleTemp-> Flink;
                continue;
            }
#endif
            pmie[ dwInd ].dwIfIndex         = poieTemp-> dwIfIndex;
            
            pmie[ dwInd ].dwIfNextHopAddr   = poieTemp-> dwIfNextHopAddr;

            pmie[ dwInd ].bIsEnabled        = TRUE;

            pmie[ dwInd ].bIGMP             = IS_ADDED_BY_IGMP( poieTemp );

            pleTemp = pleTemp-> Flink;
            
        } 
        

        ppe = GetProtocolEntry(
                PROTOCOL_LIST_HEAD(), poieFirst-> dwProtocolId, 
                poieFirst-> dwComponentId
                );
                
        if ( IS_CREATION_ALERT( ppe ) )
        {
            CREATION_ALERT( ppe )(
                dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask,
                dwInIfIndex, dwInIfNextHopAddr, dwCount, pmie
                );
        }


        //
        // Accumulate the count of OIF
        //
        
        *pdwMfeOutIfCount += dwCount;


        //
        // remove the interface the are flaged as disabled
        //

        pleTemp = pleFirst;
        
        for ( dwInd = 0; dwInd < dwCount; dwInd++ )
        {
            poieTemp = CONTAINING_RECORD( pleTemp, OUT_IF_ENTRY, leIfList );
        
            ple = pleTemp-> Flink;
            
            if ( !pmie[ dwInd ].bIsEnabled )
            {
                //
                // Forwarding for this (S, G) for this interface has been 
                // disabled by the protocol
                //

#if 1
                poieTemp-> wForward = 0;
#else
                RemoveEntryList( pleTemp );

                MGM_FREE( poieTemp );
#endif
                (*pdwMfeOutIfCount)--;
            }

            pleTemp = ple;
        }

        MGM_FREE( pmie );
    }


    TRACEPACKET2(
        PACKET, "LEAVING InvokeCreationAlert : count %x, error : %x", 
        *pdwMfeOutIfCount, dwErr
        );
}



//----------------------------------------------------------------------------
// WrongIfFromForwarder
//
//----------------------------------------------------------------------------

DWORD 
WrongIfFromForwarder(
    IN              DWORD               dwSourceAddr,
    IN              DWORD               dwGroupAddr,
    IN              DWORD               dwInIfIndex,
    IN              DWORD               dwInIfNextHopAddr,
    IN              DWORD               dwHdrSize,
    IN              PBYTE               pbPacketHdr
)
{
    DWORD           dwErr = NO_ERROR;
    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE3( 
        PACKET, "ENTERED WrongIfFromForwarder for (%lx, %lx) on interface "
        " %lx", dwSourceAddr, dwGroupAddr, dwInIfIndex
        );

    TRACE1( PACKET, "LEAVING WrongIfFromForwarder : %lx\n", dwErr );


    LEAVE_MGM_API();
    
    return dwErr;
}



//----------------------------------------------------------------------------
// FreeList
//
//----------------------------------------------------------------------------

VOID
FreeList (
    IN          PLIST_ENTRY             pleHead
)
{
    PLIST_ENTRY     ple, pleTemp;

    
    if ( IsListEmpty( pleHead ) )
    {
        return;
    }
    
    ple = pleHead-> Flink;

    while ( ple != pleHead )
    {
        pleTemp = ple-> Flink;

        RemoveEntryList( ple );

        MGM_FREE( ple );

        ple = pleTemp;
    }
}


//----------------------------------------------------------------------------
// IsListSame
//
//----------------------------------------------------------------------------

BOOL
IsListSame(
    IN          PLIST_ENTRY             pleHead1,
    IN          PLIST_ENTRY             pleHead2
)
{
    PLIST_ENTRY        ple1, ple2;

    POUT_IF_ENTRY    poif1, poif2;

    
    //
    // Check for empty lists
    //
    
    if ( ( IsListEmpty( pleHead1 ) && !IsListEmpty( pleHead2 ) ) ||
         ( !IsListEmpty( pleHead1 ) && IsListEmpty( pleHead2 ) ) )
    {
        return FALSE;
    }


    if ( IsListEmpty( pleHead1 ) && IsListEmpty( pleHead2 ) )
    {
        return TRUE;
    }


    //
    // walk lists in tandem and verify equality
    //

    ple1 = pleHead1-> Flink;
    ple2 = pleHead2-> Flink;

    do
    {
        poif1 = CONTAINING_RECORD( ple1, OUT_IF_ENTRY, leIfList );
        poif2 = CONTAINING_RECORD( ple2, OUT_IF_ENTRY, leIfList );

        if ( ( poif1-> dwIfIndex != poif2-> dwIfIndex ) ||
             ( poif1-> dwIfNextHopAddr != poif2-> dwIfNextHopAddr ) )
        {
            return FALSE;
        }

        ple1 = ple1-> Flink;
        ple2 = ple2-> Flink;
        
    } while ( ( ple1 != pleHead1 ) && ( ple2 != pleHead2 ) );


    //
    // If both lists have reached their ends, they match else they don't
    //
    
    if ( ( ( ple1 != pleHead1 ) && ( ple2 == pleHead2 ) ) ||
         ( ( ple1 == pleHead1 ) && ( ple2 != pleHead2 ) ) )
    {
        return FALSE;
    }

    else
    {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\mgm.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: Mgm.h
//
// History:
//      V Raman	June-25-1997  Created.
//
// Entry points into MGM.
//============================================================================


#include "pchmgm.h"
#pragma hdrstop



IPMGM_GLOBALS           ig;

RTM_ENTITY_INFO         g_reiRtmEntity = { 0, AF_INET, MS_IP_MGM, 0 };

RTM_REGN_PROFILE        g_rrpRtmProfile;

RTM_ENTITY_HANDLE       g_hRtmHandle;

RTM_NOTIFY_HANDLE       g_hNotificationHandle;

RTM_REGN_PROFILE        g_rrpRtmProfile;


DWORD
StopMgm(
);




//----------------------------------------------------------------------------
// MgmDllStartup
//
// Invoked from DllMain, to initialize global critical section, set status and
// register for tracing.
//----------------------------------------------------------------------------

BOOL
MgmDllStartup(
)
{
    do
    {
        ZeroMemory( &ig, sizeof( IPMGM_GLOBALS ) );


        ig.dwLogLevel = IPMGM_LOGGING_ERROR;
        
        //
        // Create private heap
        //

        ig.hIpMgmGlobalHeap = HeapCreate( 0, 0, 0 );

        if ( ig.hIpMgmGlobalHeap == NULL )
        {
            break;
        }

        //
        // initialize the lock list
        //

        ig.llStackOfLocks.sleHead.Next = NULL;

        try
        {
            InitializeCriticalSection( &ig.llStackOfLocks.csListLock );
        }
        except ( EXCEPTION_EXECUTE_HANDLER )
        {
            break;
        }

        ig.llStackOfLocks.bInit = TRUE;

        
        //
        // Initialize global critical section and set MGM status
        //

        try
        {
            InitializeCriticalSection( &ig.csGlobal );
        }
        except ( EXCEPTION_EXECUTE_HANDLER )
        {
            break;
        }

        ig.imscStatus = IPMGM_STATUS_STOPPED;

        return TRUE;

    } while ( FALSE );

    //
    // error occurred - clean up and return FALSE
    //

    //
    // destroy the lock list
    //

    if ( ig.llStackOfLocks.bInit )
    {
        DeleteCriticalSection( &ig.llStackOfLocks.csListLock );
    }

    //
    // delete private heap
    //

    if ( ig.hIpMgmGlobalHeap != NULL )
    {
        HeapDestroy( ig.hIpMgmGlobalHeap );
    }

    return FALSE;
}


//----------------------------------------------------------------------------
// MgmDllCleanup
//
// Invoked from DllMain, to delete global critical section and
// deregister for tracing.
//----------------------------------------------------------------------------

VOID
MgmDllCleanup(
)
{
    DeleteCriticalSection( &ig.csGlobal );

    //
    // delete lock list
    //

    DeleteLockList();
        
    if ( ig.llStackOfLocks.bInit )
    {
        DeleteCriticalSection( &ig.llStackOfLocks.csListLock );
    }
        
    //
    // delete private heap
    //

    if ( ig.hIpMgmGlobalHeap != NULL )
    {
        HeapDestroy( ig.hIpMgmGlobalHeap );
    }

    return;
}


//----------------------------------------------------------------------------
// MgmInitialize
//
// This function is performs Mgm Initialization that includes allocating
// a private heap, creating a activity count semaphores and the list 
// structures for protocol and interface entries.
//----------------------------------------------------------------------------

DWORD
MgmInitialize(
    IN          PROUTER_MANAGER_CONFIG      prmcRmConfig,
    IN OUT      PMGM_CALLBACKS              pmcCallbacks
)
{

    DWORD                       dwErr = NO_ERROR, dwIndex;

    LARGE_INTEGER               li;

    NTSTATUS                    nsStatus;
    


    ENTER_GLOBAL_SECTION();


    //
    // verify MGM has not already been started.
    //
    
    if ( ig.imscStatus != IPMGM_STATUS_STOPPED )
    {
        TRACE0( START, "MgmInitialize : MGM already running" );

        LOGWARN0( IPMGM_ALREADY_STARTED, NO_ERROR );

        LEAVE_GLOBAL_SECTION();

        return ERROR_CAN_NOT_COMPLETE;
    }


    //
    // register for tracing
    //

    TRACESTART();

    ig.hLogHandle = RouterLogRegister( "IPMGM" );



    
    TRACE0( ENTER, "ENTERED MgmInitialize" );

    do
    {
        //
        // Copy the Router manager callbacks.
        //

        ig.rmcRmConfig.pfnAddMfeCallback        =
            prmcRmConfig-> pfnAddMfeCallback;
        
        ig.rmcRmConfig.pfnDeleteMfeCallback     = 
            prmcRmConfig-> pfnDeleteMfeCallback;
            
        ig.rmcRmConfig.pfnGetMfeCallback        =
            prmcRmConfig-> pfnGetMfeCallback;

        ig.rmcRmConfig.pfnHasBoundaryCallback   =
            prmcRmConfig-> pfnHasBoundaryCallback;


        //
        // Hash table sizes
        //
        
        ig.rmcRmConfig.dwIfTableSize        = prmcRmConfig-> dwIfTableSize;
        ig.rmcRmConfig.dwGrpTableSize       = prmcRmConfig-> dwGrpTableSize + 1;
        ig.rmcRmConfig.dwSrcTableSize       = prmcRmConfig-> dwSrcTableSize + 1;
        ig.dwRouteTableSize                 = prmcRmConfig-> dwIfTableSize;
        ig.dwTimerQTableSize                = 
            min( prmcRmConfig-> dwGrpTableSize / 10 + 1, TIMER_TABLE_MAX_SIZE );



        if ( prmcRmConfig-> dwLogLevel <= IPMGM_LOGGING_INFO )
        {
            ig.dwLogLevel = prmcRmConfig-> dwLogLevel;
        }

        //
        // initialize the protocol list
        //

        ig.dwNumProtocols = 0;
        
        CREATE_LOCKED_LIST( &ig.mllProtocolList );


        //
        // initialize the outstanding join list

        CREATE_LOCKED_LIST( &ig.mllOutstandingJoinList );

        
        //
        // create and initialize the interface hash table 
        //

        ig.pmllIfHashTable = MGM_ALLOC( sizeof( MGM_LOCKED_LIST ) * IF_TABLE_SIZE );

        if ( ig.pmllIfHashTable == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "MgmInitialize : Failed to allocate interface table : %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( 
            ig.pmllIfHashTable, sizeof( MGM_LOCKED_LIST ) * IF_TABLE_SIZE
            );
            

        for ( dwIndex = 0; dwIndex < IF_TABLE_SIZE; dwIndex++ )
        {
            CREATE_LOCKED_LIST( &ig.pmllIfHashTable[ dwIndex ] );
        }

        
        //
        // initialize the master group list and temp group list.
        //

        CREATE_LOCKED_LIST( &ig.mllGrpList );
        CREATE_LOCKED_LIST( &ig.mllTempGrpList );

        ig.dwNumTempEntries = 0;
        

        //
        // Create and Initialize group Hash table
        //

        ig.pmllGrpHashTable = MGM_ALLOC( sizeof( MGM_LOCKED_LIST ) * GROUP_TABLE_SIZE );

        if ( ig.pmllGrpHashTable == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "MgmInitialize : Failed to allocate group table : %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory(
            ig.pmllGrpHashTable, sizeof( MGM_LOCKED_LIST ) * GROUP_TABLE_SIZE
            );
            
        
        for ( dwIndex = 0; dwIndex < GROUP_TABLE_SIZE; dwIndex++ )
        {
            CREATE_LOCKED_LIST( &ig.pmllGrpHashTable[ dwIndex ] );
        }


        //
        // Set up the table of timer queues
        //

        ig.phTimerQHandleTable = 
            MGM_ALLOC( TIMER_TABLE_SIZE * sizeof( HANDLE ) );

        if ( ig.phTimerQHandleTable == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "MgmInitialize : Failed to allocate timer table : %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory(
            ig.phTimerQHandleTable, TIMER_TABLE_SIZE * sizeof( HANDLE )
            );


        for ( dwIndex = 0; dwIndex < TIMER_TABLE_SIZE; dwIndex++ )
        {
            nsStatus = RtlCreateTimerQueue( &ig.phTimerQHandleTable[ dwIndex ] );

            if ( !NT_SUCCESS( nsStatus ) )
            {
                dwErr = ERROR_NO_SYSTEM_RESOURCES;

                break;
            }
        }

        if ( !NT_SUCCESS( nsStatus ) )
        {
            break;
        }
        

        //
        // create activity count semaphore
        //

        ig.lActivityCount = 0;

        ig.hActivitySemaphore = CreateSemaphore( NULL, 0, 0x7FFFFFFF, NULL );

        if ( ig.hActivitySemaphore == NULL )
        {
            dwErr = GetLastError();

            TRACE1(
                ANY, 
                "MgmInitialize : Failed to create activity count semaphore : %x",
                dwErr
                );

            LOGERR0( CREATE_SEMAPHORE_FAILED, dwErr );

            break;
        }


        //
        // Register with RTMv2 as a client
        //

        dwErr = RtmRegisterEntity(
                    &g_reiRtmEntity, NULL, RtmChangeNotificationCallback,
                    TRUE, &g_rrpRtmProfile, &g_hRtmHandle
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( 
                ANY, "MgmInitialize : Failed to register with Rtm : %x",
                dwErr
                );

            LOGERR0( RTM_REGISTER_FAILED, dwErr );

            break;
        }

        
        //
        // Register for marked change notification only
        //

        dwErr = RtmRegisterForChangeNotification(
                    g_hRtmHandle, RTM_VIEW_MASK_MCAST,
                    RTM_CHANGE_TYPE_BEST | RTM_NOTIFY_ONLY_MARKED_DESTS, 
                    NULL, &g_hNotificationHandle
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( 
                ANY, "MgmInitialize : Failed to register with Rtm for change"
                "notification : %x", dwErr
                );

            LOGERR0( RTM_REGISTER_FAILED, dwErr );

            break;
        }

        //
        // set up callbacks into MGM for the router manager.
        //
        
        pmcCallbacks-> pfnMfeDeleteIndication   = DeleteFromForwarder;

        pmcCallbacks-> pfnNewPacketIndication   = MgmNewPacketReceived;

        pmcCallbacks-> pfnWrongIfIndication     = WrongIfFromForwarder;
        
        pmcCallbacks-> pfnBlockGroups           = MgmBlockGroups;

        pmcCallbacks-> pfnUnBlockGroups         = MgmUnBlockGroups;



        //
        // set the status to running.  All future API calls depend on this
        //
        
        ig.imscStatus = IPMGM_STATUS_RUNNING;


        
        
    } while ( FALSE );    


    LEAVE_GLOBAL_SECTION();


    //
    // in case of error, cleanup all resources allocated
    //
    
    TRACE1( ENTER, "LEAVING MgmInitialize : %x\n", dwErr );

    if ( dwErr != NO_ERROR )
    {
        MgmDeInitialize();
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// MgmDeInitialize
//
//
//----------------------------------------------------------------------------

DWORD
MgmDeInitialize(
)
{
    DWORD                       dwErr, dwInd;
    

    TRACE0( ENTER, "ENTERED MgmDeInitialize" );


    do
    {
        //--------------------------------------------------------------------
        // Terminate all activity
        //--------------------------------------------------------------------

        dwErr = StopMgm();

        if ( dwErr != NO_ERROR )
        {
            break;
        }

    
        //--------------------------------------------------------------------
        // Free all resources
        //--------------------------------------------------------------------
    

        //
        // de-register from RTM
        //

        dwErr = RtmDeregisterFromChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( 
                ANY, "Failed to de-register change notification : %x", 
                dwErr
                );
        }
        
        dwErr = RtmDeregisterEntity( g_hRtmHandle );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to de-register from RTM: %x", dwErr );
        }

        
        //
        // delete activity semaphore
        //

        if ( ig.hActivitySemaphore != NULL )
        {
            CloseHandle( ig.hActivitySemaphore );
            ig.hActivitySemaphore  = NULL;
        }

        
        //
        // delete group lists
        //

        for ( dwInd = 0; dwInd < GROUP_TABLE_SIZE; dwInd++ )
        {
            DELETE_LOCKED_LIST( &ig.pmllGrpHashTable[ dwInd ] );
        }

        MGM_FREE( ig.pmllGrpHashTable );

        DELETE_LOCKED_LIST( &ig.mllGrpList );
        
        
        //
        // delete interface lists
        //

        for ( dwInd = 0; dwInd < IF_TABLE_SIZE; dwInd++ )
        {
            DELETE_LOCKED_LIST( &ig.pmllIfHashTable[ dwInd ] );
        }

        MGM_FREE( ig.pmllIfHashTable );


        //
        // delete protocol list
        //

        DELETE_LOCKED_LIST( &ig.mllProtocolList );
        
        //
        // free timer resources
        //

        NtClose( ig.hRouteCheckTimer );

        for ( dwInd = 0; dwInd < TIMER_TABLE_SIZE; dwInd++ )
        {
            RtlDeleteTimerQueue( ig.phTimerQHandleTable[ dwInd ] );
        }


        TRACE1( ENTER, "LEAVING MgmDeInitialize %x\n", dwErr );

        //
        // trace deregister
        //
                
        RouterLogDeregister( ig.hLogHandle );

        TRACESTOP();

        ig.imscStatus = IPMGM_STATUS_STOPPED;
        
    } while ( FALSE );
    

    return dwErr;
}



//----------------------------------------------------------------------------
// StopMgm
//
// This function waits for all the therads that are currently executing in
// MGM to finish.  In addition the status of MGM is marked as stopping which
// prevents the further threads from executing MGM API.
//----------------------------------------------------------------------------

DWORD
StopMgm(
)
{
    LONG    lThreadCount = 0;

    
    TRACE0( STOP, "ENTERED StopMgm" );
    

    //
    // Set status of MGM to be stopping
    //
    
    ENTER_GLOBAL_SECTION();

    if ( ig.imscStatus != IPMGM_STATUS_RUNNING )
    {
        LEAVE_GLOBAL_SECTION();

        TRACE0( ANY, "Mgm is not running" );
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    ig.imscStatus = IPMGM_STATUS_STOPPING;
    
    lThreadCount = ig.lActivityCount;

    LEAVE_GLOBAL_SECTION();



    TRACE1( STOP, "Number of threads in MGM : %x", lThreadCount );
    

    //
    // Wait for all the threads in MGM to terminate.
    //
        
    while ( lThreadCount-- > 0 )
    {
        WaitForSingleObject( ig.hActivitySemaphore, INFINITE );
    }

    
    //
    // Acquire and release global critical section to ensure all
    // threads have finished LEAVE_MGM_API()
    //

    ENTER_GLOBAL_SECTION();
    LEAVE_GLOBAL_SECTION();

    TRACE0( STOP, "LEAVING StopMgm" );

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// MgmRegisterMProtocol
//
// This function is invoked by a routing protocol to obtain a handle.  This
// handle must be supplied to all subsequent MGM operations.  When invoked 
// this function creates an entry in the list of clients.
//----------------------------------------------------------------------------

DWORD
MgmRegisterMProtocol( 
    IN          PROUTING_PROTOCOL_CONFIG    prpcInfo, 
    IN          DWORD                       dwProtocolId,
    IN          DWORD                       dwComponentId,
    OUT         HANDLE *                    phProtocol
)
{

    DWORD                       dwErr = NO_ERROR;

    PPROTOCOL_ENTRY             ppeEntry = NULL;

    
    //
    // increment count of clients executing MGM apis
    //
    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE2( 
        ENTER, "ENTERED MgmRegisterMProtocol %x, %x", 
        dwProtocolId, dwComponentId 
        );


    //
    // Lock Protocol list
    //
    
    ACQUIRE_PROTOCOL_LOCK_EXCLUSIVE();
        

    do
    {
        //
        // check if the protocol already exists.
        //

        ppeEntry = GetProtocolEntry( 
                    &ig.mllProtocolList.leHead, dwProtocolId, dwComponentId 
                    );

        if ( ppeEntry != NULL )
        {
            //
            // valid entry is present. quit with error
            //

            TRACE2( 
                ANY, "Entry already present for protocol : %x, %x", 
                dwProtocolId, dwComponentId
                );

            LOGERR0( PROTOCOL_ALREADY_PRESENT, dwProtocolId );

            dwErr = ERROR_ALREADY_EXISTS;
                
            break;
        }


        //
        // create new protocol entry
        //

        dwErr = CreateProtocolEntry( 
                    &ig.mllProtocolList.leHead, 
                    dwProtocolId, dwComponentId, prpcInfo, &ppeEntry 
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1(
                ANY, "Failed to create protocol entry %x", dwErr
                );

            LOGERR0( CREATE_PROTOCOL_FAILED, dwErr );

            break;
        }

        ig.dwNumProtocols++;
        

        //
        // return handle to client
        //
        
        *phProtocol = (HANDLE) ( ( (ULONG_PTR) ppeEntry ) 
                                        ^ (ULONG_PTR)MGM_CLIENT_HANDLE_TAG );

        dwErr = NO_ERROR;
        
    } while ( FALSE );


    RELEASE_PROTOCOL_LOCK_EXCLUSIVE();

    LEAVE_MGM_API();

    TRACE1( ENTER, "LEAVING MgmRegisterMProtocol : %x\n", dwErr );
    

    return dwErr;
}



//----------------------------------------------------------------------------
// MgmRegisterMProtocol
//
// This function is invoked by a routing protocol to obtain a handle.  This
// handle must be supplied to all subsequent MGM operations.  When invoked 
// this function creates an entry in the list of clients.
//----------------------------------------------------------------------------

DWORD
MgmDeRegisterMProtocol( 
    IN          HANDLE                      hProtocol
)
{
    DWORD                       dwErr = NO_ERROR;
    
    PPROTOCOL_ENTRY             ppeEntry = NULL;

    
    //
    // increment count of clients executing MGM apis
    //
    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE0( ENTER, "ENTERED MgmDeRegisterMProtocol" );


    //
    // Acquire write lock
    //

    ACQUIRE_PROTOCOL_LOCK_EXCLUSIVE();

    
    do
    {
        //
        // retrieve entry from handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                        ^ (ULONG_PTR)MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }

        
        //
        // Verify that the protocol entry does not own any interfaces 
        //
        
        if ( ppeEntry-> dwIfCount != 0 )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;

            TRACE1( ANY, "%x interfaces present for this protocol", dwErr );

            LOGERR0( INTERFACES_PRESENT, dwErr );

            break;
        }

        
        //
        // No interfaces for this protocol
        //

        DeleteProtocolEntry( ppeEntry );

        ig.dwNumProtocols--;
        
        dwErr = NO_ERROR;
        

    } while ( FALSE );
    

    RELEASE_PROTOCOL_LOCK_EXCLUSIVE();

    TRACE1( ENTER, "LEAVING MgmDeRegisterMProtocol %x\n", dwErr );

    LEAVE_MGM_API();
    
    return dwErr;
}



//============================================================================
// Interface ownership API
//
//============================================================================

//----------------------------------------------------------------------------
// MgmTakeInterfaceOwnership
//
// This function is invoked by a routing protocol when it is enabled on an 
// interface.  This function creates an entry for the specified interface
// and inserts it into the appropriate interface hash bucket.
//
// Only one protocol can take ownership of an interface at a time.  The 
// only exception to this rule is IGMP.  IGMP can co-exist with another
// routing protocol on an interface.  In this case, the routing protocol
// should take ownership of the interface first.   
//----------------------------------------------------------------------------

DWORD
MgmTakeInterfaceOwnership(
    IN          HANDLE                      hProtocol,
    IN          DWORD                       dwIfIndex,
    IN          DWORD                       dwIfNextHopAddr
)
{
    BOOL                        bFound = FALSE, bIfLock = FALSE;
    
    DWORD                       dwErr = NO_ERROR, dwBucket;
    
    PPROTOCOL_ENTRY             ppeEntry = NULL;

    PIF_ENTRY                   pieEntry = NULL;

    

    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE2( 
        ENTER, "ENTERED MgmTakeInterfaceOwnership : Interface %x, %x",
        dwIfIndex, dwIfNextHopAddr
        );
    

    ACQUIRE_PROTOCOL_LOCK_SHARED();

    do
    {
        //
        // verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                    ^ (ULONG_PTR)MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        
        TRACEIF2(
            IF, "Protocol id: 0x%x 0x%x",
            ppeEntry-> dwProtocolId, ppeEntry-> dwComponentId
            );

        //
        // Retrieve interface entry 
        //

        dwBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_EXCLUSIVE( dwBucket );
        bIfLock = TRUE;
        
        bFound = FindIfEntry( 
                    IF_BUCKET_HEAD( dwBucket ), dwIfIndex, dwIfNextHopAddr, 
                    &pieEntry
                    );

        if ( bFound )
        {
            //
            // interface entry exists 
            //

            if ( IS_PROTOCOL_IGMP( ppeEntry ) )
            {
                //
                // IGMP is being enabled to this interface.
                // Set IGMP present flag on this interface entry.
                //

                SET_ADDED_BY_IGMP( pieEntry );
            }


            //
            // A routing protocol is being enabled to this interface entry.
            //

            //
            // Check if interface is currently owned by IGMP.  In this case
            // alone the routing protocol may be added to an existing (from
            // the MGM point of view) interface.
            //
            // If another routing protocol owns the interface that is
            // an error as per the interop rules for multicast protocols
            // on a border router.  report the error.
            //

            else if ( IS_PROTOCOL_ID_IGMP( pieEntry-> dwOwningProtocol ) )
            {
                //
                // Interface currently owned by IGMP
                //

                dwErr = TransferInterfaceOwnershipToProtocol( 
                            ppeEntry, pieEntry 
                            );
            }
            
            
            else
            {
                //
                // Interface currently owned by another routing protocol.
                // This is an error.
                //
                
                dwErr = ERROR_ALREADY_EXISTS;

                TRACE2( 
                    ANY, 
                    "MgmTakeInterfaceOwnership : Already owned by routing protocol"
                    " : %d, %d", pieEntry-> dwOwningProtocol, 
                    pieEntry-> dwOwningComponent
                    );

                LOGERR0( IF_ALREADY_PRESENT, dwErr );
            }
            
            break;
        }


        //
        // No interface entry found.  Create a new one.
        //

        if ( pieEntry == NULL )
        {
            //
            // First interface in the hash bucket
            //
            
            dwErr = CreateIfEntry( 
                        &ig.pmllIfHashTable[ dwBucket ].leHead,
                        dwIfIndex, dwIfNextHopAddr,
                        ppeEntry-> dwProtocolId, ppeEntry-> dwComponentId
                        );
        }

        else
        {
            dwErr = CreateIfEntry( 
                        &pieEntry-> leIfHashList,
                        dwIfIndex, dwIfNextHopAddr,
                        ppeEntry-> dwProtocolId, ppeEntry-> dwComponentId
                        );
        }


    } while ( FALSE );


    //
    // Increment interface count for the specified protocol
    //

    if ( dwErr == NO_ERROR )
    {
        InterlockedIncrement( &ppeEntry-> dwIfCount );
    }

    
    //
    // Release held locks.
    //
    
    if ( bIfLock )
    {
        RELEASE_IF_LOCK_EXCLUSIVE( dwBucket );
    }

    RELEASE_PROTOCOL_LOCK_SHARED();
    

    TRACE1( ENTER, "LEAVING MgmTakeInterfaceOwnership %x\n", dwErr );

    LEAVE_MGM_API();
    
    return dwErr;
}


//----------------------------------------------------------------------------
// MgmReleaseInterfaceOwnership
//
// This function is invoked by a routing protocol when it is disabled 
// on an interface.  This functions deletes the entry for the specified 
// interface.  Before deleting the interface entry all the 
// fowarding entries created by the protocol that use this interface as
// the incoming interface.  Also remove all group memberships on this 
// interface.
// 
// If IGMP and routing protocol are both enabled on this interface
// IGMP should release this interface first followed by the routing
// protocol.
//
//----------------------------------------------------------------------------

DWORD
MgmReleaseInterfaceOwnership(
    IN          HANDLE                      hProtocol,
    IN          DWORD                       dwIfIndex,
    IN          DWORD                       dwIfNextHopAddr
)
{
    BOOL                        bFound = FALSE, bIGMP, bIfLock = FALSE;
    
    DWORD                       dwErr = NO_ERROR, dwBucket;
    
    PPROTOCOL_ENTRY             ppeEntry = NULL, ppe;

    PIF_ENTRY                   pieEntry = NULL;



    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE2( 
        ENTER, "ENTERED MgmReleaseInterfaceOwnership : Interface %x, %x",
        dwIfIndex, dwIfNextHopAddr
        );

    ACQUIRE_PROTOCOL_LOCK_SHARED();


    do
    {
        //
        // 1. parameter validation
        //
        
        //
        // verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                    ^ (ULONG_PTR) MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        

        TRACEIF2(
            IF, "Protocol id: 0x%x 0x%x",
            ppeEntry-> dwProtocolId, ppeEntry-> dwComponentId
            );
            
        //
        // Retrieve interface entry 
        //

        dwBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_EXCLUSIVE( dwBucket );
        bIfLock = TRUE;
        
        pieEntry = GetIfEntry( 
                        IF_BUCKET_HEAD( dwBucket ), dwIfIndex, dwIfNextHopAddr
                        );

        if ( pieEntry == NULL )
        {
            //
            // no interface entry
            //
            
            dwErr = ERROR_INVALID_PARAMETER;
            
            TRACE2( 
                ANY, "Interface entry %d, %x not found ", 
                dwIfIndex, dwIfNextHopAddr 
                );

            LOGERR0( IF_NOT_FOUND, dwErr );
            
            break;
        }


        //
        // Interface entry present.  Make sure it is owned by the protocol 
        // that is releasing it.
        //

        if ( IS_PROTOCOL_IGMP( ppeEntry ) && !IS_ADDED_BY_IGMP( pieEntry ) )
        {
            //
            // trying to delete IGMP on an interface that 
            // it is not present on.
            //
            
            dwErr = ERROR_INVALID_PARAMETER;
        
            TRACE2( 
                ANY, "IGMP not running on interface %x, %x", 
                pieEntry-> dwIfIndex, pieEntry-> dwIfNextHopAddr
                );

            LOGERR0( IF_NOT_FOUND, dwErr );
        
            break;
        }


        if ( IS_ROUTING_PROTOCOL( ppeEntry ) &&
             ( ( ppeEntry-> dwProtocolId != pieEntry-> dwOwningProtocol ) ||
               ( ppeEntry-> dwComponentId != pieEntry-> dwOwningComponent ) ) )
        {
            //
            // interface entry not owned by routing protocol 
            //
            
            dwErr = ERROR_INVALID_PARAMETER;
        
            TRACE2( 
                ANY, "Routing protcol not running on interface %x, %x",
                pieEntry-> dwIfIndex, pieEntry-> dwIfNextHopAddr
                );

            LOGERR0( IF_NOT_FOUND, dwErr );
        
            break;
        }    


        //
        // 2. Remove protocol state for the interface
        //

        ppe = ppeEntry;
        
        if ( IS_PROTOCOL_IGMP( ppeEntry ) )
        {
            //
            // IGMP is releasing this interface
            //

            CLEAR_ADDED_BY_IGMP( pieEntry );
            
            bIGMP = TRUE;

            if ( !IS_ADDED_BY_PROTOCOL( pieEntry ) )
            {
                //
                // if IGMP is the only protocol on this interface, then delete 
                // any MFEs that use this interface as the incoming interface.
                // (otherwise these MFEs were created by the routing protocol,
                // that co-exists with IGMP on this interface, leave them 
                // alone)
                //

                DeleteInInterfaceRefs( &pieEntry-> leInIfList );
            }

            else
            {
                //
                // Interface is shared by IGMP and Routing Protocol.
                //
                // Group memberships added on an interface shared by IGMP
                // and a routing protocol are owned by the routing protocol (
                // with a bit field indicating whether they have been added by
                // IGMP )
                // 
                // To delete a group membership added by IGMP on a shared
                // interface, lookup the protocol on that interface and use that
                // as the protocol that added the group membership.
                //

                ppeEntry = GetProtocolEntry( 
                            PROTOCOL_LIST_HEAD(), pieEntry-> dwOwningProtocol,
                            pieEntry-> dwOwningComponent
                            );
            }
        }

        else
        {
            //
            // Interface is being deleted by a routing protocol
            //

            if ( IS_ADDED_BY_IGMP( pieEntry ) )
            {
                //
                // IGMP still exists on this interface
                //
                
                dwErr = TransferInterfaceOwnershipToIGMP( ppeEntry, pieEntry );

                break;
            }


            //
            // only routing protocol existed on this interface.
            //
            
            CLEAR_ADDED_BY_PROTOCOL( pieEntry );

            bIGMP = FALSE;

            //
            // delete all mfes that use this interface as the incoming interface
            //
            
            DeleteInInterfaceRefs( &pieEntry-> leInIfList );
        }


        //
        // Walk the list of group/source entries that contain this
        // interface (for this protocol) and delete the references
        // to this interface.  References in this case are nothing but
        // group memberships added on this interface.
        //

        
        DeleteOutInterfaceRefs( ppeEntry, pieEntry, bIGMP );


        //
        // if neither IGMP nor a routing protocol remain on this interface
        // remove this interface entry.
        //

        if ( !IS_ADDED_BY_IGMP( pieEntry ) &&
             !IS_ADDED_BY_PROTOCOL( pieEntry ) )
        {
            if ( !IsListEmpty( &pieEntry-> leOutIfList ) ||
                 !IsListEmpty( &pieEntry-> leInIfList ) )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                
                TRACE0( ANY, "References remain for interface" );

                break;
            }
            
            DeleteIfEntry( pieEntry );
        }


    } while ( FALSE );


    //
    // release locks
    //
    
    if ( bIfLock )
    {
        RELEASE_IF_LOCK_EXCLUSIVE( dwBucket );
    }
    
    //
    // Ensure any callbacks for source specific leaves
    // (caused by the interface being deleted from MGM)
    // are issued.
    // 
    // Bug : 154227
    //
    
    InvokeOutstandingCallbacks();

    
    //
    // decrement count of interfaces owned by protocol
    //

    if ( dwErr == NO_ERROR )
    {
        InterlockedDecrement( &ppe-> dwIfCount );
    }
    

    RELEASE_PROTOCOL_LOCK_SHARED();
    
    TRACE1( ENTER, "LEAVING MgmReleaseInterfaceOwnership %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// MgmAddGroupMembershipEntry
//
// 
//----------------------------------------------------------------------------

DWORD
MgmGetProtocolOnInterface(
    IN          DWORD                       dwIfIndex,
    IN          DWORD                       dwIfNextHopAddr,
    IN  OUT     PDWORD                      pdwIfProtocolId,
    IN  OUT     PDWORD                      pdwIfComponentId
)
{

    DWORD       dwErr = NO_ERROR, dwIfBucket;

    PLIST_ENTRY pleIfHead;

    PIF_ENTRY   pie;


    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE2(
        ENTER, "ENTERED MgmGetProtocolOnInterface : Interface %x, %x",
        dwIfIndex, dwIfNextHopAddr
        );

    
    dwIfBucket  = IF_TABLE_HASH( dwIfIndex );

    pleIfHead   = IF_BUCKET_HEAD( dwIfBucket );

    ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

    
    do
    {
        pie = GetIfEntry( pleIfHead, dwIfIndex, dwIfNextHopAddr );

        if ( pie == NULL )
        {
            dwErr = ERROR_NOT_FOUND;

            TRACE2( 
                ANY, "No interface entry present for interface %x, %x",
                dwIfIndex, dwIfNextHopAddr
                );

            LOGERR0( IF_NOT_FOUND, dwErr );

            break;
        }
                

        *pdwIfProtocolId    = pie-> dwOwningProtocol;

        *pdwIfComponentId   = pie-> dwOwningComponent;
        
    } while ( FALSE );


    RELEASE_IF_LOCK_SHARED( dwIfBucket );

    TRACE1(
        ENTER, "LEAVING MgmGetProtocolOnInterface : %x\n", dwErr
        );

    LEAVE_MGM_API();

    return dwErr;
}



//============================================================================
// Group membership manipulation API. (addition / deletion / retreival)
//============================================================================

//----------------------------------------------------------------------------
// MgmAddGroupMembershipEntry
//
// 
//----------------------------------------------------------------------------

DWORD
MgmAddGroupMembershipEntry(
    IN              HANDLE                  hProtocol,
    IN              DWORD                   dwSourceAddr,
    IN              DWORD                   dwSourceMask,
    IN              DWORD                   dwGroupAddr,
    IN              DWORD                   dwGroupMask,
    IN              DWORD                   dwIfIndex,
    IN              DWORD                   dwIfNextHopAddr,
    IN              DWORD                   dwFlags
)
{
    BOOL                        bIfLock = FALSE, bgeLock = FALSE,
                                bIGMP = FALSE, bUpdateMfe, bWCFound,
                                bNewComp = FALSE;
    
    DWORD                       dwErr = NO_ERROR, dwIfBucket, 
                                dwGrpBucket, dwSrcBucket, dwInd,
                                dwWCGrpBucket;
    
    WORD                        wSourceAddedBy = 0,
                                wNumAddsByIGMP = 0, wNumAddsByRP = 0;
                                
    PPROTOCOL_ENTRY             ppeEntry = NULL;

    PIF_ENTRY                   pieEntry = NULL;

    PGROUP_ENTRY                pge = NULL, pgeWC = NULL;

    PSOURCE_ENTRY               pse = NULL;

    POUT_IF_ENTRY               poie = NULL;

    PIF_REFERENCE_ENTRY         pire = NULL;
    
    LIST_ENTRY                  leSourceList;

    PCREATION_ALERT_CONTEXT     pcac;


    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE6( 
        ENTER, "ENTERED MgmAddGroupMembershipEntry : Interface %x, %x : "
        "Source : %x, %x : Group : %x, %x", dwIfIndex, dwIfNextHopAddr,
        dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask
        );

    ACQUIRE_PROTOCOL_LOCK_SHARED();


    //
    // I. Verify input parameters
    //
    
    do
    {
        //
        // verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                        ^ (ULONG_PTR) MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        

        //
        // Retrieve interface entry 
        //

        dwIfBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_EXCLUSIVE( dwIfBucket );
        bIfLock = TRUE;
        
        pieEntry = GetIfEntry( 
                        IF_BUCKET_HEAD( dwIfBucket ), dwIfIndex, dwIfNextHopAddr
                        );

        if ( pieEntry == NULL )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            TRACE2( 
                ANY, "Specified interface was not found : %d, %d", dwIfIndex,
                dwIfNextHopAddr
                );

            LOGERR0( IF_NOT_FOUND, dwErr );

            break;
        }

        //
        // Verify interface is owned by protocol making this call,
        // or 
        // if this operation is being perfomed by IGMP, verify IGMP is
        // enabled on this interface (in this case the interface may
        // be owned by another routing protocol)
        //

        if ( ( pieEntry-> dwOwningProtocol != ppeEntry-> dwProtocolId   ||
               pieEntry-> dwOwningComponent != ppeEntry-> dwComponentId )   &&
             ( !IS_PROTOCOL_IGMP( ppeEntry )                            || 
               !IS_ADDED_BY_IGMP( pieEntry ) ) )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            TRACE4(
                ANY, "Interface %d, %d is not owned by protocol %d, %d",
                dwIfIndex, dwIfNextHopAddr, ppeEntry-> dwProtocolId,
                ppeEntry-> dwComponentId
                );
                
            LOGERR0( IF_DIFFERENT_OWNER, dwErr );

            break;
        }


        bIGMP = IS_PROTOCOL_IGMP( ppeEntry );

        if ( bIGMP )
        {
            //
            // if this operation has been invoked by IGMP,
            // retrieve the entry for the routing protocol component
            // that owns this interface.
            //
            
            ppeEntry = GetProtocolEntry( 
                            PROTOCOL_LIST_HEAD(), pieEntry-> dwOwningProtocol,
                            pieEntry-> dwOwningComponent
                            );

            if ( ppeEntry == NULL )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;

                TRACE2(
                    ANY, "IGMP join failed because owning protocol entry"
                    " (%x, %x) not found", pieEntry-> dwOwningProtocol,
                    pieEntry-> dwOwningComponent
                    );

                break;
            }
        }

    } while ( FALSE );


    //
    // return, if parameter validation fails
    //
    
    if ( dwErr != NO_ERROR )
    {
        if ( bIfLock )
        {
            RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
        }

        RELEASE_PROTOCOL_LOCK_SHARED();
        
        TRACE1( ENTER, "LEAVING MgmAddGroupMembership %x\n", dwErr );

        LEAVE_MGM_API();

        return dwErr;
    }
    

    //
    // for JOIN STATE changes, i.e for group membership additions
    //
    
    if ( dwFlags & MGM_JOIN_STATE_FLAG )
    {
        //
        // Add membership entry
        //

        InitializeListHead( &leSourceList );
        
        dwErr = AddInterfaceToSourceEntry(
                    ppeEntry, dwGroupAddr, dwGroupMask,
                    dwSourceAddr, dwSourceMask, dwIfIndex, 
                    dwIfNextHopAddr, bIGMP, &bUpdateMfe,
                    &leSourceList
                    );

        if ( dwErr == NO_ERROR )
        {
            //
            // Add to an outgoing interface reference for this group
            //

            AddSourceToRefList(
                &pieEntry-> leOutIfList, dwSourceAddr, dwSourceMask, 
                dwGroupAddr, dwGroupMask, bIGMP
                );
        }


        //
        // release locks in prepapation for updating MFEs
        // (invoking creation alerts when updating MFEs requires
        //  all locks to be released)
        //
        //  When locks are re-acquired you need to verify that 
        //  the interface (dwIfIndex, dwIfNextHopAddr) and the
        //  group membership being added is still present.
        //  Any one of those could be deleted in another thread
        //  when the locks are released.
        //
        
        if ( bIfLock )
        {
            RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
            bIfLock = FALSE;
        }
        
        //
        // Invoke pended Join/Prune alerts
        //

        InvokeOutstandingCallbacks();
        

        //
        // Update MFEs if required
        //
        
        if ( ( dwErr == NO_ERROR ) && bUpdateMfe )
        {
            //
            // Queue a work item to update the MFEs
            //  Creation alerts have to be invoked from a separate 
            //  thread.  This is done to avoid calling back into the
            //  protocol (from MGM) in the context of an add membership
            //  call from the the protocol (into MGM).  Doing so results
            //  in deadlocks (bug #323388)
            //
            
            pcac = MGM_ALLOC( sizeof( CREATION_ALERT_CONTEXT ) );

            if ( pcac != NULL )
            {
                pcac-> dwSourceAddr = dwSourceAddr;
                pcac-> dwSourceMask = dwSourceMask;

                pcac-> dwGroupAddr  = dwGroupAddr;
                pcac-> dwGroupMask  = dwGroupMask;

                pcac-> dwIfIndex    = dwIfIndex;
                pcac-> dwIfNextHopAddr = dwIfNextHopAddr;

                pcac-> dwProtocolId = ppeEntry-> dwProtocolId;
                pcac-> dwComponentId = ppeEntry-> dwComponentId;

                pcac-> bIGMP        = bIGMP;

                pcac-> leSourceList = leSourceList;

                leSourceList.Flink-> Blink = &(pcac-> leSourceList);
                leSourceList.Blink-> Flink = &(pcac-> leSourceList);

                dwErr = QueueMgmWorker(
                            WorkerFunctionInvokeCreationAlert,
                            (PVOID)pcac
                            );

                if ( dwErr != NO_ERROR )
                {
                    TRACE1(
                        ANY, "Failed to queue "
                        "WorkerFunctionInvokeCreationAlert",
                        dwErr
                        );

                    MGM_FREE( pcac );

                    dwErr = NO_ERROR;
                }
            }

            else
            {
                TRACE1(
                    ANY, "Failed to allocate %d bytes for work item "
                    "context", sizeof( CREATION_ALERT_CONTEXT )
                    );
            }
        }
    }

    //
    // For FORWARD state changes only.
    //
    
    else if ( ( dwFlags & MGM_FORWARD_STATE_FLAG ) &&
              !IS_WILDCARD_GROUP( dwGroupAddr, dwGroupMask ) &&
              !IS_WILDCARD_SOURCE( dwSourceAddr, dwSourceMask ) )
    {
        //
        // Forward state changes are for MFEs only.
        // No (*, G) or (*, *) entries are updated
        //
        
        do
        {
            //
            // Check for boundaries
            //

            if ( IS_HAS_BOUNDARY_CALLBACK() &&
                 HAS_BOUNDARY_CALLBACK()( dwIfIndex, dwGroupAddr ) )
            {
                TRACE0( ANY, "Boundary present of group on interface" );

                break;
            }
            

            //
            // Check for (*, *) membership 
            //

            bWCFound = FindRefEntry(
                        &pieEntry-> leOutIfList, 
                        WILDCARD_SOURCE, WILDCARD_SOURCE_MASK,
                        WILDCARD_GROUP, WILDCARD_GROUP_MASK,
                        &pire
                        );

            if ( bWCFound )
            {
                //
                // (*, *) entry present,
                // get counts for (*, *) membership on interface
                //

                dwWCGrpBucket = GROUP_TABLE_HASH( 
                                    WILDCARD_GROUP, WILDCARD_GROUP_MASK
                                    );
                                    
                ACQUIRE_GROUP_LOCK_SHARED( dwWCGrpBucket );

                pgeWC = GetGroupEntry(
                            GROUP_BUCKET_HEAD( dwWCGrpBucket ),
                            WILDCARD_GROUP, WILDCARD_GROUP_MASK
                            );

                if ( pgeWC != NULL )
                {
                    ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
                    
                    dwSrcBucket = SOURCE_TABLE_HASH(
                                    WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                                    );

                    pse = GetSourceEntry(
                            SOURCE_BUCKET_HEAD( pgeWC, dwSrcBucket ),
                            WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                            );

                    if ( pse != NULL )
                    {
                        poie = GetOutInterfaceEntry(
                                    &pse-> leOutIfList,
                                    dwIfIndex, dwIfNextHopAddr,
                                    ppeEntry-> dwProtocolId,
                                    ppeEntry-> dwComponentId
                                    );

                        if ( poie != NULL )
                        {
                            wSourceAddedBy |= poie-> wAddedByFlag;
                            wNumAddsByRP = poie-> wNumAddsByRP;
                        }
                    }
                }
            }
            
            //
            // Check for (*, G) membership 
            //

            dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );
                                
            ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

            pge = GetGroupEntry(
                        GROUP_BUCKET_HEAD( dwGrpBucket), 
                        dwGroupAddr, dwGroupMask
                        );

            if ( pge != NULL )
            {
                ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                
                dwSrcBucket = SOURCE_TABLE_HASH(
                                WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                                );

                pse = GetSourceEntry(
                        SOURCE_BUCKET_HEAD( pge, dwSrcBucket ),
                        WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                        );

                if ( pse != NULL )
                {
                    //
                    // get counts for interface
                    // if (*, G) is present on the interface
                    //
                    
                    poie = GetOutInterfaceEntry(
                                &pse-> leOutIfList,
                                dwIfIndex, dwIfNextHopAddr,
                                ppeEntry-> dwProtocolId,
                                ppeEntry-> dwComponentId
                                );

                    if ( poie != NULL )
                    {
                        wSourceAddedBy |= poie-> wAddedByFlag;
                        wNumAddsByIGMP = poie-> wNumAddsByIGMP;
                        wNumAddsByRP += poie-> wNumAddsByRP;
                    }
                }


                //
                // Get (S, G) entry
                //
                
                dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

                pse = GetSourceEntry(
                        SOURCE_BUCKET_HEAD( pge, dwSrcBucket ),
                        dwSourceAddr, dwSourceMask
                        );

                if ( pse != NULL )
                {
                    poie = GetOutInterfaceEntry(
                                &pse-> leOutIfList,
                                dwIfIndex, dwIfNextHopAddr,
                                ppeEntry-> dwProtocolId,
                                ppeEntry-> dwComponentId
                                );

                    if ( poie != NULL )
                    {
                        //
                        // Get counts for (S, G) membership if
                        // present on interface
                        //
                        
                        wSourceAddedBy |= poie-> wAddedByFlag;
                        wNumAddsByIGMP += poie-> wNumAddsByIGMP;
                        wNumAddsByRP += poie-> wNumAddsByRP;
                    }

                    //
                    // Add interface to MFE OIF list if any
                    // membership
                    //
                    
                    if ( wSourceAddedBy )
                    {
                        AddInterfaceToSourceMfe(
                            pge, pse, dwIfIndex, dwIfNextHopAddr,
                            ppeEntry-> dwProtocolId,
                            ppeEntry-> dwComponentId,
                            IS_PROTOCOL_IGMP( ppeEntry ),
                            &poie
                            );
                    
                        poie-> wAddedByFlag |= wSourceAddedBy;
                        poie-> wNumAddsByIGMP = wNumAddsByIGMP;
                        poie-> wNumAddsByRP = wNumAddsByRP;

                    }

                    else
                    {
                        TRACE0(
                            ANY, "Forward state not updated as no"
                            " memberships present on interface"
                            );
                    }
                }
                
                RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            }

            RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );

            if ( bWCFound )
            {
                if ( pgeWC )
                {
                    RELEASE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
                }

                RELEASE_GROUP_LOCK_SHARED( dwWCGrpBucket );
            }

        } while ( FALSE );
    }

    if ( bIfLock )
    {
        RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
    }
    
    RELEASE_PROTOCOL_LOCK_SHARED();

    TRACE1( ENTER, "LEAVING MgmAddGroupMembership %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;

}



//----------------------------------------------------------------------------
// MgmDeleteGroupMembershipEntry
//
// 
//----------------------------------------------------------------------------

DWORD
MgmDeleteGroupMembershipEntry(
    IN              HANDLE                  hProtocol,
    IN              DWORD                   dwSourceAddr,
    IN              DWORD                   dwSourceMask,
    IN              DWORD                   dwGroupAddr,
    IN              DWORD                   dwGroupMask,
    IN              DWORD                   dwIfIndex,
    IN              DWORD                   dwIfNextHopAddr,
    IN              DWORD                   dwFlags
)
{
    BOOL                        bIfLock = FALSE, bIGMP;
    
    DWORD                       dwErr = NO_ERROR, dwIfBucket,
                                dwGrpBucket, dwSrcBucket;
    
    PGROUP_ENTRY                pge = NULL;

    PSOURCE_ENTRY               pse = NULL;
    
    PPROTOCOL_ENTRY             ppeEntry = NULL;

    PIF_ENTRY                   pieEntry = NULL;



    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE6( 
        ENTER, "ENTERED MgmDeleteGroupMembership : Interface %x, %x : "
        "Source : %x, %x : Group : %x, %x", dwIfIndex, dwIfNextHopAddr,
        dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask
        );

    ACQUIRE_PROTOCOL_LOCK_SHARED();


    //
    // Verify input parameters.
    //
    
    do
    {
        //
        // verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                        ^ (ULONG_PTR) MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        

        //
        // Retrieve interface entry 
        //

        dwIfBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_EXCLUSIVE( dwIfBucket );
        bIfLock = TRUE;
        
        pieEntry = GetIfEntry( 
                        IF_BUCKET_HEAD( dwIfBucket ), dwIfIndex, dwIfNextHopAddr
                        );

        if ( pieEntry == NULL )
        {
            dwErr = ERROR_NOT_FOUND;

            TRACE0( ANY, "Specified interface was not found" );

            break;
        }

        //
        // Verify interface is owned by protocol making this call.
        // or
        // if IGMP has invoked this api, verify that IGMP is present
        // on this interface.
        //

        if ( ( pieEntry-> dwOwningProtocol != ppeEntry-> dwProtocolId   ||
               pieEntry-> dwOwningComponent != ppeEntry-> dwComponentId )   &&
             ( !IS_PROTOCOL_IGMP( ppeEntry )                            || 
               !IS_ADDED_BY_IGMP( pieEntry ) ) )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            TRACE4(
                ANY, "Interface %x, %x is not owned by %x, %x",
                dwIfIndex, dwIfNextHopAddr, ppeEntry-> dwProtocolId,
                ppeEntry-> dwComponentId
                );
                
            LOGERR0( IF_DIFFERENT_OWNER, dwErr );

            break;
        }


        //
        // in case this operation is being performed by IGMP
        // get the routing protocol that co-exists with IGMP
        // on this interface
        //
        
        bIGMP = IS_PROTOCOL_IGMP( ppeEntry );

        if ( bIGMP )
        {
            //
            // if this operation has been invoked by IGMP,
            // retrieve the entry for the routing protocol component
            // that owns this interface.
            //
            
            ppeEntry = GetProtocolEntry( 
                            PROTOCOL_LIST_HEAD(), pieEntry-> dwOwningProtocol,
                            pieEntry-> dwOwningComponent
                            );

            if ( ppeEntry == NULL )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;

                TRACE2(
                    ANY, "IGMP join failed because owning protocol entry"
                    " (%x, %x) not found", pieEntry-> dwOwningProtocol,
                    pieEntry-> dwOwningComponent
                    );

                break;
            }
        }
        
    } while ( FALSE );


    //
    // in case of error, release locks and return
    //
    
    if ( dwErr != NO_ERROR )
    {
        if ( bIfLock )
        {
            RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
        }
        
        RELEASE_PROTOCOL_LOCK_SHARED();
        
        TRACE1( ENTER, "LEAVING MgmDeleteGroupMembership %x\n", dwErr );

        LEAVE_MGM_API();

        return dwErr;
    }


    //
    // For JOIN state change
    //
    
    if ( dwFlags & MGM_JOIN_STATE_FLAG )
    {
        //
        // delete interface from source entry
        //

        DeleteInterfaceFromSourceEntry(
            ppeEntry, dwGroupAddr, dwGroupMask, 
            dwSourceAddr, dwSourceMask,
            dwIfIndex, dwIfNextHopAddr, bIGMP
            );


        //
        // delete reference entry
        //

        DeleteSourceFromRefList(
            &pieEntry-> leOutIfList, dwSourceAddr, dwSourceMask,
            dwGroupAddr, dwGroupMask, bIGMP
            );

        //
        // release locks
        //
        
        if ( bIfLock )
        {
            RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
            bIfLock = FALSE;
        }
        
        //
        // Invoke pended Join/Prune alerts
        //

        InvokeOutstandingCallbacks();

    }


    //
    // For FORWARD state changes
    //
    
    else if ( ( dwFlags & MGM_FORWARD_STATE_FLAG ) &&
              !IS_WILDCARD_GROUP( dwGroupAddr, dwGroupMask ) &&
              !IS_WILDCARD_SOURCE( dwSourceAddr, dwSourceMask ) )
    {
        //
        // FORWARD state changes are for MFEs only.
        // No (*, *) or (*, G) entries are updated
        //
        
        //
        // Find the (S, G) entry and delete the group membership
        //
        
        dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );
                            
        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

        pge = GetGroupEntry(
                    GROUP_BUCKET_HEAD( dwGrpBucket ), 
                    dwGroupAddr, dwGroupMask
                    );

        if ( pge != NULL )
        {
            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            
            dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

            pse = GetSourceEntry(
                    SOURCE_BUCKET_HEAD( pge, dwSrcBucket ),
                    dwSourceAddr, dwSourceMask
                    );

            if ( pse != NULL )
            {
                DeleteInterfaceFromSourceMfe(
                    pge, pse, dwIfIndex, dwIfNextHopAddr,
                    ppeEntry-> dwProtocolId,
                    ppeEntry-> dwComponentId, bIGMP, TRUE
                    );
            }

            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }

        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
    }
    

    //
    // release locks
    //
    
    if ( bIfLock )
    {
        RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
    }
    
    RELEASE_PROTOCOL_LOCK_SHARED();
    
    TRACE1( ENTER, "LEAVING MgmDeleteGroupMembership %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE Update API.
//
//----------------------------------------------------------------------------

DWORD
MgmSetMfe(
    IN              HANDLE                  hProtocol,
    IN              PMIB_IPMCAST_MFE        pmimm
)
{
    BOOL                bGrpLock = FALSE, bgeLock = FALSE;
    
    DWORD               dwErr = NO_ERROR, dwGrpBucket, dwSrcBucket;
    
    PPROTOCOL_ENTRY     ppeEntry;

    PGROUP_ENTRY        pge;

    PSOURCE_ENTRY       pse;

    
    //
    // Check if MGM is still running and increment counts
    //
    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    
    TRACE2( 
        ENTER, "ENTERED MgmSetMfe : (%lx, %lx)", pmimm-> dwSource,
        pmimm-> dwGroup
        );

        
    ACQUIRE_PROTOCOL_LOCK_SHARED();

 
    do
    {
        //
        // Verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                        ^ (ULONG_PTR) MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        

        //
        // Get group bucket and find group entry
        //

        dwGrpBucket = GROUP_TABLE_HASH( pmimm-> dwGroup, 0 );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );
        bGrpLock = TRUE;
        
        pge = GetGroupEntry( 
                GROUP_BUCKET_HEAD( dwGrpBucket ), pmimm-> dwGroup, 0
                );

        if ( pge == NULL )
        {
            dwErr = ERROR_NOT_FOUND;

            TRACE1( ANY, "Group %lx not found", pmimm-> dwGroup );

            break;
        }


        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        bgeLock = TRUE;

        
        //
        // Find source with group entry
        //

        dwSrcBucket = SOURCE_TABLE_HASH( 
                        pmimm-> dwSource, pmimm-> dwSrcMask 
                        );

        pse = GetSourceEntry( 
                SOURCE_BUCKET_HEAD( pge, dwSrcBucket ), pmimm-> dwSource,
                pmimm-> dwSrcMask
                );

        if ( pse == NULL )
        {
            dwErr = ERROR_NOT_FOUND;

            TRACE1( ANY, "Source %lx not found", pmimm-> dwSource );

            break;
        }

                    
        //
        // Update the source entry
        //

        pse-> dwUpstreamNeighbor = pmimm-> dwUpStrmNgbr;

    } while ( FALSE );


    if ( bgeLock )
    {
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }

    
    if ( bGrpLock )
    {
        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
    }
    
    RELEASE_PROTOCOL_LOCK_SHARED();

    LEAVE_MGM_API();
    
    return dwErr;    
}


//----------------------------------------------------------------------------
// Mgm MFE enumeration API.
//
//----------------------------------------------------------------------------

DWORD
MgmGetMfe(
    IN              PMIB_IPMCAST_MFE        pmimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer
)
{
    DWORD           dwErr;
    

    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetMfe", *pdwBufferSize );


    dwErr = GetMfe( pmimm, pdwBufferSize, pbBuffer, 0 );

    
    TRACE1( ENTER, "LEAVING MgmGetMfe %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE enumeration API.
//
//----------------------------------------------------------------------------


DWORD
MgmGetFirstMfe(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
{
    DWORD           dwErr;
    
    MIB_IPMCAST_MFE mimm;
    


    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetFirstMfe", *pdwBufferSize );


    mimm.dwGroup     = 0;
    mimm.dwSource    = 0;
    mimm.dwSrcMask   = 0;

    dwErr = GetNextMfe( 
                &mimm, pdwBufferSize, pbBuffer, pdwNumEntries, 
                TRUE, 0
                );


    TRACE1( ENTER, "LEAVING MgmGetFirstMfe %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE enumeration API.
//
//----------------------------------------------------------------------------

DWORD
MgmGetNextMfe(
    IN              PMIB_IPMCAST_MFE        pmimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
{

    DWORD           dwErr;


    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetNextMfe", *pdwBufferSize );


    dwErr = GetNextMfe( 
                pmimmStart, pdwBufferSize, pbBuffer, pdwNumEntries, 
                FALSE, 0
                );


    TRACE1( ENTER, "LEAVING MgmGetNextMfe %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE Statistics enumeration API.
//
//----------------------------------------------------------------------------

DWORD
MgmGetMfeStats(
    IN              PMIB_IPMCAST_MFE        pmimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN              DWORD                   dwFlags
)
{
    DWORD           dwErr;
    

    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetMfeStats", *pdwBufferSize );


    dwErr = GetMfe( pmimm, pdwBufferSize, pbBuffer, dwFlags );

    
    TRACE1( ENTER, "LEAVING MgmGetMfeStats %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE Statistics enumeration API.
//
//----------------------------------------------------------------------------


DWORD
MgmGetFirstMfeStats(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries,
    IN              DWORD                   dwFlags
)
{
    DWORD           dwErr;
    
    MIB_IPMCAST_MFE mimm;
    


    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetFirstMfeStats", *pdwBufferSize );


    mimm.dwGroup     = 0;
    mimm.dwSource    = 0;
    mimm.dwSrcMask   = 0;

    dwErr = GetNextMfe( 
                &mimm, pdwBufferSize, pbBuffer, pdwNumEntries, 
                TRUE, dwFlags
                );


    TRACE1( ENTER, "LEAVING MgmGetFirstMfeStats %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE Statistics enumeration API.
//
//----------------------------------------------------------------------------

DWORD
MgmGetNextMfeStats(
    IN              PMIB_IPMCAST_MFE        pmimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries,
    IN              DWORD                   dwFlags
)
{

    DWORD           dwErr;


    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetNextMfeStats", *pdwBufferSize );


    dwErr = GetNextMfe( 
                pmimmStart, pdwBufferSize, pbBuffer, pdwNumEntries, 
                FALSE, dwFlags
                );


    TRACE1( ENTER, "LEAVING MgmGetNextMfeStats %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Group menbership entry enumeration API
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// MgmGroupEnumerationStart
//
//
//----------------------------------------------------------------------------

DWORD
MgmGroupEnumerationStart(
    IN              HANDLE                  hProtocol,
    IN              MGM_ENUM_TYPES          metEnumType,
    OUT             HANDLE *                phEnumHandle
)
{
    DWORD               dwErr = NO_ERROR;

    PPROTOCOL_ENTRY     ppeEntry;

    PGROUP_ENUMERATOR   pgeEnum;

    


    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE0( ENTER, "ENTERED MgmGroupEnumerationStart" );

    ACQUIRE_PROTOCOL_LOCK_SHARED();


    do
    {
        //
        // verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                    ^ (ULONG_PTR) MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        

        //
        // create an enumerator.
        //

        pgeEnum = MGM_ALLOC( sizeof( GROUP_ENUMERATOR ) );

        if ( pgeEnum == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "Failed to allocate group enumerator of size : %d", 
                sizeof( GROUP_ENUMERATOR )
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        
        ZeroMemory( pgeEnum, sizeof( GROUP_ENUMERATOR ) );

        pgeEnum-> dwSignature = MGM_ENUM_SIGNATURE;

        
        //
        // return handle to the enumerator.
        //

        *phEnumHandle = (HANDLE) ( ( (ULONG_PTR) pgeEnum ) 
                                        ^ (ULONG_PTR) MGM_ENUM_HANDLE_TAG );

    } while ( FALSE );


    RELEASE_PROTOCOL_LOCK_SHARED();

    TRACE1( ENTER, "LEAVING MgmGroupEnumerationStart\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// MgmGroupEnumerationGetNext
//
//
//----------------------------------------------------------------------------

DWORD
MgmGroupEnumerationGetNext(
    IN              HANDLE                  hEnum,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
{

    DWORD               dwErr;

    PGROUP_ENUMERATOR   pgeEnum;

    

    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE0( ENTER, "ENTERED MgmGroupEnumerationGetNext" );


    do
    {
        //
        // verify enumeration handle
        //

        pgeEnum = VerifyEnumeratorHandle( hEnum );

        if ( pgeEnum == NULL )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            break;
        }


        //
        // verify buffer has space for atleast one entry.
        // Otherwise return error and note size required for
        // atleast one entry.
        //

        if ( *pdwBufferSize < sizeof( SOURCE_GROUP_ENTRY ) )
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;

            TRACE1( ANY, "Insufficient buffer size", dwErr );

            *pdwBufferSize = sizeof( SOURCE_GROUP_ENTRY );

            break;
        }


        *pdwNumEntries = 0;
        
        dwErr = GetNextGroupMemberships( 
                    pgeEnum, pdwBufferSize, pbBuffer, pdwNumEntries
                    );
        
        //
        // This comment is to be moved, ignore it.
        //
        
        // If this is the first enumeration call (i.e this is
        // the beginning of the enumeration) then include the 
        // (S, G) == (0, 0) entry if present.  
        //
        // Usually this call would start with the (source, group)
        // entry following the one mentioned in dwLastSource and 
        // dwLastGroup.  This would result in the skipping of the
        // entry at (0, 0) since the (dwLastSource, dwLastGroup) are
        // initialized to (0, 0).  To overcome this a special flag
        // field is used to note the beginning of the enumeration.
        //
        
        //
        // Check if this is the first enumeration call.
        // If so include the (S, G) == (0, 0) entry.
        //
    } while ( FALSE );
    
    TRACE0( ENTER, "LEAVING MgmGroupEnumerationGetNext\n" );

    LEAVE_MGM_API();
    
    return dwErr;
}



//----------------------------------------------------------------------------
// MgmGroupEnumerationEnd
//
//
//----------------------------------------------------------------------------

DWORD
MgmGroupEnumerationEnd(
    IN              HANDLE                  hEnum
)
{
    DWORD               dwErr = ERROR_INVALID_PARAMETER;

    PGROUP_ENUMERATOR   pgeEnum;

    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE0( ENTER, "ENTERED MgmGroupEnumerationEnd" );

    pgeEnum = VerifyEnumeratorHandle( hEnum );

    if ( pgeEnum != NULL )
    {
        MGM_FREE( pgeEnum );

        dwErr = NO_ERROR;
    }

    TRACE1( ENTER, "LEAVING MgmGroupEnumerationEnd\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}



VOID
DisplayGroupTable(
)
{

#if UNIT_DBG

    DWORD                   dwErr, dwBufSize, dwNumEntries;

    PLIST_ENTRY             pleGrp, pleGrpHead, pleSrc, pleSrcHead,
                            pleIf, pleIfHead;

    PGROUP_ENTRY            pge;

    PSOURCE_ENTRY           pse;

    POUT_IF_ENTRY           poie;

    PBYTE                   pbBuffer = NULL;

    MIB_IPMCAST_MFE         imm;

    PMIB_IPMCAST_MFE_STATS  pimms;
    

    
    //
    // Enumerate the MFEs
    // Since the forwarder is not present, stats are junk.
    // so all mfe enum does is exercise the API and merge
    // the master and temp lists so that the subsequent
    // walks of this list can be done.
    //

    dwBufSize = 1024;
    
    pbBuffer = HeapAlloc( GetProcessHeap(), 0, dwBufSize );
    RtlZeroMemory( pbBuffer, dwBufSize );
    
    dwErr = MgmGetFirstMfe( &dwBufSize, pbBuffer, &dwNumEntries );

    if ( dwErr != NO_ERROR )
    {
        printf( "MgmGetFirstMfe returned error : %d\n", dwErr );
    }


    imm.dwSource = 0;
    imm.dwSrcMask = 0xffffffff;
    imm.dwGroup = 0;
    RtlZeroMemory( pbBuffer, dwBufSize );
    dwNumEntries = 0;
    
    while ( MgmGetNextMfe( &imm, &dwBufSize, pbBuffer, &dwNumEntries )
            == NO_ERROR )
    {
        if ( dwNumEntries == 0 )
        {
            break;
        }
        
        pimms = (PMIB_IPMCAST_MFE_STATS) pbBuffer;

        imm.dwSource    = pimms-> dwSource;
        imm.dwSrcMask   = pimms-> dwSrcMask;
        imm.dwGroup     = pimms-> dwGroup;

        pimms = (PMIB_IPMCAST_MFE_STATS) ( (PBYTE) pimms + 
                    SIZEOF_MIB_MFE_STATS( pimms-> ulNumOutIf ) );
    }

    if ( dwErr != NO_ERROR )
    {
        printf( "MgmGetNextMfe returned error : %d\n", dwErr );
    }


    //
    // since there is no kernel mode forwarder, just walk the master
    // list of group entries and display all the group entries
    //
    
    pleGrpHead = MASTER_GROUP_LIST_HEAD();

    pleGrp = pleGrpHead-> Flink;

    while ( pleGrp != pleGrpHead )
    {
        //
        // display the group entry
        //

        pge = CONTAINING_RECORD( pleGrp, GROUP_ENTRY, leGrpList );
        
        printf( "\n\n====================================================\n" );
        printf( "Group Addr\t: %x, %x\n", pge-> dwGroupAddr, pge-> dwGroupMask );
        printf( "Num Sources\t: %d\n", pge-> dwSourceCount );
        printf( "====================================================\n\n" );
        

        pleSrcHead = MASTER_SOURCE_LIST_HEAD( pge );

        pleSrc = pleSrcHead-> Flink;

        while ( pleSrc != pleSrcHead )
        {
            pse = CONTAINING_RECORD( pleSrc, SOURCE_ENTRY, leSrcList );

            printf( "\n-----------------------Source----------------------------------" );
            printf( "\nSource Addr\t: %x, %x\n", pse-> dwSourceAddr, pse-> dwSourceMask );
            
            printf(
                "Route Addr\t: %x, %x\n", pse-> dwRouteNetwork, pse-> dwRouteMask
                );
                
            printf( 
                "Out if component: %d\nOut if count\t: %d\n\n", pse-> dwOutCompCount,
                pse-> dwOutIfCount
                );

            printf( 
                "In coming interface : %d, %x\n", pse-> dwInIfIndex, 
                pse-> dwInIfNextHopAddr
                );
                
            printf( 
                "In Protocol id : %x, %x\n\n", pse-> dwInProtocolId, 
                pse-> dwInComponentId
                );

            //
            // list all outgoing interfaces
            //

            pleIfHead = &pse-> leOutIfList;

            pleIf = pleIfHead-> Flink;

            printf( "\n----------------------Out Interfaces-----------------\n" );
            
            while ( pleIf != pleIfHead )
            {
                poie = CONTAINING_RECORD( pleIf, OUT_IF_ENTRY, leIfList );
                
                printf( 
                    "Out interface\t: %d, %x\n", poie-> dwIfIndex, 
                    poie-> dwIfNextHopAddr
                    );
                    
                printf( 
                    "Out Protocol id\t: %x, %x\n", poie-> dwProtocolId, 
                    poie-> dwComponentId
                    );

                printf(
                    "Added by\t: %x\n", poie-> wAddedByFlag
                    );

                printf(
                    "Num adds (IGMP, RP)\t: (%d, %d)\n\n", poie-> wNumAddsByIGMP,
                    poie-> wNumAddsByRP
                    );

                pleIf = pleIf-> Flink;

            }
            
            
            //
            // list mfe oil
            //

            pleIfHead = &pse-> leMfeIfList;

            pleIf = pleIfHead-> Flink;

            printf( "\n------------------Mfe Out Interfaces-----------------\n" );
            
            while ( pleIf != pleIfHead )
            {
                poie = CONTAINING_RECORD( pleIf, OUT_IF_ENTRY, leIfList );
                
                printf( 
                    "Out interface\t: %d, %x\n", poie-> dwIfIndex, 
                    poie-> dwIfNextHopAddr
                    );
                    
                printf( 
                    "Out Protocol id\t: %x, %x\n", poie-> dwProtocolId, 
                    poie-> dwComponentId
                    );

                printf(
                    "Added by\t:%x\n", poie-> wAddedByFlag
                    );

                printf(
                    "Num adds (IGMP, RP)\t: (%d, %d)\n\n", poie-> wNumAddsByIGMP,
                    poie-> wNumAddsByRP
                    );

                pleIf = pleIf-> Flink;
            }

            pleSrc = pleSrc-> Flink;
        }

        pleGrp = pleGrp-> Flink;
    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\mgmrtm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: sync.c
//
// History:
//      V Raman	July-11-1997  Created.
//
// Private interface between MGM and RTM
//============================================================================


#ifndef _ROUTING_MGMRTM_
#define _ROUTING_MGMRTM_

BOOL
MgmDllStartup(
);


VOID
MgmDllCleanup(
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\protocol.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: MgmIpRm.h
//
// History:
//      V Raman	June-25-1997  Created.
//
// Declarations for routines that manipulate protocol entries
//============================================================================


#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_

#include <mgm.h>

//----------------------------------------------------------------------------
// Each PROTOCOL_ENTRY structure stores the information for a routing
// protocol that is registered with MGM.
//
//
// dwProtocolId     -   unique protocol identifier.
//
// dwComponentId    -   unique component id, used to differentiate
//                      multiple components within a protocol.
//
// dwIfCount        -   count of interfaces owned by this protocol
//
// rpcProtocolConfig-   protocol config supplied by routing protocol
//                      on registration
// 
// dwSignature      -   Signature used to verify entry.
//----------------------------------------------------------------------------


typedef struct _PROTOCOL_ENTRY 
{
    LIST_ENTRY                  leProtocolList;

    DWORD                       dwProtocolId;

    DWORD                       dwComponentId;

    DWORD                       dwIfCount;
    
    ROUTING_PROTOCOL_CONFIG     rpcProtocolConfig;

    DWORD                       dwSignature;

} PROTOCOL_ENTRY, *PPROTOCOL_ENTRY;


#define MGM_PROTOCOL_SIGNATURE  'MGMp'



//
// Protocol table manipulation routines
//

DWORD
CreateProtocolEntry(
    PLIST_ENTRY                 pleProtocolList,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    PROUTING_PROTOCOL_CONFIG    prpcConfig,
    PPROTOCOL_ENTRY  *          pppeEntry
);


VOID
DeleteProtocolEntry(
    PPROTOCOL_ENTRY             ppeEntry
);


PPROTOCOL_ENTRY
GetProtocolEntry(
    PLIST_ENTRY                 pleProtocolList,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId 
);


VOID
DeleteProtocolList(
    PLIST_ENTRY                 pleProtocolList
);


DWORD
VerifyProtocolHandle(
    PPROTOCOL_ENTRY             ppeEntry
);


PPROTOCOL_ENTRY
GetIgmpProtocolEntry(
    PLIST_ENTRY                 pleProtocolList
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\log.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    log.h
//
// History:
//  V Raman Aug-18-1997     Created.
//
// This file is processed by mapmsg to produce a .mc file,
// then the .mc file is compiled by the message compiler,
// and the resulting binary is included in IPMGM's resource file.
//
// Don't change the comments following the manifest constants
// without understanding how mapmsg works.
//============================================================================


#define IPMGMLOG_BASE                           50000

#define IPMGMLOG_INIT_CRITSEC_FAILED            (IPMGMLOG_BASE + 1)
/*
 * IPMGM was unable to initialize a critical section.
 * The data is the exception code.
 */

#define IPMGMLOG_HEAP_CREATE_FAILED             (IPMGMLOG_BASE + 2)
/*
 * IPMGM was unable to create a heap.
 * The data is the error code.
 */

#define IPMGMLOG_HEAP_ALLOC_FAILED              (IPMGMLOG_BASE + 3)
/*
 * IPMGM was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define IPMGMLOG_IPMGM_ALREADY_STARTED          (IPMGMLOG_BASE + 4)
/*
 * IPMGM received a start request when it was already running.
 */

#define IPMGMLOG_CREATE_RWL_FAILED              (IPMGMLOG_BASE + 5)
/*
 * IPMGM was unable to create a synchronization object.
 * The data is the error code.
 */

#define IPMGMLOG_CREATE_EVENT_FAILED            (IPMGMLOG_BASE + 6)
/*
 * IPMGM was unable to create an event.
 * The data is the error code.
 */

#define IPMGMLOG_CREATE_SEMAPHORE_FAILED        (IPMGMLOG_BASE + 7)
/*
 * IPMGM was unable to create a semaphore.
 * The data is the error code.
 */

#define IPMGMLOG_IPMGM_STARTED                  (IPMGMLOG_BASE + 8)
/*
 * IPMGM has started successfully.
 */

#define IPMGMLOG_QUEUE_WORKER_FAILED            (IPMGMLOG_BASE + 9)
/*
 * IPMGM could not schedule a task to be executed.
 * This may have been caused by a memory allocation failure.
 * The data is the error code.
 */

#define IPMGMLOG_PROTOCOL_NOT_FOUND             (IPMGMLOG_BASE + 10)
/*
 * IPMGM could not find the protocol component (%1, %2)
 */

#define IPMGMLOG_PROTOCOL_ALREADY_PRESENT       (IPMGMLOG_BASE + 11)
/*
 * Protocol component has already registered with IPMGM 
 */

#define IPMGMLOG_CREATE_PROTOCOL_FAILED         (IPMGMLOG_BASE + 12)
/*
 * IPMGM failed to register the protocol component.
 * The data is in the error code.
 */

#define IPMGMLOG_INTERFACES_PRESENT             (IPMGMLOG_BASE + 13)
/*
 * The protocol component that is attempting to deregister is currently
 * enabled on one or more interfaces.   
 */

#define IPMGMLOG_IF_ALREADY_PRESENT             (IPMGMLOG_BASE + 14)
/*
 * This protocol component has already been enabled on this interface 
 */

#define IPMGMLOG_IF_NOT_FOUND                   (IPMGMLOG_BASE + 15)
/*
 * Specified interface was not present in MGM. 
 */

#define IPMGMLOG_IF_DIFFERENT_OWNER             (IPMGMLOG_BASE + 16)
/*
 * Another routing protocol component has already been enabled on
 * this interface.  Only one routing protocol component may be 
 * enabled on an interface at any time.
 */

#define IPMGMLOG_IF_IGMP_NOT_PRESENT            (IPMGMLOG_BASE + 17)
/*
 * IGMP is not enabled on this interface 
 */

#define IPMGMLOG_IF_PROTOCOL_NOT_PRESENT        (IPMGMLOG_BASE + 18)
/*
 * No routing protocol has been enabled on this interface 
 */

#define IPMGMLOG_INVALID_PROTOCOL_HANDLE        (IPMGMLOG_BASE + 19)
/*
 * The handle specified by the protocol component is not valid. This
 * maybe because the protocol component is not registered with IPMGM
 */

#define IPMGMLOG_IF_IGMP_PRESENT                (IPMGMLOG_BASE + 20)
/*
 * Interface cannot be deleted because IGMP is still active on 
 * this interface. 
 */

#define IPMGMLOG_INVALID_TIMER_HANDLE           (IPMGMLOG_BASE + 21)
/*
 * Failed to set timer for forwarding entry.  
 * The error code is in the data.
 */

#define IPMGMLOG_RTM_REGISTER_FAILED            (IPMGMLOG_BASE + 22)
/*
 * Failed to register with RTM.
 * The error code is in the data.
 */

#define IPMGMLOG_IPMGM_STOPPED                  (IPMGMLOG_BASE + 99)
/*
 * IPMGM has stopped.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\protocol.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: protocol.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// Routines that manipulate protocol entries
//============================================================================

#include "pchmgm.h"
#pragma hdrstop


//----------------------------------------------------------------------------
// CreateProtocolEntry
//
// This function creates, initializes and inserts a new protocol entry in the
// the list of protocols registered with MGM.
//
// Assumes that the protocol list is already locked.
//----------------------------------------------------------------------------

DWORD
CreateProtocolEntry(
    PLIST_ENTRY                 pleProtocolList,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId, 
    PROUTING_PROTOCOL_CONFIG    prpcConfig,
    PPROTOCOL_ENTRY  *          pppeEntry
)
{

    DWORD               dwErr = NO_ERROR;
    
    PPROTOCOL_ENTRY     ppe = NULL;



    do
    {
        //
        // Allocate new protocol entry.
        //

        ppe = MGM_ALLOC( sizeof( PROTOCOL_ENTRY ) );

        if ( ppe == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            
            TRACE1( 
                ANY, 
                "CreateProtocolEntry : Could not allocate protocol entry %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }


        //
        // Initialize protocol entry
        //

        InitializeListHead( &ppe-> leProtocolList );
        

        ppe-> dwProtocolId      = dwProtocolId;
        ppe-> dwComponentId     = dwComponentId;
        ppe-> dwIfCount         = 0;

        CopyMemory( 
            &ppe-> rpcProtocolConfig, prpcConfig, 
            sizeof( ROUTING_PROTOCOL_CONFIG )
            );

        ppe-> dwSignature       = MGM_PROTOCOL_SIGNATURE;


        //
        // Insert into protocol list
        //

        InsertTailList( pleProtocolList, &ppe-> leProtocolList );

        *pppeEntry = ppe;
        
        dwErr = NO_ERROR;
        
    } while ( FALSE );


    return dwErr;
}


//----------------------------------------------------------------------------
// GetProtocolEntry
//
// This function retrieves an entry from the list of protocols registered 
// with MGM.
//
// Assumes that the protocol list is already locked.
//----------------------------------------------------------------------------


PPROTOCOL_ENTRY
GetProtocolEntry(
    PLIST_ENTRY                 pleProtocolList,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId 
)
{

    BOOL                bFound = FALSE;
    PLIST_ENTRY         ple = NULL;
    PPROTOCOL_ENTRY     ppe = NULL;

    
    //
    // Scan protocol list and find entry
    //
    
    for ( ple = pleProtocolList-> Flink; 
          ple != pleProtocolList; 
          ple = ple-> Flink )
    {
        ppe = CONTAINING_RECORD( ple, PROTOCOL_ENTRY, leProtocolList );

        if ( ppe-> dwProtocolId == dwProtocolId &&
             ppe-> dwComponentId == dwComponentId )
        {
            bFound = TRUE;
            break;
        }
    }

    return bFound ? ppe : NULL;
}


//----------------------------------------------------------------------------
// DeleteProtocolEntry
//
// This function deletes a protocol entry from the list of registered 
// protocols.  All the interface owned by this protocol should have been
// released before this funtion is called.
//
// Assumes that the protocol list is already locked.
//----------------------------------------------------------------------------


VOID
DeleteProtocolEntry(
    PPROTOCOL_ENTRY             ppeEntry
)
{
    //
    // remove protocol entry from list
    //

    RemoveEntryList( &ppeEntry-> leProtocolList );

    MGM_FREE( ppeEntry );
}



//----------------------------------------------------------------------------
// DeleteProtocolList
//
// This function deletes a protocol entry from the list of registered 
// protocols.  All the interface owned by this protocol should have been
// released before this funtion is called.
//
// Assumes that the protocol list is already locked.
//----------------------------------------------------------------------------

VOID
DeleteProtocolList(
    PLIST_ENTRY                 pleProtocolList
)
{

    PLIST_ENTRY         ple = NULL;
    
    PPROTOCOL_ENTRY     ppe = NULL;

    
    while ( !IsListEmpty( pleProtocolList ) )
    {
        ple = pleProtocolList-> Flink;
        
        ppe = CONTAINING_RECORD( ple, PROTOCOL_ENTRY, leProtocolList );

        DeleteProtocolEntry( ppe );
    }
}



//----------------------------------------------------------------------------
// VerifyProtocolHandle
//
// This function verifies that the specified pointer points to a valid
// protocol entry 
//
// Assumes that the protocol list is already locked.
//----------------------------------------------------------------------------

DWORD
VerifyProtocolHandle(
    PPROTOCOL_ENTRY             ppeEntry
)
{

    DWORD dwErr = NO_ERROR;
    
    try
    {
        if ( ppeEntry-> dwSignature != MGM_PROTOCOL_SIGNATURE )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            TRACE0( ANY, "Invalid protocol handle" );

            LOGERR0( INVALID_PROTOCOL_HANDLE, dwErr );

        }
    }
    
    except ( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? 
                                   EXCEPTION_EXECUTE_HANDLER :
                                   EXCEPTION_CONTINUE_SEARCH )
    {
        dwErr = ERROR_INVALID_PARAMETER;

        TRACE0( ANY, "Invalid protocol handle" );

        LOGERR0( INVALID_PROTOCOL_HANDLE, dwErr );

    }

    return dwErr;
}




//----------------------------------------------------------------------------
// FindIgmpProtocolEntry
//
//  Find the protocol entry for IGMP
//----------------------------------------------------------------------------


PPROTOCOL_ENTRY
GetIgmpProtocolEntry(
    PLIST_ENTRY                 pleProtocolList
)
{
    BOOL                bFound = FALSE;

    PLIST_ENTRY         ple = NULL;

    PPROTOCOL_ENTRY     ppe = NULL;


    
    //
    // Scan protocol list and find entry
    //
    
    for ( ple = pleProtocolList-> Flink; 
          ple != pleProtocolList; 
          ple = ple-> Flink )
    {
        ppe = CONTAINING_RECORD( ple, PROTOCOL_ENTRY, leProtocolList );

        if ( IS_PROTOCOL_IGMP( ppe ) )
        {
            bFound = TRUE;
            break;
        }
    }

    return bFound ? ppe : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\route.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: route.h
//
// History:
//      V Raman	2-5-1997  Created.
//
// Declarations for routines that manipulate routes entries
//============================================================================


#ifndef _ROUTE_H_
#define _ROUTE_H_


DWORD
WINAPI 
RtmChangeNotificationCallback(
    RTM_ENTITY_HANDLE           hRtmHandle,
    RTM_EVENT_TYPE              retEventType,
    PVOID                       pvContext1,
    PVOID                       pvContext2
);

VOID
WorkerFunctionProcessRtmChangeNotification(
    PVOID                       pvContext
);

DWORD
ProcessUnMarkedDestination(
    PRTM_DEST_INFO          prdi
);

DWORD
ProcessRouteDelete(
    PRTM_DEST_INFO          prdi
);

DWORD
ProcessRouteUpdate(
    PRTM_DEST_INFO          prdi
);

VOID
DeleteMfeAndRefs(
    PLIST_ENTRY     ple
);

HANDLE
SelectNextHop(
    PRTM_DEST_INFO      prdi
);



//----------------------------------------------------------------------------
//
// Route reference operations
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// MFE_REFERENCE_ENTRY
//
// Each route maintains a list of MFE entries that use this route for 
// their RPF check.  Each entry in this reference list stores the
// source, group info.
//
// Fields descriptions are left as an exercise to the reader.
//
//----------------------------------------------------------------------------

typedef struct _ROUTE_REFERENCE_ENTRY
{
    LIST_ENTRY                  leRefList;

    DWORD                       dwGroupAddr;

    DWORD                       dwGroupMask;

    DWORD                       dwSourceAddr;

    DWORD                       dwSourceMask;

    HANDLE                      hNextHop;

} ROUTE_REFERENCE_ENTRY, *PROUTE_REFERENCE_ENTRY;



VOID
AddSourceGroupToRouteRefList(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    HANDLE                      hNextHop,
    PBYTE                       pbBuffer
);



BOOL
FindRouteRefEntry(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PROUTE_REFERENCE_ENTRY *    pprre
);



VOID
DeleteRouteRef(
    PROUTE_REFERENCE_ENTRY      prre
);

//
// imported from packet.c
//

BOOL
IsMFEPresent(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bAddToForwarder
);

#endif // _ROUTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\route.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: route.c
//
// History:
//      V Raman	Feb-5-1998  Created.
//
// Routines that manipulate routes entries
//============================================================================


#include "pchmgm.h"
#pragma hdrstop



//----------------------------------------------------------------------------
//
// Route reference operations
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// AddSourceGroupToRouteRefList
//
//  This function inserts a reference for each MFE that uses this route
//  for it RPF check.  It is invoked by the new packet function on creation
//  of an MFE.
//----------------------------------------------------------------------------

VOID
AddSourceGroupToRouteRefList(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    HANDLE                      hNextHop,
    PBYTE                       pbBuffer
)
{
    BOOL                        bUnLock = FALSE, bMark = FALSE;

    DWORD                       dwErr;

    PMGM_LOCKED_LIST            pmllMfeList;

    PBYTE                       pbOpaqueInfo = NULL;

    PRTM_DEST_INFO              prdi = (PRTM_DEST_INFO) pbBuffer;

    PROUTE_REFERENCE_ENTRY      prre = NULL, prreNew = NULL;



    TRACEROUTE0( ROUTE, "ENTERED AddSourceGroupToRouteRefList" );

    do
    {
        //
        // Create a route reference entry
        //

        prre = MGM_ALLOC( sizeof( ROUTE_REFERENCE_ENTRY ) );

        if ( prre == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "Failed to allocate %d bytes",
                sizeof( ROUTE_REFERENCE_ENTRY )
                );

            break;
        }


        prre-> dwSourceAddr = dwSourceAddr;
        prre-> dwSourceMask = dwSourceMask;

        prre-> dwGroupAddr  = dwGroupAddr;
        prre-> dwGroupMask  = dwGroupMask;

        prre-> hNextHop     = hNextHop;

        InitializeListHead ( &prre-> leRefList );


        //
        // Lock the dest
        //

        dwErr = RtmLockDestination(
                    g_hRtmHandle, prdi-> DestHandle, TRUE, TRUE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to lock dest %x", dwErr );

            break;
        }

        bUnLock = TRUE;


        //
        // Get the opaque pointer
        //

        dwErr = RtmGetOpaqueInformationPointer(
                    g_hRtmHandle, prdi-> DestHandle, &pbOpaqueInfo
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to retrieve opaque pointer %x", dwErr );

            break;
        }


        if ( *( ( PBYTE * ) pbOpaqueInfo ) == NULL )
        {
            //
            // NULL opaque pointer implies this is the first MFe that
            // depends on this route
            //

            //
            // create a locked list
            //

            pmllMfeList = MGM_ALLOC( sizeof( MGM_LOCKED_LIST ) );

            if ( pmllMfeList == NULL )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                TRACE1(
                    ANY, "AddSourceGroupToRouteRefList : "
                    "Failed to allocate route ref list %x", dwErr
                    );

                break;
            }

            CREATE_LOCKED_LIST( pmllMfeList );

            //
            // insert the element into the list
            //

            InsertTailList(
                &( pmllMfeList-> leHead ), &( prre-> leRefList )
                );


            //
            // set the opaque pointer
            //

            *( ( PBYTE *) pbOpaqueInfo ) = (PBYTE) pmllMfeList;


            //
            // Mark the destination
            //

            bMark = TRUE;
        }

        else
        {
            pmllMfeList = ( PMGM_LOCKED_LIST ) *( ( PBYTE *) pbOpaqueInfo );

            //
            // Acquire the list lock
            //

            ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );


            //
            // release the dest lock
            //

            bUnLock = FALSE;

            dwErr = RtmLockDestination(
                        g_hRtmHandle, prdi-> DestHandle, TRUE, FALSE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to release dest %x", dwErr );
            }


            //
            // Insert the rre into the list (in its appropriate place)
            //

            if ( !FindRouteRefEntry(
                    &pmllMfeList-> leHead, dwSourceAddr, dwSourceMask,
                    dwGroupAddr, dwGroupMask, &prreNew
                    ) )
            {
                InsertTailList(
                    ( prreNew ) ? &prreNew-> leRefList :
                                  &pmllMfeList-> leHead,
                    &prre-> leRefList
                    );
            }

            else
            {
                TRACE1(
                    ANY, "Reference already exists for source %x", dwSourceAddr
                    );

                MGM_FREE( prre );
            }


            //
            // release the list lock
            //

            RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

            dwErr = NO_ERROR;
        }

    } while ( FALSE );


    //
    // In case of error , free the allocation for route reference
    //

    if ( ( dwErr != NO_ERROR ) && ( prre != NULL ) )
    {
        MGM_FREE( prre );
    }


    //
    // release the dest lock
    //

    if ( bUnLock )
    {
        dwErr = RtmLockDestination(
                    g_hRtmHandle, prdi-> DestHandle, TRUE, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to release dest %x", dwErr );
        }
    }


    //
    // mark dest if required
    //

    if ( bMark )
    {
        dwErr = RtmMarkDestForChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle,
                    prdi-> DestHandle, TRUE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to mark destination %x:", dwErr );
        }
    }

    TRACEROUTE0( ROUTE, "LEAVING AddSourceGroupToRouteRefList" );
}



//----------------------------------------------------------------------------
// FindRouteRefEntry
//
//  Finds a specified (source, group ) entry in the MFE reference list
//  for a route.
//
//  If the entry is found a pointer to the entry is returned in the parameter
//  pprre.
//  If the entry is not found a pointer to the "next" entry is returned.
//----------------------------------------------------------------------------

BOOL
FindRouteRefEntry(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PROUTE_REFERENCE_ENTRY *    pprre
)
{
    BOOL                        bFound = FALSE;

    INT                         iCmp;

    PLIST_ENTRY                 pleRef;

    PROUTE_REFERENCE_ENTRY      prre;


    TRACEROUTE0( ROUTE, "ENTERED RouteRefEntry" );

    do
    {
        *pprre = NULL;

        pleRef = pleRefList-> Flink;

        while ( pleRef != pleRefList )
        {
            prre = CONTAINING_RECORD(
                        pleRef, ROUTE_REFERENCE_ENTRY, leRefList
                        );

            //
            // is same group
            //

            if ( INET_CMP( prre-> dwGroupAddr, dwGroupAddr, iCmp ) < 0 )
            {
                pleRef = pleRef-> Flink;

                continue;
            }

            else if ( iCmp > 0 )
            {
                //
                // past possible group entry
                //

                *pprre = prre;

                break;
            }


            //
            // same group, now look for source
            //

            if ( INET_CMP( prre-> dwSourceAddr, dwSourceAddr, iCmp ) < 0 )
            {
                pleRef = pleRef-> Flink;

                continue;
            }

            else if ( iCmp > 0 )
            {
                //
                // past possible source entry
                //

                *pprre = prre;

                break;
            }

            //
            // found entry
            //

            *pprre = prre;

            bFound = TRUE;

            break;
        }

    } while ( FALSE );

    TRACEROUTE1( ROUTE, "LEAVING RouteRefEntry : %d", bFound );

    return bFound;
}



//----------------------------------------------------------------------------
// DeletRouteRef
//
//----------------------------------------------------------------------------

VOID
DeleteRouteRef(
    PROUTE_REFERENCE_ENTRY                prre
)
{
    TRACEROUTE0( ROUTE, "ENTERED DeleteRefEntry" );

    RemoveEntryList( &prre-> leRefList );

    MGM_FREE( prre );

    TRACEROUTE0( ROUTE, "LEAVING DeleteRefEntry" );
}



DWORD
WINAPI
RtmChangeNotificationCallback(
    RTM_ENTITY_HANDLE           hRtmHandle,
    RTM_EVENT_TYPE              retEventType,
    PVOID                       pvContext1,
    PVOID                       pvContext2
)
{
    DWORD dwErr = NO_ERROR;


    if ( !ENTER_MGM_API() )
    {
        TRACE0( ANY, "RtmChangeNotificationCallback : Failed to enter" );

        return ERROR_CAN_NOT_COMPLETE;
    }


    TRACE0( ROUTE, "ENTERED RtmChangeNotificationCallback" );


    do
    {
        //
        // Ignore all notifications except change notifications
        //

        if ( retEventType != RTM_CHANGE_NOTIFICATION )
        {
            break;
        }


        //
        // Queue work function to process changed destinations
        //

        dwErr = QueueMgmWorker(
                    WorkerFunctionProcessRtmChangeNotification, NULL
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to queue work item", dwErr );
        }

    } while ( FALSE );


    LEAVE_MGM_API();


    TRACE1( ROUTE, "LEAVING RtmChangeNotificationCallback : %d", dwErr );

    return dwErr;
}



VOID
WorkerFunctionProcessRtmChangeNotification(
    PVOID                       pvContext
)
{
    BOOL bMarked = FALSE, bDone = FALSE;

    DWORD dwErr, dwNumDests;

    RTM_DEST_INFO rdi;



    if ( !ENTER_MGM_WORKER() )
    {
        TRACE0(
            ANY, "WorkerFunctionProcessRtmChangeNotification : Failed to enter"
            );

        return;
    }


    TRACE0( ROUTE, "ENTERED WorkerFunctionRtmChangeNotification" );

    do
    {
        //
        // Get route changes one at a time
        //

        dwNumDests = 1;

        dwErr = RtmGetChangedDests(
                    g_hRtmHandle, g_hNotificationHandle, &dwNumDests, &rdi
                    );

        if ( ( dwErr != NO_ERROR ) && ( dwErr != ERROR_NO_MORE_ITEMS ) )
        {
            TRACE1(
                ANY, "RtmGetChangedDests failed with error : %x",
                dwErr
                );

            break;
        }


        //
        // if there are no changed dests, quit.
        //

        if ( dwNumDests == 0 )
        {
            TRACE0( ANY, "RtmGetChangedDests returns 0 dests" );

            break;
        }


        //
        // There are dests.  Check if there are no more dests.
        // If so set a flag to quit processing after this one
        //

        if ( dwErr == ERROR_NO_MORE_ITEMS )
        {
            bDone = TRUE;
        }


        //
        // Check if there any routes for this destination
        //

        if ( rdi.ViewInfo[ 0 ].Route == NULL )
        {
            //
            // No routes, assume this to be a delete
            //

            dwErr = ProcessRouteDelete( &rdi );
        }

        else
        {
            //
            // Check if dest is marked for change notification
            //

            dwErr = RtmIsMarkedForChangeNotification(
                        g_hRtmHandle, g_hNotificationHandle, rdi.DestHandle,
                        &bMarked
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1(
                    ANY, "RtmIsMarkedForChangeNotification failed with error : %x",
                    dwErr
                    );

                break;
            }


            //
            // Process this destination
            //

            ( bMarked ) ? ProcessRouteUpdate( &rdi ) :
                          ProcessUnMarkedDestination( &rdi );

        } while ( FALSE );


        //
        // Release changed destinations
        //

        dwErr = RtmReleaseChangedDests(
                    g_hRtmHandle, g_hNotificationHandle, 1, &rdi
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to released destination", dwErr );
        }

    } while ( !bDone );


    LEAVE_MGM_WORKER();

    TRACE0( ROUTE, "LEAVING WorkerFunctionRtmChangeNotification" );
}



DWORD
ProcessUnMarkedDestination(
    PRTM_DEST_INFO          prdi
)
{
    BOOL bRelDest = FALSE, bMarked = FALSE, bUnLock = FALSE,
         bRelRouteRef = FALSE, bUnMark = FALSE;

    DWORD dwErr, dwDestMask;

    PBYTE pbOpaqueInfo = NULL;

    PLIST_ENTRY ple, pleTemp;

    PROUTE_REFERENCE_ENTRY prre;

    PMGM_LOCKED_LIST pmllMfeList = NULL;

    RTM_DEST_INFO rdiLessSpecificDest;



    do
    {
        //
        // Get next less specific destination
        //

        dwErr = RtmGetLessSpecificDestination(
                    g_hRtmHandle, prdi-> DestHandle, RTM_BEST_PROTOCOL,
                    RTM_VIEW_MASK_MCAST, &rdiLessSpecificDest
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to get less specific destination", dwErr );

            break;
        }

        bRelDest = TRUE;


        //
        // Check if it is marked
        //

        dwErr = RtmIsMarkedForChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle,
                    rdiLessSpecificDest.DestHandle, &bMarked
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to check if dest is marked", dwErr );

            break;
        }


        //
        // if marked
        //

        if ( bMarked )
        {
            //
            // it is marked.  Lock it
            //

            dwErr = RtmLockDestination(
                        g_hRtmHandle,
                        rdiLessSpecificDest.DestHandle,
                        TRUE, TRUE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to lock less specific dest : %x", dwErr );

                break;
            }

            bUnLock = TRUE;


            //
            // Get its opaque pointer
            //

            dwErr = RtmGetOpaqueInformationPointer(
                        g_hRtmHandle, rdiLessSpecificDest.DestHandle,
                        &pbOpaqueInfo
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1(
                    ANY, "Failed to opaque ptr for less specific dest : %x",
                    dwErr
                    );

                break;
            }


            //
            // Check if it is NULL
            //

            if ( *( ( PBYTE * ) pbOpaqueInfo ) == NULL )
            {
                bUnMark = TRUE;

                break;
            }


            pmllMfeList = ( PMGM_LOCKED_LIST ) *( ( PBYTE * ) pbOpaqueInfo );


            //
            // lock the route reference list
            //

            ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
            bRelRouteRef = TRUE;


            //
            // Unlock the dest
            //

            bUnLock = FALSE;

            dwErr = RtmLockDestination(
                        g_hRtmHandle,
                        rdiLessSpecificDest.DestHandle,
                        TRUE, FALSE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to unlock less specific dest : %x", dwErr );

                break;
            }


            //
            // Create MASK for new dest. from len
            //

            dwDestMask = RTM_IPV4_MASK_FROM_LEN(
                            prdi-> DestAddress.NumBits
                            );

            //
            // For each reference
            //

            for ( ple = pmllMfeList-> leHead.Flink;
                  ple != &pmllMfeList-> leHead; )
            {
                prre = CONTAINING_RECORD(
                        ple, ROUTE_REFERENCE_ENTRY, leRefList
                        );

                //
                // Check if this MFE would fall under the
                // more specific route
                //

                if ( ( prre-> dwSourceAddr & dwDestMask ) ==
                     ((  * ( PDWORD ) prdi-> DestAddress.AddrBits ) & dwDestMask) )
                {
                    //
                    // if it does, delete the MFE.  This will force its
                    // recreation, at which time it will be made dependent
                    // on the more specific route
                    //

                    pleTemp = ple-> Flink;

                    RemoveEntryList( ple );

                    DeleteMfeAndRefs( ple );

                    ple = pleTemp;
                }
                else
                {
                    ple = ple-> Flink;
                }
            }


            //
            // if Ref list is empty, it needs to be deleted too.
            //

            if ( IsListEmpty( &pmllMfeList-> leHead ) )
            {
                //
                // to delete the opaque pointer, the dest needs to be locked
                // (via RtmLockDestination)
                //
                // the dest lock is held before locking the route reference
                // list ( via ACQUIRE_ROUTE_LOCK_EXCLUSIVE )
                //
                // At this point in the code, the route reference is locked
                // but the dest is not locked.
                //
                // To lock it, the route reference lock is first released
                // (via RELEASE_ROUTE_LOCK_EXCLUSIVE).
                //
                // The opaque pointer is then acquired, route ref list locked,
                // and double checked for emptiness.  This round-about ensures
                // that the route ref is not deleted while there are threads
                // waiting on its lock.  This can happen since the dest lock
                // is not held for most of the operations here
                //

                RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
                bRelRouteRef = FALSE;

                //
                // Lock dest
                //

                dwErr = RtmLockDestination(
                            g_hRtmHandle,
                            rdiLessSpecificDest.DestHandle,
                            TRUE, TRUE
                            );

                if ( dwErr != NO_ERROR )
                {
                    TRACE1( ANY, "Failed to lock dest : %x", dwErr );

                    break;
                }

                bUnLock = TRUE;


                //
                // Get Opaque pointer again
                //

                dwErr = RtmGetOpaqueInformationPointer(
                            g_hRtmHandle, rdiLessSpecificDest.DestHandle,
                            &pbOpaqueInfo
                            );

                if ( dwErr != NO_ERROR || ((* ((PBYTE *)pbOpaqueInfo) == NULL)) )
                {
                    TRACE1( ANY, "Failed to get opaque ptr : %x", dwErr );

                    break;
                }


                //
                // Get ref. list and lock it.
                //

                pmllMfeList = ( PMGM_LOCKED_LIST ) * ( ( PBYTE * ) pbOpaqueInfo );

                ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
                bRelRouteRef = TRUE;


                //
                // If list is still empty
                //

                if ( IsListEmpty( &pmllMfeList-> leHead ) )
                {
                    //
                    // Clear opaque pointer info
                    //

                    * ( PBYTE * )pbOpaqueInfo = NULL;

                    //
                    // release list lock
                    //

                    RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
                    bRelRouteRef = FALSE;

                    MGM_FREE( pmllMfeList );


                    //
                    // unmark the dest.  Change notifications for this
                    // dest are no longer required.
                    //

                    bUnMark = TRUE;
                }
            }

            else
            {
                RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
                bRelRouteRef = FALSE;
            }
        }

    } while ( FALSE );


    //
    // release route ref list lock
    //

    if ( bRelRouteRef )
    {
        RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
    }


    //
    // Unlock dest
    //

    if ( bUnLock )
    {
        dwErr = RtmLockDestination(
                    g_hRtmHandle,
                    rdiLessSpecificDest.DestHandle,
                    TRUE, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to lock dest : %x", dwErr );
        }
    }


    //
    // Unmark dest
    //

    if ( bUnMark )
    {
        dwErr = RtmMarkDestForChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle,
                    rdiLessSpecificDest.DestHandle, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to unmark DEST: %x", dwErr );
        }
    }

    return dwErr;
}



DWORD
ProcessRouteDelete(
    PRTM_DEST_INFO          prdi
)
{
    BOOL                    bMark = FALSE;

    DWORD                   dwErr;

    PMGM_LOCKED_LIST        pmllMfeList;

    PBYTE                   pbOpaqueInfo = NULL;

    PLIST_ENTRY             ple;


    do
    {
        //
        // Cannot lock dest.  Is that OK ?
        //

        //
        // Check if this is a marked destination
        // Only marked destinations are processed
        //

        dwErr = RtmIsMarkedForChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle,
                    prdi-> DestHandle, &bMark
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to check if dest marked", dwErr );

            break;
        }

        if ( !bMark )
        {
            TRACE0( 
                ANY, "Ignoring change notification for unmarked destination"
                );
                
            break;
        }


        //
        // Get Opaque pointer & the list of MFEs dependent
        // on this dest
        //

        dwErr = RtmGetOpaqueInformationPointer(
                    g_hRtmHandle, prdi-> DestHandle, &pbOpaqueInfo
                    );

        if ( (dwErr != NO_ERROR) || ((* ((PBYTE *)pbOpaqueInfo) == NULL)) )
        {
            TRACE1( ANY, "Failed to get opaque ptr", dwErr );

            break;
        }


        //
        // Clear out the opaque pointer
        //

        pmllMfeList = (PMGM_LOCKED_LIST) *( ( PBYTE * ) pbOpaqueInfo );

        *( ( PBYTE * ) pbOpaqueInfo ) = NULL;


        //
        // Cannot unlock dest.  Is that ok ?
        //

        //
        // Check if the opaque pointer is NULL
        //

        if ( pmllMfeList == NULL )
        {
            TRACE0( ANY, "Opaque pointer is NULL" );

            break;
        }


        //
        // Delete all the MFEs
        //

        ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

        while ( !IsListEmpty( &pmllMfeList-> leHead ) )
        {
            ple = RemoveHeadList( &pmllMfeList-> leHead );

            DeleteMfeAndRefs( ple );
        }


        RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

        MGM_FREE( pmllMfeList );

        dwErr = NO_ERROR;

    } while ( FALSE );


    return dwErr;
}


DWORD
ProcessRouteUpdate(
    PRTM_DEST_INFO          prdi
)
{
    BOOL                    bUnLock = FALSE, bUnMark = FALSE,
                            bFound;

    DWORD                   dwSize, dwErr, dwInd;

    PBYTE                   pbOpaqueInfo = NULL;

    PMGM_LOCKED_LIST        pmllMfeList;

    PLIST_ENTRY             ple, pleTemp;

    PROUTE_REFERENCE_ENTRY  prre;

    PRTM_ROUTE_INFO         prri;


    //
    // the processing goes as follows :
    //

    do
    {
        //
        // Allocate route info structure
        //

        dwSize = sizeof ( RTM_ROUTE_INFO ) +
                 ( g_rrpRtmProfile.MaxNextHopsInRoute - 1 ) *
                 sizeof( RTM_NEXTHOP_HANDLE );

        prri = MGM_ALLOC( dwSize );

        if ( prri == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( ANY, "Failed to allocate route info, size : %x", dwSize );

            break;
        }

        //
        // Lock destination
        //

        dwErr = RtmLockDestination(
                    g_hRtmHandle, prdi-> DestHandle, TRUE, TRUE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to lock dest : %x", dwErr );

            break;
        }

        bUnLock = TRUE;


        //
        // Get Opaque pointer
        //

        dwErr = RtmGetOpaqueInformationPointer(
                    g_hRtmHandle, prdi-> DestHandle, &pbOpaqueInfo
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to get opaque ptr : %x", dwErr );

            break;
        }


        //
        // Unmark dest if there are no MFEs that depend on it.
        //

        if ( *( ( PBYTE * ) pbOpaqueInfo ) == NULL )
        {
            bUnMark = TRUE;

            break;
        }

        pmllMfeList = (PMGM_LOCKED_LIST) *( ( PBYTE * ) pbOpaqueInfo );


        //
        // get route ref list lock
        //

        ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );


        //
        // Unlock dest
        //

        bUnLock = FALSE;

        dwErr = RtmLockDestination(
                    g_hRtmHandle, prdi-> DestHandle, TRUE, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to lock dest : %x", dwErr );

            break;
        }

        //
        // Get the route info for the best UNICAST route on dest
        //

        dwErr = RtmGetRouteInfo(
                    g_hRtmHandle, prdi ->ViewInfo[ 0 ].Route, prri, NULL);

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed route info : %x", dwErr);

            break;
        }

        //
        // For each Reference, check if NEXTHOP is still present
        //

        for ( ple = pmllMfeList-> leHead.Flink;
              ple != &pmllMfeList-> leHead; )
        {
            prre = CONTAINING_RECORD( ple, ROUTE_REFERENCE_ENTRY, leRefList );

            for ( dwInd = 0; dwInd < prri-> NextHopsList.NumNextHops; dwInd++ )
            {
                bFound = FALSE;

                if ( prre-> hNextHop == prri-> NextHopsList.NextHops[ dwInd ] )
                {
                    //
                    // OK next hop still present, nothing further needs
                    // to be done
                    //

                    bFound = TRUE;
                    break;
                }
            }


            //
            // if NEXTHOP is not present
            //

            if ( !bFound )
            {
                pleTemp = ple-> Flink;

                //
                // Delete the reference and the corresponding MFE
                //

                RemoveEntryList( ple );

                DeleteMfeAndRefs( ple );

                ple = pleTemp;
            }

            else
            {
                ple = ple-> Flink;
            }

        }

        //
        // Release the route info
        //

        dwErr = RtmReleaseRouteInfo( g_hRtmHandle, prri );
        
        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to release route info : %x", dwErr );
        }

        //
        // if Ref list is empty, it needs to be deleted too.
        //

        if ( IsListEmpty( &pmllMfeList-> leHead ) )
        {
            //
            // to delete the opaque pointer, the dest needs to be locked
            // (via RtmLockDestination)
            //
            // the dest lock is held before locking the route reference
            // list ( via ACQUIRE_ROUTE_LOCK_EXCLUSIVE )
            //
            // At this point in the code, the route reference is locked
            // but the dest is not locked.
            //
            // To lock it, the route reference lock is first released
            // (via RELEASE_ROUTE_LOCK_EXCLUSIVE).
            //
            // The opaque pointer is then acquired, route ref list locked,
            // and double checked for emptiness.  This round-about ensures
            // that the route ref is not deleted while there are threads
            // waiting on its lock.  This can happen since the dest lock
            // is not held for most of the operations here
            //

            RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );


            //
            // Lock dest
            //

            dwErr = RtmLockDestination(
                        g_hRtmHandle, prdi-> DestHandle, TRUE, TRUE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to lock dest : %x", dwErr );

                break;
            }

            bUnLock = TRUE;


            //
            // Get Opaque pointer again
            //

            dwErr = RtmGetOpaqueInformationPointer(
                        g_hRtmHandle, prdi-> DestHandle, &pbOpaqueInfo
                        );

            if ( dwErr != NO_ERROR || ((* ((PBYTE *)pbOpaqueInfo) == NULL)) )
            {
                TRACE1( ANY, "Failed to get opaque ptr : %x", dwErr );

                break;
            }


            //
            // Get ref. list and lock it.
            //

            pmllMfeList = ( PMGM_LOCKED_LIST ) *( ( PBYTE * ) pbOpaqueInfo );

            //
            // Ensure that the list still exists.  it is possible (though
            // the chances are small) that this list may have been freed
            //

            if ( pmllMfeList == NULL )
            {
                TRACE0(
                    ANY, "ProcessRouteUpdate : Route ref list already freed"
                    );

                break;
            }

            ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );


            //
            // If list is still empty
            //

            if ( IsListEmpty( &pmllMfeList-> leHead ) )
            {
                //
                // Clear opaque pointer info
                //

                *( ( PBYTE * ) pbOpaqueInfo ) = NULL;

                //
                // release list lock
                //

                RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

                MGM_FREE( pmllMfeList );


                //
                // unmark the dest.  Change notifications for this
                // dest are no longer required.
                //

                bUnMark = TRUE;
            }

            else
            {
                RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
            }
        }

        else
        {
            RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
        }

    } while ( FALSE );


    //
    // Unlock dest
    //

    if ( bUnLock )
    {
        dwErr = RtmLockDestination(
                    g_hRtmHandle, prdi-> DestHandle,
                    TRUE, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to lock dest : %x", dwErr );
        }
    }


    //
    // Unmark dest
    //

    if ( bUnMark )
    {
        dwErr = RtmMarkDestForChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle,
                    prdi-> DestHandle, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to unmark DEST: %x", dwErr );
        }
    }

    //
    // Free allocations
    //

    if ( prri )
    {
        MGM_FREE( prri );
    }

    return dwErr;
}



VOID
DeleteMfeAndRefs(
    PLIST_ENTRY     ple
    )
{
    DWORD                   dwInIfIndex = 0, dwInIfNextHopAddr = 0, dwIfBucket;

    PROUTE_REFERENCE_ENTRY  prre;

    PIF_ENTRY               pie = NULL;

    PIF_REFERENCE_ENTRY     pire = NULL;


    //
    // Get the reference entry
    //

    prre = CONTAINING_RECORD(
                ple, ROUTE_REFERENCE_ENTRY, leRefList
                );

    //
    // Look up and delete the MFE
    //

    LookupAndDeleteYourMfe(
        prre-> dwSourceAddr, prre-> dwSourceMask,
        prre-> dwGroupAddr, prre-> dwGroupMask,
        TRUE, &dwInIfIndex, &dwInIfNextHopAddr
        );


    //
    // Find incoming interface and delete ref from there too.
    //

	if ( dwInIfIndex != 0 )
	{
	    dwIfBucket = IF_TABLE_HASH( dwInIfIndex );

	    ACQUIRE_IF_LOCK_EXCLUSIVE( dwIfBucket );

	    if ( FindIfEntry(
	            IF_BUCKET_HEAD( dwIfBucket ), dwInIfIndex,
	            dwInIfNextHopAddr, &pie
	            ) )
	    {
	        if ( FindRefEntry(
	                &pie-> leInIfList, prre-> dwSourceAddr, prre-> dwSourceMask,
	                prre-> dwGroupAddr, prre-> dwGroupMask, &pire
	                ) )
	        {
	            RemoveEntryList( &pire-> leRefList );

	            MGM_FREE( pire );
	        }

	        else
	        {
	            TRACE2(
	                ANY, "Could not find ref entry for %x, %x",
	                prre-> dwSourceAddr, prre-> dwGroupAddr
	                );
	        }
	    }

	    else
	    {
	        TRACE2(
	            ANY, "Could not find i/f entry for %x, %x",
	            dwInIfIndex, dwInIfNextHopAddr
	            );
	    }
	
	    RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );

	    MGM_FREE( prre );
	}
}


HANDLE
SelectNextHop(
    PRTM_DEST_INFO      prdi
)
{
    DWORD               dwErr, dwSize;

    HANDLE              hNextHop;

    PRTM_ROUTE_INFO     prri;


    //
    // Allocate route info structure
    //

    dwSize = sizeof ( RTM_ROUTE_INFO ) +
             ( g_rrpRtmProfile.MaxNextHopsInRoute - 1 ) *
             sizeof( RTM_NEXTHOP_HANDLE );

    prri = MGM_ALLOC( dwSize );

    if ( prri == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

        TRACE1( ANY, "Failed to allocate route info, size : %x", dwSize );

        return NULL;
    }

    ZeroMemory( prri, dwSize );


    //
    // get route info
    //

    dwErr = RtmGetRouteInfo(
                g_hRtmHandle, prdi-> ViewInfo[ 0 ].Route,
                prri, NULL
                );

    if ( dwErr != NO_ERROR )
    {
        TRACE1( ANY, "Failed to get route info : %x", dwErr );

        MGM_FREE( prri );

        return NULL;
    }


    //
    // Pick the first next hop for now
    //

    hNextHop = prri-> NextHopsList.NextHops[0];


    //
    // Release the route info
    //

    dwErr = RtmReleaseRouteInfo( g_hRtmHandle, prri );

    if ( dwErr != NO_ERROR )
    {
        TRACE1( ANY, "Failed to release route info : %x", dwErr );
    }

    MGM_FREE( prri );

    return hNextHop;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\scope.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: scope.c
//
// History:
//      V Raman    June-25-1997  Created.
//
// Functions that deal with addition/deletion of scope-boundary.
//============================================================================


#include "pchmgm.h"
#pragma hdrstop


//
// prototypes for local functions
//

VOID
ScopeIfAndInvokeCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    POUT_IF_ENTRY       poie
);


VOID
UnScopeIfAndInvokeCallbacks(
    PGROUP_ENTRY    pge,
    PSOURCE_ENTRY   pse,
    POUT_IF_ENTRY   poie
);


PJOIN_ENTRY
GetNextJoinEntry(
);

BOOL
FindJoinEntry(
    PLIST_ENTRY     pleJoinList,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr,
    PJOIN_ENTRY *   ppje
);


DWORD
APIENTRY
MgmBlockGroups(
    IN          DWORD       dwFirstGroup,
    IN          DWORD       dwLastGroup,
    IN          DWORD       dwIfIndex,
    IN          DWORD       dwIfNextHopAddr
)
/*++

Routine Description :

    This function walks the Master group list and updates all group entries
    that fall in the range specified by dwFirstGroup-dwLastGroup.  It ensures
    that the interface specified by dwifIndex is not present in the OIF list
    of any MFE for groups in that range.  In addition any memberships for 
    groups in the range on interface dwIfIndex are removed and added to the 
    scoped interface list for the corresponding group.  The scoped i/f list
    is maintained so that subsequent unblocking of a group is transparently
    handled by MGM.  The interfaces present in the scoped i/f list for
    a group are automatically moved back to the OIF list when traffic for
    that group is unblocked.


Arguements :

    dwFirstGroup - Lower end of the range to be blocked

    dwLastGroup - Upper end of the range to be blocked

    dwIfIndex - Interface on which traffic is to be blocked


Return Value :

    NO_ERROR - Success

    
Environment :

    This routine is invoked by the IP RouterManager in response to setting
    of a administrative scoped boundary on an interface.
    
--*/
{

    INT             iCmp;
    
    DWORD           dwIfBucket, dwTimeOut = 0;

    BOOL            bFound, bDeleteCallback, bNewComp = FALSE;

    PIF_ENTRY       pieIfEntry;

    PPROTOCOL_ENTRY ppe;
    
    PGROUP_ENTRY    pge;

    PSOURCE_ENTRY   pse;

    POUT_IF_ENTRY   poie, poieTemp;

    PLIST_ENTRY     pleGrpHead, pleGrp, pleSrcHead, pleSrc, ple;

    
    //
    // Verify that MGM is up and running and update thread-count
    //
    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }


    TRACE3( 
        SCOPE, "ENTERED MgmBlockGroups (%lx - %lx) on %lx",
        dwFirstGroup, dwLastGroup, dwIfIndex
        );

        
    do
    {
        ACQUIRE_PROTOCOL_LOCK_SHARED();


        //
        // Verify that interface specified by dwIfIndex exists
        //

        dwIfBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

        pieIfEntry = GetIfEntry( 
                        IF_BUCKET_HEAD( dwIfBucket ), dwIfIndex, 
                        dwIfNextHopAddr
                        );

        if ( pieIfEntry == NULL )
        {
            TRACE1( SCOPE, "Interface %lx not found", dwIfIndex );

            break;
        }


        //
        // merge temp and master group lists
        //

        ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE();

        MergeTempAndMasterGroupLists( TEMP_GROUP_LIST_HEAD() );
        
        RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE();

        
        //
        // Lock master group list for reading
        //

        ACQUIRE_MASTER_GROUP_LOCK_SHARED();

        for ( pleGrpHead = MASTER_GROUP_LIST_HEAD(), 
              pleGrp = pleGrpHead-> Flink;
              pleGrp != pleGrpHead;
              pleGrp = pleGrp-> Flink )
        {
            pge = CONTAINING_RECORD( pleGrp, GROUP_ENTRY, leGrpList );


            //
            // check if group is within range
            //

            if ( INET_CMP( pge-> dwGroupAddr, dwLastGroup, iCmp ) > 0 )
            {
                //
                // The master group list is ordered by group number and 
                // the high end of the range to be blocked has been crossed.
                //

                break;            
            }

            else if ( INET_CMP( pge-> dwGroupAddr, dwFirstGroup, iCmp ) < 0 )
            {
                //
                // Skip group entries smaller than the lower end of the range
                //

                continue;
            }

            
            //
            // Group Entry in range
            //

            //
            // lock the entry and merge the temp and master source lists
            //
            
            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

            MergeTempAndMasterSourceLists( pge );
            

            //
            // Walk the Master source list.
            // For each source in the group
            //

            for ( pleSrcHead = MASTER_SOURCE_LIST_HEAD( pge ), 
                  pleSrc = pleSrcHead-> Flink;
                  pleSrc != pleSrcHead;
                  pleSrc = pleSrc-> Flink )
            {
                pse = CONTAINING_RECORD( pleSrc, SOURCE_ENTRY, leSrcList );
                
                //-----------------------------------------------------------
                // Part 1 : Membership updates.
                //-----------------------------------------------------------

                //
                // If there are any memberships for this group on this
                // interface, move them to the scoped interface list
                //

                bFound = FindOutInterfaceEntry( 
                            &pse-> leOutIfList, pieIfEntry-> dwIfIndex,
                            pieIfEntry-> dwIfNextHopAddr, 
                            pieIfEntry-> dwOwningProtocol, 
                            pieIfEntry-> dwOwningComponent, &bNewComp, &poie
                            );

                if ( bFound )
                {
                    //
                    // Move interface entry from OIF list to scoped list
                    // and invoke deletion alerts are per interop rules.
                    //

                    ScopeIfAndInvokeCallbacks( pge, pse, poie );
                    
                }

                
                //-------------------------------------------------------
                // Part 2 : MFE update.
                //-------------------------------------------------------

                bDeleteCallback = FALSE;
                
                //
                // Check if this source entry has an MFE.
                //

                if ( !IS_VALID_INTERFACE( 
                        pse-> dwInIfIndex,  pse-> dwInIfNextHopAddr 
                        ) )
                {
                    //
                    // This source entry is not an MFE.  No further 
                    // processing required, Move to next source entry
                    //

                    continue;
                }

                
                //
                // This source entry is also an MFE
                //
                
                //
                // check if the boundary being added in on incoming
                // interface. If so create negative MFE, and issue 
                // callbacks
                //

                if ( ( pse-> dwInIfIndex == pieIfEntry-> dwIfIndex ) &&
                     ( pse-> dwInIfNextHopAddr == 
                            pieIfEntry-> dwIfNextHopAddr ) )
                {
                    //
                    // Interface on which this group is to blocked is the 
                    // incoming interface
                    //

                    //
                    // Check if this is already a negative MFE.  If so 
                    // nothing more to be done, move on to next source 
                    // entry
                    //

                    if ( IsListEmpty( &pse-> leMfeIfList ) )
                    {
                        continue;
                    }
                    
                    //
                    // Delete all the outgoing interfaces in the MFE OIF
                    // list
                    //
                    
                    while ( !IsListEmpty( &pse-> leMfeIfList ) )
                    {
                        ple = RemoveHeadList( &pse-> leMfeIfList ) ;

                        poieTemp = CONTAINING_RECORD( 
                                    ple, OUT_IF_ENTRY, leIfList
                                    );

                        MGM_FREE( poieTemp );
                    }

                    pse-> dwMfeIfCount = 0;

                    //
                    // this MFE is now a negative MFE.  Make sure to 
                    // invoke the deletion alert callback for the 
                    // protocol component that owns the incoming 
                    // interface
                    //
                    
                    bDeleteCallback = TRUE;                    
                }

                else
                {
                    //
                    // Check if interface is present in the OIF of MFE.  
                    // If so remove interface from OIF and issue 
                    // callbacks as appropriate
                    //

                    bFound = FindOutInterfaceEntry(
                                &pse-> leMfeIfList, pieIfEntry-> dwIfIndex,
                                pieIfEntry-> dwIfNextHopAddr, 
                                pieIfEntry-> dwOwningProtocol, 
                                pieIfEntry-> dwOwningComponent, &bNewComp, 
                                &poie
                                );

                    if ( !bFound )
                    {
                        //
                        // interface not present in the OIF list of MFE
                        // move on to next entry
                        //

                        continue;
                    }

                    //
                    // Delete the outgoing interface
                    //

                    DeleteOutInterfaceEntry( poie );

                    pse-> dwMfeIfCount--;

                    if ( !pse-> dwMfeIfCount )
                    {
                        //
                        // MFE OIF list has no more outgoing interfaces.
                        // Need to issue deletion alert to protocol component
                        // owning incoming interface
                        //

                        bDeleteCallback = TRUE;
                    }
                }


                //
                // If needed issue deletion alert to the protocol on the 
                // incoming interface
                //

                if ( bDeleteCallback )
                {
                    ppe = GetProtocolEntry( 
                            PROTOCOL_LIST_HEAD(), pse-> dwInProtocolId,
                            pse-> dwInComponentId
                            );

                    if ( ppe == NULL )
                    {
                        //
                        // Protocol owning incoming interface is not present
                        // in incoming list.  Very strange and should not happen.
                        // Nothing to be done here, move on to next source.
                        //
                        
                        TRACE3( 
                            SCOPE, 
                            "Protocol (%d, %d) not present for interface %d",
                            pse-> dwInProtocolId, pse-> dwInComponentId, 
                            dwIfIndex
                            );

                        continue;
                    }


                    if ( IS_PRUNE_ALERT( ppe ) )
                    {
                        PRUNE_ALERT( ppe )(
                            pse-> dwSourceAddr, pse-> dwSourceMask,
                            pge-> dwGroupAddr, pge-> dwGroupMask,
                            pse-> dwInIfIndex, pse-> dwInIfNextHopAddr,
                            FALSE, &dwTimeOut
                            );
                    }
                }


                //
                // Update Kernel Mode forwarder
                //

                AddMfeToForwarder( pge, pse, dwTimeOut );
            }
            
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        } 

        RELEASE_MASTER_GROUP_LOCK_SHARED();

    } while ( FALSE );


    RELEASE_IF_LOCK_SHARED( dwIfBucket);


    //
    // Invoke pended Join/Prune alerts
    //

    InvokeOutstandingCallbacks();


    RELEASE_PROTOCOL_LOCK_SHARED();

    LEAVE_MGM_API();

    TRACE3( 
        SCOPE, "LEAVING MgmBlockGroups (%lx - %lx) on %lx\n",
        dwFirstGroup, dwLastGroup, dwIfIndex
        );

    return NO_ERROR;

}




VOID
ScopeIfAndInvokeCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    POUT_IF_ENTRY       poie
)
/*++

Routine Description :

    This routine remove an interface entry from the outgoing interface
    list for the specified source entry and puts it into the scoped
    interface list.  If the deletion of the interface to the OIF list
    requires deletion alert callbacks to be issued to protocol components
    these are issued by this routine.


Arguements :

    pge - Group entry correspondong to the group being blocked.

    pse - Source entry for the group being blocked

    poie - Interface entry corresponding to the interface over which
           the (source, group) entry is being blocked

Return Value :

    None

Environment :

    Invoked from MgmBlockGroups.  Assumes the protocol list and 
    interface bucket are locked for read, and the group entry is
    locked for write.
    
--*/
{
    BOOL                bFound, bNewComp;
    
    PPROTOCOL_ENTRY     ppe;

    POUT_IF_ENTRY       poieTemp = NULL;

    
    do
    {
        //
        // find the protocol component on the interface specified by poie
        //

        ppe = GetProtocolEntry( 
                PROTOCOL_LIST_HEAD(), poie-> dwProtocolId, 
                poie-> dwComponentId
                );

        if ( ppe == NULL )
        {
            //
            // Outgoing interface entry but corresponding owning
            // protocol is no present. This should not happen.
            // Print a warning indicating bad state and return
            //
            
            TRACE3( 
                SCOPE, "Protocol (%d, %d) not present for interface %d",
                poie-> dwProtocolId, poie-> dwComponentId, 
                poie-> dwIfIndex
                );

            break;
        }

        
        //
        // Remove interface entry from the OIF list
        //

        RemoveEntryList( &poie-> leIfList );


        //
        // Find the locaion in the scoped i/f list and insert it
        //

        bFound = FindOutInterfaceEntry(
                    &pse-> leScopedIfList, poie-> dwIfIndex, 
                    poie-> dwIfNextHopAddr, poie-> dwProtocolId,
                    poie-> dwComponentId, &bNewComp, &poieTemp
                    );

        if ( bFound )
        {
            //
            // Interface being scoped is already present in scoped
            // i/f list.  Strange.  Print warning and quit.
            //

            TRACE4(
                ANY, "Interface (%d, %d) already present in the scoped list"
                " for (%x, %x)", poie-> dwIfIndex, poie-> dwIfNextHopAddr,
                pse-> dwSourceAddr, pge-> dwGroupAddr
                );

            MGM_FREE( poie );

            break;
        }
                    

        InsertTailList( 
            ( poieTemp == NULL ) ? &pse-> leScopedIfList :
                                   &poieTemp-> leIfList,
            &poie-> leIfList
            );


        //
        // If group membership has been added by IGMP and this interface
        // is owned by a  different protocol, inform the protocol that IGMP
        // has just left the interface.  'Hank you, 'hank you very much.
        //

        if ( IS_ADDED_BY_IGMP( poie ) && !IS_PROTOCOL_IGMP( ppe ) )
        {
            if ( IS_LOCAL_LEAVE_ALERT( ppe ) )
            {
                LOCAL_LEAVE_ALERT( ppe )(
                    pse-> dwSourceAddr, pse-> dwSourceMask,
                    pge-> dwGroupAddr, pge-> dwGroupMask,
                    poie-> dwIfIndex, poie-> dwIfNextHopAddr
                    );
            }
        }

        
        //
        // Check if the removal of this interface from the OIF list
        // resulted in decreasing the number of components present 
        // in the OIF list.
        //

        FindOutInterfaceEntry(
            &pse-> leOutIfList, poie-> dwIfIndex, poie-> dwIfNextHopAddr, 
            poie-> dwProtocolId, poie-> dwComponentId, &bNewComp, &poieTemp
            );

        if ( bNewComp )
        {
            pse-> dwOutCompCount--;

            //
            // number of componets in OIF list has decreased.
            // Invoke deletion alerts as per interop rules.
            //
            
            InvokePruneAlertCallbacks( 
                pge, pse, poie-> dwIfIndex, poie-> dwIfNextHopAddr, ppe 
                );
        }
        
    } while ( FALSE );
}





VOID
InvokePruneAlertCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    DWORD               dwIfIndex,
    DWORD               dwIfNextHopAddr,
    PPROTOCOL_ENTRY     ppe
)
/*++

Routine Description :

    This routine invokes deletion alert callbacks of protocol components
    in response to an interface being removed from the OIF list of a 
    source entry. Deletion alert callbacks are issued as per the 
    interop rules.


Arguements :

    pge - Entry corresponding to group for which deletion alert callbacks
          are being issued.

    pse - Entry corresponding to source for which deletion alert callbacks
          are being issued.

    dwIfIndex - Index of interface that is being deleted (or scoped)

    dwIfNextHopAddr - Next hop on interface that is being deleted (or scoped)
    
    ppe - Protocol entry for the protocol component that owns the interface
          corresponding to poie.


Return Value :

    None


Environment :

    Invoked from ScopeIfAndCanInvokeCallbacks and 
    DeleteInterfaceFromSourceEntry
    
--*/
{
    PPROTOCOL_ENTRY ppeEntry;
    
    POUT_IF_ENTRY poieTemp;

    PLIST_ENTRY pleStart, pleProtocol;
    
    
    //----------------------------------------------------------------
    // Callback time
    //----------------------------------------------------------------
    
    //
    // Check if Source specific join
    //

    if ( !IS_WILDCARD_SOURCE( pse-> dwSourceAddr, pse-> dwSourceMask ) )
    {
        if ( pse-> dwOutCompCount == 0 )
        {

            TRACESCOPE0( GROUP, "Last component in OIL for source specific" );

            AddToOutstandingJoinList(
                pse-> dwSourceAddr, pse-> dwSourceMask,
                pge-> dwGroupAddr, pge-> dwGroupMask,
                dwIfIndex, dwIfNextHopAddr, 
                FALSE
                );
        }
    }

    else if ( pse-> dwOutCompCount == 1 )
    {
        TRACESCOPE0( 
            GROUP, "Number of components in the OIL is down to 1" 
            );


        //
        // Number of protocol components that have interfaces in the OIL
        // has reduced from 2 to 1.
        //
        // invoke PRUNE_ALERT to the remaining protocol component
        //

        poieTemp = CONTAINING_RECORD(
                    pse-> leOutIfList.Flink, OUT_IF_ENTRY, leIfList
                    );

        ppeEntry = GetProtocolEntry( 
                    PROTOCOL_LIST_HEAD(), poieTemp-> dwProtocolId,
                    poieTemp-> dwComponentId
                    );

        if ( ppeEntry == NULL )
        {
            TRACE2( 
                ANY, "InvokePruneAlertCallbacks : Could not"
                " find protocol (%x, %x)", poieTemp-> dwProtocolId,
                poieTemp-> dwComponentId
                );
        }

        
        //
        // invoke the delete membership callback for only the remaining
        // interface.
        //

        else if ( IS_PRUNE_ALERT( ppeEntry ) )
        {
            PRUNE_ALERT( ppeEntry ) (
                pse-> dwSourceAddr, pse-> dwSourceMask, 
                pge-> dwGroupAddr, pge-> dwGroupMask,
                dwIfIndex, dwIfNextHopAddr, TRUE, NULL
            );
        }
    }

    else if ( pse-> dwOutCompCount == 0 )
    {
        TRACESCOPE0( 
            GROUP, "Number of components in the OIL is down to 0" 
            );

        //
        // Number of protocol components that have interfaces in the 
        // OIL has reduced from 1 to 0.
        //
        // invoke PRUNE_ALERT to all the other protocol 
        // components
        //

        for ( pleStart = PROTOCOL_LIST_HEAD(), 
              pleProtocol = pleStart-> Flink;
              pleProtocol != pleStart;
              pleProtocol = pleProtocol-> Flink )
        {
            ppeEntry = CONTAINING_RECORD( 
                            pleProtocol, PROTOCOL_ENTRY, leProtocolList
                    );
            
            if ( ( ppeEntry-> dwProtocolId == ppe-> dwProtocolId ) &&
                 ( ppeEntry-> dwComponentId == ppe-> dwComponentId ) )
            {
                continue;
            }

            if ( IS_PRUNE_ALERT( ppeEntry ) )
            {
                PRUNE_ALERT( ppeEntry ) (
                    pse-> dwSourceAddr, pse-> dwSourceMask, 
                    pge-> dwGroupAddr, pge-> dwGroupMask, 
                    dwIfIndex, dwIfNextHopAddr, TRUE, NULL
                    );
            }
        }
    }
}



DWORD
APIENTRY
MgmUnBlockGroups(
    IN          DWORD       dwFirstGroup,
    IN          DWORD       dwLastGroup,
    IN          DWORD       dwIfIndex,
    IN          DWORD       dwIfNextHopAddr
)
/*++

Routine Description :

    This function walks the master group list and updates the memberships
    of each group entry.  If the interface (dwIfIndex) has previously been
    removed from the outgoing list of the group entry (and placed in the
    scoped i/f list) on account of a previous call to MgmBlockGroups 
    it is put back and all the MFEs for the group are
    updated to reflect this addition.
    
    In addition if this interface was the incoming interface for an MFE
    update the timer to expire the MFE in short order (within a second).
    This way we force the recreation of an MFE should there be traffic
    for this group.


Arguements :
    
    dwFirstGroup -  Lower end of the range of groups to be unblocked

    dwLastGroup -   Upper end of the range of groups be be unblocked

    dwIfIndex   -   Interface over which groups have to be unblocked.


Return Value :

    NO_ERROR - Group range successfully unblocked


Environment :

    This function is invoked by the IP RouterManager in response to
    removal of a group boundary.

--*/
{
    BOOL            bNewComp = FALSE, bWCGrpLock = FALSE,
                    bUpdatePass = FALSE;

    WORD            wWCGroupAddedBy = 0, wWCGroupNumAddsByRP = 0,
                    wGroupAddedBy, wGroupNumAddsByRP, wGroupNumAddsByIGMP,
                    wSourceAddedBy, wSourceNumAddsByRP, 
                    wSourceNumAddsByIGMP;
                    
    INT             iCmp;
    
    DWORD           dwIfBucket, dwWCBucket, dwIfProtocol, 
                    dwIfComponent, dwErr;

    PIF_ENTRY       pieIfEntry;

    PGROUP_ENTRY    pgeWC = NULL, pge;

    PSOURCE_ENTRY   pseWC = NULL, pse;

    POUT_IF_ENTRY   poie = NULL;
    

    PLIST_ENTRY     pleGrpHead, pleGrp, pleSrcHead, pleSrc;
    LIST_ENTRY      leForwardList;


    //
    // Ensure that MGM is running and increment count of threads
    // exceuting in MGM
    //

    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE3( 
        SCOPE, "ENTERED MgmUnblockGroups : (%lx - %lx) on %lx",
        dwFirstGroup, dwLastGroup, dwIfIndex
        );


    ACQUIRE_PROTOCOL_LOCK_SHARED ();

    InitializeListHead( &leForwardList );

    do
    {
        //
        // Pass I : aka Scan pass (bupdatePass == FALSE)
        //  Scan and Collect all MFEs for which CREATION_ALERTS need to
        //  invoked before updating the MFEs.  Invoke the CREATION_ALERTS
        //  outside of any locks (which is why we need two passes).
        //
        // Pass II : Update pass (bupdatePass == TRUE)
        //  Update memberships and MFEs
        //

        //
        // Verify dwIfIndex is a valid interface with MGM
        //

        dwIfBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

        pieIfEntry = GetIfEntry( 
                        IF_BUCKET_HEAD( dwIfBucket ), dwIfIndex, 
                        dwIfNextHopAddr
                        );

        if ( pieIfEntry == NULL )
        {
            TRACE2( 
                SCOPE, "Interface (%lx-%lx) not found", dwIfIndex,
                dwIfNextHopAddr
                );

            RELEASE_IF_LOCK_SHARED( dwIfBucket );

            break;
        }


        if ( bUpdatePass )
        {
            //
            // Verify the interface is still owned by the same protocol
            // as when you made the scan pass.
            // If not the protocol on the interface (on the scan pass)
            // has released the interface and there is no update to be done.
            // 

            if ( ( pieIfEntry-> dwOwningProtocol != dwIfProtocol ) ||
                 ( pieIfEntry-> dwOwningComponent != dwIfComponent ) )
            {
                TRACE2( 
                    SCOPE, "Ne protocol on interface (%lx-%lx)", dwIfIndex,
                    dwIfNextHopAddr
                    );

                RELEASE_IF_LOCK_SHARED( dwIfBucket );

                break;
            }
        }

        else
        {
            //
            // On the scan pass, store the protocol on the interface.
            // We need to verify that the protocol remains the same
            // between the scan and update passes.
            //

            dwIfProtocol    = pieIfEntry-> dwOwningProtocol;

            dwIfComponent   = pieIfEntry-> dwOwningComponent;
        }

        
        //
        // Merge temp and master group lists
        //

        ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE();

        MergeTempAndMasterGroupLists( TEMP_GROUP_LIST_HEAD() );

        RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE();

        
        //
        // Lock the master group list for reading
        //

        ACQUIRE_MASTER_GROUP_LOCK_SHARED( );

        //
        // Check if wild card recevier (*, *) for this interface.  If it is
        // note this. i.e. mark as added by protocol and numaddsbyRp = 1.
        // 
        // N.B.  
        //  You are scanning the master group list for the 
        //  WILDCARD_GROUP.  This is not as expensive as it seems since the
        //  WC entry if present would right at the beginning of the master
        //  list.
        //

        if ( FindGroupEntry( 
                MASTER_GROUP_LIST_HEAD(), WILDCARD_GROUP,
                WILDCARD_GROUP_MASK, &pgeWC, FALSE
                ) )
        {
            //
            // Lock this group entry to prevent changes to its OIF list
            // while unblokcing is in progress
            //
            
            ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
            bWCGrpLock = TRUE;
            
            dwWCBucket = SOURCE_TABLE_HASH( 
                            WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                            );

            if ( FindSourceEntry(
                    SOURCE_BUCKET_HEAD( pgeWC, dwWCBucket ),
                    WILDCARD_SOURCE, WILDCARD_SOURCE_MASK, &pseWC, TRUE
                    ) )
            {
                //
                // (*, *) entry present, check if dwIfIndex is present in its
                // OIF list
                //

                if ( FindOutInterfaceEntry( 
                        &pseWC-> leOutIfList, pieIfEntry-> dwIfIndex, 
                        pieIfEntry-> dwIfNextHopAddr, 
                        pieIfEntry->dwOwningProtocol,
                        pieIfEntry-> dwOwningComponent, &bNewComp, &poie 
                        ) )
                {
                    //
                    // This interface is a wildcard receiver.  Note this as 
                    // added by routing protocol since IGMP would never be 
                    // a (*, *) receiver
                    //

                    wWCGroupAddedBy     = poie-> wAddedByFlag;
                    wWCGroupNumAddsByRP = poie-> wNumAddsByRP;
                }
            }
        }


        for ( pleGrpHead = MASTER_GROUP_LIST_HEAD(), 
              pleGrp = pleGrpHead-> Flink;
              pleGrp != pleGrpHead;
              pleGrp = pleGrp-> Flink )
        {
            //
            // For each group in the master list
            //
            
            pge = CONTAINING_RECORD( pleGrp, GROUP_ENTRY, leGrpList );

            //
            // Skip the (*, *) entry. i.e. Skip the wildcard group.
            // This group entry has already been examined above (just
            // before the for loop).  There is no need to look at this
            // entry as the ref. counts for this entry have been collected
            // above.  In addition the "group entry lock" for this entry
            // has been acquired above and attempting to reacquire it will
            // lead to DEAD-LOCK.  This presents only a minor inconvience
            // in this "for" loop i.e. having to check and skip this entry.
            //

            if ( IS_WILDCARD_GROUP( pge-> dwGroupAddr, pge-> dwGroupMask ) )
            {
                continue;
            }

            
            //
            // check is in range specified
            //
            
            if ( INET_CMP( pge-> dwGroupAddr, dwLastGroup, iCmp ) > 0 )
            {
                //
                // The master group list is ordered by group number and 
                // the high end of the range has been crossed.  Quit
                //

                break;
            }

            if ( INET_CMP( pge-> dwGroupAddr, dwFirstGroup, iCmp ) < 0 )
            {
                //
                // Skip groups entries smaller than the lower end of the 
                // range
                //

                continue;
            }


            //
            // Group entry in range specified
            //

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );


            //
            // This group entry inherits the counts from the wildcard 
            // group entry
            //

            wGroupAddedBy       = wWCGroupAddedBy;
            wGroupNumAddsByRP   = wWCGroupNumAddsByRP;
            wGroupNumAddsByIGMP = 0;

            
            //
            // Check if there are group memberships for the wildcard source
            // that have been scoped.  Update interface counts appropriately
            //

            dwWCBucket = SOURCE_TABLE_HASH( 
                            WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                            );

            if ( FindSourceEntry( 
                    SOURCE_BUCKET_HEAD( pge, dwWCBucket ), WILDCARD_SOURCE,
                    WILDCARD_SOURCE_MASK, &pseWC, TRUE
                    ) )
            {
                //
                // Wild card source present.  Check if this interface
                // is present in its scoped i/f list
                //

                if ( FindOutInterfaceEntry( 
                        &pseWC-> leScopedIfList, pieIfEntry-> dwIfIndex,
                        pieIfEntry-> dwIfNextHopAddr, 
                        pieIfEntry-> dwOwningProtocol,
                        pieIfEntry-> dwOwningComponent,
                        &bNewComp, &poie
                        ) )
                {
                    //
                    // Wildcard member ship present present on the interface.
                    // Note it by updating counts
                    //

                    wGroupAddedBy       |= poie-> wAddedByFlag;
                        
                    wGroupNumAddsByRP   += poie-> wNumAddsByRP;
                        
                    wGroupNumAddsByIGMP  = poie-> wNumAddsByIGMP;
                }
            }


            //
            // Merge the temp and master source lists, before walking
            // the source list
            //

            MergeTempAndMasterSourceLists( pge );


            //
            // for each source entry
            //

            pleSrcHead = MASTER_SOURCE_LIST_HEAD( pge );

            for ( pleSrc = pleSrcHead-> Flink; 
                  pleSrc != pleSrcHead; 
                  pleSrc = pleSrc-> Flink )
            {
                pse = CONTAINING_RECORD( pleSrc, SOURCE_ENTRY, leSrcList );

                //
                // each source entry inherits the aggregated counts of
                // the wildcard group (*, *) and the wildcard source (*, G)
                // entry
                //
                
                wSourceAddedBy       = wGroupAddedBy;
                wSourceNumAddsByRP   = wGroupNumAddsByRP;
                wSourceNumAddsByIGMP = wGroupNumAddsByIGMP;


                //
                // Check if interface being unblocked is present in
                // the scoped i/f list for this source
                //

                if ( FindOutInterfaceEntry(
                        &pse-> leScopedIfList, pieIfEntry-> dwIfIndex,
                        pieIfEntry-> dwIfNextHopAddr,
                        pieIfEntry-> dwOwningProtocol,
                        pieIfEntry-> dwOwningComponent, &bNewComp, &poie
                        ) )
                {
                    //
                    // If this is not the wildcard source entry, presence
                    // of this interface in the scoped i/f list indicates
                    // that a source specific join for this group was
                    // performed.  Note the counts for this interface for
                    // the source specific join
                    //

                    if ( !IS_WILDCARD_SOURCE( 
                            pse-> dwSourceAddr, pse-> dwSourceMask 
                            ) )
                    {
                        wSourceAddedBy          |= poie-> wAddedByFlag;
                            
                        wSourceNumAddsByRP      += poie-> wNumAddsByRP;
                            
                        wSourceNumAddsByIGMP    += poie-> wNumAddsByIGMP;
                    }

                    
                    //
                    // The function name says it.
                    //

                    if ( bUpdatePass )
                    {
                        UnScopeIfAndInvokeCallbacks( pge, pse, poie );
                    }
                }


                //-----------------------------------------------------------
                // Part 2 : MFE Update
                //-----------------------------------------------------------

                if ( IS_VALID_INTERFACE( 
                        pse-> dwInIfIndex, pse-> dwInIfNextHopAddr
                        ) )
                {
                    //
                    // This is an MFE
                    //

                    //
                    // Check if the interface being unblocked is the
                    // incoming interface for this MFE
                    //

                    if ( ( pse-> dwInIfIndex == pieIfEntry-> dwIfIndex ) &&
                         ( pse-> dwInIfNextHopAddr == 
                                pieIfEntry-> dwIfNextHopAddr ) )
                    {
                        //
                        // The incoming interface is being unblocked.
                        // That implies this MFE is currently a negative.
                        // The easiest way to re-create the correct MFE
                        // is to delete the MFE and force its re-creation
                        // when the next packet arrives from the same
                        // (source, group).  The simplest way to delete
                        // the MFE and references to it in the interface
                        // table is to update the expiry time (set
                        // arbitrarily to 2 seconds here) and let the
                        // deletion happen via the MFETimerProc (timer.c)
                        //

                        if ( bUpdatePass )
                        {
                            RtlUpdateTimer( 
                                TIMER_QUEUE_HANDLE( 
                                    TIMER_TABLE_HASH( pge-> dwGroupAddr )
                                    ),
                                pse-> hTimer, 2000, 0 
                                );
                        }
                    }


                    //
                    // ELSE clause comment
                    //
                    // Interface being unblocked is not the incoming
                    // interface.  It could be an outgoing interface 
                    // for this MFE.  Check if any component is 
                    // interested in traffic for this (S, G).  To do
                    // this check the added by flag and if it is
                    // non-zero the interface should be added to the
                    // MFE OIF list.
                    //
                    // In addition, make sure that the incoming interface
                    // does not have a (scope) boundary on it.  In that 
                    // case, there is no MFE OIF list changes required.
                    //

                    else if (  wSourceAddedBy                       &&
                              ( !( IS_HAS_BOUNDARY_CALLBACK() ) ||
                                ( IS_HAS_BOUNDARY_CALLBACK()  &&
                                  !HAS_BOUNDARY_CALLBACK()( 
                                    dwIfIndex, pge-> dwGroupAddr
                                    ) ) ) )
                    {
                        if ( bUpdatePass && 
                             IsForwardingEnabled( 
                                pge-> dwGroupAddr, pge-> dwGroupMask,
                                pse-> dwSourceAddr, pse-> dwSourceMask,
                                &leForwardList
                                ) )
                        {
                            poie = NULL;
                            
                            AddInterfaceToSourceMfe(
                                pge, pse, pieIfEntry-> dwIfIndex,
                                pieIfEntry-> dwIfNextHopAddr,
                                pieIfEntry-> dwOwningProtocol,
                                pieIfEntry-> dwOwningComponent, FALSE, &poie
                                );

                            //
                            // Update counts for the OIF in the MFE list
                            //

                            if ( poie != NULL )
                            {
                                poie-> wAddedByFlag     = wSourceAddedBy;
                                poie-> wNumAddsByRP     = wSourceNumAddsByRP;
                                poie-> wNumAddsByIGMP   = wSourceNumAddsByIGMP;
                            }
                        }

                        else if ( !bUpdatePass )
                        {
                            AddToCheckForCreationAlertList(
                                pge-> dwGroupAddr, pge-> dwGroupMask,
                                pse-> dwSourceAddr, pse->dwSourceMask,
                                pse-> dwInIfIndex, pse-> dwInIfNextHopAddr,
                                &leForwardList
                                );
                        }
                    }
                }
            }
            
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }

        //
        // if lock on the Wildcard group entry is held, release it
        //
        
        if ( bWCGrpLock )
        {
            RELEASE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
        }

        RELEASE_MASTER_GROUP_LOCK_SHARED( );

        RELEASE_IF_LOCK_SHARED( dwIfBucket );

        if ( !bUpdatePass )
        {
            dwErr = InvokeCreationAlertForList( 
                        &leForwardList, dwIfProtocol, dwIfComponent,
                        dwIfIndex, dwIfNextHopAddr
                    );
                
            if ( dwErr != NO_ERROR )
            {
                break;
            }
            
            bUpdatePass = TRUE;
        }
        else
        {
            break;
        }
        
    } while ( TRUE );


    //
    // Release all locks and decrement thread-counts etc.
    //
    
    //
    // Invoke pended Join/Prune alerts
    //

    InvokeOutstandingCallbacks();

    
    RELEASE_PROTOCOL_LOCK_SHARED();

    FreeList( &leForwardList );
    
    LEAVE_MGM_API();

    TRACE0( SCOPE, "LEAVING MgmUnblockGroups" );

    return NO_ERROR;
}





VOID
UnScopeIfAndInvokeCallbacks(
    PGROUP_ENTRY    pge,
    PSOURCE_ENTRY   pse,
    POUT_IF_ENTRY   poie
)
/*++

Routine Description :

    This routine remove an interface entry from the scoped interface
    list for the specified source entry and puts it into the outgoing
    interface list.  If the addition of the interface to the OIF list
    requires new member callbacks to be issued to protocol components
    these are issued by this routine.


Arguements :

    pge - Group entry correspondong to the group being unblocked.

    pse - Source entry for the group being unblocked

    poie - Interface entry corresponding to the interface over which
           the (source, group) entry is being unblocked

Return Value :

    None

Environment :

    Invoked from MgmUnBlockGroups.  Assumes the protocol list and 
    interface bucket are locked for read, and the group entry is
    locked for write.
    
--*/
{
    BOOL            bFound, bNewComp = FALSE;
    
    PPROTOCOL_ENTRY ppe;
    
    POUT_IF_ENTRY   poieNext = NULL;

    
    do
    {
        //
        // Remove interface entry from the scoped I/f list
        //

        RemoveEntryList( &poie-> leIfList );


        //
        // Find its place in the OIF list for the source entry
        // and insert it in
        //

        bFound = FindOutInterfaceEntry(
                    &pse-> leOutIfList, poie-> dwIfIndex, 
                    poie-> dwIfNextHopAddr, poie-> dwProtocolId, 
                    poie-> dwComponentId, &bNewComp, &poieNext
                    );
            
        if ( bFound )
        {
            //
            // Trouble.  The interface to be inserted should not be
            // present in the OIF list for the source entry.  Since it
            // print a warning message and move on.
            //

            TRACE4( 
                ANY, "Interface (%d-%d) present in OIF list of (%x-%x)"
                " inspite of being scoped", poie-> dwIfIndex, 
                poie-> dwIfNextHopAddr, pse-> dwSourceAddr, pge-> dwGroupAddr
                );

            MGM_FREE( poie );

            break;

        }

        InsertTailList( 
            ( poieNext == NULL ) ?  &pse-> leOutIfList : 
                                    &poieNext-> leIfList,
            &poie-> leIfList
            );


        //
        // if new component, update component count and
        // call callback invoker
        //

        if ( bNewComp )
        {
            pse-> dwOutCompCount++;

            ppe = GetProtocolEntry( 
                    PROTOCOL_LIST_HEAD(), poie-> dwProtocolId, 
                    poie-> dwComponentId
                    );

            if ( ppe == NULL )
            {
                //
                // Trouble.  Interface present without any owning 
                // protocol component.
                //

                TRACE4( 
                    ANY, "Owning protocol(%d, %) for interface(%d, %d)"
                    " not found", poie-> dwProtocolId, poie-> dwComponentId,
                    poie-> dwIfIndex, poie-> dwIfNextHopAddr
                    );

                return;
            }

            InvokeJoinAlertCallbacks( 
                pge, pse, poie, IS_ADDED_BY_IGMP( poie ), ppe
                );
        }

    } while ( FALSE );
}



VOID
InvokeJoinAlertCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    POUT_IF_ENTRY       poie,
    BOOL                bIGMP,
    PPROTOCOL_ENTRY     ppe
)
/*++

Routine Description :

    This routine invokes New Member callbacks in response to a new
    protocol component being added to the outgoing interface list
    of a source entry.  New member callbacks are issued according
    to interop rules.

Argumements :

    pge - Entry corresponding to group for which new member callbacks
          are being issued.

    pse - Entry corresponding to source for which new member callbacks
          are being issued.

    poie - Entry corresponding to interface whose addition triggered the 
           callback mechanism.

    bIGMP - Indicates if IGMP is adding this interface.

    ppe - Protocol entry for the protocol component that owns the interface
          corresponding to poie.
          
Return Value :

    None


Environment :

    Invoked from AddInterfaceToSourceEntry and UnScopeIfAndInvokeCallbacks
    
--*/
{
    PPROTOCOL_ENTRY     ppeEntry;

    POUT_IF_ENTRY       poiePrev;
    
    PLIST_ENTRY         ple, pleStart;

    

    //
    // Check if Source specific join
    //

    if ( !IS_WILDCARD_SOURCE( pse-> dwSourceAddr, pse-> dwSourceMask ) )
    {
        if ( pse-> dwOutCompCount == 1 )
        {

            TRACESCOPE0( GROUP, "First component in OIL for source specific" );

            AddToOutstandingJoinList(
                pse-> dwSourceAddr, pse-> dwSourceMask,
                pge-> dwGroupAddr, pge-> dwGroupMask,
                poie-> dwIfIndex, poie-> dwIfNextHopAddr, 
                TRUE
                );
        }
    }

    
    else if ( pse-> dwOutCompCount == 1 )
    {
        TRACESCOPE0( GROUP, "First component in OIL" );

        //
        // Interaction between routing protocols.
        //
        
        //
        // first component in the OIL.
        //
        // Send new member callback to all the other (than the
        // the one adding this group membership on
        // this interface) routing protocol components
        //
        // At this point you have a read lock on the protocol list
        // so you can walk the list
        //

        pleStart = PROTOCOL_LIST_HEAD();
        
        for ( ple = pleStart-> Flink; ple != pleStart; ple = ple-> Flink )
        {
            ppeEntry = CONTAINING_RECORD( 
                        ple, PROTOCOL_ENTRY, leProtocolList 
                        );

            //
            // all OTHER protocol components need to be told of the 
            // interface addition. So skip the component adding 
            // this interface.
            //
            
            if ( ( ppeEntry-> dwProtocolId == ppe-> dwProtocolId ) &&
                 ( ppeEntry-> dwComponentId == ppe-> dwComponentId ) )
            {
                continue;
            }


            //
            // if routing protocol has requested new member callback
            //
            
            if ( IS_JOIN_ALERT( ppeEntry ) )
            {
                JOIN_ALERT( ppeEntry )(
                    pse-> dwSourceAddr, pse-> dwSourceMask,
                    pge-> dwGroupAddr, pge-> dwGroupMask, TRUE
                );
            }
        }
    }


    //
    // if second component to add an interface to the OIL
    // invoke new member callback to first component.
    // 
    // Note :
    //  If the first component that added a group membership
    //  was IGMP skip JOIN_ALERT callback.
    //

    else if ( pse-> dwOutCompCount == 2 )
    {
        TRACESCOPE0( GROUP, "Second component in OIL" );
        
        //
        // find the "other (first)" routing protocol component to add 
        // an interface to the OIL
        //

        for ( ple = pse-> leOutIfList.Flink;
              ple != &pse-> leOutIfList;
              ple = ple-> Flink )
        {
            poiePrev = CONTAINING_RECORD( 
                        ple, OUT_IF_ENTRY, leIfList 
                        );

            //
            // if the protocol component that added this interface to 
            // the OIL is different indicating that it is the other 
            // component invoke its new member interface
            // 

            if ( ( poiePrev-> dwProtocolId != ppe-> dwProtocolId ) ||
                 ( poiePrev-> dwComponentId != ppe-> dwComponentId ) )
            {

                //
                // Find the protocol entry for the other interface
                //

                ppeEntry = GetProtocolEntry( 
                            &ig.mllProtocolList.leHead,
                            poiePrev-> dwProtocolId,
                            poiePrev-> dwComponentId
                            );

                if ( ppeEntry == NULL )
                {
                    TRACE2( 
                        ANY, "InvokeJoinAlertCallbacks : Could not"
                        "find protocol %x, %x", poie-> dwProtocolId,
                        poie-> dwComponentId
                    );
                }

                else if ( IS_ROUTING_PROTOCOL( ppeEntry ) &&
                          IS_JOIN_ALERT( ppeEntry ) )
                {
                    //
                    // JOIN_ALERT callback will be skipped if
                    // the first component is IGMP
                    //
                    
                    JOIN_ALERT( ppeEntry )(
                        pse-> dwSourceAddr, pse-> dwSourceMask, 
                        pge-> dwGroupAddr, pge-> dwGroupMask, TRUE
                        );
                }

                break;
            }
        }
    }


    //
    // if this group membership was added by IGMP, and
    // a routing protocol co-exists with IGMP on this interface
    // inform the routing protocol too.
    //

    if ( bIGMP && IS_ROUTING_PROTOCOL( ppe ) )
    {
        if ( IS_LOCAL_JOIN_ALERT( ppe ) )
        {
            LOCAL_JOIN_ALERT( ppe )(
                pse-> dwSourceAddr, pse-> dwSourceMask, 
                pge-> dwGroupAddr, pge-> dwGroupMask,
                poie-> dwIfIndex, poie-> dwIfNextHopAddr
                );
        }
    }
}




DWORD
AddToOutstandingJoinList(
    DWORD       dwSourceAddr,
    DWORD       dwSourceMask,
    DWORD       dwGroupAddr,
    DWORD       dwGroupMask,
    DWORD       dwIfIndex,
    DWORD       dwIfNextHopAddr,
    BOOL        bJoin
)
/*++

Routine Description :

    This routine adds a Join entry to the global outstanding join list.
    Each entry in this list represents a "source specific" join/leave for
    which the corresponding join/prune alerts have not yet been issued.
    The reason for deferring the callbacks has to do with the order of
    locking of buckets in the IF HASH table.  When a membership is 
    added/deleted a lock is taken on the interface bucket that contains
    the interface on which the membership is being changed.  When the
    source entry for which the membership is being changed has been
    updated you determine (as per interop rules) whether 
    a join/prune needs to be issued to the protocol on the incoming 
    interface.  If it must you need to look up the incoming interface
    and then find the protocol on that interface and invoke its callbacks.
    To do this you need to look up the incoming interface in the 
    IF hash table and locking the bucket for that IF entry.  You lock two
    buckets simultaneously.  Hence the deferral
    

Arguements :

    dwSourceAddr - Source address for which a join/leave has occured

    dwSourceMask - Mask corresponding to dwSourceAddr

    dwGroupAddr - Group for which a join/leave has occured

    dwGroupMask - Mask corresponding to dwGroupAddr

    dwIfIndex   - Incoming interface index as per the MCAST RIB

    dwIfNextHopAddr - Next hop address corresponding to dwIfIndex

    bJoin - Indicates if an outstanding entry is being added because of a
            join or leave


Return Value :

    NO_ERROR - Success

    ERROR_NOT_ENOUGH_MEMORY - failed to allocate a join entry


Environment :

    Invoked in the context of Invoke[PruneAlert/JoinAlert]Callbacks
    
--*/
{
    BOOL            bFound;
    
    DWORD           dwErr = NO_ERROR;

    PJOIN_ENTRY     pje = NULL, pjeNew;

    
    ACQUIRE_JOIN_LIST_LOCK_EXCLUSIVE();
    
    do
    {
        bFound = FindJoinEntry(
                    JOIN_LIST_HEAD(), dwSourceAddr, dwSourceMask,
                    dwGroupAddr, dwGroupMask, dwIfIndex, dwIfNextHopAddr,
                    &pje
                    );

        if ( bFound )
        {
            //
            // Join entry already exists for this interface.
            // Check if it is of the same type 
            //

            if ( pje-> bJoin != bJoin )
            {
                //
                // Join entries of different types, null each other
                // remove this join entry
                //

                RemoveEntryList( &pje-> leJoinList );

                MGM_FREE( pje );
            }
        }

        else
        {
            //
            // Join entry does not exist.  Create one and insert it.
            //

            pjeNew = MGM_ALLOC( sizeof( JOIN_ENTRY ) );

            if ( pjeNew == NULL )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                TRACE1( ANY, "Failed to create Join Entry : %x", dwErr );

                break;
            }

            InitializeListHead( &pjeNew-> leJoinList );

            pjeNew-> dwSourceAddr      = dwSourceAddr;

            pjeNew-> dwSourceMask      = dwSourceMask;

            pjeNew-> dwGroupAddr       = dwGroupAddr;

            pjeNew-> dwGroupMask       = dwGroupMask;

            pjeNew-> dwIfIndex         = dwIfIndex;

            pjeNew-> dwIfNextHopAddr   = dwIfNextHopAddr;

            pjeNew-> bJoin             = bJoin;

            InsertTailList( 
                ( pje == NULL ) ? JOIN_LIST_HEAD() : &pje-> leJoinList,
                &pjeNew-> leJoinList
                );
        }
        
    } while ( FALSE );

    RELEASE_JOIN_LIST_LOCK_EXCLUSIVE();

    return dwErr;
}




PJOIN_ENTRY
GetNextJoinEntry(
)
/*++

Routine Description :

    This function removes the first outstanding join entry and returns it


Arguements :


Return Values :

    NULL -  if outstanding join list is empty

    pointer to a join entry otherwise


Environment :

    Invoked from InvokeOutstandingCallbacks
    
--*/
{
    PLIST_ENTRY     ple;

    PJOIN_ENTRY     pje = NULL;

    
    ACQUIRE_JOIN_LIST_LOCK_EXCLUSIVE();

    if ( !IsListEmpty( JOIN_LIST_HEAD() ) )
    {
        ple = RemoveHeadList( JOIN_LIST_HEAD() );

        pje = CONTAINING_RECORD( ple, JOIN_ENTRY, leJoinList );
    }

    RELEASE_JOIN_LIST_LOCK_EXCLUSIVE();

    return pje;
}




BOOL
FindJoinEntry(
    PLIST_ENTRY     pleJoinList,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr,
    PJOIN_ENTRY *   ppje
)
/*++

Routine Description :

    This routine finds a specified join entry in the outstanding join list.


Arguements :
    pleJoinList - Join list to be searched

    dwSourceAddr - Source address for which a join/leave has occured

    dwSourceMask - Mask corresponding to dwSourceAddr

    dwGroupAddr - Group for which a join/leave has occured

    dwGroupMask - Mask corresponding to dwGroupAddr

    dwIfIndex   - Incoming interface index as per the MCAST RIB

    dwIfNextHopAddr - Next hop address corresponding to dwIfIndex

    ppje - a pointer to join entry if found or 
           a pointer to the next element in the join list if it exists or
           NULL

           
Return Values :

    TRUE - Join entry found

    FALSE - Join entry not found


Environment :

    Invoked from AddToOutstandingJoinList
--*/
{
    INT             iCmp;
    
    PLIST_ENTRY     ple = NULL;

    PJOIN_ENTRY     pje = NULL;

    BOOL            bFound = FALSE;
    


    *ppje = NULL;
    

    for ( ple = pleJoinList-> Flink; ple != pleJoinList; ple = ple-> Flink )
    {
        pje = CONTAINING_RECORD( ple, JOIN_ENTRY, leJoinList );

        if ( INET_CMP( pje-> dwGroupAddr, dwGroupAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            *ppje = pje;
            break;
        }
        

        if ( INET_CMP( pje-> dwSourceAddr, dwSourceAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //
            
            *ppje = pje;
            break;
        }

        
        if ( pje-> dwIfIndex < dwIfIndex )
        {
            continue;
        }

        else if ( pje-> dwIfIndex > dwIfIndex )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //
            
            *ppje = pje;
            break;
        }
        

        if ( INET_CMP( pje-> dwIfNextHopAddr, dwIfNextHopAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            *ppje = pje;
            break;
        }

        
        //
        // entry found
        //

        *ppje = pje;

        bFound = TRUE;
        
        break;
    }

    return bFound;
}




VOID
InvokeOutstandingCallbacks(
)
/*++

Routine Description :

    This routine walks the global outstanding join list, and for each entry
    finds the incoming interface and the protocol on it and invokes the
    appropriate callback (JoinAlert/PruneAlert).
    

Arguements :

           
Return Values :


Environment :

    Whenever a source specific join or leave occurs or when scoped boundaries
    change.
--*/
{
    BOOL            bFound;
    
    DWORD           dwIfBucket;
    
    PJOIN_ENTRY     pje;

    PIF_ENTRY       pie;

    PPROTOCOL_ENTRY ppe;
    
    DWORD           dwErr;
    
    RTM_NET_ADDRESS rnaAddr;

    RTM_DEST_INFO   rdiDest;

    RTM_NEXTHOP_INFO rniNextHop;

    BOOL            bRelDest, bRelNextHop, bRelIfLock;

    HANDLE          hNextHop;


    //
    // While there are join entries
    //  - Get the next join entry
    //  - Look source and find incoming interface
    //  - Find the interface entry and get the protocol on that i/f
    //  - invoke its callback
    //

    while ( ( pje = GetNextJoinEntry() ) != NULL )
    {
        bRelDest = bRelNextHop = bRelIfLock = FALSE;
        
        do
        {
            //
            // Get route to source
            //
            
            RTM_IPV4_MAKE_NET_ADDRESS( 
                &rnaAddr, pje-> dwSourceAddr, IPv4_ADDR_LEN 
                );

            dwErr = RtmGetMostSpecificDestination(
                        g_hRtmHandle, &rnaAddr, RTM_BEST_PROTOCOL, 
                        RTM_VIEW_MASK_MCAST, &rdiDest
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( 
                    ANY, "InvokeOutstandingCallbacks : Failed to lookup "
                    "route : %x", dwErr
                    );

                break;
            }

            bRelDest = TRUE;


            //
            // Select next hop info
            //

            hNextHop = SelectNextHop( &rdiDest );

            if ( hNextHop == NULL )
            {
                TRACE1(
                    ANY, "InvokeOutstandingCallbacks : Failed to select "
                    "next hop : %x", dwErr
                    );

                break;
            }


            //
            // Get nexthop info
            //

            dwErr = RtmGetNextHopInfo(
                        g_hRtmHandle, hNextHop, &rniNextHop
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( 
                    ANY, "InvokeOutstandingCallbacks : Failed to get "
                    "next hop info : %x", dwErr
                    );

                break;
            }

            bRelNextHop = TRUE;


            //
            // Find the incming interface entry
            //
            
            dwIfBucket = IF_TABLE_HASH( rniNextHop.InterfaceIndex );

            ACQUIRE_IF_LOCK_SHARED( dwIfBucket );
            bRelIfLock = TRUE;
            
            bFound = FindIfEntry( 
                        IF_BUCKET_HEAD( dwIfBucket ), rniNextHop.InterfaceIndex,
                        0, &pie
                        );

            if ( ( pie == NULL )            ||
                 ( !bFound          && 
                   pie-> dwIfIndex != rniNextHop.InterfaceIndex ) )
            {
                //
                // No interface with the specified ID exists. 
                // Nothing to be done
                //

                break;
            }


            //
            // Check if the interface on which JOIN/PRUNE occured is
            // the same as the incoming interface.
            //
            // If so skip it.
            //

            if ( ( pje-> dwIfIndex == pie-> dwIfIndex ) &&
                 ( pje-> dwIfNextHopAddr == pie-> dwIfNextHopAddr ) )
            {
                //
                // No join/prune required
                //

                TRACEGROUP2(
                    GROUP, "No callback as incoming if == joined/pruned "
                    "if 0x%x 0x%x",
                    pje-> dwIfIndex, pje-> dwIfNextHopAddr
                    );

                break;
            }

            
            ppe = GetProtocolEntry(
                    PROTOCOL_LIST_HEAD(), pie-> dwOwningProtocol,
                    pie-> dwOwningComponent
                    );
                    
            if ( ppe == NULL )
            {
                //
                // No protocol present for interface entry.  Strange
                //
                
                break;
            }


            if ( pje-> bJoin )
            {
                if ( IS_JOIN_ALERT( ppe ) )
                {
                    JOIN_ALERT( ppe )(
                        pje-> dwSourceAddr, pje-> dwSourceMask, 
                        pje-> dwGroupAddr, pje-> dwGroupMask,
                        TRUE
                        );
                }
            }

            else
            {
                if ( IS_PRUNE_ALERT( ppe ) )
                {
                    PRUNE_ALERT( ppe )(
                        pje-> dwSourceAddr, pje-> dwSourceMask, 
                        pje-> dwGroupAddr, pje-> dwGroupMask,
                        pje-> dwIfIndex, pje-> dwIfNextHopAddr, 
                        TRUE, NULL
                        );
                }
            }

        } while ( FALSE );

        MGM_FREE( pje );

        if ( bRelIfLock )
        {
            RELEASE_IF_LOCK_SHARED( dwIfBucket );
        }

        if ( bRelDest )
        {
            dwErr = RtmReleaseDestInfo( g_hRtmHandle, &rdiDest );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to release dest info : %x", dwErr );
            }
        }

        if ( bRelNextHop )
        {
            dwErr = RtmReleaseNextHopInfo( g_hRtmHandle, &rniNextHop );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to release dest info : %x", dwErr );
            }
        }
    }
}



VOID
AddToCheckForCreationAlertList(
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    PLIST_ENTRY     pleForwardList
)
/*++

Routine Description :


Arguements :

           
Return Values :


Environment :

--*/
{
    PJOIN_ENTRY     pje;

    
    //
    // Create an entry in the forward list
    //

    pje = MGM_ALLOC( sizeof( JOIN_ENTRY ) );

    if ( pje == NULL )
    {
        TRACE0( ANY, "Failed to allocate forward list entry" );

        return;
    }

    InitializeListHead( &pje-> leJoinList );

    pje-> dwSourceAddr      = dwSourceAddr;

    pje-> dwSourceMask      = dwSourceMask;
    
    pje-> dwGroupAddr       = dwGroupAddr;
    
    pje-> dwGroupMask       = dwGroupMask;

    pje-> dwIfIndex         = dwInIfIndex;

    pje-> dwIfNextHopAddr   = dwInIfNextHopAddr;

    pje-> bJoin             = TRUE;


    //
    // Insert at the end of the list
    //
    
    InsertTailList( pleForwardList, &pje-> leJoinList );

    return;
}



BOOL
IsForwardingEnabled(
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    PLIST_ENTRY     pleForwardList
)
/*++
--*/
{
    PLIST_ENTRY     ple, pleTemp;

    PJOIN_ENTRY     pje;

    BOOL            bEnable = FALSE;

    INT             iCmp;


    
    //
    // find the source group entry and 
    // check if forwarding is enabled for it
    //

    ple = pleForwardList-> Flink; 

    while ( ple != pleForwardList )
    {
        pje = CONTAINING_RECORD( ple, JOIN_ENTRY, leJoinList );

        if ( INET_CMP( pje-> dwGroupAddr, dwGroupAddr, iCmp ) < 0 )
        {
            pleTemp = ple-> Flink;

            RemoveEntryList( ple );

            MGM_FREE( pje );

            ple = pleTemp;
            
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            break;
        }
        

        if ( INET_CMP( pje-> dwSourceAddr, dwSourceAddr, iCmp ) < 0 )
        {
            pleTemp = ple-> Flink;

            RemoveEntryList( ple );

            MGM_FREE( pje );

            ple = pleTemp;
            
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            break;
        }


        //
        // found source-group entry
        //

        bEnable = pje-> bJoin;

        RemoveEntryList( ple );

        MGM_FREE( pje );

        break;
    }

    return bEnable;
}




DWORD
InvokeCreationAlertForList( 
    PLIST_ENTRY     pleForwardList,
    DWORD           dwProtocolId,
    DWORD           dwComponentId,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr
)
{
    PPROTOCOL_ENTRY ppe;

    PLIST_ENTRY     ple;

    PJOIN_ENTRY     pje;

    MGM_IF_ENTRY    mie;


    //
    // Get the protocol entry on which CREATION_ALERTs are to
    // be invoked.
    //

    ppe = GetProtocolEntry(
            PROTOCOL_LIST_HEAD(), dwProtocolId, dwComponentId
            );

    if ( ppe == NULL )
    {
        TRACE2(
            ANY, "Could not invoke CREATION_ALERTs since protocol"
            "(%ld, %ld) not found", dwProtocolId, dwComponentId
            );
            
        return ERROR_NOT_FOUND;
    }


    if ( !( IS_CREATION_ALERT( ppe ) ) )
    {
        TRACE2(
            ANY, "Protocol (%ld, %ld) does not have a CREATION_ALERT",
            dwProtocolId, dwComponentId
            );

        return NO_ERROR;
    }

    
    //
    // for each member of the list invoke CREATION_ALERT
    //

    ple = pleForwardList-> Flink;

    while ( ple != pleForwardList )
    {
        pje = CONTAINING_RECORD( ple, JOIN_ENTRY, leJoinList );

        mie.dwIfIndex       = dwIfIndex;

        mie.dwIfNextHopAddr = dwIfNextHopAddr;

        mie.bIGMP           = TRUE;

        mie.bIsEnabled        = pje-> bJoin;


        CREATION_ALERT( ppe )(
            pje-> dwSourceAddr, pje-> dwSourceMask,
            pje-> dwGroupAddr, pje-> dwGroupMask,
            pje-> dwIfIndex, pje-> dwIfNextHopAddr,
            1, &mie
            );

        pje-> bJoin         = mie.bIsEnabled;

        ple                 = ple-> Flink;
    }

    return NO_ERROR;
}


VOID
WorkerFunctionInvokeCreationAlert(
    PVOID       pvContext
    )
/*++

Routine Description:

    This routine invokes the creation alert for the protocol that
    owns the interface specified in the context.  This invocation
    needs to happen from a worker thread for locking reasons.

    For a group join the protocol calls into MGM via the
    MgmAddGroupMembership API.  We cannot call back into the protocol
    in the context of this API call since the protocol could be holding 
    locks when invoking this API which in turn may be acquired in the 
    context of the callback.  Hence the call back are invoked from a 
    worker thread

Parameters

    pvContext   - pointer to a CREATION_ALERT_CONTEXT structure 
                  containing the source, group, and interface on which 
                  a membership join occured.

Return Value:

    None

Environment:

    Invoked from MgmAddGroupMembership for (*, G) and (*, *) joins.  
    Calls in protocols to issue CREATION_ALERT_CALLBACK
    
--*/
{
    DWORD dwInd, dwErr, dwIfBucket, dwGrpBucket, dwSrcBucket;
    
    BOOL bNewComp, bIfLock = FALSE, bGrpLock = FALSE, bgeLock = FALSE;
    
    PIF_ENTRY pieEntry;
    PGROUP_ENTRY pge;
    PSOURCE_ENTRY pse;
    POUT_IF_ENTRY poie;
    LIST_ENTRY leSourceList;
    
    PCREATION_ALERT_CONTEXT pcac = (PCREATION_ALERT_CONTEXT) pvContext;


    if (!ENTER_MGM_WORKER())
    {
        TRACE0(
            ANY, "InvokeCreationAlert: Failed to enter"
            );

        MGM_FREE( pcac );
        
        return;
    }


    TRACE0( GROUP, "ENTERED WorkerFunctionInvokeCreationAlert" );

    //
    // Acquire protocol lock first to maintain locking order
    //

    ACQUIRE_PROTOCOL_LOCK_SHARED();

    do
    {
        dwIfBucket = IF_TABLE_HASH(
                        pcac-> dwIfIndex
                        );

        //
        // For wildcard group - i.e. (*, *) membership adds.
        //
        
        if ( IS_WILDCARD_GROUP( pcac-> dwGroupAddr, pcac-> dwGroupMask ) )
        {
            InitializeListHead( &leSourceList );
            
            //
            // Walk each bucket of the group table
            //
            
            for ( dwInd = 1; dwInd < GROUP_TABLE_SIZE; dwInd++ )
            {
                //
                // Lock the interface to prevent the (*, *)
                // membership from being deleted while MFEs
                // are being updated.
                //
                
                ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

                pieEntry = GetIfEntry(
                            IF_BUCKET_HEAD( dwIfBucket ),
                            pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                            );

                if ( pieEntry == NULL )
                {
                    //
                    // Interface is no longer present with MGM.
                    // possibly deleted in another thread.
                    // There is no further MFE update to be performed.
                    // quit now.
                    //

                    RELEASE_IF_LOCK_SHARED( dwIfBucket );

                    break;
                }

                //
                // Pass 1: Accumulate (S, G) values for all groups
                //         in this group bucket into leSourceList.
                //
                
                AddInterfaceToAllMfeInGroupBucket(
                    pcac-> dwIfIndex, pcac-> dwIfNextHopAddr,
                    pcac-> dwProtocolId, pcac-> dwComponentId,
                    dwInd, pcac-> bIGMP, FALSE, &leSourceList
                    );

                RELEASE_IF_LOCK_SHARED( dwIfBucket );


                //
                // Invoke CREATION_ALERTs on them outside locks
                //
                
                dwErr = InvokeCreationAlertForList( 
                            &leSourceList, 
                            pcac-> dwProtocolId, pcac-> dwComponentId,
                            pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                            );
                            
                if ( dwErr == NO_ERROR )
                {
                    //
                    // Lock the interface to prevent the (*, *)
                    // membership from being deleted while MFEs
                    // are being updated.
                    //
                    
                    ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

                    pieEntry = GetIfEntry(
                                IF_BUCKET_HEAD( dwIfBucket ),
                                pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                                );
                                
                    if ( pieEntry == NULL )
                    {
                        //
                        // Interface is no longer present with MGM.
                        // possibly deleted in another thread.
                        // There is no further MFE update to be performed.
                        // quit now.
                        //

                        RELEASE_IF_LOCK_SHARED( dwIfBucket );

                        break;
                    }
                    

                    //
                    // Verify that the (*, *) membership on this interface
                    // is still present.
                    // It could have been deleted in a separate thread.
                    //

                    dwGrpBucket = GROUP_TABLE_HASH( 0, 0 );

                    ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

                    pge = GetGroupEntry( 
                            GROUP_BUCKET_HEAD( dwGrpBucket ), 0, 0
                            );
                    
                    if ( pge != NULL )
                    {
                        ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pge );
                        
                        dwSrcBucket = SOURCE_TABLE_HASH( 0, 0 );
                        
                        if ( FindSourceEntry(
                                SOURCE_BUCKET_HEAD( pge, dwSrcBucket ), 
                                0, 0, &pse, TRUE ) )
                        {
                            if ( FindOutInterfaceEntry(
                                    &pse-> leOutIfList,
                                    pcac-> dwIfIndex, 
                                    pcac-> dwIfNextHopAddr,
                                    pcac-> dwProtocolId, 
                                    pcac-> dwComponentId,
                                    &bNewComp, 
                                    &poie ) )
                            {
                                //
                                // (*, *) membership is present on 
                                // this interface
                                //

                                //
                                // Pass 2 : Update all MFEs in this
                                //          bucket as per the results
                                //          of the CREATION_ALERTs
                                //
                                
                                AddInterfaceToAllMfeInGroupBucket(
                                    pcac-> dwIfIndex, 
                                    pcac-> dwIfNextHopAddr,
                                    pcac-> dwProtocolId, 
                                    pcac-> dwComponentId,
                                    dwInd, 
                                    pcac-> bIGMP, 
                                    TRUE, 
                                    &leSourceList
                                    );
                            }

                            else
                            {
                                //
                                // (*, *) membership is NO longer 
                                // present on this interface
                                //
                                
                                dwInd = GROUP_TABLE_SIZE;
                            }
                        }

                        else
                        {
                            //
                            // (*, *) membership is no longer present
                            //
                            
                            dwInd = GROUP_TABLE_SIZE;
                        }

                        RELEASE_GROUP_ENTRY_LOCK_SHARED( pge );
                    }

                    else
                    {
                        //
                        // (*, *) membership is no longer present
                        //
                        
                        dwInd = GROUP_TABLE_SIZE;
                    }
                    
                    RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
                    
                    RELEASE_IF_LOCK_SHARED( dwIfBucket );
                }

                FreeList( &leSourceList );
            }

            FreeList( &leSourceList );
        }


        //
        // For wildard sources i.e. (*, G) membership adds
        //
        
        else if ( IS_WILDCARD_SOURCE( 
                    pcac-> dwSourceAddr, pcac-> dwSourceMask 
                    ) )
        {
            do
            {
                //
                // Invoke CREATION_ALERTs for all MFEs for the group
                //
                
                dwErr = InvokeCreationAlertForList( 
                            &(pcac-> leSourceList),
                            pcac-> dwProtocolId,
                            pcac-> dwComponentId, 
                            pcac-> dwIfIndex,
                            pcac-> dwIfNextHopAddr
                            );
                            
                if ( dwErr != NO_ERROR )
                {
                    break;
                }


                //
                // Lock the interface to prevent the (*, G)
                // membership from being deleted while MFEs
                // are being updated.
                //
                
                ACQUIRE_IF_LOCK_SHARED( dwIfBucket );
                bIfLock = TRUE;

                pieEntry = GetIfEntry(
                            IF_BUCKET_HEAD( dwIfBucket ),
                            pcac-> dwIfIndex, 
                            pcac-> dwIfNextHopAddr
                            );

                if ( pieEntry == NULL )
                {
                    //
                    // Interface is no longer present with MGM.
                    // possibly deleted in another thread.
                    // There is no further MFE update to be performed.
                    // quit now.
                    //

                    TRACE2(
                        ANY, "InvokeCreationAlert: Interface 0x%x 0x%x"
                        " is no longer present",
                        pcac-> dwIfIndex, 
                        pcac-> dwIfNextHopAddr
                        );
                        
                    break;
                }
                

                //
                // Verify that the (*, G) membership is still
                // present on the interface
                //
                
                dwGrpBucket = GROUP_TABLE_HASH( 
                                pcac-> dwGroupAddr, 
                                pcac-> dwGroupMask
                                );

                ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
                bGrpLock = TRUE;

                pge = GetGroupEntry( 
                        GROUP_BUCKET_HEAD( dwGrpBucket ), 
                        pcac-> dwGroupAddr,
                        pcac-> dwGroupMask
                        );

                if ( pge == NULL )
                {
                    //
                    // Group entry no longer present, possibly
                    // deleted in some other thread
                    //

                    TRACE2(
                        ANY, "InvokeCreationAlert: Group 0x%x 0x%x "
                        "is no longer present",
                        pcac-> dwGroupAddr, pcac-> dwGroupMask
                        );

                    break;
                }
                
                ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                bgeLock = TRUE;

                dwSrcBucket = SOURCE_TABLE_HASH( 
                                pcac-> dwSourceAddr, 
                                pcac-> dwSourceMask 
                                );

                pse = GetSourceEntry(
                        SOURCE_BUCKET_HEAD( pge, dwSrcBucket ),
                        pcac-> dwSourceAddr, 
                        pcac-> dwSourceMask
                        );
                        
                if ( pse == NULL )
                {
                    //
                    // Source entry no longer present, possibly
                    // deleted in some other thread
                    //

                    TRACE2(
                        ANY, "InvokeCreationAlert: Source 0x%x 0x%x "
                        "is no longer present",
                        pcac-> dwSourceAddr, pcac-> dwSourceMask
                        );

                    break;
                
                }

                poie = GetOutInterfaceEntry(
                        &pse-> leOutIfList,
                        pcac-> dwIfIndex, pcac-> dwIfNextHopAddr,
                        pcac-> dwProtocolId, pcac-> dwComponentId
                        );

                if ( poie == NULL )
                {
                    TRACE2(
                        ANY, "InvokeCreationAlert: Interface 0x%x 0x%x "
                        "is no longer present in OIF",
                        pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                        );

                    break;
                    
                }
                
                //
                // (*, G) present on this interface.
                // Update all for group MFE as per results of 
                // creation alerts.
                //
                
                AddInterfaceToGroupMfe(
                    pge, pcac-> dwIfIndex, pcac-> dwIfNextHopAddr,
                    pcac-> dwProtocolId, pcac-> dwComponentId,
                    pcac-> bIGMP, TRUE, &(pcac-> leSourceList)
                    );
                
            } while ( FALSE );


            //
            // release locks
            //

            if ( bgeLock )
            {
                RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                bgeLock = FALSE;
            }
            
            if ( bGrpLock )
            {
                RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
                bgeLock = FALSE;
            }

            if ( bIfLock )
            {
                RELEASE_IF_LOCK_SHARED( dwIfBucket );
                bIfLock = FALSE;
            }
            
            FreeList( &(pcac-> leSourceList) );
        } 
        
    } while ( FALSE );
    

    if ( bIfLock )
    {
        RELEASE_IF_LOCK_SHARED( dwIfBucket );
    }
    
    RELEASE_PROTOCOL_LOCK_SHARED();

    MGM_FREE( pcac );
    
    LEAVE_MGM_WORKER();
    
    TRACE0( GROUP, "LEAVING WorkerFunctionInvokeCreationAlert" );

    return;
}


#if 0
v()
{
        //
        // Ensure interface on which join occured is still present 
        //

        dwIfBucket = IF_TABLE_HASH(
                        pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                        );

        ACQUIRE_IF_LOCK_SHARED( dwIfBucket );
        bIfLock = TRUE;
        
        pieEntry = GetIfEntry(
                    IF_BUCKET_HEAD( dwIfBucket ),
                    pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                    );

        if ( pieEntry == NULL )
        {
            TRACE2(
                ANY,
                "InvokeCreationAlert: Could not find interface 0x%x 0x%x",
                pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                );

            break;
        }


        //
        // Ensure that group is still joined on the interface.  Since this
        // is being executed asynchronously, it is possible that between 
        // the time this work item was queued and the time it gets executed 
        // the membership may have been deleted.
        //

        dwGrpBucket = GROUP_TABLE_HASH( 
                        pcac-> dwGroupAddr, pcac-> dwGroupMask
                        );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );
        bGrpBucket = TRUE;

        pge = GetGroupEntry(
                GROUP_BUCKET_HEAD( dwGrpBucket ),
                pcac-> dwGroupAddr, pcac-> dwGroupMask
                );

        if ( pge == NULL )
        {
            TRACE2(
                ANY, "InvokeCreationAlert: Could not find group 0x%x 0x%x",
                pcac-> dwGroupAddr, pcac-> dwGroupMask
                );

            break;
        }

        ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pge );
        bGrpLock = TRUE;

        dwSrcBucket = SOURCE_TABLE_HASH(
                         pcac-> dwSourceAddr, pcac-> dwSourceMask
                         );

        pse = GetSourceEntry(
                SOURCE_BUCKET_HEAD( pge, dwSrcBucket ),
                pcac-> dwSourceAddr, pcac-> dwSourceMask
                );

        if ( pse == NULL )
        {
            TRACE2(
                ANY, "InvokeCreationAlert: Could not find source 0x%x "
                "0x%x",
                pcac-> dwSourceAddr, pcac-> dwSourceMask
                );

            break;
        }


        if (GetOutInterfaceEntry(
                &pse-> leOutIfList,
                pcac-> dwIfIndex, pcac-> dwIfNextHopAddr,
                pcac-> dwProtocolId, pcac-> dwComponentId
                ) == NULL)
        {
            TRACE2(
                ANY, "InvokeCreationAlert: Interface 0x%x 0x%x not "
                "present in OIF list",
                pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                );

            break;
        }

        //
        // release locks
        //

        RELEASE_GROUP_ENTRY_LOCK_SHARED( pge );
        bGrpLock = FALSE;

        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
        bGrpBucket = FALSE;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\scope.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: scope.h
//
// History:
//      V Raman    June-25-1997  Created.
//
// Prototypes for functions that implement the admin-scoped boundaries 
//============================================================================


#ifndef _SCOPE_H_
#define _SCOPE_H_


DWORD
APIENTRY
MgmBlockGroups(
    IN          DWORD       dwFirstGroup,
    IN          DWORD       dwLastGroup,
    IN          DWORD       dwIfIndex,
    IN          DWORD       dwIfNextHopAddr
);



DWORD
APIENTRY
MgmUnBlockGroups(
    IN          DWORD       dwFirstGroup,
    IN          DWORD       dwLastGroup,
    IN          DWORD       dwIfIndex,
    IN          DWORD       dwIfNextHopAddr
);


//
// Routines that invoke the NEW and DELETE member callbacks for
// protocols as per the interop rules
//

VOID
InvokePruneAlertCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    DWORD               dwIfIndex,
    DWORD               dwIfNextHopAddr,
    PPROTOCOL_ENTRY     ppe
);

VOID
InvokeJoinAlertCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    POUT_IF_ENTRY       poie,
    BOOL                bIGMP,
    PPROTOCOL_ENTRY     ppe
);




//
// Node in the Outstanding Join List
//

typedef struct _JOIN_ENTRY
{
    LIST_ENTRY  leJoinList;
    
    DWORD       dwSourceAddr;

    DWORD       dwSourceMask;

    DWORD       dwGroupAddr;

    DWORD       dwGroupMask;

    DWORD       dwIfIndex;

    DWORD       dwIfNextHopAddr;

    BOOL        bJoin;
    
} JOIN_ENTRY, *PJOIN_ENTRY;



//
// Functions to manipulate the join list
//

DWORD
AddToOutstandingJoinList(
    DWORD       dwSourceAddr,
    DWORD       dwSourceMask,
    DWORD       dwGroupAddr,
    DWORD       dwGroupMask,
    DWORD       dwIfIndex,
    DWORD       dwIfNextHopAddr,
    BOOL        bJoin
);

VOID
InvokeOutstandingCallbacks(
);



 //
 // Functions to manipulate the check for creation alert list
 //

VOID
AddToCheckForCreationAlertList(
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    PLIST_ENTRY     pleForwardList
);


VOID
FreeList(
    PLIST_ENTRY     pleForwardList
);


BOOL
IsForwardingEnabled(
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    PLIST_ENTRY     pleSourceList
);


DWORD
InvokeCreationAlertForList( 
    PLIST_ENTRY     pleForwardList,
    DWORD           dwProtocolId,
    DWORD           dwComponentId,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr
);


//
// Context passed to worker function WorkerFunctionInvokeCreationAlert
//

typedef struct _CREATION_ALERT_CONTEXT {

    //
    // Source(s) for the group that was joined
    //
    
    DWORD           dwSourceAddr;

    DWORD           dwSourceMask;

    //
    // Group(s) that were joined
    //

    DWORD           dwGroupAddr;

    DWORD           dwGroupMask;

    //
    // Interface on which joined.  This is the interface
    // for which creation alerts have to issued
    //

    DWORD           dwIfIndex;

    DWORD           dwIfNextHopAddr;


    //
    // Protocol that performed the join
    //

    DWORD           dwProtocolId;

    DWORD           dwComponentId;

    BOOL            bIGMP;


    //
    // for (*, G) entries, list of MFE(s) for G to be
    // updated
    //

    LIST_ENTRY      leSourceList;
    
} CREATION_ALERT_CONTEXT, *PCREATION_ALERT_CONTEXT;


//
// worker function required for invoking creation alert
// to protocols from a worker thread
//

VOID
WorkerFunctionInvokeCreationAlert(
    PVOID           pvContext
);

#endif // _SCOPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\sync.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: sync.h
//
// History:
//      V Raman	July-11-1997  Created.
//
// Lock structures and synchronization routines.
// Lock structures borrowed from RIPv2 by Abolade Gbadegesin.
// Dynamic locking idea borrowed from RTM by Vadim Eydelman.
//============================================================================

#ifndef _SYNC_H_
#define _SYNC_H_


//----------------------------------------------------------------------------
//
// Read/Write locks for synchronization of access to various lists
//
// Given the large number of lists (including the various hash buckets) and
// the relatively small number of clients that concurrently invoke MGM 
// API, statically allocating a lock structure for each list was 
// considered expensive.  Locks are created as needed and stored in a 
// stack structure (implemented as a singly linked list) after use.
//
// Subsequent requests for locks are all satisfied by reusing the locks 
// stored on the stack.  Only if the stack is empty ie. all locks in the
// stack are in use are new locks created.
//
// This ensures that the most number of locks created is no larger than
// the maximum number of concurrent clients at any time.
//
// csReadWriteBlock     -       Critical section guarding access to
//                              lReaderCount.
// lReaderCount         -       Count of readers currently using the
//                              shared resource.
// hReaderDoneEvent     -       Event on which writers block when readers
//                              are currently using the lists.
// lUseCount            -       Count of readers + writers.  Used to 
//                              determine if there are any threads waiting
//                              on the lock.  If there are none the lock
//                              can be released to te stack of locks.
//----------------------------------------------------------------------------

typedef struct _MGM_READ_WRITE_LOCK
{
    SINGLE_LIST_ENTRY           sleLockList;
    
    CRITICAL_SECTION            csReaderWriterBlock;
    
    LONG                        lReaderCount;
    
    HANDLE                      hReaderDoneEvent;

    LONG                        lUseCount;
    
} MGM_READ_WRITE_LOCK, *PMGM_READ_WRITE_LOCK;



//----------------------------------------------------------------------------
//
// Read/write locks are created dynamically and stored for
// reuse in a stack struture.  
//
//----------------------------------------------------------------------------

typedef struct _LOCK_LIST
{
    SINGLE_LIST_ENTRY               sleHead;

    CRITICAL_SECTION                csListLock;

    BOOL                            bInit;

} LOCK_LIST, *PLOCK_LIST;



//----------------------------------------------------------------------------
// Standard locked list structure.
//----------------------------------------------------------------------------

typedef struct _MGM_LOCKED_LIST 
{

    LIST_ENTRY                  leHead;

    PMGM_READ_WRITE_LOCK        pmrwlLock;

    DWORD                       dwCreated;
    
} MGM_LOCKED_LIST, *PMGM_LOCKED_LIST;


#define CREATE_LOCKED_LIST( p )                                             \
{                                                                           \
    (p)-> pmrwlLock = NULL;                                                 \
    InitializeListHead( &(p)->leHead );                                     \
    (p)-> dwCreated = 0x12345678;                                           \
}


#define DELETE_LOCKED_LIST( p )                                             \
{                                                                           \
    (p)-> pmrwlLock = NULL;                                                 \
    if ( !IsListEmpty( &(p)-> leHead ) )                                    \
        TRACE0( ANY, "Locked list being deleted is not empty" );            \
    InitializeListHead( &(p)-> leHead );                                    \
    (p)-> dwCreated = 0;                                                    \
}


#define LOCKED_LIST_HEAD( p )   &(p)-> leHead 



//
// Routines to create/delete locks
//

DWORD
CreateReadWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
);

VOID
DeleteReadWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK    pmrwl
);

VOID
DeleteLockList(
);


//
// Routines to acquire and release locks.
//

DWORD
AcquireReadLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
);

VOID
ReleaseReadLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
);


DWORD
AcquireWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
);

VOID
ReleaseWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
);



#endif // _SYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\sync.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: sync.c
//
// History:
//      V Raman	July-11-1997  Created.
//
// Basic locking operations. Borrowed from RIP implementation by abolade
//============================================================================


#include "pchmgm.h"
#pragma hdrstop


//----------------------------------------------------------------------------
// Function:    QueueMgmWorker  
//
// This function is called to queue a MGM function in a safe fashion;
// if cleanup is in progress or if MGM has stopped, this function
// discards the work-item.
//----------------------------------------------------------------------------

DWORD
QueueMgmWorker(
    WORKERFUNCTION pFunction,
    PVOID pContext
    ) {

    DWORD dwErr;

    ENTER_GLOBAL_SECTION();
    
    if (ig.imscStatus != IPMGM_STATUS_RUNNING) {

        //
        // cannot queue a work function when MGM has quit or is quitting
        //

        dwErr = ERROR_CAN_NOT_COMPLETE;
    }
    else {

        ++ig.lActivityCount;

        dwErr = RtlQueueWorkItem(pFunction, pContext, 0);

        if (dwErr != STATUS_SUCCESS) { --ig.lActivityCount; }
    }

    LEAVE_GLOBAL_SECTION();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    EnterMgmAPI
//
// This function is called to when entering a MGM api, as well as
// when entering the input thread and timer thread.
// It checks to see if MGM has stopped, and if so it quits; otherwise
// it increments the count of active threads.
//----------------------------------------------------------------------------

BOOL
EnterMgmAPI(
    ) {

    BOOL bEntered;

    ENTER_GLOBAL_SECTION();

    if (ig.imscStatus == IPMGM_STATUS_RUNNING) {

        //
        // MGM is running, so the API may continue
        //

        ++ig.lActivityCount;

        bEntered = TRUE;
    }
    else {

        //
        // MGM is not running, so the API exits quietly
        //

        bEntered = FALSE;
    }

    LEAVE_GLOBAL_SECTION();

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    EnterMgmWorker
//
// This function is called when entering a MGM worker-function.
// Since there is a lapse between the time a worker-function is queued
// and the time the function is actually invoked by a worker thread,
// this function must check to see if MGM has stopped or is stopping;
// if this is the case, then it decrements the activity count, 
// releases the activity semaphore, and quits.
//----------------------------------------------------------------------------

BOOL
EnterMgmWorker(
    ) {

    BOOL bEntered;

    ENTER_GLOBAL_SECTION();

    if (ig.imscStatus == IPMGM_STATUS_RUNNING) {

        //
        // MGM is running, so the function may continue
        //

        bEntered = TRUE;
    }
    else
    if (ig.imscStatus == IPMGM_STATUS_STOPPING) {

        //
        // MGM is not running, but it was, so the function must stop.
        // 

        --ig.lActivityCount;

        ReleaseSemaphore(ig.hActivitySemaphore, 1, NULL);

        bEntered = FALSE;
    }
    else {

        //
        // MGM probably never started. quit quietly
        //

        bEntered = FALSE;
    }

    LEAVE_GLOBAL_SECTION();

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    LeaveMgmWorker
//
// This function is called when leaving a MGM API or worker function.
// It decrements the activity count, and if it detects that MGM has stopped
// or is stopping, it releases the activity semaphore.
//----------------------------------------------------------------------------

VOID
LeaveMgmWorker(
    ) {

    ENTER_GLOBAL_SECTION();

    --ig.lActivityCount;

    if (ig.imscStatus == IPMGM_STATUS_STOPPING) {

        ReleaseSemaphore(ig.hActivitySemaphore, 1, NULL);
    }

    LEAVE_GLOBAL_SECTION();

}




//----------------------------------------------------------------------------
// CreateReadWriteLock
//
// This function is called to create and initialize a new read-write lock
// structure.  It is invoked by AcquireXLock ( X = { Read | Write } )
//----------------------------------------------------------------------------

DWORD
CreateReadWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
    )
{

    DWORD                   dwErr;
    PMGM_READ_WRITE_LOCK    pmrwl;
    

    TRACELOCK1( "ENTERED CreateReadWriteLock : %x", ppmrwl );

    do
    {
        *ppmrwl = NULL;
        
    
        //
        // Allocate a lock structure
        //

        pmrwl = MGM_ALLOC( sizeof( MGM_READ_WRITE_LOCK ) );

        if ( pmrwl == NULL ) 
        {
            dwErr = GetLastError();

            TRACE1( 
                ANY, "CreateReadWriteLock failed to allocate lock : %x", dwErr
                );

            break;                
        }


        //
        // Init. critcal section
        //

        try
        {
            InitializeCriticalSection( &pmrwl-> csReaderWriterBlock );
        }
        except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = GetLastError();

            MGM_FREE( pmrwl );

            TRACE1( 
                ANY, 
                "CreateReadWriteLock failed to initialize critical section : %x",
                dwErr
                );

            break;
        }

        
        //
        // create reader done event.
        //
        
        pmrwl-> hReaderDoneEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

        if ( pmrwl-> hReaderDoneEvent == NULL )
        {
            dwErr = GetLastError();
        
            MGM_FREE( pmrwl );
            
            TRACE1( 
                ANY, 
                "CreateReadWriteLock failed to create event : %x",
                dwErr
                );

            break;                
        }


        //
        // initialize count fields
        //
        
        pmrwl-> lUseCount = 0;

        pmrwl-> lReaderCount = 0;


        pmrwl-> sleLockList.Next = NULL;

        *ppmrwl = pmrwl;

        dwErr = NO_ERROR;
        
    } while ( FALSE );


    TRACELOCK1( "LEAVING CreateReadWriteLock : %x", dwErr );

    return dwErr;
}


//----------------------------------------------------------------------------
// DeleteReadWriteLock
//
// This functions destroys a read-write lock.  It is invoked when MGM is
// being stopped.  During normal operation when a read-write lock is no longer
// required it pushed onto a global stack of locks for reuse as needed.
//----------------------------------------------------------------------------

VOID
DeleteReadWriteLock(
    IN      PMGM_READ_WRITE_LOCK    pmrwl
    )
{
    DeleteCriticalSection( &pmrwl-> csReaderWriterBlock ); 

    CloseHandle( pmrwl-> hReaderDoneEvent );

    MGM_FREE( pmrwl );
}



//----------------------------------------------------------------------------
// DeleteLockList
//
// This function deletes the entire list of locks present in the stack of
// read write locks.  Assumes stack of locks is locked.
//----------------------------------------------------------------------------

VOID
DeleteLockList(
)
{
    PSINGLE_LIST_ENTRY      psle = NULL;

    PMGM_READ_WRITE_LOCK    pmrwl = NULL;
    

    TRACELOCK0( "ENTERED DeleteLockList"  );

    ENTER_GLOBAL_LOCK_LIST_SECTION();
    

    psle = PopEntryList( &ig.llStackOfLocks.sleHead );

    while ( psle != NULL )
    {
        pmrwl = CONTAINING_RECORD( psle, MGM_READ_WRITE_LOCK, sleLockList );

        DeleteReadWriteLock( pmrwl );
        
        psle = PopEntryList( &ig.llStackOfLocks.sleHead );
    }

    LEAVE_GLOBAL_LOCK_LIST_SECTION();

    TRACELOCK0( "LEAVING DeleteLockList");
}



//----------------------------------------------------------------------------
// AcquireReadLock
//
// This function provides read access to a protected resource.  If needed 
// it will reuse a lock from the stack of locks if available or allocate a 
// new read-write lock.
//----------------------------------------------------------------------------

DWORD
AcquireReadLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
    )
{
    DWORD                           dwErr = NO_ERROR;
    
    PSINGLE_LIST_ENTRY              psle = NULL;
    


    //
    // determine if a lock needs to be allocated first.  
    // Perform this check with in a critical section so
    // that two locks are not concurrently 
    // assigned to a single resource.  
    //

    ENTER_GLOBAL_LOCK_LIST_SECTION();

    if ( *ppmrwl == NULL )
    {
        //
        // get a lock from the stack of locks
        //

        psle = PopEntryList( &ig.llStackOfLocks.sleHead );

        if ( psle != NULL )
        {
            *ppmrwl = CONTAINING_RECORD( 
                        psle, MGM_READ_WRITE_LOCK, sleLockList 
                        );
        }

        else
        {
            //
            // Stack of locks was empty. Create a new lock
            // 

            dwErr = CreateReadWriteLock( ppmrwl );

            if ( dwErr != NO_ERROR )
            {
                //
                // failed to create a lock.  Possibly ran out of resources
                //
                
                LEAVE_GLOBAL_LOCK_LIST_SECTION();
                
                TRACE2( 
                    ANY, "LEAVING AcquireReadLock, lock %x, error %x",
                    ppmrwl, dwErr
                    );
                    
                return dwErr;
            }
        }
    }

    
    //
    // *ppmrwl points to a valid lock structure.
    //

    InterlockedIncrement( &( (*ppmrwl)-> lUseCount ) );

    TRACECOUNT1( "AcquireReadLock, Users %d", (*ppmrwl)-> lUseCount );

    LEAVE_GLOBAL_LOCK_LIST_SECTION();


    //
    // Increment reader count
    //
    
    EnterCriticalSection( &( (*ppmrwl)-> csReaderWriterBlock ) );

    InterlockedIncrement( &( (*ppmrwl)-> lReaderCount ) );

    TRACECOUNT1( "Readers %d", (*ppmrwl)-> lReaderCount );
        
    LeaveCriticalSection( &( (*ppmrwl)-> csReaderWriterBlock ) );

    
    return NO_ERROR;
}



//----------------------------------------------------------------------------
// ReleaseReadLock
//
// This function is invoked to release read access to a protected resource.
// If there are no more reader/writers waiting on this lock, the read-write
// lock is released to the global stack of locks for later reuse.
//----------------------------------------------------------------------------

VOID
ReleaseReadLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
    )
{
    //
    // Decrement reader count, and signal any waiting writer
    //

    if ( InterlockedDecrement( &( (*ppmrwl)-> lReaderCount ) ) < 0 )
    {
        SetEvent( (*ppmrwl)-> hReaderDoneEvent );
    }


    //
    // determine if the lock is being used. If not the lock should be
    // released to the stack of locks.
    //

    ENTER_GLOBAL_LOCK_LIST_SECTION();


    if ( InterlockedDecrement( &( (*ppmrwl)-> lUseCount ) ) == 0 )
    {
        PushEntryList( &ig.llStackOfLocks.sleHead, &( (*ppmrwl)-> sleLockList ) );
        *ppmrwl = NULL;

        TRACECOUNT0( "ReleaseReadLock no more users" );
    }

    else
    {
        TRACECOUNT2(
            "ReleaseReadLock, Readers %x, users %x",
            (*ppmrwl)-> lReaderCount, (*ppmrwl)-> lUseCount
            );
    }
    
    LEAVE_GLOBAL_LOCK_LIST_SECTION();
}



//----------------------------------------------------------------------------
// AcquireWriteLock
//
// This function provides write access to a protected resource.  If needed 
// it will reuse a lock from the stack of locks if available or allocate a 
// new read-write lock.
//----------------------------------------------------------------------------

DWORD
AcquireWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
    )
{
    DWORD                           dwErr = NO_ERROR;
    
    PSINGLE_LIST_ENTRY              psle = NULL;
    
    //
    // determine is the you need to allocate a lock first.  If needed
    // do so under mutual exclusive so that two locks are not
    // concurrently assigned for the same resources.
    //

    ENTER_GLOBAL_LOCK_LIST_SECTION();

    if ( *ppmrwl == NULL )
    {
        //
        // get a lock from the stack of locks
        //

        psle = PopEntryList( &ig.llStackOfLocks.sleHead );

        if ( psle != NULL )
        {
            *ppmrwl = CONTAINING_RECORD( 
                        psle, 
                        MGM_READ_WRITE_LOCK, 
                        sleLockList 
                        );
        }

        else
        {
            //
            // Stack of locks was empty. Create a new lock
            // 

            dwErr = CreateReadWriteLock( ppmrwl );

            if ( dwErr != NO_ERROR )
            {
                LEAVE_GLOBAL_LOCK_LIST_SECTION();
                return dwErr;
            }
        }
    }

    
    //
    // *ppmrwl points to a valid lock structure.
    //

    InterlockedIncrement( &( (*ppmrwl)-> lUseCount ) );

    TRACECOUNT1( "AcquireWriteLock, Users %d", (*ppmrwl)-> lUseCount );
    
    LEAVE_GLOBAL_LOCK_LIST_SECTION();


    //
    // acquire write lock.
    //

    EnterCriticalSection( &( (*ppmrwl)-> csReaderWriterBlock ) );

    if ( InterlockedDecrement( &( (*ppmrwl)-> lReaderCount ) ) >= 0 )
    {
        //
        // other readers present.  Wait for them to finish
        //

        TRACECOUNT1( "AcquireWriteLock, Readers %d", (*ppmrwl)-> lReaderCount );
       
        WaitForSingleObject( (*ppmrwl)-> hReaderDoneEvent, INFINITE );
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// ReleaseWriteLock
//
// This function is invoked to release write access to a protected resource.
// If there are no more reader/writers waiting on this lock, the read-write
// lock is released to the global stack of locks for later reuse.
//----------------------------------------------------------------------------

VOID
ReleaseWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
    )
{
    //
    // release the write lock
    //
    
    (*ppmrwl)-> lReaderCount = 0;

    LeaveCriticalSection( &( (*ppmrwl)-> csReaderWriterBlock ) );


    //
    // determine if the lock is being used by anyone else.
    // if not we need to release the lock back to the stack.
    //

    ENTER_GLOBAL_LOCK_LIST_SECTION();

    if ( InterlockedDecrement( &( (*ppmrwl)-> lUseCount ) ) == 0 )
    {
        PushEntryList( &ig.llStackOfLocks.sleHead, &( (*ppmrwl)-> sleLockList ) );
        *ppmrwl = NULL;
        TRACECOUNT0( "ReleaseWriteLock no more users" );
    }

    else
    {
        TRACECOUNT2(
            "ReleaseWriteLock, Readers %x, users %x",
            (*ppmrwl)-> lReaderCount, (*ppmrwl)-> lUseCount
            );
    }
    
    
    LEAVE_GLOBAL_LOCK_LIST_SECTION();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\timer.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: timer.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// Functions to manager ageing out of MFEs.
//============================================================================


#include "pchmgm.h"
#pragma hdrstop


//----------------------------------------------------------------------------
// DeleteFromForwarder
//
//  This function is an entry point for IP RouterManager.  It is invoked
//  in response to deletion (because of timeouts) of MFEs in the kernel
//  mode forwarder.  This entry point is invoked with a list of deleted
//  MFEs.
//
//  This function flags each of the MFEs that have been deleted by the
//  forwarder as "not present in the forwarder"
//----------------------------------------------------------------------------

DWORD
DeleteFromForwarder(
    DWORD                       dwEntryCount,
    PIPMCAST_DELETE_MFE         pimdmMfes
)
{
    DWORD                       dwInd, dwGrpBucket, dwSrcBucket;

    PGROUP_ENTRY                pge;

    PSOURCE_ENTRY               pse;

    PLIST_ENTRY                 pleHead;

    

    TRACE1( TIMER, "ENTERED DeleteFromForwarder, Entries %x", dwEntryCount );


    //
    // for each MFE that has been deleted from the KMF
    //

    for ( dwInd = 0; dwInd < dwEntryCount; dwInd++ )
    {
        //
        // 1. Lookup the MFE in MGM 
        //

        //
        // 1.1 Find group entry
        //
        
        dwGrpBucket = GROUP_TABLE_HASH( pimdmMfes[ dwInd ].dwGroup, 0 );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

        pleHead = GROUP_BUCKET_HEAD( dwGrpBucket );
        
        pge = GetGroupEntry( pleHead, pimdmMfes[ dwInd ].dwGroup, 0 );

        if ( pge != NULL )
        {
            //
            // 1.2 Group entry found, find source entry
            //

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            
            dwSrcBucket = SOURCE_TABLE_HASH( 
                            pimdmMfes[ dwInd ].dwSource, 
                            pimdmMfes[ dwInd ].dwSrcMask
                            );

            pleHead = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

            pse = GetSourceEntry(
                     pleHead, 
                     pimdmMfes[ dwInd ].dwSource, 
                     pimdmMfes[ dwInd ].dwSrcMask
                     );

            if ( pse != NULL )
            {
                pse-> bInForwarder = FALSE;
            }

            else
            {
                TRACE2( 
                    TIMER, "DeleteFromForwarder - Source Entry not found : "
                    "( %x, %x )", pimdmMfes[ dwInd ].dwSource, 
                    pimdmMfes[ dwInd ].dwSrcMask
                    ); 
            }

            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }

        else
        {
            TRACE1( 
                TIMER, "DeleteFromForwarder - Group Entry not found : "
                "( %x )", pimdmMfes[ dwInd ].dwGroup 
                ); 
        }

        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
    }

    TRACE0( TIMER, "LEAVING DeleteFromForwarder\n" );

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// MFETimerProc
//
//  This function is invoked by the MFE timer mechanism.  
//  It deletes the MFE that has timed out from the source/group table.
//  If the MFE is currently present in the Kernel mode forwarder, then
//  it is deleted from the forwarder as well.
//
//  If this MFE was in use by the forwarder, it will be recreated on the
//  next packet miss.
//
//----------------------------------------------------------------------------

VOID
MFETimerProc(
    PVOID                       pvContext,
    BOOLEAN                     pbFlag                        
)
{
    BOOL                        bUnLock = FALSE, bUnMark = FALSE;
    
    DWORD                       dwIfBucket, dwErr;

    PLIST_ENTRY                 pleIfHead;

    PIF_ENTRY                   pie = NULL;

    PIF_REFERENCE_ENTRY         pire = NULL;

    PTIMER_CONTEXT              ptwc = (PTIMER_CONTEXT) pvContext;
    
    RTM_NET_ADDRESS             rnaSource;

    RTM_DEST_INFO               rdiDestInfo;

    PBYTE                       pbOpaqueInfo = NULL;

    PMGM_LOCKED_LIST            pmllMfeList;

    PROUTE_REFERENCE_ENTRY      prreNew = NULL;



    TRACE4( 
        TIMER, "ENTERED MFETimerProc, Source : %x %x, Group : %x %x",
        ptwc-> dwSourceAddr, ptwc-> dwSourceMask,
        ptwc-> dwGroupAddr, ptwc-> dwGroupMask
        );


    do
    {
        //
        // delete the reference to this MFE in the route used for its RPF
        //

        do
        {
            //
            // Lookup route to source
            //

            RTM_IPV4_MAKE_NET_ADDRESS( 
                &rnaSource, ptwc-> dwSourceAddr, IPv4_ADDR_LEN
                );

            dwErr = RtmGetMostSpecificDestination(
                        g_hRtmHandle, &rnaSource, RTM_BEST_PROTOCOL,
                        RTM_VIEW_MASK_MCAST, &rdiDestInfo
                        );
                        
            if ( dwErr != NO_ERROR )
            {
                TRACE2(
                    ANY, "No Route to source %x, %d", ptwc-> dwSourceAddr, 
                    dwErr 
                    );

                break;
            }


            //
            // Lock the dest
            //

            dwErr = RtmLockDestination(
                        g_hRtmHandle, rdiDestInfo.DestHandle, TRUE, TRUE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to lock dest %x", dwErr );

                break;
            }

            bUnLock = TRUE;


            //
            // Get the opaque pointer
            //

            dwErr = RtmGetOpaqueInformationPointer(
                        g_hRtmHandle, rdiDestInfo.DestHandle, &pbOpaqueInfo
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to retrieve opaque pointer %x", dwErr );

                break;
            }


            //
            // if opaque info is present
            //
            
            if ( *( ( PBYTE * ) pbOpaqueInfo ) != NULL )
            {
                pmllMfeList = ( PMGM_LOCKED_LIST ) *( ( PBYTE *) pbOpaqueInfo );

                ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

                //
                // delete the rre from the list
                //

                if ( FindRouteRefEntry(
                        &pmllMfeList-> leHead, ptwc-> dwSourceAddr, 
                        ptwc-> dwSourceMask, ptwc-> dwGroupAddr, 
                        ptwc-> dwGroupMask, &prreNew
                        ) )
                {
                    DeleteRouteRef( prreNew );
                }

                else
                {
                    TRACE1(
                        ANY, "Reference does not exist for source %x", 
                        ptwc-> dwSourceAddr
                        );
                }

                //
                // if there are no more references to this dest, delete the locked list
                //

                if ( IsListEmpty( &pmllMfeList-> leHead ) )
                {
                    //
                    // Clear opaque pointer info
                    //

                    *( ( PBYTE * ) pbOpaqueInfo ) = NULL;

                    //
                    // release list lock
                    //

                    RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

                    MGM_FREE( pmllMfeList );


                    //
                    // unmark the dest.  Change notifications for this
                    // dest are no longer required.
                    //

                    bUnMark = TRUE;
                }

                else
                {
                    //
                    // release the list lock
                    //

                    RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
                }
                
                dwErr = NO_ERROR;
            }
            
        } while ( FALSE );
        

        //
        // Unlock dest
        //

        if ( bUnLock )
        {
            dwErr = RtmLockDestination(
                        g_hRtmHandle, rdiDestInfo.DestHandle,
                        TRUE, FALSE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to unlock dest : %x", dwErr );
            }
        }


        //
        // Unmark dest
        //

        if ( bUnMark )
        {
            dwErr = RtmMarkDestForChangeNotification(
                        g_hRtmHandle, g_hNotificationHandle,
                        rdiDestInfo.DestHandle, FALSE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to unmark DEST: %x", dwErr );
            }
        }

        
        //
        // delete the MFE and the reference to it in the 
        // incoming interface entry
        //

        //
        // find If entry for incomng interface of the MFE
        //

        dwIfBucket = IF_TABLE_HASH( ptwc-> dwIfIndex );

        ACQUIRE_IF_LOCK_EXCLUSIVE( dwIfBucket );

        pleIfHead = IF_BUCKET_HEAD( dwIfBucket );

        if ( !FindIfEntry( 
                pleIfHead, ptwc-> dwIfIndex, ptwc-> dwIfNextHopAddr, &pie ) )
        {
            //
            // specified incoming interface does not exist, 
            // this is an error condition.  All MFEs using this 
            // interface should have been deleted when this interface
            // was removed.  print an error message and quit.
            //

            TRACE2( 
                ANY, "MFETimerProc has invalid incoming interface : %x, %x",
                ptwc-> dwIfIndex, ptwc-> dwIfNextHopAddr
                );

            TRACE4(
                ANY, "Source : %x %x, Group : %x %x", 
                ptwc-> dwSourceAddr, ptwc-> dwSourceMask,
                ptwc-> dwGroupAddr, ptwc-> dwGroupMask
                );

            break;
        }

        LookupAndDeleteYourMfe( 
            ptwc-> dwSourceAddr, ptwc-> dwSourceMask, 
            ptwc-> dwGroupAddr, ptwc-> dwGroupMask, 
            TRUE, NULL, NULL
            );


        //
        // delete reference to this MFE from the incoming refeence list
        // for this interface
        //

        pleIfHead = &pie-> leInIfList;

        if ( !FindRefEntry( pleIfHead, ptwc-> dwSourceAddr, ptwc-> dwSourceMask,
                ptwc-> dwGroupAddr, ptwc-> dwGroupMask, &pire )  )
        {
            //
            // Apparently this interface is not reference by the specified
            // MFE.  This is a non-critical error.  Log a message too track
            // this condition.
            //

            TRACE2( 
                ANY, "MFETimerProc : No reference for interface : %x, %x",
                ptwc-> dwIfIndex, ptwc-> dwIfNextHopAddr
                );

            TRACE4(
                ANY, "Source : %x %x, Group : %x %x", 
                ptwc-> dwSourceAddr, ptwc-> dwSourceMask,
                ptwc-> dwGroupAddr, ptwc-> dwGroupMask
                );

            break;
        }


        RemoveEntryList( &pire-> leRefList );

        MGM_FREE( pire );
        
    } while ( FALSE );


    RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );

    //
    // release route reference.
    //

    MGM_FREE( ptwc );

    TRACE0( TIMER, "LEAVING MFETimerProc\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mgm\timer.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: timer.h
//
// History:
//      V Raman	June-25-1997  Created.
//
// Prototyes for functions to manage ageing out of MFEs.
//============================================================================

#ifndef _TIMER_H_
#define _TIMER_H_


//----------------------------------------------------------------------------
// TIMER_CONTEXT
//
//  structure used to pass context information to timer routines
//----------------------------------------------------------------------------

typedef struct _TIMER_CONTEXT
{
    DWORD           dwSourceAddr;

    DWORD           dwSourceMask;

    DWORD           dwGroupAddr;

    DWORD           dwGroupMask;

    DWORD           dwIfIndex;

    DWORD           dwIfNextHopAddr;
    
} TIMER_CONTEXT, *PTIMER_CONTEXT;



DWORD
DeleteFromForwarder(
    DWORD                       dwEntryCount,
    PIPMCAST_DELETE_MFE         pimdmMfes
);

VOID
MFETimerProc(
    PVOID                       pvContext,
    BOOLEAN                     pbFlag                        
);

#endif //_TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mprmsg\makefile.inc ===
$(O)\mprmsg.mc: ..\inc\mprlog.h $(SDK_INC_PATH)\mprerror.h $(SDK_INC_PATH)\raserror.h
    mapmsg ROUTER ROUTER_LOG_BASE ..\inc\mprlog.h > $(O)\mprmsg.mc
    mapmsg -a $(O)\mprmsg.mc ROUTER ROUTEBASE $(SDK_INC_PATH)\mprerror.h
    mapmsg -a $(O)\mprmsg.mc ROUTER RASBASE $(SDK_INC_PATH)\raserror.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mprmsg\evttbl.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:


Abstract:


--*/

#pragma once

#include <mprlog.h>

typedef struct _SUBCOMP_ENTRY
{
    PWCHAR          pwszSubComp;
    ULONG           ulEventCount;
    PDWORD          Events;
}SUBCOMP_ENTRY, *PSUBCOMP_ENTRY;

#define CreateSubcompEntry(n, t)    \
    {n, sizeof(t)/sizeof(DWORD), t}

typedef struct _COMP_ENTRY
{
    PWCHAR          pwszComponent;
    ULONG           ulSubcompCount;
    PSUBCOMP_ENTRY  SubcompInfo;
}COMP_ENTRY, *PCOMP_ENTRY;

#define CreateCompEntry(w,t)        \
    {w, sizeof(t)/sizeof(SUBCOMP_ENTRY), t}


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Define your tables here                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD ppp_auth[] = {
    ROUTERLOG_AUTH_FAILURE,
    ROUTERLOG_AUTH_SUCCESS,
    ROUTERLOG_AUTH_CONVERSATION_FAILURE,
    ROUTERLOG_CANT_ADD_RASSECURITYNAME,
    ROUTERLOG_SESSOPEN_REJECTED,
    ROUTERLOG_SECURITY_NET_ERROR,
    ROUTERLOG_CANNOT_INIT_SEC_ATTRIBUTE,
    ROUTERLOG_CANNOT_REGISTER_LSA,
    ROUTERLOG_AUTH_TIMEOUT,
    ROUTERLOG_AUTH_NO_PROJECTIONS,
    ROUTERLOG_AUTH_INTERNAL_ERROR,
    ROUTERLOG_NO_DIALIN_PRIVILEGE,
    ROUTERLOG_ENCRYPTION_REQUIRED,
    ROUTERLOG_NO_SECURITY_CHECK,
    ROUTERLOG_PASSWORD_EXPIRED,
    ROUTERLOG_ACCT_EXPIRED,
    ROUTERLOG_SEC_AUTH_FAILURE,
    ROUTERLOG_SEC_AUTH_INTERNAL_ERROR,
    ROUTERLOG_AUTH_DIFFUSER_FAILURE,
    ROUTERLOG_LICENSE_LIMIT_EXCEEDED
};

SUBCOMP_ENTRY ppp_table[] = {
    CreateSubcompEntry(L"auth", ppp_auth),
};


COMP_ENTRY ppp_info[]  = {
    CreateCompEntry(L"RemoteAccess", ppp_table),
};

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Add your info to the global table                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

PCOMP_ENTRY g_Components[] = 
{
    ppp_info,
};

ULONG   g_ulCompCount = sizeof(g_Components)/sizeof(PCOMP_ENTRY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\asyframe.h ===
#define 	RECV_OVERFLOW	10  // preamb + postamb + ?

#define 	RESYNC_LEN		10 	// size of rcv default buffer


//*********** ASYNC PROTOCOL DEFINITIONS AND STRUCTURES *****************
#define		SOH_BCAST		0x01
#define		SOH_DEST		0x02

// if a type field exists, OR in this bit (i.e. TCP/IP,  IPX)
#define		SOH_TYPE		0x80

// if the frame went through coherency, OR in this bit
#define		SOH_COMPRESS	0x40

// if the frame has escape characters removed (ASCII 0-31) set this.
#define		SOH_ESCAPE		0x20


#define		SYN				0x16
#define		ETX				0x03

//*********** FRAME STRUCTURES
typedef struct preamble preamble;
struct preamble {

	UCHAR		syn;
	UCHAR		soh;
};

typedef struct postamble postamble;

struct postamble {

	UCHAR		etx;
	UCHAR		crclsb;
	UCHAR		crcmsb;
};


//*** Frame parsing....
#define     ETHERNET_HEADER_SIZE    14


//*** Ethernet type header
typedef struct ether_addr ether_addr;

struct ether_addr {
		UCHAR   dst[6];
	    UCHAR   src[6];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\mprmsg\mprmsg.c ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>

#include "evttbl.h"

BOOL
WINAPI
DLLMAIN(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID pUnused
    ) 
{
    switch(dwReason) {
        case DLL_PROCESS_ATTACH:

            DisableThreadLibraryCalls(hInstance);

            break;

        case DLL_PROCESS_DETACH:

            break;

        default:

            break;
    }

    return TRUE;
}

DWORD
GetEventIds(
    IN  PWCHAR  pwszComponent,
    IN  PWCHAR  pwszSubComponent,
    OUT PDWORD  pdwEventIds,
    OUT PULONG  pulEventCount
    )
{
    ULONG   i;

    PSUBCOMP_ENTRY  pInfo;

    pInfo = NULL;

    for(i = 0; i < g_ulCompCount; i++)
    {
        ULONG   j;

        if(_wcsicmp(pwszComponent,
                    g_Components[i]->pwszComponent) != 0)
        {
            continue;
        }

        for(j = 0; j < g_Components[i]->ulSubcompCount; j++)
        {
            if(_wcsicmp(pwszSubComponent,
                        g_Components[i]->SubcompInfo[j].pwszSubComp) == 0)
            {
                pInfo = &(g_Components[i]->SubcompInfo[j]);
                
                break;
            }
        }

        if(pInfo)
        {
            break;
        }
    }

    if(pInfo == NULL)
    {
        return ERROR_NOT_FOUND;
    }

    if(pInfo->ulEventCount > *pulEventCount)
    {
        *pulEventCount = pInfo->ulEventCount;

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pulEventCount = pInfo->ulEventCount;

    CopyMemory(pdwEventIds,
               pInfo->Events,
               (sizeof(DWORD) * pInfo->ulEventCount));
        
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\asyncall.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    asyncall.h

Abstract:

     This code include most of the 'h' files for rashub.c

Author:

    Thomas J. Dimitri (TommyD) 29-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

/* This flag enables the retrofitted support for old RAS compression and
** coherency, i.e. the scheme available on WFW311 and NT31 clients.  This
** support was added post-NT35 for inclusion in the NT-PPC release.  It looks
** to NDISWAN like a hardware specific compression.  (SteveC)
**
** Note: The 'CompressBCast' feature that allows user to control whether
**       broadcast frames are compressed is not supported here because the
**       ethernet header (from which NT31 determined a frame was a broadcast)
**       is not available in the new NDISWAN interface.  This was a tuning
**       feature, where data not likely to repeat (broadcasts) were eliminated
**       from the pattern buffer.  There should not be any functional problems
**       simply compressing broadcast frames since the receiver determines
**       whether decompression is required regardless of this setting.  Given
**       this, it's a mystery why TommyD bothered negotiating this with the
**       peer.  To avoid hitting non-default code paths on the clients we will
**       simply negotiate the old default (no compression), but will still
**       compress everything on the outgoing path.
*/

#include <ndis.h>
#include <ndiswan.h>
#include <asyncpub.h>

#include <xfilter.h>
#include <ntddser.h>

#include "asynchrd.h"

#include "frame.h"
#include "asyncsft.h"
#include "globals.h"
#include "asyframe.h"

//
//  Global constants.
//


#define PPP_ALL     (PPP_FRAMING | \
                     PPP_COMPRESS_ADDRESS_CONTROL | \
                     PPP_COMPRESS_PROTOCOL_FIELD | \
                     PPP_ACCM_SUPPORTED)

#define SLIP_ALL    (SLIP_FRAMING | \
                     SLIP_VJ_COMPRESSION | \
                     SLIP_VJ_AUTODETECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\asynchrd.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    async.c

Abstract:

    The main program for a ASYNC (Local Area Network Controller
    Am 7990) MAC driver.

Author:

    Anthony V. Ercolano (tonye) creation-date 19-Jun-1990

Environment:

    This driver is expected to work in DOS, OS2 and NT at the equivalent
    of kernal mode.

    Architecturally, there is an assumption in this driver that we are
    on a little endian machine.

Notes:

    optional-notes

Revision History:


--*/

#ifndef _ASYNCHARDWARE_
#define _ASYNCHARDWARE_

//
// All registers on the ASYNC are 16 bits.
//



//
// Masks for the normal summary bits in the transmit descriptor.
//
#define ASYNC_TRANSMIT_END_OF_PACKET       ((UCHAR)(0x01))
#define ASYNC_TRANSMIT_START_OF_PACKET     ((UCHAR)(0x02))
#define ASYNC_TRANSMIT_DEFERRED            ((UCHAR)(0x04))
#define ASYNC_TRANSMIT_ONE_RETRY           ((UCHAR)(0x08))
#define ASYNC_TRANSMIT_MORE_THAN_ONE_RETRY ((UCHAR)(0x10))
#define ASYNC_TRANSMIT_ANY_ERRORS          ((UCHAR)(0x40))
#define ASYNC_TRANSMIT_OWNED_BY_CHIP       ((UCHAR)(0x80))

//
// Set of masks to recover particular errors that a transmit can encounter.
//
#define ASYNC_TRANSMIT_TDR            ((USHORT)(0x03ff))
#define ASYNC_TRANSMIT_RETRY          ((USHORT)(0x0400))
#define ASYNC_TRANSMIT_LOST_CARRIER   ((USHORT)(0x0800))
#define ASYNC_TRANSMIT_LATE_COLLISION ((USHORT)(0x0100))
#define ASYNC_TRANSMIT_UNDERFLOW      ((USHORT)(0x4000))
#define ASYNC_TRANSMIT_BUFFER         ((USHORT)(0x8000))


#endif // _ASYNCHARDWARE_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\crc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    crc.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

// asyncmac.c will define the global parameters.
#include "globals.h"
#include "crctable.h"


USHORT
CalcCRC(
	register PUCHAR	Frame,
	register UINT	FrameSize)
{

	register USHORT  currCRC=0;

	// we use a do while for efficiency purposes in loop optimizations
	do {
		currCRC=crc_table[((currCRC >> 8) ^ *Frame++) & 0xff] ^ (currCRC << 8);
	} while(--FrameSize);

	return currCRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\asyncsft.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    asyncsft.h

Abstract:


Author:


Environment:

    This driver is expected to work in DOS, OS2 and NT at the equivalent
    of kernal mode.

    Architecturally, there is an assumption in this driver that we are
    on a little endian machine.

Notes:

    optional-notes

Revision History:


--*/

#ifndef _ASYNCSFT_
#define _ASYNCSFT_

//
// Memory tags
//
#define ASYNC_IOCTX_TAG     '1ysA'
#define ASYNC_INFO_TAG      '2ysA'
#define ASYNC_ADAPTER_TAG   '3ysA'
#define ASYNC_FRAME_TAG     '4ysA'
#define ASYNC_WORKITEM_TAG  '5ysA'

#define INLINE  __inline

//
//  UINT min(UINT a, UINT b)
//

#ifndef min
#define min(a, b)   ((a) <= (b) ? (a) : (b))
#endif

//
//  UINT max(UINT a, UINT b)
//

#ifndef max
#define max(a, b)   ((a) >= (b) ? (a) : (b))
#endif


#define MAKEWORD(l, h)                  ((USHORT) ((l) | ((h) << 8)))
#define MAKELONG(l, h)                  ((ULONG)  ((l) | ((h) << 16)))
#define MAKE_SIGNATURE(a, b, c, d)      MAKELONG(MAKEWORD(a, b), MAKEWORD(c, d))


#define ASYNC_NDIS_MAJOR_VERSION 4
#define ASYNC_NDIS_MINOR_VERSION 0

//  change these, just added these to compile.

#define ETHERNET_HEADER_SIZE    14

//  what window size to request on the line-up indication

#define ASYNC_WINDOW_SIZE       2

//
//  PPP uses CIPX, and VJ TCP/IP header compression
//  the frame gets expanded inplace when decompressed.
//

#define PPP_PADDING 128

#define MAC_NAME_SIZE           256

//
//  ZZZ These macros are peculiar to NT.
//

#define ASYNC_MOVE_MEMORY(Destination,Source,Length)  NdisMoveMemory(Destination,Source,Length)
#define ASYNC_ZERO_MEMORY(Destination,Length)         NdisZeroMemory(Destination,Length)


/* Added this macro to eliminate problems caused by Tommy's redefinition and
** hard-coding of MaxFrameSize for PPP.
*/
#define MaxFrameSizeWithPppExpansion(x) (((x)*2)+PPP_PADDING+100)

typedef struct _OID_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    PVOID           Context;
} OID_WORK_ITEM, *POID_WORK_ITEM;

//
//  Used to contain a queued operation.
//

typedef struct _ASYNC_PEND_DATA {
    PNDIS_REQUEST Next;
    struct _ASYNC_OPEN * Open;
    NDIS_REQUEST_TYPE RequestType;
} ASYNC_PEND_DATA, * PASYNC_PEND_DATA;


// o CRC errors are when the 16bit V.41 CRC check fails
// o TimeoutErrors occur when inter-character delays within
//   a frame are exceeded
// o AlignmentErrors occur when the SYN byte or ETX bytes which
//   mark the beginning and end of frames are not found.
// o The other errors are standard UART errors returned by the serial driver
typedef struct SERIAL_STATS SERIAL_STATS, *PSERIAL_STATS;
struct SERIAL_STATS {
    ULONG       CRCErrors;                      // Serial-like info only
    ULONG       TimeoutErrors;                  // Serial-like info only
    ULONG       AlignmentErrors;                // Serial-like info only
    ULONG       SerialOverrunErrors;            // Serial-like info only
    ULONG       FramingErrors;                  // Serial-like info only
    ULONG       BufferOverrunErrors;            // Serial-like info only
};

// The bytes transmitted, bytes received, frames received, frame transmitted
// are monitored for frame and bytes going to the output device or
// coming from the output device.  If software compression used, it
// is on top of this layer.
typedef struct GENERIC_STATS GENERIC_STATS, *PGENERIC_STATS;
struct GENERIC_STATS {
    ULONG       BytesTransmitted;               // Generic info
    ULONG       BytesReceived;                  // Generic info
    ULONG       FramesTransmitted;              // Generic info
    ULONG       FramesReceived;                 // Generic info
};

//
//  This macro will return a pointer to the reserved area of
//  a PNDIS_REQUEST.
//

#define PASYNC_PEND_DATA_FROM_PNDIS_REQUEST(Request) \
   ((PASYNC_PEND_DATA)((PVOID)((Request)->MacReserved)))

//
//  This macros returns the enclosing NdisRequest.
//

#define PNDIS_REQUEST_FROM_PASYNC_PEND_DATA(PendOp)\
   ((PNDIS_REQUEST)((PVOID)(PendOp)))

typedef struct ASYNC_CCB ASYNC_CCB, *PASYNC_CCB;

//  Every port will be atomically at some state.  Typically states go into
//  intermediate states when they go from from closed to open and vice-versa.

typedef enum _ASYNC_PORT_STATE {
    PORT_BOGUS,         //  PORT_BOGUS gets assigned the NULL value
    PORT_OPEN,          //  Port opened
    PORT_CLOSED,        //  Port closed
    PORT_CLOSING,       //  Port closing (cleaning up, deallocating)
    PORT_OPENING,       //  Port opening (checking arguments, allocating)
    PORT_FRAMING,       //  Port opened and sending/reading frames
} ASYNC_PORT_STATE;

//
//  The ASYNC_INFO structure is a per port field.  The ASYNC_CONNECTION
//  field is embedded in it because it also a per port field.
//

struct ASYNC_INFO {
    LIST_ENTRY          Linkage;
    ULONG               RefCount;
    ULONG               Flags;
#define OID_WORK_SCHEDULED  0x00000001

    PASYNC_ADAPTER      Adapter;        //  Back pointer to ADAPTER struct.
    PDEVICE_OBJECT      DeviceObject;   //  Pointer to device object.

    ASYNC_PORT_STATE    PortState;      //  OPEN, CLOSED, CLOSING, OPENING
    HANDLE              Handle;         //  Port handle
    PFILE_OBJECT        FileObject;     //  handle is dereferenced for IRPs
    KEVENT              ClosingEvent;   //  we use this event to synch closing
    KEVENT              DetectEvent;    //  sync the detect worker

    UINT                QualOfConnect;  //  Defined by NDIS
    ULONG               LinkSpeed;      //  in 100bps

    NDIS_HANDLE         hNdisEndPoint;
    NDIS_HANDLE         NdisLinkContext;
    LIST_ENTRY          DDCDQueue;


    ULONG               WaitMaskToUse ; // Wait mask used for reads.

    union {

        NDIS_WAN_GET_LINK_INFO  GetLinkInfo;    //... For OID requests.
        NDIS_WAN_SET_LINK_INFO  SetLinkInfo;

    };

    //  use for reading frames

    PASYNC_FRAME        AsyncFrame;     //  allocated for READs (one frame only)
    WORK_QUEUE_ITEM     WorkItem;       //  use to queue up first read thread
    UINT                BytesWanted;
    UINT                BytesRead;

    //... Statistics tracking

    SERIAL_STATS        SerialStats;    // Keep track of serial stats

    ULONG               In;
    ULONG               Out;
    UINT                ReadStackCounter;

    NDIS_SPIN_LOCK      Lock;
};


//
//  This structure, and it corresponding per port structures are
//  allocated when we get AddAdapter.
//

struct ASYNC_ADAPTER {

    //
    //  WAN information. for OID_WAN_GET_INFO request.
    //
    NDIS_WAN_INFO   WanInfo;

    //
    //  Keeps a reference count on the current number of uses of
    //  this adapter block.  Uses is defined to be the number of
    //  routines currently within the "external" interface.
    //
    LONG    RefCount;

    //
    // List of active ports
    //
    LIST_ENTRY  ActivePorts;

    //
    //  Spinlock to protect fields in this structure..
    //
    NDIS_SPIN_LOCK Lock;

    //
    //  Handle given by NDIS at MPInit
    //
    NDIS_HANDLE MiniportHandle;

    //
    //  Flag that when enabled lets routines know that a reset
    //  is in progress.
    //
    BOOLEAN ResetInProgress;

/*
    LIST_ENTRY  FramePoolHead;

    LIST_ENTRY  AllocPoolHead;
*/

    //  It will handle most file operations and transport
    //  operations known today.  You pay about 44 bytes
    //  per stacksize.  The registry parameter 'IrpStackSize'
    //  will change this default if it exists.
    UCHAR IrpStackSize;

    //  Here we default to the ethernet max frame size
    //  The regsitry parameter 'MaxFrameSize' will change
    //  this default if it exists.

    /* Note: This is meaningful only for non-PPP framing.  For PPP framing the
    **       value is currently the hard-coded DEFAULT_PPP_MAX_FRAME_SIZE.
    **       See also DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE;
    */
    ULONG MaxFrameSize;

    //
    //  Number of ports this adapter owns.
    //
    USHORT      NumPorts;

    //  How many frames to allocate per port.
    //  The registry parameter 'FramesPerPort' can change this value
    USHORT FramesPerPort;

    //  Minimum inter character timeout
    ULONG   TimeoutBase;

    //  Tacked on to TimeoutBase based on the baud rate
    ULONG   TimeoutBaud;

    //  Timeout to use to resync if a frame is dropped
    ULONG   TimeoutReSync;

    //
    // Serial driver should only complete sends when the
    // data hits the wire
    //
    ULONG   WriteBufferingEnabled;

    NPAGED_LOOKASIDE_LIST   AsyncFrameList;
};

//
//  Define Maximum number of bytes a protocol can read during a
//  receive data indication.
//
#define ASYNC_MAX_LOOKAHEAD DEFAULT_MAX_FRAME_SIZE

typedef struct _ASYNC_IO_CTX {
    BOOLEAN         Sync;
    KEVENT          Event;          // use this event to signal completion
    IO_STATUS_BLOCK IoStatus;       // use this to store Irp status
    PVOID           Context;
    union {
        SERIAL_STATUS       SerialStatus;
        SERIAL_QUEUE_SIZE   SerialQueueSize;
        SERIAL_TIMEOUTS     SerialTimeouts;
        SERIAL_CHARS        SerialChars;
        SERIAL_COMMPROP     CommProperties;
        UCHAR               EscapeChar;
        UCHAR               SerialPurge;
        ULONG               WaitMask;
        ULONG               WriteBufferingEnabled;
    };
} ASYNC_IO_CTX, *PASYNC_IO_CTX;

//
//  This macro will act a "epilogue" to every routine in the
//  *interface*.  It will check whether any requests need
//  to defer their processing.  It will also decrement the reference
//  count on the adapter.
//
//  NOTE: This really does nothing now since there is no DPC for the AsyncMac.
//  --tommyd
//
//  Note that we don't need to include checking for blocked receives
//  since blocked receives imply that there will eventually be an
//  interrupt.
//
//  NOTE: This macro assumes that it is called with the lock acquired.
//
//  ZZZ This routine is NT specific.
//
#define ASYNC_DO_DEFERRED(Adapter) \
{ \
    PASYNC_ADAPTER _A = (Adapter); \
    _A->References--; \
    NdisReleaseSpinLock(&_A->Lock); \
}


//
//  We define the external interfaces to the async driver.
//  These routines are only external to permit separate
//  compilation.  Given a truely fast compiler they could
//  all reside in a single file and be static.
//

NTSTATUS
AsyncSendPacket(
    IN PASYNC_INFO      AsyncInfo,
    IN PNDIS_WAN_PACKET WanPacket);

VOID
AsyncIndicateFragment(
    IN PASYNC_INFO  pInfo,
    IN ULONG        Error);

NTSTATUS
AsyncStartReads(
    PASYNC_INFO     pInfo);

NTSTATUS
AsyncSetupIrp(
    IN PASYNC_FRAME Frame,
    IN PIRP         irp);

VOID
SetSerialStuff(
    PIRP            irp,
    PASYNC_INFO     pInfo,
    ULONG           linkSpeed);

VOID
CancelSerialRequests(
    PASYNC_INFO     pInfo);

VOID
SetSerialTimeouts(
    PASYNC_INFO         pInfo,
    ULONG               linkSpeed);

VOID
SerialSetEscapeChar(
    PASYNC_INFO         pInfo,
    UCHAR               EscapeChar);

VOID
SerialSetWaitMask(
    PASYNC_INFO         pInfo,
    ULONG               WaitMask);

VOID
SerialSetEventChar(
    PASYNC_INFO         pInfo,
    UCHAR               EventChar);

VOID
InitSerialIrp(
    PIRP                irp,
    PASYNC_INFO         pInfo,
    ULONG               IoControlCode,
    ULONG               InputBufferLength);

NTSTATUS
AsyncAllocateFrames(
    IN  PASYNC_ADAPTER  Adapter,
    IN  UINT            NumOfFrames);

VOID
AsyncSendLineUp(
    PASYNC_INFO pInfo);

//
// mp.c
//
VOID    
MpHalt(
    IN NDIS_HANDLE  MiniportAdapterContext
    );

NDIS_STATUS
MpInit(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN  PNDIS_MEDIUM    MediumArray,
    IN  UINT            MediumArraySize,
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    );

NDIS_STATUS
MpQueryInfo(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    );

NDIS_STATUS
MpReconfigure(
    OUT PNDIS_STATUS    OpenErrorStatus,
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    );

NDIS_STATUS
MpReset(
    OUT PBOOLEAN        AddressingReset,
    IN  NDIS_HANDLE     MiniportAdapterContext
    );

NDIS_STATUS
MpSend(
    IN  NDIS_HANDLE         MiniportAdapterContext,
    IN  NDIS_HANDLE         NdisLinkHandle,
    IN  PNDIS_WAN_PACKET    Packet
    );

NDIS_STATUS
MpSetInfo(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesRead,
    OUT PULONG      BytesNeeded
    );

//
//  crc.c
//

USHORT
CalcCRC(
    PUCHAR  Frame,
    UINT    FrameSize);

//
//  pppcrc.c
//
USHORT
CalcCRCPPP(
    PUCHAR cp,
    UINT   len);


//
//  init.c
//

VOID
AsyncSetupExternalNaming(
    PDRIVER_OBJECT  DriverObject
    );

VOID
AsyncCleanupExternalNaming(VOID);

//
// io.c
//
PASYNC_IO_CTX
AsyncAllocateIoCtx(
    BOOLEAN AllocateSync,
    PVOID   Context
);

VOID
AsyncFreeIoCtx(
    PASYNC_IO_CTX   AsyncIoCtx
);

//
//   chkcomm.c
//

VOID
AsyncCheckCommStatus(
    IN PASYNC_INFO      pInfo);


//
//  send.c
//

NDIS_STATUS
AsyncTryToSendPacket(
    IN NDIS_HANDLE      MacBindingHandle,
    IN PASYNC_INFO      AsyncInfo,
    IN PASYNC_ADAPTER   Adapter);

//
//  pppread.c
//
NTSTATUS
AsyncPPPWaitMask(
    IN PASYNC_INFO Info);

NTSTATUS
AsyncPPPRead(
    IN PASYNC_INFO Info);

//
//  irps.c
//
VOID
AsyncCancelQueued(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp);

VOID
AsyncCancelAllQueued(
    PLIST_ENTRY     QueueToCancel);

VOID
AsyncQueueIrp(
    PLIST_ENTRY     Queue,
    PIRP            Irp);

BOOLEAN
TryToCompleteDDCDIrp(
    PASYNC_INFO     pInfo);

//
//  pppframe.c
//

VOID
AssemblePPPFrame(
    PNDIS_WAN_PACKET Packet);

//
//  slipframe.c
//

VOID
AssembleSLIPFrame(
    PNDIS_WAN_PACKET Packet);

VOID
AssembleRASFrame(
        PNDIS_WAN_PACKET Packet);


//
// serial.c
//
NTSTATUS
SerialIoSyncCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);
    
NTSTATUS
SerialIoAsyncCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);

//
// asyncmac.c
//
NTSTATUS
AsyncDriverDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
AsyncDriverCreate(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

NTSTATUS
AsyncDriverCleanup(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

#endif //  _ASYNCSFT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\chkcomm.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    chkcomm.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#include "asyncall.h"

NTSTATUS
AsyncCheckCommStatusCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)

/*++



--*/
{
    NTSTATUS            status;
    PSERIAL_STATUS      pSerialStatus;
    PASYNC_IO_CTX AsyncIoCtx = (PASYNC_IO_CTX)Context;
    PASYNC_INFO         pInfo=AsyncIoCtx->Context;

    DeviceObject;       // prevent compiler warnings

    status = Irp->IoStatus.Status;
    pSerialStatus=(PSERIAL_STATUS)(Irp->AssociatedIrp.SystemBuffer);

    DbgTracef(0,("ACCSCR: s=$%x\n",status));

    switch (status) {
    case STATUS_SUCCESS:

        if (pSerialStatus->Errors & SERIAL_ERROR_FRAMING) {
            DbgTracef(-1,("ACCSCR: Framing error\n"));
            pInfo->SerialStats.FramingErrors++;
        }

        if (pSerialStatus->Errors & SERIAL_ERROR_OVERRUN) {
            DbgTracef(-1,("ACCSCR: Overrun error \n"));
            pInfo->SerialStats.SerialOverrunErrors++;
        }

        if (pSerialStatus->Errors & SERIAL_ERROR_QUEUEOVERRUN) {
            DbgTracef(-1,("ACCSCR: Q-Overrun error\n"));
            pInfo->SerialStats.BufferOverrunErrors++;
        }

        //
        // Keep proper count of errors
        //
        AsyncIndicateFragment(
            pInfo,
            pSerialStatus->Errors);

        // Fall through...

    default:
        //
        // Free up memory we used to make this call
        //
        IoFreeIrp(Irp);
        AsyncFreeIoCtx(AsyncIoCtx);
    }

    //
    //  We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    //

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

VOID
AsyncCheckCommStatus(
    IN PASYNC_INFO  pInfo)
/*++

    This is the Worker Thread entry for reading comm status errors

--*/
{
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    PDEVICE_OBJECT      deviceObject=pInfo->DeviceObject;
    PFILE_OBJECT        fileObject=pInfo->FileObject;
    PASYNC_IO_CTX       AsyncIoCtx;
    NTSTATUS            status;

    irp=IoAllocateIrp(deviceObject->StackSize, (BOOLEAN)FALSE);

    //
    // Are we out of irps?  Oh no!
    //
    if (irp==NULL) {
        return;
    }

    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;
    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = NULL;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    irp->Flags = IRP_BUFFERED_IO;
    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialStatus;

    irpSp = IoGetNextIrpStackLocation(irp);


    irpSp->FileObject = fileObject;
    if (fileObject->Flags & FO_WRITE_THROUGH) {
        irpSp->Flags = SL_WRITE_THROUGH;
    }


    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode=IOCTL_SERIAL_GET_COMMSTATUS;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(SERIAL_STATUS);

    IoSetCompletionRoutine(
            irp,                            // irp to use
            AsyncCheckCommStatusCompletionRoutine,      // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel


    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(deviceObject, irp);

    DbgTracef(0,("ACCS: IoctlGetCommStatus returned with 0x%.8x\n", status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\debug.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\asyncmac.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    async.c

Abstract:

    This is the main file for the AsyncMAC Driver for the Remote Access
    Service.  This driver conforms to the NDIS 3.0 interface.

    This driver was adapted from the LANCE driver written by
    TonyE.

    NULL device driver code from DarrylH.

    The idea for handling loopback and sends simultaneously is largely
    adapted from the EtherLink II NDIS driver by Adam Barr.

Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#include "asyncall.h"

// asyncmac.c will define the global parameters.
#define GLOBALS
#include "globals.h"


NDIS_HANDLE NdisWrapperHandle;
PDRIVER_OBJECT  AsyncDriverObject;
NDIS_HANDLE     AsyncDeviceHandle;
NPAGED_LOOKASIDE_LIST   AsyncIoCtxList;
NPAGED_LOOKASIDE_LIST   AsyncInfoList;
ULONG   glConnectionCount = 0;

VOID
AsyncUnload(
    IN NDIS_HANDLE MacMacContext
    );

NDIS_STATUS
AsyncFillInGlobalData(
    IN PASYNC_ADAPTER Adapter,
    IN PNDIS_REQUEST NdisRequest);

//
// Define the local routines used by this driver module.
//

NTSTATUS
AsyncIOCtlRequest(
    IN PIRP pIrp,                       // Pointer to I/O request packet
    IN PIO_STACK_LOCATION pIrpSp        // Pointer to the IRP stack location
);


//
// ZZZ Portable interface.
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath)


/*++

Routine Description:

    This is the primary initialization routine for the async driver.
    It is simply responsible for the intializing the wrapper and registering
    the MAC.  It then calls a system and architecture specific routine that
    will initialize and register each adapter.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The status of the operation.

--*/

{
    NDIS_STATUS InitStatus;
    NDIS_MINIPORT_CHARACTERISTICS AsyncChar;

    //
    // Initialize some globals
    //
    ExInitializeNPagedLookasideList(&AsyncIoCtxList,
        NULL,
        NULL,
        0,
        sizeof(ASYNC_IO_CTX),
        ASYNC_IOCTX_TAG,
        0);

    ExInitializeNPagedLookasideList(&AsyncInfoList,
        NULL,
        NULL,
        0,
        sizeof(ASYNC_INFO),
        ASYNC_INFO_TAG,
        0);

    NdisAllocateSpinLock(&GlobalLock);

    AsyncDriverObject = DriverObject;

    //
    //  Initialize the wrapper.
    //
    NdisMInitializeWrapper(&NdisWrapperHandle,
                           DriverObject,
                           RegistryPath,
                           NULL);

    //
    //  Initialize the MAC characteristics for the call to NdisRegisterMac.
    //
    NdisZeroMemory(&AsyncChar, sizeof(AsyncChar));

    AsyncChar.MajorNdisVersion = ASYNC_NDIS_MAJOR_VERSION;
    AsyncChar.MinorNdisVersion = ASYNC_NDIS_MINOR_VERSION;
    AsyncChar.Reserved = NDIS_USE_WAN_WRAPPER;

    //
    // We do not need the following handlers:
    // CheckForHang
    // DisableInterrupt
    // EnableInterrupt
    // HandleInterrupt
    // ISR
    // Send
    // TransferData
    //
    AsyncChar.HaltHandler = MpHalt;
    AsyncChar.InitializeHandler = MpInit;
    AsyncChar.QueryInformationHandler = MpQueryInfo;
    AsyncChar.ReconfigureHandler = MpReconfigure;
    AsyncChar.ResetHandler = MpReset;
    AsyncChar.WanSendHandler = MpSend;
    AsyncChar.SetInformationHandler = MpSetInfo;

    InitStatus =
    NdisMRegisterMiniport(NdisWrapperHandle,
                          &AsyncChar,
                          sizeof(AsyncChar));

    if ( InitStatus == NDIS_STATUS_SUCCESS ) {

#if MY_DEVICE_OBJECT
        //
        // Initialize the driver object with this device driver's entry points.
        //
        NdisMjDeviceControl = DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL];
        NdisMjCreate = DriverObject->MajorFunction[IRP_MJ_CREATE];
        NdisMjCleanup = DriverObject->MajorFunction[IRP_MJ_CLEANUP];

        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = AsyncDriverDispatch;
        DriverObject->MajorFunction[IRP_MJ_CREATE]  = AsyncDriverCreate;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP]  = AsyncDriverCleanup;

        AsyncSetupExternalNaming(DriverObject);
#endif

        NdisUnload = DriverObject->DriverUnload;
        DriverObject->DriverUnload = AsyncUnload;

        DbgTracef(0,("AsyncMAC succeeded to Register MAC\n"));

        return NDIS_STATUS_SUCCESS;
    }

    ExDeleteNPagedLookasideList(&AsyncIoCtxList);
    ExDeleteNPagedLookasideList(&AsyncInfoList);

    NdisTerminateWrapper(NdisWrapperHandle, DriverObject);

    return NDIS_STATUS_FAILURE;
}

NTSTATUS
AsyncDriverCreate(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != AsyncDeviceObject) {

        return(NdisMjCreate(pDeviceObject, pIrp));
    }
#endif

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return (STATUS_SUCCESS);

}

NTSTATUS
AsyncDriverCleanup(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != AsyncDeviceObject) {

        return(NdisMjCleanup(pDeviceObject, pIrp));
    }
#endif

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return (STATUS_SUCCESS);
}

NTSTATUS
AsyncDriverDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)

/*++

Routine Description:

    This routine is the main dispatch routine for the AsyncMac device
    driver.  It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.


--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    ULONG   ulDeviceType;
    ULONG   ulMethod;

    // 
    // if this is win64 make sure the calling process is 64bit
    // since this interface is only used by rasman and rasman
    // will always be 64bit on 64bit systems we will not bother
    // with thunking.  if the process is not a 64bit process get
    // out.
#ifdef _WIN64
    if (IoIs32bitProcess(Irp)) {
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return (STATUS_NOT_SUPPORTED);
    }
#endif

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ulDeviceType = (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16) & 0x0000FFFF;
    ulMethod = irpSp->Parameters.DeviceIoControl.IoControlCode & 0x00000003;

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
        (ulDeviceType != FILE_DEVICE_ASYMAC) ||
        (DeviceObject != AsyncDeviceObject)) {

        return(NdisMjDeviceControl(DeviceObject, Irp));
    }
#else
    if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
        (ulDeviceType != FILE_DEVICE_NETWORK) ||
        (DeviceObject != AsyncDeviceObject) ||
        (ulMethod != METHOD_BUFFERED)) {

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return (STATUS_NOT_SUPPORTED);
    }
#endif

    status = AsyncIOCtlRequest(Irp, irpSp);

    switch (status) {
        case STATUS_SUCCESS:
            break;

        case STATUS_PENDING:
            return(status);

        case STATUS_INFO_LENGTH_MISMATCH:
            //
            // See if this was a request to get size needed for
            // ioctl.
            //
            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= 
                sizeof(ULONG)) {
                *(PULONG_PTR)Irp->AssociatedIrp.SystemBuffer = 
                    Irp->IoStatus.Information;
                Irp->IoStatus.Information = sizeof(ULONG);
            } else {
                Irp->IoStatus.Information = 0;
            }
            status = STATUS_SUCCESS;
        break;

        default:
            if (status < 0xC0000000) {
                status = STATUS_UNSUCCESSFUL;
            }
            Irp->IoStatus.Information = 0;
            break;
    }

    //
    // Copy the final status into the return status, 
    // complete the request and get out of here.
    //

    Irp->IoStatus.Status = status;

    IoCompleteRequest( Irp, (UCHAR)0 );

    return (status);
}

VOID
AsyncUnload(
    PDRIVER_OBJECT  DriverObject
    )

/*++

Routine Description:

    AsyncUnload is called when the MAC is to unload itself.

Arguments:

    MacMacContext - not used.

Return Value:

    None.

--*/

{
    ExDeleteNPagedLookasideList(&AsyncIoCtxList);
    ExDeleteNPagedLookasideList(&AsyncInfoList);

#ifdef MY_DEVICE_OBJECT
    AsyncCleanupExternalNaming();
#endif

    (*NdisUnload)(DriverObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\crcppp.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    crcppp.c

Abstract:

Author:

    Thomas J. Dimitri  (TommyD)

Environment:

Revision History:

--*/
#include "asyncall.h"

//
// FCS lookup table as calculated by the table generator in section
// B.2.
//

static USHORT fcstab[256] = {
      0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
      0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
      0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
      0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
      0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
      0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
      0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
      0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
      0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
      0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
      0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
      0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
      0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
      0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
      0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
      0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
      0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
      0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
      0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
      0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
      0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
      0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
      0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
      0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
      0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
      0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
      0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
      0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
      0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
      0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
      0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
      0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

#define PPPINITFCS      0xffff  /* Initial FCS value */
#define PPPGOODFCS      0xf0b8  /* Good final FCS value */

//
// Calculate a new fcs given the current fcs and the new data.
//
USHORT
CalcCRCPPP(
	PUCHAR cp,
	UINT   len)
{
	register USHORT fcs = PPPINITFCS;

	while (len--)
		fcs = (fcs >> 8) ^ fcstab[(fcs ^ *cp++) & 0xff];

	return (fcs);
}













=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\crcppp.h ===
//
// u16 represents an unsigned 16-bit number.  Adjust the typedef for
// your hardware.
//

typedef unsigned short u16;


//
// FCS lookup table as calculated by the table generator in section
// B.2.
//

static USHORT fcstab[256] = {
      0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
      0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
      0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
      0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
      0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
      0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
      0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
      0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
      0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
      0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
      0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
      0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
      0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
      0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
      0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
      0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
      0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
      0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
      0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
      0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
      0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
      0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
      0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
      0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
      0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
      0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
      0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
      0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
      0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
      0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
      0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
      0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

#define PPPINITFCS      0xffff  /* Initial FCS value */
#define PPPGOODFCS      0xf0b8  /* Good final FCS value */

//
// Calculate a new fcs given the current fcs and the new data.
//
USHORT
pppfcs(
	UCHAR cp,
	UINT  len)
{
	register USHORT fcs = 0;

	while (len--)
		fcs = (fcs >> 8) ^ fcstab[(fcs ^ *cp++) & 0xff];

	return (fcs);
}













=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\data.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    data.c

Abstract:

     This source file contains global data items.

Author:

    RAy Patch  (raypa) 04/19/94

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#include "asyncall.h"

//
// We use the global below to daisy chain the IOCtl.
//

PDISPATCH_FUNC NdisMjDeviceControl = NULL;
PDISPATCH_FUNC NdisMjCreate = NULL;
PDISPATCH_FUNC NdisMjCleanup = NULL;
PDRIVER_UNLOAD	NdisUnload = NULL;

//
// TraceLevel is used for DbgTracef printing.  If the trace_level
// is less than or equal to TraceLevel, the message will be printed.
//

SCHAR TraceLevel = -2;

//
// This struct keeps track of the last Adapter as well
// as all the Adapters opened so far.
//

PASYNC_ADAPTER	GlobalAdapter = NULL;

//
// Keep track of how many adapters we have total.
//

ULONG GlobalAdapterCount = 0;

//
//  Keep track of sends.
//

ULONG GlobalXmitWentOut = 0;

//
// Use this lock when playing with the GlobalAdapterHead or other
// global variables.
//

NDIS_SPIN_LOCK GlobalLock;

NDIS_PHYSICAL_ADDRESS HighestAcceptableMax = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);

PDEVICE_OBJECT	AsyncDeviceObject = NULL;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\detect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    detect.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#include "asyncall.h"

VOID
SerialFlushReads(
    PASYNC_INFO         pInfo);


NTSTATUS
AsyncDetectCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PASYNC_INFO      pInfo)

/*++

    This is the IO Completion routine for ReadFrame.

--*/
{
    NTSTATUS        status;
    PASYNC_FRAME    pFrame;
    PUCHAR          frameStart;

    DbgTracef(-1,("Entering AsyncDetectCompletionRoutine\n"));

    status = Irp->IoStatus.Status;

    pInfo->BytesRead = (ULONG)Irp->IoStatus.Information;

    IoFreeIrp(Irp);

    pFrame=pInfo->AsyncFrame;

    DbgTracef(2,("DET PortState = %u for Info 0x%.8x\n", pInfo->PortState, pInfo));

    //
    // check if this port is closing down or already closed
    //
    if (pInfo->PortState == PORT_CLOSING ||
        pInfo->PortState == PORT_CLOSED) {

        if (pInfo->PortState == PORT_CLOSED) {
            DbgTracef(-2,("ASYNC: Port closed - but still reading on it!\n"));
        }

        //
        // Acknowledge that the port is closed
        //
        KeSetEvent(
            &pInfo->ClosingEvent,       // Event
            1,                          // Priority
            (BOOLEAN)FALSE);            // Wait (does not follow)

        //
        // Ok, if this happens, we are shutting down.  Stop
        // posting reads.  Don't make it try to deallocate the irp!
        //
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //
    // If the port is close and we are still posting reads, something
    // is seriously wrong here!
    //

    if (pInfo->PortState == PORT_CLOSED) {
        DbgTracef(-2, ("ASYNC: !!Whoa, I'm reading bytes on a dead port!!\n"));
    }


    //
    //  Send off a irp to check comm status
    //

    AsyncCheckCommStatus(pInfo);

    switch (status) {

    case STATUS_SUCCESS:

        //
        // Look at the first byte and see if we can
        // detect the framing.
        //
        frameStart=pFrame->Frame + PPP_PADDING;

        //
        // NOTE: New RAS framing clients come in with 0x02 not 0x01
        //
        if (frameStart[0] == SYN && (frameStart[1]==0x01 || frameStart[1] == 0x02)) {
            ULONG   bytesWanted;
            PUCHAR  frameStart2;

            pInfo->SetLinkInfo.SendFramingBits =
            pInfo->SetLinkInfo.RecvFramingBits = RAS_FRAMING;

            DbgTracef(-1,("ASYNC: RAS framing detected\n"));

            frameStart2=pFrame->Frame+10;

            //
            // Adjust buffer for old RAS read
            //
            ASYNC_MOVE_MEMORY(
                frameStart2,
                frameStart,
                6);

            frameStart=frameStart2;

            bytesWanted=(frameStart[2]*256)+(frameStart[3]);

            if (bytesWanted > (ULONG)(max( pInfo->Adapter->MaxFrameSize, DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE ))) {

                DbgTracef(-1,("---ASYNC: Frame too large -- size: %d!\n", bytesWanted));
                //
                // set frame start to non-SYN character
                //
                *frameStart = 0;
                pInfo->BytesRead=0;
                pInfo->BytesWanted=6;

                //
                // break added to fix problem where frame has length
                // greater than max frame size.  This will send us back
                // to detect the next frame!  Added 10/31/95 by TonyBe.
                //
                break;
            }

            // if this is the first we posted, post another to get
            // rest of frame.
            if (pInfo->BytesRead == 6) {

                pInfo->BytesRead=6;
                pInfo->BytesWanted=bytesWanted +
                                    // SYN+SOH+LEN+ETX+CRC
                                        1 + 1 + 2 + 1 + 2 -
                                        6;

                DbgTracef(2,("---Posting second read for %d bytes\n",pInfo->BytesWanted));
            }

        } else

            //
            // It turns out that NetManage send the flag byte at the
            // end always.  This means taht their first frame is wrong.
            // Anyway, this throws off the detect routine.  So, we
            // will be robust and accept frames without the FLAG_BYTE.
            //

            if ((frameStart[0] == PPP_FLAG_BYTE && frameStart[1]==0xFF) ||
                (frameStart[0] == 0xFF && frameStart[1]==PPP_ESC_BYTE)) {

                pInfo->SetLinkInfo.SendFramingBits =
                pInfo->SetLinkInfo.RecvFramingBits = PPP_FRAMING;
                pInfo->SetLinkInfo.SendACCM=0xFFFFFFFF;

                DbgTracef(-1,("ASYNC: PPP framing detected\n"));

            }
            else {

                //
                // Read again!
                //

                DbgTracef(-1,("ASYNC: No framing detected yet\n"));
                DbgTracef(-1,("ASYNC: Got %.2x %.2x %.2x %.2x %.2x %.2x\n",
                            frameStart[0],
                            frameStart[1],
                            frameStart[2],
                            frameStart[3],
                            frameStart[4],
                            frameStart[5]));

                break;
            }


        //
        // set framing mode active
        //
        pInfo->PortState = PORT_FRAMING;

        //
        //  Send off the worker thread to start reading frames
        //  off this port - we want to be at passive level otherwise
        //  it don't work.
        //
    
        ExInitializeWorkItem(&(pInfo->WorkItem),
                             (PWORKER_THREAD_ROUTINE)AsyncStartReads,
                             pInfo);
        
        ExQueueWorkItem(&(pInfo->WorkItem), DelayedWorkQueue);

        return(STATUS_MORE_PROCESSING_REQUIRED);

    case STATUS_TIMEOUT:
        DbgTracef(-1,("---ASYNC: detect Status %x%0.8x on read\n", status));
        break;

    case STATUS_CANCELLED:
    case STATUS_PORT_DISCONNECTED:
    default:
        return(STATUS_MORE_PROCESSING_REQUIRED);

    }

    //
    // Wipe out rest of this buffer
    //
    SerialFlushReads(pInfo);

    KeClearEvent(&pInfo->DetectEvent);

    //
    // Here we are at the end of processing this IRP so we go
    // ahead and post another read from the serial port.
    //
    // this is done on a worker since we run out of stack otherwise
    //
    ExInitializeWorkItem(&(pInfo->WorkItem),
                         (PWORKER_THREAD_ROUTINE) AsyncDetectRead,
                         pInfo);

    ExQueueWorkItem(&(pInfo->WorkItem), DelayedWorkQueue);

    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    //
    return(STATUS_MORE_PROCESSING_REQUIRED);
}


NTSTATUS
AsyncDetectRead(
    IN PASYNC_INFO pInfo)

/*++

--*/
{
    NTSTATUS            status;
    PIRP                irp;
    PDEVICE_OBJECT      deviceObject=pInfo->DeviceObject;
    PFILE_OBJECT        fileObject=pInfo->FileObject;
    PIO_STACK_LOCATION  irpSp;
    PASYNC_FRAME        pFrame;
    PASYNC_ADAPTER      pAdapter=pInfo->Adapter;

    DbgTracef(-1,("Entering AsyncDetectRead\n"));

    do {

        if (pInfo->PortState == PORT_CLOSING ||
            pInfo->PortState == PORT_CLOSED) {

            status = STATUS_SUCCESS;
            break;
        }

        // get ptr to first frame in list...
        pFrame=pInfo->AsyncFrame;

        irp =
            IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

        // Setup this irp with defaults
        AsyncSetupIrp(pFrame, irp);

        irp->AssociatedIrp.SystemBuffer =
        irp->UserBuffer =
             pFrame->Frame + PPP_PADDING;

        //
        // Get a pointer to the stack location for the first driver.  This will be
        // used to pass the original function codes and parameters.
        //

        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_READ;
        irpSp->FileObject = fileObject;
        if (fileObject->Flags & FO_WRITE_THROUGH) {
            irpSp->Flags = SL_WRITE_THROUGH;
        }

        //
        // If this write operation is to be performed without any caching, set the
        // appropriate flag in the IRP so no caching is performed.
        //

        irp->Flags |= IRP_READ_OPERATION;

        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
            irp->Flags |= IRP_NOCACHE;
        }

        //
        // Copy the caller's parameters to the service-specific portion of the
        // IRP.
        //

        irpSp->Parameters.Read.Length = 6;                  // from frame...
        irpSp->Parameters.Read.Key = 0;                     // we don't use a key
        irpSp->Parameters.Read.ByteOffset = fileObject->CurrentByteOffset;

        IoSetCompletionRoutine(
                irp,                            // irp to use
                AsyncDetectCompletionRoutine,   // routine to call when irp is done
                pInfo,                          // context to pass routine
                TRUE,                           // call on success
                TRUE,                           // call on error
                TRUE);                          // call on cancel

        //
        // We DO NOT insert the packet at the head of the IRP list for the thread.
        // because we do NOT really have an IoCompletionRoutine that does
        // anything with the thread.
        //

        //
        // Now simply invoke the driver at its dispatch entry with the IRP.
        //

        status = IoCallDriver(deviceObject, irp);

    } while (FALSE);

    KeSetEvent(&pInfo->DetectEvent,
               1,
               FALSE);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\crctable.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    crctable.h

Abstract:

	This module is used to take apart NBF Frames and print what LLC
	and/or NetBIOS Frame is being sent (or received).

Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

UCHAR	dst_addr[6] = {' ', 'D', 'E', 'S', 'T', ' '};
UCHAR	src_addr[6] = {' ', 'S', 'R', 'C', ' ', ' '};
UCHAR	bcast_addr[6] = {0x03, 0x00, 0x00, 0x00, 0x00, 0x01};

//*** CRC table

static USHORT crc_table[256] = {

	0x0000,
	0x1021,
	0x2042,
	0x3063,
	0x4084,
	0x50a5,
	0x60c6,
	0x70e7,
	0x8108,
	0x9129,
	0xa14a,
	0xb16b,
	0xc18c,
	0xd1ad,
	0xe1ce,
	0xf1ef,
	0x1231,
	0x0210,
	0x3273,
	0x2252,
	0x52b5,
	0x4294,
	0x72f7,
	0x62d6,
	0x9339,
	0x8318,
	0xb37b,
	0xa35a,
	0xd3bd,
	0xc39c,
	0xf3ff,
	0xe3de,
	0x2462,
	0x3443,
	0x0420,
	0x1401,
	0x64e6,
	0x74c7,
	0x44a4,
	0x5485,
	0xa56a,
	0xb54b,
	0x8528,
	0x9509,
	0xe5ee,
	0xf5cf,
	0xc5ac,
	0xd58d,
	0x3653,
	0x2672,
	0x1611,
	0x0630,
	0x76d7,
	0x66f6,
	0x5695,
	0x46b4,
	0xb75b,
	0xa77a,
	0x9719,
	0x8738,
	0xf7df,
	0xe7fe,
	0xd79d,
	0xc7bc,
	0x48c4,
	0x58e5,
	0x6886,
	0x78a7,
	0x0840,
	0x1861,
	0x2802,
	0x3823,
	0xc9cc,
	0xd9ed,
	0xe98e,
	0xf9af,
	0x8948,
	0x9969,
	0xa90a,
	0xb92b,
	0x5af5,
	0x4ad4,
	0x7ab7,
	0x6a96,
	0x1a71,
	0x0a50,
	0x3a33,
	0x2a12,
	0xdbfd,
	0xcbdc,
	0xfbbf,
	0xeb9e,
	0x9b79,
	0x8b58,
	0xbb3b,
	0xab1a,
	0x6ca6,
	0x7c87,
	0x4ce4,
	0x5cc5,
	0x2c22,
	0x3c03,
	0x0c60,
	0x1c41,
	0xedae,
	0xfd8f,
	0xcdec,
	0xddcd,
	0xad2a,
	0xbd0b,
	0x8d68,
	0x9d49,
	0x7e97,
	0x6eb6,
	0x5ed5,
	0x4ef4,
	0x3e13,
	0x2e32,
	0x1e51,
	0x0e70,
	0xff9f,
	0xefbe,
	0xdfdd,
	0xcffc,
	0xbf1b,
	0xaf3a,
	0x9f59,
	0x8f78,
	0x9188,
	0x81a9,
	0xb1ca,
	0xa1eb,
	0xd10c,
	0xc12d,
	0xf14e,
	0xe16f,
	0x1080,
	0x00a1,
	0x30c2,
	0x20e3,
	0x5004,
	0x4025,
	0x7046,
	0x6067,
	0x83b9,
	0x9398,
	0xa3fb,
	0xb3da,
	0xc33d,
	0xd31c,
	0xe37f,
	0xf35e,
	0x02b1,
	0x1290,
	0x22f3,
	0x32d2,
	0x4235,
	0x5214,
	0x6277,
	0x7256,
	0xb5ea,
	0xa5cb,
	0x95a8,
	0x8589,
	0xf56e,
	0xe54f,
	0xd52c,
	0xc50d,
	0x34e2,
	0x24c3,
	0x14a0,
	0x0481,
	0x7466,
	0x6447,
	0x5424,
	0x4405,
	0xa7db,
	0xb7fa,
	0x8799,
	0x97b8,
	0xe75f,
	0xf77e,
	0xc71d,
	0xd73c,
	0x26d3,
	0x36f2,
	0x0691,
	0x16b0,
	0x6657,
	0x7676,
	0x4615,
	0x5634,
	0xd94c,
	0xc96d,
	0xf90e,
	0xe92f,
	0x99c8,
	0x89e9,
	0xb98a,
	0xa9ab,
	0x5844,
	0x4865,
	0x7806,
	0x6827,
	0x18c0,
	0x08e1,
	0x3882,
	0x28a3,
	0xcb7d,
	0xdb5c,
	0xeb3f,
	0xfb1e,
	0x8bf9,
	0x9bd8,
	0xabbb,
	0xbb9a,
	0x4a75,
	0x5a54,
	0x6a37,
	0x7a16,
	0x0af1,
	0x1ad0,
	0x2ab3,
	0x3a92,
	0xfd2e,
	0xed0f,
	0xdd6c,
	0xcd4d,
	0xbdaa,
	0xad8b,
	0x9de8,
	0x8dc9,
	0x7c26,
	0x6c07,
	0x5c64,
	0x4c45,
	0x3ca2,
	0x2c83,
	0x1ce0,
	0x0cc1,
	0xef1f,
	0xff3e,
	0xcf5d,
	0xdf7c,
	0xaf9b,
	0xbfba,
	0x8fd9,
	0x9ff8,
	0x6e17,
	0x7e36,
	0x4e55,
	0x5e74,
	0x2e93,
	0x3eb2,
	0x0ed1,
	0x1ef0 };


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\frame.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    frame.h

Abstract:

Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

// first, some default values

// the ethernet max frame size is 1500+6+6+2  = 1514

/* Note that this only applies to non-PPP framing.  See below.
*/
#define DEFAULT_MAX_FRAME_SIZE  1514

/* The hard-coded PPP maximum frame sizes for send and receive paths.
**
** Note:  TommyD had these hard-coded.  I have simply made this more explicit
**        by removing their attachment to MaxFrameSize which was causing
**        problems for NT31 RAS compression.  The doubling is for PPP
**        byte-stuffing, the PPP_PADDING to adjust for possible VJ expansion,
**        and the 100...well, ask TommyD...and the 14 to limit exposure, i.e.
**        wind up with the exact number TommyD was using.
*/
#define DEFAULT_PPP_MAX_FRAME_SIZE          1500
#define DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE ((DEFAULT_PPP_MAX_FRAME_SIZE*2)+PPP_PADDING+100+14)

// ChuckL says 5 is a good default irp stack size
// perhaps we should lower this though since it's typically just 1
// but what if the com port is redirected??
#define DEFAULT_IRP_STACK_SIZE  5

#define SLIP_END_BYTE       192
#define SLIP_ESC_BYTE       219
#define SLIP_ESC_END_BYTE   220
#define SLIP_ESC_ESC_BYTE   221


#define PPP_FLAG_BYTE       0x7e
#define PPP_ESC_BYTE        0x7d


// define the number of framesPerPort

/* The NT35 setting, where sends are IRPed directly from the input buffer
** passed down from NDISWAN.
*/
#define DEFAULT_FRAMES_PER_PORT 1

// define if xon/xoff capability is on by default (off)
#define DEFAULT_XON_XOFF    0

// the mininmum timeout value per connection in ms
#define DEFAULT_TIMEOUT_BASE 500

// the multiplier based on the baud rate tacked on to the base in ms
#define DEFAULT_TIMEOUT_BAUD 28800

// the timeout to use if we drop a frame in ms
#define DEFAULT_TIMEOUT_RESYNC 500


typedef struct ASYNC_FRAME_HEADER ASYNC_FRAME_HEADER, *PASYNC_FRAME_HEADER;

struct ASYNC_FRAME_HEADER {
    UCHAR   SyncByte;           // 0x16
    UCHAR   FrameType;          // 0x01, 0x02 (directed vs. multicast)
                                // 0x08 compression
    UCHAR   HighFrameLength;
    UCHAR   LowFrameLength;
};

typedef struct ASYNC_FRAME_TRAILER ASYNC_FRAME_TRAILER, *PASYNC_FRAME_TRAILER;

struct ASYNC_FRAME_TRAILER {
    UCHAR   EtxByte;            // 0x03
    UCHAR   LowCRCByte;
    UCHAR   HighCRCByte;
};

typedef ULONG  FRAME_ID;

typedef struct ASYNC_ADAPTER ASYNC_ADAPTER, *PASYNC_ADAPTER;
typedef struct ASYNC_INFO ASYNC_INFO, *PASYNC_INFO;
typedef struct ASYNC_FRAME ASYNC_FRAME, *PASYNC_FRAME;

struct ASYNC_FRAME {

    // For PPP/SLIP.

    ULONG       WaitMask;               // Mask bits when IRP completes
#if 0
    PIRP        Irp;                    // Irp allocated based on DefaultIrpStackSize.
#if DBG
    ULONG       Line;
    CHAR       *File;
#endif
#endif

    UINT        FrameLength;            // Size of Frame allocated.
    PUCHAR      Frame;                  // Buffer allocated based on
                                        // DefaultFrameSize

    WORK_QUEUE_ITEM WorkItem;           // For stack overflow reads

    PASYNC_ADAPTER      Adapter;        // back ptr to adapter
    PASYNC_INFO         Info;           // back ptr to info field

    NDIS_HANDLE     MacBindingHandle;
    NDIS_HANDLE     NdisBindingContext;
};

NTSTATUS
AsyncGetFrameFromPool(
    IN  PASYNC_INFO  Info,
    OUT PASYNC_FRAME *NewFrame );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\digiser.h ===
/*++

*****************************************************************************
*                                                                           *
*  This software contains proprietary and confidential information of       *
*                                                                           *
*                    Digi International Inc.                                *
*                                                                           *
*  By accepting transfer of this copy, Recipient agrees to retain this      *
*  software in confidence, to prevent disclosure to others, and to make     *
*  no use of this software other than that for which it was delivered.      *
*  This is an unpublished copyrighted work of Digi International Inc.       *
*  Except as permitted by federal law, 17 USC 117, copying is strictly      *
*  prohibited.                                                              *
*                                                                           *
*****************************************************************************

Module Name:

   digiser.h

Abstract:

   This file contains the recommended extensions to the Microsoft Windows NT
   Serial Interface (NTDDSER.H) needed to support hardware framing.

Revision History:

   $Log: digiser.h $

   Revision 1.3  1995/09/15 14:55:24  dirkh
   Remove SERIAL_ERROR_CRC (use STATUS_CRC_ERROR instead).
   Comments are more explicit.

   Revision 1.2  1995/06/12 15:23:44  dirkh
   Merge two structures (SERIAL_GET_FRAMING and SERIAL_SET_FRAMING)
   into one (SERIAL_FRAMING_STATE).  Document relationship with IOCTLs.

   Revision 1.1  1995/05/31 15:05:19  mikez
   Initial revision

--*/


//
// NtDeviceIoControlFile IoControlCode values for this device
//
#ifndef Microsoft_Adopts_These_Changes
#define IOCTL_SERIAL_QUERY_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,0x801,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,0x802,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,0x803,METHOD_BUFFERED,FILE_ANY_ACCESS)
#else
#define IOCTL_SERIAL_QUERY_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,35,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,36,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,37,METHOD_BUFFERED,FILE_ANY_ACCESS)
#endif


//
// Provider capabilities flags (IOCTL_SERIAL_GET_PROPERTIES)
//
#define SERIAL_PCF_FRAMING	((ULONG)0x0400)


//
// Defines the bitmask that the driver can use to notify
// state changes via IOCTL_SERIAL_SET_WAIT_MASK and IOCTL_SERIAL_WAIT_ON_MASK.
//
// Note that these events will *not* be delivered if there is an outstanding read IRP.
// The status of the read IRP serves as notification of the receipt of a (good or bad) frame.
// Repeat:  These events will be detected and delivered only if the read queue is empty.
//
#define SERIAL_EV_RXFRAME	0x2000  // A valid frame was received
#define SERIAL_EV_BADFRAME	0x4000  // An errored frame was received.


//
// Read IRPs are always completed when a frame is received.
// Following are the values that can be returned by the
// driver in IoStatus.Status of the read IRP.
//
// STATUS_SUCCESS (good frame, data length is IoStatus.Information)
// STATUS_CRC_ERROR
// STATUS_DATA_ERROR (abort frame)
// STATUS_DATA_OVERRUN (buffer overrun -- note that buffer must have space for CRC bytes, although CRC bytes will not be indicated on STATUS_SUCCESS)
//


//
// This structure is used to query the framing options
// supported by hardware (IOCTL_SERIAL_QUERY_FRAMING).
//
typedef struct _SERIAL_FRAMING_INFO {
	OUT ULONG FramingBits;			// Standard NDIS_WAN_INFO field
	OUT ULONG HdrCompressionBits;	// Standard NDIS_WAN_INFO field
	OUT ULONG DataCompressionBits;	// To be decided
	OUT ULONG DataEncryptionBits;	// To be decided
} SERIAL_FRAMING_INFO, *PSERIAL_FRAMING_INFO;


//
// This structure is used to set and retrieve
// the current hardware framing settings
// (IOCTL_SERIAL_SET_FRAMING, IOCTL_SERIAL_GET_FRAMING).
//
// Valid values for [Send,Recv]FramingBits include (for example)
// PPP_FRAMING, PPP_ACCM_SUPPORTED, and ISO3309_FRAMING.
//
typedef struct _SERIAL_FRAMING_STATE {
	IN OUT ULONG	BitMask;				// 0: 16 bit CRC
											// 1: 32 bit CRC
	IN OUT ULONG	SendFramingBits;		// Standard NDIS_WAN_SET_LINK_INFO field
	IN OUT ULONG	RecvFramingBits;		// Standard NDIS_WAN_SET_LINK_INFO field
	IN OUT ULONG	SendCompressionBits;	// Standard NDIS_WAN_SET_LINK_INFO field
	IN OUT ULONG	RecvCompressionBits;	// Standard NDIS_WAN_SET_LINK_INFO field
	IN OUT ULONG	SendEncryptionBits; // To be decided
	IN OUT ULONG	RecvEncryptionBits;	// To be decided
	IN OUT ULONG 	SendACCM;				// Standard NDIS_WAN_SET_LINK_INFO field
	IN OUT ULONG 	RecvACCM;				// Standard NDIS_WAN_SET_LINK_INFO field
} SERIAL_FRAMING_STATE, *PSERIAL_FRAMING_STATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\init.h ===
//
// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
#define DEFAULT_DIRECTORY L"DosDevices"

//
// For the above directory, the AsyncMAC driver will
// use the following name as the suffix of the AsyncMAC
// driver for that directory.  It will NOT append
// a number onto the end of the name.
#define DEFAULT_ASYNCMAC_NAME L"ASYNCMAC"


// define some globals

UNICODE_STRING	ObjectDirectory;
UNICODE_STRING	SymbolicLinkName;
BOOLEAN 		CreatedSymbolicLink=FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\init.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	init.c

Abstract:


Author:

	Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

	Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

// asyncmac.c will define the global parameters.
#include "globals.h"
#include "init.h"

#ifdef MY_DEVICE_OBJECT

VOID
AsyncSetupExternalNaming(
	PDRIVER_OBJECT	DriverObject
	)

/*++

Routine Description:

	This routine will be used to create a symbolic link
	to the driver name in the given object directory.

	It will also create an entry in the device map for
	this device.

Arguments:

	MacName - The NDIS Mac Name in Open Adapter

Return Value:

	None.

--*/

{
	NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\ASYNCMAC");
	NDIS_STRING Name = NDIS_STRING_CONST("\\Device\\ASYNCMAC");
	NTSTATUS	Status;

	AsyncDeviceObject = NULL;

	Status =
	IoCreateDevice(DriverObject,
				   sizeof(LIST_ENTRY),
				   &Name,
				   FILE_DEVICE_ASYMAC,
				   0,
				   FALSE,
				   (PDEVICE_OBJECT*)&AsyncDeviceObject);

	if (Status != STATUS_SUCCESS) {
#if DBG
		DbgPrint("ASYNCMAC: IoCreateDevice Failed %4.4x\n", Status);
#endif
		return;
	}

	AsyncDeviceObject->Flags |= DO_BUFFERED_IO;

	IoCreateSymbolicLink(&SymbolicName, &Name);
}


VOID
AsyncCleanupExternalNaming(
	VOID
	)

/*++

Routine Description:

	This routine will be used to delete a symbolic link
	to the driver name in the given object directory.

	It will also delete an entry in the device map for
	this device.

Arguments:

	MacName - The NDIS Mac Name in Open Adapter

Return Value:

	None.

--*/

{
	NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\ASYNCMAC");

	DbgTracef(1,
		("ASYNC: In SerialCleanupExternalNaming\n"));

	if (AsyncDeviceObject == NULL) {
		return;
	}

	IoDeleteSymbolicLink(&SymbolicName);

	IoDeleteDevice(AsyncDeviceObject);

	AsyncDeviceObject = NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\io.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    io.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

// asyncmac.c will define the global parameters.
#include "globals.h"


NTSTATUS
AsyncSetupIrp(
    IN  PASYNC_FRAME Frame,
    IN  PIRP    irp
    )

/*++

    This is the routine which intializes the Irp

--*/
{
    //    PMDL              mdl;
    PDEVICE_OBJECT  deviceObject=Frame->Info->DeviceObject;
    PFILE_OBJECT    fileObject=Frame->Info->FileObject;

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = NULL;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the caller's data is copied into it.  Otherwise, a Memory
    // Descriptor List (MDL) is allocated and the caller's buffer is locked
    // down using it.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The device does not support direct I/O.  Allocate a system buffer,
        // and copy the caller's data into it.  This is done using an
        // exception handler that will perform cleanup if the operation
        // fails.  Note that this is only done if the operation has a non-zero
        // length.
        //

        irp->AssociatedIrp.SystemBuffer = Frame->Frame;

        //
        // Set the IRP_BUFFERED_IO flag in the IRP so that I/O completion
        // will know that this is not a direct I/O operation.
        //

        irp->Flags = IRP_BUFFERED_IO;


    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This
        // is done using an exception handler that will perform cleanup if
        // the operation fails.  Note that no MDL is allocated, nor is any
        // memory probed or locked if the length of the request was zero.
        //

#if DBG
    DbgPrintf(("The DeviceObject is NOT BUFFERED_IO!! IRP FAILURE!!\n"));

    DbgBreakPoint();
#endif

    } else {

        //
        // Pass the address of the caller's buffer to the device driver.  It
        // is now up to the driver to do everything.
        //

        irp->UserBuffer = Frame->Frame;

    }

    // For now, if we get this far, it means success!
    return(STATUS_SUCCESS);
}

PASYNC_IO_CTX
AsyncAllocateIoCtx(
    BOOLEAN AllocateSync,
    PVOID   Context
)
{
    PASYNC_IO_CTX   AsyncIoCtx;

    AsyncIoCtx = ExAllocateFromNPagedLookasideList(&AsyncIoCtxList);

    if (AsyncIoCtx == NULL) {
        return (NULL);
    }

    RtlZeroMemory(AsyncIoCtx, sizeof(ASYNC_IO_CTX));
    AsyncIoCtx->Context = Context;
    AsyncIoCtx->Sync = AllocateSync;
    if (AllocateSync) {
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
        KeInitializeEvent(&AsyncIoCtx->Event,
                          SynchronizationEvent,
                          (BOOLEAN)FALSE);
    }

    return (AsyncIoCtx);
}

VOID
AsyncFreeIoCtx(
    PASYNC_IO_CTX   AsyncIoCtx
)
{
    ExFreeToNPagedLookasideList(&AsyncIoCtxList,
                                AsyncIoCtx);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\globals.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    globals.h

Abstract:

	 This include file either prototypes the globals or defines the globals
    depending on whether the GLOBALS define value is extern or not.

Author:

    Thomas J. Dimitri (TommyD) 29-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

// only one module (asyncmac.c) gets to define the GLOBALS macro

#ifdef NOCODE

#define DBGPRINT 1

#ifndef	GLOBALS

#define	GLOBALS extern
#define EQU  ; / ## /
#define GLOBALSTATIC extern
#else
#define EQU  =
#define GLOBALSTATIC static
#endif

#else

#define GLOBALS

#endif


#define STATIC


#if DBG
#define DbgPrintf(_x_) DbgPrint _x_
#define DbgTracef(trace_level,_x_) if ((SCHAR)trace_level < TraceLevel) DbgPrint _x_
#define DbgDumpBytes(_x_) DebugDumpBytes _x_
#else
#define DbgPrintf(_x_)
#define DbgTracef(trace_level,_x_)
#define DbgDumpBytes(_x_)
#endif

//
//ZZZ Get from configuration file.
//

#define MAX_MULTICAST_ADDRESS ((UINT)16)
#define MAX_ADAPTERS ((UINT)4)

//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDISPATCH_FUNC) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
//  Global data items.
//

extern PDISPATCH_FUNC NdisMjDeviceControl;

extern PDISPATCH_FUNC NdisMjCreate;

extern PDISPATCH_FUNC NdisMjCleanup;

extern PDRIVER_UNLOAD NdisUnload;

extern SCHAR TraceLevel;

extern NDIS_SPIN_LOCK	GlobalLock;

extern PASYNC_ADAPTER	GlobalAdapter;

extern ULONG	GlobalAdapterCount;

extern ULONG GlobalXmitWentOut;

extern NDIS_PHYSICAL_ADDRESS HighestAcceptableMax;

extern NPAGED_LOOKASIDE_LIST	AsyncIoCtxList;

extern NPAGED_LOOKASIDE_LIST	AsyncInfoList;

extern PDEVICE_OBJECT	AsyncDeviceObject;

extern NDIS_HANDLE		AsyncDeviceHandle;

extern ULONG    glConnectionCount;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\ioctl.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This is the main file for handling DevIOCtl calls for AsyncMAC.
    This driver conforms to the NDIS 3.0 interface.

Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

#ifdef NDIS_NT
    #include <ntiologc.h>
#endif


//  asyncmac.c will define the global parameters.

VOID
AsyncSendLineUp(
    PASYNC_INFO pInfo
    )
{
    PASYNC_ADAPTER      pAdapter = pInfo->Adapter;
    NDIS_MAC_LINE_UP    MacLineUp;

    //
    //  divide the baud by 100 because NDIS wants it in 100s of bits per sec
    //

    MacLineUp.LinkSpeed = pInfo->LinkSpeed / 100;
    MacLineUp.Quality = pInfo->QualOfConnect;
    MacLineUp.SendWindow = ASYNC_WINDOW_SIZE;

    MacLineUp.ConnectionWrapperID = pInfo;
    MacLineUp.NdisLinkHandle      = pInfo;

    MacLineUp.NdisLinkContext = pInfo->NdisLinkContext;

    //
    // Tell the transport above (or really RasHub) that the connection
    // is now up.  We have a new link speed, frame size, quality of service
    //

    NdisMIndicateStatus(pAdapter->MiniportHandle,
                        NDIS_STATUS_WAN_LINE_UP,   // General Status.
                        &MacLineUp,                // (baud rate in 100 bps).
                        sizeof(NDIS_MAC_LINE_UP));

    //
    // Get the next binding (in case of multiple bindings like BloodHound)
    //

    pInfo->NdisLinkContext = MacLineUp.NdisLinkContext;
}


NTSTATUS
AsyncIOCtlRequest(
    IN PIRP                 pIrp,
    IN PIO_STACK_LOCATION   pIrpSp
    )

/*++

Routine Description:

    This routine takes an irp and checks to see if the IOCtl
    is a valid one.  If so, it performs the IOCtl and returns
    any errors in the process.

Return Value:

    The function value is the final status of the IOCtl.

--*/

{
    NTSTATUS            status;
    ULONG               funcCode;
    PVOID               pBufOut;
    ULONG               InBufLength, OutBufLength;
    NDIS_HANDLE         hNdisEndPoint;
    PASYMAC_CLOSE       pCloseStruct;
    PASYMAC_OPEN        pOpenStruct;
    PASYMAC_DCDCHANGE   pDCDStruct;
    PASYNC_ADAPTER      Adapter;
    LARGE_INTEGER li ;

    //
    //  Initialize locals.
    //

    status = STATUS_SUCCESS;

    //
    // Initialize the I/O Status block
    //

    InBufLength     = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    OutBufLength    = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    funcCode        = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

    //
    // Validate the function code
    //

#ifdef MY_DEVICE_OBJECT
    if ( (funcCode >> 16) != FILE_DEVICE_ASYMAC ) {

        return STATUS_INVALID_PARAMETER;
    }
#else
    if ( (funcCode >> 16) != FILE_DEVICE_NETWORK ) {

        return STATUS_INVALID_PARAMETER;
    }
#endif
    //
    //  Get a quick ptr to the IN/OUT SystemBuffer
    //

    pBufOut = pIrp->AssociatedIrp.SystemBuffer;

    switch ( funcCode ) {

        case IOCTL_ASYMAC_OPEN:

            DbgTracef(0,("AsyncIOCtlRequest: IOCTL_ASYMAC_OPEN.\n"));

            pIrp->IoStatus.Information = sizeof(ASYMAC_OPEN);

            if (InBufLength  >= sizeof(ASYMAC_OPEN) &&
                OutBufLength >= sizeof(ASYMAC_OPEN)) {

                pOpenStruct = pBufOut;

            } else {

                status = STATUS_INFO_LENGTH_MISMATCH;
            }

            break;


        case IOCTL_ASYMAC_CLOSE:

            DbgTracef(0,("AsyncIOCtlRequest: IOCTL_ASYMAC_CLOSE\n"));

            if ( InBufLength >= sizeof(ASYMAC_CLOSE) ) {

                pCloseStruct = pBufOut;

            } else {

                status = STATUS_INFO_LENGTH_MISMATCH;
            }

            break;


        case IOCTL_ASYMAC_TRACE:

#if DBG
            DbgPrint("AsyncIOCtlRequest: IOCTL_ASYMAC_TRACE.\n");

            if ( InBufLength >= sizeof(TraceLevel) ) {

                CHAR *pTraceLevel=pBufOut;
                TraceLevel=*pTraceLevel;

            } else {

                status = STATUS_INFO_LENGTH_MISMATCH;
            }
#endif
            return status;
            break;


        case IOCTL_ASYMAC_DCDCHANGE:

            DbgTracef(0,("AsyncIOCtlRequest: IOCTL_ASYMAC_DCDCHANGE.\n"));


            if ( InBufLength >= sizeof(ASYMAC_DCDCHANGE) ) {

                pDCDStruct = pBufOut;

            } else {
                status = STATUS_INFO_LENGTH_MISMATCH;
            }

            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Check if we already have an error (like STATUS_INFO_LENGTH_MISMATCH).
    //

    if ( status != STATUS_SUCCESS ) {

        return status;
    }

    //
    // Since most of IOCTL structs are similar
    // we get the Adapter and hNdisEndPoint here using
    // the StatsStruct (we could several of them)
    //

    pOpenStruct     = pBufOut;
    hNdisEndPoint   = pOpenStruct->hNdisEndpoint;

    //
    //  No error yet, let's go ahead and grab the global lock...
    //

    if ((Adapter = GlobalAdapter) == NULL ) {

        return ASYNC_ERROR_NO_ADAPTER;
    }

    // there's a race condition right here that I am
    // not bothering to get rid of because it would
    // require the removal of this adapter in between
    // here (which is, for all intensive purposes, impossible).

    // Hmm... now that we have the lock we can do stuff

    NdisAcquireSpinLock(&Adapter->Lock);

    // Here we do the real work for the function call

    switch ( funcCode ) {

        case IOCTL_ASYMAC_OPEN:
        {
            PASYNC_INFO                 pNewInfo = NULL;
            USHORT                      i;
            PDEVICE_OBJECT              deviceObject;
            PFILE_OBJECT                fileObject;
            OBJECT_HANDLE_INFORMATION   handleInformation;

            //
            // Get a new AsyncInfo
            //
            pNewInfo = (PASYNC_INFO)
                ExAllocateFromNPagedLookasideList(&AsyncInfoList);

            //
            // Check if we could not find an open port
            //

            if ( pNewInfo == NULL ) {

                NdisReleaseSpinLock(&Adapter->Lock);

                return ASYNC_ERROR_NO_PORT_AVAILABLE;
            }

            RtlZeroMemory(pNewInfo, sizeof(ASYNC_INFO));

            pNewInfo->Adapter = Adapter;

            status =
                AsyncGetFrameFromPool(pNewInfo, &pNewInfo->AsyncFrame);

            if (status != NDIS_STATUS_SUCCESS) {
                ExFreeToNPagedLookasideList(&AsyncInfoList, pNewInfo);

                NdisReleaseSpinLock(&Adapter->Lock);

                return ASYNC_ERROR_NO_PORT_AVAILABLE;
            }

            KeInitializeEvent(&pNewInfo->DetectEvent,
                              SynchronizationEvent,
                              TRUE);

            // increment the reference count (don't kill this adapter)
            InterlockedIncrement(&Adapter->RefCount);

            // release spin lock so we can do some real work.
            NdisReleaseSpinLock(&Adapter->Lock);

            //
            // Reference the file object so the target device can be found and
            // the access rights mask can be used in the following checks for
            // callers in user mode.  Note that if the handle does not refer to
            // a file object, then it will fail.
            //

            status = ObReferenceObjectByHandle(pOpenStruct->FileHandle,
                                               FILE_READ_DATA | FILE_WRITE_DATA,
                                               *IoFileObjectType,
                                               UserMode,
                                               (PVOID) &fileObject,
                                               &handleInformation);

            if (!NT_SUCCESS(status)) {

                pNewInfo->PortState = PORT_CLOSED;

                NdisAcquireSpinLock(&Adapter->Lock);
                // RemoveEntryList(&pNewInfo->Linkage);
                ExFreeToNPagedLookasideList(&Adapter->AsyncFrameList,
                                            pNewInfo->AsyncFrame);
                NdisReleaseSpinLock(&Adapter->Lock);
                ExFreeToNPagedLookasideList(&AsyncInfoList,
                                            pNewInfo);

                return ASYNC_ERROR_NO_PORT_AVAILABLE;
            }

            //
            // Init the portinfo block
            //
            InitializeListHead(&pNewInfo->DDCDQueue);

            // Ok, we've gotten this far.  We have a port.
            // Own port, and check params...
            // Nothing can be done to the port until it comes
            // out of the PORT_OPENING state.
            pNewInfo->PortState = PORT_OPENING;

            NdisAllocateSpinLock(&pNewInfo->Lock);

            //
            // Get the address of the target device object.  Note that this was already
            // done for the no intermediate buffering case, but is done here again to
            // speed up the turbo write path.
            //

            deviceObject = IoGetRelatedDeviceObject(fileObject);

            ObReferenceObject(deviceObject);

            // ok, we have a VALID handle of *something*
            // we do NOT assume that the handle is anything
            // in particular except a device which accepts
            // non-buffered IO (no MDLs) Reads and Writes

            // set new info...

            pNewInfo->Handle = pOpenStruct->FileHandle;

            //
            // Tuck away link speed for line up
            // and timeouts
            //
            pNewInfo->LinkSpeed = pOpenStruct->LinkSpeed;

            //
            // Return endpoint to RASMAN
            //
            pOpenStruct->hNdisEndpoint  =
            pNewInfo->hNdisEndPoint     = pNewInfo;

            // Get parameters set from Registry and return our capabilities

            pNewInfo->QualOfConnect     = pOpenStruct->QualOfConnect;
            pNewInfo->PortState         = PORT_FRAMING;
            pNewInfo->FileObject        = fileObject;
            pNewInfo->DeviceObject      = deviceObject;
            pNewInfo->NdisLinkContext   = NULL;

            //
            //  Initialize the NDIS_WAN_GET_LINK_INFO structure.
            //

            pNewInfo->GetLinkInfo.MaxSendFrameSize  = DEFAULT_PPP_MAX_FRAME_SIZE;
            pNewInfo->GetLinkInfo.MaxRecvFrameSize  = DEFAULT_PPP_MAX_FRAME_SIZE;
            pNewInfo->GetLinkInfo.HeaderPadding         = DEFAULT_PPP_MAX_FRAME_SIZE;
            pNewInfo->GetLinkInfo.TailPadding           = 4;
            pNewInfo->GetLinkInfo.SendFramingBits       = PPP_FRAMING;
            pNewInfo->GetLinkInfo.RecvFramingBits       = PPP_FRAMING;
            pNewInfo->GetLinkInfo.SendCompressionBits   = 0;
            pNewInfo->GetLinkInfo.RecvCompressionBits   = 0;
            pNewInfo->GetLinkInfo.SendACCM              = (ULONG) -1;
            pNewInfo->GetLinkInfo.RecvACCM              = (ULONG) -1;

            ASYNC_ZERO_MEMORY(&(pNewInfo->SerialStats), sizeof(SERIAL_STATS));

            NdisAcquireSpinLock(&Adapter->Lock);
            InsertHeadList(&Adapter->ActivePorts, &pNewInfo->Linkage);
            NdisReleaseSpinLock(&Adapter->Lock);


            //
            //  Send a line up to the WAN wrapper.
            //
            AsyncSendLineUp(pNewInfo);

            //
            // We send a special IRP to the serial driver to set it in RAS friendly mode
            // where it will not complete write requests until the packet has been transmitted
            // on the wire. This is mostly important in case of intelligent controllers.
            //
            pNewInfo->WaitMaskToUse = 
                (SERIAL_EV_RXFLAG | SERIAL_EV_RLSD | SERIAL_EV_DSR | 
                 SERIAL_EV_RX80FULL | SERIAL_EV_ERR) ;

            {
                NTSTATUS        status;
                PASYNC_IO_CTX   AsyncIoCtx;
                PIRP            irp;

                irp = 
                    IoAllocateIrp(pNewInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

                if (irp != NULL) {
                    AsyncIoCtx = AsyncAllocateIoCtx(TRUE, pNewInfo);

                    if (AsyncIoCtx == NULL) {
                        IoFreeIrp(irp);
                        irp = NULL;
                    }
                }

                if (irp != NULL) {
#define IOCTL_SERIAL_PRIVATE_RAS CTL_CODE(FILE_DEVICE_SERIAL_PORT,4000,METHOD_BUFFERED,FILE_ANY_ACCESS)

                    InitSerialIrp(irp,
                                  pNewInfo,
                                  IOCTL_SERIAL_PRIVATE_RAS,
                                  sizeof(ULONG));

                    AsyncIoCtx->WriteBufferingEnabled =
                        Adapter->WriteBufferingEnabled;

                    irp->AssociatedIrp.SystemBuffer=
                        &AsyncIoCtx->WriteBufferingEnabled;

                    IoSetCompletionRoutine(irp,                             // irp to use
                                           SerialIoSyncCompletionRoutine,   // routine to call when irp is done
                                           AsyncIoCtx,                      // context to pass routine
                                           TRUE,                            // call on success
                                           TRUE,                            // call on error
                                           TRUE);                           // call on cancel

                    // Now simply invoke the driver at its dispatch entry with the IRP.
                    //
                    KeClearEvent(&AsyncIoCtx->Event);
                    status = IoCallDriver(pNewInfo->DeviceObject, irp);
                    if (status == STATUS_PENDING) {
                        KeWaitForSingleObject(&AsyncIoCtx->Event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL);
                        status = AsyncIoCtx->IoStatus.Status;
                    }

                    IoFreeIrp(irp);
                    AsyncFreeIoCtx(AsyncIoCtx);

                    if (status == STATUS_SUCCESS) {

                        //
                        // this means that the driver below is DIGI. we should disable setting of the EV_ERR
                        // flags in this case.
                        //

                        pNewInfo->WaitMaskToUse &= ~SERIAL_EV_ERR;

                    }
                }
            }

            //
            // Start the detect framing out with a 6 byte read to get the header
            //
            pNewInfo->BytesWanted=6;
            pNewInfo->BytesRead=0;

            //
            //  Start reading.
            //

            AsyncStartReads(pNewInfo);

            if (NdisInterlockedIncrement(&glConnectionCount) == 1) {
                ObReferenceObject(AsyncDeviceObject);

            }

            break;
        }

        case IOCTL_ASYMAC_TRACE:
            NdisReleaseSpinLock(&Adapter->Lock);
            status = STATUS_SUCCESS;
            break;

        case IOCTL_ASYMAC_CLOSE:
        case IOCTL_ASYMAC_DCDCHANGE:
        {
            PASYNC_INFO     pNewInfo;       // ptr to open port if found
            USHORT          i;
            PLIST_ENTRY     pListEntry;
            BOOLEAN         Valid = FALSE;

            switch (funcCode) {

                case IOCTL_ASYMAC_CLOSE:
                {
                    NDIS_MAC_LINE_DOWN  AsyncLineDown;

                    pNewInfo = (PASYNC_INFO)pCloseStruct->hNdisEndpoint;

                    // Verify that the pointer is a valid ASYNC_INFO
                    for (pListEntry=Adapter->ActivePorts.Flink;
                         pListEntry!=&Adapter->ActivePorts;
                         pListEntry=pListEntry->Flink)
                    {
                        if (&pNewInfo->Linkage==pListEntry)
                        {
                            Valid = TRUE;
                            break;
                        }
                    }

                    if (!Valid) {
                        status=ASYNC_ERROR_PORT_NOT_FOUND;
                        break;
                    }

                    // release spin lock so we can do some real work.
                    NdisReleaseSpinLock(&Adapter->Lock);

                    NdisAcquireSpinLock(&pNewInfo->Lock);

                    // ASSERT(pNewInfo->PortState == PORT_FRAMING);
                    
                    if(pNewInfo->PortState != PORT_FRAMING)
                    {
                        KdPrint(("AsyncIOCtlRequest: IOCTL_ASYMAC_CLOSE."));
                        KdPrint(("PortState = %d != PORT_FRAMING\n", pNewInfo->PortState));

                        NdisReleaseSpinLock(&pNewInfo->Lock);
                        return ASYNC_ERROR_PORT_BAD_STATE;
                        // break;
                    }

                    AsyncLineDown.NdisLinkContext = pNewInfo->NdisLinkContext;

                    // Signal that port is closing.
                    pNewInfo->PortState = PORT_CLOSING;

                    //Set MUTEX to wait on
                    KeInitializeEvent(&pNewInfo->ClosingEvent,       // Event
                                      SynchronizationEvent,          // Event type
                                      (BOOLEAN)FALSE);               // Not signalled state

                    NdisReleaseSpinLock(&pNewInfo->Lock);

                    //
                    // If we have an outstanding Detect worker
                    // wait for it to complete!
                    //
                    KeWaitForSingleObject(&pNewInfo->DetectEvent,
                                          UserRequest,
                                          KernelMode,
                                          FALSE,
                                          NULL);

                    //
                    // now we must send down an IRP do cancel
                    // any request pending in the serial driver
                    //
                    CancelSerialRequests(pNewInfo);

                    //
                    // Also, cancel any outstanding DDCD irps
                    //

                    AsyncCancelAllQueued(&pNewInfo->DDCDQueue);

                    // Synchronize closing with the read irp

                    li.LowPart = 5000 ;
                    li.HighPart = 0 ;

                    if (KeWaitForSingleObject (&pNewInfo->ClosingEvent,// PVOID Object,
                                               UserRequest,           // KWAIT_REASON WaitReason,
                                               KernelMode,            // KPROCESSOR_MODE WaitMode,
                                               (BOOLEAN)FALSE,        // BOOLEAN Alertable,
                                               &li) == STATUS_TIMEOUT) {

                        // If the wait fails cause another flush
                        //
                        NTSTATUS    status;
                        PIRP        irp;
                        PASYNC_IO_CTX   AsyncIoCtx;

                        irp=
                            IoAllocateIrp(pNewInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

                        if (irp == NULL)
                            goto DEREF ;


                        AsyncIoCtx = AsyncAllocateIoCtx(TRUE, pNewInfo);

                        if (AsyncIoCtx == NULL) {
                            IoFreeIrp(irp);
                            goto DEREF;
                        }

                        InitSerialIrp(irp,
                                      pNewInfo,
                                      IOCTL_SERIAL_PURGE,
                                      sizeof(ULONG));

                        // kill all read and write threads.
                        AsyncIoCtx->SerialPurge =
                            SERIAL_PURGE_TXABORT | SERIAL_PURGE_RXABORT;

                        irp->AssociatedIrp.SystemBuffer=
                            &AsyncIoCtx->SerialPurge;

                        IoSetCompletionRoutine(irp,     // irp to use
                                               SerialIoSyncCompletionRoutine,  // routine to call when irp is done
                                               AsyncIoCtx,                 // context to pass routine
                                               TRUE,                       // call on success
                                               TRUE,                       // call on error
                                               TRUE);                      // call on cancel

                        // Now simply invoke the driver at its dispatch entry with the IRP.
                        //
                        KeClearEvent(&AsyncIoCtx->Event);
                        status = IoCallDriver(pNewInfo->DeviceObject, irp);

                        if (status == STATUS_PENDING) {
                            KeWaitForSingleObject(&AsyncIoCtx->Event,
                                                  Executive,
                                                  KernelMode,
                                                  FALSE,
                                                  NULL);
                            status = AsyncIoCtx->IoStatus.Status;
                        }

                        IoFreeIrp(irp);
                        AsyncFreeIoCtx(AsyncIoCtx);

                        // if we do hit this code - wait for some time to let
                        // the read complete
                        //
                        KeDelayExecutionThread (KernelMode, FALSE, &li) ;
                    }


                    //
                    // Get rid of our reference to the serial port
                    //
                    DEREF:
                    ObDereferenceObject(pNewInfo->DeviceObject);

                    ObDereferenceObject(pNewInfo->FileObject);

                    NdisMIndicateStatus(Adapter->MiniportHandle,
                                        NDIS_STATUS_WAN_LINE_DOWN,  // General Status
                                        &AsyncLineDown,            // Specific Status
                                        sizeof(NDIS_MAC_LINE_DOWN));

                    // reacquire spin lock
                    NdisAcquireSpinLock(&Adapter->Lock);

                    RemoveEntryList(&pNewInfo->Linkage);

                    // decrement the reference count because we're done.
                    InterlockedDecrement(&Adapter->RefCount);

                    pNewInfo->PortState = PORT_CLOSED;

                    NdisFreeSpinLock(&pNewInfo->Lock);

                    ExFreeToNPagedLookasideList(&Adapter->AsyncFrameList,
                                                pNewInfo->AsyncFrame);

                    ExFreeToNPagedLookasideList(&AsyncInfoList,
                                                pNewInfo);

                    if (NdisInterlockedDecrement(&glConnectionCount) == 0) {
                        ObDereferenceObject(AsyncDeviceObject);
                    }

                    break;          // get out of case statement
                }

                case IOCTL_ASYMAC_DCDCHANGE:
    
                    pNewInfo = (PASYNC_INFO)pDCDStruct->hNdisEndpoint;
                    
                    // Verify that the pointer is a valid ASYNC_INFO
                    for (pListEntry=Adapter->ActivePorts.Flink;
                         pListEntry!=&Adapter->ActivePorts;
                         pListEntry=pListEntry->Flink)
                    {
                        if (&pNewInfo->Linkage==pListEntry)
                        {
                            Valid = TRUE;
                            break;
                        }
                    }

                    //
                    // If the port is already closed, we WILL complain
                    //
                    if (!Valid || pNewInfo->PortState == PORT_CLOSED) {
                        status=ASYNC_ERROR_PORT_NOT_FOUND;
                        break;
                    }

                    //
                    // If any irps are pending, cancel all of them
                    // Only one irp can be outstanding at a time.
                    //
                    AsyncCancelAllQueued(&pNewInfo->DDCDQueue);

                    DbgTracef(0, ("ASYNC: Queueing up DDCD IRP\n"));

                    AsyncQueueIrp(&pNewInfo->DDCDQueue, pIrp);

                    //
                    // we'll have to wait for the SERIAL driver
                    // to flip DCD or DSR
                    //
                    status=STATUS_PENDING;
                    break;

            } // end switch

            NdisReleaseSpinLock(&Adapter->Lock);
            return(status);
        }
        break;

    }   // end switch

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\irps.c ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

	irps.c

Abstract:


Author:

	Thomas Dimitri (tommyd) 08-May-1992

--*/

#include "asyncall.h"
#include "globals.h"

VOID
AsyncCancelQueued(
	PDEVICE_OBJECT	DeviceObject,
	PIRP			Irp)
{
	DbgTracef(0, ("RASHUB: IRP 0x%.8x is being cancelled.\n", Irp));

	// Mark this Irp as cancelled
	Irp->IoStatus.Status = STATUS_CANCELLED;
	Irp->IoStatus.Information = 0;

	// Take off our own list
	RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

	// Release cancel spin lock which the IO system acquired??
	IoReleaseCancelSpinLock(Irp->CancelIrql);

	IoCompleteRequest(
		Irp,
		IO_NETWORK_INCREMENT);
}

VOID
AsyncCancelAllQueued(
	PLIST_ENTRY		QueueToCancel)
{
	KIRQL		oldIrql;
	PLIST_ENTRY	headOfList;
	PIRP		pIrp;

	//
	// We are pigs here using the global spin lock
	// but this is called so infrequently, we can
	// be pigs
	//
	IoAcquireCancelSpinLock(&oldIrql);

	//
	// Run through entire list until it is empty
	//
	for (;;) {

		if (IsListEmpty(QueueToCancel)) {
			break;
		}

		//
		// pick off the head of the list
		//
		headOfList = RemoveHeadList(QueueToCancel);

		pIrp = CONTAINING_RECORD(
				headOfList,
				IRP,
				Tail.Overlay.ListEntry);

		//
		// Disable the cancel routine
		//
		IoSetCancelRoutine(
			pIrp,
			NULL);

		//
		// Mark this irp as cancelled
		//
		pIrp->Cancel = TRUE;
		pIrp->IoStatus.Status = STATUS_CANCELLED;
		pIrp->IoStatus.Information = 0;

		//
		// We must release the spin lock before calling completing the irp
		//
		IoReleaseCancelSpinLock(oldIrql);

		DbgTracef(0, ("RASHUB: Cancelling a request\n"));

		IoCompleteRequest(
			pIrp,
			IO_NETWORK_INCREMENT);

		DbgTracef(0, ("RASHUB: Done cancelling a request\n"));

		//
		// Acquire it again before looking at the list
		//
		IoAcquireCancelSpinLock(&oldIrql);

	}

	IoReleaseCancelSpinLock(oldIrql);

}


VOID
AsyncQueueIrp(
	PLIST_ENTRY		Queue,
	PIRP			Irp)
{
	KIRQL		oldIrql;

	//
	// We are pigs here using the global spin lock
	//
	IoAcquireCancelSpinLock(&oldIrql);

	//
	// Mark the irp as pending and return from this ioctl
	//
	Irp->IoStatus.Status = STATUS_PENDING;
	IoMarkIrpPending(Irp);

	//
	// Queue up the irp at the end
	//
	InsertTailList(
		Queue,
		&Irp->Tail.Overlay.ListEntry);

	//
	// Set the cancel routine (also the purge routine)
	//
	IoSetCancelRoutine(
		Irp,
		AsyncCancelQueued);

	IoReleaseCancelSpinLock(oldIrql);

}


BOOLEAN
TryToCompleteDDCDIrp(
	PASYNC_INFO		pInfo)
	
/*++

Routine Description:


Arguments:


Return Value:


--*/

{

	KIRQL				oldIrql;
	PLIST_ENTRY			headOfList;
	PIRP				pIrp;

	IoAcquireCancelSpinLock(&oldIrql);

	if (IsListEmpty(&pInfo->DDCDQueue)) {
		IoReleaseCancelSpinLock(oldIrql);
		return((BOOLEAN)FALSE);
	}

	headOfList = RemoveHeadList(&pInfo->DDCDQueue);

	pIrp = CONTAINING_RECORD(
				headOfList,
				IRP,
				Tail.Overlay.ListEntry);

	IoSetCancelRoutine(
			pIrp,
			NULL);

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;

	IoReleaseCancelSpinLock(oldIrql);

	IoCompleteRequest(
			pIrp,
			IO_NETWORK_INCREMENT);

	return((BOOLEAN)TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\oid.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    oid.c

Abstract:

    This source file handles ALL oid requests from the wrapper.

Author:

    Ray Patch (raypa) 04/12/94

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    raypa           04/12/94            Created.

--*/

#include "asyncall.h"

//
//  New WAN OID supported list.
//

NDIS_OID AsyncGlobalSupportedOids[] = {
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,

    OID_WAN_PERMANENT_ADDRESS,
    OID_WAN_CURRENT_ADDRESS,
    OID_WAN_PROTOCOL_TYPE,
    OID_WAN_MEDIUM_SUBTYPE,
    OID_WAN_HEADER_FORMAT,

    OID_WAN_GET_INFO,
    OID_WAN_GET_LINK_INFO,
    OID_WAN_GET_COMP_INFO,

    OID_WAN_SET_LINK_INFO,
    OID_WAN_SET_COMP_INFO,

    OID_WAN_GET_STATS_INFO,

    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
    OID_PNP_ENABLE_WAKE_UP
};


//
//  Forward references for this source file.
//

NDIS_STATUS
AsyncSetLinkInfo(
    IN  POID_WORK_ITEM  OidWorkItem
    );

NDIS_STATUS
MpQueryInfo(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    )
/*++

Routine Description:

    The MpQueryProtocolInformation process a Query request for
    NDIS_OIDs that are specific to a binding about the MAC.  Note that
    some of the OIDs that are specific to bindings are also queryable
    on a global basis.  Rather than recreate this code to handle the
    global queries, I use a flag to indicate if this is a query for the
    global data or the binding specific data.

Arguments:

    Adapter - a pointer to the adapter.

    Oid - the NDIS_OID to process.

Return Value:

    The function value is the status of the operation.

--*/

{
    NDIS_MEDIUM             Medium          = NdisMediumWan;
    ULONG                   GenericULong    = 0;
    USHORT                  GenericUShort   = 0;
    UCHAR                   GenericArray[] = {' ', 'A', 'S', 'Y', 'N', 0xFF};
    NDIS_STATUS             StatusToReturn  = NDIS_STATUS_SUCCESS;
    NDIS_HARDWARE_STATUS    HardwareStatus  = NdisHardwareStatusReady;
    PVOID                   MoveSource;
    ULONG                   MoveBytes;
    INT                     fDoCommonMove = TRUE;
    PASYNC_ADAPTER          Adapter = MiniportAdapterContext;

    ASSERT( sizeof(ULONG) == 4 );

    //
    //  Switch on request type
    //
    //  By default we assume the source and the number of bytes to move

    MoveSource = &GenericULong;
    MoveBytes  = sizeof(GenericULong);

    switch ( Oid ) {

    case OID_GEN_SUPPORTED_LIST:

        MoveSource = AsyncGlobalSupportedOids;
        MoveBytes  = sizeof(AsyncGlobalSupportedOids);

        break;

    case OID_GEN_HARDWARE_STATUS:
        MoveSource = (PVOID)&HardwareStatus;
        MoveBytes = sizeof(HardwareStatus);
        break;

    case OID_GEN_MEDIA_SUPPORTED:
    case OID_GEN_MEDIA_IN_USE:
        MoveSource = (PVOID)&Medium;
        MoveBytes = sizeof(Medium);
        break;

    case OID_GEN_MAXIMUM_LOOKAHEAD:
    case OID_GEN_CURRENT_LOOKAHEAD:
    case OID_GEN_MAXIMUM_FRAME_SIZE:
        GenericULong = Adapter->MaxFrameSize;
        break;

    case OID_GEN_LINK_SPEED:
        //
        // Who knows what the initial link speed is?
        // This should not be called, right?
        //
        GenericULong = (ULONG)288;
        break;

    case OID_GEN_TRANSMIT_BUFFER_SPACE:
    case OID_GEN_RECEIVE_BUFFER_SPACE:
        GenericULong = (ULONG)(Adapter->MaxFrameSize * 2);
        break;

    case OID_GEN_TRANSMIT_BLOCK_SIZE:
    case OID_GEN_RECEIVE_BLOCK_SIZE:
    case OID_GEN_MAXIMUM_TOTAL_SIZE:
        GenericULong = (ULONG)(Adapter->MaxFrameSize);
        break;

    case OID_GEN_VENDOR_ID:
        GenericULong = 0xFFFFFFFF;
        MoveBytes = 3;
        break;

    case OID_GEN_VENDOR_DESCRIPTION:
        MoveSource = (PVOID)"AsyncMac Adapter";
        MoveBytes = 16;
        break;

    case OID_GEN_DRIVER_VERSION:
        GenericUShort = 0x0500;
        MoveSource = (PVOID)&GenericUShort;
        MoveBytes = sizeof(USHORT);
        break;

    case OID_GEN_MAC_OPTIONS:
        GenericULong = (ULONG)(NDIS_MAC_OPTION_RECEIVE_SERIALIZED |
                               NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                               NDIS_MAC_OPTION_FULL_DUPLEX |
                               NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA);
        break;

    case OID_WAN_PROTOCOL_TYPE:

        DbgTracef(0,("AsyncQueryProtocolInformation: Oid = OID_WAN_PROTOCOL_TYPE.\n"));

        break;

    case OID_WAN_PERMANENT_ADDRESS:
    case OID_WAN_CURRENT_ADDRESS:
        MoveSource = (PVOID)GenericArray;
        MoveBytes = ETH_LENGTH_OF_ADDRESS;
        break;

    case OID_WAN_MEDIUM_SUBTYPE:
        GenericULong = NdisWanMediumSerial;
        break;

    case OID_WAN_HEADER_FORMAT:
        GenericULong = NdisWanHeaderEthernet;
        break;

    case OID_WAN_GET_INFO:

        DbgTracef(0,("AsyncQueryProtocolInformation: Oid = OID_WAN_GET_INFO.\n"));

        MoveSource = &Adapter->WanInfo;
        MoveBytes  = sizeof(NDIS_WAN_INFO);

        break;

    case OID_WAN_GET_LINK_INFO:
        {
        NDIS_WAN_GET_LINK_INFO* pInfo;
        PASYNC_INFO             AsyncInfo;

        DbgTracef(0,("AsyncQueryProtocolInformation: Oid = OID_WAN_GET_LINK_INFO.\n"));
        pInfo = (NDIS_WAN_GET_LINK_INFO* )InformationBuffer;
        AsyncInfo = (PASYNC_INFO) pInfo->NdisLinkHandle;
        MoveSource = &AsyncInfo->GetLinkInfo,
        MoveBytes = sizeof(NDIS_WAN_GET_LINK_INFO);

        }

        break;

    case OID_WAN_GET_COMP_INFO:
    {
        DbgTracef(0,("AsyncQueryProtocolInformation: Oid = OID_WAN_GET_COMP_INFO.\n"));
        StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;
        break;
    }

    case OID_WAN_GET_STATS_INFO:
    {

        DbgTracef(0,("AsyncQueryProtocolInformation: Oid = OID_WAN_GET_STATS_INFO\n"));
        StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;
        break;
    }



    case OID_GEN_XMIT_OK:
    case OID_GEN_RCV_OK:
    case OID_GEN_XMIT_ERROR:
    case OID_GEN_RCV_ERROR:
    case OID_GEN_RCV_NO_BUFFER:
        break;

    case OID_PNP_CAPABILITIES:
    case OID_PNP_SET_POWER:
    case OID_PNP_QUERY_POWER:
    case OID_PNP_ENABLE_WAKE_UP:
        break;

    default:
        StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;
        break;
    }

    //
    //  If were here then we need to move the data into the callers buffer.
    //

    if ( StatusToReturn == NDIS_STATUS_SUCCESS ) {

        if (fDoCommonMove)
        {
            //
            //  If there is enough room then we can copy the data and
            //  return the number of bytes copied, otherwise we must
            //  fail and return the number of bytes needed.
            //
            if ( MoveBytes <= InformationBufferLength ) {

                ASYNC_MOVE_MEMORY(InformationBuffer, MoveSource, MoveBytes);

                *BytesWritten += MoveBytes;

            } else {

                *BytesNeeded = MoveBytes;

                StatusToReturn = NDIS_STATUS_BUFFER_TOO_SHORT;

            }
        }
    }

    return StatusToReturn;
}


NDIS_STATUS
MpSetInfo(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesRead,
    OUT PULONG      BytesNeeded
    )
/*++

Routine Description:

    The AsyncSetInformation is used by AsyncRequest to set information
    about the MAC.

    Note: Assumes it is called with the lock held.  Any calls are made down
    to the serial driver from this routine may return pending.  If this happens
    the completion routine for the call needs to complete this request by
    calling NdisMSetInformationComplete.

Arguments:

    MiniportAdapterContext - A pointer to the adapter.


Return Value:

    The function value is the status of the operation.

--*/

{
    NDIS_STATUS     StatusToReturn;
    PASYNC_ADAPTER  Adapter = MiniportAdapterContext;

    //
    //  Initialize locals.
    //

    StatusToReturn = NDIS_STATUS_SUCCESS;

    switch ( Oid ) {

    case OID_WAN_SET_LINK_INFO:
        {
        PASYNC_INFO AsyncInfo;
        WORK_QUEUE_ITEM WorkItem;
        PNDIS_WAN_SET_LINK_INFO SetLinkInfo;
        POID_WORK_ITEM  OidWorkItem;

        SetLinkInfo = (PNDIS_WAN_SET_LINK_INFO)InformationBuffer;
        AsyncInfo = (PASYNC_INFO) SetLinkInfo->NdisLinkHandle;

        NdisAcquireSpinLock(&AsyncInfo->Lock);

        if (AsyncInfo->PortState != PORT_FRAMING) {
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }

        OidWorkItem = ExAllocatePoolWithTag(NonPagedPool,
            sizeof(OID_WORK_ITEM), ASYNC_WORKITEM_TAG);

        if (OidWorkItem == NULL) {
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }

        AsyncInfo->Flags |= OID_WORK_SCHEDULED;

        //
        // Cannot issue IRPs at anything but PASSIVE level!
        // We must schedule a passive worker to carry this out.
        //
        DbgTracef(-2,("AsyncSetInformation: Oid = OID_WAN_SET_LINK_INFO\n"));

        NdisReleaseSpinLock(&AsyncInfo->Lock);

        OidWorkItem->Context = SetLinkInfo;

        ExInitializeWorkItem(&OidWorkItem->WorkQueueItem, 
            AsyncSetLinkInfo, OidWorkItem);

        ExQueueWorkItem(&OidWorkItem->WorkQueueItem, DelayedWorkQueue);

        StatusToReturn = NDIS_STATUS_PENDING;

        break;
        }

    case OID_WAN_SET_COMP_INFO:
    {
        DbgTracef(0,("AsyncSetInformation: Oid = OID_WAN_SET_COMP_INFO.\n"));
        StatusToReturn = NDIS_STATUS_INVALID_OID;
        break;
    }

        case OID_PNP_CAPABILITIES:
        case OID_PNP_SET_POWER:
        case OID_PNP_QUERY_POWER:
        case OID_PNP_ENABLE_WAKE_UP:
            break;

    default:

        StatusToReturn = NDIS_STATUS_INVALID_OID;

        *BytesRead   = 0;
        *BytesNeeded = 0;

        break;
    }

    if ( StatusToReturn == NDIS_STATUS_SUCCESS ) {

        *BytesRead   = InformationBufferLength;
        *BytesNeeded = 0;

    }

    return StatusToReturn;
}

NDIS_STATUS
AsyncSetLinkInfo(
    IN  POID_WORK_ITEM  OidWorkItem
    )
{
    PASYNC_INFO AsyncInfo;
    ULONG       RecvFramingBits;
    NDIS_STATUS Status;
    PNDIS_WAN_SET_LINK_INFO SetLinkInfo;

    SetLinkInfo = (PNDIS_WAN_SET_LINK_INFO)OidWorkItem->Context;
    AsyncInfo = (PASYNC_INFO) SetLinkInfo->NdisLinkHandle;
    ExFreePool(OidWorkItem);

    do {

        //
        //  If the port is already closed, we bail out.
        //
        NdisAcquireSpinLock(&AsyncInfo->Lock);

        AsyncInfo->Flags &= ~OID_WORK_SCHEDULED;

        if (AsyncInfo->PortState != PORT_FRAMING) {
    
            Status = NDIS_STATUS_FAILURE;
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }
    
        //
        //  Save off the current receive framing bits before we copy the
        //  incoming link information into our local copy.
        //
    
        RecvFramingBits = AsyncInfo->SetLinkInfo.RecvFramingBits;
    
        //
        //  Fill in the NDIS_WAN_SET_LINK_INFO structure.
        //
    
        ASYNC_MOVE_MEMORY(&AsyncInfo->SetLinkInfo,
                          SetLinkInfo,
                          sizeof(NDIS_WAN_SET_LINK_INFO));
    
        DbgTracef(1,("ASYNC: Framing change to 0x%.8x from 0x%.8x\n",
                SetLinkInfo->RecvFramingBits, RecvFramingBits));
    
        //
        // If we are in auto-detect and they want auto-detect
        // then there is nothing to do!!!
        //
        if (!(RecvFramingBits | SetLinkInfo->RecvFramingBits)) {
            Status = NDIS_STATUS_SUCCESS;
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }
    
        if (SetLinkInfo->RecvFramingBits == 0 && AsyncInfo->PortState == PORT_FRAMING) {
            //
            // ignore the request
            //
            Status = NDIS_STATUS_SUCCESS;
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }
    
        //
        //  If we are changing from PPP framing to another
        //  form of PPP framing, or from SLIP framing to
        //  another form then there is no need to kill the
        //  current framing.
        //
        
        if ((RecvFramingBits & SetLinkInfo->RecvFramingBits & PPP_FRAMING)  ||
            (RecvFramingBits & SetLinkInfo->RecvFramingBits & SLIP_FRAMING) ) {
        
            DbgTracef(-1,("ASYNC: Framing already set to 0x%.8x - ignoring\n",
                SetLinkInfo->RecvFramingBits));
        
            //
            //  We are framing, start reading.
            //
        
            AsyncInfo->PortState = PORT_FRAMING;
        
            Status = NDIS_STATUS_SUCCESS;
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }
    
        //
        //  If we have some sort of framing we must
        //  kill that framing and wait for it to die down
        //
    
        KeInitializeEvent(&AsyncInfo->ClosingEvent,
                          SynchronizationEvent,
                          FALSE);
    
        //
        // Signal that port is closing.
        //
    
        AsyncInfo->PortState = PORT_CLOSING;
    
        NdisReleaseSpinLock(&AsyncInfo->Lock);

        //
        //  Now we must send down an IRP
        //
        CancelSerialRequests(AsyncInfo);
    
        //
        //  Synchronize closing with the read irp
        //
        KeWaitForSingleObject (&AsyncInfo->ClosingEvent,
                               UserRequest,
                               KernelMode,
                               FALSE,
                               NULL);
    
        AsyncInfo->PortState = PORT_FRAMING;
    
        AsyncStartReads(AsyncInfo);

        Status = NDIS_STATUS_SUCCESS;

    } while ( 0 );

    NdisMSetInformationComplete(AsyncInfo->Adapter->MiniportHandle, Status);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\mp.c ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    mp.c
    
Abstract:

    This file contains the routines that asyncmac uses to present
    the NDIS 5.0 miniport interface
    
Author:

    Tony Bell   (TonyBe) May 20, 1997

Environment:

    Kernel Mode

Revision History:

    TonyBe      05/20/97        Created

--*/

#include "asyncall.h"

extern  NDIS_HANDLE NdisWrapperHandle;

VOID    
MpHalt(
    IN NDIS_HANDLE  MiniportAdapterContext
    )
{
    PASYNC_ADAPTER  Adapter = (PASYNC_ADAPTER)MiniportAdapterContext;

    DbgTracef(0,("AsyncMac: In MpHalt\n"));

    NdisAcquireSpinLock(&GlobalLock);

    ASSERT(Adapter == GlobalAdapter);

#if DBG
    if (InterlockedCompareExchange(&glConnectionCount, 0, 0) != 0) {
        DbgPrint("MpHalt with outstanding connections!\n");
        DbgBreakPoint();
    }
#endif

    GlobalAdapterCount--;
    GlobalAdapter = NULL;

    NdisReleaseSpinLock(&GlobalLock);

    ExDeleteNPagedLookasideList(&Adapter->AsyncFrameList);

#ifndef MY_DEVICE_OBJECT
    if (AsyncDeviceHandle != NULL) {
        NdisMDeregisterDevice(AsyncDeviceHandle);
        AsyncDeviceHandle = NULL;
        AsyncDeviceObject = NULL;
    }
#endif

    ExFreePool(Adapter);

    return;

}

NDIS_STATUS
MpInit(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN  PNDIS_MEDIUM    MediumArray,
    IN  UINT            MediumArraySize,
    IN  NDIS_HANDLE     MiniportAdapterHandle,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    )
{
    //
    // Pointer for the adapter root.
    //
    PASYNC_ADAPTER Adapter;

    NDIS_HANDLE ConfigHandle;
    PNDIS_CONFIGURATION_PARAMETER ReturnedValue;

    NDIS_STRING PortsStr    = NDIS_STRING_CONST("Ports");

    NDIS_STRING IrpStackSizeStr = NDIS_STRING_CONST("IrpStackSize");
    NDIS_STRING MaxFrameSizeStr = NDIS_STRING_CONST("MaxFrameSize");
    NDIS_STRING FramesPerPortStr= NDIS_STRING_CONST("FramesPerPort");
    NDIS_STRING XonXoffStr      = NDIS_STRING_CONST("XonXoff");
    NDIS_STRING TimeoutBaseStr=   NDIS_STRING_CONST("TimeoutBase");
    NDIS_STRING TimeoutBaudStr=   NDIS_STRING_CONST("TimeoutBaud");
    NDIS_STRING TimeoutReSyncStr= NDIS_STRING_CONST("TimeoutReSync");
    NDIS_STRING WriteBufferingStr= NDIS_STRING_CONST("WriteBufferingEnabled");

    NDIS_STATUS Status;

    // assign some defaults if these strings are not found in the registry

    UCHAR       irpStackSize  = DEFAULT_IRP_STACK_SIZE;
    ULONG       maxFrameSize  = DEFAULT_MAX_FRAME_SIZE;
    USHORT      framesPerPort = DEFAULT_FRAMES_PER_PORT;
    ULONG       xonXoff       = DEFAULT_XON_XOFF;
    ULONG       timeoutBase   = DEFAULT_TIMEOUT_BASE;
    ULONG       timeoutBaud   = DEFAULT_TIMEOUT_BAUD;
    ULONG       timeoutReSync = DEFAULT_TIMEOUT_RESYNC;
    ULONG       WriteBufferingEnabled = 1;
    ULONG       NeededFrameSize;

    UINT        MaxMulticastList = 32;
    USHORT      i;      // counter

    //
    // We only support a single instance of AsyncMac
    //
    if (GlobalAdapterCount != 0) {
        return NDIS_STATUS_FAILURE;
    }

    for (i = 0; i < MediumArraySize; i++) {
        if (MediumArray[i] == NdisMediumWan) {
            break;
        }
    }

    if (i == MediumArraySize) {
        return (NDIS_STATUS_UNSUPPORTED_MEDIA);
    }

    *SelectedMediumIndex = i;

    //
    //  Card specific information.
    //


    //
    // Allocate the Adapter block.
    //
    Adapter = (PASYNC_ADAPTER)
        ExAllocatePoolWithTag(NonPagedPool,
                              sizeof(ASYNC_ADAPTER),
                              ASYNC_ADAPTER_TAG);
    if (Adapter == NULL){

        DbgTracef(-1,("AsyncMac: Could not allocate physical memory!!!\n"));
        return NDIS_STATUS_RESOURCES;
    }

    ASYNC_ZERO_MEMORY(Adapter, sizeof(ASYNC_ADAPTER));

    Adapter->MiniportHandle = MiniportAdapterHandle;

    NdisOpenConfiguration(
                    &Status,
                    &ConfigHandle,
                    WrapperConfigurationContext);

    if (Status != NDIS_STATUS_SUCCESS) {

        return NDIS_STATUS_FAILURE;

    }

    //
    // Read if the default IrpStackSize is used for this adapter.
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &IrpStackSizeStr,
                    NdisParameterInteger);

    if ( Status == NDIS_STATUS_SUCCESS ) {

        irpStackSize=(UCHAR)ReturnedValue->ParameterData.IntegerData;

        DbgTracef(0,("This MAC Adapter has an irp stack size of %u.\n",irpStackSize));
    }

    //
    // Read if the default MaxFrameSize is used for this adapter.
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &MaxFrameSizeStr,
                    NdisParameterInteger);

    if ( Status == NDIS_STATUS_SUCCESS ) {

        maxFrameSize=ReturnedValue->ParameterData.IntegerData;

        DbgTracef(0,("This MAC Adapter has a max frame size of %u.\n",maxFrameSize));
    }

    //
    // Read if the default for frames per port is changed
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &FramesPerPortStr,
                    NdisParameterInteger);

    if ( Status == NDIS_STATUS_SUCCESS ) {

        framesPerPort=(USHORT)ReturnedValue->ParameterData.IntegerData;

        DbgTracef(0,("This MAC Adapter has frames per port set to: %u.\n",framesPerPort));
    }

    //
    // Read if the default for Xon Xoff is changed
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &XonXoffStr,
                    NdisParameterInteger);


    if (Status == NDIS_STATUS_SUCCESS) {

        xonXoff=(ULONG)ReturnedValue->ParameterData.IntegerData;
        DbgTracef(0,("This MAC Adapter has Xon/Xoff set to: %u.\n",xonXoff));
    }

    //
    // Read if the default for Timeout Base has changed
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &TimeoutBaseStr,
                    NdisParameterInteger);

    if ( Status == NDIS_STATUS_SUCCESS ) {

        timeoutBase = ReturnedValue->ParameterData.IntegerData;

        DbgTracef(0,("This MAC Adapter has TimeoutBase set to: %u.\n", timeoutBase));
    }

    //
    // Read if the default for Timeout Baud has changed
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &TimeoutBaudStr,
                    NdisParameterInteger);

    if ( Status == NDIS_STATUS_SUCCESS ) {

        timeoutBaud = ReturnedValue->ParameterData.IntegerData;

        DbgTracef(0,("This MAC Adapter has TimeoutBaud set to: %u.\n", timeoutBaud));
    }

    //
    // Read if the default for Timeout ReSync has changed
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &TimeoutReSyncStr,
                    NdisParameterInteger);

    if (Status == NDIS_STATUS_SUCCESS) {
        timeoutReSync=ReturnedValue->ParameterData.IntegerData;
        DbgTracef(0,("This MAC Adapter has TimeoutReSync set to: %u.\n",timeoutReSync));
    }

    NdisReadConfiguration(&Status,
                          &ReturnedValue,
                          ConfigHandle,
                          &WriteBufferingStr,
                          NdisParameterInteger);

    if (Status == NDIS_STATUS_SUCCESS) {
        WriteBufferingEnabled = ReturnedValue->ParameterData.IntegerData;
        DbgTracef(0,("This MAC Adapter has WriteBufferingEnabled set to: %u.\n", WriteBufferingEnabled));
    }

    NdisCloseConfiguration(ConfigHandle);

    NdisMSetAttributesEx(MiniportAdapterHandle,
                         Adapter,
                         (UINT)-1,
                         NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT  |
                         NDIS_ATTRIBUTE_DESERIALIZE             |
                         NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
                         NdisInterfaceInternal);

    //
    //  Initialize the ADAPTER structure here!!!
    //
    NdisAllocateSpinLock(&Adapter->Lock);
    Adapter->IrpStackSize       = irpStackSize;

    //
    // We double the max frame size for PPP byte stuffing.
    // We also tack on some PADDING just to be safe.
    //

    //
    // Changed by DigiBoard 10/06/1995
    //
    //    Adapter->MaxFrameSize       = maxFrameSize;
    Adapter->MaxFrameSize       = (maxFrameSize * 2) + PPP_PADDING + 100;

    Adapter->FramesPerPort      = (framesPerPort > 0) ?
                                  framesPerPort : DEFAULT_FRAMES_PER_PORT;

    Adapter->TimeoutBase        = timeoutBase;
    Adapter->TimeoutBaud        = timeoutBaud;
    Adapter->TimeoutReSync      = timeoutReSync;
    Adapter->WriteBufferingEnabled = WriteBufferingEnabled;
    InitializeListHead(&Adapter->ActivePorts);

    //
    // Init the frame lookaside list.  DataSize is dependent
    // on compression compile option.
    //
    {
        ULONG   DataSize;

        DataSize = Adapter->MaxFrameSize;
    
        if (DataSize < DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE)
            DataSize = DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE;

        ExInitializeNPagedLookasideList(&Adapter->AsyncFrameList,
                                        NULL,
                                        NULL,
                                        0,
                                        sizeof(ASYNC_FRAME) +
                                        DataSize +
                                        sizeof(PVOID),
                                        ASYNC_FRAME_TAG,
                                        0);
    }

    //
    // Insert this "new" adapter into our list of all Adapters.
    //

    NdisAcquireSpinLock(&GlobalLock);

    GlobalAdapter = Adapter;
    GlobalAdapterCount++;

    NdisReleaseSpinLock(&GlobalLock);

#ifndef MY_DEVICE_OBJECT
    if (AsyncDeviceObject == NULL) {
        PDRIVER_DISPATCH DispatchTable[IRP_MJ_MAXIMUM_FUNCTION] = {NULL};
        NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\ASYNCMAC");
        NDIS_STRING Name = NDIS_STRING_CONST("\\Device\\ASYNCMAC");
        NTSTATUS    Status;


        DispatchTable[IRP_MJ_CREATE] = AsyncDriverCreate;
        DispatchTable[IRP_MJ_DEVICE_CONTROL] = AsyncDriverDispatch;
        DispatchTable[IRP_MJ_CLEANUP] = AsyncDriverCleanup;

        Status =
        NdisMRegisterDevice(NdisWrapperHandle,
                            &Name,
                            &SymbolicName,
                            DispatchTable,
                            &AsyncDeviceObject,
                            &AsyncDeviceHandle);

        if (Status == STATUS_SUCCESS) {
            AsyncDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        } else {
            AsyncDeviceObject = NULL;
        }
    }
#endif

    //
    //  Initialize the WAN info here.
    //
    Adapter->WanInfo.MaxFrameSize               = DEFAULT_PPP_MAX_FRAME_SIZE;
    Adapter->WanInfo.MaxTransmit                = 2;
    Adapter->WanInfo.HeaderPadding              = DEFAULT_PPP_MAX_FRAME_SIZE;
    Adapter->WanInfo.TailPadding                = 4 + sizeof(IO_STATUS_BLOCK);
    Adapter->WanInfo.MemoryFlags                = 0;
    Adapter->WanInfo.HighestAcceptableAddress   = HighestAcceptableMax;
    Adapter->WanInfo.Endpoints                  = 1000;
    Adapter->WanInfo.FramingBits                = PPP_ALL | SLIP_ALL;
    Adapter->WanInfo.DesiredACCM                = xonXoff;

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
MpReconfigure(
    OUT PNDIS_STATUS    OpenErrorStatus,
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    )
{
    return (NDIS_STATUS_SUCCESS);

}

NDIS_STATUS
MpReset(
    OUT PBOOLEAN        AddressingReset,
    IN  NDIS_HANDLE     MiniportAdapterContext
    )
{
    *AddressingReset = FALSE;

    return (NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\serial.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    serial.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

#define IopQueueThreadIrp( Irp ) {                      \
    KIRQL irql;                                         \
    KeRaiseIrql( (KIRQL)APC_LEVEL, &irql );             \
    InsertHeadList( &Irp->Tail.Overlay.Thread->IrpList, \
                    &Irp->ThreadListEntry );            \
    KeLowerIrql( irql );                                \
    }


VOID
InitSerialIrp(
    PIRP            irp,
    PASYNC_INFO     pInfo,
    ULONG           IoControlCode,
    ULONG           InputBufferLength)
{
    PIO_STACK_LOCATION  irpSp;
    PFILE_OBJECT    fileObject = pInfo->FileObject;

    irpSp = IoGetNextIrpStackLocation(irp);

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = NULL;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    irp->Flags = IRP_BUFFERED_IO;

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

    //
    // stuff in file object
    //
    irpSp->FileObject = fileObject ;

    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = InputBufferLength;
}

NTSTATUS
SerialIoSyncCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
{
    PASYNC_IO_CTX AsyncIoCtx = (PASYNC_IO_CTX)Context;

    DbgTracef(0,("SerialIoSyncCompletion returns 0x%.8x\n", Irp->IoStatus.Status));

    ASSERT(AsyncIoCtx->Sync == TRUE);

    AsyncIoCtx->IoStatus = Irp->IoStatus;

    KeSetEvent(&AsyncIoCtx->Event,      // Event
               1,                       // Priority
               (BOOLEAN)FALSE);         // Wait (does not follow)


    //
    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
SerialIoAsyncCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
{
    DbgTracef(0,("SerialIoAsyncCompletion returns 0x%.8x\n", Irp->IoStatus.Status));

    ASSERT(((PASYNC_IO_CTX)Context)->Sync == FALSE);

    //
    // Free the irp here.  Hopefully this has no disastrous
    // side effects such as the IO system trying to reference
    // the irp when we complete.
    
    IoFreeIrp(Irp);

    AsyncFreeIoCtx((PASYNC_IO_CTX)Context);

    //
    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//*
// Note: we ignore the irp passed in to work around a problem where the SET_QUEUE_SIZE ioctl
// is not completed synchronously
//
//*
VOID
SetSerialStuff(
    PIRP        unusedirp,
    PASYNC_INFO     pInfo,
    ULONG       linkSpeed)

{
    NTSTATUS        status;
    PIRP            irp ;
    PASYNC_IO_CTX   AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_SET_QUEUE_SIZE,
        sizeof(SERIAL_QUEUE_SIZE));


    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    AsyncIoCtx->SerialQueueSize.InSize=4096;
    AsyncIoCtx->SerialQueueSize.OutSize=4096;

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialQueueSize;


    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(pInfo->DeviceObject, irp);

    DbgTracef(0,("IoctlSetQueueSize status 0x%.8x\n", status));

    SetSerialTimeouts(pInfo,linkSpeed);
}


VOID
CancelSerialRequests(
    PASYNC_INFO  pInfo)
/*++


--*/

{
    NTSTATUS        status;
    PASYNC_IO_CTX   AsyncIoCtx;
    PIRP            irp;

    //
    // For PPP we must clear the WAIT MASK if it exists
    //

    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_SET_WAIT_MASK,
        sizeof(ULONG));

    AsyncIoCtx = AsyncAllocateIoCtx(TRUE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    AsyncIoCtx->WaitMask = 0;
    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->WaitMask;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoSyncCompletionRoutine,  // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    KeClearEvent(&AsyncIoCtx->Event);

    status = IoCallDriver(pInfo->DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&AsyncIoCtx->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = AsyncIoCtx->IoStatus.Status;
    }

    DbgTracef(0,("IoctlSerialWaitMask returned with 0x%.8x\n", status));

    if (status != STATUS_SUCCESS) {

        KeSetEvent(&pInfo->ClosingEvent,        //  Event
                   1,                           //  Priority
                   (BOOLEAN)FALSE);         //  Wait (does not follow)
    }

    InitSerialIrp(irp, pInfo, IOCTL_SERIAL_PURGE, sizeof(ULONG));

    RtlZeroMemory(&AsyncIoCtx->IoStatus, sizeof(IO_STATUS_BLOCK));

    // kill all read and write threads.
    AsyncIoCtx->SerialPurge = SERIAL_PURGE_TXABORT | SERIAL_PURGE_RXABORT;

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialPurge;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoSyncCompletionRoutine,  // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel
    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    KeClearEvent(&AsyncIoCtx->Event);
    status = IoCallDriver(pInfo->DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&AsyncIoCtx->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = AsyncIoCtx->IoStatus.Status;
    }

    if (status != STATUS_SUCCESS) {

        KeSetEvent(&pInfo->ClosingEvent,        //  Event
                   1,                           //  Priority
                   (BOOLEAN)FALSE);             //  Wait (does not follow)
    }

    IoFreeIrp(irp);
    AsyncFreeIoCtx(AsyncIoCtx);

    DbgTracef(0,("IoctlSerialPurge returned with 0x%.8x\n", status));
}

VOID
SetSerialTimeouts(
    PASYNC_INFO         pInfo,
    ULONG               linkSpeed)
/*++


--*/

{
    NTSTATUS            status;
    PIRP                irp;
    PASYNC_ADAPTER      pAdapter=pInfo->Adapter;
    PASYNC_IO_CTX       AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_SET_TIMEOUTS,
        sizeof(SERIAL_TIMEOUTS));

    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    //
    // The assumption here is that V.42bis is using 256 byte frames.
    // Thus, it takes (256000 / 8) / (linkspeed in 100's of bits per sec)
    // time in millisecs to get that frame across.
    //
    // 500 or 1/2 sec is the fudge factor for satellite delay on
    // a long distance call
    //

    //
    // If the linkSpeed is high, we assume we are trying to resync
    // so we set the timeout low.  linkSpeed is in 100s of bits per sec.
    //
    if (linkSpeed == 0) {
        //
        // return immediately (PPP or SLIP framing)
        //
        AsyncIoCtx->SerialTimeouts.ReadIntervalTimeout= MAXULONG;

    } else if (linkSpeed > 20000) {

        AsyncIoCtx->SerialTimeouts.ReadIntervalTimeout= pAdapter->TimeoutReSync;

    } else {

        AsyncIoCtx->SerialTimeouts.ReadIntervalTimeout=
            pAdapter->TimeoutBase + (pAdapter->TimeoutBaud / linkSpeed);
    }

    AsyncIoCtx->SerialTimeouts.ReadTotalTimeoutMultiplier=  0;          // none
    AsyncIoCtx->SerialTimeouts.ReadTotalTimeoutConstant=    0;          // none
    AsyncIoCtx->SerialTimeouts.WriteTotalTimeoutMultiplier= 4;          // 2400 baud
    AsyncIoCtx->SerialTimeouts.WriteTotalTimeoutConstant=   4000;       // 4 secs

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialTimeouts;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(pInfo->DeviceObject, irp);

    DbgTracef(0,("IoctlSetSerialTimeouts returned 0x%.8x\n", status));
}


VOID
SerialSetEscapeChar(
    PASYNC_INFO         pInfo,
    UCHAR               EscapeChar) {

    NTSTATUS            status;
    PIRP                irp;
    PASYNC_IO_CTX   AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_LSRMST_INSERT,
        sizeof(UCHAR));

    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    AsyncIoCtx->EscapeChar = EscapeChar;

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->EscapeChar;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(pInfo->DeviceObject, irp);

    DbgTracef(0,("IoctlSetEscapeChar returned with 0x%.8x\n", status));
}


VOID
SerialSetWaitMask(
    PASYNC_INFO         pInfo,
    ULONG               WaitMask) {

    NTSTATUS            status;
    PIRP                irp;
    PASYNC_IO_CTX   AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_SET_WAIT_MASK,
        sizeof(ULONG));

    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    AsyncIoCtx->WaitMask = WaitMask;

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->WaitMask;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //
    status = IoCallDriver(pInfo->DeviceObject, irp);

    DbgTracef(0,("IoctlSetWaitMask returned with 0x%.8x\n", status));
}

VOID
SerialSetEventChar(
    PASYNC_INFO         pInfo,
    UCHAR               EventChar) {

    NTSTATUS            status;
    PIRP                irp;
    PASYNC_IO_CTX       AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_GET_CHARS,
        sizeof(SERIAL_CHARS));

    AsyncIoCtx = AsyncAllocateIoCtx(TRUE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialChars;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoSyncCompletionRoutine,  // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    KeClearEvent(&AsyncIoCtx->Event);
    status = IoCallDriver(pInfo->DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&AsyncIoCtx->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = AsyncIoCtx->IoStatus.Status;
    }

    DbgTracef(0,("IoctlGetChars returned with 0x%.8x\n", status));

    if (status != STATUS_SUCCESS) {
        IoFreeIrp(irp);
        AsyncFreeIoCtx(AsyncIoCtx);
        return;
    }

    AsyncIoCtx->SerialChars.EventChar = EventChar;
    AsyncIoCtx->Sync = FALSE;

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_SET_CHARS,
        sizeof(SERIAL_CHARS));

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(pInfo->DeviceObject, irp);

    DbgTracef(0,("IoctlSetChars returned with 0x%.8x\n", status));
}


VOID
SerialFlushReads(
    PASYNC_INFO         pInfo) {

    ULONG               serialPurge;
    NTSTATUS            status;
    PIRP                irp;
    PASYNC_IO_CTX   AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_PURGE,
        sizeof(ULONG));

    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    // kill read buffer
    AsyncIoCtx->SerialPurge=SERIAL_PURGE_RXCLEAR;

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialPurge;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(pInfo->DeviceObject, irp);
    DbgTracef(0,("IoctlPurge returned with 0x%.8x\n", status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\pppframe.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    pppframe.c

Abstract:

Author:

    Thomas J. Dimitri  (TommyD)

Environment:

Revision History:

--*/

#include "asyncall.h"

VOID
AssemblePPPFrame(
	PNDIS_WAN_PACKET	WanPacket)

{
	PUCHAR		pOldFrame;
	PUCHAR		pNewFrame;
	USHORT		crcData;
	UINT		dataSize;
	PASYNC_INFO	pInfo;
	ULONG		bitMask;

	//
	// Initialize locals
	//

    pOldFrame = WanPacket->CurrentBuffer;

    pNewFrame = WanPacket->StartBuffer;

	//
	// for quicker access, get a copy of data length field
	//
	dataSize = WanPacket->CurrentLength;

	pInfo = WanPacket->MacReserved1;
    bitMask = pInfo->SetLinkInfo.SendACCM;
						

//
// Now we run through the entire frame and pad it FORWARDS...
//
// <------------- new frame -----------> (could be twice as large)
// +-----------------------------------+
// |                                 |x|
// +-----------------------------------+
//									  ^
// <---- old frame -->	   	    	  |
// +-----------------+				  |
// |			   |x|                |
// +-----------------+				  |
//					|				  |
//                  \-----------------/
//
// so that we don't overrun ourselves
//
//-----------------------------------------------------------------------
//
//         +----------+----------+----------+----------+------------
//         |   Flag   | Address  | Control  | Protocol | Information
//         | 01111110 | 11111111 | 00000011 | 16 bits  |      *
//         +----------+----------+----------+----------+------------
//                 ---+----------+----------+-----------------
//                    |   FCS    |   Flag   | Inter-frame Fill
//                    | 16 bits  | 01111110 | or next Address
//                 ---+----------+----------+-----------------
//
//
// Frame Check Sequence (FCS) Field
//
//   The Frame Check Sequence field is normally 16 bits (two octets).  The
//   use of other FCS lengths may be defined at a later time, or by prior
//   agreement.
//
//   The FCS field is calculated over all bits of the Address, Control,
//   Protocol and Information fields not including any start and stop bits
//   (asynchronous) and any bits (synchronous) or octets (asynchronous)
//   inserted for transparency.  This does not include the Flag Sequences
//   or the FCS field itself.  The FCS is transmitted with the coefficient
//   of the highest term first.
//
//      Note: When octets are received which are flagged in the Async-
//      Control-Character-Map, they are discarded before calculating the
//      FCS.  See the description in Appendix A.
//
//
//	RFC 1331                Point-to-Point Protocol                 May 1992
//  Transparency
//
//      On asynchronous links, a character stuffing procedure is used.
//      The Control Escape octet is defined as binary 01111101
//      (hexadecimal 0x7d) where the bit positions are numbered 87654321
//      (not 76543210, BEWARE).
//
//      After FCS computation, the transmitter examines the entire frame
//      between the two Flag Sequences.  Each Flag Sequence, Control
//      Escape octet and octet with value less than hexadecimal 0x20 which
//      is flagged in the Remote Async-Control-Character-Map is replaced
//      by a two octet sequence consisting of the Control Escape octet and
//      the original octet with bit 6 complemented (i.e., exclusive-or'd
//      with hexadecimal 0x20).
//
//      Prior to FCS computation, the receiver examines the entire frame
//      between the two Flag Sequences.  Each octet with value less than
//      hexadecimal 0x20 is checked.  If it is flagged in the Local
//      Async-Control-Character-Map, it is simply removed (it may have
//      been inserted by intervening data communications equipment).  For
//      each Control Escape octet, that octet is also removed, but bit 6
//      of the following octet is complemented.  A Control Escape octet
//      immediately preceding the closing Flag Sequence indicates an
//      invalid frame.
//
//         Note: The inclusion of all octets less than hexadecimal 0x20
//         allows all ASCII control characters [10] excluding DEL (Delete)
//         to be transparently communicated through almost all known data
//         communications equipment.
//
//
//      The transmitter may also send octets with value in the range 0x40
//      through 0xff (except 0x5e) in Control Escape format.  Since these
//      octet values are not negotiable, this does not solve the problem
//      of receivers which cannot handle all non-control characters.
//      Also, since the technique does not affect the 8th bit, this does
//      not solve problems for communications links that can send only 7-
//      bit characters.
//
//      A few examples may make this more clear.  Packet data is
//      transmitted on the link as follows:
//
//         0x7e is encoded as 0x7d, 0x5e.
//         0x7d is encoded as 0x7d, 0x5d.
//
//         0x01 is encoded as 0x7d, 0x21.
//
//      Some modems with software flow control may intercept outgoing DC1
//      and DC3 ignoring the 8th (parity) bit.  This data would be
//      transmitted on the link as follows:
//
//         0x11 is encoded as 0x7d, 0x31.
//         0x13 is encoded as 0x7d, 0x33.
//         0x91 is encoded as 0x7d, 0xb1.
//         0x93 is encoded as 0x7d, 0xb3.
//


	//
	// put CRC from FLAG byte to FLAG byte
	//
	crcData=CalcCRCPPP(pOldFrame,	// Skip FLAG
					   dataSize);	// All the way to end

	crcData ^= 0xFFFF;

	//
	// Do it the hard way to avoid little endian problems.
	//
	pOldFrame[dataSize]=(UCHAR)(crcData);
	pOldFrame[dataSize+1]=(UCHAR)(crcData >> 8);

    dataSize += 2;	// include two CRC bytes we just added

	*pNewFrame++ = PPP_FLAG_BYTE; // 0x7e - mark beginning of frame

	//
	// If we do not have a bitMask (common case), we use a faster loop
	//
	if (bitMask) {
	
		//
		// loop to remove all control, ESC, and FLAG chars
		//
		while (dataSize--) {
			UCHAR c;

			c=*pOldFrame++;	// get current byte in frame

			//
			// Check if we have to escape out this byte or not
			//
			if ( ( (c < 32) && ((0x01 << c) & bitMask)) ||
			    	c == PPP_ESC_BYTE || c == PPP_FLAG_BYTE) {
			
				*pNewFrame++ = PPP_ESC_BYTE;
				*pNewFrame++ = c ^ 0x20;

			} else {
	
				*pNewFrame++ = c;
			}
		}

	} else {

		//
		// loop to remove all ESC and FLAG chars
		//
		while (dataSize--) {
			UCHAR c;

			c=*pOldFrame++;	// get current byte in frame

			//
			// Check if we have to escape out this byte or not
			//
			if (c == PPP_ESC_BYTE || c == PPP_FLAG_BYTE) {
			
				*pNewFrame++ = PPP_ESC_BYTE;
				*pNewFrame++ = c ^ 0x20;

			} else {
	
				*pNewFrame++ = c;
			}
		}

	}


	//
	// Mark end of frame
	//
	*pNewFrame++= PPP_FLAG_BYTE;

	//
	// Calc how many bytes we expanded to including CRC
	//
	WanPacket->CurrentLength = (ULONG)(pNewFrame - WanPacket->StartBuffer);

	//
	// Put in the adjusted length -- actual num of bytes to send
	//

	WanPacket->CurrentBuffer = WanPacket->StartBuffer;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\read.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    _read.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

#define RAISEIRQL

#if DBG
ULONG UlFramesUp = 0;
#endif


#ifdef  LALALA
PVOID   CurrentWatchPoint=0;

static
VOID
AsyncSetBreakPoint(
    PVOID   LinearAddress) {

    ASSERT(CurrentWatchPoint == 0);
    CurrentWatchPoint = LinearAddress;

    _asm {
        mov eax, LinearAddress
        mov dr0, eax
        mov eax, dr7
        or  eax, 10303h
        mov dr7, eax
    }
}


static
VOID
AsyncRemoveBreakPoint(
    PVOID LinearAddress) {

    ASSERT(CurrentWatchPoint == LinearAddress);
    CurrentWatchPoint = 0;

    _asm {

        mov eax, dr7
        mov ebx, 10003h
        not ebx
        and eax, ebx
        mov dr7, eax

    }
}
#endif

//   the function below is called by an executive worker thread
//   to start reading frames.

NTSTATUS
AsyncStartReads(
    PASYNC_INFO pInfo
)

/*++



--*/

{
    UCHAR   eventChar;

    //
    //   Initialize locals.
    //

    //
    //  assign back ptr from frame to adapter
    //

    pInfo->AsyncFrame->Adapter = pInfo->Adapter;

    //
    //  assign other back ptr
    //

    pInfo->AsyncFrame->Info = pInfo;

    //
    //  set baud rate and timeouts
    //  we use a linkspeed of 0 to indicate
    //  no read interval timeout
    //

    SetSerialStuff(NULL, pInfo, 0);

    eventChar = PPP_FLAG_BYTE;

    if (pInfo->GetLinkInfo.RecvFramingBits & SLIP_FRAMING) {

        eventChar = SLIP_END_BYTE;
    }

    SerialSetEventChar(pInfo, eventChar);

    //
    //   We will wait on whenever we get the special PPP flag byte
    //   or whenever we get RLSD or DSR changes (for possible hang-up
    //   cases) or when the receive buffer is getting full.
    //

    SerialSetWaitMask(pInfo, pInfo->WaitMaskToUse) ;

    //
    //   For SLIP and PPP reads we use the AsyncPPPRead routine.
    //
    AsyncPPPRead(pInfo);

    return NDIS_STATUS_SUCCESS;
}


VOID
AsyncIndicateFragment(
    IN PASYNC_INFO  pInfo,
    IN ULONG        Error)
{

    PASYNC_ADAPTER      pAdapter=pInfo->Adapter;
    NDIS_MAC_FRAGMENT   AsyncFragment;

    AsyncFragment.NdisLinkContext = pInfo->NdisLinkContext;
    AsyncFragment.Errors = Error;


    //
    //  Tell the transport above (or really RasHub) that a frame
    //  was just dropped.  Give the endpoint when doing so.
    //
    NdisMIndicateStatus(
        pAdapter->MiniportHandle,
        NDIS_STATUS_WAN_FRAGMENT,       //  General Status
        &AsyncFragment,                 //  Specific Status (address)
        sizeof(NDIS_MAC_FRAGMENT));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\pppread.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pppread.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#include "asyncall.h"

NTSTATUS
AsyncSLIPCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);

NTSTATUS
AsyncWaitMaskCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);

NTSTATUS
AsyncPPPWaitMask(
    IN PASYNC_INFO Info)

/*++

Assumption -- 0 length frames are not sent (this includes headers)!!!
Also, this is NOT a synchronous operation.  It is always asynchronous.

Routine Description:

    This service writes Length bytes of data from the caller's Buffer to the
    "port" handle.  It is assumed that the handle uses non-buffered IO.

--*/
{
    NTSTATUS            status;
    PIRP                irp;
    PASYNC_FRAME        pFrame;
    PASYNC_ADAPTER      pAdapter=Info->Adapter;

    pFrame=Info->AsyncFrame;

    irp = 
        IoAllocateIrp(Info->DeviceObject->StackSize, (BOOLEAN)FALSE);

    InitSerialIrp(irp,
                  Info,
                  IOCTL_SERIAL_WAIT_ON_MASK,
                  sizeof(ULONG));

    irp->AssociatedIrp.SystemBuffer=&pFrame->WaitMask;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            AsyncWaitMaskCompletionRoutine, // routine to call when irp is done
            Info,                           // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(Info->DeviceObject, irp);

    //
    // Status for a local serial driver should be
    // STATUS_SUCCESS since the irp should complete
    // immediately because there are no read timeouts.
    //
    // For a remote serial driver, it will pend.
    //
    return(status);
}


NTSTATUS
AsyncPPPCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)

/*++

    This is the IO Completion routine for ReadFrame.

--*/
{
    NTSTATUS        status;
    PASYNC_INFO     pInfo;
    ULONG           bytesReceived;

    PASYNC_FRAME    pFrame;
    PUCHAR          frameStart, frameEnd;
    USHORT          crcData;
    PUCHAR          frameEnd2,frameStart2;
    ULONG           bitMask;
    LONG            bytesWanted;

    DeviceObject;       // prevent compiler warnings

    status = Irp->IoStatus.Status;
    bytesReceived=(ULONG)Irp->IoStatus.Information;

    IoFreeIrp(Irp);

    pInfo=Context;

    pFrame=pInfo->AsyncFrame;

    switch (status) {

    case STATUS_SUCCESS:

        pFrame=pInfo->AsyncFrame;

        //
        // Any bytes to process?  This can happen if
        // the WaitMask completes late and by the time
        // we process the read, another event character has come
        // in.
        //
        if (bytesReceived==0) {
            break;
        }

        //
        // Update num of bytes read total for this frame
        //
        pInfo->BytesRead = bytesReceived = pInfo->BytesRead + bytesReceived;

        //
        // Set frameEnd to last byte processed.  Initially,
        // we have processed nothing (i.e. processed up to
        // the start of the first byte).
        //
        frameStart=pFrame->Frame + PPP_PADDING;

PROCESS_FRAME:
        //
        // Now we have actuallyRead bytes unused
        // Also, we may have a complete frame.
        //
        while (*frameStart == PPP_FLAG_BYTE && --bytesReceived) {
            frameStart++;
        }

        //
        // If we reach here, there is only a start FLAG...
        //
        if (bytesReceived == 0) {
            break;
        }

        //
        // frameEnd is set to the first byte not yet processed.
        // If we are starting out, that is the first byte!
        //
        frameEnd=frameStart;

        //
        // Assume the start of the frame has the PPP_FLAG_BYTE
        // Look for the second PPP_FLAG_BYTE (end of frame)
        //
        while (*frameEnd != PPP_FLAG_BYTE && --bytesReceived) {
            frameEnd++;
        }

        //
        // At this point...
        // frameStart = beginning PPP_FLAG_BYTE seen
        // frameEnd = end PPP_FLAG_BYTE
        // bytesReceived = bytes after frameEnd not processed
        //

        //
        // if bytesReceived is 0, we ran out of space before hitting
        // the END flag.  We will have to wait for the next round
        //
        // NOTE: if BytesRead gets too high we trash the frame
        // because we could not find the FLAG_BYTE
        //
        if (bytesReceived==0) {
            break;
        }
        
        if (*(pFrame->Frame+PPP_PADDING) != PPP_FLAG_BYTE) {

            //
            // We had garbage at the start.  Remove the garbage.
            //
            pInfo->SerialStats.AlignmentErrors++;

            //
            //  Tell the transport above us that we dropped a packet
            //  Hopefully, it will quickly resync.
            //
            AsyncIndicateFragment(
                pInfo,
                WAN_ERROR_ALIGNMENT);


            goto NEXT_PPP_FRAME;
        }

        //
        // Length of frame is frameEnd - frameStart
        //
        bytesWanted = (LONG)(frameEnd - frameStart);


        bitMask = pInfo->Adapter->WanInfo.DesiredACCM;

        frameEnd2 = frameStart2 = frameStart;

        //
        // Replace back all control chars, ESC, and FLAG chars
        //
        while (bytesWanted-- > 0) {
            if ((*frameEnd2=*frameStart2++) == PPP_ESC_BYTE) {

                //
                // We have not run the CRC check yet!!
                // We have be careful about sending bytesWanted
                // back to -1 on corrupted data
                //

                bytesWanted--;

                *frameEnd2 = (*frameStart2++ ^ 0x20);
            }

            frameEnd2++;
        }

        if (*frameStart2 != PPP_FLAG_BYTE) {
            DbgTracef(-2,("BAD PPP FRAME at 0x%.8x  0x%.8x\n", frameStart, frameEnd2));
        }

        //
        // if CRC-16, get 16 bit CRC from end of frame
        //
        frameEnd2 -= 2;

        //
        // Little endian assumptions for CRC
        //
        crcData=(USHORT)frameEnd2[0]+(USHORT)(frameEnd2[1] << 8);
        crcData ^= 0xFFFF;

        //
        // Change the bytesWanted field to what it normally is
        // without the byte stuffing (length of frame between flags)
        // Note that it can be -1 if only one byte was
        // found in between the flag bytes
        //
        bytesWanted = (LONG)(frameEnd2 - frameStart);

        //
        // If we get some sort of garbage inbetween
        // the PPP flags, we just assume it is noise and
        // discard it.  We don't record a PPP CRC error just
        // an alignment error.
        //
        if (bytesWanted < 3) {
            pInfo->SerialStats.AlignmentErrors++;
            //
            //  Tell the transport above us that we dropped a packet
            //  Hopefully, it will quickly resync.
            //
            AsyncIndicateFragment(pInfo, WAN_ERROR_ALIGNMENT);

            goto NEXT_PPP_FRAME;
        }

        //
        // get CRC from FLAG byte to FLAG byte
        //
        if (crcData != CalcCRCPPP(frameStart, bytesWanted)) {

            DbgTracef(0,("---CRC check failed on control char frame!\n"));

            //
            // Record the CRC error
            //
            pInfo->SerialStats.CRCErrors++;

            //
            //  Tell the transport above us that we dropped a packet
            //  Hopefully, it will quickly resync.
            //
            AsyncIndicateFragment(
                pInfo,
                WAN_ERROR_CRC);


            goto NEXT_PPP_FRAME;
        }

/*
        for ( i = 0; (i < (ULONG)bytesWanted) && (i < 48); i++ )
        {
            if ( (i & 15) == 0 )
                DbgTracef(-1, ("\nrx:\t") );
            DbgTracef(-1, ("%.2x ", frameStart[i]) );
        }
        DbgTracef(-1, ("\n") );
*/
    {
        KIRQL               irql;
        NDIS_STATUS         Status;
        PASYNC_ADAPTER      Adapter = pInfo->Adapter;

        KeRaiseIrql( (KIRQL)DISPATCH_LEVEL, &irql );
        //
        // Tell the transport above (or really RasHub) that the connection
        // is now up.  We have a new link speed, frame size, quality of service
        //

        NdisMWanIndicateReceive(&Status,
                               Adapter->MiniportHandle,
                               pInfo->NdisLinkContext,
                               frameStart,              // ptr to start of packet
                               bytesWanted);            // Total packet length  - header
        NdisMWanIndicateReceiveComplete(Adapter->MiniportHandle,
                                       pInfo->NdisLinkContext);

        KeLowerIrql( irql );
    }
    
    NEXT_PPP_FRAME:

        //
        // if bytesReceived == 0 no frame was found
        // thus we must keep the current frame and continue
        // processing
        //
        if (bytesReceived) {

            //
            // Calculate how much of what we received
            // just got passed up as a frame and move the
            // rest to the beginning.
            //
            frameStart=pFrame->Frame + PPP_PADDING;
            frameEnd2=frameStart + pInfo->BytesRead;
            pInfo->BytesRead =
                            bytesReceived = (ULONG)(frameEnd2-frameEnd);

            ASYNC_MOVE_MEMORY(
                frameStart,         // dest
                frameEnd,           // src
                bytesReceived);     // length

            //
            // Need at least four bytes for a frame to exist
            //
            if (bytesReceived > 3) {
                goto PROCESS_FRAME;
            }
        }

        break;

    case STATUS_PENDING:
        DbgTracef(0,("---ASYNC: Status PENDING on read\n"));

    case STATUS_CANCELLED:
        // else this is an anomally!
        DbgTracef(-2,("---ASYNC: Status cancelled on read for unknown reason!!\n"));

    default:
#if DBG
        DbgPrint ("AsyncPPPCompletionRoutine: status == %x, no more reads\n", status) ;
#endif
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //
    // Here we are at the end of processing this IRP so we go
    // ahead and post another read from the serial port.
    //
    AsyncPPPWaitMask(pInfo);

    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    return(STATUS_MORE_PROCESSING_REQUIRED);
}


NTSTATUS
AsyncPPPRead(
    IN PASYNC_INFO Info)


/*++

Assumption -- 0 length frames are not sent (this includes headers)!!!
Also, this is NOT a synchronous operation.  It is always asynchronous.

MUST use non-paged pool to read!!!

Routine Description:

    This service writes Length bytes of data from the caller's Buffer to the
    "port" handle.  It is assumed that the handle uses non-buffered IO.

--*/
{
    NTSTATUS            status;
    PIRP                irp;
    PDEVICE_OBJECT      deviceObject=Info->DeviceObject;
    PFILE_OBJECT        fileObject=Info->FileObject;
    PIO_STACK_LOCATION  irpSp;
    PASYNC_FRAME        pFrame;
    PASYNC_ADAPTER      pAdapter=Info->Adapter;
    PIO_COMPLETION_ROUTINE routine;

    pFrame=Info->AsyncFrame;

    //
    // check if this port is closing down or already closed
    //
    if (Info->PortState == PORT_CLOSING ||
        Info->PortState == PORT_CLOSED) {

        if (Info->PortState == PORT_CLOSED) {
            DbgTracef(-2,("ASYNC: Port closed - but still reading on it!\n"));
        }

        //
        // Acknowledge that the port is closed
        //
        KeSetEvent(&Info->ClosingEvent,     // Event
                   1,                           // Priority
                   (BOOLEAN)FALSE);         // Wait (does not follow)

        //
        // Ok, if this happens, we are shutting down.  Stop
        // posting reads.  Don't make it try to deallocate the irp!
        //
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //
    //  Has our stack counter reached its max?
    //

    if ( Info->ReadStackCounter > 1 ) {

        //
        //  Send off the worker thread to compress this frame
        //
    
        ExInitializeWorkItem(&pFrame->WorkItem,
            (PWORKER_THREAD_ROUTINE) AsyncPPPRead, Info);

        //
        // reset stack counter since we are scheduling
        // a worker thread
        //
        Info->ReadStackCounter=0;

        //
        //  We choose to be nice and use delayed.
        //

        ExQueueWorkItem(&pFrame->WorkItem, DelayedWorkQueue);


        return NDIS_STATUS_PENDING;
    }

    //
    //  One more stack used up.
    //

    Info->ReadStackCounter++;


    // get irp from frame (each frame has an irp allocate with it)

    irp =
        IoAllocateIrp(Info->DeviceObject->StackSize, (BOOLEAN)FALSE);

    // Setup this irp with defaults
    AsyncSetupIrp(pFrame, irp);

    //
    // If we've read all the bytes we can and we still do not
    // have a frame, we trash our buffer and start over
    // again.
    //

    if (Info->BytesRead >= (DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE - PPP_PADDING)) {

        Info->SerialStats.BufferOverrunErrors++;

        //
        //  Tell the transport above us that we dropped a packet
        //  Hopefully, it will quickly resync.
        //
        AsyncIndicateFragment(Info, WAN_ERROR_BUFFEROVERRUN);

        Info->BytesRead=0;
    }
    
    irp->AssociatedIrp.SystemBuffer =
         pFrame->Frame + Info->BytesRead + PPP_PADDING;


    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;
    if (fileObject->Flags & FO_WRITE_THROUGH) {
        irpSp->Flags = SL_WRITE_THROUGH;
    }

    //
    // If this write operation is to be performed without any caching, set the
    // appropriate flag in the IRP so no caching is performed.
    //

    irp->Flags |= IRP_READ_OPERATION;

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length =
        DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE - Info->BytesRead - PPP_PADDING;

    irpSp->Parameters.Read.Key = 0;                     // we don't use a key
    irpSp->Parameters.Read.ByteOffset = fileObject->CurrentByteOffset;

    if ( Info->GetLinkInfo.SendFramingBits & SLIP_FRAMING ) {

        routine=AsyncSLIPCompletionRoutine;

    } else {

        routine=AsyncPPPCompletionRoutine;
    }

    IoSetCompletionRoutine(
            irp,                            // irp to use
            routine,                        // routine to call when irp is done
            Info,                           // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // We DO NOT insert the packet at the head of the IRP list for the thread.
    // because we do NOT really have an IoCompletionRoutine that does
    // anything with the thread.
    //

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(deviceObject, irp);

    //
    // unroll the stack counter
    //
    if ( Info->ReadStackCounter > 0 ) {

        Info->ReadStackCounter--;
    }

    //
    // Status for a local serial driver should be
    // STATUS_SUCCESS since the irp should complete
    // immediately because there are no read timeouts.
    //
    // For a remote serial driver, it will pend.
    //
    return(status);
}


NTSTATUS
AsyncWaitMaskCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)

/*++

    This is the IO Completion routine for ReadFrame.

--*/
{
    NTSTATUS        status;
    PASYNC_INFO     pInfo=Context;
    PASYNC_FRAME    pFrame;
    DeviceObject;   // avoid compiler warnings

    status = Irp->IoStatus.Status;
    pFrame=pInfo->AsyncFrame;

    IoFreeIrp(Irp);

    // check if this port is closing down or already closed
    if (pInfo->PortState == PORT_CLOSING ||
        pInfo->PortState == PORT_CLOSED) {

        if (pInfo->PortState == PORT_CLOSED) {
            DbgTracef(-2,("ASYNC: Port closed - but still reading on it!\n"));
        }

        //
        // Acknowledge that the port is closed
        //
        KeSetEvent(
            &pInfo->ClosingEvent,       // Event
            1,                          // Priority
            (BOOLEAN)FALSE);            // Wait (does not follow)

        DbgTracef(1,("ASYNC: PPP no longer holds the wait_on_mask\n"));

        //
        // Ok, if this happens, we are shutting down.  Stop
        // posting reads.  Don't make it try to deallocate the irp!
        //
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    // wait failed
    //
    if (status != STATUS_SUCCESS) {

        pInfo->PortState = PORT_FRAMING;

        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //
    //  Send off a irp to check comm status
    //  of this port (because we suspect a problem).
    //
    if (pFrame->WaitMask & SERIAL_EV_ERR) {
        AsyncCheckCommStatus(pInfo);
    }

    //
    // Check if RLSD or DSR changed state.
    // If so, we probably have to complete and IRP
    //
    if (pFrame->WaitMask & (SERIAL_EV_RLSD | SERIAL_EV_DSR)) {
        TryToCompleteDDCDIrp(pInfo);
    }

#if DBG
    if (status == STATUS_INVALID_PARAMETER) {

        DbgPrint("ASYNC: PPP BAD WAIT MASK!  Irp is at 0x%.8x\n",Irp);
        DbgBreakPoint();
    }
#endif

    //
    // If we have some more bytes (specifically the event character)
    // in the buffer, let's process those new bytes
    //
    if (pFrame->WaitMask & (SERIAL_EV_RXFLAG | SERIAL_EV_RX80FULL)) {

        //
        // Read current buffer and try to process a frame
        //

        AsyncPPPRead(pInfo);

    } else {
        //
        // Set another WaitMask call
        //
        AsyncPPPWaitMask(pInfo);
    }

    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    return(STATUS_MORE_PROCESSING_REQUIRED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\send.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    send.c

Abstract:


    NOTE: ZZZ There is a potential priority inversion problem when
    allocating the packet.  For nt it looks like we need to raise
    the irql to dpc when we start the allocation.

Author:

    Thomas J. Dimitri 8-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    Ray Patch (raypa)       04/13/94        Modified for new WAN wrapper.

--*/

#include "asyncall.h"
#include "globals.h"

//
//  Forward references.
//

extern
NTSTATUS
AsyncWriteCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PNDIS_WAN_PACKET WanPacket);

//=============================================================================
//  Function:
//
//      AsyncSend()
//
//  Description:
//
//      This function is the main entry point for transmitting data to the serial
//      driver. When entered, we get the MAC binding handle (a pointer to our
//      private data structure) and the WAN packet which we are going to send.
//      We don't bother queuing the frame, we simple allocate an IRP and ship
//      it to the serial driver and let him worry about it.
//
//  In Parameters:
//
//      NdisLinkContext - Pointer to the ASYNC_INFO structure.
//
//      Packet - WAN packet containing the data to be framed and shipped.
//
//  Out Parameters:
//
//      None.
//
//  Return status:
//
//      NDIS_STATUS_SUCCESS.
//=============================================================================

NDIS_STATUS
MpSend(
    IN NDIS_HANDLE      MacBindingHandle,
    IN NDIS_HANDLE      NdisLinkHandle,
    IN PNDIS_WAN_PACKET Packet)
{

    PASYNC_INFO         AsyncInfo;
    NDIS_STATUS         Status;

    DbgTracef(1,("AS\n"));

    //
    //  Get the open handle for this MAC binding.
    //

    AsyncInfo = (PASYNC_INFO) NdisLinkHandle;

    //
    //  First make sure this link is still up.
    //

    if (AsyncInfo->PortState == PORT_FRAMING &&
        (AsyncInfo->GetLinkInfo.SendFramingBits & 
         (PPP_FRAMING | SLIP_FRAMING)) != 0)
    {

        //
        //  Now we can send this frame.
        //
    
        Status = AsyncSendPacket(
                    NdisLinkHandle,
                    Packet);
    
        // For all Status values (PENDING, SUCCESS, and ERROR) the callback from Write will
        // do a sendcomplete indication so we always return PENDING.
        //
        Status = STATUS_PENDING ;
    }
    else
    {

        DbgTracef(-2,("AsyncSend: Link not found, dropping packet!\n"));

        Status = NDIS_STATUS_SUCCESS;
    }

    return Status;
}

//=============================================================================
//  Function:
//
//      AsyncSendPacket()
//
//  Description:
//      This function is called from AsyncSend() to send an IRP to the serial
//      driver. If this IRP pends, the the I/O complete routine will be called
//      later to complete the request.
//
//  In Parameters:
//
//      Packet - WAN packet containing the data to be framed and shipped.
//
//  Out Parameters:
//
//      None.
//
//  Return status:
//
//      NDIS_STATUS_SUCCESS.
//=============================================================================

NTSTATUS
AsyncSendPacket(
    IN PASYNC_INFO      AsyncInfo,
    IN PNDIS_WAN_PACKET WanPacket)

{
    NTSTATUS            Status;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    PFILE_OBJECT        FileObject;
    PDEVICE_OBJECT      DeviceObject;
    PASYNC_ADAPTER      Adapter;
    UCHAR               irpStackSize;

    //
    //  Initialize locals.
    //

    FileObject   = AsyncInfo->FileObject;

    DeviceObject = AsyncInfo->DeviceObject;

    Adapter = AsyncInfo->Adapter;

    irpStackSize = (UCHAR) Adapter->IrpStackSize;

    //
    //  Get irp from irp pool.
    //

    irp = IoAllocateIrp(DeviceObject->StackSize, (BOOLEAN)FALSE);

    //
    // The IO subsystem may be out of irps.
    //

    if (irp == NULL) {
        return(NDIS_STATUS_RESOURCES);
    }

    //
    // Tuck pointer to AsyncInfo for completion use
    //

    WanPacket->MacReserved1 = AsyncInfo;

    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = NULL;

    //
    // 8 byte align (also use end of packet for IOSB).
    //

    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;


    //
    //  Get a pointer to the stack location for the first driver.  This will be
    //  used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    irpSp->MajorFunction = IRP_MJ_WRITE;

    irpSp->FileObject = FileObject;

    if (FileObject->Flags & FO_WRITE_THROUGH) {

        irpSp->Flags = SL_WRITE_THROUGH;
    }

    //
    //  If this write operation is to be performed without any caching, set the
    //  appropriate flag in the IRP so no caching is performed.
    //

    if (FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

        irp->Flags |= (IRP_NOCACHE | IRP_WRITE_OPERATION);

    } else {

        irp->Flags |= IRP_WRITE_OPERATION;
    }

    //
    //  Assemble a RAS, PPP, SLIP frame type.
    //

    if (AsyncInfo->GetLinkInfo.SendFramingBits & PPP_FRAMING) {

        AssemblePPPFrame(WanPacket);

    } else

    if (AsyncInfo->GetLinkInfo.SendFramingBits & SLIP_FRAMING) {

        AssembleSLIPFrame(WanPacket);

    }

    irp->AssociatedIrp.SystemBuffer =
        WanPacket->CurrentBuffer;

    DbgTracef(0, ("Writing out %.2x %.2x %.2x %.2x %.2x\n",
        WanPacket->CurrentBuffer[0],
        WanPacket->CurrentBuffer[1],
        WanPacket->CurrentBuffer[2],
        WanPacket->CurrentBuffer[3],
        WanPacket->CurrentBuffer[4]));

    //
    //  Copy the caller's parameters to the service-specific portion of the IRP.
    //

    irpSp->Parameters.Write.Length = WanPacket->CurrentLength;

    irpSp->Parameters.Write.Key =  0;

    irpSp->Parameters.Write.ByteOffset = FileObject->CurrentByteOffset;

    //
    //  Setup IRP for callback.
    //

    IoSetCompletionRoutine(
        irp,                            //  irp to use
        AsyncWriteCompletionRoutine,    //  routine to call when irp is done
        WanPacket,                      //  context to pass routine
        TRUE,                           //  call on success
        TRUE,                           //  call on error
        TRUE);                          //  call on cancel


    //
    //  We DO NOT insert the packet at the head of the IRP list for the thread.
    //  because we do NOT really have an IoCompletionRoutine that does
    //  anything with the thread or needs to be in that thread's context.
    //

    GlobalXmitWentOut++;

    AsyncInfo->In++;

    //
    //  Now simply invoke the driver at its dispatch entry with the IRP.
    //

    Status = IoCallDriver(DeviceObject, irp);

    //  According to TonyE, the status for the serial driver should
    //  always be STATUS_PENDING.  DigiBoard usually STATUS_SUCCESS.

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\slipfram.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    slipframe.c

Abstract:

Author:

    Thomas J. Dimitri  (TommyD)

Environment:

Revision History:

    Ray Patch (raypa)       04/13/94        Modified for new WAN wrapper.

--*/

#include "asyncall.h"


VOID
AssembleSLIPFrame(
    PNDIS_WAN_PACKET pFrame)

{
	PUCHAR		pOldFrame;
	PUCHAR		pNewFrame;
	UINT		dataSize;
        UCHAR           c;

	//
	// Initialize locals
	//

    pOldFrame=pFrame->CurrentBuffer;

    pNewFrame  =pFrame->StartBuffer;

	//
	// for quicker access, get a copy of data length field
	//
	dataSize=pFrame->CurrentLength;

    //
    // Now we run through the entire frame and pad it FORWARDS...
    //
    // <------------- new frame -----------> (could be twice as large)
    // +-----------------------------------+
    // |                                 |x|
    // +-----------------------------------+
    //									  ^
    // <---- old frame -->	   	    	  |
    // +-----------------+				  |
    // |			   |x|                |
    // +-----------------+				  |
    //					|				  |
    //                  \-----------------/
    //
    //
    //
    //         192 is encoded as 219, 220
    //         219 is encoded as 219, 221
    //

	*pNewFrame++ = SLIP_END_BYTE; // 192 - mark beginning of frame

    //
    // loop to remove all 192 and 219 chars
    //

    while ( dataSize-- ) {

		c = *pOldFrame++;

		//
		// Check if we have to escape out this byte or not
		//

		switch (c) {

	    case SLIP_END_BYTE:

			*pNewFrame++ = SLIP_ESC_BYTE;
			*pNewFrame++ = SLIP_ESC_END_BYTE;
			break;

	    case SLIP_ESC_BYTE:
			*pNewFrame++ = SLIP_ESC_BYTE;
			*pNewFrame++ = SLIP_ESC_ESC_BYTE;
			break;

	    default:
			*pNewFrame++ = c;

		}
    }

    //
    //  Mark end of frame
    //
    *pNewFrame++ = SLIP_END_BYTE;

	//
	// Calc how many bytes we expanded to including CRC
	//
	pFrame->CurrentLength = (ULONG)(pNewFrame - pFrame->StartBuffer);

	//
	// Put in the adjusted length -- actual num of bytes to send
	//
	pFrame->CurrentBuffer = pFrame->StartBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\slipread.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    slipread.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#include "asyncall.h"

NTSTATUS
AsyncWaitMaskCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);


NTSTATUS
AsyncPPPWaitMask(
    IN PASYNC_INFO Info);


NTSTATUS
AsyncSLIPCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)

/*++

    This is the IO Completion routine for ReadFrame.

--*/
{
    NTSTATUS        status;
    PASYNC_INFO     pInfo;
    ULONG           bytesReceived;

    PASYNC_FRAME    pFrame;
    PUCHAR          frameStart, frameEnd;
    PUCHAR          frameEnd2,frameStart2;
    ULONG           bitMask;
    LONG            bytesWanted;        // keep this a long ( < 0 is used)


    DeviceObject;       // prevent compiler warnings

    status = Irp->IoStatus.Status;
    bytesReceived=(ULONG)Irp->IoStatus.Information;

    IoFreeIrp(Irp);

    pInfo=Context;

    pFrame=pInfo->AsyncFrame;

    switch (status) {

    case STATUS_SUCCESS:


        //
        // Any bytes to process?  This can happen if
        // the WaitMask completes late and by the time
        // we process the read, another event character has come
        // in.
        //
        if (bytesReceived==0) {
            break;
        }

        //
        // Update num of bytes read total for this frame
        //
        pInfo->BytesRead = bytesReceived = pInfo->BytesRead + bytesReceived;

        //
        // Set frameEnd to last byte processed.  Initially,
        // we have processed nothing (i.e. processed up to
        // the start of the first byte).
        //
        frameStart=pFrame->Frame + PPP_PADDING;

PROCESS_FRAME:
        //
        // Now we have actuallyRead bytes unused
        // Also, we may have a complete frame.
        //
        while (*frameStart == SLIP_END_BYTE && --bytesReceived) {
            frameStart++;
        }

        //
        // If we reach here, there is no end FLAG
        //
        if (bytesReceived == 0) {
            break;
        }

        //
        // frameEnd is set to the first byte not yet processed.
        // If we are starting out, that is the first byte!
        //
        frameEnd=frameStart;

        //
        // Assume the start of the frame has the SLIP_END_BYTE
        // Look for the second SLIP_END_BYTE (end of frame)
        //
        while (*frameEnd != SLIP_END_BYTE && --bytesReceived) {
            frameEnd++;
        }

        //
        // if bytesReceived is 0, we got nothing
        //
        // NOTE: if BytesRead gets too high we trash the frame
        // because we could not find the FLAG_BYTE
        //
        if (bytesReceived==0) {
            break;
        }
        
        if (*(pFrame->Frame+PPP_PADDING) != SLIP_END_BYTE) {
            //
            // We had garbage at the start.  Remove the garbage.
            //

            pInfo->SerialStats.AlignmentErrors++;

            //
            //  Tell the transport above us that we dropped a packet
            //  Hopefully, it will quickly resync.
            //
            AsyncIndicateFragment(
                pInfo,
                WAN_ERROR_ALIGNMENT);

            goto NEXT_SLIP_FRAME;
        }

        //
        // Length of frame is frameEnd - frameStart
        //
        bytesWanted = (LONG)(frameEnd - frameStart);

        bitMask = pInfo->Adapter->WanInfo.DesiredACCM;

        frameEnd2 = frameStart2 = frameStart;

        //
        // Replace back all control chars, ESC, and FLAG chars
        //
        while (bytesWanted-- > 0) {
            if ((*frameEnd2=*frameStart2++) == SLIP_ESC_BYTE) {

                //
                // We have not run the CRC check yet!!
                // We have be careful about sending bytesWanted
                // back to -1 on corrupted data
                //

                bytesWanted--;

                *frameEnd2 = SLIP_END_BYTE;

                if (*frameStart2++ == SLIP_ESC_ESC_BYTE) {
                    *frameEnd2 = SLIP_ESC_BYTE;
                }
            }

            frameEnd2++;
        }

        //
        // Change the bytesWanted field to what it normally is,
        // the length of the frame.
        //
        bytesWanted = (LONG)(frameEnd2 - frameStart);

        // Keep those stats up to date
        {
            KIRQL       irql;
            NTSTATUS    Status;
            PASYNC_ADAPTER  Adapter = pInfo->Adapter;

            KeRaiseIrql( (KIRQL)DISPATCH_LEVEL, &irql );

            //
            // Compressed TCP/IP packets must at least 3 bytes long
            //
            if (bytesWanted >= 3) {
        
                NdisMWanIndicateReceive(
                    &Status,
                    Adapter->MiniportHandle,
                    pInfo->NdisLinkContext,
                    frameStart,
                    bytesWanted);
    
                NdisMWanIndicateReceiveComplete(
                    Adapter->MiniportHandle,
                    pInfo->NdisLinkContext);

            } else {

                pInfo->SerialStats.AlignmentErrors++;

                //
                //  Tell the transport above us that we dropped a packet
                //  Hopefully, it will quickly resync.
                //
                AsyncIndicateFragment(
                    pInfo,
                    WAN_ERROR_ALIGNMENT);

                DbgTracef(-2,("SLIP: Frame too small %u\n", bytesWanted));
            }


            KeLowerIrql( irql );
        }

    NEXT_SLIP_FRAME:

        //
        // if bytesReceived == 0 no frame was found
        // thus we must keep the current frame and continue
        // processing
        //
        if (bytesReceived) {

            //
            // Calculate how much of what we received
            // just got passed up as a frame and move the
            // rest to the beginning.
            //
            frameStart=pFrame->Frame + PPP_PADDING;
            frameEnd2=frameStart + pInfo->BytesRead;
            pInfo->BytesRead =
                            bytesReceived = (LONG)(frameEnd2-frameEnd);

            ASYNC_MOVE_MEMORY(
                frameStart,         // dest
                frameEnd,           // src
                bytesReceived);     // length

            //
            // Need at least four bytes for a frame to exist
            //
            if (bytesReceived > 3) {
                goto PROCESS_FRAME;
            }
        }

        break;

    case STATUS_CANCELLED:
        // else this is an anomally!
        DbgTracef(-2,("---ASYNC: Status cancelled on read for unknown reason!!\n"));
        break;

    case STATUS_PENDING:
        DbgTracef(0,("---ASYNC: Status PENDING on read\n"));
        break;

    default:
        DbgTracef(-2,("---ASYNC: Unknown status 0x%.8x on read",status));
        break;

    }

    //
    // Here we are at the end of processing this IRP so we go
    // ahead and post another read from the serial port.
    //
    AsyncPPPWaitMask(pInfo);

    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    return(STATUS_MORE_PROCESSING_REQUIRED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\asyncmac\write.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    _write.c

Abstract:

    This is the main file for the AsyncMAC Driver for the Remote Access
    Service.  This driver conforms to the NDIS 3.0 interface.

Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    Ray Patch (raypa)       04/13/94        Modified for new WAN wrapper.

--*/

#define RAISEIRQL

#include "asyncall.h"

#if DBG
ULONG UlFramesOut = 0;
#endif

//  asyncmac.c will define the global parameters.

ULONG   GlobalXmitCameBack  = 0;
ULONG   GlobalXmitCameBack2 = 0;
ULONG   GlobalXmitCameBack3 = 0;

//
//  The assemble frame routine is specific for RAS 1.0 and 2.0
//  frame formats.  It uses a 16 byte CRC at the end.
//

VOID
AsyncFrameRASXonXoff(
    PUCHAR pStartOfFrame,
    postamble *pPostamble,
    PASYNC_FRAME pFrame,
    UCHAR controlCastByte);

VOID
AsyncFrameRASNormal(
    PUCHAR pStartOfFrame,
    postamble *pPostamble,
    PASYNC_FRAME pFrame,
    UCHAR controlCastByte);


NTSTATUS
AsyncWriteCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,           //... Our device object.
    IN PIRP             Irp,                    //... I/O request packet.
    IN PNDIS_WAN_PACKET WanPacket               //... Completion context.
    )

/*++

    This is the IO Completion routine for WriteFrame.

    It is called when an I/O Write request has completed.

--*/
{
    NTSTATUS            Status;
    NTSTATUS            PacketStatus;
    PASYNC_INFO         AsyncInfo;

    //
    //  Make the compiler happy.
    //

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    //  Initialize locals.
    //

    AsyncInfo       = WanPacket->MacReserved1;

    PacketStatus    = NDIS_STATUS_FAILURE;

    Status          = Irp->IoStatus.Status;

    //
    // Free the irp used to send the packt to the serial driver
    //
    IoFreeIrp(Irp);

    //
    //  What was the outcome of the IRP.
    //

    switch ( Status ) {

    case STATUS_SUCCESS:
        PacketStatus = NDIS_STATUS_SUCCESS;
        break;

    case STATUS_TIMEOUT:
        DbgTracef(-2,("ASYNC: Status TIMEOUT on write\n"));
        break;

    case STATUS_CANCELLED:
        DbgTracef(-2,("ASYNC: Status CANCELLED on write\n"));
        break;

    case STATUS_PENDING:
        DbgTracef(0,("ASYNC: Status PENDING on write\n"));
        break;

    default:
        DbgTracef(-2,("ASYNC: Unknown status 0x%.8x on write", Status));
        break;

    }

    //
    //  Count this packet completion.
    //
    AsyncInfo->Out++;

    //
    // Tell the Wrapper that we have finally the packet has been sent
    //

    NdisMWanSendComplete(
            AsyncInfo->Adapter->MiniportHandle,
            WanPacket,
            PacketStatus);

    //
    //  We return STATUS_MORE_PROCESSING_REQUIRED so that the
    //  IoCompletionRoutine will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
AsyncGetFrameFromPool(
    IN  PASYNC_INFO     Info,
    OUT PASYNC_FRAME    *NewFrame )

/*++

--*/
{
    PASYNC_ADAPTER      Adapter=Info->Adapter;
    PASYNC_FRAME        pFrame;

    pFrame = (ASYNC_FRAME*)
        ExAllocateFromNPagedLookasideList(&Adapter->AsyncFrameList);

    if (pFrame == NULL) {
        *NewFrame = NULL;
        return NDIS_STATUS_RESOURCES;
    }

    //
    // increase by 16 for frame runover padding when we have to resync
    //
    pFrame->Frame =
        (PUCHAR)pFrame + sizeof(ASYNC_FRAME) + sizeof(PVOID);
    (ULONG_PTR)pFrame->Frame &= ~((ULONG_PTR)(sizeof(PVOID)-1));

    pFrame->FrameLength = Adapter->MaxFrameSize;

    //  assign back ptr from frame to adapter

    pFrame->Adapter=Adapter;

    //  setup another back ptr

    pFrame->Info=Info;

    *NewFrame = pFrame;

    return(NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndistapi\ndistapi.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ndistapi.c

Abstract:

    This module contains the NdisTapi.sys implementation

Author:

    Dan Knudson (DanKn)    20-Feb-1994

Notes:

    (Future/outstanding issues)

    - stuff marked with "PnP" needs to be rev'd for plug 'n play support

Revision History:

--*/



#include "ndis.h"
#include "stdarg.h"
#include "stdio.h"
#include "ntddndis.h"
#include "ndistapi.h"
#include "private.h"
#include "intrface.h"


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
NdisTapiCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NdisTapiCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NdisTapiDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NdisTapiUnload(
    IN PDRIVER_OBJECT DriverObject
    );


#if DBG
VOID
DbgPrt(
    IN LONG  DbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    );
#endif

VOID
DoProviderInitComplete(
    PPROVIDER_REQUEST  ProviderRequest,
    NDIS_STATUS Status
    );

ULONG
GetLineEvents(
    PVOID   EventBuffer,
    ULONG   BufferSize
    );

BOOLEAN
SyncInitAllProviders(
    void
    );

VOID
DoIrpMjCloseWork(
    PIRP    Irp
    );

NDIS_STATUS
SendProviderInitRequest(
    PPROVIDER_INFO  Provider
    );

NDIS_STATUS
SendProviderShutdown(
    PPROVIDER_INFO  Provider,
    PKIRQL          oldIrql
    );

VOID
NdisTapiIndicateStatus(
    IN  ULONG_PTR   DriverHandle,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

VOID
DoLineOpenCompleteWork(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      provider
    );

VOID
DoLineOpenWork(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      provider
    );

NDIS_STATUS
VerifyProvider(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      *provider
    );

NDIS_STATUS
VerifyLineClose(
    PNDISTAPI_REQUEST ndisTapiRequest,
    PPROVIDER_INFO     provider
    );

NTSTATUS
DoIoctlConnectWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    );

NTSTATUS
DoIoctlQuerySetWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    );

NTSTATUS
DoGetProviderEventsWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    );

NTSTATUS
DoLineCreateWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    );

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif

NPAGED_LOOKASIDE_LIST  ProviderEventLookaside;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/

{

    PDEVICE_OBJECT  deviceObject        = NULL;
    NTSTATUS        ntStatus;
    WCHAR           deviceNameBuffer[]  = L"\\Device\\NdisTapi";
    UNICODE_STRING  deviceNameUnicodeString;
    UNICODE_STRING  registryPath;


    DBGOUT ((2, "DriverEntry: enter"));

    //
    // Create a NON-EXCLUSIVE device, i.e. multiple threads at a time
    // can send i/o requests.
    //

    RtlInitUnicodeString (&deviceNameUnicodeString, deviceNameBuffer);

    ntStatus = IoCreateDevice(
        DriverObject,
        sizeof (KMDD_DEVICE_EXTENSION),
        &deviceNameUnicodeString,
        FILE_DEVICE_NDISTAPI,
        0,
        FALSE,
        &deviceObject
        );


    if (NT_SUCCESS(ntStatus))
    {
        //
        // Init the global & sero the extension
        //

        DeviceExtension =
            (PKMDD_DEVICE_EXTENSION) deviceObject->DeviceExtension;

        RtlZeroMemory(
            DeviceExtension,
            sizeof (KMDD_DEVICE_EXTENSION)
            );


        //
        // Create a NULL-terminated registry path & retrieve the registry
        // params (EventDataQueueLength)
        //

        registryPath.Buffer = ExAllocatePoolWithTag(
            PagedPool,
            RegistryPath->Length + sizeof(UNICODE_NULL),
            'IPAT'
            );

        if (!registryPath.Buffer)
        {
            DBGOUT((1, "DriverEntry: ExAllocPool for szRegistryPath failed"));

            ntStatus = STATUS_UNSUCCESSFUL;

            goto DriverEntry_err;
        }
        else
        {
            registryPath.Length = RegistryPath->Length;
            registryPath.MaximumLength =
                registryPath.Length + sizeof(UNICODE_NULL);

            RtlZeroMemory(
                registryPath.Buffer,
                registryPath.MaximumLength
                    );

            RtlMoveMemory(
                registryPath.Buffer,
                RegistryPath->Buffer,
                RegistryPath->Length
                );
        }

        ExFreePool (registryPath.Buffer);


        InitializeListHead(&DeviceExtension->ProviderEventList);

        ExInitializeNPagedLookasideList(&ProviderEventLookaside,
                                        NULL,
                                        NULL,
                                        0,
                                        sizeof(PROVIDER_EVENT),
                                        'IPAT',
                                        0);


        DeviceExtension->DeviceObject       = deviceObject;
        DeviceExtension->Status             = NDISTAPI_STATUS_DISCONNECTED;
        DeviceExtension->NdisTapiNumDevices = 0;
        DeviceExtension->htCall             = 0x80000001;

        KeInitializeSpinLock (&DeviceExtension->SpinLock);

        InitializeListHead(&DeviceExtension->ProviderRequestList);

        //
        // Create dispatch points for device control, create, close.
        //

        DriverObject->MajorFunction[IRP_MJ_CREATE]         =
        DriverObject->MajorFunction[IRP_MJ_CLOSE]          =
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = NdisTapiDispatch;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = NdisTapiCleanup;
        DriverObject->DriverUnload                         = NdisTapiUnload;
    }


    if (!NT_SUCCESS(ntStatus)) {

DriverEntry_err:

        //
        // Something went wrong, so clean up
        //

        DBGOUT((0, "init failed"));

        if (deviceObject)
        {

        while (!(IsListEmpty(&DeviceExtension->ProviderEventList))) {
            PPROVIDER_EVENT ProviderEvent;

            ProviderEvent = (PPROVIDER_EVENT)
                RemoveHeadList(&DeviceExtension->ProviderEventList);

            ExFreeToNPagedLookasideList(&ProviderEventLookaside, ProviderEvent);
        }

            IoDeleteDevice (deviceObject);
        }
    }


    DBGOUT ((2, "DriverEntry: exit"));

    return ntStatus;
}



VOID
NdisTapiCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    KIRQL   oldIrql;

    DBGOUT((2,"NdisTapiCancel: enter"));


    //
    // Release the cancel spinlock
    //

    IoReleaseCancelSpinLock (Irp->CancelIrql);


    //
    // Acquire the SpinLock & check to see if we're canceling a
    // pending get-events Irp
    //

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    do {

        DeviceExtension->IrpsCanceledCount++;

        if (Irp == DeviceExtension->EventsRequestIrp) {
            DeviceExtension->EventsRequestIrp = NULL;
            DeviceExtension->Flags |= EVENTIRP_CANCELED;
            break;
        }

        //
        // Try to remove request from our special
        // user-mode requests dev queue
        //
        if (!IsListEmpty(&DeviceExtension->ProviderRequestList)) {
            PLIST_ENTRY Entry;

            Entry = DeviceExtension->ProviderRequestList.Flink;

            while (Entry != &DeviceExtension->ProviderRequestList) {
                PPROVIDER_REQUEST   pReq;

                pReq = (PPROVIDER_REQUEST)Entry;

                if (pReq->Irp == Irp) {
                    RemoveEntryList(&pReq->Linkage);
                    DeviceExtension->RequestCount--;
                    DeviceExtension->Flags |= REQUESTIRP_CANCELED;
                    break;
                }

                Entry = Entry->Flink;
            }

            if (Entry == &DeviceExtension->ProviderRequestList) {
                DBGOUT((1,"NdisTapiCancel: Irp %p not in device queue?!?", Irp));
                DeviceExtension->Flags |= CANCELIRP_NOTFOUND;
            }
        }

    } while (FALSE);

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    //
    // Complete the request with STATUS_CANCELLED.
    //

    Irp->IoStatus.Status      = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DBGOUT((2,"NdisTapiCancel: completing irp=%p", Irp));
}



NTSTATUS
NdisTapiCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for cleanup requests.
    All requests queued are completed with STATUS_CANCELLED.

Arguments:

    DeviceObject - Pointer to device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    KIRQL   oldIrql;
    PNDISTAPI_REQUEST   ndisTapiRequest;
    PKDEVICE_QUEUE_ENTRY    packet;


    DBGOUT((2,"NdisTapiCleanup: enter"));


    //
    // Sync access to EventsRequestIrp by acquiring SpinLock
    //
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    DeviceExtension->Flags |= CLEANUP_INITIATED;

    //
    // Check to see if there's a get-events request pending that needs
    // completing
    //
    if ((DeviceExtension->EventsRequestIrp != NULL) &&
        (DeviceExtension->EventsRequestIrp->Tail.Overlay.OriginalFileObject ==
        Irp->Tail.Overlay.OriginalFileObject)) {
        PIRP    LocalIrp;

        //
        // Acquire the cancel spinlock, remove the request from the
        // cancellable state, and free the cancel spinlock.
        //

        LocalIrp = DeviceExtension->EventsRequestIrp;
        if (IoSetCancelRoutine (LocalIrp, NULL) != NULL) {
            DeviceExtension->EventsRequestIrp = NULL;
            LocalIrp->IoStatus.Status      = STATUS_CANCELLED;
            LocalIrp->IoStatus.Information = 0;
            DeviceExtension->IrpsCanceledCount++;
            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
            DBGOUT((2,"NdisTapiCleanup: Completing EventRequestIrp %p", LocalIrp));
            IoCompleteRequest (LocalIrp, IO_NO_INCREMENT);
            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
        }
    }

    //
    // Cancel all outstanding QUERY/SET_INFO requests
    //
    if (!IsListEmpty(&DeviceExtension->ProviderRequestList)) {
        PPROVIDER_REQUEST   pReq;

        pReq = (PPROVIDER_REQUEST)
            DeviceExtension->ProviderRequestList.Flink;

        //
        // Until we have walked the entire list
        //
        while ((PVOID)pReq != (PVOID)&DeviceExtension->ProviderRequestList) {
            PIRP    LocalIrp;

            LocalIrp = pReq->Irp;

            //
            // If the current entry's irp has a fileobject that is
            // the same as the cleanup irp's fileobject then remove it
            // from the list and cancel it
            //
            if (LocalIrp->Tail.Overlay.OriginalFileObject ==
                Irp->Tail.Overlay.OriginalFileObject) {

                //
                // Remove the IRP from the cancelable state
                //

                if (IoSetCancelRoutine (LocalIrp, NULL) == NULL) {
                    //
                    // The irp has been canceled.  Let
                    // cancel routine cleanup.
                    //
                    pReq = 
                        (PPROVIDER_REQUEST)pReq->Linkage.Flink;

                    continue;
                }

                RemoveEntryList(&pReq->Linkage);
                DeviceExtension->RequestCount--;

                //
                // Set the status & info size values appropriately, & complete
                // the request
                //

                ndisTapiRequest = LocalIrp->AssociatedIrp.SystemBuffer;
                ndisTapiRequest->ulReturnValue = (ULONG) NDIS_STATUS_FAILURE;

                LocalIrp->IoStatus.Status = STATUS_CANCELLED;
                LocalIrp->IoStatus.Information = 0;
                DeviceExtension->IrpsCanceledCount++;

                KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
                DBGOUT((2,"NdisTapiCleanup: Completing ProviderRequestIrp %p", LocalIrp));
                IoCompleteRequest (LocalIrp, IO_NO_INCREMENT);
                KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

                pReq = (PPROVIDER_REQUEST)
                    DeviceExtension->ProviderRequestList.Flink;

            } else {
                pReq = (PPROVIDER_REQUEST)
                    pReq->Linkage.Flink;
            }
        }
    }

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    //
    // Complete the cleanup request with STATUS_SUCCESS.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DBGOUT((2,"NdisTapiCleanup: exit"));

    return(STATUS_SUCCESS);
}




NTSTATUS
NdisTapiDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )

/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/

{
    NTSTATUS    NtStatus;
    PVOID               ioBuffer;
    ULONG               inputBufferLength;
    ULONG               outputBufferLength;
    PIO_STACK_LOCATION  irpStack;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //
    ioBuffer = 
        Irp->AssociatedIrp.SystemBuffer;

    inputBufferLength = 
        irpStack->Parameters.DeviceIoControl.InputBufferLength;

    outputBufferLength = 
        irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    switch (irpStack->MajorFunction) {
        case IRP_MJ_CREATE:
            DBGOUT ((2, "IRP_MJ_CREATE, Irp=%p", Irp));

            InterlockedIncrement(&DeviceExtension->RefCount);
            NtStatus = Irp->IoStatus.Status 
                = STATUS_SUCCESS;
            Irp->IoStatus.Information = 0;
            break;

        case IRP_MJ_CLOSE:
            DBGOUT ((2, "IRP_MJ_CLOSE, Irp=%p", Irp));

            DoIrpMjCloseWork(Irp);
            NtStatus = STATUS_SUCCESS;
            break;

        case IRP_MJ_DEVICE_CONTROL:

            switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
                case IOCTL_NDISTAPI_CONNECT:
                    DBGOUT ((2, "IOCTL_NDISTAPI_CONNECT, Irp=%p", Irp));
    
                    NtStatus = 
                        DoIoctlConnectWork(Irp,
                                           ioBuffer,
                                           inputBufferLength,
                                           outputBufferLength);
                    break;
    
                case IOCTL_NDISTAPI_QUERY_INFO:
                case IOCTL_NDISTAPI_SET_INFO:
                    DBGOUT ((2, "IOCTL_NDISTAPI_QUERY/SET_INFO, Irp=%p", Irp));
    
                    NtStatus = 
                        DoIoctlQuerySetWork(Irp,
                                            ioBuffer,
                                            inputBufferLength,
                                            outputBufferLength);
                    break;
    
                case IOCTL_NDISTAPI_GET_LINE_EVENTS:
                    DBGOUT ((2, "IOCTL_NDISTAPI_GET_LINE_EVENTS, Irp=%p", Irp));

                    NtStatus = 
                        DoGetProviderEventsWork(Irp,
                                                ioBuffer,
                                                inputBufferLength,
                                                outputBufferLength);
                    break;
    
                case IOCTL_NDISTAPI_CREATE:
                    DBGOUT ((2, "IOCTL_NDISTAPI_CREATE, Irp=%p", Irp));

                    NtStatus = 
                        DoLineCreateWork(Irp,
                                         ioBuffer,
                                         inputBufferLength,
                                         outputBufferLength);
                    break;

                default:
                    DBGOUT ((2, "Unknown IRP_MJ_DEVICE_CONTROL, Irp=%p", Irp));

                    NtStatus = Irp->IoStatus.Status = 
                        STATUS_INVALID_PARAMETER;
                    Irp->IoStatus.Information = 0;
                    break;
            }
            break;
    }

    if (NtStatus == STATUS_PENDING) {
        return (STATUS_PENDING);
    }

    ASSERT(NtStatus == Irp->IoStatus.Status);

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DBGOUT((3, "NdisTapiDispatch: completed Irp=%p", Irp));

    return NtStatus;
}

VOID
NdisTapiUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/

{
    KIRQL                   oldIrql;
    PPROVIDER_INFO provider, nextProvider;


    DBGOUT ((2, "NdisTapiUnload: enter"));

    //
    // Delete the device object & sundry resources
    //

    while (!(IsListEmpty(&DeviceExtension->ProviderEventList))) {
        PPROVIDER_EVENT ProviderEvent;

        ProviderEvent = (PPROVIDER_EVENT)
            RemoveHeadList(&DeviceExtension->ProviderEventList);

        ExFreeToNPagedLookasideList(&ProviderEventLookaside, ProviderEvent);
    }

    ExDeleteNPagedLookasideList(&ProviderEventLookaside);

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    provider = DeviceExtension->Providers;

    while (provider != NULL)
    {
        nextProvider = provider->Next;

        ExFreePool (provider);

        provider = nextProvider;
    }

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    IoDeleteDevice (DriverObject->DeviceObject);

    DBGOUT ((2, "NdisTapiUnload: exit"));

    return;
}


VOID
NdisTapiRegisterProvider(
    IN  NDIS_HANDLE                 ProviderHandle,
    IN  PNDISTAPI_CHARACTERISTICS   Chars
    )
/*++

Routine Description:

    This func gets called by Ndis as a result of a Mac driver
    registering for Connection Wrapper services.

Arguments:



Return Value:


--*/

{
    KIRQL           oldIrql;
    BOOLEAN         sendRequest = FALSE;
    NDIS_STATUS     ndisStatus;
    PPROVIDER_INFO  provider, newProvider;


    DBGOUT ((2, "NdisTapiRegisterProvider: enter"));

    //
    // Grab the spin lock & add the new provider, and see whether to
    // send the provider an init request
    //
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    //
    // See if this provider has already registered once.
    //
    provider = DeviceExtension->Providers;

    while (provider != NULL) {
        if (provider->Status == PROVIDER_STATUS_OFFLINE &&

            RtlCompareMemory(
                &provider->Guid,
                &Chars->Guid,
                sizeof(provider->Guid)) == sizeof(provider->Guid)) {
            DBGOUT((
                1,
                "Found a provider %p for Guid %4.4x-%2.2x-%2.2x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x",
                provider,
                provider->Guid.Data1,
                provider->Guid.Data2,
                provider->Guid.Data3,
                provider->Guid.Data4[0],
                provider->Guid.Data4[1],
                provider->Guid.Data4[2],
                provider->Guid.Data4[3],
                provider->Guid.Data4[4],
                provider->Guid.Data4[5],
                provider->Guid.Data4[6],
                provider->Guid.Data4[7]
                ));

            DBGOUT((
                1,
                "numDevices %d BaseID %d",
                provider->NumDevices,
                provider->DeviceIDBase
                ));

            provider->Status = PROVIDER_STATUS_PENDING_REINIT;
            provider->ProviderHandle = ProviderHandle;
            provider->RequestProc = Chars->RequestProc;
            provider->MediaType = Chars->MediaType;
            break;
        }

        provider = provider->Next;
    }

    if (provider == NULL) {
        //
        // Create a new provider instance
        //

        newProvider = ExAllocatePoolWithTag(
                NonPagedPoolCacheAligned,
                sizeof(PROVIDER_INFO),
                'IPAT'
                );

        if (!newProvider) {
            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
            return;
        }

        RtlZeroMemory(newProvider, sizeof(PROVIDER_INFO));

        newProvider->Status         = PROVIDER_STATUS_PENDING_INIT;
        newProvider->ProviderHandle = ProviderHandle;
        newProvider->RequestProc    = Chars->RequestProc;

        RtlMoveMemory(
            &newProvider->Guid,
            &Chars->Guid,
            sizeof(newProvider->Guid)
            );

        newProvider->MediaType      = Chars->MediaType;
        newProvider->Next           = NULL;

        DBGOUT((
            1,
            "New provider for Guid %4.4x-%2.2x-%2.2x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x",
            newProvider->Guid.Data1,
            newProvider->Guid.Data2,
            newProvider->Guid.Data3,
            newProvider->Guid.Data4[0],
            newProvider->Guid.Data4[1],
            newProvider->Guid.Data4[2],
            newProvider->Guid.Data4[3],
            newProvider->Guid.Data4[4],
            newProvider->Guid.Data4[5],
            newProvider->Guid.Data4[6],
            newProvider->Guid.Data4[7]
            ));

        //
        // Add the new provider, and see whether to send the 
        // provider an init request
        //

        if ((provider = DeviceExtension->Providers) == NULL) {
            DeviceExtension->Providers = newProvider;
        }
        else {
            while (provider->Next != NULL) {
                provider = provider->Next;
            }

            provider->Next = newProvider;
        }

        provider = newProvider;
    }


    //
    // The only case where we want to send off an init request to the
    // provider directly is when we are currently connected to TAPI,
    // and even then only when there are no other inits pending (since
    // we must synchronize inits due to calculation of DeviceIDBase)
    //

    if (DeviceExtension->Status == NDISTAPI_STATUS_CONNECTED) {
        //
        // TAPI is up.
        //
        // If TAPI already knows about this provider
        // go ahead and init the provider with it's current
        // DeviceIDBase.
        //
        // If TAPI does not know about this provider we
        // need to give TAPI an indication of a new device
        // coming on line.
        //
        if (provider->Status == PROVIDER_STATUS_PENDING_REINIT) {

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            ndisStatus = 
                SendProviderInitRequest (provider);

            if (ndisStatus == NDIS_STATUS_PENDING) {
                //
                // Wait for completion routine to get called
                //

                KeWaitForSingleObject (&provider->SyncEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       (PTIME) NULL);
            }

            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

            //
            // Get tapi to reset the state of these lines by
            // forcing a line_close...
            //
            if (provider->DeviceInfo != NULL) {
                PDEVICE_INFO    DeviceInfo;
                ULONG           i;
                
                for(i = 0, DeviceInfo = provider->DeviceInfo;
                    i < provider->NumDevices;
                    i++, DeviceInfo++) {
                    NDIS_TAPI_EVENT NdisTapiEvent;


                    RtlZeroMemory (&NdisTapiEvent, sizeof(NDIS_TAPI_EVENT));

                    if (DeviceInfo->htLine != (HTAPI_LINE)NULL)
                    {
                        NdisTapiEvent.htLine = DeviceInfo->htLine;
                        NdisTapiEvent.ulMsg = LINE_CLOSE;

                        KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

                        NdisTapiIndicateStatus((ULONG_PTR) provider,
                                               &NdisTapiEvent,
                                               sizeof (NDIS_TAPI_EVENT));

                        KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

                        DeviceInfo->htLine = (HTAPI_LINE)NULL;
                        DeviceInfo->hdLine = (HDRV_LINE)NULL;
                    }
                }
            }

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

        } else {

            NDIS_TAPI_EVENT NdisTapiEvent;

            ASSERT(provider->Status == PROVIDER_STATUS_PENDING_INIT);

            provider->Status = PROVIDER_STATUS_PENDING_LINE_CREATE;

            //
            // If there are no providers in the middle of doing
            // line_create's then we will kick off creates for this
            // provider.
            //
            // If we already have a line create pending on a provider
            // then we will wait until all of its line creates have
            // finished before we start sending them from
            // this one.
            //
            if (!(DeviceExtension->Flags & PENDING_LINECREATE)) {

                //
                // Do a LINE_CREATE so that we can get the starting
                // BaseID for this provider.  When TAPI calls us back
                // with ProviderCreateLineDevice we will have the
                // BaseDeviceID to use for this provider and we will
                // then init the provider.  Once we find out how many
                // devices the provider has we will alert TAPI of the
                // additional devices.
                //
                RtlZeroMemory(&NdisTapiEvent, sizeof(NDIS_TAPI_EVENT));

                provider->TempID = (ULONG_PTR)provider;

                DBGOUT((-1, 
                        "LINE_CREATE %d for provider %p",
                        provider->CreateCount,
                        provider->TempID
                        ));

                NdisTapiEvent.ulMsg = LINE_CREATE;
                NdisTapiEvent.ulParam1 = 0;
                NdisTapiEvent.ulParam2 = provider->TempID;
                NdisTapiEvent.ulParam3 = 0;

                DeviceExtension->Flags |= PENDING_LINECREATE;

                KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

                NdisTapiIndicateStatus((ULONG_PTR)provider, &NdisTapiEvent, sizeof(NDIS_TAPI_EVENT));
            }
            else
            {
                KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
            }
        }

        KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
    }

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    ObReferenceObject(DeviceExtension->DeviceObject);
}



VOID
NdisTapiDeregisterProvider(
    IN  NDIS_HANDLE ProviderHandle
    )

/*++

Routine Description:

    This func...

    Note that this func does not send the provider a shutdown message,
    as an implicit shutdown is assumed when the provider deegisters.

Arguments:



Return Value:


--*/

{
    KIRQL           oldIrql;
    BOOLEAN         sendShutdownMsg = FALSE;
    PPROVIDER_INFO  provider, previousProvider;


    DBGOUT ((2, "NdisTapiDeregisterProvider: enter"));

    //
    // Grab the spin lock protecting the device extension
    //
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    //
    // Find the provider instance corresponding to ProviderHandle
    //

    previousProvider = NULL;
    provider = DeviceExtension->Providers;

    while (provider != NULL &&
           provider->ProviderHandle != ProviderHandle) {
        
        previousProvider = provider;

        provider = provider->Next;
    }

    if (provider == NULL) {
        KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
        return;
    }

    if (provider->Status == PROVIDER_STATUS_ONLINE) {
        DeviceExtension->NdisTapiNumDevices -= provider->NumDevices;
    }

    //
    // Send the ProviderShutdown only if the provider
    // is not in PROVIDER_STATUS_OFFLINE. Otherwise
    // DoIrpMjCloseWork can end up sending 
    // Providershutdown on a removed adapter.
    //
    if(provider->Status != PROVIDER_STATUS_OFFLINE)
    {
        SendProviderShutdown (provider, &oldIrql);
        provider->Status = PROVIDER_STATUS_OFFLINE;
    }

    //
    // Do the right thing according to the current NdisTapi state
    //

    switch (DeviceExtension->Status)
    {
        case NDISTAPI_STATUS_CONNECTED:
        {
                UINT    i;

        //
        // Mark provider as offline
        //
        provider->Status = PROVIDER_STATUS_OFFLINE;
        provider->ProviderHandle = NULL;

#if 0
        if (provider->DeviceInfo != NULL) {
            PDEVICE_INFO    DeviceInfo;

            for(
                i = 0, DeviceInfo = provider->DeviceInfo;
                i < provider->NumDevices;
                i++, DeviceInfo++
                )
            {
                NDIS_TAPI_EVENT NdisTapiEvent;


                RtlZeroMemory (&NdisTapiEvent, sizeof(NDIS_TAPI_EVENT));

                if (DeviceInfo->htLine != (HTAPI_LINE)NULL)
                {
                    NdisTapiEvent.htLine = DeviceInfo->htLine;
                    NdisTapiEvent.ulMsg = LINE_CLOSE;

                    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

                    NdisTapiIndicateStatus((ULONG_PTR) provider,
                                           &NdisTapiEvent,
                                           sizeof (NDIS_TAPI_EVENT));

                    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

                    DeviceInfo->htLine = (HTAPI_LINE)NULL;
                }
            }
        }
#endif

        // PnP: what if providerInfo->State == PROVIDER_INIT_PENDING
        // PnP: what if providerInfo->State == PROVIDER_OFFLINE

        break;

        }

    case NDISTAPI_STATUS_DISCONNECTING:
    case NDISTAPI_STATUS_DISCONNECTED:

        //
        // Fix up pointers, remove provider from list
        //
        if (previousProvider == NULL) {
            DeviceExtension->Providers = provider->Next;
        } else {
            previousProvider->Next = provider->Next;
        }

        ExFreePool (provider);

        break;

    case NDISTAPI_STATUS_CONNECTING:

        // PnP: implement

        break;

    } // switch

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    ObDereferenceObject(DeviceExtension->DeviceObject);

    DBGOUT((2, "NdisTapiDeregisterProvider: exit"));
}



VOID
NdisTapiIndicateStatus(
    IN  ULONG_PTR   DriverHandle,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    )

/*++

Routine Description:

    This func gets called by Ndis when a miniport driver calls
    NdisIndicateStatus to notify us of an async event
    (i.e. new call, call state chg, dev state chg, etc.)

Arguments:



Return Value:


--*/

{
    PIRP    irp;
    KIRQL   oldIrql;
    ULONG   bytesInQueue;
    ULONG   bytesToMove;
    ULONG   moveSize;
    BOOLEAN satisfiedPendingEventsRequest = FALSE;
    PNDIS_TAPI_EVENT    ndisTapiEvent;
    PNDISTAPI_EVENT_DATA    ndisTapiEventData;


    DBGOUT((2,"NdisTapiIndicateStatus: enter"));


    bytesInQueue = StatusBufferSize;

    moveSize = 0;


    //
    // Sync event buf access by acquiring SpinLock
    //

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    //
    // The very first thing to do is check if this is a LINE_NEWCALL
    // indication.  If so, we need to generate a unique tapi call
    // handle, which will be both returned to the calling miniport
    // (for use in subsequent status indications) and passed up to
    // the tapi server.
    //
    // The algorithim for computing a unique "htCall" is to start
    // at the value 0x80000001, and perpetually increment by 2.  
    // Keeping the low bit set will allow the user-mode TAPI component
    // we talk to to distinguish between these incoming call handles
    // and outgoing call handles, the latter of which will always
    // have the low bit zero'd (since they're really pointers to heap).
    // We are again going to use the space between 0x80000001 and 0xFFFFFFFF
    // to identify our call handle.  This allows for a maximum of 1GB of
    // calls to be active at a time.  This is done to avoid a conflict
    // with ndiswan's connection table index.  A bug in the ddk doc's
    // had users providing the connectionid instead of ndiswan's context
    // in the line get id oid.  Ndiswan has to check both of these and
    // now that they overlap it can cause problems.  NdisWan will use
    // 0x00000000 - 0x80000000 for it's context values.
    //
    // In <= NT 4.0, valid values used to range between 0x80000000
    // and 0xffffffff, as we relied on the fact that user-mode
    // addresses always had the low bit zero'd.  (Not a valid
    // assumption anymore!)
    //

    ndisTapiEvent = StatusBuffer;

    if (ndisTapiEvent->ulMsg == LINE_NEWCALL)
    {
        ndisTapiEvent->ulParam2 = DeviceExtension->htCall;

        DeviceExtension->htCall++;
        DeviceExtension->htCall++;

        if (DeviceExtension->htCall < 0x80000000) {
            DeviceExtension->htCall = 0x80000001;
        }
    }


    //
    // Check of there is an outstanding request to satisfy
    //

    if (DeviceExtension->EventsRequestIrp) {

        ASSERT(IsListEmpty(&DeviceExtension->ProviderEventList));

        //
        // Acquire the cancel spinlock, remove the request from the
        // cancellable state, and free the cancel spinlock.
        //

        irp = DeviceExtension->EventsRequestIrp;

        if (IoSetCancelRoutine(irp, NULL) != NULL) {
            DeviceExtension->EventsRequestIrp = NULL;


            //
            // Copy as much of the input data possible from the input data
            // queue to the SystemBuffer to satisfy the read.
            //

            ndisTapiEventData = irp->AssociatedIrp.SystemBuffer;

            bytesToMove = ndisTapiEventData->ulTotalSize;

            moveSize = (bytesInQueue < bytesToMove) ? bytesInQueue : bytesToMove;

            RtlMoveMemory (
                ndisTapiEventData->Data,
                (PCHAR) StatusBuffer,
                moveSize
                );


            //
            // Set the flag so that we start the next packet and complete
            // this read request (with STATUS_SUCCESS) prior to return.
            //

            ndisTapiEventData->ulUsedSize = moveSize;

            irp->IoStatus.Status = STATUS_SUCCESS;

            irp->IoStatus.Information = sizeof(NDISTAPI_EVENT_DATA) + moveSize - 1;

            satisfiedPendingEventsRequest = TRUE;
        }

    } else {

        do {
            PPROVIDER_EVENT ProviderEvent;

            ProviderEvent =
                ExAllocateFromNPagedLookasideList(&ProviderEventLookaside);

            if (ProviderEvent == NULL) {
                break;
            }

            RtlMoveMemory(&ProviderEvent->Event, StatusBuffer, sizeof(NDIS_TAPI_EVENT));

            InsertTailList(&DeviceExtension->ProviderEventList,
                           &ProviderEvent->Linkage);

            DeviceExtension->EventCount++;

        } while ( FALSE );
    }

    //
    // Release the spinlock
    //

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);


    //
    // If we satisfied an outstanding get events request then complete it
    //

    if (satisfiedPendingEventsRequest) {
        IoCompleteRequest (irp, IO_NO_INCREMENT);

        DBGOUT((2, "NdisTapiIndicateStatus: completion req %p", irp));
    }


    DBGOUT((2,"NdisTapiIndicateStatus: exit"));

    return;
}

VOID
NdisTapiCompleteRequest(
    IN  NDIS_HANDLE     NdisHandle,
    IN  PNDIS_REQUEST   NdisRequest,
    IN  NDIS_STATUS     NdisStatus
    )

/*++

Routine Description:

    This func gets called by Ndis as a result of a Mac driver
    calling NdisCompleteRequest of one of our requests.

Arguments:



Return Value:


--*/

{
    PIRP                    Irp;
    KIRQL                   oldIrql;
    ULONG                   requestID;
    PNDISTAPI_REQUEST       ndisTapiRequest;
    PPROVIDER_REQUEST       providerRequest;
    PPROVIDER_REQUEST       tempReq;
    PIO_STACK_LOCATION      irpStack;

    DBGOUT ((2, "NdisTapiCompleteRequest: enter"));

    providerRequest =
        CONTAINING_RECORD(NdisRequest, PROVIDER_REQUEST, NdisRequest);

    do {
        if (providerRequest->Flags & INTERNAL_REQUEST) {

            //
            // This request originated from NdisTapi.sys
            //
            switch (NdisRequest->DATA.SET_INFORMATION.Oid) {
                case OID_TAPI_PROVIDER_INITIALIZE:
                    DBGOUT((3,
                            "NdisTapiCompleteRequest: ProviderInit - Provider=%p, reqID=%x, Status=%x",
                            providerRequest->Provider,
                            providerRequest->RequestID,
                            NdisStatus));

                    switch (DeviceExtension->Status) {
                        case NDISTAPI_STATUS_CONNECTED:
                        case NDISTAPI_STATUS_CONNECTING:

                            DoProviderInitComplete (providerRequest, NdisStatus);
                            break;

                        case NDISTAPI_STATUS_DISCONNECTED:
                        case NDISTAPI_STATUS_DISCONNECTING:
                        default:
                            break;

                    }
                    break;

                case OID_TAPI_PROVIDER_SHUTDOWN:
                    DBGOUT((3,
                            "NdisTapiCompleteRequest: ProviderShutdown - Provider=%p, reqID=%x, Status=%x",
                            providerRequest->Provider,
                            providerRequest->RequestID,
                            NdisStatus));
                    break;

                default:
                    DBGOUT((1, "NdisTapiCompleteRequest: unrecognized Oid"));

                    break;
            }

            break;
        }

        //
        // This is a request originating from TAPI
        //


        //
        // Acquire the SpinLock since we're going to be removing a
        // TAPI request from the queue, and it might not be the request
        // we're looking for. The primary concern is that we could (if
        // the request we're really looking for has been removed) remove
        // a synchrously-completed request that is about to be removed &
        // completed in NdisTapiDispatch, in which case we want to stick
        // the request back in the queue before NdisTapiDispatch tries
        // to remove it.
        //
        KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

        tempReq = 
            (PPROVIDER_REQUEST)DeviceExtension->ProviderRequestList.Flink;

        while ((PVOID)tempReq != (PVOID)&DeviceExtension->ProviderRequestList) {
            if (tempReq == providerRequest) {
                break;
            }

            tempReq = 
                (PPROVIDER_REQUEST)tempReq->Linkage.Flink;
        }

        if (tempReq != providerRequest) {
#if DBG
            DbgPrint("NDISTAPI: NdisTapiCompleteRequest: Request %p not found!\n", 
                providerRequest);
#endif
            DeviceExtension->MissingRequests++;

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
            break;
        }

        Irp = providerRequest->Irp;

        ndisTapiRequest = Irp->AssociatedIrp.SystemBuffer;

        ASSERT(providerRequest->RequestID == 
            *((ULONG *)ndisTapiRequest->Data));

        //
        // Remove the IRP from the cancelable state
        //
        if (IoSetCancelRoutine(Irp, NULL) == NULL) {
            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
            break;
        }

        RemoveEntryList(&providerRequest->Linkage);
        DeviceExtension->RequestCount--;

        KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

        DBGOUT((3,
                "NdisTapiCompleteRequest: Irp=%p, Oid=%x, devID=%d, reqID=%x, Status=%x",
                Irp,
                ndisTapiRequest->Oid,
                ndisTapiRequest->ulDeviceID,
                *((ULONG *)ndisTapiRequest->Data),
                  NdisStatus));

        //
        // Copy the relevant info back to the IRP
        //

        irpStack = IoGetCurrentIrpStackLocation (Irp);

        //
        // If this was a succesful QUERY_INFO request copy all the
        // data back to the tapi request buf & set
        // Irp->IoStatus.Information appropriately. Otherwise, we
        // just need to pass back the return value. Also mark irp
        // as successfully completed (regardless of actual op result)
        //

        if ((NdisRequest->RequestType == NdisRequestQueryInformation) &&
            (NdisStatus == NDIS_STATUS_SUCCESS)) {

            RtlMoveMemory(ndisTapiRequest->Data,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                ndisTapiRequest->ulDataSize);

            Irp->IoStatus.Information =
                irpStack->Parameters.DeviceIoControl.OutputBufferLength;
        } else {

            Irp->IoStatus.Information = sizeof (ULONG);
        }

        if((NdisRequest->RequestType == NdisRequestQueryInformation) &&
          (NdisRequest->DATA.QUERY_INFORMATION.Oid == OID_TAPI_OPEN)) {
        
            DoLineOpenCompleteWork(ndisTapiRequest,
                            providerRequest->Provider);
        }
        

        Irp->IoStatus.Status = STATUS_SUCCESS;

        ndisTapiRequest->ulReturnValue = NdisStatus;

        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } while (FALSE);

    ExFreePool (providerRequest);

    DBGOUT ((2, "NdisTapiCompleteRequest: exit"));
}


#if DBG
VOID
DbgPrt(
    IN LONG  DbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    )

/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/

{
    if (DbgLevel <= NdisTapiDebugLevel)
    {
        char    buf[256] = "NDISTAPI: ";
        va_list ap;

        va_start (ap, DbgMessage);

        vsprintf (&buf[10], DbgMessage, ap);

        strcat (buf, "\n");

        DbgPrint (buf);

        va_end(ap);
    }

    return;
}
#endif // DBG


VOID
DoProviderInitComplete(
    PPROVIDER_REQUEST  ProviderRequest,
    NDIS_STATUS Status
    )

/*++

Routine Description:



Arguments:

    ProviderInitRequest - pointer successfully completed init request

Return Value:



Note:

--*/

{
    PPROVIDER_INFO                  provider = ProviderRequest->Provider;
    PNDIS_TAPI_PROVIDER_INITIALIZE  providerInitData =
        (PNDIS_TAPI_PROVIDER_INITIALIZE) ProviderRequest->Data;
    KIRQL OldIrql;

    DBGOUT ((2, "DoProviderInitComplete: enter"));

    //
    // Wrap this in an exception handler in case the provider was
    // removed during an async completion
    //
    try
    {
        if (Status == NDIS_STATUS_SUCCESS) {

            provider->ProviderID = (ULONG)providerInitData->ulProviderID;
            provider->NumDevices = providerInitData->ulNumLineDevs;

            KeAcquireSpinLock(&DeviceExtension->SpinLock, &OldIrql);

            DeviceExtension->NdisTapiNumDevices += provider->NumDevices;

            KeReleaseSpinLock(&DeviceExtension->SpinLock, OldIrql);

            provider->Status = PROVIDER_STATUS_ONLINE;

            if (provider->DeviceInfo == NULL) {
                provider->DeviceInfo = (PDEVICE_INFO)
                    ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(DEVICE_INFO) * provider->NumDevices,
                        'IPAT'
                        );

                if (provider->DeviceInfo != NULL) {
                    PDEVICE_INFO    DeviceInfo;
                    UINT    i;

                    RtlZeroMemory(
                        provider->DeviceInfo,
                        sizeof(DEVICE_INFO) * provider->NumDevices
                        );

                    for(i = 0, DeviceInfo = provider->DeviceInfo;
                        i < provider->NumDevices;
                        i++, DeviceInfo++) {
                        DeviceInfo->DeviceID = provider->DeviceIDBase + i;
                    }
                }
            }
        }

        //
        // Set the event which sync's miniport inits
        //

        KeSetEvent(&provider->SyncEvent,
                   0,
                   FALSE);

        DBGOUT((3,
                "providerID = 0x%x, numDevices = %d, BaseID = %d",
                provider->ProviderID,
                provider->NumDevices,
                provider->DeviceIDBase));
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        DBGOUT((1, "DoProviderInitComplete: provider invalid"));
    }

    DBGOUT ((2, "DoProviderInitComplete: exit"));
}


ULONG
GetLineEvents(
    PCHAR   EventBuffer,
    ULONG   BufferSize
    )

/*++

Routine Description:



Arguments:



Return Value:



Note:

    Assumes DeviceExtension->SpinLock held by caller.

--*/

{
    ULONG   BytesLeft;
    ULONG   BytesMoved;
    ULONG   EventCount;

    BytesLeft = BufferSize;
    BytesMoved = 0;
    EventCount = 0;

    while (!(IsListEmpty(&DeviceExtension->ProviderEventList))) {
        PPROVIDER_EVENT ProviderEvent;

        if (BytesLeft < sizeof(NDIS_TAPI_EVENT)) {
            break;
        }

        ProviderEvent = (PPROVIDER_EVENT)
            RemoveHeadList(&DeviceExtension->ProviderEventList);

        EventCount++;

        RtlMoveMemory(EventBuffer + BytesMoved,
                      (PUCHAR)&ProviderEvent->Event,
                      sizeof(NDIS_TAPI_EVENT));

        BytesMoved += sizeof(NDIS_TAPI_EVENT);
        BytesLeft -= sizeof(NDIS_TAPI_EVENT);

        ExFreeToNPagedLookasideList(&ProviderEventLookaside,
                                    ProviderEvent);
    }

    DeviceExtension->EventCount -= EventCount;

    DBGOUT((3, "GetLineEvents: Returned %d Events", EventCount));

    return (BytesMoved);
}


NDIS_STATUS
SendProviderInitRequest(
    PPROVIDER_INFO  Provider
    )

/*++

Routine Description:



Arguments:

    Provider - pointer to a PROVIDER_INFO representing provider to initialize

Return Value:



Note:

--*/

{
    KIRQL   oldIrql;
    NDIS_STATUS ndisStatus;
    PNDIS_REQUEST   NdisRequest;
    PPROVIDER_INFO  tmpProvider;
    PPROVIDER_REQUEST   providerRequest;
    PNDIS_TAPI_PROVIDER_INITIALIZE  providerInitData;

    DBGOUT ((2, "SendProviderInitRequest: enter"));

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    //
    // Determine the DeviceIDBase to be used for this provider
    //
    if (Provider->Status == PROVIDER_STATUS_PENDING_INIT) {

        Provider->DeviceIDBase = DeviceExtension->ProviderBaseID;
        tmpProvider = DeviceExtension->Providers;

        while (tmpProvider != NULL) {
            if (tmpProvider->Status != PROVIDER_STATUS_PENDING_INIT) {
                Provider->DeviceIDBase += tmpProvider->NumDevices;
            }

            tmpProvider = tmpProvider->Next;
        }
    }


    //
    // Create a provider init request
    //
    providerRequest = ExAllocatePoolWithTag(
        NonPagedPoolCacheAligned,
        sizeof(PROVIDER_REQUEST) + sizeof(NDIS_TAPI_PROVIDER_INITIALIZE) -
            sizeof(ULONG),
        'IPAT'
        );

    if (!providerRequest) {
        KeReleaseSpinLock(&DeviceExtension->SpinLock, oldIrql);

        return NDIS_STATUS_RESOURCES;
    }


    providerRequest->Irp = NULL;
    providerRequest->Flags = INTERNAL_REQUEST;
    providerRequest->Provider = Provider;
    NdisRequest = &providerRequest->NdisRequest;

    NdisRequest->RequestType = 
        NdisRequestQueryInformation;

    NdisRequest->DATA.SET_INFORMATION.Oid =
        OID_TAPI_PROVIDER_INITIALIZE;

    NdisRequest->DATA.SET_INFORMATION.InformationBuffer =
        providerRequest->Data;

    NdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
        sizeof(NDIS_TAPI_PROVIDER_INITIALIZE);

    providerInitData                 =
        (PNDIS_TAPI_PROVIDER_INITIALIZE) providerRequest->Data;

    providerRequest->RequestID =
        providerInitData->ulRequestID = ++DeviceExtension->ulRequestID;

    providerInitData->ulDeviceIDBase = Provider->DeviceIDBase;

    KeInitializeEvent(&Provider->SyncEvent,
                      SynchronizationEvent,
                      FALSE);

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    //
    // Send the request
    //
    ndisStatus=
        (*Provider->RequestProc)
            (Provider->ProviderHandle,NdisRequest);

    if (ndisStatus != NDIS_STATUS_PENDING) {
        DoProviderInitComplete (providerRequest, ndisStatus);
        ExFreePool (providerRequest);
    }

    DBGOUT ((2, "SendProviderInitRequest: exit status %x", ndisStatus));

    return ndisStatus;
}


NDIS_STATUS
SendProviderShutdown(
    PPROVIDER_INFO  Provider,
    PKIRQL          oldIrql
    )

/*++

Routine Description:



Arguments:



Return Value:

    A pointer to the next provider in the global providers list

Note:

    Assumes DeviceExtension->SpinLock held by caller.

--*/

{
    NDIS_STATUS ndisStatus;
    PNDIS_REQUEST   NdisRequest;
    PPROVIDER_REQUEST   providerRequest;
    PNDIS_TAPI_PROVIDER_SHUTDOWN    providerShutdownData;

    DBGOUT ((2, "SendProviderShutdown: Provider=%p", Provider));

    //
    // Create a provider init request
    //
    providerRequest = 
        ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
            sizeof(PROVIDER_REQUEST) + sizeof(NDIS_TAPI_PROVIDER_SHUTDOWN) -
            sizeof(ULONG),
            'IPAT');

    if (!providerRequest) {
        return NDIS_STATUS_RESOURCES;
    }

    providerRequest->Irp = NULL;
    providerRequest->Flags = INTERNAL_REQUEST;
    providerRequest->Provider = Provider;
    NdisRequest = &providerRequest->NdisRequest;

    NdisRequest->RequestType = 
        NdisRequestSetInformation;

    NdisRequest->DATA.SET_INFORMATION.Oid =
        OID_TAPI_PROVIDER_SHUTDOWN;

    NdisRequest->DATA.SET_INFORMATION.InformationBuffer =
        providerRequest->Data;

    NdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
        sizeof(NDIS_TAPI_PROVIDER_SHUTDOWN);

    providerShutdownData =
        (PNDIS_TAPI_PROVIDER_SHUTDOWN)providerRequest->Data;

    providerRequest->RequestID =
        providerShutdownData->ulRequestID = ++DeviceExtension->ulRequestID;

    KeReleaseSpinLock (&DeviceExtension->SpinLock, *oldIrql);

    //
    // Send the request
    //
    ndisStatus = 
        (*Provider->RequestProc)
            (Provider->ProviderHandle, NdisRequest);

    //
    // If request was completed synchronously then free the request
    // (otherwise it will get freed when the completion proc is called)
    //
    if (ndisStatus != NDIS_STATUS_PENDING) {
        ExFreePool (providerRequest);
    }

    DBGOUT ((2, "SendProviderShutdown: Status=%x", ndisStatus));

    KeAcquireSpinLock (&DeviceExtension->SpinLock, oldIrql);

    return ndisStatus;
}


BOOLEAN
SyncInitAllProviders(
    void
    )

/*++

Routine Description:

    This functions walks the list of registered providers and sends
    init requests to the providers in the PENDING_INIT state

Arguments:

    (none)

Return Value:

    TRUE if all registered providers initialized, or
    FALSE if there are more providers to initialze

Note:

--*/

{
    ULONG           numDevices = 0;
    NDIS_STATUS     ndisStatus;
    PPROVIDER_INFO  provider;
    KIRQL           oldIrql;


    DBGOUT((2, "SyncInitAllProviders: enter"));

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    provider = DeviceExtension->Providers;

    while (provider != NULL) {
        if (provider->Status == PROVIDER_STATUS_PENDING_INIT ||
            provider->Status == PROVIDER_STATUS_PENDING_REINIT ||
            provider->Status == PROVIDER_STATUS_PENDING_LINE_CREATE) {

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            ndisStatus = SendProviderInitRequest (provider);

            if (ndisStatus == NDIS_STATUS_PENDING) {
                //
                // Wait for completion routine to get called
                //

                KeWaitForSingleObject (&provider->SyncEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       (PTIME) NULL
                                       );

            }

            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
        }

        provider = provider->Next;
    }


    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    DBGOUT((2, "SyncInitAllProviders: exit"));

    return TRUE;
}

VOID
DoIrpMjCloseWork(
    PIRP    Irp
    )
{
    KIRQL               oldIrql;

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    if (InterlockedDecrement(&DeviceExtension->RefCount) == 0) {

        if (DeviceExtension->Status == NDISTAPI_STATUS_CONNECTED) {
            PPROVIDER_INFO provider;

            DeviceExtension->Status =
                NDISTAPI_STATUS_DISCONNECTING;

            //
            // Send the providers a shutdown request
            //

            provider = DeviceExtension->Providers;

            while (provider != NULL) {

                switch (provider->Status) {
                    case PROVIDER_STATUS_ONLINE:

                        DeviceExtension->NdisTapiNumDevices -= provider->NumDevices;
                        SendProviderShutdown (provider, &oldIrql);

                        //
                        // fall thru...
                        //
                    case PROVIDER_STATUS_PENDING_INIT:
                    case PROVIDER_STATUS_PENDING_REINIT:

                        //
                        // Reset provider status
                        //
                        provider->Status = PROVIDER_STATUS_PENDING_INIT;
                        break;

                    case PROVIDER_STATUS_OFFLINE:
                        break;

                }

                provider = provider->Next;
            }

            DeviceExtension->Status = NDISTAPI_STATUS_DISCONNECTED;

            ASSERT(DeviceExtension->NdisTapiNumDevices == 0);
        }
    }

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
}

NTSTATUS
DoIoctlConnectWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    )
{
    KIRQL   oldIrql;
    ULONG   InfoSize;
    NTSTATUS    NtStatus;

    //
    // Someone's connecting. Make sure they passed us a valid
    // info buffer
    //
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    do {

        if ((inputBufferLength < 2*sizeof(ULONG)) ||
            (outputBufferLength < sizeof(ULONG))) {

            DBGOUT ((3, "IOCTL_NDISTAPI_CONNECT: buffer too small"));
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            InfoSize = 0;
            break;
        }

        if (DeviceExtension->Status == NDISTAPI_STATUS_DISCONNECTED) {

            DeviceExtension->Status = NDISTAPI_STATUS_CONNECTING;

            DeviceExtension->ProviderBaseID =
                *((ULONG *) ioBuffer);

            DBGOUT ((1, "ProviderBaseID %d",
                     DeviceExtension->ProviderBaseID));
            //
            // Synchronously init all providers
            //
            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            SyncInitAllProviders();

            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
        }

        //
        // Return the number of line devs
        //
        {
            ULONG OfflineCount;
            PPROVIDER_INFO provider;

            //
            // Since some providers might be temporarily offline
            // we need to tell tapi about them even though they
            // are not currently useable.  This keeps the tapi
            // deviceid space consistent.
            //
            OfflineCount = 0;

            provider = DeviceExtension->Providers;
            while (provider != NULL) {
                if (provider->Status == PROVIDER_STATUS_OFFLINE) {
                    OfflineCount += provider->NumDevices;
                }
                provider = provider->Next;
            }

            *((ULONG *) ioBuffer)=
                DeviceExtension->NdisTapiNumDevices + OfflineCount;
        }

        DeviceExtension->Status = NDISTAPI_STATUS_CONNECTED;

        KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

        InfoSize = sizeof(ULONG);
        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    Irp->IoStatus.Status = NtStatus;
    Irp->IoStatus.Information = InfoSize;

    return (NtStatus);
}

NTSTATUS
DoIoctlQuerySetWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    )
{
    KIRQL   oldIrql;
    ULONG   InfoSize;
    NTSTATUS    NtStatus;
    PPROVIDER_INFO  provider;
    NDIS_STATUS     ndisStatus;
    PNDIS_REQUEST   NdisRequest;
    PNDISTAPI_REQUEST   ndisTapiRequest;
    PPROVIDER_REQUEST   providerRequest;
    PIO_STACK_LOCATION  irpStack;

    do {
        ndisTapiRequest = ioBuffer;
        NtStatus = STATUS_SUCCESS;
        InfoSize = 0;

        //
        // Make sure input & output buffers are large enough
        //
        if ((inputBufferLength < sizeof (NDISTAPI_REQUEST))  ||

            (ndisTapiRequest->ulDataSize > 0x10000000) ||

            (inputBufferLength < (sizeof (NDISTAPI_REQUEST) +
                ndisTapiRequest->ulDataSize - sizeof (UCHAR)) ||

            (outputBufferLength < (sizeof (NDISTAPI_REQUEST) +
                ndisTapiRequest->ulDataSize - sizeof (UCHAR))))) {
            DBGOUT((-1, "NdisTapiDispatch: buffer to small!"));
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Verify we're connected, then check the device ID of the
        // incoming request against our list of online devices
        //
        ndisStatus = 
            VerifyProvider(ndisTapiRequest, &provider);

        if (ndisStatus != NDIS_STATUS_SUCCESS) {
            ndisTapiRequest->ulReturnValue = ndisStatus;
            InfoSize = sizeof(ULONG);
            break;
        }

        //
        // If this is a line_close, check to see if the line has
        // been opened before sending a line close oid
        //
        if(ndisTapiRequest->Oid == OID_TAPI_CLOSE) {

            ndisStatus = VerifyLineClose(ndisTapiRequest, provider);

            if(ndisStatus != NDIS_STATUS_SUCCESS)
            {
                ndisTapiRequest->ulReturnValue = ndisStatus;
                InfoSize = sizeof(ULONG);
                break;
            }
            
        }
        

        //
        // Create the providerRequest & submit it
        //
        providerRequest = 
            ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                sizeof(PROVIDER_REQUEST) + 
                ndisTapiRequest->ulDataSize -
                sizeof(ULONG),
                'IPAT');

        if (providerRequest == NULL) {
            DBGOUT((-1, "NdisTapiDispatch: unable to alloc request buf"));

            ndisTapiRequest->ulReturnValue = NDIS_STATUS_RESOURCES;
            InfoSize = sizeof (ULONG);
            break;
        }

        if (ndisTapiRequest->Oid == OID_TAPI_OPEN) {
            DoLineOpenWork(ndisTapiRequest, provider);
        }

        KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

        providerRequest->Flags = 0;
        providerRequest->Irp = Irp;
        providerRequest->Provider = provider;
        providerRequest->RequestID = 
            *((ULONG *)ndisTapiRequest->Data) = ++DeviceExtension->ulRequestID;

        RtlMoveMemory(providerRequest->Data, 
            ndisTapiRequest->Data, ndisTapiRequest->ulDataSize);

        NdisRequest = &providerRequest->NdisRequest;

        irpStack = IoGetCurrentIrpStackLocation (Irp);

        NdisRequest->RequestType =
            (irpStack->Parameters.DeviceIoControl.IoControlCode == 
             IOCTL_NDISTAPI_QUERY_INFO) ? NdisRequestQueryInformation : 
            NdisRequestSetInformation;

        NdisRequest->DATA.SET_INFORMATION.Oid =
            ndisTapiRequest->Oid;

        NdisRequest->DATA.SET_INFORMATION.InformationBuffer =
            providerRequest->Data;

        NdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
            ndisTapiRequest->ulDataSize;

        DBGOUT((3,
                "DoIoctlQuerySetWork: Oid=%x, devID=%d, reqID=%x",
                ndisTapiRequest->Oid,
                ndisTapiRequest->ulDeviceID,
                *((ULONG *)ndisTapiRequest->Data)));

        //
        // Queue up this TAPI request in our request list.
        //
        InsertTailList(&DeviceExtension->ProviderRequestList, 
                       &providerRequest->Linkage);
        DeviceExtension->RequestCount++;

        KeReleaseSpinLock(&DeviceExtension->SpinLock, oldIrql);

        //
        // Mark the TAPI request pending and set the cancel routine
        //
        IoMarkIrpPending(Irp);
        Irp->IoStatus.Status = STATUS_PENDING;
        IoSetCancelRoutine (Irp, NdisTapiCancel);

        //
        // Call the provider's request proc
        //
        ndisStatus = 
            (*provider->RequestProc)
                (provider->ProviderHandle, NdisRequest);

        //
        // If PENDING was returned then just exit & let the completion
        // routine handle the request completion
        //
        // NOTE: If pending was returned then the request may have
        //       already been completed, so DO NOT touch anything
        //       in the Irp (don't reference the pointer, etc.)
        //

        if (ndisStatus == NDIS_STATUS_PENDING) {
            DBGOUT((1, "DoIoctlQuerySetWork: exit Irp=%p, Status=%x",
                    Irp, STATUS_PENDING));

            return (STATUS_PENDING);
        }

        //
        // The provider request completed synchronously, so remove
        // the TAPI request from the device queue. We need to
        // synchronize access to this queue with the
        // SpinLock.
        //
        KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
        do {
            PPROVIDER_REQUEST   pReq;

            pReq = (PPROVIDER_REQUEST)
                DeviceExtension->ProviderRequestList.Flink;

            while ((PVOID)pReq != (PVOID)&DeviceExtension->ProviderRequestList) {
                if (pReq == providerRequest) {
                    break;
                }

                pReq = (PPROVIDER_REQUEST)
                    pReq->Linkage.Flink;
            }

            if (pReq != providerRequest) {
                DBGOUT((0, "DoIoctlQuerySetWork - Request %p not found!", 
                    providerRequest));
                KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
                return (STATUS_PENDING);
            }

            Irp = providerRequest->Irp;

            ndisTapiRequest = Irp->AssociatedIrp.SystemBuffer;

            ASSERT(providerRequest->RequestID == 
                *((ULONG *)ndisTapiRequest->Data));

            //
            // Remove the IRP from the cancelable state
            //
            if (IoSetCancelRoutine(Irp, NULL) == NULL) {
                DBGOUT((0, "DoIoctlQuerySetWork - Irp %p has been canceled!", Irp));
                KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
                return (STATUS_PENDING);
            }

            RemoveEntryList(&providerRequest->Linkage);
            DeviceExtension->RequestCount--;

        } while (FALSE);
        KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

        //
        // If this was a succesful QUERY_INFO request copy all the
        // data back to the tapi request buf & set
        // Irp->IoStatus.Information appropriately. Otherwise, we
        // just need to pass back the return value.
        //

        if ((irpStack->Parameters.DeviceIoControl.IoControlCode == 
             IOCTL_NDISTAPI_QUERY_INFO) &&
            (ndisStatus == NDIS_STATUS_SUCCESS)) {

            RtlMoveMemory(ndisTapiRequest->Data,
                          providerRequest->Data,
                          ndisTapiRequest->ulDataSize);

            InfoSize =
                irpStack->Parameters.DeviceIoControl.OutputBufferLength;

        } else {
            InfoSize = sizeof (ULONG);
        }

        ndisTapiRequest->ulReturnValue = ndisStatus;

        //
        // Free the providerRequest
        //
        ExFreePool (providerRequest);

    } while (FALSE);

    Irp->IoStatus.Status = NtStatus;
    Irp->IoStatus.Information = InfoSize;

    DBGOUT((1, "DoIoctlQuerySetWork: exit Irp=%p, Status=%x",
            Irp, NtStatus));

    return (NtStatus);
}

VOID
DoLineOpenCompleteWork(
    PNDISTAPI_REQUEST ndisTapiRequest,
    PPROVIDER_INFO provider
    )
{
    DBGOUT((2, "DoLineOpenCompleteWork: Open Completed"));
    
    //
    // Now stash the hdLine for this deviceid
    //
    if (provider->DeviceInfo != NULL) {
        UINT    i;
        PDEVICE_INFO    DeviceInfo;
        PNDIS_TAPI_OPEN TapiOpen;

        TapiOpen = (PNDIS_TAPI_OPEN) ndisTapiRequest->Data;
        for(i = 0, DeviceInfo = provider->DeviceInfo;
            i < provider->NumDevices;
            i++, DeviceInfo++) {
            if (DeviceInfo->DeviceID == TapiOpen->ulDeviceID) {

                DeviceInfo->hdLine = TapiOpen->hdLine;

                DBGOUT((2, "Complete for open. stashing hdline=0x%x for device %d",
                            DeviceInfo->hdLine, DeviceInfo->DeviceID));
                
                break;
            }
        }
    }
}

VOID
DoLineOpenWork(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      provider
    )
{
    KIRQL   oldIrql;
    PNDIS_TAPI_OPEN TapiOpen;
    PNDISTAPI_OPENDATA  OpenData;

    TapiOpen = (PNDIS_TAPI_OPEN) ndisTapiRequest->Data;

    if (ndisTapiRequest->ulDataSize >= sizeof(NDIS_TAPI_OPEN) +
                                       sizeof(NDISTAPI_OPENDATA)) {

        OpenData = (PNDISTAPI_OPENDATA)
            ((PUCHAR)ndisTapiRequest->Data + sizeof(NDIS_TAPI_OPEN));

        RtlMoveMemory(&OpenData->Guid, 
            &provider->Guid, sizeof(OpenData->Guid));

        OpenData->MediaType = provider->MediaType;
    }

    //
    // Now stash the htLine for this deviceid
    //
    if (provider->DeviceInfo != NULL) {
        UINT    i;
        PDEVICE_INFO    DeviceInfo;

        for(i = 0, DeviceInfo = provider->DeviceInfo;
            i < provider->NumDevices;
            i++, DeviceInfo++) {
            if (DeviceInfo->DeviceID == TapiOpen->ulDeviceID) {

                DeviceInfo->htLine = TapiOpen->htLine;

                DBGOUT((
                    1,
                    "Stash htLine - provider %p DeviceID %d htLine %x",
                        provider,
                        DeviceInfo->DeviceID,
                        DeviceInfo->htLine));
            }
        }
    }
}

NDIS_STATUS
VerifyLineClose(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      provider
    )
{
    NDIS_STATUS ndisStatus = NDIS_STATUS_SUCCESS;
    
    if (provider->DeviceInfo != NULL) {
        UINT    i;
        PDEVICE_INFO    DeviceInfo;
        PNDIS_TAPI_CLOSE TapiClose;

        TapiClose = (PNDIS_TAPI_CLOSE) ndisTapiRequest->Data;
        for(i = 0, DeviceInfo = provider->DeviceInfo;
            i < provider->NumDevices;
            i++, DeviceInfo++) {
            if (DeviceInfo->hdLine == TapiClose->hdLine) {
                break;
            }
        }

        if(i == provider->NumDevices)
        {
            DBGOUT((2,"LINE_CLOSE: didn't find hdLine=0x%x",
                    TapiClose->hdLine));
            ndisStatus = NDISTAPIERR_DEVICEOFFLINE;
        }
        else
        {
            DBGOUT((2, "LINE_CLOSE: found hdLine=0x%x",
                        TapiClose->hdLine));
        }
    }

    return ndisStatus;
}

NDIS_STATUS
VerifyProvider(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      *provider
    )
{
    KIRQL   oldIrql;
    PPROVIDER_INFO  pp;
    NDIS_STATUS     Status;
    ULONG           targetDeviceID;

    Status = NDIS_STATUS_SUCCESS;
    *provider = NULL;

    targetDeviceID = ndisTapiRequest->ulDeviceID;

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    do {

        if (DeviceExtension->Status != NDISTAPI_STATUS_CONNECTED) {
            DBGOUT((3, "VerifyProvider: unconnected, returning err"));

            Status = NDISTAPIERR_UNINITIALIZED;
            break;
        }

        pp = DeviceExtension->Providers;

        while (pp != NULL) {

            if ((pp->Status == PROVIDER_STATUS_ONLINE) &&
                (targetDeviceID >= pp->DeviceIDBase) &&
                (targetDeviceID <
                     pp->DeviceIDBase + pp->NumDevices)
                ) {

                break;
            }

            pp = pp->Next;
        }

        if (pp == NULL ||
            pp->ProviderHandle == NULL) {
            //
            // Set Irp->IoStatus.Information large enough that err code
            // gets copied back to user buffer
            //
            DBGOUT((3, "VerifyProvider: dev offline, returning err"));

            Status = NDISTAPIERR_DEVICEOFFLINE;
            break;
        }

        *provider = pp;

    } while (FALSE);

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    return (Status);
}

NTSTATUS
DoGetProviderEventsWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    )
{
    KIRQL   oldIrql;
    ULONG   InfoSize;
    NTSTATUS    NtStatus;
    PNDISTAPI_EVENT_DATA    ndisTapiEventData;

    ndisTapiEventData = ioBuffer;
    NtStatus = STATUS_SUCCESS;
    InfoSize = 0;

    //
    // Sync event buf access by acquiring SpinLock
    //
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    do {

        if ((inputBufferLength < sizeof (NDISTAPI_EVENT_DATA))  ||
            (outputBufferLength < sizeof(NDISTAPI_EVENT_DATA)) ||
            ((outputBufferLength - 
             FIELD_OFFSET(NDISTAPI_EVENT_DATA, Data[0])) <
             ndisTapiEventData->ulTotalSize)) {

            NtStatus = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        if (DeviceExtension->Status != NDISTAPI_STATUS_CONNECTED) {
            DBGOUT((3, "DoGetProviderEventsWork: Status!=NDIS_STATUS_CONNECTED!"));
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        if (DeviceExtension->EventsRequestIrp != NULL) {
#if DBG
            DbgPrint("NDISTAPI: Attempt to set duplicate EventIrp o:%p, d:%p\n",
                DeviceExtension->EventsRequestIrp, Irp);
#endif
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // Inspect DeviceExtension to see if there's any data available
        //
        if (DeviceExtension->EventCount == 0) {

            //
            // Hold the request pending.  It remains in the cancelable
            // state.  When new line event input is received
            // (NdisTapiIndicateStatus) or generated (i.e.
            // LINEDEVSTATE_REINIT) the data will get copied & the
            // request completed.
            //
            ASSERT(DeviceExtension->EventsRequestIrp == NULL);

            DeviceExtension->EventsRequestIrp = Irp;

            IoMarkIrpPending(Irp);
            Irp->IoStatus.Status = STATUS_PENDING;
            IoSetCancelRoutine (Irp, NdisTapiCancel);

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            DBGOUT((3, "DoGetProviderEventsWork: Pending Irp=%p", Irp));

            return(STATUS_PENDING);
        }

        //
        // There's line event data queued in our ring buffer. Grab as
        // much as we can & complete the request.
        //
        ndisTapiEventData->ulUsedSize = 
            GetLineEvents(ndisTapiEventData->Data,
                          ndisTapiEventData->ulTotalSize);

        InfoSize = 
            ndisTapiEventData->ulUsedSize + sizeof(NDISTAPI_EVENT_DATA) - 1;

        DBGOUT((3, "GetLineEvents: SyncComplete Irp=%p", Irp));

    } while (FALSE);

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
    Irp->IoStatus.Status = NtStatus;
    Irp->IoStatus.Information = InfoSize;

    return (NtStatus);
}

NTSTATUS
DoLineCreateWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    )
{
    KIRQL   oldIrql;
    ULONG   InfoSize;
    NTSTATUS    NtStatus;
    PPROVIDER_INFO  provider;
    PNDISTAPI_CREATE_INFO   CreateInfo;

    InfoSize = 0;
    NtStatus = STATUS_SUCCESS;

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    do {

        if (inputBufferLength < sizeof(CreateInfo)) {
            DBGOUT ((3, "IOCTL_NDISTAPI_CREATE: buffer too small"));
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        if (DeviceExtension->Status != NDISTAPI_STATUS_CONNECTED) {
            DBGOUT((3, "IOCTL_NDISTAPI_CREATE: while unconnected, returning err"));
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        CreateInfo = (PNDISTAPI_CREATE_INFO)ioBuffer;

        provider = DeviceExtension->Providers;

        while (provider != NULL) {
            if (provider->TempID == CreateInfo->TempID) {
                break;
            }
            provider = provider->Next;
        }

        if (provider == NULL) {
            DBGOUT((0, "IOCTL_NDISTAPI_CREATE: Provider not found %x", 
                    CreateInfo->TempID));
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        if (provider->Status == PROVIDER_STATUS_OFFLINE) {
            DBGOUT((0,  "IOCTL_CREATE - Provider %p invalid state %x", 
                    provider, provider->Status));
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        DBGOUT((1, "IOCTL_NDISTAPI_CREATE: provider %p ID %d", 
                provider, CreateInfo->DeviceID));

        if (provider->CreateCount == 0) {
            NDIS_STATUS     ndisStatus;

            //
            // Set the base ID
            //
            provider->DeviceIDBase =
                CreateInfo->DeviceID;

            //
            // Init the provider
            //

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            ndisStatus = SendProviderInitRequest (provider);

            if (ndisStatus == NDIS_STATUS_PENDING) {
                //
                // Wait for completion routine to get called
                //

                KeWaitForSingleObject (&provider->SyncEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       (PTIME) NULL);
            }

            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
        }

        ASSERT(CreateInfo->DeviceID ==
            (provider->DeviceIDBase + provider->CreateCount));

        provider->CreateCount++;

        ASSERT(provider->CreateCount <= provider->NumDevices);

        if (provider->CreateCount == provider->NumDevices) {

            //
            // We have finished all of the line_creates for this
            // provider so find the next provider that needs to be
            // kick started.
            //
            provider = provider->Next;

            while (provider != NULL) {

                if (provider->Status == 
                    PROVIDER_STATUS_PENDING_LINE_CREATE) {
                    break;
                }

                provider = provider->Next;
            }
        }

        if (provider != NULL) {

            NDIS_TAPI_EVENT NdisTapiEvent;

            //
            // Do a LINE_CREATE for all additional devices
            // on this provider
            //
            RtlZeroMemory(&NdisTapiEvent, sizeof(NDIS_TAPI_EVENT));

            provider->TempID = (ULONG_PTR)provider;

            DBGOUT((
                -1,
                "LINE_CREATE %d for provider %p",
                provider->CreateCount,
                provider->TempID
                ));

            NdisTapiEvent.ulMsg = LINE_CREATE;
            NdisTapiEvent.ulParam1 = 0;
            NdisTapiEvent.ulParam2 = provider->TempID;
            NdisTapiEvent.ulParam3 = 0;

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            NdisTapiIndicateStatus((ULONG_PTR) provider,
                                   &NdisTapiEvent,
                                   sizeof (NDIS_TAPI_EVENT));

            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

        } else {

            DeviceExtension->Flags &= ~PENDING_LINECREATE;
        }

        InfoSize = sizeof(NDISTAPI_CREATE_INFO);

    } while (FALSE);

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    Irp->IoStatus.Status = NtStatus;
    Irp->IoStatus.Information = InfoSize;

    return (NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\ccp.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ccp.c

Abstract:


Author:

    Thomas J. Dimitri (TommyD) 29-March-1994

Environment:

Revision History:


--*/


#include "wan.h"

        
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, WanInitECP)
#pragma alloc_text(INIT, WanInitVJ)
#endif

#define __FILE_SIG__    CCP_FILESIG

NDIS_STATUS
AllocateEncryptMemory(
    PCRYPTO_INFO    CryptoInfo
    );

NDIS_STATUS
AllocateCompressMemory(
    PBUNDLECB   BundleCB
    );

NTSTATUS
AllocateCryptoMSChapV1(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    );

NTSTATUS
AllocateCryptoMSChapV2(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    );

#ifdef EAP_ON
NTSTATUS
AllocateCryptoEap(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    );
#endif

NPAGED_LOOKASIDE_LIST   EncryptCtxList; // List of free encryption contexts
NPAGED_LOOKASIDE_LIST   CachedKeyList;  // List of free encryption contexts
#ifdef ENCRYPT_128BIT
NPAGED_LOOKASIDE_LIST   CachedKeyListLong;  // List of free encryption contexts
#endif

VOID
WanInitECP(
    VOID
)
{

    NdisInitializeNPagedLookasideList(&EncryptCtxList,
                                      NULL,
                                      NULL,
                                      0,
                                      ENCRYPTCTX_SIZE,
                                      ENCRYPTCTX_TAG,
                                      0);

    NdisInitializeNPagedLookasideList(&CachedKeyList,
                                      NULL,
                                      NULL,
                                      0,
                                      glCachedKeyCount * (sizeof(USHORT) + MAX_SESSIONKEY_SIZE),
                                      CACHEDKEY_TAG,
                                      0);

#ifdef ENCRYPT_128BIT
    NdisInitializeNPagedLookasideList(&CachedKeyListLong,
                                      NULL,
                                      NULL,
                                      0,
                                      glCachedKeyCount * (sizeof(USHORT) + MAX_USERSESSIONKEY_SIZE),
                                      CACHEDKEY_TAG,
                                      0);
#endif
}

VOID
WanDeleteECP(
    VOID
    )
{
    NdisDeleteNPagedLookasideList(&EncryptCtxList);
    NdisDeleteNPagedLookasideList(&CachedKeyList);
#ifdef ENCRYPT_128BIT
    NdisDeleteNPagedLookasideList(&CachedKeyListLong);
#endif
}


//
// Assumes the endpoint lock is held
//
NTSTATUS
WanAllocateECP(
    PBUNDLECB           BundleCB,
    PCOMPRESS_INFO      CompInfo,
    PCRYPTO_INFO        CryptoInfo,
    BOOLEAN             IsSend
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanAllocateECP: Enter"));

    //
    // Is encryption enabled?
    //

#ifdef ENCRYPT_128BIT
    if ((CompInfo->MSCompType &
        (NDISWAN_ENCRYPTION | NDISWAN_40_ENCRYPTION | 
         NDISWAN_56_ENCRYPTION | NDISWAN_128_ENCRYPTION))) {
#else
    if ((CompInfo->MSCompType &
        (NDISWAN_ENCRYPTION | NDISWAN_40_ENCRYPTION |
         NDISWAN_56_ENCRYPTION))) {
#endif
        if (CryptoInfo->Context == NULL) {

            Status = AllocateEncryptMemory(CryptoInfo);

            if (Status != NDIS_STATUS_SUCCESS) {
                NdisWanDbgOut(DBG_FAILURE, DBG_CCP, ("Can't allocate encryption key!"));
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
        
        do
        {
            CryptoInfo->Flags |=
                (CompInfo->Flags & CCP_IS_SERVER) ? CRYPTO_IS_SERVER : 0;
    
            if (CompInfo->AuthType == AUTH_USE_MSCHAPV1) {
                Status = AllocateCryptoMSChapV1(BundleCB,
                                                CompInfo,
                                                CryptoInfo,
                                                IsSend);
    
            } else if (CompInfo->AuthType == AUTH_USE_MSCHAPV2) {
                Status = AllocateCryptoMSChapV2(BundleCB,
                                                CompInfo,
                                                CryptoInfo,
                                                IsSend);
#ifdef EAP_ON
            } else if (CompInfo->AuthType == AUTH_USE_EAP) {
                Status = AllocateCryptoEap(BundleCB,
                                           CompInfo,
                                           CryptoInfo,
                                           IsSend);
#endif
            } else {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            if (!IsSend && CryptoInfo->CachedKeyBuffer == NULL) {

#ifdef DBG_ECP
    DbgPrint("NDISWAN: CompInfo = %p\n", CompInfo);
    DbgPrint("NDISWAN: CryptoInfo = %p\n", CryptoInfo);
    DbgPrint("NDISWAN: MSCompType = %0x\n", CompInfo->MSCompType);
    DbgPrint("NDISWAN: Flags = %0x\n", CryptoInfo->Flags);
    DbgPrint("NDISWAN: SessionKeyLength = %d\n", CryptoInfo->SessionKeyLength);
#endif

#ifdef ENCRYPT_128BIT
                if ((CompInfo->MSCompType & NDISWAN_128_ENCRYPTION)) 
                {
                    CryptoInfo->CachedKeyBuffer = NdisAllocateFromNPagedLookasideList(&CachedKeyListLong);
                }
                else
#endif
                {
                    CryptoInfo->CachedKeyBuffer = NdisAllocateFromNPagedLookasideList(&CachedKeyList);
                }

                if (CryptoInfo->CachedKeyBuffer == NULL) {
                    NdisWanDbgOut(DBG_FAILURE, DBG_CCP, ("Can't allocate cached key array!"));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
                else
                {
                    CryptoInfo->pCurrKey = (PCACHED_KEY)CryptoInfo->CachedKeyBuffer;
                    CryptoInfo->pLastKey = (PCACHED_KEY)((PUCHAR) CryptoInfo->CachedKeyBuffer + 
                        (glCachedKeyCount - 1) * (sizeof(USHORT)+ CryptoInfo->SessionKeyLength));
                    NdisFillMemory(CryptoInfo->CachedKeyBuffer, 
                        glCachedKeyCount * (sizeof(USHORT)+ CryptoInfo->SessionKeyLength), 
                        0xff);
                }
            }
        } while(FALSE);

        if (Status != STATUS_SUCCESS) {

            if (CryptoInfo->Context != NULL) {
                NdisFreeToNPagedLookasideList(&EncryptCtxList,
                                              CryptoInfo->Context);
                //
                // Clear so we know it is deallocated
                //
                CryptoInfo->Context =
                CryptoInfo->RC4Key= NULL;
            }

            if (CryptoInfo->CachedKeyBuffer != NULL) {
#ifdef ENCRYPT_128BIT
                if ((CompInfo->MSCompType & NDISWAN_128_ENCRYPTION)) 
                {
                    NdisFreeToNPagedLookasideList(&CachedKeyListLong, CryptoInfo->CachedKeyBuffer);
                }
                else
#endif
                {
                    NdisFreeToNPagedLookasideList(&CachedKeyList, CryptoInfo->CachedKeyBuffer);
                }
                CryptoInfo->CachedKeyBuffer = NULL;
                CryptoInfo->pCurrKey = CryptoInfo->pLastKey = NULL;
            }


            NdisWanDbgOut(DBG_FAILURE, DBG_CCP, ("Failed allocating Crypto Status %x!", Status));
            return (Status);
        }

        //
        // Next packet out is flushed
        //
        BundleCB->Flags |= RECV_PACKET_FLUSH;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanAllocateECP: Exit"));

    return(Status);
}

//
// Assumes the endpoint lock is held
//
VOID
WanDeallocateECP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanDeallocateECP: Enter"));

    //
    // Deallocate encryption keys.
    //
    if (CryptoInfo->Context != NULL) {
        NdisFreeToNPagedLookasideList(&EncryptCtxList,
                                      CryptoInfo->Context);

        //
        // Clear so we know it is deallocated
        //
        CryptoInfo->Context =
        CryptoInfo->RC4Key= NULL;
    }

    if (CryptoInfo->CachedKeyBuffer != NULL) {
#ifdef ENCRYPT_128BIT
        if ((CompInfo->MSCompType & NDISWAN_128_ENCRYPTION)) 
        {
            NdisFreeToNPagedLookasideList(&CachedKeyListLong, CryptoInfo->CachedKeyBuffer);
        }
        else
#endif
        {
            NdisFreeToNPagedLookasideList(&CachedKeyList, CryptoInfo->CachedKeyBuffer);
        }
        CryptoInfo->CachedKeyBuffer = NULL;
        CryptoInfo->pCurrKey = CryptoInfo->pLastKey = NULL;
    }

    //
    // Clear the encrption bits
    //
#ifdef ENCRYPT_128BIT
    CompInfo->MSCompType &= ~(NDISWAN_ENCRYPTION | NDISWAN_40_ENCRYPTION | 
                              NDISWAN_56_ENCRYPTION | NDISWAN_128_ENCRYPTION);
#else
    CompInfo->MSCompType &= ~(NDISWAN_ENCRYPTION | NDISWAN_40_ENCRYPTION |
                              NDISWAN_56_ENCRYPTION);
#endif

    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanDeallocateCCP: Exit"));
}

NTSTATUS
AllocateCryptoMSChapV1(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    )
{
    if (CompInfo->MSCompType & NDISWAN_ENCRYPTION) {
        //
        // For legacy encryption we use the 8 byte LMSessionKey
        // for initiali encryption session key.  The first 256
        // packets will be sent using this without any salt
        // (the first 256 packets are using 64 bit encryption).
        // After the first 256 we will always salt the first 3
        // bytes of the encryption key so that we are doing 40
        // bit encryption.
        //
        CryptoInfo->SessionKeyLength = MAX_SESSIONKEY_SIZE;

        NdisMoveMemory(CryptoInfo->StartKey,
                       CompInfo->LMSessionKey,
                       CryptoInfo->SessionKeyLength);

        NdisMoveMemory(CryptoInfo->SessionKey,
                       CryptoInfo->StartKey,
                       CryptoInfo->SessionKeyLength);

    } else if (CompInfo->MSCompType & 
               (NDISWAN_40_ENCRYPTION | NDISWAN_56_ENCRYPTION)) {

        CryptoInfo->SessionKeyLength = MAX_SESSIONKEY_SIZE;

        //
        // For our new 40/56 bit encryption we will use SHA on the
        // 8 byte LMSessionKey to derive our intial 8 byte
        // encryption session key.
        //

        NdisMoveMemory(CryptoInfo->StartKey,
                       CompInfo->LMSessionKey,
                       CryptoInfo->SessionKeyLength);

        NdisMoveMemory(CryptoInfo->SessionKey,
                       CompInfo->LMSessionKey,
                       CryptoInfo->SessionKeyLength);

        GetNewKeyFromSHA(CryptoInfo);

        if (CompInfo->MSCompType & NDISWAN_40_ENCRYPTION) {
            //
            // Set the first 3 bytes to reduce to
            // 40 bits of random key
            //
            CryptoInfo->SessionKey[0] = 0xD1;
            CryptoInfo->SessionKey[1] = 0x26;
            CryptoInfo->SessionKey[2] = 0x9E;

        } else {

            //
            // Set the first byte to reduce to
            // 56 bits of random key
            //
            CryptoInfo->SessionKey[0] = 0xD1;
        }

#ifdef ENCRYPT_128BIT
    } else if (CompInfo->MSCompType & NDISWAN_128_ENCRYPTION) {

        CryptoInfo->SessionKeyLength = MAX_USERSESSIONKEY_SIZE;

        //
        // For our new 128 bit encryption we will use SHA on the
        // 16 byte NTUserSessionKey and the 8 byte Challenge to
        // derive our the intial 128 bit encryption session key.
        //
        NdisMoveMemory(CryptoInfo->StartKey,
                       CompInfo->UserSessionKey,
                       MAX_USERSESSIONKEY_SIZE);

        GetStartKeyFromSHA(CryptoInfo, CompInfo->Challenge);

        GetNewKeyFromSHA(CryptoInfo);
#endif
    }

    //
    // Initialize the rc4 send table
    //
    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
    ("RC4 encryption KeyLength %d", CryptoInfo->SessionKeyLength));
    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
    ("RC4 encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
        CryptoInfo->SessionKey[0],
        CryptoInfo->SessionKey[1],
        CryptoInfo->SessionKey[2],
        CryptoInfo->SessionKey[3],
        CryptoInfo->SessionKey[4],
        CryptoInfo->SessionKey[5],
        CryptoInfo->SessionKey[6],
        CryptoInfo->SessionKey[7],
        CryptoInfo->SessionKey[8],
        CryptoInfo->SessionKey[9],
        CryptoInfo->SessionKey[10],
        CryptoInfo->SessionKey[11],
        CryptoInfo->SessionKey[12],
        CryptoInfo->SessionKey[13],
        CryptoInfo->SessionKey[14],
        CryptoInfo->SessionKey[15]));

    rc4_key(CryptoInfo->RC4Key,
            CryptoInfo->SessionKeyLength,
            CryptoInfo->SessionKey);

    return (STATUS_SUCCESS);
}

NTSTATUS
AllocateCryptoMSChapV2(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    )
{

    NdisMoveMemory(CryptoInfo->StartKey,
                   CompInfo->UserSessionKey,
                   sizeof(CryptoInfo->StartKey));

    if (CompInfo->MSCompType & NDISWAN_ENCRYPTION) {

        return(STATUS_UNSUCCESSFUL);

    } else if (CompInfo->MSCompType & 
               (NDISWAN_40_ENCRYPTION | NDISWAN_56_ENCRYPTION)) {

        CryptoInfo->SessionKeyLength = MAX_SESSIONKEY_SIZE;

#ifdef ENCRYPT_128BIT
    } else if (CompInfo->MSCompType & NDISWAN_128_ENCRYPTION) {

        CryptoInfo->SessionKeyLength = MAX_USERSESSIONKEY_SIZE;

#endif
    }

    GetMasterKey(CryptoInfo, CompInfo->NTResponse);

    //
    // Setup the first key
    //
    GetAsymetricStartKey(CryptoInfo, IsSend);

    GetNewKeyFromSHA(CryptoInfo);

    if (CompInfo->MSCompType & NDISWAN_40_ENCRYPTION) {
        //
        // Set the first 3 bytes to reduce to
        // 40 bits of random key
        //
        CryptoInfo->SessionKey[0] = 0xD1;
        CryptoInfo->SessionKey[1] = 0x26;
        CryptoInfo->SessionKey[2] = 0x9E;

    } else if (CompInfo->MSCompType & NDISWAN_56_ENCRYPTION) {

        //
        // Set the first byte to reduce to
        // 56 bits of random key
        //
        CryptoInfo->SessionKey[0] = 0xD1;
    }

    //
    // Initialize the rc4 send table
    //
    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
        ("RC4 encryption KeyLength %d", CryptoInfo->SessionKeyLength));

    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
        ("RC4 encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
        CryptoInfo->SessionKey[0],CryptoInfo->SessionKey[1],
        CryptoInfo->SessionKey[2],CryptoInfo->SessionKey[3],
        CryptoInfo->SessionKey[4],CryptoInfo->SessionKey[5],
        CryptoInfo->SessionKey[6],CryptoInfo->SessionKey[7],
        CryptoInfo->SessionKey[8],CryptoInfo->SessionKey[9],
        CryptoInfo->SessionKey[10],CryptoInfo->SessionKey[11],
        CryptoInfo->SessionKey[12],CryptoInfo->SessionKey[13],
        CryptoInfo->SessionKey[14],CryptoInfo->SessionKey[15]));

    rc4_key(CryptoInfo->RC4Key,
            CryptoInfo->SessionKeyLength,
            CryptoInfo->SessionKey);

    return (STATUS_SUCCESS);
}

#ifdef EAP_ON
NTSTATUS
AllocateCryptoEap(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    )
{

    ULONG   KeySize;

    KeySize = CompInfo->EapKeyLength;

    if (CompInfo->MSCompType & NDISWAN_ENCRYPTION) {

        return(STATUS_UNSUCCESSFUL);

    } else if (CompInfo->MSCompType & 
               (NDISWAN_40_ENCRYPTION | NDISWAN_56_ENCRYPTION)) {

        //
        // Might need to pad this out.  Spec calls for padding
        // at the left (front) of the value
        //

        CryptoInfo->SessionKeyLength = MAX_SESSIONKEY_SIZE;

#ifdef ENCRYPT_128BIT
    } else if (CompInfo->MSCompType & NDISWAN_128_ENCRYPTION) {

        //
        // Might need to pad this out.  Spec calls for padding
        // at the left (front) of the value
        //

        CryptoInfo->SessionKeyLength = MAX_USERSESSIONKEY_SIZE;

#endif
    }

    NdisMoveMemory(CryptoInfo->StartKey,
                   CompInfo->EapKey,
                   CryptoInfo->SessionKeyLength);

    NdisMoveMemory(CryptoInfo->SessionKey,
                   CryptoInfo->StartKey,
                   CryptoInfo->SessionKeyLength);

    GetNewKeyFromSHA(CryptoInfo);

    if (CompInfo->MSCompType & NDISWAN_40_ENCRYPTION) {
        //
        // Set the first 3 bytes to reduce to
        // 40 bits of random key
        //
        CryptoInfo->SessionKey[0] = 0xD1;
        CryptoInfo->SessionKey[1] = 0x26;
        CryptoInfo->SessionKey[2] = 0x9E;

    } else if (CompInfo->MSCompType & NDISWAN_56_ENCRYPTION) {

        //
        // Set the first byte to reduce to
        // 56 bits of random key
        //
        CryptoInfo->SessionKey[0] = 0xD1;
    }

    //
    // Initialize the rc4 send table
    //
    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
        ("RC4 encryption KeyLength %d", CryptoInfo->SessionKeyLength));

    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
        ("RC4 encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
        CryptoInfo->SessionKey[0],CryptoInfo->SessionKey[1],
        CryptoInfo->SessionKey[2],CryptoInfo->SessionKey[3],
        CryptoInfo->SessionKey[4],CryptoInfo->SessionKey[5],
        CryptoInfo->SessionKey[6],CryptoInfo->SessionKey[7],
        CryptoInfo->SessionKey[8],CryptoInfo->SessionKey[9],
        CryptoInfo->SessionKey[10],CryptoInfo->SessionKey[11],
        CryptoInfo->SessionKey[12],CryptoInfo->SessionKey[13],
        CryptoInfo->SessionKey[14],CryptoInfo->SessionKey[15]));

    rc4_key(CryptoInfo->RC4Key,
            CryptoInfo->SessionKeyLength,
            CryptoInfo->SessionKey);

    return (STATUS_SUCCESS);
}
#endif

NTSTATUS
WanAllocateCCP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    BOOLEAN         IsSend
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanAllocateCCP: Enter"));

    if (CompInfo->MSCompType & NDISWAN_COMPRESSION) {
        ULONG   CompressSend;
        ULONG   CompressRecv;

        //
        // Get compression context sizes
        //
        getcontextsizes (&CompressSend, &CompressRecv);

        if (IsSend) {

            if (BundleCB->SendCompressContext == NULL) {
                NdisWanAllocateMemory(&BundleCB->SendCompressContext, CompressSend, COMPCTX_TAG);

                //
                // If we can't allocate memory the machine is toast.
                // Forget about freeing anything up.
                //
                if (BundleCB->SendCompressContext == NULL) {
                    NdisWanDbgOut(DBG_FAILURE, DBG_CCP, ("Can't allocate compression!"));
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }

            initsendcontext (BundleCB->SendCompressContext);

        } else {

            if (BundleCB->RecvCompressContext == NULL) {
                NdisWanAllocateMemory(&BundleCB->RecvCompressContext, CompressRecv, COMPCTX_TAG);

                //
                // If we can't allocate memory the machine is toast.
                // Forget about freeing anything up.
                //
                if (BundleCB->RecvCompressContext == NULL) {
                    NdisWanDbgOut(DBG_FAILURE, DBG_CCP, ("Can't allocate decompression"));
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }

            //
            // Initialize the decompression history table
            //
            initrecvcontext (BundleCB->RecvCompressContext);
        }

        Status = STATUS_SUCCESS;

        //
        // Next packet out is flushed
        //
        BundleCB->Flags |= RECV_PACKET_FLUSH;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanAllocateCCP: Exit"));

    return (Status);
}

VOID
WanDeallocateCCP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    BOOLEAN         IsSend
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanDeallocateCCP: Enter"));

    if (IsSend) {
        if (BundleCB->SendCompressContext != NULL) {

            NdisWanFreeMemory(BundleCB->SendCompressContext);

            BundleCB->SendCompressContext= NULL;
        }
    } else {

        if (BundleCB->RecvCompressContext != NULL) {
            NdisWanFreeMemory(BundleCB->RecvCompressContext);

            BundleCB->RecvCompressContext= NULL;
        }
    }

    //
    // Clear the compression bits
    //
    CompInfo->MSCompType &= ~NDISWAN_COMPRESSION;

    
    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanDeallocateCCP: Exit"));
}

NDIS_STATUS
AllocateEncryptMemory(
    PCRYPTO_INFO    CryptoInfo
    )
{
    PUCHAR  Mem;

    Mem =
        NdisAllocateFromNPagedLookasideList(&EncryptCtxList);

    if (Mem == NULL) {
        return (NDIS_STATUS_FAILURE);
    }

    NdisZeroMemory(Mem, ENCRYPTCTX_SIZE);

    CryptoInfo->Context = Mem;
    Mem += (sizeof(A_SHA_CTX) + sizeof(PVOID));

    CryptoInfo->RC4Key = Mem;
    (ULONG_PTR)CryptoInfo->RC4Key &= ~((ULONG_PTR)sizeof(PVOID)-1);

    return(NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\cm.c ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    cm.c

Abstract:

    This file contains the functions that implement the ndiswan
    NDIS 5.0 call manager interface.  These functions are used by the
    ndiswan miniport and NDIS 5.0 clients.

Author:

    Tony Bell   (TonyBe) January 9, 1997

Environment:

    Kernel Mode

Revision History:

    TonyBe      01/09/97        Created

--*/

#include "wan.h"
#include "traffic.h"
#include "ntddtc.h"

#define __FILE_SIG__    CM_FILESIG

NDIS_STATUS
CmCreateVc(
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     NdisVcHandle,
    OUT PNDIS_HANDLE    ProtocolVcContext
    )
{
    PCM_AFSAPCB AfSapCB = (PCM_AFSAPCB)ProtocolAfContext;
    PCM_VCCB    CmVcCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCreateVc: Enter"));

    CmVcCB =
        NdisWanAllocateCmVcCB(AfSapCB, NdisVcHandle);

    if (CmVcCB == NULL) {
        return (NDIS_STATUS_RESOURCES);
    }

    *ProtocolVcContext = CmVcCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCreateVc: Exit"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmDeleteVc(
    IN  NDIS_HANDLE     ProtocolVcContext
    )
{
    PCM_VCCB    CmVcCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeleteVc: Enter"));

    CmVcCB = (PCM_VCCB)ProtocolVcContext;

    ASSERT(CmVcCB->RefCount == 0);

    NdisWanFreeCmVcCB(CmVcCB);

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeleteVc: Exit"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmOpenAf(
    IN  NDIS_HANDLE             CallMgrBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             NdisAfHandle,
    OUT PNDIS_HANDLE            CallMgrAfContext
    )
{
    PMINIPORTCB MiniportCB = (PMINIPORTCB)CallMgrBindingContext;
    PCM_AFSAPCB AfSapCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmOpenAf: Enter"));

    if (AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_PPP) {
        return (NDIS_STATUS_FAILURE);
    }

    AfSapCB =
        NdisWanAllocateCmAfSapCB(MiniportCB);

    if (AfSapCB == NULL) {
        return (NDIS_STATUS_RESOURCES);
    }

    *CallMgrAfContext = (NDIS_HANDLE)AfSapCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmOpenAf: Exit"));

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmCloseAf(
    IN  NDIS_HANDLE     CallMgrAfContext
    )
{
    PCM_AFSAPCB AfSapCB = (PCM_AFSAPCB)CallMgrAfContext;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCloseAf: Enter"));

    NdisWanFreeCmAfSapCB(AfSapCB);

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCloseAf: Exit"));

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmRegisterSap(
    IN  NDIS_HANDLE             CallMgrAfContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    )
{
    PMINIPORTCB MiniportCB = (PMINIPORTCB)CallMgrAfContext;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmRegisterSap: Enter SapType %d", Sap->SapType));

    *CallMgrSapContext = CallMgrAfContext;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmRegisterSap: Exit"));

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmDeregisterSap(
    IN  NDIS_HANDLE             CallMgrSapContext
    )
{
    PCM_AFSAPCB AfSapCB = (PCM_AFSAPCB)CallMgrSapContext;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeregisterSap: Enter"));


    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeregisterSap: Exit"));
    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmMakeCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    OUT PNDIS_HANDLE            CallMgrPartyContext OPTIONAL
    )
{
    PBUNDLECB   BundleCB;
    PPROTOCOLCB ProtocolCB;
    PCM_VCCB    CmVcCB;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParams;
    PCO_MEDIA_PARAMETERS    MediaParams;
    PCO_SPECIFIC_PARAMETERS SpecificParams;
    LPQOS_WAN_MEDIA QosMedia;
    LPQOS_OBJECT_HDR QoSObject;
    LONG    ParamsLength;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmMakeCall: Enter"));

    CmVcCB = (PCM_VCCB)CallMgrVcContext;

    CallMgrParams =
        CallParameters->CallMgrParameters;

    MediaParams =
        CallParameters->MediaParameters;

    SpecificParams = &MediaParams->MediaSpecific;

    if (SpecificParams->ParamType != PARAM_TYPE_GQOS_INFO) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_CM,
        ("CmMakeCall: Not a QOS Vc! ParamType %x", SpecificParams->ParamType));
        return (NDIS_STATUS_FAILURE);
    }

    QosMedia = (LPQOS_WAN_MEDIA)SpecificParams->Parameters;

    //
    // Need to check the flowspec for bandwidth
    //

    do {
        ULONG_PTR   BIndex, PIndex;

        //
        // Get the protocolcb
        //
        GetNdisWanIndices(QosMedia->LinkId, BIndex, PIndex);

        if (!IsBundleValid((NDIS_HANDLE)BIndex, 
                           TRUE, 
                           &BundleCB)) {

            Status = NDIS_STATUS_FAILURE;
            break;
        }

        AcquireBundleLock(BundleCB);

        PROTOCOLCB_FROM_PROTOCOLH(BundleCB, ProtocolCB, PIndex);

        if (ProtocolCB == NULL ||
            ProtocolCB == (PVOID)RESERVED_PROTOCOLCB ||
            ProtocolCB->State != PROTOCOL_ROUTED) {
            ReleaseBundleLock(BundleCB);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // If we don't have multilink or if we have encryption then we can not
        // do isslow
        //
        if (!(BundleCB->FramingInfo.SendFramingBits & PPP_MULTILINK_FRAMING) || 
            (BundleCB->SendFlags & DO_ENCRYPTION)) {
            CmVcCB->FlowClass = 0;
        } else {

            if (QosMedia->ISSLOW == 1) {
                CmVcCB->FlowClass = MAX_MCML;
                BundleCB->Flags |= QOS_ENABLED;
            } else {
                CmVcCB->FlowClass = 0;
            }
        }


#ifdef USE_QOS_WORKER
        NdisInitializeWorkItem(&BundleCB->QoSWorkItem,
                               QoSSendFragments,
                               BundleCB);
#endif

        SetBundleFlags(BundleCB);

        NdisWanDbgOut(DBG_INFO, DBG_CM, ("MakeCall Vc/Protocol %p/%p %d/%d",
            CmVcCB, ProtocolCB, CmVcCB->State, ProtocolCB->State));

        NdisWanDbgOut(DBG_INFO, DBG_CM, ("Setting FlowClass %x Isslow %d",
            CmVcCB->FlowClass, QosMedia->ISSLOW));

        REF_CMVCCB(CmVcCB);

        CmVcCB->ProtocolCB = ProtocolCB;

        InsertTailList(&ProtocolCB->VcList, &CmVcCB->Linkage);

        REF_PROTOCOLCB(ProtocolCB);

        ReleaseBundleLock(BundleCB);

        InterlockedExchange((PLONG)&CmVcCB->State, CMVC_ACTIVE);

        NdisMCmActivateVc(CmVcCB->NdisVcHandle, CallParameters);

    } while (FALSE);

    //
    // Deref for ref applied in IsBundleValid
    //
    DEREF_BUNDLECB(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmMakeCall: Exit"));

    return(Status);
}

NDIS_STATUS
CmCloseCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
    IN  PVOID                   CloseData           OPTIONAL,
    IN  UINT                    Size                OPTIONAL
    )
{
    PPROTOCOLCB ProtocolCB;
    PBUNDLECB   BundleCB;
    PCM_VCCB    CmVcCB;
    BOOLEAN     DisableQoS = TRUE;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCloseCall: Enter"));

    CmVcCB = (PCM_VCCB)CallMgrVcContext;

    ProtocolCB =
        CmVcCB->ProtocolCB;

    BundleCB =
        ProtocolCB->BundleCB;

    AcquireBundleLock(BundleCB);

    if (CmVcCB->State != CMVC_CLOSE_DISPATCHED) {
        RemoveEntryList(&CmVcCB->Linkage);
    }

    //
    // Walk the Vc list and see if there are any
    // ISSLOW Vc's.  If there are not then disable QOS
    //
    {
        PCM_VCCB    _vc;

        _vc = (PCM_VCCB)ProtocolCB->VcList.Flink;

        while ((PVOID)_vc != (PVOID)&ProtocolCB->VcList) {
            if (_vc->FlowClass == MAX_MCML) {
                DisableQoS = FALSE;
                break;
            }
            _vc = (PCM_VCCB)_vc->Linkage.Flink;
        }
    }

    NdisWanDbgOut(DBG_INFO, DBG_CM, ("CloseCall Vc/Protocol %p/%p %d/%d",
        CmVcCB, ProtocolCB, CmVcCB->State, ProtocolCB->State));

    InterlockedExchange((PLONG)&CmVcCB->State, CMVC_CLOSING);

    DEREF_CMVCCB(CmVcCB);

    DEREF_PROTOCOLCB(ProtocolCB);

    if (DisableQoS && BundleCB != NULL) {

        BundleCB->Flags &= ~QOS_ENABLED;
    }

    ReleaseBundleLock(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCloseCall: Exit"));

    return(NDIS_STATUS_PENDING);
}

NDIS_STATUS
CmModifyCallQoS(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    PCM_VCCB    CmVcCB;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParams;
    PCO_MEDIA_PARAMETERS    MediaParams;
    PCO_SPECIFIC_PARAMETERS SpecificParams;
    LPQOS_WAN_MEDIA QosMedia;
    LPQOS_OBJECT_HDR QoSObject;
    PBUNDLECB   BundleCB;
    PPROTOCOLCB ProtocolCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmModifyCallQos: Enter"));

    CmVcCB = (PCM_VCCB)CallMgrVcContext;

    CallMgrParams =
        CallParameters->CallMgrParameters;

    MediaParams =
        CallParameters->MediaParameters;

    SpecificParams = &MediaParams->MediaSpecific;

    if (SpecificParams->ParamType != PARAM_TYPE_GQOS_INFO) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_CM,
        ("CmMakeCall: Not a QOS Vc! ParamType %x", SpecificParams->ParamType));
        return (NDIS_STATUS_SUCCESS);
    }

    QosMedia = (LPQOS_WAN_MEDIA)SpecificParams->Parameters;

    ProtocolCB = CmVcCB->ProtocolCB;

    if (ProtocolCB == NULL) {
        return (NDIS_STATUS_SUCCESS);
    }

    BundleCB = ProtocolCB->BundleCB;

    if (BundleCB == NULL) {
        return (NDIS_STATUS_SUCCESS);
    }

    AcquireBundleLock(BundleCB);

    //
    // If we don't have multilink or if we have encryption then we can not
    // do isslow
    //
    if (!(BundleCB->FramingInfo.SendFramingBits & PPP_MULTILINK_FRAMING) || 
        (BundleCB->SendFlags & DO_ENCRYPTION)) 
    {
        CmVcCB->FlowClass = 0;
    } else {

        if (QosMedia->ISSLOW == 1) {
            CmVcCB->FlowClass = MAX_MCML;
            BundleCB->Flags |= QOS_ENABLED;
        } else {
            CmVcCB->FlowClass = 0;
            
            // Walk the Vc list and see if there are any
            // ISSLOW Vc's.  If there are not then disable QOS
            {
                PCM_VCCB    _vc;
                BOOLEAN     DisableQoS = TRUE;
        
                _vc = (PCM_VCCB)ProtocolCB->VcList.Flink;
        
                while ((PVOID)_vc != (PVOID)&ProtocolCB->VcList) {
                    if (_vc->FlowClass == MAX_MCML) {
                        DisableQoS = FALSE;
                        break;
                    }
                    _vc = (PCM_VCCB)_vc->Linkage.Flink;
                }
                
                if (DisableQoS) {
                    BundleCB->Flags &= ~QOS_ENABLED;
                }
            }
        }
    }
                              
    SetBundleFlags(BundleCB);

    ReleaseBundleLock(BundleCB);

    NdisWanDbgOut(DBG_DEATH, DBG_CM, ("Updating FlowClass %x for Vc/Protocol %p/%p, Isslow %d",
        CmVcCB->FlowClass, CmVcCB, CmVcCB->ProtocolCB, QosMedia->ISSLOW));

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmModifyCallQos: Exit"));
    return(NDIS_STATUS_SUCCESS);
}

VOID
CmIncomingCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmIncomingCallComplete: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmIncomingCallComplete: Exit"));
}

VOID
CmActivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmActivateVcComplete: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmActivateVcComplete: Exit"));
}

VOID
CmDeactivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeactivateVcComplete: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeactivateVcComplete: Exit"));
}

NDIS_STATUS
CmRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    )
{
    NDIS_STATUS Status;
    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmRequest: Enter"));

    Status =
    NdisWanCoOidProc((PMINIPORTCB)ProtocolAfContext,
                     (PCM_VCCB)ProtocolVcContext,
                     NdisRequest);

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmRequest: Exit Status: 0x%x", Status));
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\cl.c ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    cl.c

Abstract:

    This file contains the functions that implement the ndiswan
    NDIS 5.0 client interface.  These functions are used to interface
    with NDIS 5.0 miniports/call managers.

Author:

    Tony Bell   (TonyBe) January 9, 1997

Environment:

    Kernel Mode

Revision History:

    TonyBe      01/09/97        Created

--*/

//
// We want to initialize all of the global variables now!
//
#include "wan.h"
#include "atm.h"

#define __FILE_SIG__    CL_FILESIG

NDIS_STATUS
ClCreateVc(
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     NdisVcHandle,
    OUT PNDIS_HANDLE    ProtocolVcContext
    )
{
    PCL_AFSAPCB AfSapCB = (PCL_AFSAPCB)ProtocolAfContext;
    POPENCB     OpenCB = AfSapCB->OpenCB;
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCreateVc: Enter"));

    //
    // Get a linkcb
    //
    LinkCB = NdisWanAllocateLinkCB(OpenCB, 0);

    if (LinkCB == NULL) {

        //
        // Error getting LinkCB!
        //

        return (NDIS_STATUS_RESOURCES);
        
    }

    LinkCB->NdisLinkHandle = NdisVcHandle;
    LinkCB->ConnectionWrapperID = NdisVcHandle;
    LinkCB->AfSapCB = AfSapCB;

    //
    // Set some default values
    //
    LinkCB->RFlowSpec.PeakBandwidth =
    LinkCB->SFlowSpec.PeakBandwidth = 28800 / 8;

    LinkCB->SendWindow = OpenCB->WanInfo.MaxTransmit;

    //
    // Get a bundlecb
    //
    BundleCB = NdisWanAllocateBundleCB();

    if (BundleCB == NULL) {
        NdisWanFreeLinkCB(LinkCB);

        //
        // Error getting BundleCB!
        //
        return (NDIS_STATUS_RESOURCES);
    }

    //
    // Add LinkCB to BundleCB
    //
    AcquireBundleLock(BundleCB);

    AddLinkToBundle(BundleCB, LinkCB);

    ReleaseBundleLock(BundleCB);

    //
    // Place BundleCB in active connection table
    //
    if (NULL == InsertBundleInConnectionTable(BundleCB)) {
        //
        // Error inserting link in ConnectionTable
        //
        RemoveLinkFromBundle(BundleCB, LinkCB, FALSE);
        NdisWanFreeLinkCB(LinkCB);
        NdisWanFreeBundleCB(BundleCB);

        return (NDIS_STATUS_RESOURCES);
    }

    //
    // Place LinkCB in active connection table
    //
    if (NULL == InsertLinkInConnectionTable(LinkCB)) {
        //
        // Error inserting bundle in connectiontable
        //
        RemoveLinkFromBundle(BundleCB, LinkCB, FALSE);
        NdisWanFreeLinkCB(LinkCB);
        NdisWanFreeBundleCB(BundleCB);

        return (NDIS_STATUS_RESOURCES);
    }

    *ProtocolVcContext = LinkCB->hLinkHandle;

    NdisAcquireSpinLock(&AfSapCB->Lock);
    REF_CLAFSAPCB(AfSapCB);
    NdisReleaseSpinLock(&AfSapCB->Lock);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCreateVc: Exit"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
ClDeleteVc(
    IN  NDIS_HANDLE     ProtocolVcContext
    )
{
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;
    PCL_AFSAPCB AfSapCB;

    if (!IsLinkValid(ProtocolVcContext, FALSE, &LinkCB)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_CL,
            ("NDISWAN: Possible double delete of VcContext %x\n",
            ProtocolVcContext));

        return (NDIS_STATUS_FAILURE);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClDeleteVc: Enter %p", LinkCB));

    NdisAcquireSpinLock(&LinkCB->Lock);

    AfSapCB = LinkCB->AfSapCB;

    //
    // For the ref applied in IsLinkValid.  We
    // don't have to use the full deref code here as we know the ref
    // applied at CreateVc will keep the link around.
    //
    LinkCB->RefCount--;

    //
    // For the createvc reference
    //
    DEREF_LINKCB_LOCKED(LinkCB);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClDeleteVc: Exit"));

    DEREF_CLAFSAPCB(AfSapCB);

    return(NDIS_STATUS_SUCCESS);
}

VOID
ClOpenAfComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     NdisAfHandle
    )
{
    PCL_AFSAPCB     AfSapCB = (PCL_AFSAPCB)ProtocolAfContext;
    POPENCB         OpenCB = AfSapCB->OpenCB;
    PCO_SAP         Sap;
    NDIS_HANDLE     SapHandle;
    UCHAR           SapBuffer[CLSAP_BUFFERSIZE];

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClOpenAfComplete: Enter %p %x", AfSapCB, Status));

    NdisAcquireSpinLock(&AfSapCB->Lock);

    AfSapCB->Flags &= ~(AF_OPENING);

    if (Status == NDIS_STATUS_SUCCESS) {

        AfSapCB->Flags |= 
            (AF_OPENED | SAP_REGISTERING);
        AfSapCB->AfHandle = NdisAfHandle;

        NdisReleaseSpinLock(&AfSapCB->Lock);

        //
        // If we successfully opened the AddressFamily we
        // need to register our SAP.
        //
        NdisAcquireSpinLock(&OpenCB->Lock);

        InsertHeadList(&OpenCB->AfSapCBList,
                       &AfSapCB->Linkage);

        NdisReleaseSpinLock(&OpenCB->Lock);

        Sap = (PCO_SAP)SapBuffer;
        //
        // Register our SAP
        //
        Sap->SapType = SAP_TYPE_NDISWAN_PPP;
        Sap->SapLength = sizeof(DEVICECLASS_NDISWAN_SAP);
        NdisMoveMemory(Sap->Sap,
            DEVICECLASS_NDISWAN_SAP,
            sizeof(DEVICECLASS_NDISWAN_SAP));

        Status =
        NdisClRegisterSap(AfSapCB->AfHandle,
                          AfSapCB,
                          Sap,
                          &SapHandle);

        if (Status != NDIS_STATUS_PENDING) {
            ClRegisterSapComplete(Status, AfSapCB, Sap, SapHandle);
        }

        NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
        ("ClRegisterSap SapHandle 0x%x status: 0x%x", SapHandle, Status));

    } else {

        AfSapCB->Flags |= AF_OPEN_FAILED;

        //
        // We failed to register the address family so free
        // associated memory.
        //
        NdisWanFreeClAfSapCB(AfSapCB);

        NdisReleaseSpinLock(&AfSapCB->Lock);

        //
        // Since the open af was initiated from the notification
        // of a new af from ndis we have to decrement the af
        // registering count.
        //
        NdisAcquireSpinLock(&OpenCB->Lock);
        if (--OpenCB->AfRegisteringCount == 0) {
            NdisWanSetNotificationEvent(&OpenCB->AfRegisteringEvent);
        }
        NdisReleaseSpinLock(&OpenCB->Lock);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClOpenAfComplete: Exit"));
}

VOID
ClCloseAfComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext
    )
{
    PCL_AFSAPCB     AfSapCB = (PCL_AFSAPCB)ProtocolAfContext;
    POPENCB         OpenCB = AfSapCB->OpenCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCloseAfComplete: Enter %p %x", AfSapCB, Status));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    do {

        //
        // If the close attempt failed there must be another
        // thread that is already doing the close.  Let the
        // other thread cleanup the afsapcb.
        //
        if (Status != NDIS_STATUS_SUCCESS) {
            break;
        }

        NdisAcquireSpinLock(&AfSapCB->Lock);
        AfSapCB->Flags &= ~(AF_CLOSING);
        AfSapCB->Flags |= (AF_CLOSED);
        NdisReleaseSpinLock(&AfSapCB->Lock);

        NdisAcquireSpinLock(&OpenCB->Lock);

        RemoveEntryList(&AfSapCB->Linkage);

        NdisReleaseSpinLock(&OpenCB->Lock);

        NdisWanFreeClAfSapCB(AfSapCB);

    } while (FALSE);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCloseAfComplete: Exit"));
}

VOID
ClRegisterSapComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolSapContext,
    IN  PCO_SAP         Sap,
    IN  NDIS_HANDLE     NdisSapHandle
    )
{
    PCL_AFSAPCB     AfSapCB = (PCL_AFSAPCB)ProtocolSapContext;
    POPENCB         OpenCB = AfSapCB->OpenCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClRegisterSapComplete: Enter %p %x", AfSapCB, Status));

    NdisAcquireSpinLock(&AfSapCB->Lock);
    AfSapCB->Flags &= ~(SAP_REGISTERING);

    if (Status == NDIS_STATUS_SUCCESS) {


        AfSapCB->Flags |= SAP_REGISTERED;
        AfSapCB->SapHandle = NdisSapHandle;

        NdisReleaseSpinLock(&AfSapCB->Lock);

    } else {

        //
        // We failed to register our sap so close the address family
        //
        AfSapCB->Flags &= ~(AF_OPENED);
        AfSapCB->Flags |= 
            (SAP_REGISTER_FAILED | AF_CLOSING);

        NdisReleaseSpinLock(&AfSapCB->Lock);

        NdisAcquireSpinLock(&OpenCB->Lock);

        RemoveEntryList(&AfSapCB->Linkage);

        InsertTailList(&OpenCB->AfSapCBClosing, &AfSapCB->Linkage);

        NdisReleaseSpinLock(&OpenCB->Lock);

        NdisClCloseAddressFamily(AfSapCB->AfHandle);

        if (Status != NDIS_STATUS_PENDING) {
            ClCloseAfComplete(Status, AfSapCB);
        }
    }

    //
    // Since the open af was initiated from the notification
    // of a new af from ndis we have to decrement the af
    // registering count.
    //
    NdisAcquireSpinLock(&OpenCB->Lock);
    if (--OpenCB->AfRegisteringCount == 0) {
        NdisWanSetNotificationEvent(&OpenCB->AfRegisteringEvent);
    }
    NdisReleaseSpinLock(&OpenCB->Lock);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClRegisterSapComplete: Exit"));
}

VOID
ClDeregisterSapComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolSapContext
    )
{
    PCL_AFSAPCB     AfSapCB = (PCL_AFSAPCB)ProtocolSapContext;
    POPENCB         OpenCB = AfSapCB->OpenCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClDeregisterSapComplete: Enter %p %x", AfSapCB, Status));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    NdisAcquireSpinLock(&AfSapCB->Lock);

    ASSERT(AfSapCB->Flags & AF_OPENED);

    AfSapCB->Flags &= ~(AF_OPENED | SAP_DEREGISTERING);
    AfSapCB->Flags |= (AF_CLOSING);

    NdisReleaseSpinLock(&AfSapCB->Lock);

    Status =
        NdisClCloseAddressFamily(AfSapCB->AfHandle);

    if (Status != NDIS_STATUS_PENDING) {
        ClCloseAfComplete(Status, AfSapCB);
    }

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClDeregisterSapComplete: Exit"));
}

VOID
ClMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClMakeCallComplete: Enter %p %x", ProtocolVcContext, Status));

    DbgBreakPoint();

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClMakeCallComplete: Exit"));
}

VOID
ClModifyQoSComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClModifyQoSComplete: Enter %p %x", ProtocolVcContext, Status));

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClModifyQoSComplete: Exit"));
}

VOID
ClCloseCallComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  NDIS_HANDLE     ProtocolPartyContext OPTIONAL
    )
{

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCloseCallComplete: Enter %p %x", ProtocolVcContext, Status));

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCloseCallComplete: Exit"));

}

NDIS_STATUS
ClIncomingCall(
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    )
{
    PCL_AFSAPCB     AfSapCB = (PCL_AFSAPCB)ProtocolSapContext;
    PLINKCB         LinkCB;
    POPENCB         OpenCB = AfSapCB->OpenCB;
    PBUNDLECB       BundleCB;
    BOOLEAN         AtmUseLLC = FALSE;
    BOOLEAN         MediaBroadband = FALSE;
    PWAN_LINK_INFO  LinkInfo;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClIncomingCall: Enter %p %p", AfSapCB, ProtocolVcContext));

    do {

        if (!AreLinkAndBundleValid(ProtocolVcContext, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {

            Status = NDIS_STATUS_FAILURE;
            break;
        }

        NdisAcquireSpinLock(&LinkCB->Lock);

        LinkCB->ClCallState = CL_CALL_CONNECTED;

        NdisReleaseSpinLock(&LinkCB->Lock);

        AcquireBundleLock(BundleCB);

        NdisMoveMemory(&LinkCB->SFlowSpec,
                       &CallParameters->CallMgrParameters->Transmit,
                       sizeof(FLOWSPEC));

        NdisMoveMemory(&LinkCB->RFlowSpec,
                       &CallParameters->CallMgrParameters->Receive,
                       sizeof(FLOWSPEC));

        if (LinkCB->SFlowSpec.PeakBandwidth == 0) {
            LinkCB->SFlowSpec.PeakBandwidth = 28800 / 8;
        }

        if (LinkCB->RFlowSpec.PeakBandwidth == 0) {
            LinkCB->RFlowSpec.PeakBandwidth = LinkCB->SFlowSpec.PeakBandwidth;
        }

        LinkInfo = &LinkCB->LinkInfo;

        //
        // Assume all CoNDIS miniports support PPP framing
        //
        LinkInfo->SendFramingBits =
        LinkInfo->RecvFramingBits = PPP_FRAMING;

        LinkCB->RecvHandler = ReceivePPP;

        if (OpenCB->MediumType == NdisMediumAtm ||

            (OpenCB->MediumType == NdisMediumWan &&
            (OpenCB->MediumSubType == NdisWanMediumAtm ||
             OpenCB->MediumSubType == NdisWanMediumPppoe)) ||

            (OpenCB->MediumType == NdisMediumCoWan &&
            (OpenCB->MediumSubType == NdisWanMediumAtm ||
             OpenCB->MediumSubType == NdisWanMediumPppoe))) {

            MediaBroadband = TRUE;

            LinkCB->RecvHandler = DetectBroadbandFraming;
        }

        if (MediaBroadband) {

            if (CallParameters->Flags & PERMANENT_VC) {

                //
                // Per TomF we are going to use NULL encap as
                // our default PVC encapsulation
                //
                if (gbAtmUseLLCOnPVC) {
                    AtmUseLLC = TRUE;

                }

            } else {
                //
                // If this is an ATM SVC we need to see
                // if the SVC needs LLC framing or not
                //
                if (gbAtmUseLLCOnSVC) {
                    AtmUseLLC = TRUE;

                } else {
                    ULONG           IeCount;
                    Q2931_IE UNALIGNED  *Ie;
                    ATM_BLLI_IE UNALIGNED  *Bli;
                    Q2931_CALLMGR_PARAMETERS    *cmparams;

                    cmparams = (Q2931_CALLMGR_PARAMETERS*)
                        &(CallParameters->CallMgrParameters->CallMgrSpecific.Parameters[0]);

                    Bli = NULL;
                    Ie = (Q2931_IE UNALIGNED *)&cmparams->InfoElements[0];
                    for (IeCount = 0;
                        IeCount < cmparams->InfoElementCount;
                        IeCount++) {

                        if (Ie->IEType == IE_BLLI) {
                            Bli = (ATM_BLLI_IE UNALIGNED*)&Ie->IE[0];
                            break;
                        }

                        Ie = (Q2931_IE UNALIGNED *)((ULONG_PTR)Ie + Ie->IELength);
                    }

                    if (Bli != NULL) {
                        AtmUseLLC = (Bli->Layer2Protocol == BLLI_L2_LLC);
                    }
                }
            }

            if (AtmUseLLC) {
                LinkInfo->SendFramingBits |= LLC_ENCAPSULATION;
                LinkInfo->RecvFramingBits |= LLC_ENCAPSULATION;
                LinkCB->RecvHandler = ReceiveLLC;
            }

            if (!(LinkInfo->SendFramingBits & LLC_ENCAPSULATION)) {
                LinkInfo->SendFramingBits |= PPP_COMPRESS_ADDRESS_CONTROL;
                LinkInfo->RecvFramingBits |= PPP_COMPRESS_ADDRESS_CONTROL;
            }
        }

        NdisWanDbgOut(DBG_TRACE, DBG_CL, ("SPeakBandwidth %d SendWindow %d",
            LinkCB->SFlowSpec.PeakBandwidth,
            LinkCB->SendWindow));

        if (CallParameters->Flags & PERMANENT_VC) {

            //
            // This is a PVC so we will disable idle data detection
            // thus allowing the connection to remain active
            //
            BundleCB->Flags |= DISABLE_IDLE_DETECT;
        }

        BundleCB->FramingInfo.RecvFramingBits =
        BundleCB->FramingInfo.SendFramingBits = PPP_FRAMING;

        UpdateBundleInfo(BundleCB);

        //
        // Deref for the ref applied by AreLinkAndBundleValid.  This
        // will release the BundleCB->Lock!
        //
        DEREF_BUNDLECB_LOCKED(BundleCB);

        //
        // Deref for the ref applied by AreLinkAndBundleValid.
        //
        DEREF_LINKCB(LinkCB);

    } while (0);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClIncomingCall: Exit"));

    return (Status);
}

VOID
ClIncomingCallQoSChange(
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    PLINKCB         LinkCB;
    PBUNDLECB       BundleCB;
    POPENCB         OpenCB;
    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClIncomingCallQoSChange: Enter %p", ProtocolVcContext));

    do {

        if (!AreLinkAndBundleValid(ProtocolVcContext,
                                   TRUE,
                                   &LinkCB,
                                   &BundleCB)) {
            break;
        }

        AcquireBundleLock(BundleCB);

        OpenCB = LinkCB->OpenCB;

        //
        // Do I need to pass this info to 5.0 Clients?????
        //

        NdisMoveMemory(&LinkCB->SFlowSpec,
                       &CallParameters->CallMgrParameters->Transmit,
                       sizeof(FLOWSPEC));

        NdisMoveMemory(&LinkCB->RFlowSpec,
                       &CallParameters->CallMgrParameters->Receive,
                       sizeof(FLOWSPEC));

        if (LinkCB->SFlowSpec.PeakBandwidth == 0) {
            LinkCB->SFlowSpec.PeakBandwidth = 28800 / 8;
        }

        if (LinkCB->RFlowSpec.PeakBandwidth == 0) {
            LinkCB->RFlowSpec.PeakBandwidth = LinkCB->SFlowSpec.PeakBandwidth;
        }

        UpdateBundleInfo(BundleCB);

        //
        // Deref for the ref applied by AreLinkAndBundleValid.  This will
        // release the BundleCB->Lock.
        //
        DEREF_BUNDLECB_LOCKED(BundleCB);

        //
        // Deref for the ref applied by AreLinkAndBundleValid.
        //
        DEREF_LINKCB(LinkCB);

    } while (0);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClIncomingCallQoSChange: Exit"));
}

VOID
ClIncomingCloseCall(
    IN  NDIS_STATUS     CloseStatus,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PVOID           CloseData   OPTIONAL,
    IN  UINT            Size        OPTIONAL
    )
{
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;
    PRECV_DESC  RecvDesc;
    NDIS_STATUS Status;
    ULONG       i;
    BOOLEAN     FreeBundle = FALSE;
    BOOLEAN     FreeLink = FALSE;

    NdisWanDbgOut(DBG_TRACE, DBG_CL,
        ("ClIncomingCloseCall: Enter %p %x", ProtocolVcContext, CloseStatus));

    do {

        if (!AreLinkAndBundleValid(ProtocolVcContext,
                                   TRUE,
                                   &LinkCB,
                                   &BundleCB)) {
#if DBG
            DbgPrint("NDISWAN: CloseCall after link has gone down VcContext %x\n",
                ProtocolVcContext);

            DbgBreakPoint();
#endif
            break;
        }

        NdisAcquireSpinLock(&LinkCB->Lock);

        //
        // Link is now going down
        //
        LinkCB->State = LINK_GOING_DOWN;

        if (LinkCB->VcRefCount == 0) {

            LinkCB->ClCallState = CL_CALL_CLOSED;

            NdisReleaseSpinLock(&LinkCB->Lock);

            Status =
                NdisClCloseCall(LinkCB->NdisLinkHandle,
                                NULL,
                                NULL,
                                0);

            if (Status != NDIS_STATUS_PENDING) {
                ClCloseCallComplete(Status,
                                    LinkCB,
                                    NULL);
            }

        } else {
            LinkCB->ClCallState = CL_CALL_CLOSE_PENDING;

            NdisReleaseSpinLock(&LinkCB->Lock);
        }

        NdisAcquireSpinLock(&IoRecvList.Lock);

        RecvDesc = (PRECV_DESC)IoRecvList.DescList.Flink;

        while ((PVOID)RecvDesc != (PVOID)&IoRecvList.DescList) {
            PRECV_DESC  Next;

            Next = (PRECV_DESC)RecvDesc->Linkage.Flink;

            if (RecvDesc->LinkCB == LinkCB) {

                RemoveEntryList(&RecvDesc->Linkage);

                LinkCB->RecvDescCount--;

                IoRecvList.ulDescCount--;

                NdisWanFreeRecvDesc(RecvDesc);
            }

            RecvDesc = Next;
        }

        NdisReleaseSpinLock(&IoRecvList.Lock);

        //
        // Flush the Bundle's fragment send queues that
        // have sends pending on this link
        //
        AcquireBundleLock(BundleCB);

        for (i = 0; i < MAX_MCML; i++) {
            PSEND_DESC SendDesc;
            PSEND_FRAG_INFO FragInfo;

            FragInfo = &BundleCB->SendFragInfo[i];

            SendDesc = (PSEND_DESC)FragInfo->FragQueue.Flink;

            while ((PVOID)SendDesc != (PVOID)&FragInfo->FragQueue) {

                if (SendDesc->LinkCB == LinkCB) {
                    PSEND_DESC  NextSendDesc;

                    NextSendDesc = (PSEND_DESC)SendDesc->Linkage.Flink;

                    RemoveEntryList(&SendDesc->Linkage);

                    FragInfo->FragQueueDepth--;

                    (*LinkCB->SendHandler)(SendDesc);

                    SendDesc = NextSendDesc;
                } else {
                    SendDesc = (PSEND_DESC)SendDesc->Linkage.Flink;
                }
            }
        }

        UpdateBundleInfo(BundleCB);

        ReleaseBundleLock(BundleCB);

        //
        // Deref's for the refs applied by AreLinkAndBundleValid.
        //
        DEREF_LINKCB(LinkCB);

        DEREF_BUNDLECB(BundleCB);

    } while (0);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClIncomingCloseCall: Exit"));
}

VOID
ClCallConnected(
    IN  NDIS_HANDLE     ProtocolVcContext
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCallConnected: Enter %p", ProtocolVcContext));

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCallConnected: Exit"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\cnvint.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    cnvint.c

Abstract:

    Text to integer and integer to text converion routines.

Author:

    Steve Wood (stevewo) 23-Aug-1990

Revision History:

--*/

#include <ntrtlp.h>

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlIntegerToChar)
#pragma alloc_text(PAGE,RtlCharToInteger)
#pragma alloc_text(PAGE,RtlUnicodeStringToInteger)
#pragma alloc_text(PAGE,RtlIntegerToUnicodeString)
#pragma alloc_text(PAGE,RtlLargeIntegerToChar)
#endif

CHAR RtlpIntegerChars[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

NTSTATUS
RtlIntegerToChar (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> 4 - Shift;
        }

    s = &Result[ 32 ];
    *s = '\0';
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
            }
        else {
            Digit = Value % Base;
            Value = Value / Base;
            }

        *--s = RtlpIntegerChars[ Digit ];
    } while (Value != 0);

    Length = &Result[ 32 ] - s;
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = '0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length );

            if ((LONG)Length < OutputLength) {
                String[ Length ] = '\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}


NTSTATUS
RtlCharToInteger (
    IN PCSZ String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    CHAR c, Sign;
    ULONG Result, Digit, Shift;

    while ((Sign = *String++) <= ' ') {
        if (!*String) {
            String--;
            break;
            }
        }

    c = Sign;
    if (c == '-' || c == '+') {
        c = *String++;
        }

    if (!ARGUMENT_PRESENT( Base )) {
        Base = 10;
        Shift = 0;
        if (c == '0') {
            c = *String++;
            if (c == 'x') {
                Base = 16;
                Shift = 4;
                }
            else
            if (c == 'o') {
                Base = 8;
                Shift = 3;
                }
            else
            if (c == 'b') {
                Base = 2;
                Shift = 1;
                }
            else {
                String--;
                }

            c = *String++;
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
            }
        }

    Result = 0;
    while (c) {
        if (c >= '0' && c <= '9') {
            Digit = c - '0';
            }
        else
        if (c >= 'A' && c <= 'F') {
            Digit = c - 'A' + 10;
            }
        else
        if (c >= 'a' && c <= 'f') {
            Digit = c - 'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        c = *String++;
        }

    if (Sign == '-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlUnicodeStringToInteger (
    IN PUNICODE_STRING String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    PCWSTR s;
    WCHAR c, Sign;
    ULONG nChars, Result, Digit, Shift;

    s = String->Buffer;
    nChars = String->Length / sizeof( WCHAR );
    while (nChars-- && (Sign = *s++) <= ' ') {
        if (!nChars) {
            Sign = UNICODE_NULL;
            break;
            }
        }

    c = Sign;
    if (c == L'-' || c == L'+') {
        if (nChars) {
            nChars--;
            c = *s++;
            }
        else {
            c = UNICODE_NULL;
            }
        }

    if (!ARGUMENT_PRESENT( Base )) {
        Base = 10;
        Shift = 0;
        if (c == L'0') {
            if (nChars) {
                nChars--;
                c = *s++;
                if (c == L'x') {
                    Base = 16;
                    Shift = 4;
                    }
                else
                if (c == L'o') {
                    Base = 8;
                    Shift = 3;
                    }
                else
                if (c == L'b') {
                    Base = 2;
                    Shift = 1;
                    }
                else {
                    nChars++;
                    s--;
                    }
                }

            if (nChars) {
                nChars--;
                c = *s++;
                }
            else {
                c = UNICODE_NULL;
                }
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
            }
        }

    Result = 0;
    while (c != UNICODE_NULL) {
        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';
            }
        else
        if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;
            }
        else
        if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        if (!nChars) {
            break;
            }
        nChars--;
        c = *s++;
        }

    if (Sign == L'-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlIntegerToUnicodeString (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )
{
    NTSTATUS Status;
    UCHAR ResultBuffer[ 16 ];
    ANSI_STRING AnsiString;

    Status = RtlIntegerToChar( Value, Base, sizeof( ResultBuffer ), ResultBuffer );
    if (NT_SUCCESS( Status )) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof( ResultBuffer );
        AnsiString.Length = (USHORT)strlen( ResultBuffer );
        Status = RtlAnsiStringToUnicodeString( String, &AnsiString, FALSE );
        }

    return( Status );
}


NTSTATUS
RtlLargeIntegerToChar (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[ 100 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> 4 - Shift;
        }

    s = &Result[ 99 ];
    *s = '\0';
    if (Shift != 0) {
        ULONG LowValue,HighValue,HighShift,HighMask;

        LowValue = Value->LowPart;
        HighValue = Value->HighPart;
        HighShift = Shift - (sizeof(ULONG) % Shift);
        HighMask = 0xF >> 4 - HighShift;
        do {
            Digit = LowValue & Mask;
            LowValue = (LowValue >> Shift) | ((HighValue & HighMask) << (sizeof(ULONG) - HighShift));
            HighValue = HighValue >> HighShift;
            *--s = RtlpIntegerChars[ Digit ];
        } while ((LowValue | HighValue) != 0);
    } else {
        LARGE_INTEGER TempValue=*Value;
        do {
            TempValue = RtlExtendedLargeIntegerDivide(TempValue,Base,&Digit);
            *--s = RtlpIntegerChars[ Digit ];
        } while (TempValue.HighPart != 0 || TempValue.LowPart != 0);
    }

    Length = &Result[ 99 ] - s;
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = '0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length );

            if ((LONG)Length < OutputLength) {
                String[ Length ] = '\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\adapter.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Adapter.h

Abstract:

    This file contains major data structures used by the NdisWan driver

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#ifndef _NDISWAN_ADAPTER_
#define _NDISWAN_ADAPTER_

//
// This is the control block for the NdisWan adapter that is created by the NDIS Wrapper
// making a call to NdisWanInitialize.
//
typedef struct _MINIPORTCB {
    LIST_ENTRY              Linkage;            // Used to link adapter into global list
    ULONG                   RefCount;           // Adapter reference count
    NDIS_HANDLE             MiniportHandle;     // Assigned in MiniportInitialize
    LIST_ENTRY              AfSapCBList;
    ULONG                   AfRefCount;
    LIST_ENTRY              ProtocolCBList;
    ULONG                   Flags;              // Flags
#define RESET_IN_PROGRESS       0x00000001
#define ASK_FOR_RESET           0x00000002
#define RECEIVE_COMPLETE        0x00000004
#define HALT_IN_PROGRESS        0x00000008
#define PROTOCOL_KEEPS_STATS    0x00000010
    NDIS_MEDIUM             MediumType;             // Medium type that we are emulating
    NDIS_HARDWARE_STATUS    HardwareStatus;         // Hardware status (????)
    NDIS_STRING             AdapterName;            // Adapter Name (????)
    UCHAR                   NetworkAddress[ETH_LENGTH_OF_ADDRESS];  // Ethernet address for this adapter
    UCHAR                   Reserved1[2];
    ULONG                   NumberofProtocols;
    USHORT                  ProtocolType;
    USHORT                  Reserved2;
    struct _PROTOCOLCB      *NbfProtocolCB;
    WAN_EVENT               HaltEvent;              // Async notification event
    NDIS_SPIN_LOCK          Lock;               // Structure access lock
#if DBG
    LIST_ENTRY              SendPacketList;
    LIST_ENTRY              RecvPacketList;
#endif
} MINIPORTCB, *PMINIPORTCB;

//
// This is the open block for each WAN Miniport adapter that NdisWan binds to through
// the NDIS Wrapper as a "protocol".
//
typedef struct _OPENCB {
    LIST_ENTRY              Linkage;            // Used to link adapter into global list
    ULONG                   RefCount;
    ULONG                   Flags;
#define OPEN_LEGACY         0x00000001
#define OPEN_CLOSING        0x00000002
#define CLOSE_SCHEDULED     0x00000004
#define SEND_RESOURCES      0x00000008
#define OPEN_IN_BIND        0x00000010
    UINT                    ActiveLinkCount;
    NDIS_HANDLE             BindingHandle;      // Binding handle
    NDIS_STRING             MiniportName;       // WAN Miniport name
    GUID                    Guid;               // Parsed GUID of this miniport
    NDIS_HANDLE             UnbindContext;
    NDIS_MEDIUM             MediumType;         // WAN Miniport medium type
    NDIS_WAN_MEDIUM_SUBTYPE MediumSubType;      // WAN Miniport medium subtype
    NDIS_WAN_HEADER_FORMAT  WanHeaderFormat;    // WAN Miniport header type
    NDIS_WORK_ITEM          WorkItem;
    WAN_EVENT               NotificationEvent;  // Async notification event for adapter operations (open, close, ...)
    NDIS_STATUS             NotificationStatus; // Notification status for async adapter events
    NDIS_WAN_INFO           WanInfo;            // WanInfo structure
    LIST_ENTRY              WanRequestList;
    LIST_ENTRY              AfSapCBList;
    LIST_ENTRY              AfSapCBClosing;
    ULONG                   BufferSize;
    ULONG                   SendResources;
    union {
        NPAGED_LOOKASIDE_LIST   WanPacketPool;      // Used if no memory flags set

        struct {
            PUCHAR              PacketMemory;   // Used if memory flags set
            ULONG               PacketMemorySize;
            SLIST_HEADER        WanPacketList;
        };
    };
    ULONG                   AfRegisteringCount;
    WAN_EVENT               AfRegisteringEvent;
    WAN_EVENT               InitEvent;
    NDIS_SPIN_LOCK          Lock;               // Structure access lock
#if DBG
    LIST_ENTRY              SendPacketList;
#endif
} OPENCB, *POPENCB;

#define MINIPORTCB_SIZE sizeof(MINIPORTCB)
#define OPENCB_SIZE     sizeof(OPENCB)

//
// Main control block for all global data
//
typedef struct _NDISWANCB {
    NDIS_SPIN_LOCK      Lock;                       // Structure access lock
    ULONG               RefCount;
    NDIS_HANDLE         NdisWrapperHandle;          // NDIS Wrapper handle
    NDIS_HANDLE         MiniportDriverHandle;       // Handle for this miniport
    NDIS_HANDLE         ProtocolHandle;             // Our protocol handle
    ULONG               NumberOfProtocols;          // Total number of protocols that we are bound to
    ULONG               NumberOfLinks;              // Total number of links for all WAN Miniport Adapters
    PDRIVER_OBJECT      pDriverObject;              // Pointer to the NT Driver Object
    PDEVICE_OBJECT      pDeviceObject;              // Pointer to the device object
    NDIS_HANDLE         DeviceHandle;
    PDRIVER_UNLOAD      NdisUnloadHandler;
    PIRP                HibernateEventIrp;
    PMINIPORTCB         PromiscuousAdapter;

#ifdef MY_DEVICE_OBJECT
    PDRIVER_DISPATCH    MajorFunction[IRP_MJ_MAXIMUM_FUNCTION+1];   // Device dispatch functions
#endif

}NDISWANCB, *PNDISWANCB;

#endif  // _NDISWAN_ADAPTER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndistapi\private.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    private.h

Abstract:

    Private definitions for NdisTapi.sys

Author:

    Dan Knudson (DanKn)    20-Feb-1994

Revision History:

--*/


//
// Various definitions
//

typedef enum _PROVIDER_STATUS
{
    PROVIDER_STATUS_ONLINE,
    PROVIDER_STATUS_OFFLINE,
    PROVIDER_STATUS_PENDING_INIT,
    PROVIDER_STATUS_PENDING_REINIT,
    PROVIDER_STATUS_PENDING_LINE_CREATE
} PROVIDER_STATUS, *PPROVIDER_STATUS;


typedef NDIS_STATUS (*REQUEST_PROC)(NDIS_HANDLE, PNDIS_REQUEST);

typedef struct _DEVICE_INFO {
    ULONG       DeviceID;

    HTAPI_LINE  htLine;

    HDRV_LINE   hdLine;

} DEVICE_INFO, *PDEVICE_INFO;


typedef struct _PROVIDER_INFO
{
    struct _PROVIDER_INFO  *Next;

    PROVIDER_STATUS Status;

    NDIS_HANDLE     ProviderHandle;

    REQUEST_PROC    RequestProc;

    ULONG           ProviderID;

    ULONG           NumDevices;

    ULONG           DeviceIDBase;

    GUID            Guid;

    NDIS_WAN_MEDIUM_SUBTYPE MediaType;

    ULONG_PTR       TempID;

    ULONG           CreateCount;

    KEVENT          SyncEvent;

    PDEVICE_INFO    DeviceInfo;

} PROVIDER_INFO, *PPROVIDER_INFO;


typedef enum _NDISTAPI_STATUS
{
    NDISTAPI_STATUS_CONNECTED,
    NDISTAPI_STATUS_DISCONNECTED,
    NDISTAPI_STATUS_CONNECTING,
    NDISTAPI_STATUS_DISCONNECTING

} NDISTAPI_STATUS, *PNDISTAPI_STATUS;


typedef struct _KMDD_DEVICE_EXTENSION
{
    //
    // Pointer to a list of registered providers. (Some may actually
    // not be currently registered, but they were at one point so we've
    // saved a placeholder for them should they come back online at some
    // point.)
    //

    PPROVIDER_INFO  Providers;

    //
    // Whether TAPI has the the connection wrapper open
    //
    NDISTAPI_STATUS Status;

    ULONG           RefCount;
    //
    // Pointer to the NdisTapi device object
    //
    PDEVICE_OBJECT  DeviceObject;

    //
    // BaseID
    //
    ULONG   ProviderBaseID;

    //
    // The number of line devices we told told TAPI we supported when
    // it opened us (some of which may not actually be online at any
    // given time)
    //

    ULONG           NdisTapiNumDevices;

    //
    // Whether we have an outstanding provider init request
    //
    ULONG           Flags;
#define PENDING_LINECREATE      0x00000001
#define CLEANUP_INITIATED       0x00000002
#define EVENTIRP_CANCELED       0x00000004
#define REQUESTIRP_CANCELED     0x00000008
#define DUPLICATE_EVENTIRP      0x00000010
#define CANCELIRP_NOTFOUND      0x00000020

    //
    // Count of irps canceled through the cancel routine or
    // cleanup routine
    //
    ULONG           IrpsCanceledCount;

    //
    // Count of irps missing when a request is completed by
    // the underlying miniport
    //
    ULONG           MissingRequests;

    //
    // Used to key irp request queue
    //
    ULONG           ulRequestID;

    //
    // Value return to provider for next NEWCALL msg
    //

    ULONG           htCall;

    //
    // Outstanding get-events request
    //

    PIRP            EventsRequestIrp;

    //
    // List of events waiting for service by user-mode
    //
    LIST_ENTRY      ProviderEventList;
    ULONG           EventCount;         // Number of events in queue

    //
    // List of requests sent to the providers
    //
    LIST_ENTRY      ProviderRequestList;
    ULONG           RequestCount;       // Number of requests in queue

    PFILE_OBJECT    NCPAFileObject;

    //
    // Synchronizes access to the device extension following fields
    //
    KSPIN_LOCK      SpinLock;

} KMDD_DEVICE_EXTENSION, *PKMDD_DEVICE_EXTENSION;


typedef struct _PROVIDER_EVENT {
    //
    // List linkage
    //
    LIST_ENTRY  Linkage;

    //
    // Event
    //
    NDIS_TAPI_EVENT Event;

}PROVIDER_EVENT, *PPROVIDER_EVENT;

typedef struct _PROVIDER_REQUEST
{
    LIST_ENTRY      Linkage;        // Link into providerrequest list
                                    // ASSUMED to be first member!!!!
    PIRP            Irp;            // Original IRP
    PPROVIDER_INFO  Provider;       // Provider this is destined for
    ULONG           RequestID;      // unique identifier for request
    ULONG           Flags;          //
#define INTERNAL_REQUEST    0x00000001
    PVOID           Alignment1;
    NDIS_REQUEST    NdisRequest;    // NDIS_REQUEST storage
    PVOID           Alignment2;
    ULONG           Data[1];        // This field is a placeholder for an 
                                    // NDIS_TAPI_XXX structure, the first 
                                    // ULONG of which is always a request ID.
} PROVIDER_REQUEST, *PPROVIDER_REQUEST;


//
// Our global device extension
//

PKMDD_DEVICE_EXTENSION DeviceExtension;



#if DBG

//
// A var which determines the verboseness of the msgs printed by DBGOUT()
//
//

LONG NdisTapiDebugLevel = 0;

//
// DbgPrint wrapper
//

#define DBGOUT(arg) DbgPrt arg

#else

#define DBGOUT(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\compress.h ===
//************************************************************************
//            Microsoft Corporation
//          Copyright(c) Microsoft Corp., 1994
//
//
//  Revision history:
//  5/5/94        Created           gurdeep
//
//  This file uses 4 space tabs
//************************************************************************

#ifdef COMP_12K
#define HISTORY_SIZE        16000
#else
#define HISTORY_SIZE        (8192U) // Maximum back-pointer value, also used
#endif

#define HISTORY_MAX     (HISTORY_SIZE -1) // Maximum back-pointer value, also used

#define HASH_TABLE_SIZE     4096

#define MAX_BACK_PTR        8511

#define MAX_COMPRESSFRAME_SIZE 1600

struct SendContext {

    UCHAR   History [HISTORY_SIZE+1] ;

    int     CurrentIndex ;   // how far into the history buffer we are

    PUCHAR  ValidHistory ;   // how much of history is valid

//    UCHAR   CompressBuffer[MAX_COMPRESSFRAME_SIZE] ;

    USHORT  HashTable[HASH_TABLE_SIZE];

} ;

typedef struct SendContext SendContext ;


struct RecvContext {

    UCHAR     History [HISTORY_SIZE+1] ;

#if DBG

#define DEBUG_FENCE_VALUE   0xABABABAB
    ULONG       DebugFence;

#endif

    UCHAR     *CurrentPtr ;  // how far into the history buffer we are
} ;

typedef struct RecvContext RecvContext ;


// Prototypes
//
UCHAR
compress (
    UCHAR   *CurrentBuffer,
    UCHAR   *CompOutBuffer,
    ULONG *CurrentLength,
    SendContext *context);

//UCHAR
//compress (
//       UCHAR  *CurrentBuffer,
//       ULONG *CurrentLength,
//       SendContext *context);

int
decompress (
    UCHAR *inbuf,
    int inlen,
    int start,
    UCHAR **output,
    int *outlen,
    RecvContext *context) ;

void getcontextsizes (long *, long *) ;

void initsendcontext (SendContext *) ;

void initrecvcontext (RecvContext *) ;

VOID
GetStartKeyFromSHA(
    PCRYPTO_INFO    CryptoInfo,
    PUCHAR  Challenge
    );

VOID
GetNewKeyFromSHA(
    PCRYPTO_INFO    CryptoInfo
    );

VOID
GetMasterKey(
    PCRYPTO_INFO    CryptoInfo,
    PUCHAR          NTResponse
    );

VOID
GetAsymetricStartKey(
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    );

//
// Other defines
//

#define COMPRESSION_PADDING 4

#define PACKET_FLUSHED      0x80
#define PACKET_AT_FRONT     0x40
#define PACKET_COMPRESSED   0x20
#define PACKET_ENCRYPTED    0x10


/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#define A_SHA_DIGEST_LEN 20

typedef struct {
  ULONG state[5];                                           /* state (ABCDE) */
  ULONG count[2];                              /* number of UCHARs, msb first */
  unsigned char buffer[64];                                  /* input buffer */
} A_SHA_COMM_CTX;

typedef void (A_SHA_TRANSFORM) (ULONG [5], unsigned char [64]);

void A_SHAInitCommon (A_SHA_COMM_CTX *);
void A_SHAUpdateCommon(A_SHA_COMM_CTX *, UCHAR *, ULONG, A_SHA_TRANSFORM *);
void A_SHAFinalCommon(A_SHA_COMM_CTX *, UCHAR[A_SHA_DIGEST_LEN],
              A_SHA_TRANSFORM *);

VOID ByteReverse(UNALIGNED ULONG* Out, ULONG* In, ULONG Count);

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    ULONG       FinishFlag;
    UCHAR       HashVal[A_SHA_DIGEST_LEN];
    A_SHA_COMM_CTX  commonContext;
} A_SHA_CTX;

void A_SHAInit(A_SHA_CTX *);
void A_SHAUpdate(A_SHA_CTX *, unsigned char *, unsigned int);
void A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif


/* F, G, H and I are basic SHA functions.
 */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) ((x) ^ (y) ^ (z))
#define H(x, y, z) (((x) & (y)) | ((x) & (z)) | ((y) & (z)))
#define I(x, y, z) ((x) ^ (y) ^ (z))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
 */
#define ROUND(a, b, c, d, e, x, F, k) { \
    (e) += ROTATE_LEFT ((a), 5) + F ((b), (c), (d)) + (x) + k; \
    (b) = ROTATE_LEFT ((b), 30); \
  }
#define FF(a, b, c, d, e, x) ROUND (a, b, c, d, e, x, F, 0x5a827999);
#define GG(a, b, c, d, e, x) ROUND (a, b, c, d, e, x, G, 0x6ed9eba1);
#define HH(a, b, c, d, e, x) ROUND (a, b, c, d, e, x, H, 0x8f1bbcdc);
#define II(a, b, c, d, e, x) ROUND (a, b, c, d, e, x, I, 0xca62c1d6);

void SHATransform(ULONG [5], unsigned char [64]);
void SHAExpand(ULONG [80]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\global.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Global.h

Abstract:

    This file contains global structures for the NdisWan driver.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#ifndef _NDISWAN_GLOBAL_
#define _NDISWAN_GLOBAL_

extern NDISWANCB    NdisWanCB;                  // Global ndiswan control block

extern WAN_GLOBAL_LIST  MiniportCBList;         // List of NdisWan MiniportCB's

extern WAN_GLOBAL_LIST  OpenCBList;             // List of WAN Miniport structures

extern WAN_GLOBAL_LIST  ThresholdEventQueue;    // Queue to hold threshold events

extern IO_RECV_LIST    IoRecvList;

extern WAN_GLOBAL_LIST  TransformDrvList;

extern WAN_GLOBAL_LIST_EX   BonDWorkList;

extern WAN_GLOBAL_LIST_EX   DeferredWorkList;

#ifndef USE_QOS_WORKER
extern WAN_GLOBAL_LIST_EX  QoSWorkList;            // List of bundlecb's with QOS work
#endif

extern POOLDESC_LIST    PacketPoolList;             // List of free packet descs/ndispackets

extern NPAGED_LOOKASIDE_LIST    BundleCBList;       // List of free BundleCBs
    
extern NPAGED_LOOKASIDE_LIST    LinkProtoCBList;        // List of free LinkCBs
    
extern NPAGED_LOOKASIDE_LIST   SmallDataDescList;  // List of free small data descs
extern NPAGED_LOOKASIDE_LIST   LargeDataDescList;  // List of free small data descs

extern NPAGED_LOOKASIDE_LIST    WanRequestList;     // List of free WanRequest descs
    
extern NPAGED_LOOKASIDE_LIST    AfSapVcCBList;      // List of free protosapcb's

#if DBG
extern NPAGED_LOOKASIDE_LIST    DbgPacketDescList;
extern UCHAR                    reA[1024];
extern UCHAR                    LastIrpAction;
extern ULONG                    reI;
extern LIST_ENTRY               WanTrcList;
extern ULONG                    WanTrcCount;
#endif

extern PCONNECTION_TABLE    ConnectionTable;    // Pointer to connection table

extern PPROTOCOL_INFO_TABLE ProtocolInfoTable;  // Pointer to the PPP/Protocol value lookup table

extern NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress;

extern ULONG    glDebugLevel;                   // Trace Level values 0 - 10 (10 verbose)
extern ULONG    glDebugMask;                    // Trace bit mask
extern ULONG    glSendQueueDepth;               // # of seconds of send queue buffering
extern ULONG    glMaxMTU;                       // Maximum MTU of all protocols
extern ULONG    glMRU;                          // Maximum recv for a link
extern ULONG    glMRRU;                         // Maximum reconstructed recv for a bundle
extern ULONG    glLargeDataBufferSize;          // Size of databuffer
extern ULONG    glSmallDataBufferSize;          // Size of databuffer
extern ULONG    glTunnelMTU;                    // MTU for VPN's
extern ULONG    glMinFragSize;
extern ULONG    glMaxFragSize;
extern ULONG    glMinLinkBandwidth;
extern BOOLEAN  gbSniffLink;
extern BOOLEAN  gbDumpRecv;
extern BOOLEAN  gbHistoryless;
extern BOOLEAN  gbAtmUseLLCOnSVC;
extern BOOLEAN  gbAtmUseLLCOnPVC;
extern ULONG    glSendCount;
extern ULONG    glSendCompleteCount;
extern ULONG    glPacketPoolCount;
extern ULONG    glPacketPoolOverflow;
extern ULONG    glProtocolMaxSendPackets;
extern ULONG    glLinkCount;
extern ULONG    glConnectCount;
extern ULONG    glCachedKeyCount;
extern ULONG    glMaxOutOfOrderDepth;
extern PVOID    hSystemState;
extern BOOLEAN  gbIGMPIdle;
extern NDIS_RW_LOCK ConnTableLock;

#endif  // _NDISWAN_GLOBAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\isdn.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

	isdn.h

Abstract:

	This module defines the structures, macros, and manifests available
	to ISDN aware components.

Author:

	Tony Bell - tonybe@microsoft.com

Revision History:

	Initial Version - January 1997

--*/

#ifndef _ISDN_H
#define _ISDN_H

#endif

//
// Define Q.931 SAP.  This is registered by clients that want to
// accept incoming calls from a call manager that has registered
// the Q.931 address family
//

//
// Define Q.931 CO_CALL_PARAMETERS
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\indicate.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Indicate.c

Abstract:

    This file contains procedures to handle indications from the
    WAN Miniport drivers.


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#define __FILE_SIG__    INDICATE_FILESIG

VOID
NdisWanLineUpIndication(
    POPENCB     OpenCB,
    PUCHAR      Buffer,
    ULONG       BufferSize
    )
/*++

Routine Name:

    NdisWanLineupIndication

Routine Description:

    This routine is called when a WAN Miniport driver has a new connetion
    become active or when the status of an active connection changes.  If
    this is a new connection the routine creates a LinkCB, and a BundleCB
    for the new connection.  If this is for an already active connetion the
    connection info is updated.

Arguments:

Return Values:

    None

--*/
{
    PLINKCB     LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;
    NDIS_STATUS Status;
    PNDIS_MAC_LINE_UP   LineUpInfo = (PNDIS_MAC_LINE_UP)Buffer;
    BOOLEAN             EmptyList;

    if (BufferSize < sizeof(NDIS_MAC_LINE_UP)) {
        return;
    }

    //
    // Is this for a new connetion?
    //
    if (LineUpInfo->NdisLinkContext == NULL) {

        //
        // This is a new connection!
        //

        //
        // Get a linkcb
        //
        LinkCB = NdisWanAllocateLinkCB(OpenCB, LineUpInfo->SendWindow);

        if (LinkCB == NULL) {

            //
            // Error getting LinkCB!
            //

            return;
            
        }

        LinkCB->NdisLinkHandle = LineUpInfo->NdisLinkHandle;
        LinkCB->ConnectionWrapperID = LineUpInfo->ConnectionWrapperID;

        //
        // Get a bundlecb
        //
        BundleCB = NdisWanAllocateBundleCB();

        if (BundleCB == NULL) {

            //
            // Error getting BundleCB!
            //

            NdisWanFreeLinkCB(LinkCB);

            return;
        }

        AcquireBundleLock(BundleCB);

        //
        // Copy LineUpInfo to Link LineUpInfo
        //
/*      NdisMoveMemory((PUCHAR)&LinkCB->LineUpInfo,
                       (PUCHAR)LineUpInfo,
                       sizeof(NDIS_MAC_LINE_UP));
*/
        //
        // If a linkspeed is not reported we are
        // assuming 28.8K as the slowest...
        //
        if (LineUpInfo->LinkSpeed == 0) {
            LineUpInfo->LinkSpeed = 288;
        }

        //
        // Take 1/100bps to Bps without rolling over
        //
        {
            ULONGLONG   temp;
            ULONG       value;

            temp = LineUpInfo->LinkSpeed;
            temp *= 100;
            temp /= 8;

            //
            // Check for rollover
            //
            value = (ULONG)temp;

            if (value == 0) {
                value = 0xFFFFFFFF/8;
            }

            LinkCB->SFlowSpec.TokenRate =
            LinkCB->SFlowSpec.PeakBandwidth =
            LinkCB->RFlowSpec.TokenRate =
            LinkCB->RFlowSpec.PeakBandwidth = (ULONG)value;
        }

        LinkCB->SFlowSpec.MaxSduSize =
            (OpenCB->WanInfo.MaxFrameSize > glMaxMTU) ?
            glMaxMTU : OpenCB->WanInfo.MaxFrameSize;

        LinkCB->RFlowSpec.MaxSduSize = glMRRU;

        //
        // Add LinkCB to BundleCB
        //
        AddLinkToBundle(BundleCB, LinkCB);

        ReleaseBundleLock(BundleCB);

        //
        // Place BundleCB in active connection table
        //
        if (NULL == InsertBundleInConnectionTable(BundleCB)) {
            //
            // Error inserting link in ConnectionTable
            //
            RemoveLinkFromBundle(BundleCB, LinkCB, FALSE);
            NdisWanFreeLinkCB(LinkCB);
            NdisWanFreeBundleCB(BundleCB);

            return;
        }
    
        //
        // Place LinkCB in active connection table
        //
        if (NULL == InsertLinkInConnectionTable(LinkCB)) {
            //
            // Error inserting bundle in connectiontable
            //
            RemoveLinkFromBundle(BundleCB, LinkCB, FALSE);
            NdisWanFreeLinkCB(LinkCB);
            NdisWanFreeBundleCB(BundleCB);
    
            return;
        }

        LineUpInfo->NdisLinkContext = LinkCB->hLinkHandle;

    } else {

        do {

            //
            // This is an already existing connetion
            //
            if (!AreLinkAndBundleValid(LineUpInfo->NdisLinkContext,
                                       TRUE,
                                       &LinkCB,
                                       &BundleCB)) {
#if DBG
                DbgPrint("NDISWAN: LineUp on unknown LinkContext %x\n",
                    LineUpInfo->NdisLinkContext);
                DbgBreakPoint();
#endif
                break;
            }

            AcquireBundleLock(BundleCB);
    
            if (LineUpInfo->LinkSpeed == 0) {
                LineUpInfo->LinkSpeed = 288;
            }
    
            //
            // Take 1/100bps to Bps
            //
            {
                ULONGLONG   temp;
        
                temp = LineUpInfo->LinkSpeed;
                temp *= 100;
                temp /= 8;
        
                LinkCB->SFlowSpec.TokenRate =
                LinkCB->SFlowSpec.PeakBandwidth =
                LinkCB->RFlowSpec.TokenRate =
                LinkCB->RFlowSpec.PeakBandwidth = (ULONG)temp;
            }
    
            LinkCB->SendWindow = (LineUpInfo->SendWindow > OpenCB->WanInfo.MaxTransmit ||
                                  LineUpInfo->SendWindow == 0) ?
                                  OpenCB->WanInfo.MaxTransmit : LineUpInfo->SendWindow;

            //
            // If the new sendwindow is set smaller then the
            // current # of outstanding frames then we have to
            // close the sendwindow for the link and reduce the
            // number of sending links that the bundle sees.
            //
            // If the new sendwindow is set larger then the
            // current # of outstanding frames and the sendwindow
            // is currently closed, we need to open the sendwindow
            // and increase the number of sending links that the
            // bundle sees.
            //
            if (LinkCB->LinkActive) {
                if (LinkCB->SendWindow <= LinkCB->OutstandingFrames) {
                    if (LinkCB->SendWindowOpen) {
                        LinkCB->SendWindowOpen = FALSE;
                        BundleCB->SendingLinks -= 1;
                    }
                } else if (!LinkCB->SendWindowOpen) {
                    LinkCB->SendWindowOpen = TRUE;
                    BundleCB->SendingLinks += 1;
                }
            }

            //
            // Update BundleCB info
            //
            UpdateBundleInfo(BundleCB);
    
            //
            // Deref's for the ref's applied when we mapped the
            // context into the control blocks
            //
            DEREF_BUNDLECB_LOCKED(BundleCB);
            DEREF_LINKCB(LinkCB);

        } while ( 0 );
    }
}


VOID
NdisWanLineDownIndication(
    POPENCB     OpenCB,
    PUCHAR      Buffer,
    ULONG       BufferSize
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PNDIS_MAC_LINE_DOWN LineDownInfo = (PNDIS_MAC_LINE_DOWN)Buffer;
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;
    PRECV_DESC  RecvDesc;
    ULONG       i;

    if (!AreLinkAndBundleValid(LineDownInfo->NdisLinkContext,
                               TRUE,
                               &LinkCB,
                               &BundleCB)) {
#if DBG
        DbgPrint("NDISWAN: LineDown on unknown LinkContext %x\n",
            LineDownInfo->NdisLinkContext);
        DbgBreakPoint();
#endif

        return;
    }

    //
    // Link is now going down
    //
    NdisAcquireSpinLock(&LinkCB->Lock);

    LinkCB->State = LINK_GOING_DOWN;

    //
    // Deref for the ref applied in AreLinkAndBundleValid.  We don't
    // have to go through the full deref code as we know that the
    // ref applied at lineup will hold the block around.
    //
    LinkCB->RefCount--;

    NdisReleaseSpinLock(&LinkCB->Lock);

    NdisAcquireSpinLock(&IoRecvList.Lock);

    RecvDesc = (PRECV_DESC)IoRecvList.DescList.Flink;

    while ((PVOID)RecvDesc != (PVOID)&IoRecvList.DescList) {
        PRECV_DESC  Next;

        Next = (PRECV_DESC)RecvDesc->Linkage.Flink;

        if (RecvDesc->LinkCB == LinkCB) {

            RemoveEntryList(&RecvDesc->Linkage);

            LinkCB->RecvDescCount--;

            IoRecvList.ulDescCount--;

            NdisWanFreeRecvDesc(RecvDesc);
        }

        RecvDesc = Next;
    }

    NdisReleaseSpinLock(&IoRecvList.Lock);

    //
    // Flush the Bundle's fragment send queues that
    // have sends pending on this link
    //
    AcquireBundleLock(BundleCB);

    for (i = 0; i < MAX_MCML; i++) {
        PSEND_DESC SendDesc;
        PSEND_FRAG_INFO FragInfo;

        FragInfo = &BundleCB->SendFragInfo[i];

        SendDesc = (PSEND_DESC)FragInfo->FragQueue.Flink;

        while ((PVOID)SendDesc != (PVOID)&FragInfo->FragQueue) {

            if (SendDesc->LinkCB == LinkCB) {
                PSEND_DESC  NextSendDesc;

                NextSendDesc = (PSEND_DESC)SendDesc->Linkage.Flink;

                RemoveEntryList(&SendDesc->Linkage);

                FragInfo->FragQueueDepth--;

                (*LinkCB->SendHandler)(SendDesc);

                SendDesc = NextSendDesc;
            } else {
                SendDesc = (PSEND_DESC)SendDesc->Linkage.Flink;
            }
        }
    }

    UpdateBundleInfo(BundleCB);

    ReleaseBundleLock(BundleCB);

    //
    // For the ref from the lineup
    //
    DEREF_LINKCB(LinkCB);

    //
    // Deref for the ref applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB(BundleCB);
}


VOID
NdisWanFragmentIndication(
    POPENCB OpenCB,
    PUCHAR  Buffer,
    ULONG   BufferSize
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       Errors;
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;

    PNDIS_MAC_FRAGMENT FragmentInfo =
        (PNDIS_MAC_FRAGMENT)Buffer;

    if (!AreLinkAndBundleValid(FragmentInfo->NdisLinkContext,
                               TRUE,
                               &LinkCB,
                               &BundleCB)) {
#if DBG
    DbgPrint("NDISWAN: Status indication after link has gone down LinkContext %x\n",
                     FragmentInfo->NdisLinkContext);
            DbgBreakPoint();
#endif
        return;
    }

    Errors = FragmentInfo->Errors;

    AcquireBundleLock(BundleCB);

    if (Errors & WAN_ERROR_CRC) {
        LinkCB->Stats.CRCErrors++;
        BundleCB->Stats.CRCErrors++;
    }

    if (Errors & WAN_ERROR_FRAMING) {
        LinkCB->Stats.FramingErrors++;
        BundleCB->Stats.FramingErrors++;
    }

    if (Errors & WAN_ERROR_HARDWAREOVERRUN) {
        LinkCB->Stats.SerialOverrunErrors++;
        BundleCB->Stats.SerialOverrunErrors++;
    }

    if (Errors & WAN_ERROR_BUFFEROVERRUN) {
        LinkCB->Stats.BufferOverrunErrors++;
        BundleCB->Stats.BufferOverrunErrors++;
    }

    if (Errors & WAN_ERROR_TIMEOUT) {
        LinkCB->Stats.TimeoutErrors++;
        BundleCB->Stats.TimeoutErrors++;
    }

    if (Errors & WAN_ERROR_ALIGNMENT) {
        LinkCB->Stats.AlignmentErrors++;
        BundleCB->Stats.AlignmentErrors++;
    }

    //
    // Deref's for the ref's applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);
}

VOID
NdisCoWanFragmentIndication(
    PLINKCB     LinkCB,
    PBUNDLECB   BundleCB,
    PUCHAR      Buffer,
    ULONG       BufferSize
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   Errors;
    PNDIS_WAN_CO_FRAGMENT FragmentInfo =
        (PNDIS_WAN_CO_FRAGMENT)Buffer;

    Errors = FragmentInfo->Errors;

    AcquireBundleLock(BundleCB);

    if (Errors & WAN_ERROR_CRC) {
        LinkCB->Stats.CRCErrors++;
        BundleCB->Stats.CRCErrors++;
    }

    if (Errors & WAN_ERROR_FRAMING) {
        LinkCB->Stats.FramingErrors++;
        BundleCB->Stats.FramingErrors++;
    }

    if (Errors & WAN_ERROR_HARDWAREOVERRUN) {
        LinkCB->Stats.SerialOverrunErrors++;
        BundleCB->Stats.SerialOverrunErrors++;
    }

    if (Errors & WAN_ERROR_BUFFEROVERRUN) {
        LinkCB->Stats.BufferOverrunErrors++;
        BundleCB->Stats.BufferOverrunErrors++;
    }

    if (Errors & WAN_ERROR_TIMEOUT) {
        LinkCB->Stats.TimeoutErrors++;
        BundleCB->Stats.TimeoutErrors++;
    }

    if (Errors & WAN_ERROR_ALIGNMENT) {
        LinkCB->Stats.AlignmentErrors++;
        BundleCB->Stats.AlignmentErrors++;
    }

    ReleaseBundleLock(BundleCB);
}

VOID
NdisCoWanLinkParamChange(
    PLINKCB     LinkCB,
    PBUNDLECB   BundleCB,
    PUCHAR      Buffer,
    ULONG       BufferSize
    )
{
    PWAN_CO_LINKPARAMS  LinkParams =
        (PWAN_CO_LINKPARAMS)Buffer;

    if (BufferSize < sizeof(WAN_CO_LINKPARAMS)) {
        return;
    }

    AcquireBundleLock(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_INDICATE,
        ("LinkParamChange: SendWindow %d XmitSpeed %d RecvSpeed %d",
        LinkParams->SendWindow, LinkParams->TransmitSpeed, LinkParams->ReceiveSpeed));

    LinkCB->SendWindow = LinkParams->SendWindow;

    //
    // If the new sendwindow is set smaller then the
    // current # of outstanding frames then we have to
    // close the sendwindow for the link and reduce the
    // number of sending links that the bundle sees.
    //
    // If the new sendwindow is set larger then the
    // current # of outstanding frames and the sendwindow
    // is currently closed, we need to open the sendwindow
    // and increase the number of sending links that the
    // bundle sees.
    //
    if (LinkCB->LinkActive) {
        if (LinkCB->SendWindow <= LinkCB->OutstandingFrames) {
            if (LinkCB->SendWindowOpen) {
                LinkCB->SendWindowOpen = FALSE;
                BundleCB->SendingLinks -= 1;
            }
        } else if (!LinkCB->SendWindowOpen) {
            LinkCB->SendWindowOpen = TRUE;
            BundleCB->SendingLinks += 1;
        }
    }

    LinkCB->SFlowSpec.PeakBandwidth =
        LinkParams->TransmitSpeed;

    LinkCB->RFlowSpec.PeakBandwidth =
        LinkParams->ReceiveSpeed;

    if (LinkCB->SFlowSpec.PeakBandwidth == 0) {
        LinkCB->SFlowSpec.PeakBandwidth = 28800 / 8;
    }

    if (LinkCB->RFlowSpec.PeakBandwidth == 0) {
        LinkCB->RFlowSpec.PeakBandwidth = LinkCB->SFlowSpec.PeakBandwidth;
    }

    UpdateBundleInfo(BundleCB);

    ReleaseBundleLock(BundleCB);
}

VOID
UpdateBundleInfo(
    PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

    Expects the BundleCB->Lock to be held!

Arguments:

Return Values:

--*/
{
    PLINKCB LinkCB;
    ULONG       SlowestSSpeed, FastestSSpeed;
    ULONG       SlowestRSpeed, FastestRSpeed;
    PPROTOCOLCB ProtocolCB;
    PFLOWSPEC   BSFlowSpec, BRFlowSpec;
    ULONG       i;
    ULONG       SmallestSDU;
    LIST_ENTRY  TempList;

    BSFlowSpec = &BundleCB->SFlowSpec;
    BRFlowSpec = &BundleCB->RFlowSpec;

    SlowestSSpeed = FastestSSpeed = 0;
    SlowestRSpeed = FastestRSpeed = 0;
    SmallestSDU = 0;
    BSFlowSpec->TokenRate = 0;
    BSFlowSpec->PeakBandwidth = 0;
    BRFlowSpec->TokenRate = 0;
    BRFlowSpec->PeakBandwidth = 0;
    BundleCB->SendWindow = 0;
    BundleCB->State = BUNDLE_GOING_DOWN;

    if (BundleCB->ulLinkCBCount != 0) {
        //
        // Currently only using the SendSide FastestSpeed so
        // just get it from the head of the list.
        //
        FastestSSpeed =
            ((PLINKCB)(BundleCB->LinkCBList.Flink))->SFlowSpec.PeakBandwidth;
        SmallestSDU =
            ((PLINKCB)(BundleCB->LinkCBList.Flink))->SFlowSpec.MaxSduSize;

        //
        // If a link has a speed that is less than the minimum
        // link bandwidth (% of the fastests link speed) it is flaged
        // as not sending and does not count as a sending link.
        //

        BundleCB->SendingLinks = 0;
        BundleCB->SendResources = 0;

        for (LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
            (PVOID)LinkCB != (PVOID)&BundleCB->LinkCBList;
            LinkCB = (PLINKCB)LinkCB->Linkage.Flink) {
            ULONGLONG   n, d, temp;
            PFLOWSPEC   LSFlowSpec = &LinkCB->SFlowSpec;
            PFLOWSPEC   LRFlowSpec = &LinkCB->RFlowSpec;

            if (LinkCB->State == LINK_UP) {
                BundleCB->State = BUNDLE_UP;
            }

            n = LSFlowSpec->PeakBandwidth;
            n *= 100;
            d = FastestSSpeed;
            temp = n/d;


            LinkCB->LinkActive = ((ULONG)temp > glMinLinkBandwidth) ?
                TRUE : FALSE;

            if (LinkCB->LinkActive) {

                BundleCB->SendResources += LinkCB->SendResources;
                BundleCB->SendWindow += LinkCB->SendWindow;
                if (LinkCB->SendWindowOpen) {
                    BundleCB->SendingLinks += 1;
                }

                BSFlowSpec->PeakBandwidth += LSFlowSpec->PeakBandwidth;
                BRFlowSpec->PeakBandwidth += LRFlowSpec->PeakBandwidth;
            }

            if (LinkCB->SFlowSpec.MaxSduSize < SmallestSDU) {
                SmallestSDU = LinkCB->SFlowSpec.MaxSduSize;
            }
        }

        BundleCB->SFlowSpec.MaxSduSize = SmallestSDU;

        //
        // Now calculate the % bandwidth that each links contributes to the
        // bundle.  If a link has a speed that is less than the minimum
        // link bandwidth (% of the fastests link speed) it is flaged
        // as not sending and does not count as a sending link.
        //
        for (LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
            (PVOID)LinkCB != (PVOID)&BundleCB->LinkCBList;
            LinkCB = (PLINKCB)LinkCB->Linkage.Flink) {
            ULONGLONG   n, d, temp;
            PFLOWSPEC   LSFlowSpec = &LinkCB->SFlowSpec;
            PFLOWSPEC   LRFlowSpec = &LinkCB->RFlowSpec;

            //
            // Do sending side
            //
            n = LSFlowSpec->PeakBandwidth;
            n *= 100;
            d = BSFlowSpec->PeakBandwidth;
            temp = n/d;

            LinkCB->SBandwidth = (temp > 0) ? (ULONG)temp : 1;

            //
            // Do receiving side
            //
            n = LRFlowSpec->PeakBandwidth;
            n *= 100;
            d = BRFlowSpec->PeakBandwidth;
            temp = n/d;

            LinkCB->RBandwidth = (temp > 0) ? (ULONG)temp : 1;

        }

        BundleCB->NextLinkToXmit = 
            (PLINKCB)BundleCB->LinkCBList.Flink;

        //
        // Update the BandwidthOnDemand information
        //
        if (BundleCB->Flags & BOND_ENABLED) {
            PBOND_INFO  BonDInfo;
            ULONGLONG   SecondsInSamplePeriod;
            ULONGLONG   BytesPerSecond;
            ULONGLONG   BytesInSamplePeriod;
            ULONGLONG   temp;

            BonDInfo = BundleCB->SUpperBonDInfo;

            SecondsInSamplePeriod =
                BonDInfo->ulSecondsInSamplePeriod;

            BytesPerSecond =
                BundleCB->SFlowSpec.PeakBandwidth;

            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;

            temp = BonDInfo->usPercentBandwidth;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            BonDInfo = BundleCB->SLowerBonDInfo;

            SecondsInSamplePeriod =
                BonDInfo->ulSecondsInSamplePeriod;

            BytesPerSecond =
                BundleCB->SFlowSpec.PeakBandwidth;

            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;

            temp = BonDInfo->usPercentBandwidth;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            BonDInfo = BundleCB->RUpperBonDInfo;

            SecondsInSamplePeriod =
                BonDInfo->ulSecondsInSamplePeriod;

            BytesPerSecond =
                BundleCB->RFlowSpec.PeakBandwidth;

            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;

            temp = BonDInfo->usPercentBandwidth;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            BonDInfo = BundleCB->RLowerBonDInfo;

            SecondsInSamplePeriod =
                BonDInfo->ulSecondsInSamplePeriod;

            BytesPerSecond =
                BundleCB->RFlowSpec.PeakBandwidth;

            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;

            temp = BonDInfo->usPercentBandwidth;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;
        }
    }

    //
    // We need to do a new lineup to all routed protocols
    //
    ProtocolCB = (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;

    InitializeListHead(&TempList);

    while ((PVOID)ProtocolCB != (PVOID)&BundleCB->ProtocolCBList) {

        REF_PROTOCOLCB(ProtocolCB);

        InsertHeadList(&TempList, &ProtocolCB->RefLinkage);

        ProtocolCB = 
            (PPROTOCOLCB)ProtocolCB->Linkage.Flink;
    }

    while (!IsListEmpty(&TempList)) {
        PLIST_ENTRY Entry;

        Entry =
            RemoveHeadList(&TempList);

        ProtocolCB = CONTAINING_RECORD(Entry, PROTOCOLCB, RefLinkage);

        if (BundleCB->State == BUNDLE_UP) {
            ReleaseBundleLock(BundleCB);

            DoLineUpToProtocol(ProtocolCB);

            AcquireBundleLock(BundleCB);
        } else {
            //
            // Our link count has gone to 0.  This means 
            // that we can not send any packets.  Flush the 
            // queues and don't accept any more sends from 
            // the transports.
            //
            FlushProtocolPacketQueue(ProtocolCB);
        }

        DEREF_PROTOCOLCB(ProtocolCB);
    }
}


VOID
AddLinkToBundle(
    IN  PBUNDLECB   BundleCB,
    IN  PLINKCB     LinkCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    UINT    Class;

    //
    // Insert the links so that they are ordered with the fastest
    // sending link at the head of the list
    //
    if (IsListEmpty(&BundleCB->LinkCBList) ||
        (LinkCB->SFlowSpec.PeakBandwidth >=
        ((PLINKCB)(BundleCB->LinkCBList.Flink))->SFlowSpec.PeakBandwidth)) {

        //
        // The list was either empty or this link is a bigger pipe
        // than anything else on the bundle
        //
        InsertHeadList(&BundleCB->LinkCBList, &LinkCB->Linkage);

    } else if ((LinkCB->SFlowSpec.PeakBandwidth <=
        ((PLINKCB)(BundleCB->LinkCBList.Blink))->SFlowSpec.PeakBandwidth)) {

        //
        // This link is a smaller pipe than anything else
        // on the bundle.
        //
        InsertTailList(&(BundleCB->LinkCBList), &(LinkCB->Linkage));

    } else {
        PLINKCB Current, Next;
        BOOLEAN Inserted = FALSE;

        //
        // We need to find where this link belongs in the list!
        //
        Current = (PLINKCB)BundleCB->LinkCBList.Flink;
        Next = (PLINKCB)Current->Linkage.Flink;

        while ((PVOID)Next != (PVOID)&BundleCB->LinkCBList) {

            if (LinkCB->SFlowSpec.PeakBandwidth <= Current->SFlowSpec.PeakBandwidth &&
                LinkCB->SFlowSpec.PeakBandwidth >= Next->SFlowSpec.PeakBandwidth) {

                LinkCB->Linkage.Flink = (PLIST_ENTRY)Next;
                LinkCB->Linkage.Blink = (PLIST_ENTRY)Current;

                Current->Linkage.Flink =
                Next->Linkage.Blink =
                    (PLIST_ENTRY)LinkCB;
                
                Inserted = TRUE;
                break;
            }

            Current = Next;
            Next = (PLINKCB)Next->Linkage.Flink;
        }

        if (!Inserted) {
            InsertTailList(&(BundleCB->LinkCBList), &(LinkCB->Linkage));
        }
    }

    BundleCB->ulLinkCBCount++;

    LinkCB->BundleCB = BundleCB;

    for (Class = 0; Class < MAX_MCML; Class++) {
        PLINK_RECV_INFO     LinkRecvInfo;
        PBUNDLE_RECV_INFO   BundleRecvInfo;

        LinkRecvInfo = &LinkCB->RecvInfo[Class];
        BundleRecvInfo = &BundleCB->RecvInfo[Class];

        LinkRecvInfo->LastSeqNumber =
            BundleRecvInfo->MinSeqNumber;
    }

    //
    // Update BundleCB info
    //
    UpdateBundleInfo(BundleCB);

    REF_BUNDLECB(BundleCB);
}

VOID
RemoveLinkFromBundle(
    IN  PBUNDLECB   BundleCB,
    IN  PLINKCB     LinkCB,
    IN  BOOLEAN     Locked
    )
/*++

Routine Name:

Routine Description:

    Expects the BundleCB->Lock to be held!  Returns with the
    lock released!

Arguments:

Return Values:

--*/
{

    if (!Locked) {
        AcquireBundleLock(BundleCB);
    }

    //
    // Remove link from the bundle
    //
    RemoveEntryList(&LinkCB->Linkage);

    LinkCB->BundleCB = NULL;

    BundleCB->ulLinkCBCount--;
    BundleCB->SendingLinks--;

    //
    // Update BundleCB info
    //
    UpdateBundleInfo(BundleCB);

    //
    // Deref for ref applied when we added this linkcb to
    // the bundle
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\init.c ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This is the initialization file for the NdisWan driver.  This driver
    is a shim between the protocols, where it conforms to the NDIS 3.1/NDIS 5.0
    Miniport interface specs, and the miniport drivers, where it exports
    the NDIS 3.1 WAN Extensions for Miniports and NDIS 5.0 Call Manager/Miniport
    interfaces (it looks like a NDIS 3.1 protocol to NDIS 3.1 WAN Miniport drivers
    and a NDIS 5.0 client to NDIS 5.0 miniports).

Author:

    Tony Bell   (TonyBe) January 9, 1997

Environment:

    Kernel Mode

Revision History:

    TonyBe      01/09/97        Created

--*/


#include "wan.h"

#define __FILE_SIG__    INIT_FILESIG

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, NdisWanReadRegistry)
#pragma alloc_text(INIT, DoProtocolInit)
#pragma alloc_text(INIT, DoMiniportInit)
#endif

EXPORT
VOID
NdisTapiRegisterProvider(
    IN  NDIS_HANDLE,
    IN  PNDISTAPI_CHARACTERISTICS
    );

//
// We want to initialize all of the global variables now!
//

//
// Globals
//
NDISWANCB   NdisWanCB;                      // Global control block for NdisWan

WAN_GLOBAL_LIST MiniportCBList;             // List of NdisWan MiniportCB's

WAN_GLOBAL_LIST OpenCBList;                 // List of WAN Miniport structures

WAN_GLOBAL_LIST ThresholdEventQueue;        // Global thresholdevent queue

IO_RECV_LIST    IoRecvList;

WAN_GLOBAL_LIST TransformDrvList;

WAN_GLOBAL_LIST_EX  BonDWorkList;

WAN_GLOBAL_LIST_EX  DeferredWorkList;

POOLDESC_LIST   PacketPoolList;             // List of free packet descs/ndispackets

NPAGED_LOOKASIDE_LIST   BundleCBList;       // List of free BundleCBs

NPAGED_LOOKASIDE_LIST   LinkProtoCBList;    // List of free LinkCBs

NPAGED_LOOKASIDE_LIST   SmallDataDescList;  // List of free small data descs
NPAGED_LOOKASIDE_LIST   LargeDataDescList;  // List of free small data descs


NPAGED_LOOKASIDE_LIST   WanRequestList;     // List of free WanRequest descs

NPAGED_LOOKASIDE_LIST   AfSapVcCBList;      // List of free afsapcb's

#if DBG
NPAGED_LOOKASIDE_LIST   DbgPacketDescList;
UCHAR                   reA[1024] = {0};
UCHAR                   LastIrpAction;
ULONG                   reI = 0;
LIST_ENTRY              WanTrcList;
ULONG                   WanTrcCount;
#endif

ULONG   glDebugLevel;                   // Trace Level values 0 - 10 (10 verbose)
ULONG   glDebugMask;                    // Trace bit mask
ULONG   glSendQueueDepth;               // # of seconds of send queue buffering
ULONG   glMaxMTU = DEFAULT_MTU;         // Maximum MTU of all protocols
ULONG   glMRU;                          // Maximum recv for a link
ULONG   glMRRU;                         // Maximum reconstructed recv for a bundle
ULONG   glSmallDataBufferSize;          // Size of databuffer
ULONG   glLargeDataBufferSize;          // Size of databuffer
ULONG   glTunnelMTU;                    // MTU to be used over a VPN
ULONG   glMinFragSize;
ULONG   glMaxFragSize;
ULONG   glMinLinkBandwidth;
BOOLEAN gbSniffLink = FALSE;
BOOLEAN gbDumpRecv = FALSE;
BOOLEAN gbHistoryless = TRUE;
BOOLEAN gbIGMPIdle = TRUE;
BOOLEAN gbAtmUseLLCOnSVC = FALSE;
BOOLEAN gbAtmUseLLCOnPVC = FALSE;
ULONG   glSendCount = 0;
ULONG   glSendCompleteCount = 0;
ULONG   glPacketPoolCount;
ULONG   glPacketPoolOverflow;
ULONG   glProtocolMaxSendPackets;
ULONG   glLinkCount;
ULONG   glConnectCount;
ULONG   glCachedKeyCount = 16;
ULONG   glMaxOutOfOrderDepth = 128;
PVOID   hSystemState = NULL;
NDIS_RW_LOCK    ConnTableLock;

PCONNECTION_TABLE   ConnectionTable = NULL; // Pointer to connection table

PPROTOCOL_INFO_TABLE    ProtocolInfoTable = NULL; // Pointer to the PPP/Protocol lookup table

NDIS_PHYSICAL_ADDRESS   HighestAcceptableAddress = NDIS_PHYSICAL_ADDRESS_CONST(-1, -1);

#ifdef NT

VOID
NdisWanUnload(
    PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++
Routine Name:

    DriverEntry

Routine Description:

    This is the NT OS specific driver entry point.  It kicks off initialization
    for the driver.  We return from this routine only after NdisWan has installed
    itself as: a Miniport driver, a "transport" to the WAN Miniport drivers, and
    has been bound to the WAN Miniport drivers.

Arguments:

    DriverObject - NT OS specific Object
    RegistryPath - NT OS specific pointer to registry location for NdisWan

Return Values:

    STATUS_SUCCESS
    STATUS_FAILURE

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    NDIS_STRING NdisTapiName = NDIS_STRING_CONST("NdisTapi");

    NdisZeroMemory(&NdisWanCB, sizeof(NdisWanCB));

    glDebugLevel = DBG_CRITICAL_ERROR;
    glDebugMask = DBG_ALL;

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DriverEntry: Enter"));

    NdisMInitializeWrapper(&(NdisWanCB.NdisWrapperHandle),
                           DriverObject,
                           RegistryPath,
                           NULL);

    Status = NdisWanCreateProtocolInfoTable();

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                      ("NdisWanCreatePPPProtocolTable Failed! Status: 0x%x - %s",
                      Status, NdisWanGetNdisStatus(Status)));

        return (STATUS_UNSUCCESSFUL);
    }

    NdisWanReadRegistry(RegistryPath);

    //
    // Initialize globals
    //
    NdisAllocateSpinLock(&NdisWanCB.Lock);

    NdisWanCB.pDriverObject = DriverObject;

    NdisZeroMemory(&MiniportCBList, sizeof(WAN_GLOBAL_LIST));
    InitializeListHead(&(MiniportCBList.List));
    NdisAllocateSpinLock(&MiniportCBList.Lock);

    NdisZeroMemory(&OpenCBList, sizeof(WAN_GLOBAL_LIST));
    InitializeListHead(&(OpenCBList.List));
    NdisAllocateSpinLock(&OpenCBList.Lock);

    NdisZeroMemory(&ThresholdEventQueue, sizeof(WAN_GLOBAL_LIST));
    InitializeListHead(&(ThresholdEventQueue.List));
    NdisAllocateSpinLock(&ThresholdEventQueue.Lock);

    NdisZeroMemory(&PacketPoolList, sizeof(POOLDESC_LIST));
    InitializeListHead(&PacketPoolList.List);
    NdisAllocateSpinLock(&PacketPoolList.Lock);

    NdisZeroMemory(&IoRecvList, sizeof(IO_RECV_LIST));
    InitializeListHead(&IoRecvList.IrpList);
    InitializeListHead(&IoRecvList.DescList);
    NdisAllocateSpinLock(&IoRecvList.Lock);

    NdisZeroMemory(&TransformDrvList, sizeof(WAN_GLOBAL_LIST));
    InitializeListHead(&TransformDrvList.List);
    NdisAllocateSpinLock(&TransformDrvList.Lock);

    KeInitializeTimerEx(&IoRecvList.Timer, NotificationTimer);
    KeInitializeDpc(&IoRecvList.Dpc, IoRecvIrpWorker, NULL);

    NdisZeroMemory(&BonDWorkList, sizeof(WAN_GLOBAL_LIST_EX));
    InitializeListHead(&BonDWorkList.List);
    NdisAllocateSpinLock(&BonDWorkList.Lock);
    KeInitializeTimerEx(&BonDWorkList.Timer, NotificationTimer);
    KeInitializeDpc(&BonDWorkList.Dpc, BonDWorker, NULL);

    NdisZeroMemory(&DeferredWorkList, sizeof(WAN_GLOBAL_LIST_EX));
    InitializeListHead(&DeferredWorkList.List);
    NdisAllocateSpinLock(&DeferredWorkList.Lock);
    KeInitializeTimerEx(&DeferredWorkList.Timer, NotificationTimer);
    KeInitializeDpc(&DeferredWorkList.Dpc, DeferredWorker, NULL);

    //
    // Is depth used by the OS?
    //
    NdisInitializeNPagedLookasideList(&BundleCBList,
                                      NULL,
                                      NULL,
                                      0,
                                      BUNDLECB_SIZE,
                                      BUNDLECB_TAG,
                                      0);

    NdisInitializeNPagedLookasideList(&LinkProtoCBList,
                                      NULL,
                                      NULL,
                                      0,
                                      LINKPROTOCB_SIZE,
                                      LINKPROTOCB_TAG,
                                      0);

    //
    // Calculated from the following:
    // MAX_FRAME_SIZE + PROTOCOL_HEADER_LENGTH + sizeof(PVOID) + (MAX_FRAME_SIZE + 7)/8
    //
    {
        ULONG   Size = (glMaxMTU > glMRRU) ? glMaxMTU : glMRRU;

        glLargeDataBufferSize = 
            Size + PROTOCOL_HEADER_LENGTH + 
            sizeof(PVOID) + ((Size + 7)/8);
        glLargeDataBufferSize &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        glSmallDataBufferSize = glLargeDataBufferSize/2 + sizeof(PVOID);
        glSmallDataBufferSize &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        NdisInitializeNPagedLookasideList(&SmallDataDescList,
                                          AllocateDataDesc,
                                          FreeDataDesc,
                                          0,
                                          DATADESC_SIZE + 
                                          glSmallDataBufferSize,
                                          SMALLDATADESC_TAG,
                                          0);

        NdisInitializeNPagedLookasideList(&LargeDataDescList,
                                          AllocateDataDesc,
                                          FreeDataDesc,
                                          0,
                                          DATADESC_SIZE + 
                                          glLargeDataBufferSize,
                                          LARGEDATADESC_TAG,
                                          0);
    }

    NdisInitializeNPagedLookasideList(&WanRequestList,
                                      NULL,
                                      NULL,
                                      0,
                                      sizeof(WAN_REQUEST),
                                      WANREQUEST_TAG,
                                      0);


    NdisInitializeNPagedLookasideList(&AfSapVcCBList,
                                      NULL,
                                      NULL,
                                      0,
                                      AFSAPVCCB_SIZE,
                                      AFSAPVCCB_TAG,
                                      0);

    NdisInitializeReadWriteLock(&ConnTableLock);

#if DBG
    NdisInitializeNPagedLookasideList(&DbgPacketDescList,
                                      NULL,
                                      NULL,
                                      0,
                                      sizeof(DBG_PACKET),
                                      DBGPACKET_TAG,
                                      0);
    InitializeListHead(&WanTrcList);
    WanTrcCount = 0;
#endif

    WanInitECP();
    WanInitVJ();

    //
    // Initialzie as a "Protocol" to the WAN Miniport drivers
    //
    Status = DoProtocolInit(RegistryPath);

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                      ("DoProtocolInit Failed! Status: 0x%x - %s",
                      Status, NdisWanGetNdisStatus(Status)));

        goto DriverEntryError;
    }

    //
    // Initialize as a Miniport driver to the transports
    //
    Status = DoMiniportInit();

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                      ("DoMiniportInit Failed! Status: 0x%x - %s",
                      Status, NdisWanGetNdisStatus(Status)));

        goto DriverEntryError;
    }

    //
    // Open the miniports
    //
#if 0
    NdisWanBindMiniports(RegistryPath);
#endif

    //
    // Allocate and initialize the ConnectionTable
    //
    Status =
        NdisWanCreateConnectionTable(NdisWanCB.NumberOfLinks);

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                      ("NdisWanInitConnectionTable Failed! Status: 0x%x - %s",
                      Status, NdisWanGetNdisStatus(Status)));

        goto DriverEntryError;

    }


    //
    // Initialize the Ioctl interface
    //
#ifdef MY_DEVICE_OBJECT
    {
        NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\NdisWan");
        NDIS_STRING Name = NDIS_STRING_CONST("\\Device\\NdisWan");
        ULONG   i;

        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
    
            NdisWanCB.MajorFunction[i] = (PVOID)DriverObject->MajorFunction[i];
            DriverObject->MajorFunction[i] = NdisWanIrpStub;
        }
    
        DriverObject->MajorFunction[IRP_MJ_CREATE] = NdisWanCreate;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = NdisWanIoctl;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP] = NdisWanCleanup;
    //  DriverObject->MajorFunction[IRP_MJ_PNP_POWER] = NdisWanPnPPower;
        NdisWanCB.NdisUnloadHandler = DriverObject->DriverUnload;
        DriverObject->DriverUnload = (PVOID)NdisWanUnload;
    
        IoCreateDevice(DriverObject,
                       sizeof(LIST_ENTRY),
                       &Name,
                       FILE_DEVICE_NDISWAN,
                       0,
                       FALSE,
                       (PDEVICE_OBJECT*)&NdisWanCB.pDeviceObject);
    
        NdisWanDbgOut(DBG_INFO, DBG_INIT,
                      ("IoCreateSymbolicLink: %ls -> %ls",
                                SymbolicName.Buffer, Name.Buffer));
    
        ((PDEVICE_OBJECT)NdisWanCB.pDeviceObject)->Flags |= DO_BUFFERED_IO;
    
        IoCreateSymbolicLink(&SymbolicName,
                             &Name);
    }
#endif

    NdisMRegisterUnloadHandler(NdisWanCB.NdisWrapperHandle,
                               NdisWanUnload);

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DriverEntry: Exit"));

    return (STATUS_SUCCESS);

    //
    // An error occured so we need to cleanup things
    //
DriverEntryError:

    NdisWanGlobalCleanup();

    //
    // Terminate the wrapper
    //
    NdisTerminateWrapper(NdisWanCB.NdisWrapperHandle,
                         NdisWanCB.pDriverObject);

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DriverEntry: Exit Error!"));

    return (STATUS_UNSUCCESSFUL);
    
}

VOID
NdisWanUnload(
    PDRIVER_OBJECT DriverObject
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("NdisWanUnload: Entry!"));

    NdisWanGlobalCleanup();

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("NdisWanUnload: Exit!"));
}

VOID
NdisWanReadRegistry(
    IN  PUNICODE_STRING RegistryPath
    )
/*++

Routine Name:

    NdisWanReadRegistry

Routine Description:

    This routine will read the registry values for NdisWan.  These values only
    need to be read once for all adapters as their information is global.

Arguments:

    WrapperConfigurationContext - Handle to registry key where NdisWan information
                                  is stored.

Return Values:

    None

--*/
{
    NDIS_STATUS Status;
    PWSTR       ParameterKey = L"NdisWan\\Parameters";
    PWSTR       MinFragmentSizeKeyWord = L"MinimumFragmentSize";
    PWSTR       MaxFragmentSizeKeyWord = L"MaximumFragmentSize";
    PWSTR       LinkBandwidthKeyWord = L"MinimumLinkBandwidth";
    PWSTR       CachedKeyCountKeyWord = L"CachedKeyCount";
    PWSTR       MaxOutOfOrderDepthKeyWord = L"MaxOutOfOrderDepth";
    PWSTR       DebugLevelKeyWord = L"DebugLevel";
    PWSTR       DebugMaskKeyWord = L"DebugMask";
    PWSTR       NumberOfPortsKeyWord = L"NumberOfPorts";
    PWSTR       PacketPoolCountKeyWord = L"NdisPacketPoolCount";
    PWSTR       PacketPoolOverflowKeyWord = L"NdisPacketPoolOverflow";
    PWSTR       ProtocolMaxSendPacketsKeyWord = L"ProtocolMaxSendPackets";
    PWSTR       SniffLinkKeyWord = L"SniffLink";
    PWSTR       SendQueueDepthKeyWord = L"SendQueueDepth";
    PWSTR       MRUKeyWord = L"MRU";
    PWSTR       MRRUKeyWord = L"MRRU";
    PWSTR       TunnelMTUKeyWord = L"TunnelMTU";
    PWSTR       HistorylessKeyWord = L"Historyless";
    PWSTR       AtmUseLLCOnSVCKeyWord = L"AtmUseLLCOnSVC";
    PWSTR       AtmUseLLCOnPVCKeyWord = L"AtmUseLLCOnPVC";
    PWSTR       IGMPIdleKeyWord = L"IGMPIdle";
    ULONG       GenericULong;
    RTL_QUERY_REGISTRY_TABLE    QueryTable[6];

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("NdisWanReadRegistry: Enter"));

    //
    // See if there are any data transform drivers in the system
    //
    {
        PWSTR   TransformDriversKey = L"TransformDriver\\Drivers";
        PWSTR   TransformDriverKeyWord = L"Drivers";

        NdisZeroMemory(&QueryTable, sizeof(QueryTable));
        QueryTable[0].QueryRoutine = OpenTransformDriver;
        QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
        QueryTable[0].Name = TransformDriverKeyWord;
        QueryTable[0].EntryContext = NULL;
        QueryTable[0].DefaultType = 0;
        Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                        TransformDriversKey,
                                        &QueryTable[0],
                                        NULL,
                                        NULL);
    
        NdisWanDbgOut(DBG_INFO, DBG_INIT,
                      ("RtlQueryRegistry - 'TransformDriver\\Drivers' Status: 0x%x",
                      Status));
    }


    //
    // First setup the protocol id table
    //
    {
        PWSTR   ProtocolsKey = L"NdisWan\\Parameters\\Protocols\\";
        PWSTR   ProtocolKeyWord = L"ProtocolType";
        PWSTR   PPPKeyWord = L"PPPProtocolType";
        PWSTR   ProtocolMTUKeyWord = L"ProtocolMTU";
        PWSTR   TunnelMTUKeyword = L"TunnelMTU";
        PWSTR   QueueDepthKeyword = L"PacketQueueDepth";
        ULONG   i, Generic1, Generic2;
        PROTOCOL_INFO   ProtocolInfo;
        UNICODE_STRING  uni1;

        NdisWanInitUnicodeString(&uni1, ProtocolsKey);

        NdisZeroMemory(&QueryTable, sizeof(QueryTable));

        //
        // Read the ProtocolType parameter MULTI_SZ
        //
        QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
        QueryTable[0].Name = ProtocolKeyWord;
        QueryTable[0].EntryContext = &Generic1;
        QueryTable[0].DefaultType = 0;

        //
        // Read the PPPProtocolType parameter MULTI_SZ
        //
        QueryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[1].Name = PPPKeyWord;
        QueryTable[1].EntryContext = &Generic2;
        QueryTable[1].DefaultType = 0;

        //
        // Read the ProtocolMTU parameter DWORD
        //
        QueryTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[2].Name = ProtocolMTUKeyWord;
        QueryTable[2].EntryContext = &ProtocolInfo.MTU;
        QueryTable[2].DefaultType = 0;

        //
        // Read the ProtocolMTU parameter DWORD
        //
        QueryTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[3].Name = TunnelMTUKeyWord;
        QueryTable[3].EntryContext = &ProtocolInfo.TunnelMTU;
        QueryTable[3].DefaultType = 0;

        //
        // Read the PacketQueueDepth parameter DWORD
        //
        QueryTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[4].Name = QueueDepthKeyword;
        QueryTable[4].EntryContext = &ProtocolInfo.PacketQueueDepth;
        QueryTable[4].DefaultType = 0;

        for (i = 0; i < 32; i++) {
            WCHAR   Buffer[512] = {0};
            WCHAR   Buffer2[256] = {0};
            UNICODE_STRING  uni2;
            UNICODE_STRING  IndexString;

            uni2.Buffer = Buffer;
            uni2.MaximumLength = sizeof(Buffer);
            uni2.Length = uni1.Length;
            NdisWanCopyUnicodeString(&uni2, &uni1);
            IndexString.Buffer = Buffer2;
            IndexString.MaximumLength = sizeof(Buffer2);
            RtlIntegerToUnicodeString(i, 10, &IndexString);
            RtlAppendUnicodeStringToString(&uni2, &IndexString);

            NdisZeroMemory(&ProtocolInfo, sizeof(ProtocolInfo));

            Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                            uni2.Buffer,
                                            QueryTable,
                                            NULL,
                                            NULL);
            if (Status == STATUS_SUCCESS) {
                ProtocolInfo.ProtocolType = (USHORT)Generic1;
                ProtocolInfo.PPPId = (USHORT)Generic2;
                ProtocolInfo.Flags = PROTOCOL_UNBOUND;
                SetProtocolInfo(&ProtocolInfo);
            }
        }
    }

    //
    // Read the MinFragmentSize parameter DWORD
    //
    glMinFragSize = DEFAULT_MIN_FRAG_SIZE;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = MinFragmentSizeKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MinimumFragmentSize' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0) {
        glMinFragSize = GenericULong;
    }

    //
    // Read the MaxFragmentSize parameter DWORD
    //
    glMaxFragSize = glMaxMTU;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = MaxFragmentSizeKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MaximumFragmentSize' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0 &&
        GenericULong < glMaxMTU) {
        glMaxFragSize = GenericULong;
    }

    if (glMaxFragSize < glMinFragSize) {
        glMinFragSize = glMaxFragSize;
    }

    //
    // Read the MinimumLinkBandwidth parameter DWORD
    //
    glMinLinkBandwidth = 25;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = LinkBandwidthKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MinimumLinkBandwidth' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong <= 100) {
        glMinLinkBandwidth = GenericULong;
    }

    //
    // Read the NumberOfPorts parameter DWORD
    //
    NdisWanCB.NumberOfLinks = 250;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = NumberOfPortsKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'NumberOfPorts' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0) {
        NdisWanCB.NumberOfLinks = GenericULong;
    }

    //
    // Read the NdisPacketPoolCount parameter DWORD
    //
    glPacketPoolCount = 100;
//  glPacketPoolCount = 1;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = PacketPoolCountKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'NdisPacketPoolCount' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0) {
        glPacketPoolCount = GenericULong;
    }

    //
    // Read the NdisPacketPoolOverflow parameter DWORD
    //
//  glPacketPoolOverflow = PAGE_SIZE / (sizeof(NDIS_PACKET) + sizeof(NDISWAN_PROTOCOL_RESERVED));
    glPacketPoolOverflow = 0;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = PacketPoolOverflowKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'NdisPacketPoolOverflow' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0) {
        glPacketPoolOverflow = GenericULong;
    }

    //
    // Read the ProtocolMaxSendPackets parameter DWORD
    //
    glProtocolMaxSendPackets = 5;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = ProtocolMaxSendPacketsKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'ProtocolMaxSendPackets' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0) {
        glProtocolMaxSendPackets = GenericULong;
    }

    //
    // Read the CachedKeyCount parameter DWORD
    //
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = CachedKeyCountKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'CachedKeyCount' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glCachedKeyCount = GenericULong;
    }

    //
    // Read the MaxOutOfOrderDepth parameter DWORD
    //
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = MaxOutOfOrderDepthKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MaxOutOfOrderDepth' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glMaxOutOfOrderDepth = GenericULong;
    }

    //
    // Read the DebugLevel parameter DWORD
    //
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = DebugLevelKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'DebugLevel' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glDebugLevel = GenericULong;
    }

    //
    // Read the DebugIdentifier parameter DWORD
    //
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = DebugMaskKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'DebugMask' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glDebugMask = GenericULong;
    }

    //
    // Read the SniffLink parameter DWORD
    //
    gbSniffLink = FALSE;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = SniffLinkKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'SniffLink' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        gbSniffLink = (GenericULong == 0) ? FALSE : TRUE;
    }

    //
    // Read the SendQueueDepth parameter DWORD
    //
    glSendQueueDepth = 2;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = SendQueueDepthKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'SendQueueDepth' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glSendQueueDepth = (GenericULong == 0) ? 2 : GenericULong;
    }

    //
    // Read the MRU parameter DWORD
    //
    glMRU = DEFAULT_MRU;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = MRUKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MRU' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glMRU = (GenericULong == 0) ? DEFAULT_MRU : GenericULong;
    }

    //
    // Read the MRRU parameter DWORD
    //
    glMRRU = DEFAULT_MRRU;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = MRRUKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MRRU' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glMRRU = (GenericULong == 0) ? DEFAULT_MRRU : GenericULong;
    }

    //
    // Read the TunnelMTU parameter DWORD
    //
    glTunnelMTU = DEFAULT_TUNNEL_MTU;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = TunnelMTUKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'TunnelMTU' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glTunnelMTU = (GenericULong == 0) ? DEFAULT_TUNNEL_MTU : GenericULong;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("NdisWanReadRegistry: Exit"));

    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    gbHistoryless = TRUE;
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = HistorylessKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);
    
    NdisWanDbgOut(DBG_INFO, DBG_INIT,
        ("RtlQueryRegistry - 'Historyless' Status: 0x%x", Status));
    
    if (Status == NDIS_STATUS_SUCCESS) {
        gbHistoryless = (GenericULong) ? TRUE : FALSE;
    }

    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = AtmUseLLCOnSVCKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);
    
    NdisWanDbgOut(DBG_INFO, DBG_INIT,
        ("RtlQueryRegistry - 'AtmUseLLCOnSVC' Status: 0x%x", Status));
    
    if (Status == NDIS_STATUS_SUCCESS) {
            gbAtmUseLLCOnSVC = (GenericULong) ? TRUE : FALSE;
    }

    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = AtmUseLLCOnPVCKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);
    
    NdisWanDbgOut(DBG_INFO, DBG_INIT,
        ("RtlQueryRegistry - 'AtmUseLLCOnPVC' Status: 0x%x", Status));
    
    if (Status == NDIS_STATUS_SUCCESS) {
            gbAtmUseLLCOnPVC = (GenericULong) ? TRUE : FALSE;
    }

    //
    // Read the IGMPIdle parameter DWORD
    //
    gbIGMPIdle = TRUE;
    NdisZeroMemory(&QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = IGMPIdleKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'IGMPIdle' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        gbIGMPIdle = (GenericULong == 0) ? FALSE : TRUE;
    }
}

NTSTATUS
OpenTransformDriver(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = STATUS_SUCCESS;
    PIRP    Irp;
    PTRANSDRVCB TransDrvCB;
    KEVENT  TransDrvEvent;
    IO_STATUS_BLOCK IoStatus;

    NdisWanAllocateMemory(&TransDrvCB,
                          sizeof(PTRANSDRVCB),
                          TRANSDRV_TAG);
    if (TransDrvCB == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    InterlockedExchange((PLONG)&TransDrvCB->State, TRANSDRV_OPENING);

    //
    // Open the transform driver
    //
    NdisWanStringToNdisString(&TransDrvCB->Name, ValueName);

    Status =
    IoGetDeviceObjectPointer(&TransDrvCB->Name,
                             SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                             &TransDrvCB->FObj,
                             &TransDrvCB->DObj);

    if (Status != STATUS_SUCCESS) {
        NdisWanFreeMemory(TransDrvCB);
        NdisWanDbgOut(DBG_TRACE, DBG_INIT,
            ("NDISWAN: Failed to open the TransformDriver %ls! %x\n", TransDrvCB->Name.Buffer, Status));
        return (Status);
    }

    ObReferenceObject(TransDrvCB->DObj);
    ObDereferenceObject(TransDrvCB->FObj);

    TransDrvCB->Open.ClientOpenContext = TransDrvCB;
    TransDrvCB->Open.MajorVersion = 1;
    TransDrvCB->Open.MinorVersion = 0;
    TransDrvCB->Open.TransformRegisterHandler = TransformRegister;
    TransDrvCB->Open.TransformTxCompleteHandler = TransformTxComplete;
    TransDrvCB->Open.TransformRxCompleteHandler = TransformRxComplete;
    TransDrvCB->Open.SendCtrlPacketHandler = TransformSendCtrlPacket;

    NdisWanDbgOut(DBG_TRACE, DBG_INIT,
        ("NDISWAN: Opened TransformDriver %ls successfully!\n", TransDrvCB->Name.Buffer));

    //
    // Build Irp
    //
    KeInitializeEvent(&TransDrvEvent, NotificationEvent, FALSE);

    Irp =
        IoBuildDeviceIoControlRequest(IOCTL_TRANSFORM_OPEN,
                                      TransDrvCB->DObj,
                                      &TransDrvCB->Open,
                                      sizeof(TransDrvCB->Open),
                                      &TransDrvCB->Open,
                                      sizeof(TransDrvCB->Open),
                                      FALSE,
                                      &TransDrvEvent,
                                      &IoStatus);

    if (Irp == NULL) {
        ObDereferenceObject(TransDrvCB->DObj);
        NdisWanFreeMemory(TransDrvCB);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Send Irp
    //
    Status =
        IoCallDriver(TransDrvCB->DObj, Irp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&TransDrvEvent,
                              UserRequest,
                              KernelMode,
                              FALSE,
                              NULL);
        Status = IoStatus.Status;
    }

    if (Status != STATUS_SUCCESS) {
        ObDereferenceObject(TransDrvCB->DObj);
        NdisWanFreeMemory(TransDrvCB);
        NdisWanDbgOut(DBG_FAILURE, DBG_INIT,
            ("NDISWAN: Failed registering with TransformDriver %ls. %x\n",
            TransDrvCB->Name.Buffer, Status));
        return(Status);
    }

    InterlockedExchange((PLONG)&TransDrvCB->State, TRANSDRV_OPENED);

    //
    // If successfull add driver to list
    //
    InsertTailGlobalList(TransformDrvList,
                         &TransDrvCB->Linkage);

    return (STATUS_SUCCESS);
}

#endif      // NT specific code



NDIS_STATUS
DoMiniportInit(
    VOID
    )
/*++

Routine Name:

    DoMiniportInit

Routine Description:

    This routines registers NdisWan as a Miniport driver with the NDIS wrapper.
    The wrapper will now call NdisWanInitialize once for each adapter instance
    of NdisWan that is in the registry.

Arguments:

    None

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_BAD_VERSION
    NDIS_STATUS_FAILURE

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    NDIS_MINIPORT_CHARACTERISTICS   MiniportChars;

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DoMiniportInit: Enter"));

    NdisZeroMemory(&MiniportChars, sizeof(MiniportChars));

    MiniportChars.MajorNdisVersion = 5;
    MiniportChars.MinorNdisVersion = 0;

    //
    // NDIS 3.0 handlers
    //
    MiniportChars.HaltHandler = MPHalt;
    MiniportChars.InitializeHandler = MPInitialize;
//  MiniportChars.QueryInformationHandler = MPQueryInformation;
    MiniportChars.ReconfigureHandler = MPReconfigure;
    MiniportChars.ResetHandler = MPReset;
//  MiniportChars.SetInformationHandler = MPSetInformation;

    //
    // We are providing a sendpackets handlers so
    // we don't need the regular send handler
    //
    MiniportChars.SendHandler = NULL;

    //
    // We are going to indicate packets so we
    // don't need a transfer data handler
    //
    MiniportChars.TransferDataHandler = NULL;

    //
    // Since we don't have any hardware to worry about we will
    // not handle any of the interrupt stuff!
    //
    MiniportChars.DisableInterruptHandler = NULL;
    MiniportChars.EnableInterruptHandler = NULL;
    MiniportChars.HandleInterruptHandler = NULL;
    MiniportChars.ISRHandler = NULL;

    //
    // We will disable the check for hang timeout so we do not
    // need a check for hang handler!
    //
    MiniportChars.CheckForHangHandler = NULL;

    //
    // NDIS 4.0 handlers
    //
    MiniportChars.ReturnPacketHandler = MPReturnPacket;
    MiniportChars.SendPacketsHandler = MPSendPackets;

    //
    // unused
    //
    MiniportChars.AllocateCompleteHandler = NULL;

    //
    // NDIS 5.0 handlers
    //
    MiniportChars.CoCreateVcHandler = MPCoCreateVc;
    MiniportChars.CoDeleteVcHandler = MPCoDeleteVc;
    MiniportChars.CoActivateVcHandler = MPCoActivateVc;
    MiniportChars.CoDeactivateVcHandler = MPCoDeactivateVc;
    MiniportChars.CoSendPacketsHandler = MPCoSendPackets;
    MiniportChars.CoRequestHandler = MPCoRequest;

    Status = NdisMRegisterMiniport(NdisWanCB.NdisWrapperHandle,
                                   &MiniportChars,
                                   sizeof(MiniportChars));

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DoMiniportInit: Exit %x", Status));

    return (Status);
}



NDIS_STATUS
DoProtocolInit(
    IN  PUNICODE_STRING RegistryPath
    )
/*++

Routine Name:

    DoProtocolInit

Routine Description:

    This function registers NdisWan as a protocol with the NDIS wrapper.

Arguments:

    None

Return Values:

    NDIS_STATUS_BAD_CHARACTERISTICS
    NDIS_STATUS_BAD_VERSION
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_SUCCESS

--*/
{
    NDIS_PROTOCOL_CHARACTERISTICS ProtocolChars;
    NDIS_STATUS Status;
//  NDIS_STRING NdisWanName = NDIS_STRING_CONST("NdisWanProto");
    NDIS_STRING NdisWanName = NDIS_STRING_CONST("NdisWan");

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DoProtocolInit: Enter"));

    NdisZeroMemory(&ProtocolChars, sizeof(ProtocolChars));

    ProtocolChars.Name.Length = NdisWanName.Length;
    ProtocolChars.Name.Buffer = (PVOID)NdisWanName.Buffer;

    ProtocolChars.MajorNdisVersion = 5;
    ProtocolChars.MinorNdisVersion = 0;

    //
    // NDIS 3.0 handlers
    //
    ProtocolChars.OpenAdapterCompleteHandler = ProtoOpenAdapterComplete;
    ProtocolChars.CloseAdapterCompleteHandler = ProtoCloseAdapterComplete;
    ProtocolChars.WanSendCompleteHandler = ProtoWanSendComplete;
    ProtocolChars.TransferDataCompleteHandler = NULL;
    ProtocolChars.ResetCompleteHandler = ProtoResetComplete;
    ProtocolChars.RequestCompleteHandler = ProtoRequestComplete;
    ProtocolChars.WanReceiveHandler = ProtoWanReceiveIndication;
    ProtocolChars.ReceiveCompleteHandler = ProtoReceiveComplete;
    ProtocolChars.StatusHandler = ProtoIndicateStatus;
    ProtocolChars.StatusCompleteHandler = ProtoIndicateStatusComplete;

    //
    // NDIS 4.0 handlers
    //
    ProtocolChars.ReceivePacketHandler = NULL;

    //
    // PnP handlers
    //
    ProtocolChars.BindAdapterHandler = ProtoBindAdapter;
    ProtocolChars.UnbindAdapterHandler = ProtoUnbindAdapter;
    ProtocolChars.PnPEventHandler = ProtoPnPEvent;
    ProtocolChars.UnloadHandler = ProtoUnload;

    //
    // NDIS 5.0 handlers
    //
    ProtocolChars.CoSendCompleteHandler = ProtoCoSendComplete;
    ProtocolChars.CoStatusHandler = ProtoCoIndicateStatus;
    ProtocolChars.CoReceivePacketHandler = ProtoCoReceivePacket;
    ProtocolChars.CoAfRegisterNotifyHandler = ProtoCoAfRegisterNotify;

    NdisRegisterProtocol(&Status,
                         &NdisWanCB.ProtocolHandle,
                         (PNDIS_PROTOCOL_CHARACTERISTICS)&ProtocolChars,
                         sizeof(NDIS_PROTOCOL_CHARACTERISTICS) + ProtocolChars.Name.Length);

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DoProtocolInit: Exit"));

    return (Status);
}

VOID
SetProtocolInfo(
    IN  PPROTOCOL_INFO ProtocolInfo
    )
/*++

Routine Name:

    InsertProtocolInfo

Routine Description:

    This routine takes a information about a protocol and inserts it
    into the appropriate lookup table.

Arguments:


Return Values:

--*/
{
    ULONG   i;
    ULONG   ArraySize;
    PPROTOCOL_INFO  InfoArray;

    if (ProtocolInfo->ProtocolType == 0) {
        return;
    }

    NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

    ArraySize = ProtocolInfoTable->ulArraySize;

    //
    // First check to see if this value is already in the array
    //
    for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
         i < ArraySize; i++, InfoArray++) {
        if (InfoArray->ProtocolType == ProtocolInfo->ProtocolType) {
            //
            // This protocol is already in the table
            // update values if they are valid (0 is invalid)
            //
            if (ProtocolInfo->PPPId != 0) {
                InfoArray->PPPId = ProtocolInfo->PPPId;
            }
            if (ProtocolInfo->TunnelMTU != 0) {
                InfoArray->TunnelMTU = ProtocolInfo->TunnelMTU;
            }
            if (ProtocolInfo->MTU != 0) {
                InfoArray->MTU = ProtocolInfo->MTU;
                if (InfoArray->MTU < InfoArray->TunnelMTU) {
                    InfoArray->TunnelMTU = InfoArray->MTU;
                }
            }
            if (ProtocolInfo->MTU > glMaxMTU) {
                glMaxMTU = ProtocolInfo->MTU;
            }
            if (ProtocolInfo->PacketQueueDepth != 0) {
                InfoArray->PacketQueueDepth =
                    ProtocolInfo->PacketQueueDepth;
            }
            if (ProtocolInfo->Flags != 0) {
                //
                // Is this a bind notification?
                //
                if (ProtocolInfo->Flags & PROTOCOL_BOUND) {
                    if (InfoArray->Flags & PROTOCOL_UNBOUND) {
                        InfoArray->Flags &= ~PROTOCOL_UNBOUND;
                        InfoArray->Flags |=
                            (PROTOCOL_BOUND | PROTOCOL_EVENT_OCCURRED);
                        ProtocolInfoTable->Flags |= PROTOCOL_EVENT_OCCURRED;
                    } else if ((InfoArray->Flags & PROTOCOL_BOUND) &&
                               (ProtocolInfo->ProtocolType == PROTOCOL_IP)) {
                        //
                        // This means we were unbound and then
                        // bound again without our miniport being
                        // halted (layered driver insertion i.e psched).
                        // Currently this only interferes with rasman
                        // if the protocol is IP.
                        // We need to tell ras about two events,
                        // the unbind and the bind.
                        //
                        InfoArray->Flags |=
                            (PROTOCOL_BOUND | 
                             PROTOCOL_REBOUND |
                             PROTOCOL_EVENT_OCCURRED);
                        ProtocolInfoTable->Flags |= PROTOCOL_EVENT_OCCURRED;

                    }
                }

                //
                // is this an unbind notification?
                //
                if (ProtocolInfo->Flags & PROTOCOL_UNBOUND) {
                    if (InfoArray->Flags & PROTOCOL_BOUND) {
                        InfoArray->Flags &= ~(PROTOCOL_BOUND | PROTOCOL_REBOUND);
                        InfoArray->Flags |=
                            (PROTOCOL_UNBOUND | PROTOCOL_EVENT_OCCURRED);
                        ProtocolInfoTable->Flags |= PROTOCOL_EVENT_OCCURRED;
                    }
                }
            }

            if (ProtocolInfoTable->Flags & PROTOCOL_EVENT_OCCURRED &&
                !(ProtocolInfoTable->Flags & PROTOCOL_EVENT_SIGNALLED)) {

                if (ProtocolInfoTable->EventIrp != NULL) {
                    PIRP    Irp;

                    Irp = ProtocolInfoTable->EventIrp;

                    if (IoSetCancelRoutine(Irp, NULL)) {

                        ProtocolInfoTable->EventIrp = NULL;
                        ProtocolInfoTable->Flags |= PROTOCOL_EVENT_SIGNALLED;

                        NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

                        Irp->IoStatus.Status = STATUS_SUCCESS;
                        Irp->IoStatus.Information = 0;

                        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

                        NdisAcquireSpinLock(&ProtocolInfoTable->Lock);
                    }
                }
            }

            break;
        }
    }
    
    //
    // We did not find the value in the array so
    // we will add it at the 1st available spot
    //
    if (i >= ArraySize) {
    
        for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
             i < ArraySize; i++, InfoArray++) {
            //
            // We are looking for an empty slot to add
            // the new values to the table
            //
            if (InfoArray->ProtocolType == 0) {
                *InfoArray = *ProtocolInfo;
                if (ProtocolInfo->MTU > glMaxMTU) {
                    glMaxMTU = ProtocolInfo->MTU;
                }
                break;
            }
        }
    }

    NdisReleaseSpinLock(&ProtocolInfoTable->Lock);
}

BOOLEAN
GetProtocolInfo(
    IN OUT  PPROTOCOL_INFO ProtocolInfo
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   i;
    ULONG   ArraySize;
    PPROTOCOL_INFO  InfoArray;
    BOOLEAN ReturnValue = FALSE;

    NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

    ArraySize = ProtocolInfoTable->ulArraySize;

    for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
         i < ArraySize; i++, InfoArray++) {

        if (InfoArray->ProtocolType == ProtocolInfo->ProtocolType) {
            *ProtocolInfo = *InfoArray;
            ReturnValue = TRUE;
            break;
        }
    }

    NdisReleaseSpinLock(&ProtocolInfoTable->Lock);
    return (ReturnValue);
}

NDIS_HANDLE
InsertLinkInConnectionTable(
    IN  PLINKCB LinkCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   Index, i;
    PLINKCB *LinkArray;
    NDIS_STATUS Status;
    LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&ConnTableLock, TRUE, &LockState);

    if (ConnectionTable->ulNumActiveLinks >
        (ConnectionTable->ulArraySize - 1)/2) {
        //
        // We need to grow the table!
        //
        Status =
        NdisWanCreateConnectionTable(ConnectionTable->ulArraySize +
                                    (ConnectionTable->ulArraySize * 2));

        if (Status != NDIS_STATUS_SUCCESS) {
            NdisReleaseReadWriteLock(&ConnTableLock, &LockState);
            return (NULL);
        }
    }

    //
    // We are doing a linear search for an empty spot in
    // the link array
    //
    LinkArray = ConnectionTable->LinkArray;
    i = ConnectionTable->ulArraySize;
    Index = (ConnectionTable->ulNextLink == 0) ?
            1 : ConnectionTable->ulNextLink;
    do {

        if (LinkArray[Index] == NULL) {
            LinkArray[Index] = LinkCB;
            LinkCB->hLinkHandle = (NDIS_HANDLE)ULongToPtr(Index);
            ConnectionTable->ulNextLink = (Index+1) % ConnectionTable->ulArraySize;
            InterlockedIncrement(&glLinkCount);
            if (ConnectionTable->ulNumActiveLinks == 0) {
                hSystemState =
                PoRegisterSystemState(NULL, ES_SYSTEM_REQUIRED | ES_CONTINUOUS);
            }
            ConnectionTable->ulNumActiveLinks++;
            InsertTailList(&ConnectionTable->LinkList, 
                           &LinkCB->ConnTableLinkage);
            break;
        }
        Index = (Index+1) % ConnectionTable->ulArraySize;
        Index = (Index == 0) ? 1 : Index;
        i--;
    } while ( i );

    if (i == 0) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
            ("InsertLinkCB: ConnectionTable is full!"));
        Index = 0;      
    }

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    return ((NDIS_HANDLE)ULongToPtr(Index));
}

VOID
RemoveLinkFromConnectionTable(
    IN  PLINKCB LinkCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG    Index = PtrToUlong(LinkCB->hLinkHandle);
    PLINKCB *LinkArray;
    LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&ConnTableLock, TRUE, &LockState);

    LinkArray = ConnectionTable->LinkArray;
    
    do {

        if (Index == 0 || Index > ConnectionTable->ulArraySize) {
            NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                ("RemoveLinkCB: Invalid LinkHandle! Handle: %d\n", Index));
            ASSERT(0);
            break;
        }

        if (LinkArray[Index] == NULL) {
            NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                ("RemoveLinkCB: LinkCB not in connection table! LinkCB: %p\n", LinkCB));
            ASSERT(0);
            break;          
        }

        ASSERT(LinkCB == LinkArray[Index]);

        LinkArray[Index] = NULL;
    
        RemoveEntryList(&LinkCB->ConnTableLinkage);

        ConnectionTable->ulNumActiveLinks--;

        if (ConnectionTable->ulNumActiveLinks == 0) {
            PoUnregisterSystemState(hSystemState);
            hSystemState = NULL;
        }

    } while ( 0 );

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);
}

NDIS_HANDLE
InsertBundleInConnectionTable(
    IN  PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   Index,i;
    PBUNDLECB   *BundleArray;
    NDIS_STATUS Status;
    LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&ConnTableLock, TRUE, &LockState);

    if (ConnectionTable->ulNumActiveBundles >
        (ConnectionTable->ulArraySize - 1)/2) {
        //
        // We need to grow the table!
        //
        Status =
            NdisWanCreateConnectionTable(ConnectionTable->ulArraySize +
                                        (ConnectionTable->ulArraySize * 2));

        if (Status != NDIS_STATUS_SUCCESS) {
            NdisReleaseReadWriteLock(&ConnTableLock, &LockState);
            return (NULL);
        }
    }

    //
    // We are doing a linear search for an empty spot in
    // the link array
    //
    BundleArray = ConnectionTable->BundleArray;
    i = ConnectionTable->ulArraySize;
    Index = (ConnectionTable->ulNextBundle == 0) ?
            1 : ConnectionTable->ulNextBundle;
    do {

        if (BundleArray[Index] == NULL) {
            BundleArray[Index] = BundleCB;
            ConnectionTable->ulNumActiveBundles++;
            BundleCB->hBundleHandle = (NDIS_HANDLE)ULongToPtr(Index);
            InsertTailList(&ConnectionTable->BundleList, &BundleCB->Linkage);
            ConnectionTable->ulNextBundle = (Index+1) % ConnectionTable->ulArraySize;
            break;
        }
        Index = (Index+1) % ConnectionTable->ulArraySize;
        Index = (Index == 0) ? 1 : Index;
        i--;
    } while ( i );

    if (i == 0) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
            ("InsertBundleCB: ConnectionTable is full!"));
        Index = 0;      
    }

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    return ((NDIS_HANDLE)ULongToPtr(Index));
}

VOID
RemoveBundleFromConnectionTable(
    IN  PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG        Index = PtrToUlong(BundleCB->hBundleHandle);
    PBUNDLECB   *BundleArray;
    LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&ConnTableLock, TRUE, &LockState);

    BundleArray = ConnectionTable->BundleArray;

    do {

        if (Index == 0 || Index > ConnectionTable->ulArraySize) {
            NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                ("RemoveBundleCB: Invalid BundleHandle! Handle: %d\n", Index));
            ASSERT(0);
            break;
        }

        if (BundleArray[Index] == NULL) {
            NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                ("RemoveBundleCB: BundleCB not in connection table! BundleCB: %p\n", BundleCB));
            ASSERT(0);
            break;          
        }

        ASSERT(BundleCB == BundleArray[Index]);

        RemoveEntryList(&BundleCB->Linkage);

        BundleArray[Index] = NULL;
    
        ConnectionTable->ulNumActiveBundles--;

    } while ( 0 );

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);
}

VOID
NdisWanGlobalCleanup(
    VOID
    )
/*++

Routine Name:

    NdisWanGlobalCleanup

Routine Description:
    This routine is responsible for cleaning up all allocated resources.

Arguments:

    None

Return Values:

    None

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("GlobalCleanup - Enter"));

    //
    // Stop all timers
    //

    //
    // Complete all outstanding requests
    //

    if (NdisWanCB.ProtocolHandle != NULL) {
        NDIS_STATUS Status;

        ASSERT(OpenCBList.ulCount == 0);

        NdisDeregisterProtocol(&Status,
                               NdisWanCB.ProtocolHandle);
        NdisWanCB.ProtocolHandle = NULL;
    }

    WanDeleteECP();
    WanDeleteVJ();

    //
    // Free all of the BundleCB's
    //

    //
    // Free all of the LinkCB's
    //

    ASSERT(IsListEmpty(&MiniportCBList.List));
    ASSERT(IsListEmpty(&OpenCBList.List));

    NdisFreeSpinLock(&MiniportCBList.Lock);
    NdisFreeSpinLock(&OpenCBList.Lock);
    NdisFreeSpinLock(&ThresholdEventQueue.Lock);
    NdisFreeSpinLock(&PacketPoolList.Lock);
    NdisFreeSpinLock(&IoRecvList.Lock);
    NdisDeleteNPagedLookasideList(&BundleCBList);
    NdisDeleteNPagedLookasideList(&LinkProtoCBList);
    NdisDeleteNPagedLookasideList(&LargeDataDescList);
    NdisDeleteNPagedLookasideList(&SmallDataDescList);
    NdisDeleteNPagedLookasideList(&WanRequestList);
    NdisDeleteNPagedLookasideList(&AfSapVcCBList);

#if DBG
    NdisDeleteNPagedLookasideList(&DbgPacketDescList);
#endif

    //
    // Free globals
    //
    if (ConnectionTable != NULL) {
        NdisWanFreeMemory(ConnectionTable);
        ConnectionTable = NULL;
    }

    if (ProtocolInfoTable != NULL) {
        NdisWanFreeMemory(ProtocolInfoTable);
        ProtocolInfoTable = NULL;
    }

    //
    // Free packet pool
    //
    NdisAcquireSpinLock(&PacketPoolList.Lock);

    while (!IsListEmpty(&PacketPoolList.List)) {
        PPOOL_DESC  PoolDesc;

        PoolDesc =
            (PPOOL_DESC)RemoveHeadList(&PacketPoolList.List);
    
        ASSERT(PoolDesc->AllocatedCount == 0);
            
        NdisFreePacketPool(PoolDesc->PoolHandle);

        NdisWanFreeMemory(PoolDesc);
    }

    NdisReleaseSpinLock(&PacketPoolList.Lock);

    NdisFreeSpinLock(&PacketPoolList.Lock);

#ifdef MY_DEVICE_OBJECT
    if (NdisWanCB.pDeviceObject != NULL) {
        NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\NdisWan");

        IoDeleteSymbolicLink(&SymbolicName);
        IoDeleteDevice(NdisWanCB.pDeviceObject);
        NdisWanCB.pDeviceObject = NULL;
    }
#else
    if (NdisWanCB.pDeviceObject != NULL) {
        NdisMDeregisterDevice(NdisWanCB.DeviceHandle);
        NdisWanCB.pDeviceObject = NULL;
    }
#endif

    NdisFreeSpinLock(&NdisWanCB.Lock);

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("GlobalCleanup - Exit"));
}

#if DBG     // Debug

PUCHAR
NdisWanGetNdisStatus(
    NDIS_STATUS GeneralStatus
    )
/*++

Routine Name:

    NdisWanGetNdisStatus

Routine Description:

    This routine returns a pointer to the string describing the NDIS error
    denoted by GeneralStatus

Arguments:

    GeneralStatus - The NDIS status you wish to make readable

Return Values:

    Returns a pointer to a string describing GeneralStatus

--*/
{
    static NDIS_STATUS Status[] = {
        NDIS_STATUS_SUCCESS,
        NDIS_STATUS_PENDING,

        NDIS_STATUS_ADAPTER_NOT_FOUND,
        NDIS_STATUS_ADAPTER_NOT_OPEN,
        NDIS_STATUS_ADAPTER_NOT_READY,
        NDIS_STATUS_ADAPTER_REMOVED,
        NDIS_STATUS_BAD_CHARACTERISTICS,
        NDIS_STATUS_BAD_VERSION,
        NDIS_STATUS_CLOSING,
        NDIS_STATUS_DEVICE_FAILED,
        NDIS_STATUS_FAILURE,
        NDIS_STATUS_INVALID_DATA,
        NDIS_STATUS_INVALID_LENGTH,
        NDIS_STATUS_INVALID_OID,
        NDIS_STATUS_INVALID_PACKET,
        NDIS_STATUS_MULTICAST_FULL,
        NDIS_STATUS_NOT_INDICATING,
        NDIS_STATUS_NOT_RECOGNIZED,
        NDIS_STATUS_NOT_RESETTABLE,
        NDIS_STATUS_NOT_SUPPORTED,
        NDIS_STATUS_OPEN_FAILED,
        NDIS_STATUS_OPEN_LIST_FULL,
        NDIS_STATUS_REQUEST_ABORTED,
        NDIS_STATUS_RESET_IN_PROGRESS,
        NDIS_STATUS_RESOURCES,
        NDIS_STATUS_UNSUPPORTED_MEDIA
    };
    static PUCHAR String[] = {
        "SUCCESS",
        "PENDING",

        "ADAPTER_NOT_FOUND",
        "ADAPTER_NOT_OPEN",
        "ADAPTER_NOT_READY",
        "ADAPTER_REMOVED",
        "BAD_CHARACTERISTICS",
        "BAD_VERSION",
        "CLOSING",
        "DEVICE_FAILED",
        "FAILURE",
        "INVALID_DATA",
        "INVALID_LENGTH",
        "INVALID_OID",
        "INVALID_PACKET",
        "MULTICAST_FULL",
        "NOT_INDICATING",
        "NOT_RECOGNIZED",
        "NOT_RESETTABLE",
        "NOT_SUPPORTED",
        "OPEN_FAILED",
        "OPEN_LIST_FULL",
        "REQUEST_ABORTED",
        "RESET_IN_PROGRESS",
        "RESOURCES",
        "UNSUPPORTED_MEDIA"
    };

    static UCHAR BadStatus[] = "UNDEFINED";
#define StatusCount (sizeof(Status)/sizeof(NDIS_STATUS))
    INT i;

    for (i=0; i<StatusCount; i++)
        if (GeneralStatus == Status[i])
            return String[i];
    return BadStatus;
#undef StatusCount
}
#endif      // End Debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\compress.c ===
//************************************************************************
//            Microsoft Corporation
//          Copyright(c) Microsoft Corp., 1990-1992
//
//
//  Revision history:
//  5/5/94        Created           gurdeep
//
//************************************************************************

//#define COMP_12K

#include "wan.h"

#define __FILE_SIG__    COMPRESS_FILESIG

//#define DEBUG
CONST
unsigned long lookup_array1[256] = {
    0,      10276755,   20553510,   30830265,
    41107020,   51383775,   61660530,   71937285,
    82214040,   92490795,   102767550,  113044305,
    123321060,  133597815,  143874570,  154151325,
    164428080,  174704835,  184981590,  195258345,
    205535100,  215811855,  226088610,  236365365,
    246642120,  256918875,  267195630,  277472385,
    287749140,  298025895,  308302650,  318579405,
    328856160,  339132915,  349409670,  359686425,
    369963180,  380239935,  390516690,  400793445,
    411070200,  421346955,  431623710,  441900465,
    452177220,  462453975,  472730730,  483007485,
    493284240,  503560995,  513837750,  524114505,
    534391260,  544668015,  554944770,  565221525,
    575498280,  585775035,  596051790,  606328545,
    616605300,  626882055,  637158810,  647435565,
    657712320,  667989075,  678265830,  688542585,
    698819340,  709096095,  719372850,  729649605,
    739926360,  750203115,  760479870,  770756625,
    781033380,  791310135,  801586890,  811863645,
    822140400,  832417155,  842693910,  852970665,
    863247420,  873524175,  883800930,  894077685,
    904354440,  914631195,  924907950,  935184705,
    945461460,  955738215,  966014970,  976291725,
    986568480,  996845235,  1007121990, 1017398745,
    1027675500, 1037952255, 1048229010, 1058505765,
    1068782520, 1079059275, 1089336030, 1099612785,
    1109889540, 1120166295, 1130443050, 1140719805,
    1150996560, 1161273315, 1171550070, 1181826825,
    1192103580, 1202380335, 1212657090, 1222933845,
    1233210600, 1243487355, 1253764110, 1264040865,
    1274317620, 1284594375, 1294871130, 1305147885,
    1315424640, 1325701395, 1335978150, 1346254905,
    1356531660, 1366808415, 1377085170, 1387361925,
    1397638680, 1407915435, 1418192190, 1428468945,
    1438745700, 1449022455, 1459299210, 1469575965,
    1479852720, 1490129475, 1500406230, 1510682985,
    1520959740, 1531236495, 1541513250, 1551790005,
    1562066760, 1572343515, 1582620270, 1592897025,
    1603173780, 1613450535, 1623727290, 1634004045,
    1644280800, 1654557555, 1664834310, 1675111065,
    1685387820, 1695664575, 1705941330, 1716218085,
    1726494840, 1736771595, 1747048350, 1757325105,
    1767601860, 1777878615, 1788155370, 1798432125,
    1808708880, 1818985635, 1829262390, 1839539145,
    1849815900, 1860092655, 1870369410, 1880646165,
    1890922920, 1901199675, 1911476430, 1921753185,
    1932029940, 1942306695, 1952583450, 1962860205,
    1973136960, 1983413715, 1993690470, 2003967225,
    2014243980, 2024520735, 2034797490, 2045074245,
    2055351000, 2065627755, 2075904510, 2086181265,
    2096458020, 2106734775, 2117011530, 2127288285,
    2137565040, 2147841795, 2158118550, 2168395305,
    2178672060, 2188948815, 2199225570, 2209502325,
    2219779080, 2230055835, 2240332590, 2250609345,
    2260886100, 2271162855, 2281439610, 2291716365,
    2301993120, 2312269875, 2322546630, 2332823385,
    2343100140, 2353376895, 2363653650, 2373930405,
    2384207160, 2394483915, 2404760670, 2415037425,
    2425314180, 2435590935, 2445867690, 2456144445,
    2466421200, 2476697955, 2486974710, 2497251465,
    2507528220, 2517804975, 2528081730, 2538358485,
    2548635240, 2558911995, 2569188750, 2579465505,
    2589742260, 2600019015, 2610295770, 2620572525
};

/*
    for i = 0 to 255,
        lookup_array2[i] = lookup_array1[i] << 8;
*/
CONST
unsigned long lookup_array2[256] = {
    0,      2630849280, 966731264,  3597580544,
    1933462528, 269344512,  2900193792, 1236075776,
    3866925056, 2202807040, 538689024,  3169538304,
    1505420288, 4136269568, 2472151552, 808033536,
    3438882816, 1774764800, 110646784,  2741496064,
    1077378048, 3708227328, 2044109312, 379991296,
    3010840576, 1346722560, 3977571840, 2313453824,
    649335808,  3280185088, 1616067072, 4246916352,
    2582798336, 918680320,  3549529600, 1885411584,
    221293568,  2852142848, 1188024832, 3818874112,
    2154756096, 490638080,  3121487360, 1457369344,
    4088218624, 2424100608, 759982592,  3390831872,
    1726713856, 62595840,   2693445120, 1029327104,
    3660176384, 1996058368, 331940352,  2962789632,
    1298671616, 3929520896, 2265402880, 601284864,
    3232134144, 1568016128, 4198865408, 2534747392,
    870629376,  3501478656, 1837360640, 173242624,
    2804091904, 1139973888, 3770823168, 2106705152,
    442587136,  3073436416, 1409318400, 4040167680,
    2376049664, 711931648,  3342780928, 1678662912,
    14544896,   2645394176, 981276160,  3612125440,
    1948007424, 283889408,  2914738688, 1250620672,
    3881469952, 2217351936, 553233920,  3184083200,
    1519965184, 4150814464, 2486696448, 822578432,
    3453427712, 1789309696, 125191680,  2756040960,
    1091922944, 3722772224, 2058654208, 394536192,
    3025385472, 1361267456, 3992116736, 2327998720,
    663880704,  3294729984, 1630611968, 4261461248,
    2597343232, 933225216,  3564074496, 1899956480,
    235838464,  2866687744, 1202569728, 3833419008,
    2169300992, 505182976,  3136032256, 1471914240,
    4102763520, 2438645504, 774527488,  3405376768,
    1741258752, 77140736,   2707990016, 1043872000,
    3674721280, 2010603264, 346485248,  2977334528,
    1313216512, 3944065792, 2279947776, 615829760,
    3246679040, 1582561024, 4213410304, 2549292288,
    885174272,  3516023552, 1851905536, 187787520,
    2818636800, 1154518784, 3785368064, 2121250048,
    457132032,  3087981312, 1423863296, 4054712576,
    2390594560, 726476544,  3357325824, 1693207808,
    29089792,   2659939072, 995821056,  3626670336,
    1962552320, 298434304,  2929283584, 1265165568,
    3896014848, 2231896832, 567778816,  3198628096,
    1534510080, 4165359360, 2501241344, 837123328,
    3467972608, 1803854592, 139736576,  2770585856,
    1106467840, 3737317120, 2073199104, 409081088,
    3039930368, 1375812352, 4006661632, 2342543616,
    678425600,  3309274880, 1645156864, 4276006144,
    2611888128, 947770112,  3578619392, 1914501376,
    250383360,  2881232640, 1217114624, 3847963904,
    2183845888, 519727872,  3150577152, 1486459136,
    4117308416, 2453190400, 789072384,  3419921664,
    1755803648, 91685632,   2722534912, 1058416896,
    3689266176, 2025148160, 361030144,  2991879424,
    1327761408, 3958610688, 2294492672, 630374656,
    3261223936, 1597105920, 4227955200, 2563837184,
    899719168,  3530568448, 1866450432, 202332416,
    2833181696, 1169063680, 3799912960, 2135794944,
    471676928,  3102526208, 1438408192, 4069257472,
    2405139456, 741021440,  3371870720, 1707752704,
    43634688,   2674483968, 1010365952, 3641215232,
    1977097216, 312979200,  2943828480, 1279710464,
    3910559744, 2246441728, 582323712,  3213172992,
    1549054976, 4179904256, 2515786240, 851668224
};

/*
    for i = 0 to 255,
        lookup_array3[i] = lookup_array1[i] << 16;
*/
CONST
unsigned long lookup_array3[256] = {
    0,       3482517504,      2670067712,      1857617920,
    1045168128,  232718336,   3715235840,      2902786048,
    2090336256,  1277886464,      465436672,       3947954176,
    3135504384,  2323054592,      1510604800,      698155008,
    4180672512,  3368222720,      2555772928,      1743323136,
    930873344,   118423552,   3600941056,      2788491264,
    1976041472,  1163591680,      351141888,       3833659392,
    3021209600,  2208759808,      1396310016,      583860224,
    4066377728,  3253927936,      2441478144,      1629028352,
    816578560,   4128768,     3486646272,      2674196480,
    1861746688,  1049296896,      236847104,       3719364608,
    2906914816,  2094465024,      1282015232,      469565440,
    3952082944,  3139633152,      2327183360,      1514733568,
    702283776,   4184801280,      3372351488,      2559901696,
    1747451904,  935002112,   122552320,       3605069824,
    2792620032,  1980170240,      1167720448,      355270656,
    3837788160,  3025338368,      2212888576,      1400438784,
    587988992,   4070506496,      3258056704,      2445606912,
    1633157120,  820707328,   8257536,     3490775040,
    2678325248,  1865875456,      1053425664,      240975872,
    3723493376,  2911043584,      2098593792,      1286144000,
    473694208,   3956211712,      3143761920,      2331312128,
    1518862336,  706412544,   4188930048,      3376480256,
    2564030464,  1751580672,      939130880,       126681088,
    3609198592,  2796748800,      1984299008,      1171849216,
    359399424,   3841916928,      3029467136,      2217017344,
    1404567552,  592117760,   4074635264,      3262185472,
    2449735680,  1637285888,      824836096,       12386304,
    3494903808,  2682454016,      1870004224,      1057554432,
    245104640,   3727622144,      2915172352,      2102722560,
    1290272768,  477822976,   3960340480,      3147890688,
    2335440896,  1522991104,      710541312,       4193058816,
    3380609024,  2568159232,      1755709440,      943259648,
    130809856,   3613327360,      2800877568,      1988427776,
    1175977984,  363528192,   3846045696,      3033595904,
    2221146112,  1408696320,      596246528,       4078764032,
    3266314240,  2453864448,      1641414656,      828964864,
    16515072,    3499032576,      2686582784,      1874132992,
    1061683200,  249233408,   3731750912,      2919301120,
    2106851328,  1294401536,      481951744,       3964469248,
    3152019456,  2339569664,      1527119872,      714670080,
    4197187584,  3384737792,      2572288000,      1759838208,
    947388416,   134938624,   3617456128,      2805006336,
    1992556544,  1180106752,      367656960,       3850174464,
    3037724672,  2225274880,      1412825088,      600375296,
    4082892800,  3270443008,      2457993216,      1645543424,
    833093632,   20643840,    3503161344,      2690711552,
    1878261760,  1065811968,      253362176,       3735879680,
    2923429888,  2110980096,      1298530304,      486080512,
    3968598016,  3156148224,      2343698432,      1531248640,
    718798848,   4201316352,      3388866560,      2576416768,
    1763966976,  951517184,   139067392,       3621584896,
    2809135104,  1996685312,      1184235520,      371785728,
    3854303232,  3041853440,      2229403648,      1416953856,
    604504064,   4087021568,      3274571776,      2462121984,
    1649672192,  837222400,   24772608,    3507290112,
    2694840320,  1882390528,      1069940736,      257490944,
    3740008448,  2927558656,      2115108864,      1302659072,
    490209280,   3972726784,      3160276992,      2347827200,
    1535377408,  722927616,   4205445120,      3392995328,
    2580545536,  1768095744,      955645952,       143196160,
    3625713664,  2813263872,      2000814080,      1188364288,
    375914496,   3858432000,      3045982208,      2233532416,
    1421082624,  608632832,   4091150336,      3278700544
};

/*
    The key for the multiplicative hash function consists of 3 unsigned
    characters. They are composed (logically) by concatenating them i.e.
    the composed key = 2^16*c2 + 2^8*c2 + c3 and fits in 24 bits. The
    composed key is not actually computed here as we use the components
    to directly compute the hash function.

    The multiplicative hash function consists of taking the higher order
    12 bits (2^12 = 4096) of the lower order 24 bits of the product
    key * Multiplier where
        Multiplier = floor(A * pow(2.0, (double) w));
        double A = 0.6125423371;    (chosen according to Knuth)
        w = 24 (the key's width in bits)
    The algorithm for this is in Cormen/Leiserson/Rivest.

    To do the multplication efficiently, the product c*Multiplier is
    precomputed and stored in lookup_array1 (for all 256 possible c's).
    lookup_array2 and lookup_array3 contain the same data as lookup_array1
    but shifted left 8 and 16 bits respectively.

    MultHash1 is the mult hashing function. MultHash0 contains an older
    (slower but less space-efficient) version of the same function.
*/


#define MULTHASH1(c1,c2,c3) \
        ((lookup_array1[c1]+ \
          lookup_array2[c2]+ \
          lookup_array3[c3]  ) & 0x00fff000) >> 12


/*
USHORT  xorlookup1 [256] = {
        0x110, 0x120, 0x130, 0x140, 0x150, 0x160, 0x170, 0x180, // 0-7
        0x190, 0x1a0, 0x1b0, 0x1c0, 0x1d0, 0x1e0, 0x1f0, 0x100, // 8-15
        0x210, 0x220, 0x230, 0x240, 0x250, 0x260, 0x270, 0x280, // 16-23
        0x290, 0x2a0, 0x2b0, 0x2c0, 0x2d0, 0x2e0, 0x2f0, 0x200, // 24-31
        0x310, 0x320, 0x330, 0x340, 0x350, 0x360, 0x370, 0x380, // 32-39
        0x390, 0x3a0, 0x3b0, 0x3c0, 0x3d0, 0x3e0, 0x3f0, 0x300, // 40-47
        0x410, 0x420, 0x430, 0x440, 0x450, 0x460, 0x470, 0x480, // 48-55
        0x490, 0x4a0, 0x4b0, 0x4c0, 0x4d0, 0x4e0, 0x4f0, 0x400, // 56-63
        0x510, 0x520, 0x530, 0x540, 0x550, 0x560, 0x570, 0x580, // 64-71
        0x590, 0x5a0, 0x5b0, 0x5c0, 0x5d0, 0x5e0, 0x5f0, 0x500, // 72-79
        0x610, 0x620, 0x630, 0x640, 0x650, 0x660, 0x670, 0x680, // 80-87
        0x690, 0x6a0, 0x6b0, 0x6c0, 0x6d0, 0x6e0, 0x6f0, 0x600, // 88-95
        0x710, 0x720, 0x730, 0x740, 0x750, 0x760, 0x770, 0x780, // 96-103
        0x790, 0x7a0, 0x7b0, 0x7c0, 0x7d0, 0x7e0, 0x7f0, 0x700, // 104-111
        0x810, 0x820, 0x830, 0x840, 0x850, 0x860, 0x870, 0x880, // 112-119
        0x890, 0x8a0, 0x8b0, 0x8c0, 0x8d0, 0x8e0, 0x8f0, 0x800, // 120-127
        0x910, 0x920, 0x930, 0x940, 0x950, 0x960, 0x970, 0x980, // 128-135
        0x990, 0x9a0, 0x9b0, 0x9c0, 0x9d0, 0x9e0, 0x9f0, 0x900, // 136-143
        0xa10, 0xa20, 0xa30, 0xa40, 0xa50, 0xa60, 0xa70, 0xa80, // 144-151
        0xa90, 0xaa0, 0xab0, 0xac0, 0xad0, 0xae0, 0xaf0, 0xa00, // 152-159
        0xb10, 0xb20, 0xb30, 0xb40, 0xb50, 0xb60, 0xb70, 0xb80, // 160-167
        0xb90, 0xba0, 0xbb0, 0xbc0, 0xbd0, 0xbe0, 0xbf0, 0xb00, // 168-175
        0xc10, 0xc20, 0xc30, 0xc40, 0xc50, 0xc60, 0xc70, 0xc80, // 176-183
        0xc90, 0xca0, 0xcb0, 0xcc0, 0xcd0, 0xce0, 0xcf0, 0xc00, // 184-191
        0xd10, 0xd20, 0xd30, 0xd40, 0xd50, 0xd60, 0xd70, 0xd80, // 192-199
        0xd90, 0xda0, 0xdb0, 0xdc0, 0xdd0, 0xde0, 0xdf0, 0xd00, // 200-207
        0xe10, 0xe20, 0xe30, 0xe40, 0xe50, 0xe60, 0xe70, 0xe80, // 208-215
        0xe90, 0xea0, 0xeb0, 0xec0, 0xed0, 0xee0, 0xef0, 0xe00, // 216-223
        0xf10, 0xf20, 0xf30, 0xf40, 0xf50, 0xf60, 0xf70, 0xf80, // 224-231
        0xf90, 0xfa0, 0xfb0, 0xfc0, 0xfd0, 0xfe0, 0xff0, 0xf00, // 232-239
        0x010, 0x020, 0x030, 0x040, 0x050, 0x060, 0x070, 0x080, // 240-247
        0x090, 0x0a0, 0x0b0, 0x0c0, 0x0d0, 0x0e0, 0x0f0, 0x000 }; // 248-255


USHORT  xorlookup2 [256] = {
        0x101, 0x201, 0x301, 0x401, 0x501, 0x601, 0x701, 0x801, // 0-7
        0x901, 0xa01, 0xb01, 0xc01, 0xd01, 0xe01, 0xf01, 0x001, // 8-15
        0x102, 0x202, 0x302, 0x402, 0x502, 0x602, 0x702, 0x802, // 16-23
        0x902, 0xa02, 0xb02, 0xc02, 0xd02, 0xe02, 0xf02, 0x002, // 24-31
        0x103, 0x203, 0x303, 0x403, 0x503, 0x603, 0x703, 0x803, // 32-39
        0x903, 0xa03, 0xb03, 0xc03, 0xd03, 0xe03, 0xf03, 0x003, // 40-47
        0x104, 0x204, 0x304, 0x404, 0x504, 0x604, 0x704, 0x804, // 48-55
        0x904, 0xa04, 0xb04, 0xc04, 0xd04, 0xe04, 0xf04, 0x004, // 56-63
        0x105, 0x205, 0x305, 0x405, 0x505, 0x605, 0x705, 0x805, // 64-71
        0x905, 0xa05, 0xb05, 0xc05, 0xd05, 0xe05, 0xf05, 0x005, // 72-79
        0x106, 0x206, 0x306, 0x406, 0x506, 0x606, 0x706, 0x806, // 80-87
        0x906, 0xa06, 0xb06, 0xc06, 0xd06, 0xe06, 0xf06, 0x006, // 88-95
        0x107, 0x207, 0x307, 0x407, 0x507, 0x607, 0x707, 0x807, // 96-103
        0x907, 0xa07, 0xb07, 0xc07, 0xd07, 0xe07, 0xf07, 0x007, // 104-111
        0x108, 0x208, 0x308, 0x408, 0x508, 0x608, 0x708, 0x808, // 112-119
        0x908, 0xa08, 0xb08, 0xc08, 0xd08, 0xe08, 0xf08, 0x008, // 120-127
        0x109, 0x209, 0x309, 0x409, 0x509, 0x609, 0x709, 0x809, // 128-135
        0x909, 0xa09, 0xb09, 0xc09, 0xd09, 0xe09, 0xf09, 0x009, // 136-143
        0x10a, 0x20a, 0x30a, 0x40a, 0x50a, 0x60a, 0x70a, 0x80a, // 144-151
        0x90a, 0xa0a, 0xb0a, 0xc0a, 0xd0a, 0xe0a, 0xf0a, 0x00a, // 152-159
        0x10b, 0x20b, 0x30b, 0x40b, 0x50b, 0x60b, 0x70b, 0x80b, // 160-167
        0x90b, 0xa0b, 0xb0b, 0xc0b, 0xd0b, 0xe0b, 0xf0b, 0x00b, // 168-175
        0x10c, 0x20c, 0x30c, 0x40c, 0x50c, 0x60c, 0x70c, 0x80c, // 176-183
        0x90c, 0xa0c, 0xb0c, 0xc0c, 0xd0c, 0xe0c, 0xf0c, 0x00c, // 184-191
        0x10d, 0x20d, 0x30d, 0x40d, 0x50d, 0x60d, 0x70d, 0x80d, // 192-199
        0x90d, 0xa0d, 0xb0d, 0xc0d, 0xd0d, 0xe0d, 0xf0d, 0x00d, // 200-207
        0x10e, 0x20e, 0x30e, 0x40e, 0x50e, 0x60e, 0x70e, 0x80e, // 208-215
        0x90e, 0xa0e, 0xb0e, 0xc0e, 0xd0e, 0xe0e, 0xf0e, 0x00e, // 216-223
        0x10f, 0x20f, 0x30f, 0x40f, 0x50f, 0x60f, 0x70f, 0x80f, // 224-231
        0x90f, 0xa0f, 0xb0f, 0xc0f, 0xd0f, 0xe0f, 0xf0f, 0x00f, // 232-239
        0x000, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800, // 240-247
        0x900, 0xa00, 0xb00, 0xc00, 0xd00, 0xe00, 0xf00, 0x100 }; // 248-255

*/

/* Bitptrs point to the current byte. The current bit (i.e. next bit to be
 * stored) is masked off by the bit entry. When this reaches zero, it is
 * reset to 0x80 and the next byte is set up. The bytes are filled MSBit
 * first. */

/* Starts and sets the first byte to zero for the bitptr. */
#define bitptr_init(s)  pbyte = s; byte=0; bit = 16;

/* Sets up the byte part of the bitptr so that it is pointing to the byte after
 * the byte which had the last bit  put into it. */
#define bitptr_end() if (bit != 16) *pbyte++=(UCHAR)(byte >> 8);

/* Goes to the next bit, and byte if necessary. */
#define bitptr_next()                  \
        if (bit < 10) {                \
          *pbyte++=(UCHAR)(byte >> 8); \
          byte <<= 8;                  \
          bit = 16;                    \
        } else                         \
            bit-- ;

/*
#define bitptr_next()                  \
        bit--;                         \
        if (bit < 9) {                 \
          *pbyte++=(UCHAR)(byte >> 8); \
          byte <<= 8;                  \
          bit = 16;                    \
        }
*/


/*  Advances to the next bit, and byte if necessary, readjusting the bit. */
#define bitptr_advance()               \
        if (bit < 9) {                 \
          *pbyte++=(UCHAR)(byte >> 8); \
          bit+=8;                      \
          byte <<= 8;                  \
        }


/* BIT I/O FUNCTIONS *********************************************************/

/* These routines output most-significant-bit-first and the input will return
 * them MSB first, too. */

/* Outputs a one bit in the bit stream. */
#define out_bit_1() bit--; byte |= (1 << bit); bitptr_advance();
#define out_bit_0() bitptr_next();

/* TestBit; output 1 if that bit is set */
//#define tb(b,w,n) if ((w) & (n)) *pbyte |= bit; bitptr_next(b);

#define out_bits_2(w) bit-=2; byte|=(w << bit); bitptr_advance();
#define out_bits_3(w) bit-=3; byte|=(w << bit); bitptr_advance();
#define out_bits_4(w) bit-=4; byte|=(w << bit); bitptr_advance();
#define out_bits_5(w) bit-=5; byte|=(w << bit); bitptr_advance();
#define out_bits_6(w) bit-=6; byte|=(w << bit); bitptr_advance();
#define out_bits_7(w) bit-=7; byte|=(w << bit); bitptr_advance();

// #define out_bits_8(w) bit-=8; byte|=(w << bit); bit+=8; *pbyte++=(UCHAR)(byte >> 8); byte <<= 8;
#define out_bits_8(w) byte|=(w << (bit-8)); *pbyte++=(UCHAR)(byte >> 8); byte <<= 8;


/*
#define out_bits_9(w)              \
     if (bit > 9) {                \
       bit-=9; byte|=(w << bit);   \
       *pbyte++=(UCHAR)(byte >> 8);\
       bit+=8;                     \
       byte <<= 8;                 \
     } else {                      \
       bit=16; byte |= w;          \
       *pbyte++=(UCHAR)(byte >> 8); *pbyte++=(UCHAR)(byte); byte=0; \
     }
*/

#define out_bits_9(w)              \
     if (bit > 9) {                \
       byte|=(w << (bit-9));       \
       *pbyte++=(UCHAR)(byte >> 8);\
       bit--;                      \
       byte <<= 8;                 \
     } else {                      \
       bit=16; byte |= w;          \
       *pbyte++=(UCHAR)(byte >> 8); *pbyte++=(UCHAR)(byte); byte=0; \
     }


#define out_bits_10(w)             \
     if (bit > 10) {               \
       bit-=10; byte |= (w << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
     } else {                      \
       out_bits_2((w >> 8));       \
       out_bits_8((w & 0xFF));     \
     }

//
// Weird effect - if out_bits_9 used instead of out_bits_8,
// it's faster!  if (bit == 11) is faster than if (bit != 11).
//

#define out_bits_11(w)             \
     if (bit > 11) {               \
        bit-=11; byte |= (w << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
     } else {                      \
        if (bit == 11) {           \
          bit=16; byte |= w;       \
          *pbyte++=(UCHAR)(byte >> 8); *pbyte++=(UCHAR)(byte); byte=0; \
        } else {                   \
          bit=11-bit;              \
          byte|=(w >> bit);        \
          *pbyte++=(UCHAR)(byte >> 8); *pbyte++=(UCHAR)(byte); \
          bit=16-bit;              \
          byte=(w << bit);         \
        }                          \
     }


#define out_bits_12(w)             \
     if (bit > 12) {               \
        bit-=12; byte |= (w << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
     } else {                      \
        out_bits_4((w >> 8));      \
        out_bits_8((w & 0xFF));    \
     }
    
#define out_bits_13(w)             \
     if (bit > 13) {               \
        bit-=13; byte |= (w << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
     } else {                      \
        out_bits_5((w >> 8));      \
        out_bits_8((w & 0xFF));    \
     }

#define out_bits_14(w)             \
     if (bit > 14) {               \
        bit-=14; byte |= (w << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
     } else {                      \
        out_bits_6((w >> 8));      \
        out_bits_8((w & 0xFF));    \
     }


#define out_reserve_4()            \
     bit-=4; bitptr_advance();


/* Starts the given bit pointer */
#define inbit_start(s) pbyte = s; bit = 16; byte=(*pbyte << 8) + *(pbyte+1); pbyte++;
#define inbit_end()      if (bit != 16) pbyte++;    

#define in_bit_next()    if (bit < 9) {          \
                            bit=16;              \
                            byte <<=8;           \
                            byte |= *(++pbyte);  \
                         }


#define in_bit_advance() if (bit < 9) {          \
                            bit+=8;              \
                            byte <<=8;           \
                            byte |= *(++pbyte);  \
                         }

/* Returns non-zero in bitset if the next bit in the stream is a 1. */
#define in_bit()     bit--; bitset = (byte >> bit) & 1; in_bit_next()


#define in_bits_2(w) bit-=2; w = (byte >> bit) & 0x03;\
                     in_bit_advance();

#define in_bits_3(w) bit-=3; w = (byte >> bit) & 0x07;\
                     in_bit_advance();

#define in_bits_4(w) bit-=4; w = (byte >> bit) & 0x0F;\
                     in_bit_advance();

#define in_bits_5(w) bit-=5; w = (byte >> bit) & 0x1F;\
                     in_bit_advance();

#define in_bits_6(w) bit-=6; w = (byte >> bit) & 0x3F;\
                     in_bit_advance();

#define in_bits_7(w) bit-=7; w = (byte >> bit) & 0x7F;\
                     in_bit_advance();

#define in_bits_8(w) bit-=8; w = (byte >> bit) & 0xFF;\
                     bit+=8; byte <<=8; byte |= *(++pbyte);


#define in_bits_9(w) bit-=9; w = (byte >> bit) & 0x1FF;          \
                     bit+=8; byte <<=8; byte |= *(++pbyte);      \
                     in_bit_advance();

#define in_bits_10(w) if (bit > 10) {                            \
                        bit-=10; w = (byte >> bit) & 0x3FF;      \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                   \
                        in_bits_2(bitset);                       \
                        in_bits_8(w);                            \
                        w= w + (bitset << 8);                    \
                      }

#define in_bits_11(w) if (bit > 11) {                            \
                        bit-=11; w = (byte >> bit) & 0x7FF;      \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                   \
                        in_bits_3(bitset);                       \
                        in_bits_8(w);                            \
                        w= w + (bitset << 8);                    \
                      }


#define in_bits_12(w) if (bit > 12) {                            \
                        bit-=12; w = (byte >> bit) & 0xFFF;      \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                   \
                        in_bits_4(bitset);                       \
                        in_bits_8(w);                            \
                        w= w + (bitset << 8);                    \
                      }



#define in_bits_13(w)\
                      if (bit > 13) {                            \
                        bit-=13; w = (byte >> bit) & 0x1FFF;     \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                   \
                        in_bits_5(bitset);                       \
                        in_bits_8(w);                            \
                        w=w + (bitset << 8);                     \
                      }


#define in_bits_14(w)\
                      if (bit > 14) {                            \
                        bit-=14; w = (byte >> bit) & 0x3FFF;     \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                   \
                        in_bits_6(bitset);                       \
                        in_bits_8(w);                            \
                        w=w + (bitset << 8);                     \
                      }



UCHAR   SHApad1[40] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
UCHAR   SHApad2[40] = {0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
                       0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
                       0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
                       0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2};

PUCHAR  ClntSSrvR = "On the client side, this is the send key; on the server side, it is the receive key.";
PUCHAR  ClntRSrvS = "On the client side, this is the receive key; on the server side, it is the send key.";
#define ECP_STRING_LEN strlen(ClntSSrvR)

#ifdef DEBUG
char
ChPrint(UCHAR b)
{
    if (isprint(b))
        return (char)b;
    else
        return '.';
}
#endif


//* compress()
//
//  Function:   Main compression function.
//
//  Parameters:
//      IN  CurrentBuffer -> points to NDIS_WAN_PACKET with data to compress
//      OUT CompOutBuffer -> points to NDIS_WAN_PACKET to compress data to
//      IN  CurrentLength -> points to Length of data to compress
//      IN  context -> connection compress context
//
//  Returns:    Nothing
//
//  WARNING:    CODE IS HIGHLY OPTIMIZED FOR TIME.
//
//
UCHAR
compress (UCHAR *CurrentBuffer, UCHAR *CompOutBuffer, ULONG *CurrentLength, SendContext *context)
{
    int     copylen ;
    int     bit;
    int     byte;
    int     backptr ;
    int     cbMatch;
    int     hashvalue ;
    int     lookup1 ;
    UCHAR    *matchptr ;
    UCHAR   *pbyte;
    UCHAR   *historyptr ;
    UCHAR   *currentptr ;
    UCHAR   *endptr ;
    UCHAR   hashchar1;
    UCHAR   hashchar2;
    UCHAR   hashchar3;
    int    literal ;
    UCHAR   status=0;   // return flags
    PUCHAR  currentbuf ;


    // Will this packet fit at the end of the history buffer?
    //
    if (((context->CurrentIndex + *CurrentLength) >= (HISTORY_MAX - 1 )) ||
        (context->CurrentIndex == 0)) {
        context->CurrentIndex = 0;   // Index into the history
        status |= PACKET_AT_FRONT;
    }

    //
    // we no longer need to save the non compressed data - tonybe 01-12-95
    //
//    RtlMoveMemory(context->CompressBuffer, CurrentBuffer, *CurrentLength) ;

    // Start out the bit pointing output
    //
    bitptr_init(CompOutBuffer);

    //
    // We are now compressing into an output buffer - tonybe 01-12-95
    //
//    bitptr_init(CurrentBuffer);

    historyptr = context->History + context->CurrentIndex ;

    currentptr = CurrentBuffer;

    //
    // we are now compressing from the currentbuffer - tonybe 01-12-95
    //
//    currentptr = context->CompressBuffer ;

    endptr = currentptr + *CurrentLength - 1;

    while (currentptr < (endptr-2)) {

        *historyptr++ = hashchar1 = *currentptr++ ;
        hashchar2 = *currentptr ;
        hashchar3 = *(currentptr+1) ;

        // "fast" hash function
        // hashvalue = (int)hashchar1 ^ xorlookup1[hashchar2] ^ xorlookup2[hashchar3];
        hashvalue = MULTHASH1(hashchar1, hashchar2, hashchar3) ;

        matchptr = context->History  + context->HashTable[hashvalue] ;

        if (matchptr != (historyptr - 1))
            context->HashTable[hashvalue] = (USHORT)(historyptr - context->History) ;

        if (context->ValidHistory < historyptr)
            context->ValidHistory = historyptr ;

        if (matchptr != context->History &&
            *(matchptr-1) == hashchar1 && *matchptr  == hashchar2 &&
            *(matchptr+1) == hashchar3 && matchptr    != (historyptr - 1) &&
            matchptr      != historyptr  && (matchptr+1)  <= context->ValidHistory) {

            backptr = ((int)(historyptr - matchptr)) & (HISTORY_SIZE - 1) ;

            *historyptr++ = hashchar2 ;     // copy the other 2 chars
            *historyptr++ = hashchar3 ;     // copy the other 2 chars
            currentptr  +=2 ;
            cbMatch = 3 ;           // length of match
            matchptr    +=2 ; // we have already matched 3

            while ((*matchptr == *currentptr) && (currentptr < endptr) && (matchptr <= context->ValidHistory)) {
                matchptr++ ;
                *historyptr++ = *currentptr++ ;
                cbMatch++ ;
            }

            // First output the backpointer
            //
            if (backptr >= 320) {
                backptr -= 320 ;
                out_bits_8((0xc000 + backptr) >> 8) ;   // 110 + 13 bits
                out_bits_8((backptr)) ;
            } else if (backptr < 64) {          // 1111 + 6 bits
                backptr += 0x3c0 ;
                out_bits_10(backptr);
            } else  {
                backptr += (0xE00 - 64);        // 1110 + 8 bits
                out_bits_12(backptr);
            }

            // output the length of the match encoding
            //
            switch (cbMatch) {
    
                case 3:
                    out_bit_0();    // length of 3 - most common
                    break;
    
                case 4:
                    out_bits_4(8);
                    break;
    
                case 5:
                    out_bits_4(9);
                    break;
    
                case 6:
                    out_bits_4(10);
                    break;
    
                case 7:
                    out_bits_4(11);
                    break;
    
                case 8:
                    out_bits_6(48);
                    break;
    
                case 9:
                    out_bits_6(49);
                    break;
    
                case 10:
                    out_bits_6(50);
                    break;
    
                case 11:
                    out_bits_6(51);
                    break;
    
                case 12:
                    out_bits_6(52);
                    break;
    
                case 13:
                    out_bits_6(53);
                    break;
    
                case 14:
                    out_bits_6(54);
                    break;
    
                case 15:
                    out_bits_6(55);
                    break;
    
                case 16:
                    out_bits_8(0xe0);
                    break;
    
                case 17:
                    out_bits_8(0xe1);
                    break;
    
                case 18:
                    out_bits_8(0xe2);
                    break;
    
                case 19:
                    out_bits_8(0xe3);
                    break;
    
                case 20:
                    out_bits_8(0xe4);
                    break;
    
                case 21:
                    out_bits_8(0xe5);
                    break;
    
                case 22:
                    out_bits_8(0xe6);
                    break;
    
                case 23:
                    out_bits_8(0xe7);
                    break;
    
                case 24:
                    out_bits_8(0xe8);
                    break;
    
                case 25:
                    out_bits_8(0xe9);
                    break;
    
                case 26:
                    out_bits_8(0xea);
                    break;
    
                case 27:
                    out_bits_8(0xeb);
                    break;
    
                case 28:
                    out_bits_8(0xec);
                    break;
    
                case 29:
                    out_bits_8(0xed);
                    break;
    
                case 30:
                    out_bits_8(0xee);
                    break;
    
                case 31:
                    out_bits_8(0xef);
                    break;
    
                default:
                    if (cbMatch < 64) {
                        out_bits_4(0xF) ;
                        cbMatch -= 32 ;
                        out_bits_6(cbMatch) ;
                    }
                    else if (cbMatch < 128) {
                        out_bits_5(0x1F) ;
                        cbMatch -= 64 ;
                        out_bits_7(cbMatch) ;
                    }
                    else if (cbMatch < 256) {
                        out_bits_6(0x3F) ;
                        cbMatch -= 128 ;
                        out_bits_8(cbMatch) ;
                    }
                    else if (cbMatch < 512) {
                        out_bits_7(0x7F) ;
                        cbMatch -= 256 ;
                        out_bits_9(cbMatch) ;
                    }
                    else if (cbMatch < 1024) {
                        out_bits_8(0xFF) ;
                        cbMatch -= 512 ;
                        out_bits_10(cbMatch) ;
                    }
                    else if (cbMatch < 2048) {
                        out_bits_9(0x1FF) ;
                        cbMatch -= 1024 ;
                        out_bits_11(cbMatch) ;
                    }
                    else if (cbMatch < 4096) {
                        out_bits_10(0x3FF) ;
                        cbMatch -= 2048 ;
                        out_bits_12(cbMatch) ;
                    }
                    else if (cbMatch < 8192) {
                        out_bits_11(0x7FF) ;
                        cbMatch -= 4096 ;
                        out_bits_13(cbMatch) ;
                    }
                    else  {             // 8192 and greater
                        out_bits_12(0xFFF) ;
                        cbMatch -= 8192 ;
                        out_bits_14(cbMatch) ;
                    }
                    break ;
            }

        } else {    // encode a literal

            // temp=literallookup[context->History[i-1]] ;
            literal= hashchar1 ;

            if (literal & 0x80) {
                literal += 0x80;
                out_bits_9(literal) ;
            } else {
                out_bits_8(literal) ;
            }

        }

    }  // while


    // get any remaining chars as literals
    while (currentptr <= endptr) {

        // temp=literallookup[context->History[i-1]] ;
        literal=*currentptr ;


        if (literal & 0x80) {
            literal += 0x80;
            out_bits_9(literal) ;
        } else {
            out_bits_8(literal) ;
        }

        *historyptr++ = *currentptr++ ;
    }


    bitptr_end() ;


    // Check if we had expansion instead of compression
    //
    if ((ULONG)(pbyte - CompOutBuffer) > *CurrentLength) { // expansion.

        //
        // We don't need to do this copy since we can just signal the outside world
        // that compression did not take place and the valid data is still in the
        // current buffer
        //
        // RtlMoveMemory(CompOutBuffer, CurrentBuffer, *CurrentLength) ;

        memset (context->History, 0, sizeof(context->History)) ;
        memset (context->HashTable, 0, sizeof(context->HashTable)) ;
#ifdef COMP_12K
        status = 0 ;
#else
        status = PACKET_FLUSHED;
#endif
        context->CurrentIndex = HISTORY_SIZE+1 ; // this forces a start over next time

    } else {     // compression successful

        *CurrentLength = (ULONG)(pbyte - CompOutBuffer);

        //
        // the compressed data is now in CompOutBuffer - tonybe 01-12-95
        //
        //  *CurrentLength = pbyte - CurrentBuffer ;

        status |= PACKET_COMPRESSED ;
        context->CurrentIndex = (int)(historyptr - context->History) ;
    }

    return(status);
}



//* getcontextsizes()
//
//  Function:   Returns size of send and receive context blocks
//
//  Parameters: OUT send -> sizeof(SendContext)
//      OUT recv -> sizeof(RecvContext)
//
//  Returns:    Nothing
//
//*
void
getcontextsizes (long *send, long *recv)
{
    *send = sizeof(SendContext) ;
    *recv = sizeof(RecvContext) ;
}


//* initsendcontext()
//
//  Function:   Initialize SendContext block
//
//  Parameters: IN  context -> connection compress context
//
//  Returns:    Nothing
//
//*
void
initsendcontext (SendContext *context)
{
    context->CurrentIndex = 0;   // Index into the history
    context->ValidHistory = 0 ;  // reset valid history
    memset (context->HashTable, 0, sizeof(context->HashTable)) ;
    memset (context->History, 0, sizeof(context->HashTable)) ;
}



//* initrecvcontext()
//
//  Function:   Initialize RecvContext block
//
//  Parameters: IN  context -> connection decompress context
//
//  Returns:    Nothing
//
//*
void
initrecvcontext (RecvContext *context)
{
    context->CurrentPtr = context->History ;

#if DBG
    context->DebugFence = DEBUG_FENCE_VALUE;
#endif

    memset (context->History, 0, sizeof(context->History)) ;
}



//* decompress()
//
//  Function:   de-compression function.
//
//  Parameters: IN     inbuf -> points to data to be uncompressed
//      IN     inlen -> length of data
//      IN     start -> flag indicating whether to start with a clean history buffer
//      OUT    output-> decompressed data
//      OUT    outlen-> lenght of decompressed data
//      IN     context -> connection decompress context
//
//  Returns:    TRUE  if decompress was successful
//              FALSE if it wasnt
//
//  WARNING:    CODE IS HIGHLY OPTIMIZED FOR TIME.
//
//*
int
decompress(
    UCHAR *inbuf,
    int inlen,
    int start,
    UCHAR **output,
    int *outlen,
    RecvContext *context)
{
    UCHAR   *inend;             // When we know we're done decompressing
    UCHAR   *outstart;          // Remember where in dbuf we started

    UCHAR   *current;

    int     backptr;            // Back pointer for copy items
    int     length;             // Where to copy from in dbuf

    UCHAR   *s1, *s2;

    int     bitset;
    int     bit;
    int     byte;
    UCHAR   *pbyte;
    UCHAR   *historyend = context->History + HISTORY_SIZE ;

    inend = inbuf + inlen ;

    //
    // Start out looking at the first bit
    //
    inbit_start(inbuf);

    if (start)      // start over clean?
    context->CurrentPtr = current = context->History ;
    else
    current = context->CurrentPtr ;

    //
    // Save our starting position
    //
    outstart = current;

    //
    // Decompress until we run out of input
    //
    while (pbyte < inend) {

    //
    // Jump on what to do with these three bits.
    //
    in_bits_3(length);

    switch (length) {

    case 0:
        in_bits_5(length) ;
        goto LITERAL ;

    case 1:
        in_bits_5(length) ;
        length += 32 ;
        goto LITERAL ;

    case 2:
        in_bits_5(length) ;
        length += 64 ;
        goto LITERAL ;

    case 3:
        in_bits_5(length) ;
        length += 96 ;
        goto LITERAL ;

    case 4:
        in_bits_6(length) ;
        length +=128 ;
        goto LITERAL ;

    case 5:
        in_bits_6(length) ;
        length +=192 ;
        goto LITERAL ;

    case 6:
        in_bits_13 (backptr) ;      // 110 - 14 bit offset
        backptr+=320 ;
        break ;

    case 7:
        in_bit() ;
        if (bitset) {
        in_bits_6(backptr) ;
        } else {
        in_bits_8(backptr) ;
        backptr+=64 ;
        }
        break ;
    }

    //
    // If we reach here, it's a copy item
    //

    //
    // Now get the length
    //

    in_bit() ;  // 1st length bit
    if (!bitset) {
        length = 3 ;
        goto DONE ;
    }

    in_bit() ;  // 2nd length bit
    if (!bitset) {
        in_bits_2 (length) ;
        length += 4 ;
        goto DONE ;
    }

    in_bit() ; // 3rd length bit
    if (!bitset) {
        in_bits_3 (length) ;
        length += 8 ;
        goto DONE ;
    }

    in_bit() ; // 4th length bit
    if (!bitset) {
        in_bits_4 (length) ;
        length += 16 ;
        goto DONE ;
    }

    in_bit() ; // 5th length bit
    if (!bitset) {
        in_bits_5 (length) ;
        length += 32 ;
        goto DONE ;
    }

    in_bit() ; // 6th length bit
    if (!bitset) {
        in_bits_6 (length) ;
        length += 64 ;
        goto DONE ;
    }

    in_bit() ; // 7th length bit
    if (!bitset) {
        in_bits_7 (length) ;
        length += 128 ;
        goto DONE ;
    }

    in_bit() ; // 8th length bit
    if (!bitset) {
        in_bits_8 (length) ;
        length += 256 ;
        goto DONE ;
    }

    in_bit() ; // 9th length bit
    if (!bitset) {
        in_bits_9 (length) ;
        length += 512 ;
        goto DONE ;
    }

    in_bit() ; // 10th length bit
    if (!bitset) {
        in_bits_10 (length) ;
        length += 1024 ;
        goto DONE ;
    }

    //
    // length cannot be greater than max packets size which is 1500
    //
#if DBG
    DbgPrint("NDISWAN: RAS Decompressor problem1: Possible data corruption\n");
#endif

    return FALSE ;


    DONE:
    //
    // Turn the backptr into an index location
    //
#ifdef COMP_12K
    s2 = current - backptr ;
#else
    s2 = context->History + (((current - context->History) - backptr) & (HISTORY_SIZE -1)) ;
#endif

    s1 = current;

    current += length;

    // if we are past the end of the history this is a bad sign: abort decompression
    //
    if (current >= historyend) {
#if DBG
        DbgPrint("NDISWAN: RAS Decompressor problem2: Possible data corruption\n");
#endif
        return FALSE ;
    }

    // loop unrolled to handle lenght>backptr case
    //
    *s1=*s2;
    *(s1+1)=*(s2+1);
    s1+=2;
    s2+=2;
    length-=2;

    //
    // copy all the bytes
    //
    while (length) {
        *s1++=*s2++;
        length--;
    }

    //
    // We have another copy item, and no literals
    //
    continue;


    LITERAL:

    //
    // We have a literal
    //
    
    if (current >= historyend) {
#if DBG
        DbgPrint("NDISWAN: RAS Decompressor problem3: Possible data corruption\n");
#endif
        return FALSE ;
    }

    //*current++ = literallookup[length];
    *current++ = (UCHAR)length;

    } // while loop


    // End case:
    //
    if (current >= historyend) {
#if DBG
        DbgPrint("NDISWAN: RAS Decompressor problem4: Possible data corruption\n");
#endif
        return FALSE ;
    }

    if ((bit == 16) && (pbyte == inend)) {
    *current++ = *(pbyte -1) ;
    }

#if DBG
    if (context->DebugFence != DEBUG_FENCE_VALUE) {
        DbgPrint("Decompression Error!\n");
        DbgPrint("context %p, current %p, outstart %p\n", context, current, outstart);
        DbgPrint("inbuf %p, inlength %d, start %p\n", inbuf, inlen, start);
        DbgBreakPoint();
    }
#endif

    *outlen = (int)(current - outstart) ; // the length of decompressed data

    *output = context->CurrentPtr ;

    context->CurrentPtr = current ;

    return TRUE ;
}


//
// This function uses the 16 byte user session key and the 8 byte
// challenge to create an intial 16 byte encryption session key.
//
VOID
GetStartKeyFromSHA(
    PCRYPTO_INFO    CryptoInfo,
    PUCHAR          Challenge
    )
{
    UCHAR   Digest[A_SHA_DIGEST_LEN];
    UCHAR   SessionKeyChallenge[MAX_USERSESSIONKEY_SIZE + MAX_CHALLENGE_SIZE];

    NdisZeroMemory(Digest, A_SHA_DIGEST_LEN);

    //
    // Copy the start session key
    //
    NdisMoveMemory(SessionKeyChallenge,
                   CryptoInfo->StartKey,
                   MAX_USERSESSIONKEY_SIZE);

    //
    // Append the challenge
    //
    NdisMoveMemory((PUCHAR)(SessionKeyChallenge + MAX_USERSESSIONKEY_SIZE),
                   Challenge,
                   MAX_CHALLENGE_SIZE);

//
// SHAInit(context)
// SHAUpdate(context, sessionkey, sessionkeylength)
// SHAUpdate(context, sessionkeychallenge, sessionkeylength + challengelength)
// SHAFinal(context, digest)
//
// Start key is the first 16 bytes of the digest.
//
    A_SHAInit(CryptoInfo->Context);

    A_SHAUpdate(CryptoInfo->Context,
                CryptoInfo->StartKey,
                MAX_USERSESSIONKEY_SIZE);

    A_SHAUpdate(CryptoInfo->Context,
                SessionKeyChallenge,
                MAX_USERSESSIONKEY_SIZE + MAX_CHALLENGE_SIZE);

    A_SHAFinal(CryptoInfo->Context,
               Digest);

    NdisMoveMemory(CryptoInfo->StartKey,
                   Digest,
                   CryptoInfo->SessionKeyLength);

    NdisMoveMemory(CryptoInfo->SessionKey,
                   Digest,
                   CryptoInfo->SessionKeyLength);
}

VOID
GetNewKeyFromSHA(
    PCRYPTO_INFO    CryptoInfo
    )
{
    UCHAR   Digest[A_SHA_DIGEST_LEN];

    NdisZeroMemory(Digest, A_SHA_DIGEST_LEN);

    A_SHAInit(CryptoInfo->Context);
    A_SHAUpdate(CryptoInfo->Context,
                CryptoInfo->StartKey,
                CryptoInfo->SessionKeyLength);
    A_SHAUpdate(CryptoInfo->Context,
                SHApad1,
                40);
    A_SHAUpdate(CryptoInfo->Context,
                CryptoInfo->SessionKey,
                CryptoInfo->SessionKeyLength);
    A_SHAUpdate(CryptoInfo->Context,
                SHApad2,
                40);
    A_SHAFinal(CryptoInfo->Context,
               Digest);

    NdisMoveMemory(CryptoInfo->SessionKey,
                   Digest,
                   CryptoInfo->SessionKeyLength);
}

VOID
GetMasterKey(
    PCRYPTO_INFO    CryptoInfo,
    PUCHAR          NTResponse
    )
{
    UCHAR   Digest[A_SHA_DIGEST_LEN];
    PVOID   Context;

    NdisZeroMemory(Digest, A_SHA_DIGEST_LEN);

    Context = CryptoInfo->Context;

    A_SHAInit(Context);

#ifdef DEBUG_CCP
    {
    PUCHAR  Key;

    Key = CryptoInfo->StartKey;

    DbgPrint("GMK-UserSessionKey: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    Key = NTResponse;

    DbgPrint("GMK-NTResponse:     %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    DbgPrint("                    %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[16],Key[17],Key[18],Key[19],
        Key[20],Key[21],Key[22],Key[23]);
    }
#endif

    A_SHAUpdate(Context,
                CryptoInfo->StartKey,
                MAX_USERSESSIONKEY_SIZE);

    A_SHAUpdate(Context,
                NTResponse,
                MAX_NT_RESPONSE);

    A_SHAUpdate(Context,
                "This is the MPPE Master Key",
                27);

    A_SHAFinal(Context, Digest);

    NdisMoveMemory(CryptoInfo->StartKey,
                   Digest,
                   MAX_USERSESSIONKEY_SIZE);

#ifdef DEBUG_CCP
    {
    PUCHAR  Key;

    Key = CryptoInfo->StartKey;

    DbgPrint("MasterKey:      %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    }
#endif

}

VOID
GetAsymetricStartKey(
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    )
{
    UCHAR   Digest[A_SHA_DIGEST_LEN];
    PVOID   Context;
    PUCHAR  s;

    NdisZeroMemory(Digest, A_SHA_DIGEST_LEN);

    Context = CryptoInfo->Context;

    if (IsSend) {
        if (CryptoInfo->Flags & CRYPTO_IS_SERVER) {
            s = ClntRSrvS;
        } else {
            s = ClntSSrvR;
        }
    } else {
        if (CryptoInfo->Flags & CRYPTO_IS_SERVER) {
            s = ClntSSrvR;
        } else {
            s = ClntRSrvS;
        }
    }

#ifdef DEBUG_CCP
    {
    PUCHAR  Key;

    Key = CryptoInfo->StartKey;

    DbgPrint("GASK-StartKey: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    DbgPrint("GASK-String: %s\n", s);
    }
#endif

    A_SHAInit(Context);

    A_SHAUpdate(Context,
                CryptoInfo->StartKey,
                MAX_USERSESSIONKEY_SIZE);

    A_SHAUpdate(Context,SHApad1,40);

    A_SHAUpdate(Context,s,strlen(s));

    A_SHAUpdate(Context,SHApad2,40);

    A_SHAFinal(Context,Digest);

    NdisMoveMemory(CryptoInfo->StartKey,
                   Digest,
                   CryptoInfo->SessionKeyLength);

    NdisMoveMemory(CryptoInfo->SessionKey,
                   Digest,
                   CryptoInfo->SessionKeyLength);

#ifdef DEBUG_CCP
    {
    PUCHAR  Key;

    Key = CryptoInfo->StartKey;

    DbgPrint("%s %s AsymetricKey: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        (CryptoInfo->Flags & CRYPTO_IS_SERVER) ? "Server" : "Client",
        (IsSend) ? "Send" : "Recv",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    }
#endif
}

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

/* SHA initialization. Begins an SHA operation, writing a new context.
 */
void A_SHAInitCommon (context)
A_SHA_COMM_CTX *context;
{
  context->count[0] = context->count[1] = 0;

  /* Load magic initialization constants.
   */
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
  context->state[4] = 0xc3d2e1f0;
}

/* SHA block update operation. Continues an SHA message-digest
     operation, processing another message block, and updating the
     context.
 */
void A_SHAUpdateCommon (context, partIn, partInLen, Transform)
A_SHA_COMM_CTX *context;
unsigned char *partIn;
ULONG partInLen;
A_SHA_TRANSFORM *Transform;
{
  unsigned int bufferLen;

  /* Compute length of buffer */
  bufferLen = (unsigned int)(context->count[1] & 0x3f);

  /* Update number of bytes */
  if ((context->count[1] += partInLen) < partInLen)
    context->count[0]++;

  /* If previous input in buffer, buffer new input and transform if
       possible.
   */
  if (bufferLen > 0 && bufferLen + partInLen >= 64) {
    NdisMoveMemory(context->buffer+bufferLen, partIn, 64-bufferLen);
    partIn += (64-bufferLen);
    partInLen -= (64-bufferLen);
    (*Transform) (context->state, context->buffer);
    bufferLen = 0;
  }

  /* Transform directly from input.
   */
  while (partInLen >= 64) {
    (*Transform) (context->state, partIn);
    partIn += 64;
    partInLen -= 64;
  }

  /* Buffer remaining input */
  NdisMoveMemory((context->buffer+bufferLen), partIn, partInLen);
}

/* SHA finalization. Ends an SHA message-digest operation, writing
     the message digest and zeroizing the context.
 */
void A_SHAFinalCommon (context, digest, Transform)
A_SHA_COMM_CTX *context;
unsigned char digest[A_SHA_DIGEST_LEN];
A_SHA_TRANSFORM *Transform;
{
  ULONG bitCount[2];
  unsigned char pad[72];
  unsigned int padLen;

  /* Compute padding: 80 00 00 ... 00 00 <bit count>
   */
  padLen = 64 - (unsigned int)(context->count[1] & 0x3f);
  if (padLen <= 8)
    padLen += 64;
  pad[0] = 0x80;
  NdisZeroMemory(pad+1, padLen-7);
  bitCount[0] = (context->count[0] << 3) | (context->count[1] >> 29);
  bitCount[1] = context->count[1] << 3;
  ByteReverse ((UNALIGNED ULONG*)(pad+padLen-8), bitCount, 2);

  /* Digest padding */
  A_SHAUpdateCommon (context, pad, padLen, Transform);

  /* Store digest */
  ByteReverse ((UNALIGNED ULONG*)digest, context->state, 5);

  /* Restart the context */
  A_SHAInitCommon (context);
}

void A_SHAInit (A_SHA_CTX *context)
{
  A_SHAInitCommon (&context->commonContext);
}

void A_SHAUpdate (context, partIn, partInLen)
A_SHA_CTX *context;
unsigned char *partIn;
unsigned int partInLen;
{
  A_SHAUpdateCommon (&context->commonContext, partIn, partInLen, SHATransform);
}

void A_SHAFinal (context, digest)
A_SHA_CTX *context;
unsigned char digest[A_SHA_DIGEST_LEN];
{
  A_SHAFinalCommon (&context->commonContext, digest, SHATransform);
}

void SHATransform (state, block)
ULONG state[5];
unsigned char block[64];
{
  ULONG a = state[0], b = state[1], c = state[2], d = state[3],
    e = state[4], x[80];

  ByteReverse (x, (ULONG*)block, 16);
  SHAExpand (x);

  /* Round 1 */
  FF (a, b, c, d, e, x[ 0]);
  FF (e, a, b, c, d, x[ 1]);
  FF (d, e, a, b, c, x[ 2]);
  FF (c, d, e, a, b, x[ 3]);
  FF (b, c, d, e, a, x[ 4]);
  FF (a, b, c, d, e, x[ 5]);
  FF (e, a, b, c, d, x[ 6]);
  FF (d, e, a, b, c, x[ 7]);
  FF (c, d, e, a, b, x[ 8]);
  FF (b, c, d, e, a, x[ 9]);
  FF (a, b, c, d, e, x[10]);
  FF (e, a, b, c, d, x[11]);
  FF (d, e, a, b, c, x[12]);
  FF (c, d, e, a, b, x[13]);
  FF (b, c, d, e, a, x[14]);
  FF (a, b, c, d, e, x[15]);
  FF (e, a, b, c, d, x[16]);
  FF (d, e, a, b, c, x[17]);
  FF (c, d, e, a, b, x[18]);
  FF (b, c, d, e, a, x[19]);

  /* Round 2 */
  GG (a, b, c, d, e, x[20]);
  GG (e, a, b, c, d, x[21]);
  GG (d, e, a, b, c, x[22]);
  GG (c, d, e, a, b, x[23]);
  GG (b, c, d, e, a, x[24]);
  GG (a, b, c, d, e, x[25]);
  GG (e, a, b, c, d, x[26]);
  GG (d, e, a, b, c, x[27]);
  GG (c, d, e, a, b, x[28]);
  GG (b, c, d, e, a, x[29]);
  GG (a, b, c, d, e, x[30]);
  GG (e, a, b, c, d, x[31]);
  GG (d, e, a, b, c, x[32]);
  GG (c, d, e, a, b, x[33]);
  GG (b, c, d, e, a, x[34]);
  GG (a, b, c, d, e, x[35]);
  GG (e, a, b, c, d, x[36]);
  GG (d, e, a, b, c, x[37]);
  GG (c, d, e, a, b, x[38]);
  GG (b, c, d, e, a, x[39]);

  /* Round 3 */
  HH (a, b, c, d, e, x[40]);
  HH (e, a, b, c, d, x[41]);
  HH (d, e, a, b, c, x[42]);
  HH (c, d, e, a, b, x[43]);
  HH (b, c, d, e, a, x[44]);
  HH (a, b, c, d, e, x[45]);
  HH (e, a, b, c, d, x[46]);
  HH (d, e, a, b, c, x[47]);
  HH (c, d, e, a, b, x[48]);
  HH (b, c, d, e, a, x[49]);
  HH (a, b, c, d, e, x[50]);
  HH (e, a, b, c, d, x[51]);
  HH (d, e, a, b, c, x[52]);
  HH (c, d, e, a, b, x[53]);
  HH (b, c, d, e, a, x[54]);
  HH (a, b, c, d, e, x[55]);
  HH (e, a, b, c, d, x[56]);
  HH (d, e, a, b, c, x[57]);
  HH (c, d, e, a, b, x[58]);
  HH (b, c, d, e, a, x[59]);

  /* Round 4 */
  II (a, b, c, d, e, x[60]);
  II (e, a, b, c, d, x[61]);
  II (d, e, a, b, c, x[62]);
  II (c, d, e, a, b, x[63]);
  II (b, c, d, e, a, x[64]);
  II (a, b, c, d, e, x[65]);
  II (e, a, b, c, d, x[66]);
  II (d, e, a, b, c, x[67]);
  II (c, d, e, a, b, x[68]);
  II (b, c, d, e, a, x[69]);
  II (a, b, c, d, e, x[70]);
  II (e, a, b, c, d, x[71]);
  II (d, e, a, b, c, x[72]);
  II (c, d, e, a, b, x[73]);
  II (b, c, d, e, a, x[74]);
  II (a, b, c, d, e, x[75]);
  II (e, a, b, c, d, x[76]);
  II (d, e, a, b, c, x[77]);
  II (c, d, e, a, b, x[78]);
  II (b, c, d, e, a, x[79]);

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
  state[4] += e;

  /* Zeroize potentially sensitive information.
   */
  NdisZeroMemory((void *)x, sizeof (x));
}

/* Expands x[0..15] into x[16..79], according to the recurrence
     x[i] = x[i-3] ^ x[i-8] ^ x[i-14] ^ x[i-16].
 */
void SHAExpand (x)
ULONG x[80];
{
  unsigned int i;
  ULONG        tmp;

  for (i = 16; i < 80; i++)
  {
    tmp = x[i-3] ^ x[i-8] ^ x[i-14] ^ x[i-16];
    x[i] = (tmp << 1) | (tmp >> 31);
  }
}

VOID
ByteReverse(
    UNALIGNED ULONG *Out,
    ULONG   *In,
    ULONG   Count
    )
{
    ULONG   i;
    ULONG   Value;

    for (i = 0; i < Count; i++) {
        Value = (ULONG)(In[i] << 16) | (In[i] >> 16);
        Out[i] = ((Value & 0xFF00FF00L) >> 8) | ((Value & 0x00FF00FFL) << 8);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\io.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    io.c

Abstract:

    This file contains the procedures to process I/O requests from
    a User Mode entity.  All OS dependent I/O interface functions
    will be conditionally coded, and will be responsible for translating
    the I/O functions from the OS format to buffers that are useable by
    the main I/O handling routine.


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe  06/06/95    Created


--*/

#include "wan.h"

#define __FILE_SIG__    IO_FILESIG

//
// Local function prototypes
//

NTSTATUS
ExecuteIo(
    IN  ULONG   ulFuncCode,
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    );

NTSTATUS
MapConnectionId(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetBundleHandle(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetFriendlyName(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
ActivateRoute(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
BundleLink(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
EnumLinksInBundle(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetProtocolPriority(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetBandwidthOnDemand(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetThresholdEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
IoSendPacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
IoReceivePacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
FlushReceivePacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetStatistics(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetLinkInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetLinkInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetCompressionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetCompressionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetVJInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetVJInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetEncryptionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetEncryptionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetIdleTime(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetDebugInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
EnumActiveBundles(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetBandwidthUtilization(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
EnumProtocolUtilization(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
FlushThresholdEvents(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetWanInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    );

NTSTATUS
DeactivateRoute(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetDriverInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
FlushProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
IoGetProtocolInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetHibernateEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
FlushHibernateEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetBundleInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
UnmapConnectionId(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

VOID
CancelThresholdEvents(
    VOID
    );

VOID
CancelIoReceivePackets(
    VOID
    );

VOID
AddProtocolCBToBundle(
    PPROTOCOLCB ProtocolCB,
    PBUNDLECB   BundleCB
    );

VOID
SortProtocolListByPriority(
    IN  PBUNDLECB BundleCB
    );

NDIS_HANDLE
AssignProtocolCBHandle(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB
    );

VOID
FreeProtocolCBHandle(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB
    );

NTSTATUS
NotImplemented(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    );

//
// End of local function prototypes
//
CONST
IO_DISPATCH_TABLE   IoDispatchTable[] =
{
    {FUNC_MAP_CONNECTION_ID     , MapConnectionId},
    {FUNC_GET_BUNDLE_HANDLE     , GetBundleHandle},
    {FUNC_SET_FRIENDLY_NAME     , SetFriendlyName},
    {FUNC_ROUTE                 , ActivateRoute},
    {FUNC_ADD_LINK_TO_BUNDLE    , BundleLink},
    {FUNC_ENUM_LINKS_IN_BUNDLE  , EnumLinksInBundle},
    {FUNC_SET_PROTOCOL_PRIORITY , SetProtocolPriority},
    {FUNC_SET_BANDWIDTH_ON_DEMAND, SetBandwidthOnDemand},
    {FUNC_SET_THRESHOLD_EVENT   , SetThresholdEvent},
    {FUNC_FLUSH_THRESHOLD_EVENTS, FlushThresholdEvents},
    {FUNC_SEND_PACKET           , IoSendPacket},
    {FUNC_RECEIVE_PACKET        , IoReceivePacket},
    {FUNC_FLUSH_RECEIVE_PACKETS , FlushReceivePacket},
    {FUNC_GET_STATS             , GetStatistics},
    {FUNC_SET_LINK_INFO         , SetLinkInfo},
    {FUNC_GET_LINK_INFO         , GetLinkInfo},
    {FUNC_SET_COMPRESSION_INFO  , SetCompressionInfo},
    {FUNC_GET_COMPRESSION_INFO  , GetCompressionInfo},
    {FUNC_SET_BRIDGE_INFO       , NotImplemented},
    {FUNC_GET_BRIDGE_INFO       , NotImplemented},
    {FUNC_SET_VJ_INFO           , SetVJInfo},
    {FUNC_GET_VJ_INFO           , GetVJInfo},
    {FUNC_SET_CIPX_INFO         , NotImplemented},
    {FUNC_GET_CIPX_INFO         , NotImplemented},
    {FUNC_SET_ENCRYPTION_INFO   , SetEncryptionInfo},
    {FUNC_GET_ENCRYPTION_INFO   , GetEncryptionInfo},
    {FUNC_SET_DEBUG_INFO        , SetDebugInfo},
    {FUNC_ENUM_ACTIVE_BUNDLES   , EnumActiveBundles},
    {FUNC_GET_NDISWANCB         , NotImplemented},
    {FUNC_GET_MINIPORTCB        , NotImplemented},
    {FUNC_GET_OPENCB            , NotImplemented},
    {FUNC_GET_BANDWIDTH_UTILIZATION, GetBandwidthUtilization},
    {FUNC_ENUM_PROTOCOL_UTILIZATION, EnumProtocolUtilization},
    {FUNC_ENUM_MINIPORTCB       , NotImplemented},
    {FUNC_ENUM_OPENCB           , NotImplemented},
    {FUNC_GET_WAN_INFO          , GetWanInfo},
    {FUNC_GET_IDLE_TIME         , GetIdleTime},
    {FUNC_UNROUTE               , DeactivateRoute},
    {FUNC_GET_DRIVER_INFO       , GetDriverInfo},
    {FUNC_SET_PROTOCOL_EVENT    , SetProtocolEvent},
    {FUNC_GET_PROTOCOL_EVENT    , GetProtocolEvent},
    {FUNC_FLUSH_PROTOCOL_EVENT  , FlushProtocolEvent},
    {FUNC_GET_PROTOCOL_INFO     , IoGetProtocolInfo},
    {FUNC_SET_HIBERNATE_EVENT   , SetHibernateEvent},
    {FUNC_FLUSH_HIBERNATE_EVENT , FlushHibernateEvent},
    {FUNC_GET_BUNDLE_INFO       , GetBundleInfo},
    {FUNC_UNMAP_CONNECTION_ID   , UnmapConnectionId}
};

#define MAX_FUNC_CODES  sizeof(IoDispatchTable)/sizeof(IO_DISPATCH_TABLE)

#ifdef NT

NTSTATUS
NdisWanIoctl(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS    Status, ReturnStatus;
    ULONG   ulBytesWritten = 0;

    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Ioctl Function Code
    //
    ULONG   ulFuncCode = (pIrpSp->Parameters.DeviceIoControl.IoControlCode >> 2) & 0x00000FFF ;
    ULONG   ulDeviceType = (pIrpSp->Parameters.DeviceIoControl.IoControlCode >> 16) & 0x0000FFFF;
    ULONG   ulMethod = pIrpSp->Parameters.DeviceIoControl.IoControlCode & 0x00000003;

    //
    // Input buffer, Output buffer, and lengths
    //
    PUCHAR  pInputBuffer = pIrp->AssociatedIrp.SystemBuffer;
    PUCHAR  pOutputBuffer = pInputBuffer;
    ULONG   ulInputBufferLength = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    ULONG   ulOutputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    // 
    // if this is win64 make sure the calling process is 64bit
    // since this interface is only used by rasman and rasman
    // will always be 64bit on 64bit systems we will not bother
    // with thunking.  if the process is not a 64bit process get
    // out.
#ifdef _WIN64
    if (IoIs32bitProcess(pIrp)) {

        pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        return (STATUS_NOT_SUPPORTED);
    }
#endif

//  NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanIoctl: FunctionCode: 0x%x, MajorFunction: 0x%x, DeviceType: 0x%x",
//                  ulFuncCode, pIrpSp->MajorFunction, ulDeviceType));
    
#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if ((pIrpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
        (ulDeviceType != FILE_DEVICE_NDISWAN) ||
        (ulMethod != METHOD_BUFFERED) ||
        (pDeviceObject != NdisWanCB.pDeviceObject)) {

        if (NdisWanCB.MajorFunction[pIrpSp->MajorFunction] == NULL) {
            pIrp->IoStatus.Information = 0;
            pIrp->IoStatus.Status = STATUS_SUCCESS;
        
            IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
        
            return(STATUS_SUCCESS);
            
        }

        return(NdisWanCB.MajorFunction[pIrpSp->MajorFunction](pDeviceObject, pIrp));
    }
#else
    if (pIrpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL ||
        ulDeviceType != FILE_DEVICE_NETWORK ||
        ulMethod != METHOD_BUFFERED) {

        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        return (STATUS_NOT_SUPPORTED);
    }
#endif

    //
    // If this is a function code that requires an irp to be pended and completed
    // later, we need to queue the irp up somewhere.  In order for this to be somewhat
    // portable we will pass the irp in as the input buffer and store it in a
    // a structure that it has it's own linkage for queueing.
    //
    if ((ulFuncCode == FUNC_SET_THRESHOLD_EVENT) ||
        (ulFuncCode == FUNC_RECEIVE_PACKET) ||
        (ulFuncCode == FUNC_SET_PROTOCOL_EVENT) ||
        (ulFuncCode == FUNC_SET_HIBERNATE_EVENT)) {

        pInputBuffer = (PUCHAR)pIrp;
    }

    Status = ExecuteIo(ulFuncCode,
                       pInputBuffer,
                       ulInputBufferLength,
                       pOutputBuffer,
                       ulOutputBufferLength,
                       &ulBytesWritten);


//  NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanIoctl: Status: 0x%x, BytesWritten: %d",
//                  Status, ulBytesWritten));

    switch (Status) {
        case STATUS_SUCCESS:
            ReturnStatus = Status;
            pIrp->IoStatus.Information = ulBytesWritten;
            break;

        case STATUS_PENDING:
            return(Status);

        case STATUS_INFO_LENGTH_MISMATCH:
            //
            // See if this was a request to get size needed for
            // ioctl.
            //
            if (ulOutputBufferLength >= sizeof(ULONG)) {
            
                *(PULONG)pOutputBuffer = ulBytesWritten;
                ulBytesWritten = sizeof(ULONG);
                pIrp->IoStatus.Information = sizeof(ULONG);
            } else {
                pIrp->IoStatus.Information = 0;
            }
            ReturnStatus = Status = 
                STATUS_SUCCESS;
            break;

        default:
            if (Status < 0xC0000000) {
                Status = 
                ReturnStatus = STATUS_UNSUCCESSFUL;
            } else {
                ReturnStatus = Status;
            }
            pIrp->IoStatus.Information = 0;
            break;
    }

    pIrp->IoStatus.Status = Status;

    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return(ReturnStatus);
}

NTSTATUS
NdisWanIrpStub(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    NdisWanDbgOut(DBG_VERBOSE, DBG_IO, ("NdisWanIrpStub: Entry"));

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != NdisWanCB.pDeviceObject &&
        NdisWanCB.MajorFunction[pIrpSp->MajorFunction] != NULL) {

        NdisWanDbgOut(DBG_VERBOSE, DBG_IO, ("NdisWanIrpStub: Exit1"));

        return(NdisWanCB.MajorFunction[pIrpSp->MajorFunction](pDeviceObject, pIrp));
    }

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    NdisWanDbgOut(DBG_VERBOSE, DBG_IO, ("NdisWanIrpStub: Exit2"));

    return (STATUS_SUCCESS);
#else

    pIrp->IoStatus.Information = 0;

    pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    NdisWanDbgOut(DBG_VERBOSE, DBG_IO, ("NdisWanIrpStub: Exit2"));

    return (STATUS_NOT_SUPPORTED);
#endif

}


NTSTATUS
NdisWanCreate(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

    NdisWanCreate

Routine Description:

    This routine is called when an app (rasman) opens ndiswan.

Arguments:

Return Values:

--*/
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCreate: Entry"));

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != NdisWanCB.pDeviceObject &&
        NdisWanCB.MajorFunction[pIrpSp->MajorFunction] != NULL) {

        NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCreate: Exit1"));

        return(NdisWanCB.MajorFunction[pIrpSp->MajorFunction](pDeviceObject, pIrp));
    }
#endif

    if (InterlockedIncrement(&NdisWanCB.RefCount) == 1) {
        ULONG   i;
        ULONG   ArraySize;
        PPROTOCOL_INFO  InfoArray;
        BOOLEAN bEvent = FALSE;

        //
        // This is the first guy!
        //
        NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

        ArraySize = ProtocolInfoTable->ulArraySize;

        for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
             i < ArraySize; i++, InfoArray++) {

            if (InfoArray->ProtocolType != 0) {
                InfoArray->Flags |= PROTOCOL_EVENT_OCCURRED;
                bEvent = TRUE;
            }
        }

        if (bEvent) {
            ProtocolInfoTable->Flags |= PROTOCOL_EVENT_OCCURRED;
        }

        NdisReleaseSpinLock(&ProtocolInfoTable->Lock);
    }

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCreate: Exit2"));

    return (STATUS_SUCCESS);
}

NTSTATUS
NdisWanCleanup(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

    NdisWanCleanup

Routine Description:

    This routine is called when all apps (rasman) that have opened
    ndiswan have gone away.  If ndiswan is still routed to any
    transports it will complete all sends and do linedowns to
    cleanup.

Arguments:

Return Values:

--*/
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCleanup: Entry"));

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != NdisWanCB.pDeviceObject &&
        NdisWanCB.MajorFunction[pIrpSp->MajorFunction] != NULL) {

        NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCleanup: Exit1"));

        return(NdisWanCB.MajorFunction[pIrpSp->MajorFunction](pDeviceObject, pIrp));
    }
#endif

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    InterlockedDecrement(&NdisWanCB.RefCount);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCleanup: Exit2"));

    return (STATUS_SUCCESS);
}

NTSTATUS
NdisWanPnPPower(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanPnPPower: Entry"));

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != NdisWanCB.pDeviceObject &&
        NdisWanCB.MajorFunction[pIrpSp->MajorFunction] != NULL) {

        NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanPnPPower: Exit1"));

        return(NdisWanCB.MajorFunction[pIrpSp->MajorFunction](pDeviceObject, pIrp));
    }
#endif

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    PoStartNextPowerIrp(pIrp);

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanPnPPower: Exit2"));

    return (STATUS_SUCCESS);
}

VOID
NdisWanCancelRoutine(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    BOOLEAN Found = FALSE;
    PLIST_ENTRY Entry;
    ULONG       CopySize = 0;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCancelRoutine: Irp 0x%p", pIrp));

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    do {

        //
        // Is this the hibernate event irp?
        //
        NdisAcquireSpinLock(&NdisWanCB.Lock);

        if (pIrp == NdisWanCB.HibernateEventIrp) {
            NdisWanCB.HibernateEventIrp = NULL;
            Found = TRUE;
        }

        NdisReleaseSpinLock(&NdisWanCB.Lock);

        if (Found) {
            break;
        }

        //
        // Is this the protocol event irp?
        //
        NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

        if (pIrp == ProtocolInfoTable->EventIrp) {
            ProtocolInfoTable->EventIrp = NULL;
            Found = TRUE;
        }

        NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

        if (Found) {
            break;
        }

        //
        // We need to walk the async event queue looking for
        // the async event that this irp is associated with
        //
        NdisAcquireSpinLock(&IoRecvList.Lock);

        for (Entry = IoRecvList.IrpList.Flink;
            Entry != &IoRecvList.IrpList;
            Entry = Entry->Flink) {

            PIRP MyIrp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

            if (MyIrp == (PVOID)pIrp) {

                IoRecvList.ulIrpCount--;

                //
                // Remove from the list
                //
                RemoveEntryList(Entry);

                Found = TRUE;

                ((PNDISWAN_IO_PACKET)(pIrp->AssociatedIrp.SystemBuffer))->usHandleType = CANCELEDHANDLE;

                INSERT_RECV_EVENT('c');

                CopySize = sizeof(NDISWAN_IO_PACKET);

                IoRecvList.LastIrp = pIrp;
                IoRecvList.LastIrpStatus = STATUS_SUCCESS;
                IoRecvList.LastCopySize = CopySize;

                IoRecvList.LastPacketNumber =
                    ((PNDISWAN_IO_PACKET)(pIrp->AssociatedIrp.SystemBuffer))->PacketNumber;

                break;
            }
        }

        NdisReleaseSpinLock(&IoRecvList.Lock);

        if (Found) {
            break;
        }

        NdisAcquireSpinLock(&ThresholdEventQueue.Lock);

        for (Entry = ThresholdEventQueue.List.Flink;
            Entry != &ThresholdEventQueue.List;
            Entry = Entry->Flink) {

            PIRP MyIrp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

            if (MyIrp == (PVOID)pIrp) {

                ThresholdEventQueue.ulCount--;

                //
                // Remove from the list
                //
                RemoveEntryList(Entry);

                Found = TRUE;
                break;
            }
        }

        NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

    } while (FALSE);


    //
    // Complete the irp
    //
    pIrp->Cancel = TRUE;
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = CopySize;
    
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
}

#endif

NTSTATUS
ExecuteIo(
    IN  ULONG   ulFuncCode,
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("ExecuteIo: FuncCode 0x%x", ulFuncCode));

    if (ulFuncCode < MAX_FUNC_CODES) {

        Status = (*IoDispatchTable[ulFuncCode].Function)(pInputBuffer,
                                                         ulInputBufferLength,
                                                         pOutputBuffer,
                                                         ulOutputBufferLength,
                                                         pulBytesWritten);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("ExecuteIo: Status 0x%x", Status));

    return (Status);
}

NTSTATUS
MapConnectionId(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    MapConnectionId

Routine Description:

    This functions takes a WAN Wrapper connection id, finds the corresponding
    LinkCB and BundleCB, and returns handles to these CB's.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_MAP_CONNECTION_ID

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_MAP_CONNECTION_ID)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_MAP_CONNNECTION_ID

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_MAP_CONNECTION_ID)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH
    STATUS_SUCCESS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNDISWAN_MAP_CONNECTION_ID In = (PNDISWAN_MAP_CONNECTION_ID)pInputBuffer;
    PNDISWAN_MAP_CONNECTION_ID Out = (PNDISWAN_MAP_CONNECTION_ID)pOutputBuffer;
    ULONG   SizeNeeded = sizeof(NDISWAN_MAP_CONNECTION_ID);
    ULONG       i;
    POPENCB OpenCB = NULL;
    PLINKCB  LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;
    LOCK_STATE  LockState;
    ULONG       Count;
    BOOLEAN     Found = FALSE;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("MapConnectionId:"));

    *pulBytesWritten = SizeNeeded;

    if (ulInputBufferLength < SizeNeeded ||
        ulOutputBufferLength < SizeNeeded) {

        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("MapConnectionId: Buffer to small: Size: %d, SizeNeeded %d",
                      ulOutputBufferLength, SizeNeeded));

        return (STATUS_INFO_LENGTH_MISMATCH);
    }

    ASSERT(In->hLinkContext != NULL);

    do {
    
        //
        // Find the linkcb that has this connection id and return
        // both the linkcb index and the bundlecb index
        //
        NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &LockState);

        do {
            ULONG   index;
            PLIST_ENTRY le;

            if (PtrToUlong(In->hConnectionID) < ConnectionTable->ulArraySize) {
                //
                // This might be my handle and thus a direct index
                //
                LinkCB = *(ConnectionTable->LinkArray +
                           PtrToUlong(In->hConnectionID));

                if ((LinkCB != NULL) &&
                    (LinkCB->hLinkContext == NULL)) {
                    Found = TRUE;
                    break;
                }
            }

            //
            // The connectionid was not my handle so find the 
            // correct linkcb in the connection table.  Walk
            // the list backward.
            //
            le = ConnectionTable->LinkList.Blink;

            while (le != &ConnectionTable->LinkList) {

                LinkCB = 
                    CONTAINING_RECORD(le, LINKCB, ConnTableLinkage);

                if (LinkCB != NULL &&
                    In->hConnectionID == LinkCB->ConnectionWrapperID &&
                    LinkCB->hLinkContext == NULL) {
                    Found = TRUE;
                    break;
                }

                le = le->Blink;
            }

        } while (FALSE);

        if (!Found) {

            NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

            break;
        }

        NdisDprAcquireSpinLock(&LinkCB->Lock);

        if (LinkCB->State != LINK_UP) {

            Found = FALSE;

            NdisDprReleaseSpinLock(&LinkCB->Lock);

            NdisReleaseReadWriteLock(&ConnTableLock, &LockState);
            break;
        }
    
        BundleCB = LinkCB->BundleCB;

        //
        // We have found the right link, return the link and bundle handles
        //
        Out->hLinkHandle = LinkCB->hLinkHandle;
        Out->hBundleHandle = BundleCB->hBundleHandle;

        LinkCB->hLinkContext = In->hLinkContext;
        BundleCB->hBundleContext = In->hBundleContext;

        REF_LINKCB(LinkCB);

        //
        // Copy the friendly name to the link
        //
        {
            ULONG   CopyLength;

            CopyLength = (ulInputBufferLength - 
                 FIELD_OFFSET(NDISWAN_MAP_CONNECTION_ID, szName[0]));

            CopyLength = (CopyLength > In->ulNameLength) ?
                In->ulNameLength : CopyLength;

            CopyLength = (CopyLength > MAX_NAME_LENGTH) ?
                MAX_NAME_LENGTH : CopyLength;

            NdisMoveMemory(LinkCB->Name, In->szName, CopyLength);
        }

        OpenCB = LinkCB->OpenCB;

        NdisDprReleaseSpinLock(&LinkCB->Lock);

        //
        // If this link has some recv's pending because
        // we did not have a context mapped yet, we could
        // get into a state where our recv's stall.  We
        // will kick start this by scheduling a routine
        // to complete the pending recv's.
        //
        NdisDprAcquireSpinLock(&IoRecvList.Lock);

        if (LinkCB->RecvDescCount != 0){

            if (!IoRecvList.TimerScheduled) {
                WAN_TIME    TimeOut;

                IoRecvList.TimerScheduled = TRUE;
                NdisWanInitWanTime(&TimeOut, 15);
                KeSetTimer(&IoRecvList.Timer,
                           TimeOut,
                           &IoRecvList.Dpc);
            }
        }

        NdisDprReleaseSpinLock(&IoRecvList.Lock);

        NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    } while ( 0 );

    if (!Found) {
        //
        // We did not find a match to the connection id
        //
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("MapConnectionId: ConnectionId not found! ConnectionId: 0x%x",
                      In->hConnectionID));

        *pulBytesWritten = 0;
        Status = NDISWAN_ERROR_INVALID_HANDLE;
    }

    if (OpenCB != NULL) {
        //
        // Wait for initialization to complete
        //
        NdisWanWaitForNotificationEvent(&OpenCB->InitEvent);
    }

    return (Status);
}


NTSTATUS
GetBundleHandle(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    GetBundleHandle

Routine Description:

    This function takes a handle to a linkcb and returns the handle to the bundlecb
    that the linkcb belongs to

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_GET_BUNDLE_HANDLE

    ulInputBufferLength - Length of the input buffer should be sizeof(NDISWAN_GET_BUNDLE_HANDLE)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_GET_BUNDLE_HANDLE

    ulOutputBufferLength - Length of the output buffer should be sizeof(NDISWAN_GET_BUNDLE_HANDLE)

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH
    STATUS_SUCCESS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNDISWAN_GET_BUNDLE_HANDLE In = (PNDISWAN_GET_BUNDLE_HANDLE)pInputBuffer;
    PNDISWAN_GET_BUNDLE_HANDLE Out = (PNDISWAN_GET_BUNDLE_HANDLE)pOutputBuffer;
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_BUNDLE_HANDLE);
    PLINKCB     LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetBundleHandle:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulInputBufferLength < SizeNeeded ||
            ulOutputBufferLength < SizeNeeded) {
            
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetBundleHandle: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
    
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE, 
                                   &LinkCB, 
                                   &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO,
                ("GetBundleHandle: Invalid LinkHandle: 0x%x", In->hLinkHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        //
        // Get the bundle handle that this link belongs to
        //
        Out->hBundleHandle = BundleCB->hBundleHandle;


    } while ( 0 );

    //
    // Derefs for the refs applied in AreLinkAndBundleValid
    //
    DEREF_LINKCB(LinkCB);
    DEREF_BUNDLECB(BundleCB);

    return (Status);
}


NTSTATUS
SetFriendlyName(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    SetFriendlyName

Routine Description:

    Sets the friendly name of either a bundlecb or a linkcb

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_SET_FRIENDLY_NAME

    ulInputBufferLength - Length of the input buffer should be sizeof(NDISWAN_SET_FRIENDLY_NAME)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_SET_FRIENDLY_NAME

    ulOutputBufferLength - Length of the output buffer should be sizeof(NDISWAN_SET_FRIENDLY_NAME)

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE_TYPE
    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH
    STATUS_SUCCESS
--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       SizeNeeded = sizeof(NDISWAN_SET_FRIENDLY_NAME);
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;
    PUCHAR      Dest;
    ULONG       CopyLength;

    PNDISWAN_SET_FRIENDLY_NAME In =
        (PNDISWAN_SET_FRIENDLY_NAME)pInputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetFriendlyName:"));

    *pulBytesWritten = 0;

    do {

        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetFriendlyName: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        if (In->usHandleType == LINKHANDLE) {
            //
            // Is this a link handle
            //

            if (!IsLinkValid(In->hHandle, 
                             TRUE, 
                             &LinkCB)) {

                NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetFriendlyName: Invalid LinkHandle: %x",
                              In->hHandle));
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            NdisAcquireSpinLock(&LinkCB->Lock);

            Dest = LinkCB->Name;

            CopyLength = In->ulNameLength;

            if (ulInputBufferLength - FIELD_OFFSET(NDISWAN_SET_FRIENDLY_NAME, szName) < CopyLength) {
                CopyLength =
                    ulInputBufferLength - FIELD_OFFSET(NDISWAN_SET_FRIENDLY_NAME, szName);
            }

            if (CopyLength > MAX_NAME_LENGTH) {
                CopyLength = MAX_NAME_LENGTH;
            }

            NdisMoveMemory(Dest,
                           In->szName,
                           CopyLength);

            //
            // Deref for the ref applied by IsLinkValid
            //
            DEREF_LINKCB_LOCKED(LinkCB);
                
        } else if (In->usHandleType == BUNDLEHANDLE) {

            //
            // Or a bundle handle
            //
            if (!IsBundleValid(In->hHandle, 
                               TRUE, 
                               &BundleCB)) {

                NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetFriendlyName: Invalid BundleHandle: 0x%x",
                              In->hHandle));
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            AcquireBundleLock(BundleCB);

            Dest = BundleCB->Name;

            CopyLength = In->ulNameLength;

            if (ulInputBufferLength - FIELD_OFFSET(NDISWAN_SET_FRIENDLY_NAME, szName) < CopyLength) {
                CopyLength =
                    ulInputBufferLength - FIELD_OFFSET(NDISWAN_SET_FRIENDLY_NAME, szName);
            }

            if (CopyLength > MAX_NAME_LENGTH) {
                CopyLength = MAX_NAME_LENGTH;
            }

            NdisMoveMemory(Dest,
                           In->szName,
                           CopyLength);

            //
            // Deref for the ref applied by IsBundleValid
            //
            DEREF_BUNDLECB_LOCKED(BundleCB);

        } else {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetFriendlyName: Invalid HandleType: 0x%x",
                          In->usHandleType));
            Status = NDISWAN_ERROR_INVALID_HANDLE_TYPE;
            break;
        }
    
    } while ( 0 );


    return (Status);
}


NTSTATUS
ActivateRoute(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    ActivateRoute

Routine Description:

    This function routes the bundle given by hbundlehandle to
    the protocol give by usprotocoltype.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_ACTIVATE_ROUTE

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_ACTIVATE_ROUTE)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_ACTIVATE_ROUTE

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_ACTIVATE_ROUTE)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_ALREADY_ROUTED
    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INSUFFICIENT_RESOURCES
    STATUS_INFO_LENGTH_MISMATCH

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNDISWAN_ROUTE In = (PNDISWAN_ROUTE)pInputBuffer;
    PNDISWAN_ROUTE  Out = (PNDISWAN_ROUTE)pOutputBuffer;
    ULONG   SizeNeeded = sizeof(NDISWAN_ROUTE);
    ULONG   AllocationSize, i;
    PBUNDLECB   BundleCB = NULL;
    BOOLEAN RouteExists = FALSE;
    PPROTOCOLCB ProtocolCB;
    NDIS_HANDLE hProto;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("ActivateRoute:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulInputBufferLength < SizeNeeded ||
            ulOutputBufferLength < SizeNeeded ||
            In->ulBufferLength > ulInputBufferLength ||
            In->usBindingNameLength > ulInputBufferLength) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("ActivateRoute: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        //
        // If this is a valid bundle
        //
        if (!IsBundleValid(In->hBundleHandle, 
                           TRUE, 
                           &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("ActivateRoute: Invalid BundleHandle: 0x%x, ProtocolType: 0x%x",
                          In->hBundleHandle, In->usProtocolType));
    
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        AcquireBundleLock(BundleCB);

        //
        // Create and initialize a ProtocolCB for this new route
        //
        ProtocolCB =
            NdisWanAllocateProtocolCB(In);
    
        if (ProtocolCB == NULL) {
            //
            // Memory allocation failed
            //
            ReleaseBundleLock(BundleCB);
    
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    
        //
        // Assign a handle for this protocolcb
        //
        hProto =
            AssignProtocolCBHandle(BundleCB, ProtocolCB);

        if (hProto == (NDIS_HANDLE)MAX_PROTOCOLS) {
    
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("ActivateRoute: No room in ProtocolCB Table: ProtocolType: 0x%2.2x",
                          ProtocolCB->ProtocolType));

            ProtocolCB->State = PROTOCOL_UNROUTING;

            NdisWanFreeProtocolCB(ProtocolCB);

            ReleaseBundleLock(BundleCB);

            Status = NDISWAN_ERROR_NO_ROUTE;
            break;
        }
    
        //
        // Do a new lineup to protocol
        //
        ReleaseBundleLock(BundleCB);
    
        Status = DoNewLineUpToProtocol(ProtocolCB);
    
        if (Status == NDIS_STATUS_SUCCESS) {
    
            Out->usDeviceNameLength =
            (ProtocolCB->OutDeviceName.Length > MAX_NAME_LENGTH) ?
            MAX_NAME_LENGTH : ProtocolCB->OutDeviceName.Length;
    
            NdisMoveMemory(&Out->DeviceName[0],
                           ProtocolCB->OutDeviceName.Buffer,
                           Out->usDeviceNameLength);
    
            //
            // Insert the protocolcb in the bundle's protocolcb table
            // and list.
            //
            AddProtocolCBToBundle(ProtocolCB, BundleCB);

        } else {
    
            AcquireBundleLock(BundleCB);

            FreeProtocolCBHandle(BundleCB, ProtocolCB);

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("ActivateRoute: Error during LineUp to ProtocolType: 0x%x",
                          ProtocolCB->ProtocolType));

            ProtocolCB->State = PROTOCOL_UNROUTING;

            NdisWanFreeProtocolCB(ProtocolCB);

            ReleaseBundleLock(BundleCB);
        }

    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid
    //
    DEREF_BUNDLECB(BundleCB);

    return (Status);
}


NTSTATUS
BundleLink(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    BundleLink

Routine Description:

    This function bundles the link given by hLinkHandle to the bundle given
    by hBundlehandle.  The resources used by the bundle that the link used
    to belong to are freed.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_ADD_LINK_TO_BUNDLE

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_ADD_LINK_TO_BUNDLE)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_ADD_LINK_TO_BUNDLE

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_ADD_LINK_TO_BUNDLE)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH

--*/
{
    ULONG       SizeNeeded = sizeof(NDISWAN_ADD_LINK_TO_BUNDLE);
    PLINKCB     LinkCB = NULL;
    PBUNDLECB   OldBundleCB = NULL, NewBundleCB = NULL;
    NTSTATUS    Status = STATUS_SUCCESS;
    PPROTOCOLCB     IoProtocolCB;
    PPACKET_QUEUE   PacketQueue;
    PACKET_QUEUE    TempPacketQueue;

    PNDISWAN_ADD_LINK_TO_BUNDLE In =
        (PNDISWAN_ADD_LINK_TO_BUNDLE)pInputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("BundleLink:"));

    *pulBytesWritten = 0;

    do {

        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("BundleLink: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
    
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &OldBundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("BundleLink: Invalid LinkHandle: 0x%x",
                          In->hLinkHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        if (!IsBundleValid(In->hBundleHandle, 
                           TRUE,
                           &NewBundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("BundleLink: Invalid NewBundleCB: 0x%p, OldBundleCB: 0x%p",
                          NewBundleCB, OldBundleCB));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        if (NewBundleCB == OldBundleCB) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("BundleLink: Invalid NewBundleCB: 0x%p, OldBundleCB: 0x%p",
                          NewBundleCB, OldBundleCB));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        AcquireBundleLock(OldBundleCB);
    
        ASSERT(OldBundleCB->ulLinkCBCount == 1);
        ASSERT(OldBundleCB->ulNumberOfRoutes == 0);
    
        OldBundleCB->State = BUNDLE_GOING_DOWN;
    
        if (OldBundleCB->OutstandingFrames != 0) {
    
            NdisWanClearSyncEvent(&OldBundleCB->OutstandingFramesEvent);
    
            OldBundleCB->Flags |= FRAMES_PENDING_EVENT;
    
            ReleaseBundleLock(OldBundleCB);
    
            NdisWanWaitForSyncEvent(&OldBundleCB->OutstandingFramesEvent);
    
            AcquireBundleLock(OldBundleCB);

        }

        //
        // Remove any ppp packets that might be on the old bundle
        // queue so we can move them to the new bundle.
        //

        IoProtocolCB = OldBundleCB->IoProtocolCB;
        PacketQueue = &IoProtocolCB->PacketQueue[MAX_MCML];

        NdisZeroMemory(&TempPacketQueue, sizeof(TempPacketQueue));

        if (!IsPacketQueueEmpty(PacketQueue)) {

            while (!IsPacketQueueEmpty(PacketQueue)) {
                PNDIS_PACKET     Packet;
                UINT            PacketLength;
                
                Packet =
                    RemoveHeadPacketQueue(PacketQueue);

                NdisQueryPacket(Packet,
                                NULL,
                                NULL,
                                NULL,
                                &PacketLength);

                InsertTailPacketQueue(&TempPacketQueue, 
                                      Packet, 
                                      PacketLength);
            }
        }
    
        //
        // Remove the link from the old bundle.  This returns
        // with the OldBundleCB lock released!
        //
        RemoveLinkFromBundle(OldBundleCB, LinkCB, TRUE);
    
        AcquireBundleLock(NewBundleCB);
    
        //
        // Add the link to the new bundle
        //
        AddLinkToBundle(NewBundleCB, LinkCB);

        SetBundleFlags(NewBundleCB);

        //
        // If there were any ppp packets on the old bundle
        // queue we can now place them on the new bundle.
        //
        if (!IsPacketQueueEmpty(&TempPacketQueue)) {

            IoProtocolCB = NewBundleCB->IoProtocolCB;
            PacketQueue = &IoProtocolCB->PacketQueue[MAX_MCML];

            while (!IsPacketQueueEmpty(&TempPacketQueue)) {
                PNDIS_PACKET     Packet;
                UINT            PacketLength;

                Packet =
                    RemoveHeadPacketQueue(&TempPacketQueue)

                NdisQueryPacket(Packet,
                                NULL,
                                NULL,
                                NULL,
                                &PacketLength);

                InsertTailPacketQueue(PacketQueue,
                                      Packet,
                                      PacketLength);
            }
        }

        ReleaseBundleLock(NewBundleCB);

    } while ( 0 );

    //
    // Derefs for the refs applied by AreLinkAndBundleValid
    //
    DEREF_LINKCB(LinkCB);
    DEREF_BUNDLECB(OldBundleCB);

    //
    // Deref for the ref applied by IsBundleValid
    //
    DEREF_BUNDLECB(NewBundleCB);

    return (Status);
}


NTSTATUS
EnumLinksInBundle(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       SizeNeeded = 0;
    ULONG       i;
    PBUNDLECB   BundleCB = NULL;
    PLINKCB     LinkCB;
    NTSTATUS    Status = STATUS_SUCCESS;

    PNDISWAN_ENUM_LINKS_IN_BUNDLE In =
        (PNDISWAN_ENUM_LINKS_IN_BUNDLE)pInputBuffer;

    PNDISWAN_ENUM_LINKS_IN_BUNDLE Out =
        (PNDISWAN_ENUM_LINKS_IN_BUNDLE)pOutputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("EnumLinksInBundle:"));

    do {

        if (ulInputBufferLength < sizeof(NDISWAN_ENUM_LINKS_IN_BUNDLE)) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("EnumLinksInBundle: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, sizeof(NDISWAN_ENUM_LINKS_IN_BUNDLE)));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!IsBundleValid(In->hBundleHandle, 
                           TRUE, 
                           &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("EnumLinksInBundle: Invalid BundleHandle: 0x%x",
                          In->hBundleHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
        
        AcquireBundleLock(BundleCB);
    
        SizeNeeded = sizeof(NDISWAN_ENUM_LINKS_IN_BUNDLE) +
                    (sizeof(NDIS_HANDLE) * BundleCB->ulLinkCBCount);
        
        *pulBytesWritten = SizeNeeded;

        if (ulOutputBufferLength < SizeNeeded) {
            
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("EnumLinksInBundle: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        Out->ulNumberOfLinks = BundleCB->ulLinkCBCount;
    
        //
        // Walk the list of linkcb's and put the handle for each
        // cb in the output handle array
        //
        i = 0;
        for (LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
             (PVOID)LinkCB != (PVOID)&BundleCB->LinkCBList;
             LinkCB = (PLINKCB)LinkCB->Linkage.Flink) {
    
            Out->hLinkHandleArray[i++] = LinkCB->hLinkHandle;
        }
    
    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
            
    return (Status);
}


NTSTATUS
SetProtocolPriority(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    SetProtocolPriority

Routine Description:

    This function sets the the priority, given by uspriority, for the
    protocol given by usprotocoltype on the bundle given by hbundlehandle.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_SET_PROTOCOL_PRIORITY

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_SET_PROTOCOL_PRIORITY)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_SET_PROTOCOL_PRIORITY

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_SET_PROTOCOL_PRIORITY)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SizeNeeded = sizeof(NDISWAN_SET_PROTOCOL_PRIORITY);
    PNDISWAN_SET_PROTOCOL_PRIORITY In = (PNDISWAN_SET_PROTOCOL_PRIORITY)pInputBuffer;
    PBUNDLECB BundleCB = NULL;
    PPROTOCOLCB ProtocolCB;
    ULONG   BytesPerSecond;

    *pulBytesWritten = 0;

    return (STATUS_SUCCESS);
}


NTSTATUS
SetBandwidthOnDemand(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    SetBandwidthOnDemand

Routine Description:

    This function sets the bandwidth on demand parameters for the bundle given by
    hbundlehandle.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_SET_BANDWIDTH_ON_DEMAND

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_SET_BANDWIDTH_ON_DEMAND)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_SET_BANDWIDTH_ON_DEMAND

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_SET_BANDWIDTH_ON_DEMAND)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PBUNDLECB BundleCB = NULL;
    ULONG   SizeNeeded = sizeof(NDISWAN_SET_BANDWIDTH_ON_DEMAND);
    PNDISWAN_SET_BANDWIDTH_ON_DEMAND In = (PNDISWAN_SET_BANDWIDTH_ON_DEMAND)pInputBuffer;
    WAN_TIME    Temp1, Temp2;
    ULONGLONG   SecondsInSamplePeriod;
    ULONGLONG   BytesPerSecond;
    ULONGLONG   BytesInSamplePeriod;
    ULONGLONG   temp;
    ULONG       LowestSamplePeriod = 0;
    PBOND_INFO      BonDInfo;
    PSAMPLE_TABLE   SampleTable;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetBandwidthOnDemand:"));

    *pulBytesWritten = 0;

    if (ulInputBufferLength < SizeNeeded) {
        
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetBandwidthOnDemand: Buffer to small: Size: %d, SizeNeeded %d",
                      ulInputBufferLength, SizeNeeded));
        *pulBytesWritten = SizeNeeded;
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // If this is a valid bundle handle
    //
    if (!IsBundleValid(In->hBundleHandle, 
                       TRUE,
                       &BundleCB)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_IO,
            ("SetBandwidthOnDemand: Invalid BundleHandle: 0x%x",
                In->hBundleHandle));

        return NDISWAN_ERROR_INVALID_HANDLE;
    }
    
    do {
        AcquireBundleLock(BundleCB);

        if (BundleCB->BonDAllocation == NULL) {
            PUCHAR  pMem;

            NdisWanAllocatePriorityMemory(&pMem,
                                          BONDALLOC_SIZE,
                                          BONDALLOC_TAG,
                                          LowPoolPriority);

            if (pMem == NULL) {

                // ReleaseBundleLock(BundleCB);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            BundleCB->BonDAllocation = pMem;

            BundleCB->SUpperBonDInfo = (PBOND_INFO)pMem;

            pMem += (sizeof(BOND_INFO) + sizeof(PVOID));
            (ULONG_PTR)pMem &= ~((ULONG_PTR)sizeof(PVOID) - 1);
            BundleCB->SLowerBonDInfo = (PBOND_INFO)pMem;

            pMem += (sizeof(BOND_INFO) + sizeof(PVOID));
            (ULONG_PTR)pMem &= ~((ULONG_PTR)sizeof(PVOID) - 1);
            BundleCB->RUpperBonDInfo = (PBOND_INFO)pMem;

            pMem += (sizeof(BOND_INFO) + sizeof(PVOID));
            (ULONG_PTR)pMem &= ~((ULONG_PTR)sizeof(PVOID) - 1);
            BundleCB->RLowerBonDInfo = (PBOND_INFO)pMem;

            BonDInfo = BundleCB->SUpperBonDInfo;
            BonDInfo->DataType = TRANSMIT_DATA;
            BonDInfo->usPercentBandwidth = 0xFFFF;

            SampleTable = &BonDInfo->SampleTable;
            SampleTable->ulSampleArraySize = SAMPLE_ARRAY_SIZE;

            BonDInfo = BundleCB->SLowerBonDInfo;
            BonDInfo->DataType = TRANSMIT_DATA;
            BonDInfo->usPercentBandwidth = 0xFFFF;
            SampleTable = &BonDInfo->SampleTable;
            SampleTable->ulSampleArraySize = SAMPLE_ARRAY_SIZE;

            BonDInfo = BundleCB->RUpperBonDInfo;
            BonDInfo->DataType = RECEIVE_DATA;
            BonDInfo->usPercentBandwidth = 0xFFFF;

            SampleTable = &BonDInfo->SampleTable;
            SampleTable->ulSampleArraySize = SAMPLE_ARRAY_SIZE;

            BonDInfo = BundleCB->RLowerBonDInfo;
            BonDInfo->DataType = RECEIVE_DATA;
            BonDInfo->usPercentBandwidth = 0xFFFF;
            SampleTable = &BonDInfo->SampleTable;
            SampleTable->ulSampleArraySize = SAMPLE_ARRAY_SIZE;
        }
    
        if (In->usLowerXmitThreshold > 0) {
            BonDInfo = BundleCB->SLowerBonDInfo;
            SampleTable = &BonDInfo->SampleTable;

            //
            // One second is the smallest sample period we support!
            //
            if (In->ulLowerXmitSamplePeriod < 1000) {
                In->ulLowerXmitSamplePeriod = 1000;
            }

    
            //
            // We need to init the sample period in 100 nanoseconds
            //
            NdisWanInitWanTime(&Temp1, MILS_TO_100NANOS);
            NdisWanInitWanTime(&Temp2, In->ulLowerXmitSamplePeriod);
            NdisWanMultiplyWanTime(&SampleTable->SamplePeriod,
                                   &Temp1,&Temp2);
    
            //
            // The sample rate is the sample period divided by the number of
            // samples in the sample array
            //
            NdisWanInitWanTime(&Temp1, SampleTable->ulSampleArraySize);
            NdisWanDivideWanTime(&SampleTable->SampleRate,
                                 &SampleTable->SamplePeriod,
                                 &Temp1);
    
            //
            // Convert %bandwidth to Bytes/SamplePeriod
            // 100bsp * 100 / 8 = BytesPerSecond
            // BytesPerSecond * SecondsInSamplePeriod = BytesInSamplePeriod
            // BytesInSamplePeriod * %Bandwidth / 100 = BytesInSamplePeriod
            //
            SecondsInSamplePeriod = BonDInfo->ulSecondsInSamplePeriod =
                In->ulLowerXmitSamplePeriod / 1000;
        
            BytesPerSecond =
                BundleCB->SFlowSpec.PeakBandwidth;
        
            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;

            BonDInfo->ulBytesInSamplePeriod = BytesInSamplePeriod;
        
            BonDInfo->usPercentBandwidth = In->usLowerXmitThreshold;
    
            temp = In->usLowerXmitThreshold;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            if (BonDInfo->State == BonDSignaled) {
                BonDInfo->State = BonDIdle;
            }
    
            NdisWanGetSystemTime(&BonDInfo->StartTime);
    
            if (In->ulLowerXmitSamplePeriod < LowestSamplePeriod ||
                LowestSamplePeriod == 0) {
                LowestSamplePeriod = In->ulLowerXmitSamplePeriod;
            }
        }
    
        if (In->usUpperXmitThreshold > 0) {
            BonDInfo = BundleCB->SUpperBonDInfo;
            SampleTable = &BonDInfo->SampleTable;
    
            //
            // One second is the smallest sample period we support!
            //
            if (In->ulUpperXmitSamplePeriod < 1000) {
                In->ulUpperXmitSamplePeriod = 1000;
            }

            //
            // We need to init the sample period in 100 nanoseconds
            //
            NdisWanInitWanTime(&Temp1, MILS_TO_100NANOS);
            NdisWanInitWanTime(&Temp2, In->ulUpperXmitSamplePeriod);
            NdisWanMultiplyWanTime(&SampleTable->SamplePeriod,
                                   &Temp1,
                                   &Temp2);
    
            //
            // The sample rate is the sample period divided by the number of
            // samples in the sample array
            //
            NdisWanInitWanTime(&Temp1, SampleTable->ulSampleArraySize);
            NdisWanDivideWanTime(&SampleTable->SampleRate,
                                 &SampleTable->SamplePeriod,
                                 &Temp1);
    
            //
            // Convert %bandwidth to Bytes/SamplePeriod
            // 100bsp * 100 / 8 = BytesPerSecond
            // BytesPerSecond * SecondsInSamplePeriod = BytesInSamplePeriod
            // BytesInSamplePeriod * %Bandwidth / 100 = BytesInSamplePeriod
            //
            SecondsInSamplePeriod = BonDInfo->ulSecondsInSamplePeriod =
                In->ulUpperXmitSamplePeriod / 1000;
        
            BytesPerSecond =
                BundleCB->SFlowSpec.PeakBandwidth;
        
            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;
        
            BonDInfo->ulBytesInSamplePeriod = 
                (ULONG)BytesInSamplePeriod;

            BonDInfo->usPercentBandwidth = In->usUpperXmitThreshold;
    
            temp = In->usUpperXmitThreshold;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            if (BonDInfo->State == BonDSignaled) {
                BonDInfo->State = BonDIdle;
            }
            NdisWanGetSystemTime(&BonDInfo->StartTime);
    
            if (In->ulUpperXmitSamplePeriod < LowestSamplePeriod ||
                LowestSamplePeriod == 0) {
                LowestSamplePeriod = In->ulUpperXmitSamplePeriod;
            }
        }
    
        if (In->usLowerRecvThreshold > 0) {
            BonDInfo = BundleCB->RLowerBonDInfo;
            SampleTable = &BonDInfo->SampleTable;
    
            //
            // One second is the smallest sample period we support!
            //
            if (In->ulLowerRecvSamplePeriod < 1000) {
                In->ulLowerRecvSamplePeriod = 1000;
            }

            //
            // We need to init the sample period in 100 nanoseconds
            //
            NdisWanInitWanTime(&Temp1, MILS_TO_100NANOS);
            NdisWanInitWanTime(&Temp2, In->ulLowerRecvSamplePeriod);
            NdisWanMultiplyWanTime(&SampleTable->SamplePeriod,
                                   &Temp1,&Temp2);
    
            //
            // The sample rate is the sample period divided by the number of
            // samples in the sample array
            //
            NdisWanInitWanTime(&Temp1, SampleTable->ulSampleArraySize);
            NdisWanDivideWanTime(&SampleTable->SampleRate,
                                 &SampleTable->SamplePeriod,
                                 &Temp1);
    
            //
            // Convert %bandwidth to Bytes/SamplePeriod
            // 100bsp * 100 / 8 = BytesPerSecond
            // BytesPerSecond * SecondsInSamplePeriod = BytesInSamplePeriod
            // BytesInSamplePeriod * %Bandwidth / 100 = BytesInSamplePeriod
            //
            SecondsInSamplePeriod = BonDInfo->ulSecondsInSamplePeriod =
                In->ulLowerRecvSamplePeriod / 1000;
        
            BytesPerSecond =
                BundleCB->RFlowSpec.PeakBandwidth;
        
            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;
        
            BonDInfo->ulBytesInSamplePeriod = BytesInSamplePeriod;

            BonDInfo->usPercentBandwidth = In->usLowerRecvThreshold;

            temp = In->usLowerRecvThreshold;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            if (BonDInfo->State == BonDSignaled) {
                BonDInfo->State = BonDIdle;
            }
            NdisWanGetSystemTime(&BonDInfo->StartTime);
    
            if (In->ulLowerRecvSamplePeriod < LowestSamplePeriod ||
                LowestSamplePeriod == 0) {
                LowestSamplePeriod = In->ulLowerRecvSamplePeriod;
            }
        }
    
        if (In->usUpperRecvThreshold > 0) {
            BonDInfo = BundleCB->RUpperBonDInfo;
            SampleTable = &BonDInfo->SampleTable;
    
            //
            // One second is the smallest sample period we support!
            //
            if (In->ulUpperRecvSamplePeriod < 1000) {
                In->ulUpperRecvSamplePeriod = 1000;
            }

            //
            // We need to init the sample period in 100 nanoseconds
            //
            NdisWanInitWanTime(&Temp1, MILS_TO_100NANOS);
            NdisWanInitWanTime(&Temp2, In->ulUpperRecvSamplePeriod);
            NdisWanMultiplyWanTime(&SampleTable->SamplePeriod,
                                   &Temp1,
                                   &Temp2);
    
            //
            // The sample rate is the sample period divided by the number of
            // samples in the sample array
            //
            NdisWanInitWanTime(&Temp1, SampleTable->ulSampleArraySize);
            NdisWanDivideWanTime(&SampleTable->SampleRate,
                                 &SampleTable->SamplePeriod,
                                 &Temp1);
    
            //
            // Convert %bandwidth to Bytes/SamplePeriod
            // 100bsp * 100 / 8 = BytesPerSecond
            // BytesPerSecond * SecondsInSamplePeriod = BytesInSamplePeriod
            // BytesInSamplePeriod * %Bandwidth / 100 = BytesInSamplePeriod
            //
            SecondsInSamplePeriod = BonDInfo->ulSecondsInSamplePeriod =
                In->ulUpperRecvSamplePeriod / 1000;
        
            BytesPerSecond =
                BundleCB->RFlowSpec.PeakBandwidth;
        
            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;
        
            BonDInfo->ulBytesInSamplePeriod = BytesInSamplePeriod;

            BonDInfo->usPercentBandwidth = In->usUpperRecvThreshold;
    
            temp = In->usUpperRecvThreshold;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            if (BonDInfo->State == BonDSignaled) {
                BonDInfo->State = BonDIdle;
            }
            NdisWanGetSystemTime(&BonDInfo->StartTime);
    
            if (In->ulUpperRecvSamplePeriod < LowestSamplePeriod ||
                LowestSamplePeriod == 0) {
                LowestSamplePeriod = In->ulUpperRecvSamplePeriod;
            }
        }
    
#if 0
        //
        // I want to set a periodic timer with a period equal to
        // the smallest non-zero period
        //
        if (LowestSamplePeriod != 0) {
            LARGE_INTEGER   FireTime;
    
            BundleCB->TimerPeriod = LowestSamplePeriod/10;
    
            FireTime.QuadPart = Int32x32To64(BundleCB->TimerPeriod, -10000);
            KeSetTimerEx(&BundleCB->BonDTimer,
                         FireTime,
                         BundleCB->TimerPeriod,
                         &BundleCB->TimerDpc);
        }
#endif
        if (!(BundleCB->Flags & BOND_ENABLED) &&
            (LowestSamplePeriod != 0)) {
            
            InsertTailGlobalListEx(BonDWorkList, &BundleCB->BonDLinkage, 1000, 1000);

            BundleCB->Flags |= BOND_ENABLED;
        }

    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid.  This release the
    // BundleCB->Lock.
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}


#ifdef NT
NTSTATUS
SetThresholdEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    SetThresholdEvent

Routine Description:

    This function queues up an asyncevent for bandwidth on demand
    events.

Arguments:

    pInputBuffer - Pointer to the input structure that should be WAN_ASYNC_EVENT

    ulInputBufferLength - Length of input buffer should be sizeof(WAN_ASYNC_EVENT)

    pOutputBuffer - Pointer to the output structure that should be WAN_ASYNC_EVENT

    ulOutputBufferLength - Length of output buffer should be sizeof(WAN_ASYNC_EVENT)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here


Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_SET_THRESHOLD_EVENT);
    PIRP    pIrp = (PIRP)pInputBuffer;
    KIRQL   Irql;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetThresholdEvent:"));

    *pulBytesWritten = 0;

    if (ulOutputBufferLength < SizeNeeded) {
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetThresholdEvent: Buffer to small: Size: %d, SizeNeeded %d",
                      ulInputBufferLength, SizeNeeded));
        *pulBytesWritten = SizeNeeded;
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    //
    // The IRP was pended so setup a cancel routine and let the
    // i/o subsystem know about the pend.
    //
    IoMarkIrpPending(pIrp);

    NdisAcquireSpinLock(&ThresholdEventQueue.Lock);
    //
    // Setup the structure
    //
    InsertTailList(&ThresholdEventQueue.List, &(pIrp->Tail.Overlay.ListEntry));

    ThresholdEventQueue.ulCount++;

    if (ThresholdEventQueue.ulCount > ThresholdEventQueue.ulMaxCount) {
        ThresholdEventQueue.ulMaxCount = ThresholdEventQueue.ulCount;
    }

    IoSetCancelRoutine(pIrp, NdisWanCancelRoutine);

    NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

    return (STATUS_PENDING);
}
#endif

NTSTATUS
FlushThresholdEvents(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("FlushThresholdEvents:"));

    *pulBytesWritten = 0;

    CancelThresholdEvents();

    return (STATUS_SUCCESS);
}

NTSTATUS
IoSendPacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_IO_PACKET);
    PNDISWAN_IO_PACKET In = (PNDISWAN_IO_PACKET)pInputBuffer;
    PLINKCB LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("IoSendPacket:"));

    *pulBytesWritten = 0;

    do {
        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_SEND, ("IoSendPacket: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (ulInputBufferLength - SizeNeeded > glLargeDataBufferSize) {
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if ((LONG)ulInputBufferLength - FIELD_OFFSET(NDISWAN_IO_PACKET, PacketData) <
            (LONG)(In->usHeaderSize + In->usPacketSize)) {
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (In->usHandleType == LINKHANDLE) {
        
            if (!AreLinkAndBundleValid(In->hHandle, 
                                       TRUE,
                                       &LinkCB, 
                                       &BundleCB)) {

                NdisWanDbgOut(DBG_FAILURE, DBG_SEND, ("IoSendPacket: Invalid Handle: 0x%x, HandleType: 0x%x",
                              In->hHandle, In->usHandleType));
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            AcquireBundleLock(BundleCB);

        } else {

            if (!IsBundleValid(In->hHandle, 
                               TRUE,
                               &BundleCB)) {

                NdisWanDbgOut(DBG_FAILURE, DBG_SEND, ("IoSendPacket: Invalid Handle: 0x%x, HandleType: 0x%x",
                              In->hHandle, In->usHandleType));
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }
        
            AcquireBundleLock(BundleCB);

            if (BundleCB->ulLinkCBCount == 0) {

                NdisWanDbgOut(DBG_FAILURE, DBG_SEND, ("IoSendPacket: Invalid Handle: 0x%x, HandleType: 0x%x",
                              In->hHandle, In->usHandleType));
    
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;

            //
            // LinkCB's lock can be acquired while BundleCB's lock
            // is held
            //
            NdisDprAcquireSpinLock(&LinkCB->Lock);

            if (LinkCB->State != LINK_UP) {
                NdisWanDbgOut(DBG_FAILURE, DBG_SEND, ("IoSendPacket: Invalid Handle: 0x%x, HandleType: 0x%x",
                              In->hHandle, In->usHandleType));
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                NdisDprReleaseSpinLock(&LinkCB->Lock);
                LinkCB = NULL;
                break;
            }

            REF_LINKCB(LinkCB);

            NdisDprReleaseSpinLock(&LinkCB->Lock);
        }

#if 0
        if (LinkCB->Stats.FramesTransmitted == 0) {
            if (In->PacketData[0] != 0xC0 ||
                In->PacketData[1] != 0x21 ||
                In->PacketData[2] != 0x01) {
                DbgPrint("NDISWAN: IOSP-FirstFrame not LCP ConfigReq bcb %p, lcb %p\n",
                         BundleCB, LinkCB);
                DbgBreakPoint();
            }
        }
#endif
        //
        // Queue an Ndis Packet for this send
        //
        Status = 
            BuildIoPacket(LinkCB, BundleCB, In, FALSE);
    
    } while ( 0 );

    //
    // Derefs for the refs applied above
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}


#ifdef NT
NTSTATUS
IoReceivePacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_IO_PACKET) + 1500;
    PIRP    Irp = (PIRP)pInputBuffer;
    PIO_STACK_LOCATION  IrpSp;
    PNDISWAN_IO_PACKET  IoPacket;
    PRECV_DESC          RecvDesc;
    KIRQL               Irql;
    PLINKCB             LinkCB;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("IoReceivePacket:"));

    if (SizeNeeded > ulOutputBufferLength) {
        NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE, ("IoReceivePacket: Buffer to small: Size: %d, SizeNeeded %d",
                      ulOutputBufferLength, SizeNeeded));
        *pulBytesWritten = SizeNeeded;
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    //
    // Do we have any receive's buffered up that
    // can be completed?
    //
    NdisAcquireSpinLock(&IoRecvList.Lock);

    RecvDesc = (PRECV_DESC)IoRecvList.DescList.Flink;

    while ((PVOID)RecvDesc != (PVOID)&IoRecvList.DescList) {

        LinkCB = RecvDesc->LinkCB;

        NdisDprAcquireSpinLock(&LinkCB->Lock);

        if ((LinkCB->hLinkContext != NULL)) {
            break;
        }

        NdisDprReleaseSpinLock(&LinkCB->Lock);

        RecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;
    }

    IoMarkIrpPending(Irp);

    if ((PVOID)RecvDesc != (PVOID)&IoRecvList.DescList) {
        LONG        BufferLength, DataLength, CopySize;

        RemoveEntryList(&RecvDesc->Linkage);

        IoRecvList.ulDescCount--;

        LinkCB->RecvDescCount--;

        NdisDprReleaseSpinLock(&LinkCB->Lock);

        INSERT_RECV_EVENT('s');

        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        BufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
        DataLength = BufferLength - sizeof(NDISWAN_IO_PACKET) + 1;

        CopySize = (RecvDesc->CurrentLength > DataLength) ?
            DataLength : RecvDesc->CurrentLength;

        IoPacket = Irp->AssociatedIrp.SystemBuffer;

        IoPacket->hHandle = LinkCB->hLinkContext;
        IoPacket->usHandleType = LINKHANDLE;
        IoPacket->usHeaderSize = 14;
        IoPacket->usPacketSize = (USHORT)CopySize;
        IoPacket->usPacketFlags = 0;

        NdisMoveMemory(IoPacket->PacketData,
                       RecvDesc->CurrentBuffer,
                       CopySize);
#if DBG
        if (gbDumpRecv) {
            INT i;
            for (i = 0; i < RecvDesc->CurrentLength; i++) {
                if (i % 16 == 0) {
                    DbgPrint("\n");
                }
                DbgPrint("%x ", RecvDesc->CurrentBuffer[i]);
            }
            DbgPrint("\n");
        }
#endif

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(NDISWAN_IO_PACKET) - 1 + CopySize;

        IoRecvList.LastPacketNumber = IoPacket->PacketNumber;
        IoRecvList.LastIrp = Irp;
        IoRecvList.LastIrpStatus = STATUS_SUCCESS;
        IoRecvList.LastCopySize = (ULONG)Irp->IoStatus.Information;

        ASSERT((LONG_PTR)Irp->IoStatus.Information > 0);

        NdisReleaseSpinLock(&IoRecvList.Lock);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        NdisWanFreeRecvDesc(RecvDesc);

    } else {

        //
        // We did not have anything buffered so lets queue
        //

        //
        // The IRP was pended so setup a cancel routine and let the
        // i/o subsystem know about the pend.
        //

        //
        // Setup the structure
        //
        InsertTailList(&IoRecvList.IrpList, &(Irp->Tail.Overlay.ListEntry));

        IoRecvList.ulIrpCount++;

        IoSetCancelRoutine(Irp, NdisWanCancelRoutine);

        INSERT_RECV_EVENT('i');

        NdisReleaseSpinLock(&IoRecvList.Lock);
    }

    return (NDIS_STATUS_PENDING);
}

VOID
IoRecvIrpWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    )
{
    PLIST_ENTRY         Entry;
    PNDISWAN_IO_PACKET  IoPacket;
    PIO_STACK_LOCATION  IrpSp;
    PIRP                Irp;
    PRECV_DESC          RecvDesc;
    KIRQL               Irql;
    LONG                BufferLength, DataLength, CopySize;
    PLINKCB             LinkCB;
    PBUNDLECB           BundleCB;

    NdisAcquireSpinLock(&IoRecvList.Lock);

    do {

        IoRecvList.TimerScheduled = FALSE;

        //
        // Do we have any irps that we can complete?
        //
        if (IoRecvList.ulIrpCount == 0) {
            break;
        }

        //
        // Do we have any receive's buffered up?
        //
        RecvDesc = (PRECV_DESC)IoRecvList.DescList.Flink;

        while ((PVOID)RecvDesc != (PVOID)&IoRecvList.DescList) {

            LinkCB = RecvDesc->LinkCB;

            NdisDprAcquireSpinLock(&LinkCB->Lock);

            if (LinkCB->hLinkContext != NULL) {
                break;
            }

            NdisDprReleaseSpinLock(&LinkCB->Lock);

            RecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;
        }

        if ((PVOID)RecvDesc == (PVOID)&IoRecvList.DescList) {

            if (!IoRecvList.TimerScheduled) {
                WAN_TIME    TimeOut;

                IoRecvList.TimerScheduled = TRUE;
                NdisWanInitWanTime(&TimeOut, 15);
                KeSetTimer(&IoRecvList.Timer,
                           TimeOut,
                           &IoRecvList.Dpc);
            }

            break;
        }

        Entry = IoRecvList.IrpList.Flink;
        Irp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
        if (!IoSetCancelRoutine(Irp, NULL)) {
            break;
        }

        //
        // Get the recvdesc
        //
        RemoveEntryList(&RecvDesc->Linkage);

        IoRecvList.ulDescCount--;

        LinkCB->RecvDescCount--;

        RemoveHeadList(&IoRecvList.IrpList);

        IoRecvList.ulIrpCount--;

        INSERT_RECV_EVENT('w');

        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        BufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
        DataLength = BufferLength - sizeof(NDISWAN_IO_PACKET);

        CopySize = (RecvDesc->CurrentLength > DataLength) ?
            DataLength : RecvDesc->CurrentLength;

        IoPacket = Irp->AssociatedIrp.SystemBuffer;

        IoPacket->hHandle = LinkCB->hLinkContext;
        IoPacket->usHandleType = LINKHANDLE;
        IoPacket->usHeaderSize = 14;
        IoPacket->usPacketSize = (USHORT)CopySize;
        IoPacket->usPacketFlags = 0;

        NdisDprReleaseSpinLock(&LinkCB->Lock);

        NdisReleaseSpinLock(&IoRecvList.Lock);

#if DBG
        if (gbDumpRecv) {
            INT i;
            for (i = 0; i < RecvDesc->CurrentLength; i++) {
                if (i % 16 == 0) {
                    DbgPrint("\n");
                }
                DbgPrint("%x ", RecvDesc->CurrentBuffer[i]);
            }
            DbgPrint("\n");
        }
#endif

        NdisMoveMemory(IoPacket->PacketData,
                       RecvDesc->CurrentBuffer,
                       CopySize);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(NDISWAN_IO_PACKET) - 1 + CopySize;

        IoRecvList.LastPacketNumber = IoPacket->PacketNumber;
        IoRecvList.LastIrp = Irp;
        IoRecvList.LastIrpStatus = STATUS_SUCCESS;
        IoRecvList.LastCopySize = (ULONG)Irp->IoStatus.Information;

        ASSERT((LONG_PTR)Irp->IoStatus.Information > 0);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        NdisWanFreeRecvDesc(RecvDesc);

        NdisAcquireSpinLock(&IoRecvList.Lock);

    } while (FALSE);

    NdisReleaseSpinLock(&IoRecvList.Lock);
}

#endif


NTSTATUS
FlushReceivePacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("FlushReceivePacket:"));

    *pulBytesWritten = 0;

    CancelIoReceivePackets();

    return (STATUS_SUCCESS);
}


NTSTATUS
GetStatistics(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_STATS);
    PNDISWAN_GET_STATS  In = (PNDISWAN_GET_STATS)pInputBuffer;
    PNDISWAN_GET_STATS  Out = (PNDISWAN_GET_STATS)pOutputBuffer;
    PBUNDLECB   BundleCB = NULL;
    PLINKCB     LinkCB = NULL;

    NdisWanDbgOut(DBG_VERBOSE, DBG_IO, ("GetStatistics:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
    
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetStatistics: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
    
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        NdisZeroMemory(&Out->Stats, sizeof(Out->Stats));
    
        if (In->usHandleType == LINKHANDLE) {
    
            //
            // Looking for link stats
            //
            if (!AreLinkAndBundleValid(In->hHandle, 
                                       FALSE,
                                       &LinkCB, 
                                       &BundleCB)) {

                NdisWanDbgOut(DBG_INFO, DBG_IO, ("GetStatistics: Invalid LinkHandle: 0x%x",
                              In->hHandle));
    
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            AcquireBundleLock(BundleCB);

            //
            // At this point we have a valid bundlecb and linkcb
            //

            //
            // Copy the stats over
            //
            NdisMoveMemory((PUCHAR)&Out->Stats.LinkStats,
                           (PUCHAR)&LinkCB->Stats,
                           sizeof(WAN_STATS));


            //
            // Copy the stats over
            //
            NdisMoveMemory((PUCHAR)&Out->Stats.BundleStats,
                           (PUCHAR)&BundleCB->Stats,
                           sizeof(WAN_STATS));

        } else if (In->usHandleType == BUNDLEHANDLE) {

            //
            // Looking for bundle stats
            //
            if (!IsBundleValid(In->hHandle, 
                               FALSE,
                               &BundleCB)) {

                NdisWanDbgOut(DBG_INFO, DBG_IO, ("GetStatistics: Invalid BundleHandle: 0x%x",
                              In->hHandle));
    
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            AcquireBundleLock(BundleCB);

            //
            // At this point we have a valid bundlecb
            //

            //
            // Copy the stats over
            //
            NdisMoveMemory((PUCHAR)&Out->Stats.BundleStats,
                           (PUCHAR)&BundleCB->Stats,
                           sizeof(WAN_STATS));
        } else {
            Status = NDISWAN_ERROR_INVALID_HANDLE_TYPE;
            break;
        }

        //
        // If we only have one protocol bound see if
        // it is keeping stats
        //
        if (BundleCB->ulNumberOfRoutes == 1) {
            PPROTOCOLCB ProtocolCB;
            PMINIPORTCB MiniportCB;

            ProtocolCB =
                (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;

            MiniportCB = ProtocolCB->MiniportCB;

            if (MiniportCB->Flags & PROTOCOL_KEEPS_STATS) {
                NDIS_WAN_GET_STATS  WanStats;

                ReleaseBundleLock(BundleCB);

                NdisZeroMemory(&WanStats, sizeof(NDIS_WAN_GET_STATS));

                ETH_COPY_NETWORK_ADDRESS(WanStats.LocalAddress, ProtocolCB->TransportAddress);

                NdisMoveMemory((PUCHAR)&WanStats.BytesSent,
                               (PUCHAR)&Out->Stats.BundleStats,
                               sizeof(WAN_STATS));

                NdisMIndicateStatus(MiniportCB->MiniportHandle,
                                    NDIS_STATUS_WAN_GET_STATS,
                                    &WanStats,
                                    sizeof(NDIS_WAN_GET_STATS));

                NdisMoveMemory((PUCHAR)&Out->Stats.LinkStats,
                               (PUCHAR)&WanStats.BytesSent,
                               sizeof(WAN_STATS));

                NdisMoveMemory((PUCHAR)&Out->Stats.BundleStats,
                               (PUCHAR)&WanStats.BytesSent,
                               sizeof(WAN_STATS));

                AcquireBundleLock(BundleCB);

            }
        }

    } while ( 0 );

    //
    // Derefs for the refs applied above
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
SetLinkInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           SizeNeeded = sizeof(NDISWAN_SET_LINK_INFO);
    WAN_REQUEST     WanRequest;
    PNDISWAN_SET_LINK_INFO  In = (PNDISWAN_SET_LINK_INFO)pInputBuffer;
    PWAN_LINK_INFO  LinkInfo;
    POPENCB         OpenCB;
    PLINKCB         TempLinkCB,LinkCB = NULL;
    PBUNDLECB       BundleCB = NULL;
    BOOLEAN         MediaBroadband = FALSE;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetLinkInfo:"));

    *pulBytesWritten = 0;

    do {

        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetLinkInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {

            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        LinkInfo = &LinkCB->LinkInfo;
        OpenCB = LinkCB->OpenCB;

        if (OpenCB->MediumType == NdisMediumAtm ||

            (OpenCB->MediumType == NdisMediumWan &&
            (OpenCB->MediumSubType == NdisWanMediumAtm ||
             OpenCB->MediumSubType == NdisWanMediumPppoe)) ||

            (OpenCB->MediumType == NdisMediumCoWan &&
            (OpenCB->MediumSubType == NdisWanMediumAtm ||
             OpenCB->MediumSubType == NdisWanMediumPppoe))) {

            MediaBroadband = TRUE;
        }

        //
        // Wait for initialization to complete
        //
        NdisWanWaitForNotificationEvent(&OpenCB->InitEvent);

        WanRequest.Type = SYNC;
        WanRequest.Origin = NDISWAN;
        NdisWanInitializeNotificationEvent(&WanRequest.NotificationEvent);
        WanRequest.OpenCB = OpenCB;
    
        if (OpenCB->Flags & OPEN_LEGACY) {
            NDIS_WAN_SET_LINK_INFO  WanMiniportLinkInfo;
    
            NdisZeroMemory(&WanMiniportLinkInfo, sizeof (NDIS_WAN_SET_LINK_INFO));
        
            //
            // Copy into buffer to be sent to WAN Miniport this
            // skips over the LinkHandle in the NDIS_WAN_SET_LINK_INFO
            // structure.
            //
            WanMiniportLinkInfo.NdisLinkHandle = LinkCB->NdisLinkHandle;
            WanMiniportLinkInfo.MaxSendFrameSize = In->LinkInfo.MaxSendFrameSize;
            WanMiniportLinkInfo.MaxRecvFrameSize = In->LinkInfo.MaxRecvFrameSize;
            WanMiniportLinkInfo.SendFramingBits = In->LinkInfo.SendFramingBits;
            WanMiniportLinkInfo.RecvFramingBits = In->LinkInfo.RecvFramingBits;
            WanMiniportLinkInfo.SendCompressionBits = In->LinkInfo.SendCompressionBits;
            WanMiniportLinkInfo.RecvCompressionBits = In->LinkInfo.RecvCompressionBits;
            WanMiniportLinkInfo.SendACCM = In->LinkInfo.SendACCM;
            WanMiniportLinkInfo.RecvACCM = In->LinkInfo.RecvACCM;
        
            //
            // Submit this to the WAN Miniport
            //
            WanRequest.NdisRequest.RequestType = 
                NdisRequestSetInformation;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid = 
                OID_WAN_SET_LINK_INFO;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer = 
                &WanMiniportLinkInfo;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 
                sizeof(NDIS_WAN_SET_LINK_INFO);
        
            NdisWanSubmitNdisRequest(OpenCB, &WanRequest);
        
        } else {
            NDIS_WAN_CO_SET_LINK_INFO   WanMiniportLinkInfo;

            NdisAcquireSpinLock(&LinkCB->Lock);

            if (LinkCB->ClCallState == CL_CALL_CONNECTED) {

                //
                // Ref so that we don't allow the
                // vc to go away.
                //
                LinkCB->VcRefCount++;

                NdisReleaseSpinLock(&LinkCB->Lock);

                NdisZeroMemory(&WanMiniportLinkInfo, sizeof (NDIS_WAN_CO_SET_LINK_INFO));

                //
                // Copy into buffer to be sent to WAN Miniport this
                // skips over the LinkHandle in the NDIS_WAN_SET_LINK_INFO
                // structure.
                //
                WanMiniportLinkInfo.MaxSendFrameSize = In->LinkInfo.MaxSendFrameSize;
                WanMiniportLinkInfo.MaxRecvFrameSize = In->LinkInfo.MaxRecvFrameSize;
                WanMiniportLinkInfo.SendFramingBits = In->LinkInfo.SendFramingBits;
                WanMiniportLinkInfo.RecvFramingBits = In->LinkInfo.RecvFramingBits;
                WanMiniportLinkInfo.SendCompressionBits = In->LinkInfo.SendCompressionBits;
                WanMiniportLinkInfo.RecvCompressionBits = In->LinkInfo.RecvCompressionBits;
                WanMiniportLinkInfo.SendACCM = In->LinkInfo.SendACCM;
                WanMiniportLinkInfo.RecvACCM = In->LinkInfo.RecvACCM;

                //
                // Submit this to the WAN Miniport
                //
                WanRequest.NdisRequest.RequestType = 
                    NdisRequestSetInformation;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid = 
                    OID_WAN_CO_SET_LINK_INFO;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer = 
                    &WanMiniportLinkInfo;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 
                    sizeof(NDIS_WAN_CO_SET_LINK_INFO);

                WanRequest.AfHandle = NULL;
                WanRequest.VcHandle = LinkCB->NdisLinkHandle;

                NdisWanSubmitNdisRequest(OpenCB, &WanRequest);

                NdisAcquireSpinLock(&LinkCB->Lock);

                DerefVc(LinkCB);

                NdisReleaseSpinLock(&LinkCB->Lock);

            } else {

                NdisReleaseSpinLock(&LinkCB->Lock);
            }
        }
    
        //
        // Copy info into our linkcb
        //
        AcquireBundleLock(BundleCB);
    
        ASSERT(In->LinkInfo.SendFramingBits != 0);
        ASSERT(In->LinkInfo.RecvFramingBits != 0);

        //
        // If we are using broadband the we must preserve the LLC and
        // ADDRESS_CONTROL framing bits.
        //
        if (MediaBroadband) {
            LinkInfo->SendFramingBits |= In->LinkInfo.SendFramingBits;
            LinkInfo->RecvFramingBits |= In->LinkInfo.RecvFramingBits;
        } else {
            LinkInfo->SendFramingBits = In->LinkInfo.SendFramingBits;
            LinkInfo->RecvFramingBits = In->LinkInfo.RecvFramingBits;
        }

        LinkCB->SFlowSpec.MaxSduSize = 
        LinkInfo->MaxSendFrameSize = In->LinkInfo.MaxSendFrameSize;

        if (OpenCB->WanInfo.MaxFrameSize < LinkCB->SFlowSpec.MaxSduSize) {
            LinkCB->SFlowSpec.MaxSduSize = OpenCB->WanInfo.MaxFrameSize;
        }

        LinkCB->RFlowSpec.MaxSduSize = 
        LinkInfo->MaxRecvFrameSize = In->LinkInfo.MaxRecvFrameSize;

        LinkInfo->SendCompressionBits = In->LinkInfo.SendCompressionBits;
        LinkInfo->RecvCompressionBits = In->LinkInfo.RecvCompressionBits;
        LinkInfo->SendACCM = In->LinkInfo.SendACCM;
        LinkInfo->RecvACCM = In->LinkInfo.RecvACCM;
        LinkInfo->MaxRRecvFrameSize = In->LinkInfo.MaxRRecvFrameSize;
        LinkInfo->MaxRSendFrameSize = In->LinkInfo.MaxRSendFrameSize;
    
        if (LinkInfo->RecvFramingBits & LLC_ENCAPSULATION) {
            LinkCB->RecvHandler = ReceiveLLC;
        } else if (LinkInfo->RecvFramingBits & PPP_FRAMING) {
            LinkCB->RecvHandler = ReceivePPP;
        } else if (LinkInfo->RecvFramingBits & RAS_FRAMING) {
            LinkCB->RecvHandler = ReceiveRAS;
        } else if (LinkInfo->RecvFramingBits & SLIP_FRAMING) {
            LinkCB->RecvHandler = ReceiveSLIP;
        } else if (LinkInfo->RecvFramingBits & (ARAP_V1_FRAMING | ARAP_V2_FRAMING)) {
            LinkCB->RecvHandler = ReceiveARAP;
        } else {
            if (MediaBroadband) {
                LinkCB->RecvHandler = DetectBroadbandFraming;
            } else {
                LinkCB->RecvHandler = DetectFraming;
            }
        }
    

        //
        // We need to set our bundle framing based on the framing for
        // each link in the bundle so we will walk the linkcb list
        // and | in each link's framing bits into the bundle.
        //
        //
        BundleCB->FramingInfo.SendFramingBits = 0;
        BundleCB->FramingInfo.RecvFramingBits = 0;
    
        for (TempLinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
            (PVOID)TempLinkCB != (PVOID)&BundleCB->LinkCBList;
            TempLinkCB = (PLINKCB)TempLinkCB->Linkage.Flink) {
    
            BundleCB->FramingInfo.SendFramingBits |= TempLinkCB->LinkInfo.SendFramingBits;
            BundleCB->FramingInfo.RecvFramingBits |= TempLinkCB->LinkInfo.RecvFramingBits;
        }
    
        BundleCB->FramingInfo.MaxRSendFrameSize = LinkInfo->MaxRSendFrameSize;
    
        //
        // Since I use the receive frame size for memory allocation.
        //
        BundleCB->FramingInfo.MaxRRecvFrameSize = (LinkInfo->MaxRRecvFrameSize) ?
                                                      LinkInfo->MaxRRecvFrameSize : glMRRU;

        //
        // If VJ header compression has been negotiated allocate
        // and initialize resources.
        //
        if (BundleCB->FramingInfo.SendFramingBits & SLIP_VJ_COMPRESSION ||
            BundleCB->FramingInfo.SendFramingBits & SLIP_VJ_AUTODETECT ||
            BundleCB->FramingInfo.RecvFramingBits & SLIP_VJ_COMPRESSION ||
            BundleCB->FramingInfo.RecvFramingBits & SLIP_VJ_AUTODETECT) {
    
            Status = sl_compress_init(&BundleCB->VJCompress, MAX_VJ_STATES);
    
            if (Status != NDIS_STATUS_SUCCESS) {
                NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("Error allocating VJ Info!"));
            }
        }
    
        //
        // Configure multilink variables if needed
        //
        if (BundleCB->FramingInfo.SendFramingBits & PPP_MULTILINK_FRAMING) {
            if (BundleCB->FramingInfo.SendFramingBits & PPP_SHORT_SEQUENCE_HDR_FORMAT) {
                BundleCB->SendSeqMask = SHORT_SEQ_MASK;
                BundleCB->SendSeqTest = TEST_SHORT_SEQ;
            } else {
                BundleCB->SendSeqMask = LONG_SEQ_MASK;
                BundleCB->SendSeqTest = TEST_LONG_SEQ;
            }
        }
            
        if (BundleCB->FramingInfo.RecvFramingBits & PPP_MULTILINK_FRAMING) {
            if (BundleCB->FramingInfo.RecvFramingBits & PPP_SHORT_SEQUENCE_HDR_FORMAT) {
                BundleCB->RecvSeqMask = SHORT_SEQ_MASK;
                BundleCB->RecvSeqTest = TEST_SHORT_SEQ;
            } else {
                BundleCB->RecvSeqMask = LONG_SEQ_MASK;
                BundleCB->RecvSeqTest = TEST_LONG_SEQ;
            }
        }

        SetBundleFlags(BundleCB);

        UpdateBundleInfo(BundleCB);
    
    } while ( 0 );

    //
    // Derefs for the refs applied by AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
GetLinkInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_LINK_INFO);
    PNDISWAN_GET_LINK_INFO  In = (PNDISWAN_GET_LINK_INFO)pInputBuffer;
    PNDISWAN_GET_LINK_INFO  Out = (PNDISWAN_GET_LINK_INFO)pOutputBuffer;
    PLINKCB         LinkCB = NULL;
    PWAN_LINK_INFO  LinkInfo;
    POPENCB         OpenCB;
    WAN_REQUEST     WanRequest;
    union {
        NDIS_WAN_GET_LINK_INFO      Mp;
        NDIS_WAN_CO_GET_LINK_INFO   Co;
    } WanMiniportLinkInfo;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetLinkInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetLinkInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!IsLinkValid(In->hLinkHandle, 
                         TRUE,
                         &LinkCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetLinkInfo: Invalid LinkHandle: 0x%x",
                          In->hLinkHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        LinkInfo = &LinkCB->LinkInfo;
        OpenCB = LinkCB->OpenCB;

        WanRequest.Type = SYNC;
        WanRequest.Origin = NDISWAN;
        NdisWanInitializeNotificationEvent(&WanRequest.NotificationEvent);
        WanRequest.OpenCB = OpenCB;
        NdisZeroMemory(&WanMiniportLinkInfo, 
                       sizeof (WanMiniportLinkInfo));
    
        if (OpenCB->Flags & OPEN_LEGACY) {
    
            //
            // Setup the link context for this request
            //
            WanMiniportLinkInfo.Mp.NdisLinkHandle = 
                LinkCB->NdisLinkHandle;
        
            //
            // Submit this to the WAN Miniport
            //
            WanRequest.NdisRequest.RequestType = 
                NdisRequestQueryInformation;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid = 
                OID_WAN_GET_LINK_INFO;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer = 
                &WanMiniportLinkInfo.Mp;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 
                sizeof(NDIS_WAN_GET_LINK_INFO);
        
            Status = NdisWanSubmitNdisRequest(OpenCB, &WanRequest);
        
            if (Status == NDIS_STATUS_SUCCESS) {

                LinkInfo->MaxSendFrameSize = 
                    WanMiniportLinkInfo.Mp.MaxSendFrameSize;
                LinkInfo->MaxRecvFrameSize = 
                    WanMiniportLinkInfo.Mp.MaxRecvFrameSize;
                LinkInfo->SendFramingBits = 
                    WanMiniportLinkInfo.Mp.SendFramingBits;
                LinkInfo->RecvFramingBits = 
                    WanMiniportLinkInfo.Mp.RecvFramingBits;
                LinkInfo->SendCompressionBits = 
                    WanMiniportLinkInfo.Mp.SendCompressionBits;
                LinkInfo->RecvCompressionBits = 
                    WanMiniportLinkInfo.Mp.RecvCompressionBits;
                LinkInfo->SendACCM = 
                    WanMiniportLinkInfo.Mp.SendACCM;
                LinkInfo->RecvACCM = 
                    WanMiniportLinkInfo.Mp.RecvACCM;
            }

        } else {

            NdisAcquireSpinLock(&LinkCB->Lock);

            if (LinkCB->ClCallState == CL_CALL_CONNECTED) {

                //
                // Ref so that we don't allow the
                // vc to go away.
                //
                LinkCB->VcRefCount++;

                NdisReleaseSpinLock(&LinkCB->Lock);

                //
                // Submit this to the WAN Miniport
                //
                WanRequest.NdisRequest.RequestType = 
                    NdisRequestQueryInformation;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid = 
                    OID_WAN_CO_GET_LINK_INFO;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer = 
                    &WanMiniportLinkInfo.Co;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 
                    sizeof(NDIS_WAN_CO_GET_LINK_INFO);

                WanRequest.AfHandle = NULL;
                WanRequest.VcHandle = LinkCB->NdisLinkHandle;

                Status = NdisWanSubmitNdisRequest(OpenCB, &WanRequest);

                NdisAcquireSpinLock(&LinkCB->Lock);

                DerefVc(LinkCB);

                NdisReleaseSpinLock(&LinkCB->Lock);

                if (Status == NDIS_STATUS_SUCCESS) {

                    LinkInfo->MaxSendFrameSize = 
                        WanMiniportLinkInfo.Co.MaxSendFrameSize;
                    LinkInfo->MaxRecvFrameSize = 
                        WanMiniportLinkInfo.Co.MaxRecvFrameSize;
                    LinkInfo->SendFramingBits = 
                        WanMiniportLinkInfo.Co.SendFramingBits;
                    LinkInfo->RecvFramingBits = 
                        WanMiniportLinkInfo.Co.RecvFramingBits;
                    LinkInfo->SendCompressionBits = 
                        WanMiniportLinkInfo.Co.SendCompressionBits;
                    LinkInfo->RecvCompressionBits = 
                        WanMiniportLinkInfo.Co.RecvCompressionBits;
                    LinkInfo->SendACCM = 
                        WanMiniportLinkInfo.Co.SendACCM;
                    LinkInfo->RecvACCM = 
                        WanMiniportLinkInfo.Co.RecvACCM;
                }

            } else {

                NdisReleaseSpinLock(&LinkCB->Lock);
            }
        }
    
        Status = NDIS_STATUS_SUCCESS;

        //
        // Fill Recv and Send MRRU
        //
        LinkInfo->MaxRSendFrameSize = glMaxMTU;
    
        LinkInfo->MaxRRecvFrameSize = glMRRU;
    
        NdisMoveMemory(&Out->LinkInfo,
                       LinkInfo,
                       sizeof(WAN_LINK_INFO));

        Out->hLinkHandle = LinkCB->hLinkHandle;

    } while ( 0 );

    //
    // Deref for ref applied by IsLinkValid
    //
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
SetCompressionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_SET_COMPRESSION_INFO);
    PNDISWAN_SET_COMPRESSION_INFO   In = (PNDISWAN_SET_COMPRESSION_INFO)pInputBuffer;
    PLINKCB         LinkCB = NULL;
    PBUNDLECB       BundleCB = NULL;
    POPENCB         OpenCB;
    WAN_REQUEST WanRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetCompressionInfo:"));

    *pulBytesWritten = 0;

    do {
        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetCompressionInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetCompressionInfo: Invalid LinkHandle: 0x%x",
                          In->hLinkHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        OpenCB = LinkCB->OpenCB;
    
#ifdef DEBUG_CCP
{
    PCOMPRESS_INFO  CompInfo;
    PUCHAR          Key;

    CompInfo = &In->SendCapabilities;
    DbgPrint("==>NdisWan: Set Send CompressInfo\n");

    DbgPrint("MSCompType:      %x\n", CompInfo->MSCompType);
    DbgPrint("AuthType:        %x\n", CompInfo->AuthType);
    DbgPrint("Flags:           %x\n", CompInfo->Flags);

    CompInfo = &In->RecvCapabilities;
    DbgPrint("==>NdisWan: Set Recv CompressInfo\n");

    DbgPrint("MSCompType:      %x\n", CompInfo->MSCompType);
    DbgPrint("AuthType:        %x\n", CompInfo->AuthType);
    DbgPrint("Flags:           %x\n", CompInfo->Flags);
}
#endif
        AcquireBundleLock(BundleCB);
    
        BundleCB->SendCompInfo.Flags =
            In->SendCapabilities.Flags;

        BundleCB->RecvCompInfo.Flags =
            In->RecvCapabilities.Flags;

        if (In->SendCapabilities.Flags & CCP_SET_KEYS) {

            BundleCB->SendCompInfo.AuthType =
                In->SendCapabilities.AuthType;

            NdisMoveMemory(&BundleCB->SendCompInfo.LMSessionKey,
                           &In->SendCapabilities.LMSessionKey,
                           sizeof(BundleCB->SendCompInfo.LMSessionKey));

            NdisMoveMemory(&BundleCB->SendCompInfo.UserSessionKey,
                           &In->SendCapabilities.UserSessionKey,
                           sizeof(BundleCB->SendCompInfo.UserSessionKey));

            NdisMoveMemory(&BundleCB->SendCompInfo.Challenge,
                           &In->SendCapabilities.Challenge,
                           sizeof(BundleCB->SendCompInfo.Challenge));

            NdisMoveMemory(&BundleCB->SendCompInfo.NTResponse,
                           &In->SendCapabilities.NTResponse,
                           sizeof(BundleCB->SendCompInfo.NTResponse));
#ifdef EAP_ON
            NdisMoveMemory(&BundleCB->SendCompInfo.EapKey,
                           &In->SendCapabilities.EapKey,
                           sizeof(BundleCB->SendCompInfo.EapKey));
#endif

#ifdef DEBUG_CCP
{
    PCOMPRESS_INFO  CompInfo;
    PUCHAR          Key;

    CompInfo = &BundleCB->SendCompInfo;

    Key = CompInfo->LMSessionKey;
    DbgPrint("Send KeyInfo\n");
    DbgPrint("LMSession Key:   %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->UserSessionKey;
    DbgPrint("UserSession Key: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    Key = CompInfo->Challenge;
    DbgPrint("Challenge:       %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->NTResponse;
    DbgPrint("NTResponse:      %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    DbgPrint("                 %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[16],Key[17],Key[18],Key[19],
        Key[20],Key[21],Key[22],Key[23]);

#ifdef EAP_ON
{
    ULONG   KeyLength, i;

    Key = CompInfo->EapKey;
    KeyLength = sizeof(CompInfo->EapKey);
    i = 0;

    DbgPrint("Eap Key:\n");
    while (i <= KeyLength-16) {
        DbgPrint("%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
            Key[i],Key[i+1],Key[i+2],Key[i+3],
            Key[i+4],Key[i+5],Key[i+6],Key[i+7],
            Key[i+8],Key[i+9],Key[i+10],Key[i+11],
            Key[i+12],Key[i+13],Key[i+14],Key[i+15]);
        i += 16;
    }
}
#endif

}
#endif
        }

        if (In->RecvCapabilities.Flags & CCP_SET_KEYS) {

            BundleCB->RecvCompInfo.AuthType =
                In->RecvCapabilities.AuthType;

            NdisMoveMemory(&BundleCB->RecvCompInfo.LMSessionKey,
                           &In->RecvCapabilities.LMSessionKey,
                           sizeof(BundleCB->RecvCompInfo.LMSessionKey));

            NdisMoveMemory(&BundleCB->RecvCompInfo.UserSessionKey,
                           &In->RecvCapabilities.UserSessionKey,
                           sizeof(BundleCB->RecvCompInfo.UserSessionKey));

            NdisMoveMemory(&BundleCB->RecvCompInfo.Challenge,
                           &In->RecvCapabilities.Challenge,
                           sizeof(BundleCB->RecvCompInfo.Challenge));

            NdisMoveMemory(&BundleCB->RecvCompInfo.NTResponse,
                           &In->RecvCapabilities.NTResponse,
                           sizeof(BundleCB->RecvCompInfo.NTResponse));
#ifdef EAP_ON
            NdisMoveMemory(&BundleCB->RecvCompInfo.EapKey,
                           &In->RecvCapabilities.EapKey,
                           sizeof(BundleCB->RecvCompInfo.EapKey));
#endif


#ifdef DEBUG_CCP
{
    PCOMPRESS_INFO  CompInfo;
    PUCHAR          Key;

    CompInfo = &BundleCB->RecvCompInfo;

    Key = CompInfo->LMSessionKey;
    DbgPrint("Recv KeyInfo\n");
    DbgPrint("LMSession Key:   %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->UserSessionKey;
    DbgPrint("UserSession Key: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    Key = CompInfo->Challenge;
    DbgPrint("Challenge:       %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->NTResponse;
    DbgPrint("NTResponse:      %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    DbgPrint("                 %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[16],Key[17],Key[18],Key[19],
        Key[20],Key[21],Key[22],Key[23]);

#ifdef EAP_ON
{
    ULONG   KeyLength, i;

    Key = CompInfo->EapKey;
    KeyLength = sizeof(CompInfo->EapKey);
    i = 0;

    DbgPrint("Eap Key:\n");
    while (i <= KeyLength-16) {
        DbgPrint("%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
            Key[i],Key[i+1],Key[i+2],Key[i+3],
            Key[i+4],Key[i+5],Key[i+6],Key[i+7],
            Key[i+8],Key[i+9],Key[i+10],Key[i+11],
            Key[i+12],Key[i+13],Key[i+14],Key[i+15]);
        i += 16;
    }
}
#endif
}
#endif
        }

        do {

            if (In->SendCapabilities.Flags & CCP_SET_COMPTYPE) {

                BundleCB->SendCompInfo.MSCompType =
                    In->SendCapabilities.MSCompType;

                do {

                    if (!(BundleCB->Flags & SEND_CCP_ALLOCATED)) {

                        BundleCB->SCoherencyCounter = 0;

                        BundleCB->Flags |= SEND_CCP_ALLOCATED;

                        Status = WanAllocateCCP(BundleCB,
                                                &BundleCB->SendCompInfo,
                                                TRUE);

                        if (Status != STATUS_SUCCESS) {
                            break;
                        }
                    }

                    if (!(BundleCB->Flags & SEND_ECP_ALLOCATED)) {

                        BundleCB->SCoherencyCounter = 0;
                        BundleCB->Flags |= SEND_ECP_ALLOCATED;

                        Status = WanAllocateECP(BundleCB,
                                                &BundleCB->SendCompInfo,
                                                &BundleCB->SendCryptoInfo,
                                                TRUE);

                        if (Status != STATUS_SUCCESS) {
                            break;
                        }
                    }

                } while (FALSE);

                if (Status != STATUS_SUCCESS) {
                    break;
                }
            }

            if (In->RecvCapabilities.Flags & CCP_SET_COMPTYPE) {

                BundleCB->RecvCompInfo.MSCompType =
                    In->RecvCapabilities.MSCompType;

                do {

                    if (!(BundleCB->Flags & RECV_CCP_ALLOCATED)) {
                        BundleCB->RCoherencyCounter = 0;
                        BundleCB->LastRC4Reset = 0;
                        BundleCB->CCPIdentifier = 0;

                        BundleCB->Flags |= RECV_CCP_ALLOCATED;

                        Status = WanAllocateCCP(BundleCB,
                                                &BundleCB->RecvCompInfo,
                                                FALSE);

                        if (Status != STATUS_SUCCESS) {
                            break;
                        }
                    }

                    if (!(BundleCB->Flags & RECV_ECP_ALLOCATED)) {
                        BundleCB->RCoherencyCounter = 0;
                        BundleCB->LastRC4Reset = 0;
                        BundleCB->CCPIdentifier = 0;

                        BundleCB->Flags |= RECV_ECP_ALLOCATED;

                        Status = WanAllocateECP(BundleCB,
                                                &BundleCB->RecvCompInfo,
                                                &BundleCB->RecvCryptoInfo,
                                                FALSE);

                        if (Status != STATUS_SUCCESS) {
                            break;
                        }
                    }

                } while (FALSE);

                if (Status != STATUS_SUCCESS) {
                    break;
                }
            }

        } while (FALSE);

        if (Status != STATUS_SUCCESS) {
            if (BundleCB->Flags & SEND_CCP_ALLOCATED) {
                BundleCB->Flags &= ~SEND_CCP_ALLOCATED;
                WanDeallocateCCP(BundleCB,
                                 &BundleCB->SendCompInfo,
                                 TRUE);
            }

            if (BundleCB->Flags & RECV_CCP_ALLOCATED) {
                BundleCB->Flags &= ~RECV_CCP_ALLOCATED;
                WanDeallocateCCP(BundleCB,
                                 &BundleCB->RecvCompInfo,
                                 FALSE);
            }

            if (BundleCB->Flags & SEND_ECP_ALLOCATED) {
                BundleCB->Flags &= ~SEND_ECP_ALLOCATED;
                WanDeallocateECP(BundleCB,
                                 &BundleCB->SendCompInfo,
                                 &BundleCB->SendCryptoInfo);
            }

            if (BundleCB->Flags & RECV_ECP_ALLOCATED) {
                BundleCB->Flags &= ~RECV_ECP_ALLOCATED;
                WanDeallocateECP(BundleCB,
                                 &BundleCB->RecvCompInfo,
                                 &BundleCB->RecvCryptoInfo);
            }
        }

        if (In->SendCapabilities.Flags & CCP_PAUSE_DATA) {

            BundleCB->Flags |= PAUSE_DATA;

        } else {

            BundleCB->Flags &= ~PAUSE_DATA;

            if (!(BundleCB->Flags & DEFERRED_WORK_QUEUED)) {

                //
                // Need to kick off sends again!
                //
                REF_BUNDLECB(BundleCB);
                BundleCB->Flags |= DEFERRED_WORK_QUEUED;
                InsertTailGlobalListEx(DeferredWorkList,
                                       &BundleCB->DeferredLinkage,
                                       15,
                                       0);

            }
        }

        SetBundleFlags(BundleCB);
    
    } while ( 0 );

    //
    // Derefs for the refs applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
GetCompressionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_COMPRESSION_INFO);
    PNDISWAN_GET_COMPRESSION_INFO In = (PNDISWAN_GET_COMPRESSION_INFO)pInputBuffer;
    PNDISWAN_GET_COMPRESSION_INFO Out = (PNDISWAN_GET_COMPRESSION_INFO)pOutputBuffer;
    PLINKCB         LinkCB = NULL;
    PBUNDLECB       BundleCB = NULL;
    POPENCB         OpenCB;
    ULONG   i;
    WAN_REQUEST WanRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetCompressionInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulInputBufferLength < SizeNeeded ||
            ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetCompressionInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {

            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
    
        OpenCB = LinkCB->OpenCB;

        Out->SendCapabilities.CompType = COMPTYPE_NONE;
        Out->SendCapabilities.CompLength = 0;
        Out->RecvCapabilities.CompType = COMPTYPE_NONE;
        Out->RecvCapabilities.CompLength = 0;

        AcquireBundleLock(BundleCB);
    
        //
        // Fill in the ndiswan specific stuff
        //
        NdisMoveMemory(Out->SendCapabilities.LMSessionKey,
                       BundleCB->SendCompInfo.LMSessionKey,
                       sizeof(Out->SendCapabilities.LMSessionKey));
    
        NdisMoveMemory(Out->SendCapabilities.UserSessionKey,
                       BundleCB->SendCompInfo.UserSessionKey,
                       sizeof(Out->SendCapabilities.UserSessionKey));
    
        NdisMoveMemory(Out->SendCapabilities.Challenge,
                       BundleCB->SendCompInfo.Challenge,
                       sizeof(Out->SendCapabilities.Challenge));
    
        NdisMoveMemory(Out->SendCapabilities.NTResponse,
                       BundleCB->SendCompInfo.NTResponse,
                       sizeof(Out->SendCapabilities.NTResponse));
#ifdef EAP_ON
        NdisMoveMemory(Out->SendCapabilities.EapKey,
                       BundleCB->SendCompInfo.EapKey,
                       sizeof(Out->SendCapabilities.EapKey));

        Out->SendCapabilities.EapKeyLength =
            BundleCB->SendCompInfo.EapKeyLength;
#endif

        NdisMoveMemory(Out->RecvCapabilities.LMSessionKey,
                       BundleCB->RecvCompInfo.LMSessionKey,
                       sizeof(Out->RecvCapabilities.LMSessionKey));
    
        NdisMoveMemory(Out->RecvCapabilities.UserSessionKey,
                       BundleCB->RecvCompInfo.UserSessionKey,
                       sizeof(Out->RecvCapabilities.UserSessionKey));
    
        NdisMoveMemory(Out->RecvCapabilities.Challenge,
                       BundleCB->RecvCompInfo.Challenge,
                       sizeof(Out->RecvCapabilities.Challenge));
    
        NdisMoveMemory(Out->RecvCapabilities.NTResponse,
                       BundleCB->RecvCompInfo.NTResponse,
                       sizeof(Out->RecvCapabilities.NTResponse));
#ifdef EAP_ON
        NdisMoveMemory(Out->RecvCapabilities.EapKey,
                       BundleCB->RecvCompInfo.EapKey,
                       sizeof(Out->RecvCapabilities.EapKey));

        Out->RecvCapabilities.EapKeyLength =
            BundleCB->RecvCompInfo.EapKeyLength;
#endif
        //
        // We will set encryption capabilities based on session key
        // availability and auth type being used.
        //

        // Set send side capabilities
        //
        Out->SendCapabilities.MSCompType = NDISWAN_COMPRESSION;
    
        if (BundleCB->SendCompInfo.AuthType == AUTH_USE_MSCHAPV1) {

            for (i = 0; i < sizeof(Out->SendCapabilities.LMSessionKey); i++) {
                if (Out->SendCapabilities.LMSessionKey[i] != 0) {

                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_ENCRYPTION | 
                         NDISWAN_40_ENCRYPTION | 
                         NDISWAN_56_ENCRYPTION);
                    break;
                }
            }

#ifdef ENCRYPT_128BIT
            for (i = 0; i < sizeof(Out->SendCapabilities.UserSessionKey); i++) {
                if (Out->SendCapabilities.UserSessionKey[i] != 0) {

                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
                    break;
                }
            }
#endif
        } else if (BundleCB->SendCompInfo.AuthType == AUTH_USE_MSCHAPV2) {

            for (i = 0; i < sizeof(Out->SendCapabilities.UserSessionKey); i++) {
                if (Out->SendCapabilities.UserSessionKey[i] != 0) {

                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_40_ENCRYPTION |
                         NDISWAN_56_ENCRYPTION);

#ifdef ENCRYPT_128BIT
                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
#endif
                    break;
                }

            }
#ifdef EAP_ON
        } else if (BundleCB->SendCompInfo.AuthType == AUTH_USE_EAP) {

            for (i = 0; i < sizeof(Out->SendCapabilities.EapKey); i++) {

                if (Out->SendCapabilities.EapKey[i] != 0) {

                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_40_ENCRYPTION |
                         NDISWAN_56_ENCRYPTION);

#ifdef ENCRYPT_128BIT
                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
#endif
                    break;
                }
            }
#endif
        }
    
        // Set send side capabilities
        //
        Out->RecvCapabilities.MSCompType = NDISWAN_COMPRESSION;

        if (BundleCB->RecvCompInfo.AuthType == AUTH_USE_MSCHAPV1) {

            for (i = 0; i < sizeof(Out->RecvCapabilities.LMSessionKey); i++) {
                if (Out->RecvCapabilities.LMSessionKey[i] != 0) {
                    Out->RecvCapabilities.MSCompType |= 
                        (NDISWAN_ENCRYPTION | 
                         NDISWAN_40_ENCRYPTION |
                         NDISWAN_56_ENCRYPTION);
                    break;
                }
            }


#ifdef ENCRYPT_128BIT
            for (i = 0; i < sizeof(Out->RecvCapabilities.UserSessionKey); i++) {
                if (Out->RecvCapabilities.UserSessionKey[i] != 0) {
    
                    Out->RecvCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
                    break;
                }
            }
#endif

        } else if (BundleCB->RecvCompInfo.AuthType == AUTH_USE_MSCHAPV2) {

            for (i = 0; i < sizeof(Out->RecvCapabilities.UserSessionKey); i++) {
                if (Out->RecvCapabilities.UserSessionKey[i] != 0) {

                    Out->RecvCapabilities.MSCompType |=
                        (NDISWAN_40_ENCRYPTION |
                         NDISWAN_56_ENCRYPTION);

#ifdef ENCRYPT_128BIT
                    Out->RecvCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
#endif
                    break;
                }
            }
#ifdef EAP_ON
        } else if (BundleCB->RecvCompInfo.AuthType == AUTH_USE_EAP) {

            for (i = 0; i < sizeof(Out->RecvCapabilities.EapKey); i++) {
                if (Out->RecvCapabilities.EapKey[i] != 0) {

                    Out->RecvCapabilities.MSCompType |=
                        (NDISWAN_40_ENCRYPTION |
                         NDISWAN_56_ENCRYPTION);

#ifdef ENCRYPT_128BIT
                    Out->RecvCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
#endif
                    break;
                }
            }
#endif
        }

    
        if (gbHistoryless &&
            (OpenCB->MediumSubType == NdisWanMediumPPTP ||
            OpenCB->MediumSubType == NdisWanMediumL2TP)) {

            Out->SendCapabilities.MSCompType |= NDISWAN_HISTORY_LESS;
            Out->RecvCapabilities.MSCompType |= NDISWAN_HISTORY_LESS;
        }
    
    
#ifdef DEBUG_CCP
{
    PCOMPRESS_INFO  CompInfo;
    PUCHAR          Key;

    CompInfo = &Out->SendCapabilities;
    DbgPrint("NdisWan: Get Send CompressInfo\n");

    DbgPrint("MSCompType:      %x\n", CompInfo->MSCompType);
    DbgPrint("AuthType:        %x\n", CompInfo->AuthType);
    DbgPrint("Flags:           %x\n", CompInfo->Flags);

    Key = CompInfo->LMSessionKey;
    DbgPrint("LMSession Key:   %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->UserSessionKey;
    DbgPrint("UserSession Key: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    Key = CompInfo->Challenge;
    DbgPrint("Challenge:       %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->NTResponse;
    DbgPrint("NTResponse:      %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);
    DbgPrint("                 %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[16],Key[17],Key[18],Key[19],
        Key[20],Key[21],Key[22],Key[23]);
}
#endif

#ifdef DEBUG_CCP
{
    PCOMPRESS_INFO  CompInfo;
    PUCHAR          Key;

    CompInfo = &Out->RecvCapabilities;
    DbgPrint("NdisWan: Get Receive CompressInfo\n");

    DbgPrint("MSCompType:      %x\n", CompInfo->MSCompType);
    DbgPrint("AuthType:        %x\n", CompInfo->AuthType);
    DbgPrint("Flags:           %x\n", CompInfo->Flags);

    Key = CompInfo->LMSessionKey;
    DbgPrint("LMSession Key:   %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->UserSessionKey;
    DbgPrint("UserSession Key: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    Key = CompInfo->Challenge;
    DbgPrint("Challenge:       %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->NTResponse;
    DbgPrint("NTResponse:      %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);
    DbgPrint("                 %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[16],Key[17],Key[18],Key[19],
        Key[20],Key[21],Key[22],Key[23]);
}
#endif

    } while ( 0 );
        
    //
    // Derefs for the refs applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
SetVJInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    PLINKCB     LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;
    ULONG       SizeNeeded = sizeof(NDISWAN_SET_VJ_INFO);
    PNDISWAN_SET_VJ_INFO    In = (PNDISWAN_SET_VJ_INFO)pInputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetVJInfo:"));

    *pulBytesWritten = 0;

    do {

        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetVJInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {

            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        AcquireBundleLock(BundleCB);
    
        NdisMoveMemory(&BundleCB->RecvVJInfo,
                       &In->RecvCapabilities,
                       sizeof(VJ_INFO));
    
        if (In->RecvCapabilities.IPCompressionProtocol == 0x2D) {
    
            if (In->RecvCapabilities.MaxSlotID < MAX_VJ_STATES) {
    
                Status = sl_compress_init(&BundleCB->VJCompress,
                         (UCHAR)(In->RecvCapabilities.MaxSlotID + 1));
                
                if (Status != NDIS_STATUS_SUCCESS) {
                    NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("Error allocating VJ Info!"));
                }
            }
        }
    
        NdisMoveMemory(&BundleCB->SendVJInfo,
                       &In->SendCapabilities,
                       sizeof(VJ_INFO));
    
        if (In->SendCapabilities.IPCompressionProtocol == 0x2D) {
    
            if (In->SendCapabilities.MaxSlotID < MAX_VJ_STATES) {
    
                Status = sl_compress_init(&BundleCB->VJCompress,
                         (UCHAR)(In->SendCapabilities.MaxSlotID + 1));
                
                if (Status != NDIS_STATUS_SUCCESS) {
                    NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("Error allocating VJ Info!"));
                }
            }
            
        }

        SetBundleFlags(BundleCB);
    
    } while ( 0 );

    //
    // Derefs for the refs applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
GetVJInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       SizeNeeded = sizeof(NDISWAN_GET_VJ_INFO);
    PLINKCB     LinkCB = NULL;
    POPENCB     OpenCB = NULL;
    NTSTATUS    Status = STATUS_SUCCESS;
    PNDISWAN_GET_VJ_INFO    In = (PNDISWAN_GET_VJ_INFO)pInputBuffer;
    PNDISWAN_GET_VJ_INFO    Out = (PNDISWAN_GET_VJ_INFO)pOutputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetVJInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetVJInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!IsLinkValid(In->hLinkHandle, 
                         TRUE,
                         &LinkCB)) {

            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        OpenCB = LinkCB->OpenCB;
    
        if (OpenCB->MediumSubType == NdisWanMediumPPTP ||
            OpenCB->MediumSubType == NdisWanMediumL2TP) {
            Out->SendCapabilities.IPCompressionProtocol =
            Out->RecvCapabilities.IPCompressionProtocol = 0;
        } else {
            Out->SendCapabilities.IPCompressionProtocol =
            Out->RecvCapabilities.IPCompressionProtocol = 0x2D;
        }
    
        Out->SendCapabilities.MaxSlotID =
        Out->RecvCapabilities.MaxSlotID = MAX_VJ_STATES - 1;
    
        Out->SendCapabilities.CompSlotID =
        Out->RecvCapabilities.CompSlotID = 1;

    } while ( 0 );

    //
    // Deref for ref applied by IsLinkValid
    //
    DEREF_LINKCB(LinkCB);

    return (Status);
}

NTSTATUS
GetBandwidthUtilization(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       SizeNeeded = sizeof(NDISWAN_GET_BANDWIDTH_UTILIZATION);
    PBUNDLECB   BundleCB = NULL;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    PNDISWAN_GET_BANDWIDTH_UTILIZATION In =
        (PNDISWAN_GET_BANDWIDTH_UTILIZATION)pInputBuffer;

    PNDISWAN_GET_BANDWIDTH_UTILIZATION Out =
        (PNDISWAN_GET_BANDWIDTH_UTILIZATION)pOutputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetBandwidthUtilization: Enter"));

    *pulBytesWritten = 0;
    if (ulInputBufferLength < sizeof(In->hBundleHandle) ||
        ulOutputBufferLength < SizeNeeded) {

        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetBandwidthUtilization: Buffer to small: Size: %d, SizeNeeded %d",
                      ulOutputBufferLength, SizeNeeded));

        *pulBytesWritten = SizeNeeded;
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    if (!IsBundleValid(In->hBundleHandle, 
                       FALSE,
                       &BundleCB)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetBandwidthUtilization: Invalid BundleHandle: 0x%x",
                      In->hBundleHandle));
        return NDISWAN_ERROR_INVALID_HANDLE;
    }
    
    do {
        ULONGLONG   MaxByteCount, temp;

        AcquireBundleLock(BundleCB);

        if(BundleCB->SUpperBonDInfo == NULL ||
          BundleCB->RUpperBonDInfo == NULL)
        {
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
            
        MaxByteCount = BundleCB->SUpperBonDInfo->ulBytesInSamplePeriod;
        temp = 0;
        if (MaxByteCount != 0) {
            temp = BundleCB->SUpperBonDInfo->SampleTable.ulCurrentSampleByteCount;
            temp *= 100;
            temp /= MaxByteCount;
        }
        Out->ulUpperXmitUtil = (ULONG)temp;

        MaxByteCount = BundleCB->SLowerBonDInfo->ulBytesInSamplePeriod;
        temp = 0;
        if (MaxByteCount != 0) {
            temp = BundleCB->SLowerBonDInfo->SampleTable.ulCurrentSampleByteCount;
            temp *= 100;
            temp /= MaxByteCount;
        }
        Out->ulLowerXmitUtil = (ULONG)temp;

        MaxByteCount = BundleCB->RUpperBonDInfo->ulBytesInSamplePeriod;
        temp = 0;
        if (MaxByteCount != 0) {
            temp = BundleCB->RUpperBonDInfo->SampleTable.ulCurrentSampleByteCount;
            temp *= 100;
            temp /= MaxByteCount;
        }
        Out->ulUpperRecvUtil = (ULONG)temp;

        MaxByteCount = BundleCB->RLowerBonDInfo->ulBytesInSamplePeriod;
        temp = 0;
        if (MaxByteCount != 0) {
            temp = BundleCB->RLowerBonDInfo->SampleTable.ulCurrentSampleByteCount;
            temp *= 100;
            temp /= MaxByteCount;
        }
        Out->ulLowerRecvUtil = (ULONG)temp;

        *pulBytesWritten = SizeNeeded;

    } while (FALSE);

    //
    // Deref for ref applied by IsBundleValid.  This releases
    // the BundleCB->Lock.
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}

NTSTATUS
EnumProtocolUtilization(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_ENUM_PROTOCOL_UTILIZATION);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("EnumProtocolUtilization:"));

    *pulBytesWritten = SizeNeeded;

    if (ulOutputBufferLength < SizeNeeded) {
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("EnumProtocolUtilization: Buffer to small: Size: %d, SizeNeeded %d",
                      ulOutputBufferLength, SizeNeeded));
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    return (STATUS_NOT_IMPLEMENTED);
}

NTSTATUS
EnumActiveBundles(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_ENUM_ACTIVE_BUNDLES);
    PNDISWAN_ENUM_ACTIVE_BUNDLES    Out = (PNDISWAN_ENUM_ACTIVE_BUNDLES)pOutputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetNumActiveBundles:"));

    *pulBytesWritten = SizeNeeded;

    if (ulOutputBufferLength < SizeNeeded) {
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetNumActiveBundles: Buffer to small: Size: %d, SizeNeeded %d",
                      ulOutputBufferLength, SizeNeeded));

        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    //
    // Does this information need to be protected by the lock?
    // I would hate to have things get slowed for this call!
    //
    Out->ulNumberOfActiveBundles = ConnectionTable->ulNumActiveBundles;

    return (STATUS_SUCCESS);
}

NTSTATUS
GetWanInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_WAN_INFO);
    PNDISWAN_GET_WAN_INFO In = (PNDISWAN_GET_WAN_INFO)pInputBuffer;
    PNDISWAN_GET_WAN_INFO Out = (PNDISWAN_GET_WAN_INFO)pOutputBuffer;
    POPENCB OpenCB;
    PLINKCB LinkCB = NULL;
    NTSTATUS    Status = STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetWanInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetWanInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        if (!IsLinkValid(In->hLinkHandle, 
                         FALSE,
                         &LinkCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetWanInfo: Invalid LinkHandle: 0x%x",
                          In->hLinkHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
    
        OpenCB = LinkCB->OpenCB;
    
        Out->WanInfo.MaxFrameSize = OpenCB->WanInfo.MaxFrameSize;
        Out->WanInfo.MaxTransmit = OpenCB->WanInfo.MaxTransmit;
        Out->WanInfo.FramingBits = OpenCB->WanInfo.FramingBits;
        Out->WanInfo.DesiredACCM = OpenCB->WanInfo.DesiredACCM;
        Out->WanInfo.MaxReconstructedFrameSize = glMRRU;
        Out->WanInfo.LinkSpeed = LinkCB->SFlowSpec.PeakBandwidth*8;

    } while ( 0 );

    //
    // Deref for ref applied by IsLinkValid
    //
    DEREF_LINKCB(LinkCB);

    return (Status);
}

NTSTATUS
SetDebugInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PNDISWAN_SET_DEBUG_INFO pDebugInfo = (PNDISWAN_SET_DEBUG_INFO)pInputBuffer;
    ULONG   SizeNeeded = sizeof(NDISWAN_SET_DEBUG_INFO);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetDebugInfo: OldLevel: 0x%x OldMask: 0x%x",
                                     glDebugLevel, glDebugMask));

    *pulBytesWritten = 0;

    if (ulInputBufferLength < SizeNeeded) {
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("Buffer to small: Size: %d, SizeNeeded %d",
                      ulInputBufferLength, SizeNeeded));
        *pulBytesWritten = SizeNeeded;
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    glDebugLevel = pDebugInfo->ulDebugLevel;
    glDebugMask = pDebugInfo->ulDebugMask;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetDebugInfo: NewLevel: 0x%x NewMask: 0x%x",
                                     glDebugLevel, glDebugMask));

    return (STATUS_SUCCESS);
}

NTSTATUS
SetEncryptionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_SET_ENCRYPTION_INFO);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetEncryptionInfo:"));

    *pulBytesWritten = 0;

    if (ulInputBufferLength < SizeNeeded) {
        
        *pulBytesWritten = SizeNeeded;
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    return (STATUS_NOT_IMPLEMENTED);
}


NTSTATUS
GetEncryptionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_ENCRYPTION_INFO);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetEncryptionInfo:"));

    *pulBytesWritten = SizeNeeded;

    if (ulOutputBufferLength < SizeNeeded) {
        
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    return (STATUS_NOT_IMPLEMENTED);
}

NTSTATUS
GetIdleTime(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
)
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       SizeNeeded = sizeof(NDISWAN_GET_IDLE_TIME);
    PNDISWAN_GET_IDLE_TIME  In  = (PNDISWAN_GET_IDLE_TIME)pInputBuffer;
    PNDISWAN_GET_IDLE_TIME  Out = (PNDISWAN_GET_IDLE_TIME)pOutputBuffer;
    PBUNDLECB   BundleCB = NULL;
    PPROTOCOLCB ProtocolCB = NULL;
    WAN_TIME    CurrentTime, Diff, OneSecond;
    WAN_TIME    LastNonIdleData;
    NTSTATUS    Status = STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetIdleTime:"));

    *pulBytesWritten = SizeNeeded;

    do {
        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetIdleTime: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!IsBundleValid(In->hBundleHandle, 
                           FALSE,
                           &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetIdleTime: Invalid BundleHandle: 0x%x",
                          In->hBundleHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
    
        AcquireBundleLock(BundleCB);

        if (BundleCB->Flags & DISABLE_IDLE_DETECT) {
            
            Out->ulSeconds = 0;
            break;
        }
    
        //
        // If this is for the bundle
        //
        if (In->usProtocolType == BUNDLE_IDLE_TIME) {
            LastNonIdleData = BundleCB->LastNonIdleData;
        } else {
    
            //
            // Find the protocol type
            //
            for (ProtocolCB = (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;
                (PVOID)ProtocolCB != (PVOID)&BundleCB->ProtocolCBList;
                ProtocolCB = (PPROTOCOLCB)ProtocolCB->Linkage.Flink) {
    
                if (ProtocolCB->ProtocolType == In->usProtocolType) {
                    break;
                }
            }
    
            if ((PVOID)ProtocolCB == (PVOID)&BundleCB->ProtocolCBList) {
                NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetIdleTime: Invalid ProtocolType: 0x%x",
                              In->usProtocolType));
                Status = NDISWAN_ERROR_NO_ROUTE;
                break;
            }
    
            LastNonIdleData = ProtocolCB->LastNonIdleData;
        }
    
        NdisWanGetSystemTime(&CurrentTime);
        NdisWanCalcTimeDiff(&Diff, &CurrentTime, &LastNonIdleData);
        NdisWanInitWanTime(&OneSecond, ONE_SECOND);
        NdisWanDivideWanTime(&CurrentTime, &Diff, &OneSecond);
    
        Out->ulSeconds = CurrentTime.LowPart;
    
    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid.  This releases the
    // BundleCB->Lock.
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}

NTSTATUS
DeactivateRoute(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    DeactivateRoute

Routine Description:

    This function unroutes the protocol given by usprotocoltype
    from the bundle given by hbundlehandle.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_UNROUTE

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_UNROUTE)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_UNROUTE

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_UNROUTE)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_ALREADY_ROUTED
    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INSUFFICIENT_RESOURCES
    STATUS_INFO_LENGTH_MISMATCH

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNDISWAN_UNROUTE In = (PNDISWAN_UNROUTE)pInputBuffer;
    PNDISWAN_UNROUTE    Out = (PNDISWAN_UNROUTE)pOutputBuffer;
    ULONG   SizeNeeded = sizeof(NDISWAN_UNROUTE);
    ULONG   AllocationSize, i;
    PBUNDLECB   BundleCB = NULL;
    BOOLEAN RouteExists = FALSE;
    BOOLEAN FreeBundle = FALSE;
    PPROTOCOLCB ProtocolCB;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("DeactivateRoute:"));

    *pulBytesWritten = 0;

    do {

        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("DeactivateRoute: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        if (!IsBundleValid(In->hBundleHandle, FALSE, &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("DeactivateRoute: Invalid BundleHandle: 0x%x, ProtocolType: 0x%x",
                          In->hBundleHandle, In->usProtocolType));
    
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
    
        //
        // This is a call to unroute
        //
        AcquireBundleLock(BundleCB);

        //
        // Find the protocolcb for this route
        //
        //
        for (ProtocolCB = (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;
            (PVOID)ProtocolCB != (PVOID)&BundleCB->ProtocolCBList;
            ProtocolCB = (PPROTOCOLCB)ProtocolCB->Linkage.Flink) {
    
            //
            // If we already have a route to this protocol type
            // flag it as already existing
            //
            if (ProtocolCB->ProtocolType == In->usProtocolType) {
                RouteExists = TRUE;
                break;
            }
            
        }

        if (!RouteExists) {
            //
            // A route already exists for this protocoltype
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("DeactivateRoute: Route does not exist: ProtocolType: 0x%2.2x",
                          In->usProtocolType));
            
            Status = NDISWAN_ERROR_NOT_ROUTED;
            break;
        }
    
    
        //
        // If the protocol is already unrouting because
        // of a halt on the protocols miniportcb we
        // will just get the out!
        //
        if (ProtocolCB->State == PROTOCOL_UNROUTING) {
            break;
        }

        ProtocolCB->State = PROTOCOL_UNROUTING;
        BundleCB->SendMask &= ~ProtocolCB->SendMaskBit;

        //
        // Flush the protocol packet queues.  This could cause us
        // to complete frames to ndis out of order.  Ndis should
        // handle this.
        //
        FlushProtocolPacketQueue(ProtocolCB);

        //
        // If we have any outstanding Vc's we need to dispatch
        // incoming close calls to them
        //
        while (!IsListEmpty(&ProtocolCB->VcList)) {
            PLIST_ENTRY Entry;
            PCM_VCCB    CmVcCB;

            Entry = RemoveHeadList(&ProtocolCB->VcList);

            CmVcCB = (PCM_VCCB)CONTAINING_RECORD(Entry, CM_VCCB, Linkage);

            if (CmVcCB->State == CMVC_ACTIVE) {

                InterlockedExchange((PLONG)&CmVcCB->State, CMVC_CLOSE_DISPATCHED);

                ReleaseBundleLock(BundleCB);

                NdisCmDispatchIncomingCloseCall(NDIS_STATUS_SUCCESS,
                                                CmVcCB->NdisVcHandle,
                                                NULL,
                                                0);

                AcquireBundleLock(BundleCB);
            }
        }

        DEREF_PROTOCOLCB(ProtocolCB);

        ReleaseBundleLock(BundleCB);

        NdisWanWaitForSyncEvent(&ProtocolCB->UnrouteEvent);

        AcquireBundleLock(BundleCB);

        DoLineDownToProtocol(ProtocolCB);

        NdisWanFreeProtocolCB(ProtocolCB);

    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}

NTSTATUS
GetDriverInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_DRIVER_INFO);
    PNDISWAN_DRIVER_INFO Out = (PNDISWAN_DRIVER_INFO)pOutputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetDriverInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
            
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        NdisZeroMemory(Out, ulOutputBufferLength);

#ifdef ENCRYPT_128BIT
        Out->DriverCaps = NDISWAN_128BIT_ENABLED;
#else
        Out->DriverCaps = 0;
#endif

    } while ( 0 );

    return (Status);

}

NTSTATUS
SetProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PIRP        Irp = (PIRP)pInputBuffer;
    NTSTATUS    Status = STATUS_PENDING;
    KIRQL       Irql;

    NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

    do {

        if ((ProtocolInfoTable->Flags & PROTOCOL_EVENT_OCCURRED) &&
            !(ProtocolInfoTable->Flags & PROTOCOL_EVENT_SIGNALLED)) {
            //
            // An event occurred but we did not signal so
            // signal now!
            //
            ProtocolInfoTable->Flags |= PROTOCOL_EVENT_SIGNALLED;
            *pulBytesWritten = 0;
            Status = STATUS_SUCCESS;
            break;

        }

        if (ProtocolInfoTable->EventIrp != NULL) {
            *pulBytesWritten = 0;
            Status = STATUS_SUCCESS;
            break;

        }

        ProtocolInfoTable->EventIrp = Irp;

        IoMarkIrpPending(Irp);

        IoSetCancelRoutine(Irp, NdisWanCancelRoutine);

        Status = STATUS_PENDING;

    } while (FALSE);

    NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

    return (Status);
}

NTSTATUS
GetProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PNDISWAN_GET_PROTOCOL_EVENT Out =
        (PNDISWAN_GET_PROTOCOL_EVENT)pOutputBuffer;
    PPROTOCOL_INFO  InfoArray;
    ULONG       ArraySize;
    ULONG       SizeNeeded = sizeof(NDISWAN_GET_PROTOCOL_EVENT);
    NTSTATUS    Status = STATUS_SUCCESS;
    UINT        i, j;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetProtocolEvent:"));

    *pulBytesWritten = 0;

    NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

    ArraySize = ProtocolInfoTable->ulArraySize;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetProtocolEvent: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        *pulBytesWritten = sizeof(NDISWAN_GET_PROTOCOL_EVENT);

        NdisZeroMemory(Out, sizeof(NDISWAN_GET_PROTOCOL_EVENT));

        j = 0;

        for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
            i < ArraySize;
            i++, InfoArray++) {

            if (InfoArray->Flags & PROTOCOL_EVENT_OCCURRED) {

                PPROTOCOL_EVENT oevent = &Out->ProtocolEvent[j];

                oevent->usProtocolType = InfoArray->ProtocolType;

                if (InfoArray->Flags & PROTOCOL_REBOUND) {
                    //
                    // This means we were unbound and then
                    // bound again without our miniport being
                    // halted.  We need to tell ras about two events,
                    // the unbind and the bind.
                    //
                    InfoArray->Flags &= ~(PROTOCOL_REBOUND |
                                          PROTOCOL_EVENT_OCCURRED);

                    oevent->ulFlags = PROTOCOL_REMOVED;

                    Out->ulNumProtocols++;

                    j++;

                    if (j < MAX_PROTOCOLS) {

                        oevent = &Out->ProtocolEvent[j];

                        oevent->usProtocolType = InfoArray->ProtocolType;

                        oevent->ulFlags = PROTOCOL_ADDED;

                        Out->ulNumProtocols++;

                        j++;
                    }


                } else {

                    oevent->ulFlags = (InfoArray->Flags & PROTOCOL_BOUND) ?
                        PROTOCOL_ADDED : PROTOCOL_REMOVED;

                    InfoArray->Flags &= ~PROTOCOL_EVENT_OCCURRED;

                    Out->ulNumProtocols++;

                    j++;
                }

                if (j == MAX_PROTOCOLS) {
                    break;
                }
            }
        }

        ProtocolInfoTable->Flags &=
            ~(PROTOCOL_EVENT_OCCURRED | PROTOCOL_EVENT_SIGNALLED);

    } while (FALSE);

    NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

    return (Status);
}

NTSTATUS
FlushProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PIRP    Irp;
    KIRQL   Irql;

    *pulBytesWritten = 0;

    NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

    Irp = ProtocolInfoTable->EventIrp;

    if ((Irp != NULL) &&
        IoSetCancelRoutine(Irp, NULL)) {

        ProtocolInfoTable->EventIrp = NULL;

        Irp->Cancel = TRUE;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        NdisAcquireSpinLock(&ProtocolInfoTable->Lock);
    }

    NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

    return (STATUS_SUCCESS);
}


NTSTATUS
IoGetProtocolInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       SizeNeeded = sizeof(NDISWAN_GET_PROTOCOL_INFO);
    PNDISWAN_GET_PROTOCOL_INFO Out =
        (PNDISWAN_GET_PROTOCOL_INFO)pOutputBuffer;

    do {
        ULONG   i = 0;
        ULONG   j = 0;
        PMINIPORTCB MiniportCB;
        ULONG       ArraySize;
        PPROTOCOL_INFO  InfoArray;

        *pulBytesWritten = SizeNeeded;

        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("IoGetProtocolInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

        ArraySize = ProtocolInfoTable->ulArraySize;

        for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
            i < ArraySize;
            i++, InfoArray++) {

            if (InfoArray->Flags & PROTOCOL_BOUND) {
                Out->ProtocolInfo[j].ProtocolType = InfoArray->ProtocolType;
                Out->ProtocolInfo[j].PPPId = InfoArray->PPPId;
                Out->ProtocolInfo[j].MTU = InfoArray->MTU;
                Out->ProtocolInfo[j].TunnelMTU = InfoArray->TunnelMTU;
                Out->ProtocolInfo[j].PacketQueueDepth = InfoArray->PacketQueueDepth;

                j++;
            }
        }

        NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

        Out->ulNumProtocols = j;

    } while (FALSE);

    return (Status);
}

NTSTATUS
SetHibernateEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PIRP        Irp = (PIRP)pInputBuffer;
    NTSTATUS    Status = STATUS_PENDING;
    KIRQL       Irql;

    NdisAcquireSpinLock(&NdisWanCB.Lock);

    do {

        if (NdisWanCB.HibernateEventIrp != NULL) {
            *pulBytesWritten = 0;
            Status = STATUS_SUCCESS;
            break;

        }

        NdisWanCB.HibernateEventIrp = Irp;

        IoMarkIrpPending(Irp);

        IoSetCancelRoutine(Irp, NdisWanCancelRoutine);

        Status = STATUS_PENDING;

    } while (FALSE);

    NdisReleaseSpinLock(&NdisWanCB.Lock);

    return (Status);
}

NTSTATUS
FlushHibernateEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PIRP    Irp;
    KIRQL   Irql;

    *pulBytesWritten = 0;

    NdisAcquireSpinLock(&NdisWanCB.Lock);

    Irp = NdisWanCB.HibernateEventIrp;

    if ((Irp != NULL) &&
        IoSetCancelRoutine(Irp, NULL)) {

        NdisWanCB.HibernateEventIrp = NULL;

        Irp->Cancel = TRUE;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        NdisReleaseSpinLock(&NdisWanCB.Lock);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        NdisAcquireSpinLock(&NdisWanCB.Lock);
    }

    NdisReleaseSpinLock(&NdisWanCB.Lock);

    return (STATUS_SUCCESS);
}

NTSTATUS
GetBundleInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_BUNDLE_INFO);
    PNDISWAN_GET_BUNDLE_INFO In = (PNDISWAN_GET_BUNDLE_INFO)pInputBuffer;
    PNDISWAN_GET_BUNDLE_INFO Out = (PNDISWAN_GET_BUNDLE_INFO)pOutputBuffer;
    POPENCB OpenCB;
    PBUNDLECB   BundleCB = NULL;
    NTSTATUS    Status = STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetWanInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulInputBufferLength < SizeNeeded ||
            ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetBundleInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        if (!IsBundleValid(In->hBundleHandle, 
                           FALSE,
                           &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetBundleInfo: Invalid Bundle Handle: 0x%x",
                          In->hBundleHandle));
            *pulBytesWritten = 0;
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
    
        AcquireBundleLock(BundleCB);

        Out->BundleInfo.SendFramingBits =
            BundleCB->FramingInfo.SendFramingBits;
        Out->BundleInfo.SendBundleSpeed =
            BundleCB->SFlowSpec.PeakBandwidth*8;
        Out->BundleInfo.SendMSCompType =
            BundleCB->SendCompInfo.MSCompType;
        Out->BundleInfo.SendAuthType =
            BundleCB->SendCompInfo.AuthType;


        Out->BundleInfo.RecvFramingBits =
            BundleCB->FramingInfo.RecvFramingBits;
        Out->BundleInfo.RecvBundleSpeed =
            BundleCB->RFlowSpec.PeakBandwidth*8;
        Out->BundleInfo.RecvMSCompType =
            BundleCB->RecvCompInfo.MSCompType;
        Out->BundleInfo.RecvAuthType =
            BundleCB->RecvCompInfo.AuthType;

    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid.  This releases
    // the BundleCB->Lock
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}

NTSTATUS
UnmapConnectionId(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       SizeNeeded = sizeof(NDISWAN_UNMAP_CONNECTION_ID);
    NTSTATUS    Status = STATUS_SUCCESS;
    LOCK_STATE  LockState;
    PNDISWAN_UNMAP_CONNECTION_ID In = 
        (PNDISWAN_UNMAP_CONNECTION_ID)pInputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("UnmapConnectionId:"));

    *pulBytesWritten = 0;

    do {
        PLINKCB     LinkCB = NULL;

        if (ulInputBufferLength < SizeNeeded) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("UnmapConnectionId: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));

            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        //
        // Validate the link handle
        //
        if (IsLinkValid(In->hLinkHandle, FALSE, &LinkCB)) {

            NdisAcquireSpinLock(&LinkCB->Lock);


            //
            // Remove the ref applied to the link at mapconnectionid time.
            // We don't have to use the full deref code as the ref applied
            // in IsLinkValid will keep the link around.
            //
            LinkCB->RefCount--;

            //
            // Remove the ref applied by IsLinkValid
            //
            DEREF_LINKCB_LOCKED(LinkCB);
        } else {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, 
                          ("UnmapConnectionId: Invalid LinkHandle %x",
                          In->hLinkHandle));

            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

    } while (FALSE);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("UnmapConnectionId:"));

    return (Status);
}
VOID
CancelThresholdEvents(
    VOID
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
#ifdef NT
    KIRQL   Irql;
    PIRP    pIrp;
    PLIST_ENTRY Entry;


    NdisAcquireSpinLock(&ThresholdEventQueue.Lock);

    while (!IsListEmpty(&ThresholdEventQueue.List)) {

        Entry = RemoveHeadList(&ThresholdEventQueue.List);
        ThresholdEventQueue.ulCount--;

        pIrp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

        if (!IoSetCancelRoutine(pIrp, NULL)) {
            //
            // Irp is being canceled so let
            // cancel routine handle it.
            //
            continue;
        }

        NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

        pIrp->Cancel = TRUE;
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        NdisAcquireSpinLock(&ThresholdEventQueue.Lock);
    }

    NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

#endif // End #ifdef NT
}

VOID
CancelIoReceivePackets(
    VOID
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
#ifdef NT
    PIRP    pIrp;
    PLIST_ENTRY Entry;

    NdisAcquireSpinLock(&IoRecvList.Lock);

    while (!IsListEmpty(&IoRecvList.IrpList)) {

        Entry = RemoveHeadList(&IoRecvList.IrpList);
        IoRecvList.ulIrpCount--;
        
        INSERT_RECV_EVENT('c');

        pIrp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

        if (!IoSetCancelRoutine(pIrp, NULL)) {
            //
            // Irp is being canceled so let 
            // cancel routine complete it
            //
            continue;
        }

        pIrp->Cancel = TRUE;
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = sizeof(NDISWAN_IO_PACKET);

        ((PNDISWAN_IO_PACKET)(pIrp->AssociatedIrp.SystemBuffer))->usHandleType = CANCELEDHANDLE;

        IoRecvList.LastIrp = pIrp;
        IoRecvList.LastIrpStatus = STATUS_CANCELLED;
        IoRecvList.LastCopySize = (ULONG)pIrp->IoStatus.Information;

        IoRecvList.LastPacketNumber =
            ((PNDISWAN_IO_PACKET)(pIrp->AssociatedIrp.SystemBuffer))->PacketNumber;


        NdisReleaseSpinLock(&IoRecvList.Lock);

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        NdisAcquireSpinLock(&IoRecvList.Lock);
    }
    
    NdisReleaseSpinLock(&IoRecvList.Lock);

#endif // End #ifdef NT

}

VOID
AddProtocolCBToBundle(
    PPROTOCOLCB ProtocolCB,
    PBUNDLECB   BundleCB
    )
/*++

Routine Name:

    AddProtocolCBToBundle

Routine Description:

    This routine adds the protocolcb to the bundlecb protocollist and
    protocoltable.  It also assigns the protocolcb's handle (index into
    the table) and set's the initial priority of all of the protocols
    on the list.

Arguments:

    ProtocolCB - Pointer to the protocol control block
    BundleCB - Pointer to the bundle control block

Return Values:

    None

--*/
{
    ULONG   i, InitialByteQuota;
    ULONG   InitialPriority;

    AcquireBundleLock(BundleCB);

    //
    // Add to list
    //
    InsertTailList(&BundleCB->ProtocolCBList, &ProtocolCB->Linkage);

    //
    // Insert in table
    //
    ASSERT(BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] ==
           (PPROTOCOLCB)RESERVED_PROTOCOLCB);

    BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] =
        ProtocolCB;

    BundleCB->ulNumberOfRoutes++;

    //
    // Setup the send mask for this protocolcb
    //
    ProtocolCB->SendMaskBit = BundleCB->SendMask + 0x00000001;
    BundleCB->SendMask = (BundleCB->SendMask << 1) | 0x00000001;

    ProtocolCB->State = PROTOCOL_ROUTED;

    if (BundleCB->NextProtocol == NULL) {
        BundleCB->NextProtocol = ProtocolCB;
    }

    REF_BUNDLECB(BundleCB);

    ReleaseBundleLock(BundleCB);
}

VOID
RemoveProtocolCBFromBundle(
    PPROTOCOLCB ProtocolCB
    )
{
    PBUNDLECB   BundleCB = ProtocolCB->BundleCB;

    //
    // If this protocolcb was not yet inserted in
    // the table just return.
    //
    if (BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] !=
        ProtocolCB) {
        
        return;
    }

    RemoveEntryList(&ProtocolCB->Linkage);

    BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] = NULL;
    BundleCB->ulNumberOfRoutes--;

    if (BundleCB->NextProtocol == ProtocolCB) {

        BundleCB->NextProtocol =
            (PPROTOCOLCB)ProtocolCB->Linkage.Flink;

        if ((PVOID)BundleCB->NextProtocol ==
            (PVOID)&BundleCB->ProtocolCBList) {

            if (BundleCB->ulNumberOfRoutes != 0) {

                //
                // If we are back to the head of the list
                // but there are still routes get the next.
                //
                BundleCB->NextProtocol =
                    (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;

            } else {

                //
                // No more routes left...
                //
                BundleCB->NextProtocol = NULL;
            }
        }
    }

    //
    // Deref for the ref applied when the protocolcb was
    // added to the bundle.  Don't need to do the entire
    // bundlecb ref code here.
    //
    BundleCB->RefCount--;
}

VOID
SortProtocolListByPriority(
    IN  PBUNDLECB BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{

}

VOID
CompleteThresholdEvent(
    PBUNDLECB   BundleCB,
    ULONG       DataType,
    ULONG       ThresholdType
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
#ifdef NT
    PLIST_ENTRY Entry;
    PIRP    pIrp;
    PNDISWAN_SET_THRESHOLD_EVENT    ThresholdEvent;

    NdisAcquireSpinLock(&ThresholdEventQueue.Lock);

    if (IsListEmpty(&ThresholdEventQueue.List)) {
        NdisReleaseSpinLock(&ThresholdEventQueue.Lock);
        return;
    }

    Entry = RemoveHeadList(&ThresholdEventQueue.List);
    ThresholdEventQueue.ulCount--;

    pIrp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

    if (IoSetCancelRoutine(pIrp, NULL)) {

        pIrp->IoStatus.Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = sizeof(NDISWAN_SET_THRESHOLD_EVENT);

        ThresholdEvent = (PNDISWAN_SET_THRESHOLD_EVENT)pIrp->AssociatedIrp.SystemBuffer;
        ThresholdEvent->hBundleContext = BundleCB->hBundleContext;
        ThresholdEvent->ulThreshold = ThresholdType;
        ThresholdEvent->ulDataType = DataType;

        NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        NdisAcquireSpinLock(&ThresholdEventQueue.Lock);
    }

    NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

#endif // End #ifdef NT
}

VOID
FlushProtocolPacketQueue(
    PPROTOCOLCB ProtocolCB
    )
{
    ULONG       Class;
    PBUNDLECB   BundleCB;

    BundleCB = ProtocolCB->BundleCB;

    for (Class = 0; Class <= MAX_MCML; Class++) {
        PPACKET_QUEUE   PacketQueue;

        PacketQueue = &ProtocolCB->PacketQueue[Class];

        while (!IsPacketQueueEmpty(PacketQueue)) {
            PNDIS_PACKET    NdisPacket;
    
            NdisPacket =
                RemoveHeadPacketQueue(PacketQueue);
    
            ReleaseBundleLock(BundleCB);

            //
            // Complete the NdisPacket
            //
            CompleteNdisPacket(ProtocolCB->MiniportCB,
                               ProtocolCB,
                               NdisPacket);

            AcquireBundleLock(BundleCB);
        }
    }

}

NDIS_HANDLE
AssignProtocolCBHandle(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB
    )
{
    ULONG   i;

    //
    // Find the first unused slot in the table
    //
    for (i = 0; i < MAX_PROTOCOLS; i++) {
        if (BundleCB->ProtocolCBTable[i] == NULL) {
            ProtocolCB->ProtocolHandle = (NDIS_HANDLE)ULongToPtr(i);
            ProtocolCB->BundleCB = BundleCB;
            BundleCB->ProtocolCBTable[i] = (PPROTOCOLCB)RESERVED_PROTOCOLCB;
            break;
        }
    }

    //
    // If there is no room in the inn return
    // i == MAX_PROTOCOLS which flags as an error.
    //

    return((NDIS_HANDLE)ULongToPtr(i));
}

VOID
FreeProtocolCBHandle(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB
    )
{

    ASSERT(BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] ==
          (PPROTOCOLCB)RESERVED_PROTOCOLCB);

    ASSERT((ULONG_PTR)ProtocolCB->ProtocolHandle < MAX_PROTOCOLS);

    BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] = NULL;
}

VOID
SetBundleFlags(
    PBUNDLECB   BundleCB
    )
{
    BundleCB->SendFlags = ((BundleCB->SendCompInfo.MSCompType & NDISWAN_COMPRESSION) &&
                          (BundleCB->SendCompressContext != NULL)) ? DO_COMPRESSION : 0;

    BundleCB->SendFlags |=
        (BundleCB->SendCompInfo.MSCompType & NDISWAN_HISTORY_LESS) ? DO_HISTORY_LESS : 0;

    if (BundleCB->SendCryptoInfo.RC4Key != NULL) {
        if (BundleCB->SendCompInfo.MSCompType & NDISWAN_ENCRYPTION) {
            BundleCB->SendFlags |= (DO_ENCRYPTION | DO_LEGACY_ENCRYPTION);
        } else if (BundleCB->SendCompInfo.MSCompType & NDISWAN_40_ENCRYPTION) {
            BundleCB->SendFlags |= (DO_ENCRYPTION | DO_40_ENCRYPTION);
        } else if (BundleCB->SendCompInfo.MSCompType & NDISWAN_56_ENCRYPTION) {
            BundleCB->SendFlags |= (DO_ENCRYPTION | DO_56_ENCRYPTION);
        }
#ifdef ENCRYPT_128BIT
        else if (BundleCB->SendCompInfo.MSCompType & NDISWAN_128_ENCRYPTION) {
            BundleCB->SendFlags |= (DO_ENCRYPTION | DO_128_ENCRYPTION);
        }
#endif
    }

    BundleCB->SendFlags |=
        (BundleCB->SendVJInfo.IPCompressionProtocol == 0x2D &&
         BundleCB->VJCompress != NULL) ? DO_VJ : 0;

    BundleCB->SendFlags |=
        ((BundleCB->FramingInfo.SendFramingBits & PPP_MULTILINK_FRAMING) &&
         ((BundleCB->ulLinkCBCount > 1) || (BundleCB->Flags & QOS_ENABLED))) ?
        DO_MULTILINK : 0;

    BundleCB->SendFlags |=
        (BundleCB->FramingInfo.SendFramingBits & NBF_PRESERVE_MAC_ADDRESS) ?
        SAVE_MAC_ADDRESS : 0;

    BundleCB->RecvFlags = ((BundleCB->RecvCompInfo.MSCompType & NDISWAN_COMPRESSION) &&
                          (BundleCB->RecvCompressContext != NULL)) ? DO_COMPRESSION : 0;

    BundleCB->RecvFlags |=
        (BundleCB->RecvCompInfo.MSCompType & NDISWAN_HISTORY_LESS) ? DO_HISTORY_LESS : 0;

    if (BundleCB->RecvCryptoInfo.RC4Key != NULL) {
        if (BundleCB->RecvCompInfo.MSCompType & NDISWAN_ENCRYPTION) {
            BundleCB->RecvFlags |= (DO_ENCRYPTION | DO_LEGACY_ENCRYPTION);
        } else if (BundleCB->RecvCompInfo.MSCompType & NDISWAN_40_ENCRYPTION) {
            BundleCB->RecvFlags |= (DO_ENCRYPTION | DO_40_ENCRYPTION);
        } else if (BundleCB->RecvCompInfo.MSCompType & NDISWAN_56_ENCRYPTION) {
            BundleCB->RecvFlags |= (DO_ENCRYPTION | DO_56_ENCRYPTION);
        }
#ifdef ENCRYPT_128BIT
        else if (BundleCB->RecvCompInfo.MSCompType & NDISWAN_128_ENCRYPTION) {
            BundleCB->RecvFlags |= (DO_ENCRYPTION | DO_128_ENCRYPTION);
        }
#endif
    }

    BundleCB->RecvFlags |=
        (BundleCB->RecvVJInfo.IPCompressionProtocol == 0x2D &&
         BundleCB->VJCompress != NULL) ? DO_VJ : 0;

    BundleCB->RecvFlags |=
        ((BundleCB->FramingInfo.RecvFramingBits & PPP_MULTILINK_FRAMING) &&
         ((BundleCB->ulLinkCBCount > 1) || (BundleCB->Flags & QOS_ENABLED))) ?
        DO_MULTILINK : 0;

    BundleCB->RecvFlags |=
        (BundleCB->FramingInfo.SendFramingBits & NBF_PRESERVE_MAC_ADDRESS) ?
        SAVE_MAC_ADDRESS : 0;

}

NTSTATUS
NotImplemented(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{

    return (STATUS_NOT_IMPLEMENTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\debug.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    debug.h
    
Abstract:

    This file contains data structures and defs used by the
    NdisWan driver for debugging
    
Author:

    Tony Bell   (TonyBe) January 18, 1997

Environment:

    Kernel Mode

Revision History:

    TonyBe      01/18/97        Created

--*/

#ifndef _NDISWAN_DEBUG_
#define _NDISWAN_DEBUG_

//
// OS specific structures
//
#ifdef NT

#endif
//
// end of OS specific structures
//

//
// Debugging
//
#define DBG_DEATH               1
#define DBG_CRITICAL_ERROR      2
#define DBG_FAILURE             4
#define DBG_INFO                6
#define DBG_TRACE               8
#define DBG_VERBOSE             10

#define DBG_INIT                0x00000001
#define DBG_MINIPORT            0x00000002
#define DBG_PROTOCOL            0x00000004
#define DBG_SEND                0x00000008
#define DBG_RECEIVE             0x00000010
#define DBG_IO                  0x00000020
#define DBG_MEMORY              0x00000040
#define DBG_VJ                  0x00000080
#define DBG_TAPI                0x00000100
#define DBG_CCP                 0x00000200
#define DBG_LOOPBACK            0x00000400
#define DBG_MULTILINK_RECV      0x00000800
#define DBG_MULTILINK_SEND      0x00001000
#define DBG_SEND_VJ             0x00002000
#define DBG_RECV_VJ             0x00004000
#define DBG_CL                  0x00008000
#define DBG_CM                  0x00010000
#define DBG_INDICATE            0x00020000
#define DBG_BACP                0x00040000
#define DBG_REQUEST             0x00080000
#define DBG_ALL                 0xFFFFFFFF

#define INIT_FILESIG            'tini'
#define MINIPORT_FILESIG        'inim'
#define PROTOCOL_FILESIG        'torp'
#define SEND_FILESIG            'dnes'
#define RECEIVE_FILESIG         'vcer'
#define IO_FILESIG              '  oi'
#define MEMORY_FILESIG          ' mem'
#define CCP_FILESIG             ' pcc'
#define CL_FILESIG              '  lc'
#define CM_FILESIG              '  mc'
#define INDICATE_FILESIG        'idni'
#define REQUEST_FILESIG         ' qer'
#define VJ_FILESIG              '  jv'
#define TAPI_FILESIG            'ipat'
#define LOOPBACK_FILESIG        'pool'
#define COMPRESS_FILESIG        'pmoc'
#define UTIL_FILESIG            'litu'

#define MAX_BYTE_DEPTH          2048

#if DBG

typedef struct _DBG_PACKET {
    LIST_ENTRY          Linkage;
    PVOID               Packet;
    ULONG               PacketType;
    struct _BUNDLECB    *BundleCB;
    ULONG               BundleState;
    ULONG               BundleFlags;
    struct _PROTOCOLCB  *ProtocolCB;
    ULONG               ProtocolState;
    struct _LINKCB      *LinkCB;
    ULONG               LinkState;
    ULONG               SendCount;
} DBG_PACKET, *PDBG_PACKET;

typedef enum DbgPktType {
    PacketTypeWan = 1,
    PacketTypeNdis
}DbgPktType;

typedef struct _DBG_PKT_CONTEXT {
    struct _BUNDLECB    *BundleCB;
    struct _PROTOCOLCB  *ProtocolCB;
    struct _LINKCB      *LinkCB;
    PVOID               Packet;
    DbgPktType          PacketType;
    PLIST_ENTRY         ListHead;
    PNDIS_SPIN_LOCK     ListLock;
} DBG_PKT_CONTEXT, *PDBG_PKT_CONTEXT;

typedef enum TRC_EVENT_TYPE {
    TrcEventSend = 1,
    TrcEventRecv
}TRC_EVENT_TYPE;

typedef struct _WAN_TRC_EVENT {
    LIST_ENTRY      Linkage;
    TRC_EVENT_TYPE  TrcType;
    WAN_TIME        TrcTimeStamp;
    ULONG           TrcInfoLength;
    PUCHAR          TrcInfo;
} WAN_TRC_EVENT, *PWAN_TRC_EVENT;

typedef enum SEND_TRC_TYPE {
    ProtocolQueue = 1,
    ProtocolSend,
    ProtocolSendComlete,
    FragmentSend,
    LinkSend,
    LinkSendComplete
} SEND_TRC_TYPE;

typedef struct _SEND_TRC_INFO {
    SEND_TRC_TYPE   SendTrcType;
    PNDIS_PACKET    NdisPacket;
    NDIS_HANDLE     BundleHandle;
    NDIS_HANDLE     ProtocolHandle;
    NDIS_HANDLE     LinkHandle;
    ULONG           SequenceNum;
} SEND_TRC_INFO, *PSEND_TRC_INFO;

#define NdisWanDbgOut(_DebugLevel, _DebugMask, _Out) {  \
    if ((glDebugLevel >= _DebugLevel) &&                \
        (_DebugMask & glDebugMask)) {                   \
        DbgPrint("NDISWAN: ");                          \
        DbgPrint _Out;                                  \
        DbgPrint("\n");                                 \
    }                                                   \
}

#undef ASSERT
#define ASSERT(exp) \
{                   \
    if (!(exp)) {   \
        DbgPrint("NDISWAN: ASSERTION FAILED! %s\n", #exp); \
        DbgPrint("NDISWAN: File: %s, Line: %d\n", __FILE__, __LINE__); \
        DbgBreakPoint(); \
    }               \
}

VOID
InsertDbgPacket(
    PDBG_PKT_CONTEXT    DbgContext
    );

BOOLEAN
RemoveDbgPacket(
    PDBG_PKT_CONTEXT    DbgContext
    );
    
#define INSERT_DBG_SEND(_pt, _ctxcb, _ppcb, _plcb, _p)      \
{                                                           \
    DBG_PKT_CONTEXT DbgContext;                             \
    DbgContext.Packet = (_p);                               \
    DbgContext.BundleCB = (_ppcb)->BundleCB;                \
    DbgContext.ProtocolCB = (_ppcb);                        \
    DbgContext.LinkCB = (_plcb);                            \
    if (_ctxcb != NULL) {                                   \
        DbgContext.PacketType = _pt;                        \
        DbgContext.ListHead = &(_ctxcb)->SendPacketList;    \
        DbgContext.ListLock = &(_ctxcb)->Lock;              \
        InsertDbgPacket(&DbgContext);                       \
    }                                                       \
}

#define REMOVE_DBG_SEND(_pt, _ctxcb, _p)                    \
{                                                           \
    DBG_PKT_CONTEXT DbgContext;                             \
    DbgContext.Packet = (_p);                               \
    if (_ctxcb != NULL) {                                   \
        DbgContext.PacketType = _pt;                        \
        DbgContext.ListHead = &(_ctxcb)->SendPacketList;    \
        DbgContext.ListLock = &(_ctxcb)->Lock;              \
        RemoveDbgPacket(&DbgContext);                       \
    }                                                       \
}

#define INSERT_DBG_RECV(_pt, _ctxcb, _ppcb, _plcb, _p)      \
{                                                           \
    DBG_PKT_CONTEXT DbgContext;                             \
    DbgContext.Packet = (_p);                               \
    DbgContext.BundleCB = NULL;                             \
    DbgContext.ProtocolCB = (_ppcb);                        \
    DbgContext.LinkCB = (_plcb);                            \
    if (_ctxcb != NULL) {                                   \
        DbgContext.PacketType = _pt;                        \
        DbgContext.ListHead = &(_ctxcb)->RecvPacketList;    \
        DbgContext.ListLock = &(_ctxcb)->Lock;              \
        InsertDbgPacket(&DbgContext);                       \
    }                                                       \
}

#define REMOVE_DBG_RECV(_pt, _ctxcb, _p)                    \
{                                                           \
    DBG_PKT_CONTEXT DbgContext;                             \
    DbgContext.Packet = (_p);                               \
    if (_ctxcb != NULL) {                                   \
        DbgContext.PacketType = _pt;                        \
        DbgContext.ListHead = &(_ctxcb)->RecvPacketList;    \
        DbgContext.ListLock = &(_ctxcb)->Lock;              \
        RemoveDbgPacket(&DbgContext);                       \
    }                                                       \
}

#define INSERT_RECV_EVENT(_c)                               \
{                                                           \
    reA[reI] = _c;                                          \
    LastIrpAction = _c;                                     \
    if (++reI >= 1024) {                                    \
        reI = 0;                                            \
    }                                                       \
}

#else   // If not built with debug

#define NdisWanDbgOut(_DebugLevel, _DebugMask, _Out)
#define INSERT_DBG_SEND(_pt, _ctxcb, _ppcb, _plcb, _p)
#define REMOVE_DBG_SEND(_pt, _ctxcb, _p)
#define INSERT_DBG_RECV(_pt, _ctxcb, _ppcb, _plcb, _p)
#define REMOVE_DBG_RECV(_pt, _ctxcb, _p)

#define INSERT_RECV_EVENT(_c)

#endif // end of !DBG

#endif // end of _NDISWAN_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\oidadd.h ===
//
// Information that applies to all VC's
// on this adapter.
//
// Struct: NDIS_WAN_CO_GET_INFO
//
#define OID_WAN_CO_GET_INFO				0x04010180

//
// Set VC specific PPP framing information.
//
// Struct: NDIS_WAN_CO_SET_LINK_INFO
//
#define OID_WAN_CO_SET_LINK_INFO		0x04010181

//
// Get VC specific PPP framing information.
//
// Struct: NDIS_WAN_CO_GET_LINK_INFO
//
#define OID_WAN_CO_GET_LINK_INFO		0x04010182

//
// Get VC specific PPP compression information
//
// Struct: NDIS_WAN_CO_GET_COMP_INFO
//
#define OID_WAN_CO_GET_COMP_INFO		0x04010280

//
// Set VC specific PPP compression information
//
// Struct: NDIS_WAN_CO_SET_COMP_INFO
//
#define OID_WAN_CO_SET_COMP_INFO		0x04010281

//
// Get VC specific statistics
//
// Struct: NDIS_WAN_CO_GET_STATS_INFO
//
#define OID_WAN_CO_GET_STATS_INFO		0x04010282

//
// Other OID's NdisWan will call...
//
//////////////////////////////////////////////////////
// OID_GEN_MAXIMUM_SEND_PACKETS:
//
// This will be used as the SendWindow between NdisWan
// and the miniport.  The query applies to all VC's on
// the AddressFamily.
//
//////////////////////////////////////////////////////
// OID_GEN_MAXIMUM_TOTAL_SIZE:
//
// This is used to query the largest send that a
// miniport can accept.  The query applies to all VC's
// on the AddressFamily.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\miniport.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Miniport.c

Abstract:

    This file contains the procedures that makeup most of the NDIS 3.1
    Miniport interface.


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#define __FILE_SIG__    MINIPORT_FILESIG

//
// Local function prototypes
//

//
// End local function prototypes
//

VOID
MPHalt(
    IN  NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Name:

    MPHalt

Routine Description:

    This routine free's all resources for the adapter.

Arguments:

    MiniportAdapterContext - AdapterContext that is given to the wrapper in
                             NdisMSetAttributes call.  Is our MiniportCB.

Return Values:

    None

--*/
{
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPHalt: Enter"));
    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MiniportCB: 0x%x", MiniportCB));

    //
    // Make sure that there are no ProtocolCB's
    // running over this miniport!  If so we
    // need to do a linedown to them.
    //
    NdisAcquireSpinLock(&MiniportCB->Lock);

    MiniportCB->Flags |= HALT_IN_PROGRESS;

    while (!IsListEmpty(&MiniportCB->ProtocolCBList)) {
        PLIST_ENTRY le;
        PPROTOCOLCB ProtocolCB;
        PBUNDLECB   BundleCB;
        ProtocolState   OldState;

        le = MiniportCB->ProtocolCBList.Flink;

        ProtocolCB =(PPROTOCOLCB)
            CONTAINING_RECORD(le, PROTOCOLCB, MiniportLinkage);

        NdisReleaseSpinLock(&MiniportCB->Lock);

        BundleCB = ProtocolCB->BundleCB;

        AcquireBundleLock(BundleCB);

        OldState = ProtocolCB->State;

        ProtocolCB->State = PROTOCOL_UNROUTING;
        BundleCB->SendMask &= ~ProtocolCB->SendMaskBit;
    
        //
        // Flush the protocol packet queues.  This could cause us
        // to complete frames to ndis out of order.  Ndis should
        // handle this.
        //
        FlushProtocolPacketQueue(ProtocolCB);
    
        //
        // If the protocols refcount goes to zero
        // we need to do a linedown and cleanup
        //
        if ((--ProtocolCB->RefCount == 0) &&
            (OldState == PROTOCOL_ROUTED)) {

            DoLineDownToProtocol(ProtocolCB);

            //
            // Returns with bundlecb->lock released
            //
            RemoveProtocolCBFromBundle(ProtocolCB);

            ReleaseBundleLock(BundleCB);

            NdisWanFreeProtocolCB(ProtocolCB);

        } else {

            ReleaseBundleLock(BundleCB);

            NdisWanWaitForSyncEvent(&MiniportCB->HaltEvent);

            NdisWanClearSyncEvent(&MiniportCB->HaltEvent);
        }

        NdisAcquireSpinLock(&MiniportCB->Lock);
    }

    NdisReleaseSpinLock(&MiniportCB->Lock);

    DEREF_MINIPORTCB(MiniportCB);

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPHalt: Exit"));
}

NDIS_STATUS
MPInitialize(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN  PNDIS_MEDIUM    MediumArray,
    IN  UINT            MediumArraySize,
    IN  NDIS_HANDLE     MiniportAdapterHandle,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    )
/*++

Routine Name:

    MPInitialize

Routine Description:

    This routine is called after NdisWan registers itself as a Miniport driver.
    It is responsible for installing NdisWan as a Miniport driver, creating
    adapter control blocks for each adapter NdisWan exposes (should only be 1),
    and initializing all adapter specific variables


Arguments:

    OpenErrorStatus - Returns information about the error if this function
                      returns NDIS_STATUS_OPEN_ERROR. Used for TokenRing.

    SelectedMediumIndex - An index into the MediumArray that specifies the
                          medium type of this driver. Should be WAN or 802.3

    MediumArray - An array of medium types supported by the NDIS library

    MediumArraySize - Size of the medium array

    MiniportAdapterHandle - Handle assigned by the NDIS library that defines
                            this miniport driver.  Used as handle in subsequent
                            calls to the NDIS library.

    WrapperConfigurationContext - Handle used to read configuration information
                                  from the registry

Return Values:

    NDIS_STATUS_ADAPTER_NOT_FOUND
    NDIS_STATUS_FAILURE
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_OPEN_ERROR
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_UNSUPPORTED_MEDIA

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PMINIPORTCB MiniportCB;
    UINT        Index;
    NDIS_HANDLE ConfigHandle;
    ULONG       NetworkAddressLength;
#ifdef NT
    LARGE_INTEGER   TickCount, SystemTime;
#endif

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPInitialize: Enter"));

    //
    // We have to be type 802.3 to the ndis wrapper, but the
    // wrapper will expose us to the transports as type wan.
    //
    for (Index = 0; Index < MediumArraySize; Index++) {

        if (MediumArray[Index] == NdisMedium802_3) {
            break;
        }
    }

    //
    // We don't have a match so we are screwed
    //
    if (Index == MediumArraySize) {
        return (NDIS_STATUS_UNSUPPORTED_MEDIA);
    }

    *SelectedMediumIndex = Index;

    //
    // Allocate and initialize miniport adapter structure
    //
#ifdef MINIPORT_NAME
    MiniportCB = NdisWanAllocateMiniportCB(&((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->MiniportName);
#else
    MiniportCB = NdisWanAllocateMiniportCB(NULL);
#endif

    if (MiniportCB == NULL) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MINIPORT,
                     ("Error Creating MiniportCB!"));
        return (NDIS_STATUS_FAILURE);
    }

#ifndef MY_DEVICE_OBJECT
    if (NdisWanCB.pDeviceObject == NULL) {
        PDRIVER_DISPATCH DispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1];
        NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\NdisWan");
        NDIS_STRING Name = NDIS_STRING_CONST("\\Device\\NdisWan");
        ULONG   i;
        NTSTATUS    Status;


        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
    
            DispatchTable[i] = NdisWanIrpStub;
        }
    
        DispatchTable[IRP_MJ_CREATE] = NdisWanCreate;
        DispatchTable[IRP_MJ_DEVICE_CONTROL] = NdisWanIoctl;
        DispatchTable[IRP_MJ_CLEANUP] = NdisWanCleanup;

        Status =
        NdisMRegisterDevice(NdisWanCB.NdisWrapperHandle,
                            &Name,
                            &SymbolicName,
                            DispatchTable,
                            &NdisWanCB.pDeviceObject,
                            &NdisWanCB.DeviceHandle);

        if (Status == STATUS_SUCCESS) {
            NdisWanCB.pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        } else {
            NdisWanCB.pDeviceObject = NULL;
        }
    }
#endif

    NdisMSetAttributesEx(MiniportAdapterHandle,
                         MiniportCB,
                         (UINT)-1,
//
// KyleB says that the following two defines are redundant if
// the miniport is deserialized.
//
//                       NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT   |
//                       NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER     |
                         NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT  |
                         NDIS_ATTRIBUTE_DESERIALIZE             |
                         NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
                         NdisInterfaceInternal);

    MiniportCB->MediumType = MediumArray[Index];
    MiniportCB->RefCount = 0;
    MiniportCB->MiniportHandle = MiniportAdapterHandle;

    //
    // Read per miniport instance data
    //
    NdisOpenConfiguration(&Status,
                          &ConfigHandle,
                          WrapperConfigurationContext);

    if (Status == NDIS_STATUS_SUCCESS) {
        
        NdisReadNetworkAddress(&Status,
                               (PVOID*)&(MiniportCB->NetworkAddress),
                               &NetworkAddressLength,
                               ConfigHandle);

        NdisCloseConfiguration(ConfigHandle);

        if (Status != NDIS_STATUS_SUCCESS ||
            NetworkAddressLength != ETH_LENGTH_OF_ADDRESS) {

            goto BuildAddress;
            
        }


    } else {

BuildAddress:

#ifdef NT

        KeQueryTickCount(&TickCount);
        KeQuerySystemTime(&SystemTime);

        MiniportCB->NetworkAddress[0] = (UCHAR)((TickCount.LowPart >> 16) ^
                                                (SystemTime.LowPart >> 16)) &
                                                0xFE;

        MiniportCB->NetworkAddress[1] = (UCHAR)((TickCount.LowPart >> 8) ^
                                                (SystemTime.LowPart >> 8));

        //
        // The following 4 bytes will be filled in at lineup time
        //
        MiniportCB->NetworkAddress[2] = ' ';
        MiniportCB->NetworkAddress[3] = 'R';
        MiniportCB->NetworkAddress[4] = 'A';
        MiniportCB->NetworkAddress[5] = 'S';
#endif

    }

    //
    // Register our connection manager address family for this
    // miniport
    //
    {

    CO_ADDRESS_FAMILY   CoAddressFamily;
    NDIS_CALL_MANAGER_CHARACTERISTICS CmCharacteristics;

    NdisZeroMemory(&CmCharacteristics,
                   sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS));

    CoAddressFamily.AddressFamily = CO_ADDRESS_FAMILY_PPP;
    CoAddressFamily.MajorVersion = NDISWAN_MAJOR_VERSION;
    CoAddressFamily.MinorVersion = NDISWAN_MINOR_VERSION;

    CmCharacteristics.MajorVersion = NDISWAN_MAJOR_VERSION;
    CmCharacteristics.MinorVersion = NDISWAN_MINOR_VERSION;

    CmCharacteristics.CmCreateVcHandler = CmCreateVc;
    CmCharacteristics.CmDeleteVcHandler = CmDeleteVc;

    CmCharacteristics.CmOpenAfHandler = CmOpenAf;
    CmCharacteristics.CmCloseAfHandler = CmCloseAf;
    CmCharacteristics.CmRegisterSapHandler = CmRegisterSap;
    CmCharacteristics.CmDeregisterSapHandler = CmDeregisterSap;
    CmCharacteristics.CmMakeCallHandler = CmMakeCall;
    CmCharacteristics.CmCloseCallHandler = CmCloseCall;
    CmCharacteristics.CmIncomingCallCompleteHandler = CmIncomingCallComplete;
    CmCharacteristics.CmAddPartyHandler = NULL;
    CmCharacteristics.CmDropPartyHandler = NULL;
    CmCharacteristics.CmActivateVcCompleteHandler = CmActivateVcComplete;
    CmCharacteristics.CmDeactivateVcCompleteHandler = CmDeactivateVcComplete;
    CmCharacteristics.CmModifyCallQoSHandler = CmModifyCallQoS;
    CmCharacteristics.CmRequestHandler = CmRequest;
    CmCharacteristics.CmRequestCompleteHandler = ProtoCoRequestComplete;


    NdisMCmRegisterAddressFamily(MiniportCB->MiniportHandle,
                                 &CoAddressFamily,
                                 &CmCharacteristics,
                                 sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS));
    }

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPInitialize: Exit"));

    REF_MINIPORTCB(MiniportCB);

    return (NDIS_STATUS_SUCCESS);
}

#if 0
NDIS_STATUS
MPQueryInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;
    NDIS_REQUEST    NdisRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPQueryInformation: Enter Oid: 0x%x", Oid));

    NdisWanInterlockedInc(&MiniportCB->RefCount);

    NdisRequest.RequestType =
        NdisRequestQueryInformation;

    NdisRequest.DATA.QUERY_INFORMATION.Oid =
        Oid;

    NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
        InformationBuffer;

    NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
        InformationBufferLength;

    NdisRequest.DATA.QUERY_INFORMATION.BytesWritten =
        *BytesWritten;

    NdisRequest.DATA.QUERY_INFORMATION.BytesNeeded =
        *BytesNeeded;

    Status = NdisWanOidProc(MiniportCB, &NdisRequest);

    *BytesWritten = NdisRequest.DATA.QUERY_INFORMATION.BytesWritten;
    *BytesNeeded = NdisRequest.DATA.QUERY_INFORMATION.BytesNeeded;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPQueryInformation: Exit Status: %x", Status));

    NdisWanInterlockedDec(&MiniportCB->RefCount);

    return (Status);
}
#endif

NDIS_STATUS
MPReconfigure(
    OUT PNDIS_STATUS    OpenErrorStatus,
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPReconfigure: Enter"));

    NdisWanInterlockedInc(&MiniportCB->RefCount);

    NdisWanInterlockedDec(&MiniportCB->RefCount);

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPReconfigure: Exit"));
    return (Status);
}

NDIS_STATUS
MPReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPReset: Enter"));

    *AddressingReset = FALSE;

    NdisWanInterlockedInc(&MiniportCB->RefCount);

    NdisAcquireSpinLock(&MiniportCB->Lock);

    MiniportCB->Flags &= ~ASK_FOR_RESET;

    NdisReleaseSpinLock(&MiniportCB->Lock);

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPReset: Exit"));

    NdisWanInterlockedDec(&MiniportCB->RefCount);

    return (Status);
}

#if 0
NDIS_STATUS
MPSetInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;
    NDIS_REQUEST    NdisRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPSetInformation: Enter Oid: 0x%x", Oid));

    NdisWanInterlockedInc(&MiniportCB->RefCount);

    NdisRequest.RequestType =
        NdisRequestSetInformation;

    NdisRequest.DATA.SET_INFORMATION.Oid =
        Oid;

    NdisRequest.DATA.SET_INFORMATION.InformationBuffer =
        InformationBuffer;

    NdisRequest.DATA.SET_INFORMATION.InformationBufferLength =
        InformationBufferLength;

    NdisRequest.DATA.SET_INFORMATION.BytesRead =
        *BytesWritten;

    NdisRequest.DATA.SET_INFORMATION.BytesNeeded =
        *BytesNeeded;

    Status = NdisWanOidProc(MiniportCB, &NdisRequest);

    *BytesWritten = NdisRequest.DATA.SET_INFORMATION.BytesRead;
    *BytesNeeded = NdisRequest.DATA.SET_INFORMATION.BytesNeeded;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPSetInformation: Exit"));

    NdisWanInterlockedDec(&MiniportCB->RefCount);

    return (Status);
}
#endif

VOID
MPReturnPacket(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PNDIS_PACKET    Packet
    )
{
    PNDISWAN_PROTOCOL_RESERVED  pres;
    PMINIPORTCB     MiniportCB;
    PNDIS_BUFFER    NdisBuffer;
    PRECV_DESC  RecvDesc;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("MPReturnPacket: Enter Packet %p", Packet));

    pres = PPROTOCOL_RESERVED_FROM_NDIS(Packet);

    MiniportCB = (PMINIPORTCB)MiniportAdapterContext;

    RecvDesc = pres->RecvDesc;

    REMOVE_DBG_RECV(PacketTypeNdis, MiniportCB, Packet);

    NdisWanFreeRecvDesc(RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("MPReturnPacket: Exit"));
}

VOID
MPSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets
    )
{
    ULONG   i;
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("MPSendPackets: Enter"));

    for (i = 0; i < NumberOfPackets; i++) {
        PNDIS_PACKET    NdisPacket = PacketArray[i];

        PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->CmVcCB = NULL;

        NdisWanQueueSend(MiniportCB,
                         NdisPacket);
        
    }

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("MPSendPackets: Exit"));
}

NDIS_STATUS
MPCoCreateVc(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     NdisVcHandle,
    OUT PNDIS_HANDLE    MiniportVcContext
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoCreateVc: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoCreateVc: Exit"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
MPCoDeleteVc(
    IN  NDIS_HANDLE MiniportVcContext
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoDeleteVc: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoDeleteVc: Exit"));
    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
MPCoActivateVc(
    IN  NDIS_HANDLE             MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoActivateVc: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoActivateVc: Exit"));
    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
MPCoDeactivateVc(
    IN  NDIS_HANDLE MiniportVcContext
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoDeactivateVc: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoDeactivateVc: Exit"));
    return (NDIS_STATUS_SUCCESS);
}

VOID
MPCoSendPackets(
    IN  NDIS_HANDLE     MiniportVcContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets
    )
{
    ULONG   i;
    PCM_VCCB    CmVcCB  = (PCM_VCCB)MiniportVcContext;
    PCM_AFSAPCB AfSapCB = CmVcCB->AfSapCB;
    PMINIPORTCB MiniportCB = AfSapCB->MiniportCB;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("MPCoSendPackets: Enter"));

    if (CmVcCB->State != CMVC_ACTIVE) {

        for (i = 0; i < NumberOfPackets; i++) {
            PNDIS_PACKET    NdisPacket = PacketArray[i];

            NdisMCoSendComplete(NDIS_STATUS_FAILURE,
                                CmVcCB->NdisVcHandle,
                                NdisPacket);
        }

        return;
    }

    for (i = 0; i < NumberOfPackets; i++) {
        PNDIS_PACKET    NdisPacket = PacketArray[i];

        REF_CMVCCB(CmVcCB);

        PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->CmVcCB = CmVcCB;

        NdisWanQueueSend(MiniportCB,
                         NdisPacket);
        
    }

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("MPCoSendPackets: Exit"));
}

NDIS_STATUS
MPCoRequest(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportVcContext   OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    )
{
    NDIS_STATUS Status;
    PCM_VCCB    CmVcCB;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoRequest: Enter Oid: 0x%x",
        NdisRequest->DATA.QUERY_INFORMATION.Oid));

    CmVcCB = (PCM_VCCB)MiniportVcContext;

    Status =
        NdisWanCoOidProc((PMINIPORTCB)MiniportAdapterContext,
                         CmVcCB,
                         NdisRequest);

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoRequest: Exit Status: 0x%x", Status));

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\loopback.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Loopback.c

Abstract:

    This file contains the procedures for doing loopback of send
    packets for ndiswan.  Loopback is being done in NdisWan because
    the NDIS wrapper could not meet all of the needs of NdisWan.

Author:

    Tony Bell   (TonyBe) January 25, 1996

Environment:

    Kernel Mode

Revision History:

    TonyBe  01/25/96    Created

--*/

#include "wan.h"

#define __FILE_SIG__    LOOPBACK_FILESIG

VOID
NdisWanIndicateLoopbackPacket(
    PMINIPORTCB     MiniportCB,
    PNDIS_PACKET    NdisPacket
    )
{
    ULONG           BytesCopied, PacketLength;
    PRECV_DESC      RecvDesc;
    PNDIS_PACKET    LocalNdisPacket;
    PNDIS_BUFFER    NdisBuffer;
    NDIS_STATUS     Status;
    PCM_VCCB        CmVcCB;
    KIRQL           OldIrql;

    NdisWanDbgOut(DBG_TRACE, DBG_LOOPBACK, ("NdisWanIndicateLoopbackPacket: Enter"));
    NdisWanDbgOut(DBG_INFO, DBG_LOOPBACK, ("MiniportCB: 0x%p, NdisPacket: 0x%p",
               MiniportCB, NdisPacket));

    NdisQueryPacket(NdisPacket,
                    NULL,
                    NULL,
                    NULL,
                    &PacketLength);

    RecvDesc = 
        NdisWanAllocateRecvDesc(PacketLength);

    if (RecvDesc == NULL) {
        return;
    }

    NdisWanCopyFromPacketToBuffer(NdisPacket,
                                  0,
                                  PacketLength,
                                  RecvDesc->StartBuffer,
                                  &BytesCopied);

    ASSERT(BytesCopied == PacketLength);

    if (MiniportCB->ProtocolType == PROTOCOL_IP) {
        UCHAR   x[ETH_LENGTH_OF_ADDRESS];
        //
        // If this is IP we are going to assume
        // that wanarp has set the appropriate
        // bit requiring ndiswan to loopback the
        // packet so we must switch the src/dest
        // contexts.
        ETH_COPY_NETWORK_ADDRESS(x, &RecvDesc->StartBuffer[6]);
        ETH_COPY_NETWORK_ADDRESS(&RecvDesc->StartBuffer[6], 
                                 &RecvDesc->StartBuffer[0]);
        ETH_COPY_NETWORK_ADDRESS(&RecvDesc->StartBuffer[0], x);
    }

    RecvDesc->CurrentLength = PacketLength;

    LocalNdisPacket = 
        RecvDesc->NdisPacket;

    NdisBuffer =
        RecvDesc->NdisBuffer;

    //
    // Attach the buffers
    //
    NdisAdjustBufferLength(NdisBuffer,
                           RecvDesc->CurrentLength);

    NdisRecalculatePacketCounts(LocalNdisPacket);

    CmVcCB =
        PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->CmVcCB;

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    NDIS_SET_PACKET_STATUS(LocalNdisPacket, NDIS_STATUS_RESOURCES);

    INSERT_DBG_RECV(PacketTypeNdis, MiniportCB, NULL, NULL, LocalNdisPacket);

    //
    // Indicate the packet
    //
    if (CmVcCB != NULL) {

        NdisMCoIndicateReceivePacket(CmVcCB->NdisVcHandle,
                                     &LocalNdisPacket,
                                     1);
    } else {

        NdisMIndicateReceivePacket(MiniportCB->MiniportHandle,
                                   &LocalNdisPacket,
                                   1);
    }

    KeLowerIrql(OldIrql);

#if DBG
    Status = NDIS_GET_PACKET_STATUS(LocalNdisPacket);

    ASSERT(Status == NDIS_STATUS_RESOURCES);
#endif

    REMOVE_DBG_RECV(PacketTypeNdis, MiniportCB, LocalNdisPacket);

    NdisWanFreeRecvDesc(RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_LOOPBACK, ("NdisWanIndicateLoopbackPacket: Exit"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\memory.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Ndiswan.c

Abstract:

    This is the initialization file for the NdisWan driver.  This driver
    is a shim between the protocols, where it conforms to the NDIS 3.1
    Miniport interface spec, and the WAN Miniport drivers, where it exports
    the WAN Extensions for Miniports (it looks like a protocol to the WAN
    Miniport drivers).

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#define __FILE_SIG__    MEMORY_FILESIG

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, NdisWanCreateProtocolInfoTable)
#endif

EXPORT
VOID
NdisTapiDeregisterProvider(
    IN  NDIS_HANDLE
    );

//
// Local function prototypes
//
PVOID
AllocateWanPacket(
    IN  POOL_TYPE   PoolType,
    IN  SIZE_T      NumberOfBytes,
    IN  ULONG       Tag
    );

VOID
FreeWanPacket(
    PVOID   WanPacket
    );

//
// End local function prototypes
//

PMINIPORTCB
NdisWanAllocateMiniportCB(
    IN  PNDIS_STRING    AdapterName
    )
/*++

Routine Name:

    NdisWanAllocateMiniportCB

Routine Description:

    This routine creates and initializes an MiniportCB

Arguments:

Return Values:

--*/
{
    PMINIPORTCB LocalMiniportCB;
    ULONG       ulAllocationSize, i;

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanCreateMiniportCB: Enter"));

    //
    // Allocate and zero out the memory block
    //
    NdisWanAllocateMemory(&LocalMiniportCB, MINIPORTCB_SIZE, MINIPORTCB_TAG);

    if (LocalMiniportCB == NULL) {

        return (NULL);
    }

    NdisZeroMemory(LocalMiniportCB, MINIPORTCB_SIZE);

    //
    // setup the new control block
    //
    NdisAllocateSpinLock(&LocalMiniportCB->Lock);

#ifdef MINIPORT_NAME
    NdisWanAllocateAdapterName(&LocalMiniportCB->AdapterName, AdapterName);
#endif

#if DBG
    InitializeListHead(&LocalMiniportCB->SendPacketList);
    InitializeListHead(&LocalMiniportCB->RecvPacketList);
#endif

    InitializeListHead(&LocalMiniportCB->ProtocolCBList);
    InitializeListHead(&LocalMiniportCB->AfSapCBList);

    NdisWanInitializeSyncEvent(&LocalMiniportCB->HaltEvent);
    NdisWanClearSyncEvent(&LocalMiniportCB->HaltEvent);

    //
    // Add to global list
    //
    InsertTailGlobalList(MiniportCBList, &(LocalMiniportCB->Linkage));

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("%ls MiniportCB: 0x%x, Number: %d",
                         LocalMiniportCB->AdapterName.Buffer, LocalMiniportCB, MiniportCBList.ulCount));

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanCreateMiniportCB: Exit"));

    return (LocalMiniportCB);
}

VOID
NdisWanFreeMiniportCB(
    IN  PMINIPORTCB pMiniportCB
    )
/*++

Routine Name:

    NdisWanFreeMiniportCB

Routine Description:

    This frees a MiniportCB

Arguments:

    pMiniportCB - Pointer to to the MiniportCB that is being destroyed

Return Values:

    None

--*/
{
    PMINIPORTCB mcb;
    BOOLEAN     Found = FALSE;

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanFreeMiniportCB: Enter"));
    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("MiniportCB: 0x%x", pMiniportCB));

#ifdef MINIPORT_NAME
    NdisWanFreeNdisString(&pMiniportCB->AdapterName);
#endif

    NdisFreeSpinLock(&pMiniportCB->Lock);

    NdisAcquireSpinLock(&MiniportCBList.Lock);

    RemoveEntryList(&pMiniportCB->Linkage);

    MiniportCBList.ulCount--;

    //
    // Walk the miniportcb list and see if this is the only
    // instance of this protocol.  If it is we need to notify
    // user-mode that a protocol has been removed.
    //
    mcb = (PMINIPORTCB)MiniportCBList.List.Flink;

    while ((PVOID)mcb != (PVOID)&MiniportCBList.List) {
        if (mcb->ProtocolType == pMiniportCB->ProtocolType) {
            Found = TRUE;
            break;
        }

        mcb = (PMINIPORTCB)mcb->Linkage.Flink;
    }

    NdisReleaseSpinLock(&MiniportCBList.Lock);

    if (Found == FALSE) {
        PROTOCOL_INFO  pinfo;

        NdisZeroMemory(&pinfo, sizeof(pinfo));
        pinfo.ProtocolType = pMiniportCB->ProtocolType;
        pinfo.Flags = PROTOCOL_UNBOUND;
        SetProtocolInfo(&pinfo);
    }

    NdisWanFreeMemory(pMiniportCB);

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanFreeMiniportCB: Exit"));
}

POPENCB
NdisWanAllocateOpenCB(
    IN  PUNICODE_STRING BindName
    )
/*++

Routine Name:

    NdisWanAllocateOpenCB

Routine Description:

    This routine creates and initializes a OpenCB

Arguments:

    BindName - Pointer to an NDIS_STRING that has the name of the WAN Miniport
               that will be used in the NdisOpenAdapter call when we bind to
               the WAN Miniport.

Return Values:

--*/
{
    POPENCB pOpenCB;
    ULONG   ulAllocationSize;
    USHORT  i;

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanCreateOpenCB: Enter"));
    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("BindName: %ls", BindName));

    //
    // Allocate memory for OpenCB
    //
    NdisWanAllocateMemory(&pOpenCB, OPENCB_SIZE, OPENCB_TAG);

    if (pOpenCB == NULL) {
        return (NULL);
    }

    NdisZeroMemory(pOpenCB, OPENCB_SIZE);
    NdisWanInitializeNotificationEvent(&pOpenCB->InitEvent);

    //
    // Parse out the GUID for this miniport
    //


    //
    // Setup new control block
    //
    NdisWanAllocateMemory(&pOpenCB->MiniportName.Buffer, BindName->MaximumLength, NDISSTRING_TAG);
    pOpenCB->MiniportName.MaximumLength = BindName->MaximumLength;
    pOpenCB->MiniportName.Length = BindName->Length;
    NdisWanCopyUnicodeString(&pOpenCB->MiniportName, BindName);

    //
    // Go to the end of the string and work back until we find
    // the first "{".  Now start parsing the string converting
    // and copying from WCHAR to CHAR all digits until we hit
    // the closing "}".
    //
    for (i = pOpenCB->MiniportName.Length/sizeof(WCHAR); i > 0; i--) {
        if (pOpenCB->MiniportName.Buffer[i-1] == (WCHAR)L'{') {
            break;
        }
    }

    if (i != 0) {
        NDIS_STRING Src;

        Src.Length =
            BindName->Length - ((i-1)*sizeof(WCHAR));
        Src.MaximumLength =
            BindName->Length - ((i-1)*sizeof(WCHAR));
        Src.Buffer = &BindName->Buffer[i-1];

        RtlGUIDFromString(&Src, &pOpenCB->Guid);
    }

    NdisAllocateSpinLock(&pOpenCB->Lock);
    InitializeListHead(&pOpenCB->AfSapCBList);
    InitializeListHead(&pOpenCB->AfSapCBClosing);
    InitializeListHead(&pOpenCB->WanRequestList);

#if DBG
    InitializeListHead(&pOpenCB->SendPacketList);
#endif

    //
    // Put OpenCB on global list
    //
    InsertTailGlobalList(OpenCBList, &(pOpenCB->Linkage));

    pOpenCB->RefCount = 1;

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("WanMiniport %ls OpenCB: 0x%x",
                                      pOpenCB->MiniportName.Buffer, pOpenCB));
    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanCreateOpenCB: Exit"));

    return(pOpenCB);
}

VOID
NdisWanFreeOpenCB(
    IN  POPENCB pOpenCB
    )
/*++

Routine Name:

    NdisWanFreeOpenCB

Routine Description:

    This routine frees a OpenCB

Arguments:

    pOpenCB - Pointer to the OpenCB that is being destroyed

Return Values:

    None

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanFreeOpenCB: Enter - OpenCB: 0x%p", pOpenCB));

    if (pOpenCB->Flags & OPEN_LEGACY &&
        pOpenCB->Flags & SEND_RESOURCES) {
        NdisWanFreeSendResources(pOpenCB);
    }

    //
    // Remove from OpenCB global list
    //
    RemoveEntryGlobalList(OpenCBList, &(pOpenCB->Linkage));

    //
    // Free the memory allocated for the NDIS_STRING
    //
    NdisWanFreeNdisString(&pOpenCB->MiniportName);

    //
    // Free the memory allocated for the control block
    //
    NdisWanFreeMemory(pOpenCB);

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanFreeOpenCB: Exit"));
}

PPROTOCOLCB
NdisWanAllocateProtocolCB(
    IN  PNDISWAN_ROUTE  Route
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PPROTOCOLCB     LocalProtocolCB;
    PUCHAR          AllocatedMemory;
    PROTOCOL_INFO   ProtocolInfo = {0};

    LocalProtocolCB =
        NdisAllocateFromNPagedLookasideList(&LinkProtoCBList);

    if (LocalProtocolCB == NULL) {
        return(NULL);
    }

    NdisZeroMemory(LocalProtocolCB, PROTOCOLCB_SIZE);

    LocalProtocolCB->Signature = PROTOCB_SIG;

    if (Route->ulBufferLength > 0) {
        NdisWanAllocateMemory(&AllocatedMemory,
                              Route->ulBufferLength,
                              PROTOCOLCB_TAG);
    
        if (AllocatedMemory == NULL) {
            NdisFreeToNPagedLookasideList(&LinkProtoCBList, LocalProtocolCB);
            return (NULL);
        }

        LocalProtocolCB->LineUpInfo = AllocatedMemory;
    }

    //
    // Copy the bindingname
    //
    if (Route->usBindingNameLength != 0) {
        USHORT  usBindingNameLength;
        WCHAR   BindingName[MAX_NAME_LENGTH+1] = {0};

        usBindingNameLength = Route->usBindingNameLength;

        //
        // We will limit the binding name string to 256 wchars
        //
        if (usBindingNameLength > (MAX_NAME_LENGTH * sizeof(WCHAR))) {
            usBindingNameLength = MAX_NAME_LENGTH * sizeof(WCHAR);
        } 

        NdisMoveMemory((PUCHAR)BindingName, 
                       (PUCHAR)Route->BindingName,
                       usBindingNameLength);

        NdisWanStringToNdisString(&LocalProtocolCB->BindingName, BindingName);
    }


    if (Route->usDeviceNameLength != 0) {
        USHORT  usDeviceNameLength;

        usDeviceNameLength = Route->usDeviceNameLength;

        //
        // We will limit the binding name string to 256 wchars
        //
        if (usDeviceNameLength > (MAX_NAME_LENGTH * sizeof(WCHAR))) {
            usDeviceNameLength = (MAX_NAME_LENGTH * sizeof(WCHAR));
        }

        NdisWanAllocateMemory(&(LocalProtocolCB->InDeviceName.Buffer),
                              usDeviceNameLength,
                              NDISSTRING_TAG);

        if (LocalProtocolCB->InDeviceName.Buffer != NULL) {

            LocalProtocolCB->InDeviceName.MaximumLength = usDeviceNameLength;
            LocalProtocolCB->InDeviceName.Length        = usDeviceNameLength;

            RtlCopyMemory((PUCHAR)LocalProtocolCB->InDeviceName.Buffer,
                          (PUCHAR)Route->DeviceName,
                          usDeviceNameLength);
        }

    }

    //
    // Copy over the protocol info
    //
    LocalProtocolCB->ulLineUpInfoLength = Route->ulBufferLength;
    if (Route->ulBufferLength != 0) {
        NdisMoveMemory(LocalProtocolCB->LineUpInfo,
                       Route->Buffer,
                       Route->ulBufferLength);
    }
    
    //
    // Setup the protocol type
    //
    LocalProtocolCB->ProtocolType = Route->usProtocolType;
    
    //
    // Get the PPP protocol value for this protocol type
    //
    ProtocolInfo.ProtocolType = Route->usProtocolType;

    if (GetProtocolInfo(&ProtocolInfo) != TRUE) {

        if (LocalProtocolCB->BindingName.Length != 0) {
            NdisWanFreeNdisString(&LocalProtocolCB->BindingName);
        }

        if (LocalProtocolCB->LineUpInfo != NULL) {
            NdisWanFreeMemory(LocalProtocolCB->LineUpInfo);
        }

        if (LocalProtocolCB->InDeviceName.Length != 0) {
            NdisWanFreeMemory(LocalProtocolCB->InDeviceName.Buffer);
        }

        NdisFreeToNPagedLookasideList(&LinkProtoCBList, LocalProtocolCB);
        return (NULL);
    }

    InitializeListHead(&LocalProtocolCB->VcList);
    NdisWanInitializeSyncEvent(&LocalProtocolCB->UnrouteEvent);

    LocalProtocolCB->PPPProtocolID = ProtocolInfo.PPPId;
    LocalProtocolCB->MTU = ProtocolInfo.MTU;
    LocalProtocolCB->TunnelMTU = ProtocolInfo.TunnelMTU;
    LocalProtocolCB->State = PROTOCOL_ROUTING;
    LocalProtocolCB->RefCount = 1;

    switch (Route->usProtocolType) {
        case PROTOCOL_IP:
            LocalProtocolCB->NonIdleDetectFunc = IpIsDataFrame;
            break;
        case PROTOCOL_IPX:
            LocalProtocolCB->NonIdleDetectFunc = IpxIsDataFrame;
            break;
        case PROTOCOL_NBF:
            LocalProtocolCB->NonIdleDetectFunc = NbfIsDataFrame;
            break;
        default:
            LocalProtocolCB->NonIdleDetectFunc = NULL;
            break;
    }
    
    NdisWanGetSystemTime(&LocalProtocolCB->LastNonIdleData);

    return(LocalProtocolCB);
}

VOID
NdisWanFreeProtocolCB(
    IN  PPROTOCOLCB ProtocolCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{

#if DBG
    {
        ULONG i;

        for (i = 0; i < MAX_MCML; i++) {
            ASSERT(ProtocolCB->PacketQueue[i].HeadQueue == NULL);
            ASSERT(ProtocolCB->PacketQueue[i].TailQueue == NULL);
        }

    }
#endif

    if (ProtocolCB->InDeviceName.Length != 0) {
        NdisWanFreeMemory(ProtocolCB->InDeviceName.Buffer);
    }

    if (ProtocolCB->OutDeviceName.Length != 0) {
        NdisWanFreeNdisString(&ProtocolCB->OutDeviceName);
    }

    if (ProtocolCB->BindingName.Length != 0) {
        NdisWanFreeNdisString(&ProtocolCB->BindingName);
    }

    if (ProtocolCB->LineUpInfo != NULL) {
        NdisWanFreeMemory(ProtocolCB->LineUpInfo);
    }

    NdisFreeSpinLock(&ProtocolCB->Lock);

    NdisFreeToNPagedLookasideList(&LinkProtoCBList, ProtocolCB);
}

PLINKCB
NdisWanAllocateLinkCB(
    IN  POPENCB OpenCB,
    IN  ULONG   SendWindow
    )
/*++

Routine Name:

    NdisWanGetLinkCB

Routine Description:

    This function returns a pointer to a LinkCB.  The LinkCB is either retrieved
    from the WanAdapters free list or, if this list is empty, it is allocated.

Arguments:

    OpenCB - Pointer to the WanAdapter control block that this Link is
                   associated with

Return Values:

    None

--*/
{
    PLINKCB LocalLinkCB;

    //
    // Figure out how much we need to allocate
    //

    LocalLinkCB =
        NdisAllocateFromNPagedLookasideList(&LinkProtoCBList);

    if (LocalLinkCB == NULL) {
        
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY, ("Error allocating memory for LinkCB"));

        return (NULL);
    }

    NdisZeroMemory(LocalLinkCB, LINKCB_SIZE);

    //
    // Initialize the control block
    //
    NdisWanInitializeSyncEvent(&LocalLinkCB->OutstandingFramesEvent);

    LocalLinkCB->Signature = LINKCB_SIG;
    LocalLinkCB->hLinkContext = NULL;
    LocalLinkCB->State = LINK_UP;
    LocalLinkCB->OpenCB = OpenCB;
    LocalLinkCB->OutstandingFrames = 0;
    LocalLinkCB->SendWindowOpen = TRUE;
    LocalLinkCB->SBandwidth = 100;
    LocalLinkCB->RBandwidth = 100;
    LocalLinkCB->SFlowSpec.MaxSduSize = glMaxMTU;
    LocalLinkCB->RFlowSpec.MaxSduSize = glMRRU;

    LocalLinkCB->LinkInfo.HeaderPadding = OpenCB->WanInfo.HeaderPadding;
    LocalLinkCB->LinkInfo.TailPadding = OpenCB->WanInfo.TailPadding;
    LocalLinkCB->LinkInfo.SendACCM =
    LocalLinkCB->LinkInfo.RecvACCM = OpenCB->WanInfo.DesiredACCM;
    LocalLinkCB->LinkInfo.MaxSendFrameSize = glMaxMTU;
    LocalLinkCB->LinkInfo.MaxRecvFrameSize = glMRU;

    if (OpenCB->Flags & OPEN_LEGACY) {
        LocalLinkCB->SendHandler = SendOnLegacyLink;
    } else {
        LocalLinkCB->SendHandler = SendOnLink;
    }

    if (OpenCB->MediumType == NdisMediumAtm ||

        (OpenCB->MediumType == NdisMediumWan &&
        (OpenCB->MediumSubType == NdisWanMediumAtm ||
         OpenCB->MediumSubType == NdisWanMediumPppoe)) ||

        (OpenCB->MediumType == NdisMediumCoWan &&
        (OpenCB->MediumSubType == NdisWanMediumAtm ||
         OpenCB->MediumSubType == NdisWanMediumPppoe))) {

        LocalLinkCB->RecvHandler = DetectBroadbandFraming;

        LocalLinkCB->LinkInfo.SendFramingBits = 
            PPP_FRAMING | PPP_COMPRESS_ADDRESS_CONTROL;

        LocalLinkCB->LinkInfo.RecvFramingBits = 
            PPP_FRAMING | PPP_COMPRESS_ADDRESS_CONTROL;

    } else {

        LocalLinkCB->RecvHandler = DetectFraming;
    }

    LocalLinkCB->SendWindow =
        (SendWindow == 0 || SendWindow > OpenCB->WanInfo.MaxTransmit) ?
        OpenCB->WanInfo.MaxTransmit : SendWindow;

    if (LocalLinkCB->SendWindow == 0) {
        LocalLinkCB->SendWindow = 1;
    }

    if (OpenCB->Flags & OPEN_LEGACY) {
        LocalLinkCB->SendResources = OpenCB->SendResources;
    } else {
        LocalLinkCB->SendResources = 1000;
    }

    NdisAllocateSpinLock(&LocalLinkCB->Lock);

    LocalLinkCB->RefCount = 1;

    REF_OPENCB(OpenCB);

    InterlockedIncrement(&OpenCB->ActiveLinkCount);

    return (LocalLinkCB);
}


VOID
NdisWanFreeLinkCB(
    PLINKCB LinkCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    POPENCB pOpenCB = LinkCB->OpenCB;

    ASSERT(LinkCB->OutstandingFrames == 0);

    LinkCB->State = LINK_DOWN;

    NdisFreeSpinLock(&LocalLinkCB->Lock);

    NdisFreeToNPagedLookasideList(&LinkProtoCBList, LinkCB);

    InterlockedDecrement(&pOpenCB->ActiveLinkCount);

    DEREF_OPENCB(pOpenCB);
}

NDIS_STATUS
NdisWanAllocateSendResources(
    POPENCB OpenCB
    )
/*++

Routine Name:

    NdisWanAllocateSendResources

Routine Description:

    Allocates all resources (SendDescriptors, WanPackets, ...)
    required for sending data.  Should be called at line up time.

Arguments:

    LinkCB - Pointer to the linkcb that the send resources will be attached to.
    SendWindow - Maximum number of sends that this link can handle

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_RESOURCES

--*/
{
    ULONG   SendWindow;
    ULONG   Endpoints;
    ULONG   NumberOfPackets;
    ULONG   BufferSize;
    ULONG   WanPacketSize;
    PNDIS_WAN_PACKET    WanPacket;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    do {

        //
        // We have to have atleast of sendwindow+1 of packets for
        // each link on the open.  In the case of MCML we need
        // this amount for each fragment queue and for the
        // single non-fragment queue. So this leaves  us with...
        //
        //
        // SendWindow + 1 + (glMaxMTU/glMinFragSize * MAX_MCML) *
        // number of links on the open
        //
        SendWindow = OpenCB->WanInfo.MaxTransmit;
        Endpoints = OpenCB->WanInfo.Endpoints;

        //
        // Sendwindow
        //
        NumberOfPackets = SendWindow;

        //
        // We keep track of how many fragmenting resources we have
        // available for each link
        //
        NumberOfPackets += ((glMaxMTU/glMinFragSize) * MAX_MCML);
        OpenCB->SendResources = NumberOfPackets;

        //
        // Add one for compression data manipulation
        //
        NumberOfPackets += 1;

        //
        // multiplied by the # of links on this open
        //
        NumberOfPackets *= Endpoints;

        //
        // The size of the buffer that we create is
        //
        BufferSize = OpenCB->WanInfo.MaxFrameSize +
                     OpenCB->WanInfo.HeaderPadding +
                     OpenCB->WanInfo.TailPadding +
                     40 + sizeof(PVOID);

        //
        // We assume compression is always on so we pad out 12%
        // incase the compressor expands.  I don't know where the
        // 12% figure comes from.
        //
        BufferSize += (OpenCB->WanInfo.MaxFrameSize + 7) / 8;

        //
        // Make sure that the buffer is dword aligned.
        //
        BufferSize &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        OpenCB->BufferSize = BufferSize;

        WanPacketSize = 
            sizeof(DATA_DESC) + sizeof(NDIS_WAN_PACKET) + 
            3*sizeof(PVOID) + BufferSize;

        //
        // If this device needs some special memory flags
        // we need to allocate memory for it's WanPackets now.
        // Otherwise we will intialize a lookaside list and
        // retrieve the packets as needed.

        if (OpenCB->WanInfo.MemoryFlags == 0) {


            NdisInitializeNPagedLookasideList(&OpenCB->WanPacketPool,
                                              AllocateWanPacket,
                                              FreeWanPacket,
                                              0,
                                              WanPacketSize,
                                              WANPACKET_TAG,
                                              0);

        } else {
            ULONG   PacketMemorySize;
            PUCHAR  PacketMemory;
            ULONG   n;

            PacketMemorySize = 
                WanPacketSize * NumberOfPackets;

            //
            // Allocate the memory for the wan packet buffer pool
            //
            NdisAllocateMemory(&PacketMemory,
                               PacketMemorySize,
                               OpenCB->WanInfo.MemoryFlags,
                               OpenCB->WanInfo.HighestAcceptableAddress);

            if (PacketMemory == NULL) {
                NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY, ("Error allocating memory for BufferPool, AllocationSize: %d",
                                 PacketMemorySize));

                Status  = NDIS_STATUS_RESOURCES;
                break;
            }

            OpenCB->PacketMemory = PacketMemory;
            OpenCB->PacketMemorySize = PacketMemorySize;
            NdisInitializeSListHead(&OpenCB->WanPacketList);

            for (n = 0; n < NumberOfPackets; n++) {
                PDATA_DESC  DataDesc;

                //
                // Point to the DataDesc
                //
                DataDesc = 
                    (PDATA_DESC)PacketMemory;

                PacketMemory =
                    ((PUCHAR)(DataDesc + 1) + sizeof(PVOID));

                (ULONG_PTR)PacketMemory &= 
                    ~((ULONG_PTR)sizeof(PVOID) - 1);

                // 
                // Point to the WanPacket
                //
                WanPacket = 
                    (PNDIS_WAN_PACKET)PacketMemory;

                PacketMemory = 
                    ((PUCHAR)(WanPacket + 1) + sizeof(PVOID));

                (ULONG_PTR)PacketMemory &= 
                    ~((ULONG_PTR)sizeof(PVOID) - 1);

                //
                // Point to the begining of the data buffer
                //
                WanPacket->StartBuffer = PacketMemory;
                WanPacket->EndBuffer = 
                    PacketMemory + BufferSize - sizeof(PVOID);

                NdisInterlockedPushEntrySList(&OpenCB->WanPacketList,
                                              (PSINGLE_LIST_ENTRY)DataDesc,
                                              &OpenCB->Lock);

                PacketMemory += BufferSize + sizeof(PVOID);
                (ULONG_PTR)PacketMemory &=
                    ~((ULONG_PTR)sizeof(PVOID) - 1);
            }
        }

    } while ( FALSE );

    if (Status == NDIS_STATUS_SUCCESS) {
        OpenCB->Flags |= SEND_RESOURCES;
    }

    return (Status);
}

VOID
NdisWanFreeSendResources(
    POPENCB OpenCB
    )
/*++

Routine Name:

    NdisWanFreeSendResources

Routine Description:

    This routine removes the WanPackets from this opencb's send list
    and free's the memory allocated for these packets.  Should be called
    when we are cleaningup an opencb.

Arguments:

    OpenCB - Pointer to the opencb that the resources are being freed from.

Return Values:

    None

--*/
{
    PUCHAR              PacketMemory;
    ULONG               PacketMemorySize, Flags;

    PacketMemory = OpenCB->PacketMemory;
    PacketMemorySize = OpenCB->PacketMemorySize;
    Flags = OpenCB->WanInfo.MemoryFlags;

    if (OpenCB->WanInfo.MemoryFlags == 0) {
        NdisDeleteNPagedLookasideList(&OpenCB->WanPacketPool);
        return;
    }

    //
    // Remove the packets from the wan packet pool
    //
    for (; ;) {
        PDATA_DESC  DataDesc;

        DataDesc = (PDATA_DESC)
            NdisInterlockedPopEntrySList(&OpenCB->WanPacketList,
                                         &OpenCB->Lock);

        if (DataDesc == NULL) {
            break;
        }
    }

    ASSERT(NdisQueryDepthSList(&OpenCB->WanPacketList) == 0);

    //
    // Free the block of memory allocated for this send
    //
    if (PacketMemory != NULL) {
        NdisFreeMemory(OpenCB->PacketMemory,
                       OpenCB->PacketMemorySize,
                       OpenCB->Flags);
    }
}

PBUNDLECB
NdisWanAllocateBundleCB(
    VOID
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PBUNDLECB   LocalBundleCB = NULL;
    PWSTR   IOName = L"I/O ProtocolCB";
    PPROTOCOLCB ProtocolCB;
    PSAMPLE_TABLE   SampleTable;
    PBOND_INFO      BonDInfo;
    UINT    Class;
    PUCHAR  pMem;

    //
    // Allocation size is the size of the control block plus the size
    // of a table of pointers to protocolcb's that might be routed to
    // this bundle.
    //
    pMem =
        NdisAllocateFromNPagedLookasideList(&BundleCBList);

    if (pMem == NULL) {
        return (NULL);
    }

    NdisZeroMemory(pMem, BUNDLECB_SIZE);

    LocalBundleCB = (PBUNDLECB)pMem;

    pMem += sizeof(BUNDLECB) + sizeof(PVOID);

    //
    // This is the memory used for the I/O protocolcb
    //
    (PUCHAR)ProtocolCB = pMem;
    (ULONG_PTR)ProtocolCB &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    pMem += sizeof(PROTOCOLCB) + sizeof(PVOID);

    //
    // This is the protocolcb table
    //
    (PUCHAR)LocalBundleCB->ProtocolCBTable = pMem;

    (ULONG_PTR)LocalBundleCB->ProtocolCBTable &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pMem += (MAX_PROTOCOLS * sizeof(PPROTOCOLCB)) + sizeof(PVOID);

    //
    // Initialize the BundleCB
    //
    NdisAllocateSpinLock(&LocalBundleCB->Lock);
    InitializeListHead(&LocalBundleCB->LinkCBList);

    for (Class = 0; Class < MAX_MCML; Class++) {
        PRECV_DESC  RecvDescHole;
        PSEND_FRAG_INFO FragInfo;
        PBUNDLE_RECV_INFO   RecvInfo;

        FragInfo = &LocalBundleCB->SendFragInfo[Class];
        RecvInfo = &LocalBundleCB->RecvInfo[Class];

        InitializeListHead(&FragInfo->FragQueue);
        FragInfo->MinFragSize = glMinFragSize;
        FragInfo->MaxFragSize = glMaxFragSize;

        InitializeListHead(&RecvInfo->AssemblyList);

        //
        // Init the recv hole desc
        //
        RecvDescHole =
            NdisWanAllocateRecvDesc(0);
    
        if (RecvDescHole == NULL) {
            UINT    i;

            for (i = 0; i < MAX_MCML; i++) {
                RecvInfo = &LocalBundleCB->RecvInfo[i];

                if (RecvInfo->RecvDescHole != NULL) {
                    NdisWanFreeRecvDesc(RecvInfo->RecvDescHole);
                    
                }
            }

            NdisFreeToNPagedLookasideList(&BundleCBList, LocalBundleCB);

            return (NULL);
        }
    
        RecvDescHole->Flags = MULTILINK_HOLE_FLAG;

        RecvInfo->RecvDescHole = RecvDescHole;
        InsertHeadList(&RecvInfo->AssemblyList, &RecvDescHole->Linkage);
        RecvInfo->AssemblyCount++;
    }

    InitializeListHead(&LocalBundleCB->ProtocolCBList);
    NdisWanInitializeSyncEvent(&LocalBundleCB->OutstandingFramesEvent);
    LocalBundleCB->State = BUNDLE_UP;
    LocalBundleCB->FramingInfo.MaxRSendFrameSize = glMaxMTU;
    LocalBundleCB->FramingInfo.MaxRRecvFrameSize = glMRRU;
    LocalBundleCB->SFlowSpec.MaxSduSize = glMaxMTU;
    LocalBundleCB->RFlowSpec.MaxSduSize = glMRRU;
    NdisWanGetSystemTime(&LocalBundleCB->LastNonIdleData);
    LocalBundleCB->SendCompInfo.CompType =
    LocalBundleCB->RecvCompInfo.CompType = COMPTYPE_NONE;

    //
    // Add the protocolcb to the bundle's table and list
    //
    ProtocolCB->ProtocolType = PROTOCOL_PRIVATE_IO;
    ProtocolCB->PPPProtocolID = PPP_PROTOCOL_PRIVATE_IO;
    ProtocolCB->BundleCB = LocalBundleCB;
    ProtocolCB->State = PROTOCOL_ROUTED;
    NdisWanStringToNdisString(&ProtocolCB->InDeviceName, IOName);
    LocalBundleCB->IoProtocolCB = ProtocolCB;

    return (LocalBundleCB);
}

VOID
NdisWanFreeBundleCB(
    IN  PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    UINT            Class;
    PPROTOCOLCB     IoProtocolCB;
    PPACKET_QUEUE   PacketQueue;

    FlushAssemblyLists(BundleCB);

    if (BundleCB->Flags & BOND_ENABLED) {
        RemoveEntryGlobalList(BonDWorkList, &BundleCB->BonDLinkage);
    }

    //
    // Free the hole place holders
    //
    for (Class = 0; Class < MAX_MCML; Class++) {
        PBUNDLE_RECV_INFO   RecvInfo =
            &BundleCB->RecvInfo[Class];

        ASSERT(RecvInfo->RecvDescHole != NULL);
        
        NdisWanFreeRecvDesc(RecvInfo->RecvDescHole);
        RecvInfo->RecvDescHole = NULL;
    }

#if 0
    KeCancelTimer(&BundleCB->BonDTimer);
#endif

    IoProtocolCB = BundleCB->IoProtocolCB;
    PacketQueue = &IoProtocolCB->PacketQueue[MAX_MCML];

    ASSERT(IsPacketQueueEmpty(PacketQueue));

    //
    // If we have ppp packets queued we need
    // to flush them and free the memory!
    //
    while (!IsPacketQueueEmpty(PacketQueue)) {
        PNDIS_PACKET     Packet;

        Packet =
            RemoveHeadPacketQueue(PacketQueue)

        CompleteNdisPacket(IoProtocolCB->MiniportCB,
                           IoProtocolCB,
                           Packet);
    }

    sl_compress_terminate(&BundleCB->VJCompress);

    if (BundleCB->Flags & SEND_CCP_ALLOCATED) {

        WanDeallocateCCP(BundleCB,
                         &BundleCB->SendCompInfo,
                         TRUE);
        BundleCB->Flags &= ~SEND_CCP_ALLOCATED;
    }

    if (BundleCB->Flags & RECV_CCP_ALLOCATED) {
        WanDeallocateCCP(BundleCB,
                         &BundleCB->RecvCompInfo,
                         FALSE);
        BundleCB->Flags &= ~RECV_CCP_ALLOCATED;
    }

    if (BundleCB->Flags & SEND_ECP_ALLOCATED) {
        WanDeallocateECP(BundleCB,
                         &BundleCB->SendCompInfo,
                         &BundleCB->SendCryptoInfo);
        BundleCB->Flags &= ~SEND_ECP_ALLOCATED;
    }

    if (BundleCB->Flags & RECV_ECP_ALLOCATED) {
        WanDeallocateECP(BundleCB,
                         &BundleCB->RecvCompInfo,
                         &BundleCB->RecvCryptoInfo);
        BundleCB->Flags &= ~RECV_ECP_ALLOCATED;
    }

    if (BundleCB->BonDAllocation != NULL) {
        NdisWanFreeMemory(BundleCB->BonDAllocation);
        BundleCB->BonDAllocation = NULL;
    }

    BundleCB->State = BUNDLE_DOWN;

    NdisFreeSpinLock(&BundleCB->Lock);

    NdisWanFreeNdisString(&BundleCB->IoProtocolCB->InDeviceName);

    NdisFreeToNPagedLookasideList(&BundleCBList, BundleCB);
}


NDIS_STATUS
NdisWanCreateProtocolInfoTable(
    VOID
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG       ulAllocationSize = 0;
    PUCHAR      AllocatedMemory;
    PROTOCOL_INFO   ProtocolInfo;

    //
    // Allocate ProtocolLookupTable.  This table is used to match protocol values
    // with their corresponding PPP Protocol values.  The table size is set to
    // MAX_PROTOCOLS.
    //
    ulAllocationSize = sizeof(PROTOCOL_INFO_TABLE) +
                     (sizeof(PROTOCOL_INFO) * MAX_PROTOCOLS);
    

    NdisWanAllocateMemory(&AllocatedMemory, ulAllocationSize, PROTOCOLTABLE_TAG);

    if (AllocatedMemory == NULL) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY,
               ("Failed allocating memory for ProtocolLookupTable! TableSize: %d",
               ulAllocationSize));

        return (NDIS_STATUS_RESOURCES);     
    }

    ProtocolInfoTable = (PPROTOCOL_INFO_TABLE)AllocatedMemory;

    //
    // Save the allocation size
    //
    ProtocolInfoTable->ulAllocationSize = ulAllocationSize;

    //
    // Store the array size.  This should be read from the registry
    //
    ProtocolInfoTable->ulArraySize = MAX_PROTOCOLS;

    NdisAllocateSpinLock(&ProtocolInfoTable->Lock);

    //
    // Setup the pointer to the ProtocolValue array
    //
    AllocatedMemory += sizeof(PROTOCOL_INFO_TABLE);
    ProtocolInfoTable->ProtocolInfo = (PPROTOCOL_INFO)(AllocatedMemory);

    //
    // Insert default values for Netbuei, IP, IPX
    //
    ProtocolInfo.ProtocolType = PROTOCOL_PRIVATE_IO;
    ProtocolInfo.PPPId = PPP_PROTOCOL_PRIVATE_IO;
    ProtocolInfo.MTU = DEFAULT_MTU;
    ProtocolInfo.TunnelMTU = DEFAULT_MTU;
    ProtocolInfo.PacketQueueDepth = DEFAULT_PACKETQUEUE_DEPTH;
    ProtocolInfo.Flags = PROTOCOL_UNBOUND;
    SetProtocolInfo(&ProtocolInfo);

    ProtocolInfo.ProtocolType = PROTOCOL_IP;
    ProtocolInfo.PPPId = PPP_PROTOCOL_IP;
    ProtocolInfo.MTU = DEFAULT_MTU;
    ProtocolInfo.TunnelMTU = DEFAULT_TUNNEL_MTU;
    ProtocolInfo.PacketQueueDepth = DEFAULT_PACKETQUEUE_DEPTH;
    ProtocolInfo.Flags = PROTOCOL_UNBOUND;
    SetProtocolInfo(&ProtocolInfo);

    ProtocolInfo.ProtocolType = PROTOCOL_IPX;
    ProtocolInfo.PPPId = PPP_PROTOCOL_IPX;
    ProtocolInfo.MTU = DEFAULT_MTU;
    ProtocolInfo.TunnelMTU = DEFAULT_MTU;
    ProtocolInfo.PacketQueueDepth = DEFAULT_PACKETQUEUE_DEPTH;
    ProtocolInfo.Flags = PROTOCOL_UNBOUND;
    SetProtocolInfo(&ProtocolInfo);

    ProtocolInfo.ProtocolType = PROTOCOL_NBF;
    ProtocolInfo.PPPId = PPP_PROTOCOL_NBF;
    ProtocolInfo.MTU = DEFAULT_MTU;
    ProtocolInfo.TunnelMTU = DEFAULT_MTU;
    ProtocolInfo.PacketQueueDepth = DEFAULT_PACKETQUEUE_DEPTH;
    ProtocolInfo.Flags = PROTOCOL_UNBOUND;
    SetProtocolInfo(&ProtocolInfo);

    ProtocolInfo.ProtocolType = PROTOCOL_APPLETALK;
    ProtocolInfo.PPPId = PPP_PROTOCOL_APPLETALK;
    ProtocolInfo.MTU = DEFAULT_MTU;
    ProtocolInfo.TunnelMTU = DEFAULT_MTU;
    ProtocolInfo.PacketQueueDepth = DEFAULT_PACKETQUEUE_DEPTH;
    ProtocolInfo.Flags = PROTOCOL_UNBOUND;
    SetProtocolInfo(&ProtocolInfo);

    return (Status);

}

VOID
NdisWanDestroyProtocolInfoTable(
    VOID
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NdisFreeSpinLock(&ProtocolInfoTable->Lock);

    NdisWanFreeMemory(ProtocolInfoTable);
}

NDIS_STATUS
NdisWanCreateConnectionTable(
    ULONG   TableSize
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       ulAllocationSize = 0;
    ULONG       ulArraySize;
    PUCHAR      AllocatedMemory;
    PCONNECTION_TABLE   NewTable;

    //
    // Since we skip the first place in the tables we increase the
    // size by one.
    //
    ulArraySize = TableSize + 1;

    //
    // Allocate the Bundle and Link Arrays based on the number of possible connections
    // that we have in the system.  This should be grown if we get called
    // to reinitialize and gain new ports.
    //
    ulAllocationSize = sizeof(CONNECTION_TABLE) +
                     (sizeof(PBUNDLECB) * ulArraySize) +
                     (sizeof(PLINKCB) * ulArraySize);

    NdisWanAllocateMemory(&AllocatedMemory, ulAllocationSize, CONNECTIONTABLE_TAG);

    if (AllocatedMemory == NULL) {

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY,
               ("Failed allocating memory for ConnectionTable! Size: %d, Links: %d",
               ulAllocationSize, TableSize));

        return (NDIS_STATUS_RESOURCES);
    }

    NewTable = (PCONNECTION_TABLE)AllocatedMemory;

    //
    // This is the amount of memory we allocated
    //
    NewTable->ulAllocationSize = ulAllocationSize;
    NewTable->ulArraySize = TableSize;
    NewTable->ulNextLink =
    NewTable->ulNextBundle = 1;
    InitializeListHead(&NewTable->BundleList);
    InitializeListHead(&NewTable->LinkList);

    //
    // Setup pointer to the linkcb array
    //
    AllocatedMemory += sizeof(CONNECTION_TABLE);
    NewTable->LinkArray = (PLINKCB*)(AllocatedMemory);
    
    //
    // Setup the pointer to the bundlecb array
    //
    AllocatedMemory += (sizeof(PLINKCB) * ulArraySize);
    NewTable->BundleArray = (PBUNDLECB*)(AllocatedMemory);

    if (ConnectionTable != NULL) {
        PCONNECTION_TABLE   FreeTable;

        //
        // We must be growing the table.  This will be
        // called with the current connectiontable lock
        // held!
        //
        NewTable->ulNumActiveLinks = ConnectionTable->ulNumActiveLinks;
        NewTable->ulNumActiveBundles = ConnectionTable->ulNumActiveBundles;
        NewTable->ulNextLink = ConnectionTable->ulNextLink;
        NewTable->ulNextBundle = ConnectionTable->ulNextBundle;

        NdisMoveMemory((PUCHAR)NewTable->LinkArray,
                       (PUCHAR)ConnectionTable->LinkArray,
                       ConnectionTable->ulArraySize * sizeof(PLINKCB));

        NdisMoveMemory((PUCHAR)NewTable->BundleArray,
                       (PUCHAR)ConnectionTable->BundleArray,
                       ConnectionTable->ulArraySize * sizeof(PBUNDLECB));

        while (!IsListEmpty(&ConnectionTable->BundleList)) {
            PBUNDLECB   BundleCB;

            BundleCB = (PBUNDLECB)RemoveHeadList(&ConnectionTable->BundleList);
            InsertTailList(&NewTable->BundleList, &BundleCB->Linkage);
        }

        while (!IsListEmpty(&ConnectionTable->LinkList)) {
            PLIST_ENTRY Entry;
            PLINKCB     LinkCB;

            Entry = RemoveHeadList(&ConnectionTable->LinkList);
            LinkCB = 
                (PLINKCB)CONTAINING_RECORD(Entry, LINKCB, ConnTableLinkage);
            InsertTailList(&NewTable->LinkList, &LinkCB->ConnTableLinkage);

        }

        FreeTable = ConnectionTable;
        ConnectionTable = NewTable;

        //
        // Destroy the old table
        //
        NdisWanFreeMemory(FreeTable);


    } else {
        ConnectionTable = NewTable;
    }

    return (NDIS_STATUS_SUCCESS);
}

PNDIS_PACKET
NdisWanAllocateNdisPacket(
    ULONG   MagicNumber
    )
{
    PNDIS_PACKET    ReturnPacket = NULL;
    PPOOL_DESC      PoolDesc;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    ULONG           i;
    PSINGLE_LIST_ENTRY  p = NULL;
    PNDISWAN_PROTOCOL_RESERVED  pres;

    NdisAcquireSpinLock(&PacketPoolList.Lock);

    //
    // Walk the pool desc list and try to allocate a packet
    //
    PoolDesc = (PPOOL_DESC)PacketPoolList.List.Flink;

    while (PoolDesc != (PPOOL_DESC)&PacketPoolList.List) {

        p = PopEntryList(&PoolDesc->Head);

        if (p != NULL) {
            break;
        }
        
        PoolDesc = (PPOOL_DESC)PoolDesc->Linkage.Flink;
    }

    if (p == NULL) {
        //
        // We have walked the pool list and did not find any
        // free packets on any of the free pools, so allocate
        // a new pool and get a packet from it.
        //
        NdisWanAllocatePriorityMemory(&PoolDesc, 
                                      sizeof(POOL_DESC), 
                                      POOLDESC_TAG,
                                      NormalPoolPriority);

        if (PoolDesc == NULL) {
            NdisReleaseSpinLock(&PacketPoolList.Lock);
            return (NULL);
        }

        NdisAllocatePacketPoolEx(&Status,
                                 &PoolDesc->PoolHandle,
                                 glPacketPoolCount,
                                 0,
                                 sizeof(NDISWAN_PROTOCOL_RESERVED));

        if (Status != NDIS_STATUS_SUCCESS) {
            NdisWanFreeMemory(PoolDesc);
            NdisReleaseSpinLock(&PacketPoolList.Lock);
            return (NULL);
        }

        for (i = 0; i < glPacketPoolCount; i++) {
            PNDIS_PACKET    np;

            NdisAllocatePacket(&Status,
                               &np,
                               PoolDesc->PoolHandle);

            ASSERT(np != NULL);

            pres = PPROTOCOL_RESERVED_FROM_NDIS(np);

            PushEntryList(&PoolDesc->Head, &pres->SLink);

            PoolDesc->FreeCount++;
        }

        InsertTailList(&PacketPoolList.List, &PoolDesc->Linkage);

        PacketPoolList.TotalDescCount++;
        PacketPoolList.FreeCount += PoolDesc->FreeCount;

        if (PacketPoolList.TotalDescCount >
            PacketPoolList.MaxDescCount) {
            
            PacketPoolList.MaxDescCount = PacketPoolList.TotalDescCount;
        }

        p = PopEntryList(&PoolDesc->Head);
    }

    ASSERT(p != NULL);

    pres = CONTAINING_RECORD(p, NDISWAN_PROTOCOL_RESERVED, SLink);
    ReturnPacket = CONTAINING_RECORD(pres, NDIS_PACKET, ProtocolReserved);

    NdisReinitializePacket(ReturnPacket);

    PoolDesc->AllocatedCount++;
    PoolDesc->FreeCount--;
    ASSERT((PoolDesc->AllocatedCount + PoolDesc->FreeCount) == glPacketPoolCount);

    if (PoolDesc->AllocatedCount >
        PoolDesc->MaxAllocatedCount) {

        PoolDesc->MaxAllocatedCount =
            PoolDesc->AllocatedCount;
    }

    PacketPoolList.AllocatedCount++;
    PacketPoolList.FreeCount--;

#if DBG
{
    PPOOL_DESC  pdesc;
    ULONG       FreeCount, AllocatedCount;

    pdesc = (PPOOL_DESC)PacketPoolList.List.Flink;

    FreeCount = AllocatedCount = 0;

    while ((PVOID)pdesc != (PVOID)&PacketPoolList.List) {
        FreeCount += pdesc->FreeCount;
        AllocatedCount += pdesc->AllocatedCount;
        pdesc = (PPOOL_DESC)pdesc->Linkage.Flink;
    }

    if (PacketPoolList.AllocatedCount != AllocatedCount ||
        PacketPoolList.FreeCount != FreeCount){
        DbgPrint("NDISWAN: AllocatePacket - PacketPool counts out of sync!\n");
        DbgBreakPoint();
    }

#if 0
    if (PacketPoolList.AllocatedCount > 200) {
        DbgPrint("NDISWAN: AllocatePacket - Over 200 outstanding packets!\n");
        DbgBreakPoint();
    }
#endif

}
#endif

    if (PacketPoolList.AllocatedCount >
        PacketPoolList.MaxAllocatedCount) {

        PacketPoolList.MaxAllocatedCount =
            PacketPoolList.AllocatedCount;
    }
    
    pres->MagicNumber = MagicNumber;
    pres->PoolDesc = PoolDesc;

    NDIS_SET_PACKET_HEADER_SIZE(ReturnPacket, 
                                MAC_HEADER_LENGTH);

    NDIS_SET_PACKET_STATUS(ReturnPacket, 
                           NDIS_STATUS_SUCCESS);

    NdisReleaseSpinLock(&PacketPoolList.Lock);

    return (ReturnPacket);
}

VOID
NdisWanFreeNdisPacket(
    PNDIS_PACKET    NdisPacket
    )
{
    PNDISWAN_PROTOCOL_RESERVED  pres;
    PPOOL_DESC      PoolDesc;
    PNDIS_BUFFER    NdisBuffer;
    PUCHAR          DataBuffer;

    pres = PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket);

    ASSERT(pres->MagicNumber == MAGIC_INTERNAL_ALLOC ||
           pres->MagicNumber == MAGIC_INTERNAL_IO ||
           pres->MagicNumber == MAGIC_INTERNAL_SEND ||
           pres->MagicNumber == MAGIC_INTERNAL_RECV ||
           pres->MagicNumber == MAGIC_INTERNAL_ALLOC);

    PoolDesc = pres->PoolDesc;

    NdisAcquireSpinLock(&PacketPoolList.Lock);

#if DBG
{
    PPOOL_DESC  pdesc;

    pdesc = (PPOOL_DESC)PacketPoolList.List.Flink;

    while ((PVOID)pdesc != (PVOID)&PacketPoolList.List) {

        if (PoolDesc == pdesc) {
            //
            // We found the correct pool
            //
            break;
        }

        pdesc = (PPOOL_DESC)pdesc->Linkage.Flink;
    }

    if((PVOID)PoolDesc == (PVOID)&PacketPoolList.List){
        DbgPrint("NDISWAN: FreePacket PoolDesc %x not on PacketPoolList!\n",
                 PoolDesc);
        DbgBreakPoint();
    }
}
#endif

    PushEntryList(&PoolDesc->Head, &pres->SLink);

    PoolDesc->AllocatedCount--;
    PoolDesc->FreeCount++;

    ASSERT((PoolDesc->AllocatedCount + PoolDesc->FreeCount) == glPacketPoolCount);

    PacketPoolList.AllocatedCount--;
    PacketPoolList.FreeCount++;

#if DBG
{
    PPOOL_DESC  pdesc;
    ULONG       FreeCount, AllocatedCount;

    pdesc = (PPOOL_DESC)PacketPoolList.List.Flink;

    FreeCount = AllocatedCount = 0;

    while ((PVOID)pdesc != (PVOID)&PacketPoolList.List) {
        FreeCount += pdesc->FreeCount;
        AllocatedCount += pdesc->AllocatedCount;


        pdesc = (PPOOL_DESC)pdesc->Linkage.Flink;
    }

    if (PacketPoolList.AllocatedCount != AllocatedCount ||
        PacketPoolList.FreeCount != FreeCount){
        DbgPrint("NDISWAN: FreePacket - PacketPool counts out of sync!\n");
        DbgBreakPoint();
    }
}
#endif

    //
    // If all of the packets have been returned to this pool desc
    // and this is not the only pool desc then free it!
    //
    if (PoolDesc->AllocatedCount == 0 &&
        PacketPoolList.TotalDescCount > 1 &&
        PacketPoolList.FreeCount > PoolDesc->FreeCount) {
        PSINGLE_LIST_ENTRY  p = NULL;

        RemoveEntryList(&PoolDesc->Linkage);

        PacketPoolList.TotalDescCount--;
        PacketPoolList.FreeCount -= PoolDesc->FreeCount;

        p = PopEntryList(&PoolDesc->Head);

        while (p != NULL) {
            PNDIS_PACKET    ReturnPacket;

            pres = CONTAINING_RECORD(p, NDISWAN_PROTOCOL_RESERVED, SLink);
            ReturnPacket = CONTAINING_RECORD(pres, NDIS_PACKET, ProtocolReserved);

            NdisFreePacket(ReturnPacket);

            p = PopEntryList(&PoolDesc->Head);
        }

        NdisFreePacketPool(PoolDesc->PoolHandle);
        NdisWanFreeMemory(PoolDesc);
    }

    NdisReleaseSpinLock(&PacketPoolList.Lock);
}

PVOID
AllocateDataDesc(
    POOL_TYPE   PoolType,
    SIZE_T      NumberOfBytes,
    ULONG       Tag
    )
/*++

Routine Name:

    AllocateDataDesc

Routine Description:

    This routine is called by the lookasidelist manager if there are not
    any descriptors available.  It will allocated memory for: DATA_DESC,
    NDIS_BUFFER, NDIS_PACKET, and a block of memory of size.
    
Arguments:

Return Values:

--*/
{
    PDATA_DESC      DataDesc;
    PUCHAR          DataBuffer;
    NDIS_STATUS     Status;

    NdisWanAllocatePriorityMemory(&DataDesc, 
                                  NumberOfBytes, 
                                  Tag,
                                  NormalPoolPriority);

    if (DataDesc == NULL) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY,
                      ("AllocateDataDesc failed! Size %d",
                      NumberOfBytes));
        return (NULL);
    }

    DataBuffer = 
        ((PUCHAR)(DataDesc + 1) + sizeof(PVOID));
    (ULONG_PTR)DataBuffer &= 
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    DataDesc->DataBuffer = DataBuffer;

    DataDesc->DataBufferLength = 
        (ULONG)(((PUCHAR)DataDesc + NumberOfBytes) - DataBuffer);

    // This is not portable to Win95!  I need to allocate a buffer
    // pool and use a valid handle.
    //
    NdisAllocateBuffer(&Status, 
                       &DataDesc->NdisBuffer, 
                       NULL,
                       DataDesc->DataBuffer,
                       DataDesc->DataBufferLength);

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisWanFreeMemory(DataDesc);

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY,
                      ("NdisAllocateBuffer failed! DataBufferSize %d",
                      DataDesc->DataBufferLength));
        return (NULL);
    }

    DataDesc->NdisPacket =
        NdisWanAllocateNdisPacket(MAGIC_INTERNAL_ALLOC);

    if (DataDesc->NdisPacket == NULL) {

        NdisFreeBuffer(DataDesc->NdisBuffer);

        NdisWanFreeMemory(DataDesc);

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY,
                      ("NdisWanAllocateNdisPacket failed! DataBufferSize %d"));

        return (NULL);
    }

    NdisChainBufferAtFront(DataDesc->NdisPacket,
                           DataDesc->NdisBuffer);

    return(DataDesc);
}

VOID
FreeDataDesc(
    PVOID   Buffer
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PDATA_DESC      DataDesc;

    DataDesc = (PDATA_DESC)Buffer;

    NdisReinitializePacket(DataDesc->NdisPacket);

    NdisWanFreeNdisPacket(DataDesc->NdisPacket);

    NdisFreeBuffer(DataDesc->NdisBuffer);

    NdisWanFreeMemory(Buffer);
}

PRECV_DESC
NdisWanAllocateRecvDesc(
    ULONG   SizeNeeded
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PDATA_DESC  DataDesc;
    PRECV_DESC  RecvDesc;
    ULONG       Length;
    PNPAGED_LOOKASIDE_LIST  LookasideList;

    if (SizeNeeded > glLargeDataBufferSize) {
        DbgPrint("NDISWAN: Error Allocating RecvDesc Size %d\n",
                 SizeNeeded);
        return (NULL);
    } else if (SizeNeeded > glSmallDataBufferSize) {
        LookasideList = &LargeDataDescList;
    } else {
        LookasideList = &SmallDataDescList;
    }

    DataDesc =
        NdisAllocateFromNPagedLookasideList(LookasideList);

    if (DataDesc == NULL) {
        return (NULL);
    }

    PPROTOCOL_RESERVED_FROM_NDIS(DataDesc->NdisPacket)->MagicNumber =
        MAGIC_INTERNAL_RECV;

    DataDesc->LookasideList = LookasideList;
    RecvDesc = &DataDesc->RecvDesc;

    NdisZeroMemory(RecvDesc, sizeof(RECV_DESC));

    RecvDesc->Signature = RECVDESC_SIG;
    RecvDesc->DataBuffer =
        DataDesc->DataBuffer;
    RecvDesc->NdisBuffer =
        DataDesc->NdisBuffer;
    RecvDesc->NdisPacket =
        DataDesc->NdisPacket;

    NdisQueryBuffer(RecvDesc->NdisBuffer,
                    &RecvDesc->StartBuffer,
                    &Length);

    RecvDesc->CurrentBuffer = 
        RecvDesc->StartBuffer + MAC_HEADER_LENGTH + PROTOCOL_HEADER_LENGTH;

    return (RecvDesc);
}

VOID
NdisWanFreeRecvDesc(
    PRECV_DESC  RecvDesc
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PDATA_DESC      DataDesc;
    PNDIS_BUFFER    NdisBuffer;
    PNDIS_PACKET    NdisPacket;
    PNPAGED_LOOKASIDE_LIST  LookasideList;

    if (RecvDesc->OriginalPacket != NULL) {

        NdisReturnPackets(&RecvDesc->OriginalPacket, 1);
        RecvDesc->OriginalPacket = NULL;
    }

    DataDesc = 
        CONTAINING_RECORD(RecvDesc, DATA_DESC, RecvDesc);

    NdisBuffer = 
        DataDesc->NdisBuffer;

    NdisPacket =
        DataDesc->NdisPacket;

    LookasideList = 
        DataDesc->LookasideList;

#if DBG
    {
    ULONG           BufferCount;

    NdisQueryPacket(NdisPacket,
                    NULL,
                    &BufferCount,
                    NULL,
                    NULL);

    ASSERT(BufferCount == 1);
    }
#endif

    NdisAdjustBufferLength(NdisBuffer, 
                           DataDesc->DataBufferLength);

    NdisRecalculatePacketCounts(NdisPacket);

    NDIS_SET_PACKET_HEADER_SIZE(NdisPacket, 
                                MAC_HEADER_LENGTH);

    NDIS_SET_PACKET_STATUS(NdisPacket, 
                           NDIS_STATUS_SUCCESS);

    ASSERT(PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->MagicNumber == MAGIC_INTERNAL_RECV);

    NdisFreeToNPagedLookasideList(LookasideList, DataDesc);
}

PSEND_DESC
NdisWanAllocateSendDesc(
    PLINKCB LinkCB,
    ULONG   SizeNeeded
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    POPENCB     OpenCB;
    PSEND_DESC  SendDesc;

    //
    // Need to determine if this link represents a legacy
    // wan miniport or a NDIS 5.0 miniport and get the
    // appropriate buffer descriptor.
    //
    OpenCB = LinkCB->OpenCB;

    if (OpenCB->Flags & OPEN_LEGACY) {
        PDATA_DESC          DataDesc;
        PNDIS_WAN_PACKET    WanPacket;

        //
        // Get a buffer desriptor off of the open block
        //
        if (OpenCB->WanInfo.MemoryFlags == 0) {
            PNPAGED_LOOKASIDE_LIST  LookasideList;

            LookasideList = &OpenCB->WanPacketPool;
    
            DataDesc = 
                NdisAllocateFromNPagedLookasideList(LookasideList);

            if (DataDesc == NULL) {
                return(NULL);
            }

            DataDesc->LookasideList = LookasideList;

            WanPacket = (PNDIS_WAN_PACKET)
                ((PUCHAR)(DataDesc + 1) + sizeof(PVOID));

            (ULONG_PTR)WanPacket &=
                ~((ULONG_PTR)sizeof(PVOID) - 1);

            //
            // Point to the begining of the data.
            //
            WanPacket->StartBuffer = 
                ((PUCHAR)(WanPacket + 1) + sizeof(PVOID));

            (ULONG_PTR)WanPacket->StartBuffer &=
                ~((ULONG_PTR)sizeof(PVOID) - 1);

            WanPacket->EndBuffer = WanPacket->StartBuffer +
                                   OpenCB->BufferSize - sizeof(PVOID);
    
        } else {
            DataDesc = (PDATA_DESC)
                NdisInterlockedPopEntrySList(&OpenCB->WanPacketList,
                                             &OpenCB->Lock);
    
            if (DataDesc == NULL) {
                return (NULL);
            }
        }

        SendDesc = &DataDesc->SendDesc;
        NdisZeroMemory(SendDesc, sizeof(SEND_DESC));

        SendDesc->Signature = SENDESC_SIG;
        SendDesc->LinkCB = LinkCB;
        SendDesc->WanPacket = WanPacket;

        WanPacket->CurrentBuffer =
            WanPacket->StartBuffer + OpenCB->WanInfo.HeaderPadding;

        SendDesc->StartBuffer =
            WanPacket->CurrentBuffer;


    } else {
        PDATA_DESC  DataDesc;
        ULONG       Length;
        PNPAGED_LOOKASIDE_LIST  LookasideList;

        if (SizeNeeded > glLargeDataBufferSize) {
            DbgPrint("NDISWAN: Error Allocating SendDesc Size %d\n",
                     SizeNeeded);
            return (NULL);
        } else if (SizeNeeded > glSmallDataBufferSize) {
            LookasideList = &LargeDataDescList;
        } else {
            LookasideList = &SmallDataDescList;
        }

        DataDesc =
            NdisAllocateFromNPagedLookasideList(LookasideList);

        if (DataDesc == NULL) {
            return (NULL);
        }

        DataDesc->LookasideList = LookasideList;

        PPROTOCOL_RESERVED_FROM_NDIS(DataDesc->NdisPacket)->MagicNumber =
            MAGIC_INTERNAL_SEND;

        SendDesc = &DataDesc->SendDesc;
        NdisZeroMemory(SendDesc, sizeof(SEND_DESC));

        SendDesc->Signature = SENDESC_SIG;
        SendDesc->LinkCB = LinkCB;
        SendDesc->NdisPacket =
            DataDesc->NdisPacket;
        SendDesc->NdisBuffer =
            DataDesc->NdisBuffer;

        NdisQueryBuffer(SendDesc->NdisBuffer,
                        &SendDesc->StartBuffer,
                        &Length);
    }

    LinkCB->SendResources -= 1;
    LinkCB->BundleCB->SendResources -= 1;

    return (SendDesc);
}

VOID
NdisWanFreeSendDesc(
    PSEND_DESC  SendDesc
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    POPENCB     OpenCB;
    PDATA_DESC  DataDesc;
    PLINKCB     LinkCB;
    PNPAGED_LOOKASIDE_LIST  LookasideList;

    LinkCB =
        SendDesc->LinkCB;

    OpenCB = LinkCB->OpenCB;

    DataDesc = 
        CONTAINING_RECORD(SendDesc, DATA_DESC, SendDesc);

    LookasideList = DataDesc->LookasideList;

    if (OpenCB->Flags & OPEN_LEGACY) {

        if (OpenCB->WanInfo.MemoryFlags == 0) {

            NdisFreeToNPagedLookasideList(LookasideList, DataDesc);

        } else {

            NdisInterlockedPushEntrySList(&OpenCB->WanPacketList,
                                          (PSINGLE_LIST_ENTRY)DataDesc,
                                          &OpenCB->Lock);
        }

    } else {
        PNDIS_BUFFER    NdisBuffer;
        PNDIS_PACKET    NdisPacket;

        NdisBuffer = 
            DataDesc->NdisBuffer;

        NdisPacket =
            DataDesc->NdisPacket;

#if DBG
        {
        ULONG           BufferCount;

        NdisQueryPacket(NdisPacket,
                        NULL,
                        &BufferCount,
                        NULL,
                        NULL);

        ASSERT(BufferCount == 1);
        }
#endif

        NdisAdjustBufferLength(NdisBuffer,
                               DataDesc->DataBufferLength);

        NdisRecalculatePacketCounts(NdisPacket);

        NDIS_SET_PACKET_HEADER_SIZE(NdisPacket, 
                                    MAC_HEADER_LENGTH);

        NDIS_SET_PACKET_STATUS(NdisPacket, 
                               NDIS_STATUS_SUCCESS);

        ASSERT(PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->MagicNumber == MAGIC_INTERNAL_SEND);

        NdisFreeToNPagedLookasideList(LookasideList, DataDesc);
    }

    LinkCB->SendResources += 1;
    LinkCB->BundleCB->SendResources += 1;
}

PCL_AFSAPCB
NdisWanAllocateClAfSapCB(
    POPENCB             OpenCB,
    PCO_ADDRESS_FAMILY  AddressFamily
    )
{
    PCL_AFSAPCB AfSapCB;

    AfSapCB =
        NdisAllocateFromNPagedLookasideList(&AfSapVcCBList);

    if (AfSapCB == NULL) {
        return (NULL);
    }

    NdisZeroMemory(AfSapCB, sizeof(CL_AFSAPCB));

    AfSapCB->Signature = CLAFSAP_SIG;
    AfSapCB->OpenCB = OpenCB;

    AfSapCB->Af.AddressFamily = AddressFamily->AddressFamily;
    AfSapCB->Af.MajorVersion = AddressFamily->MajorVersion;
    AfSapCB->Af.MinorVersion = AddressFamily->MinorVersion;

    AfSapCB->RefCount = 1;
    AfSapCB->Flags = AF_OPENING;

    return (AfSapCB);
}

VOID
NdisWanFreeClAfSapCB(
    PCL_AFSAPCB AfSapCB
    )
{
    NdisFreeToNPagedLookasideList(&AfSapVcCBList,
                                  AfSapCB);
}

PCM_AFSAPCB
NdisWanAllocateCmAfSapCB(
    PMINIPORTCB MiniportCB
    )
{
    PCM_AFSAPCB AfSapCB;

    AfSapCB =
    NdisAllocateFromNPagedLookasideList(&AfSapVcCBList);

    if (AfSapCB == NULL) {
        return (NULL);
    }

    NdisZeroMemory(AfSapCB, sizeof(CM_AFSAPCB));

    AfSapCB->Signature = CMAFSAP_SIG;
    AfSapCB->MiniportCB = MiniportCB;

    REF_MINIPORTCB(MiniportCB);

    NdisAcquireSpinLock(&MiniportCB->Lock);

    InsertHeadList(&MiniportCB->AfSapCBList,
                   &AfSapCB->Linkage);

    NdisWanInitializeNotificationEvent(&AfSapCB->NotificationEvent);

    NdisWanInterlockedInc(&MiniportCB->AfRefCount);

    NdisReleaseSpinLock(&MiniportCB->Lock);

    return (AfSapCB);
}

VOID
NdisWanFreeCmAfSapCB(
    PCM_AFSAPCB AfSapCB
    )
{
    PMINIPORTCB MiniportCB  = AfSapCB->MiniportCB;

    NdisAcquireSpinLock(&MiniportCB->Lock);

    NdisWanInterlockedDec(&MiniportCB->AfRefCount);

    RemoveEntryList(&AfSapCB->Linkage);

    NdisReleaseSpinLock(&MiniportCB->Lock);

    DEREF_MINIPORTCB(MiniportCB);

    NdisFreeToNPagedLookasideList(&AfSapVcCBList,
                                  AfSapCB);
}

PCM_VCCB
NdisWanAllocateCmVcCB(
    PCM_AFSAPCB AfSapCB,
    NDIS_HANDLE NdisVcHandle
    )
{
    PCM_VCCB    CmVcCB;

    CmVcCB =
        NdisAllocateFromNPagedLookasideList(&AfSapVcCBList);

    if (CmVcCB == NULL) {
        return (NULL);
    }

    NdisZeroMemory(CmVcCB, sizeof(CM_VCCB));

    CmVcCB->AfSapCB = AfSapCB;
    CmVcCB->Signature = CMVC_SIG;
    CmVcCB->NdisVcHandle = NdisVcHandle;

    return (CmVcCB);
}

VOID
NdisWanFreeCmVcCB(
    PCM_VCCB    CmVcCB
    )
{
    NdisFreeToNPagedLookasideList(&AfSapVcCBList, CmVcCB);
}

NDIS_STATUS
AllocateIoNdisPacket(
    ULONG           SizeNeeded,
    PNDIS_PACKET    *NdisPacket,
    PNDIS_BUFFER    *NdisBuffer, 
    PUCHAR          *DataBuffer
    )
/*++

Routine Name:
    
    AllocateIoNdisPacket
    
Routine Description:

    This routine will alocate a packet used to send a PPP control
    packet over a wan endpoint.  The routine is written with the
    assumption that there will only ever be a single NDIS_BUFFER
    attached to the packet.  This buffer is attached immediately
    to the front of the packet.  Before calling a miniport the
    NDIS_BUFFER must have it's length adjusted and the packet must
    recalculate all counts.

Arguments:

Return Values:

--*/
{
    PDATA_DESC  DataDesc;
    ULONG       Length;
    PNPAGED_LOOKASIDE_LIST  LookasideList;

    if (SizeNeeded > glLargeDataBufferSize) {

        DbgPrint("NDISWAN: Error Allocating IoNdisPacket Size %d\n",
                 SizeNeeded);
        return (NDIS_STATUS_FAILURE);
    } else if (SizeNeeded > glSmallDataBufferSize) {
        LookasideList = &LargeDataDescList;
    } else {
        LookasideList = &SmallDataDescList;
    }

    DataDesc =
        NdisAllocateFromNPagedLookasideList(LookasideList);

    if (DataDesc == NULL) {
        return (NDIS_STATUS_RESOURCES);
    }

    DataDesc->LookasideList = LookasideList;

    *NdisPacket =
        DataDesc->NdisPacket;

    PPROTOCOL_RESERVED_FROM_NDIS(DataDesc->NdisPacket)->MagicNumber =
        MAGIC_INTERNAL_IO;

    PPROTOCOL_RESERVED_FROM_NDIS(DataDesc->NdisPacket)->DataDesc =
        DataDesc;

    *NdisBuffer =
        DataDesc->NdisBuffer;

    NdisQueryBuffer(DataDesc->NdisBuffer,
                    &DataDesc->DataBuffer,
                    &Length);
    *DataBuffer =
        DataDesc->DataBuffer;

    return (NDIS_STATUS_SUCCESS);
}

VOID
FreeIoNdisPacket(
    PNDIS_PACKET    NdisPacket
)
/*++

Routine Name:

    FreeIoNdisPacket
    
Routine Description:

    This routine will free a packet used to send a PPP control
    packet over a wan endpoint.  The routine is written with the
    assumption that there will only ever be a single NDIS_BUFFER
    attached to the packet.  This buffer does not have to be
    explicitly removed from the packet here as a pointer to it
    is stored in the DATA_DESC itself and will be freed when
    the DATA_DESC is freed.

Arguments:

Return Values:

--*/
{
    PDATA_DESC      DataDesc;
    PNDIS_BUFFER    NdisBuffer;
    PNPAGED_LOOKASIDE_LIST  LookasideList;

    DataDesc = 
        PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->DataDesc;

    ASSERT(PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->MagicNumber == MAGIC_INTERNAL_IO);

    LookasideList = 
        DataDesc->LookasideList;

    NdisAdjustBufferLength(DataDesc->NdisBuffer,
                           DataDesc->DataBufferLength);

    NdisRecalculatePacketCounts(NdisPacket);

    NDIS_SET_PACKET_HEADER_SIZE(NdisPacket, 
                                MAC_HEADER_LENGTH);

    NDIS_SET_PACKET_STATUS(NdisPacket, 
                           NDIS_STATUS_SUCCESS);

    NdisFreeToNPagedLookasideList(LookasideList, DataDesc);
}

PVOID
AllocateWanPacket(
    IN  POOL_TYPE   PoolType,
    IN  SIZE_T      NumberOfBytes,
    IN  ULONG       Tag
    )
{
    PVOID   pMem;

    NdisWanAllocatePriorityMemory(&pMem,
                                  NumberOfBytes,
                                  Tag,
                                  NormalPoolPriority);

    return(pMem);
}

VOID
FreeWanPacket(
    PVOID   WanPacket
    )
{
    NdisWanFreeMemory(WanPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\packet.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    packet.h
    
Abstract:

    This file contains data structures used by the NdisWan driver
    to define ndis packet particulars.
    


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      02/11/97

--*/

#ifndef _NDISWAN_PACKETS_
#define _NDISWAN_PACKETS_

#define MAGIC_EXTERNAL_RECV     '!RxE'
#define MAGIC_EXTERANL_SEND     '!SxE'
#define MAGIC_INTERNAL_IO       '!InI'
#define MAGIC_INTERNAL_SEND     '!SnI'      
#define MAGIC_INTERNAL_RECV     '!RnI'
#define MAGIC_INTERNAL_ALLOC    '!AnI'

//
// The first 16 bytes of the protocol reserved section
// of a ndis packet indicated to ndiswan by a miniport
// belong to ndiswan
//
typedef struct _NDISWAN_RECV_RESERVED {
    LIST_ENTRY  Linkage;
    ULONG       MagicNumber;
    ULONG       NdisPacket;
} NDISWAN_RECV_RESERVED, *PNDISWAN_RECV_RESERVED;

//
// When ndiswan indicates a ndis packet to a protocol
// the first 16 bytes of the protocol reseved belong to
// the transport.  NdisWan will store its information
// beyond this area.
//
typedef struct _NDISWAN_PROTOCOL_RESERVED {
    UCHAR               Reserved[16];   // 16 bytes reserved for the protocol
    union {
        SINGLE_LIST_ENTRY   SLink;
        ULONG               MagicNumber;
    };
    struct _POOL_DESC   *PoolDesc;
    struct _LINKCB      *LinkCB;

    union {
        struct _RECV_DESC   *RecvDesc;
        struct _SEND_DESC   *SendDesc;
        struct _DATA_DESC   *DataDesc;
    };
} NDISWAN_PROTOCOL_RESERVED, *PNDISWAN_PROTOCOL_RESERVED;

typedef struct _NDISWAN_MINIPORT_RESERVED {
    union {
        PNDIS_PACKET    Next;
        ULONG           RefCount;   // Used to count number of fragments
    };
    struct _CM_VCCB *CmVcCB;
} NDISWAN_MINIPORT_RESERVED, *PNDISWAN_MINIPORT_RESERVED;

typedef struct _POOLDESC_LIST {
    LIST_ENTRY      List;
    NDIS_SPIN_LOCK  Lock;
    ULONG           TotalDescCount;
    ULONG           MaxDescCount;
    ULONG           AllocatedCount;
    ULONG           MaxAllocatedCount;
    ULONG           FreeCount;
} POOLDESC_LIST, *PPOOLDESC_LIST;

typedef struct _POOL_DESC {
    LIST_ENTRY          Linkage;
    SINGLE_LIST_ENTRY   Head;
    NDIS_HANDLE         PoolHandle;
    ULONG               AllocatedCount;
    ULONG               MaxAllocatedCount;
    ULONG               FreeCount;
} POOL_DESC, *PPOOL_DESC;

typedef struct _PACKET_QUEUE {
    PNDIS_PACKET    HeadQueue;      // Queue of ndis packets
                                        // waiting to be sent
    PNDIS_PACKET    TailQueue;      // Last packet on the queue

    ULONG           ByteDepth;
    ULONG           MaxByteDepth;
    ULONG           PacketDepth;
    ULONG           MaxPacketDepth;
    ULONG           DumpedPacketCount;
    ULONG           DumpedByteCount;
    LONG            OutstandingFrags;
} PACKET_QUEUE, *PPACKET_QUEUE;

#endif // end of _NDISWAN_PACKETS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\receive.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Receive.c

Abstract:

    This file contains the procedures for handling a receive indication from
    a Wan Miniport link, bound to the lower interface of NdisWan, and passing
    the data on to a protocol, bound to the upper interface of NdisWan.  The
    upper interface of NdisWan conforms to the NDIS 3.1 Miniport specification.
    The lower interface of NdisWan conforms to the NDIS 3.1 Extentions for
    Wan Miniport drivers.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe  06/06/95    Created

--*/

#include "wan.h"

#define __FILE_SIG__    RECEIVE_FILESIG

VOID
DoMultilinkProcessing(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

VOID
UpdateMinRecvSeqNumber(
    PBUNDLECB   BundleCB,
    UINT        Class
    );

VOID
TryToAssembleFrame(
    PBUNDLECB   BundleCB,
    UINT        Class
    );

NDIS_STATUS
ProcessPPPFrame(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    );

NDIS_STATUS
IndicateRecvPacket(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    );

BOOLEAN
DoVJDecompression(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    );

BOOLEAN
DoDecompDecryptProcessing(
    PBUNDLECB   BundleCB,
    PUCHAR      *DataPointer,
    PLONG       DataLength
    );

VOID
DoCompressionReset(
    PBUNDLECB   BundleCB
    );

VOID
FlushRecvDescWindow(
    PBUNDLECB   BundleCB,
    UINT        Class
    );

VOID
FindHoleInRecvList(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc,
    UINT        Class
    );

BOOLEAN
GetProtocolFromPPPId(
    PBUNDLECB   BundleCB,
    USHORT      Id,
    PPROTOCOLCB *ProtocolCB
    );

#ifdef NT

NDIS_STATUS
CompleteIoRecvPacket(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    );

#endif

NDIS_STATUS
DetectBroadbandFraming(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    PUCHAR      FramePointer;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("DetectFraming: Enter"));

    FramePointer = RecvDesc->CurrentBuffer;

    if (*FramePointer == 0xFE && *(FramePointer + 1) == 0xFE &&
        *(FramePointer + 2) == 0x03 && *(FramePointer + 3) == 0xCF) {
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits =
                PPP_FRAMING | LLC_ENCAPSULATION;

            LinkCB->RecvHandler = ReceiveLLC;

    } else {

        LinkCB->LinkInfo.RecvFramingBits =
        LinkCB->LinkInfo.SendFramingBits = 
            PPP_FRAMING | PPP_COMPRESS_ADDRESS_CONTROL;

        LinkCB->RecvHandler = ReceivePPP;
    }

    Status = (*LinkCB->RecvHandler)(LinkCB, RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("DetectFraming: Exit Status %x",Status));

    return (Status);
}


NDIS_STATUS
DetectFraming(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    PUCHAR      FramePointer;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("DetectFraming: Enter"));

    ASSERT(LinkCB->LinkInfo.RecvFramingBits == 0x00);

    FramePointer = RecvDesc->CurrentBuffer;

    //
    // If we are in framing detect mode figure it out
    //
    if (LinkCB->LinkInfo.RecvFramingBits == 0 ||
        LinkCB->LinkInfo.SendFramingBits == 0) {

        if (*FramePointer == 0xFF && *(FramePointer + 1) == 0x03) {
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits = PPP_FRAMING;
            LinkCB->RecvHandler = ReceivePPP;
        } else if (*FramePointer == 0x01 && *(FramePointer + 1) == 0x1B &&
                   *(FramePointer + 2) == 0x02){
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits = ARAP_V2_FRAMING;
            LinkCB->RecvHandler = ReceiveARAP;
        } else if (*FramePointer == 0x16 && *(FramePointer + 1) == 0x10 &&
                   *(FramePointer + 2) == 0x02){
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits = ARAP_V1_FRAMING;
            LinkCB->RecvHandler = ReceiveARAP;
        } else if (*FramePointer == 0xFE && *(FramePointer + 1) == 0xFE &&
                   *(FramePointer + 2) == 0x03 &&
                   *(FramePointer + 3) == 0xCF) {
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits =
                PPP_FRAMING | LLC_ENCAPSULATION;
            LinkCB->RecvHandler = ReceiveLLC;
        } else {
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits = RAS_FRAMING;
            LinkCB->RecvHandler = ReceiveRAS;
        }

        if (BundleCB->FramingInfo.RecvFramingBits == 0x00) {

            if (LinkCB->LinkInfo.RecvFramingBits & PPP_FRAMING) {
                BundleCB->FramingInfo.RecvFramingBits =
                BundleCB->FramingInfo.SendFramingBits = PPP_FRAMING;
            } else if (LinkCB->LinkInfo.RecvFramingBits & ARAP_V1_FRAMING) {
                BundleCB->FramingInfo.RecvFramingBits =
                BundleCB->FramingInfo.SendFramingBits = ARAP_V1_FRAMING;
            } else if (LinkCB->LinkInfo.RecvFramingBits & ARAP_V2_FRAMING) {
                BundleCB->FramingInfo.RecvFramingBits =
                BundleCB->FramingInfo.SendFramingBits = ARAP_V2_FRAMING;
            } else if (LinkCB->LinkInfo.RecvFramingBits & RAS_FRAMING) {
                BundleCB->FramingInfo.RecvFramingBits =
                BundleCB->FramingInfo.SendFramingBits = RAS_FRAMING;
            } else {
                NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE,
                    ("DetectFraming Failed! 0x%2.2x 0x%2.2x 0x%2.2x",
                    FramePointer[0], FramePointer[1], FramePointer[2]));
                return (NDIS_STATUS_SUCCESS);
            }
        }

    } else {
        NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE,
            ("FramingBits set but still in detect 0x%x 0x%x",
            LinkCB->LinkInfo.RecvFramingBits,
            LinkCB->LinkInfo.SendFramingBits));
        return (NDIS_STATUS_SUCCESS);
    }

    Status = (*LinkCB->RecvHandler)(LinkCB, RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("DetectFraming: Exit Status %x",Status));

    return (Status);
}

NDIS_STATUS
ReceivePPP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    PBUNDLECB       BundleCB = LinkCB->BundleCB;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PUCHAR          FramePointer = RecvDesc->CurrentBuffer;
    LONG            FrameLength = RecvDesc->CurrentLength;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceivePPP: Enter"));

    //
    // Remove the address/control part of the PPP header
    //
    if (*FramePointer == 0xFF) {
        FramePointer += 2;
        FrameLength -= 2;
    }

    if (FrameLength <= 0) {
        Status = NDIS_STATUS_FAILURE;
        goto RECEIVE_PPP_EXIT;
    }

    //
    // If multilink framing is set and this is a multilink frame
    // send to the multilink processor!
    //
    if ((LinkCB->LinkInfo.RecvFramingBits & PPP_MULTILINK_FRAMING) &&
        ((*FramePointer == 0x3D) ||
         (*FramePointer == 0x00) && (*(FramePointer + 1) == 0x3D)) ) {

        //
        // Remove multilink protocol id
        //
        if (*FramePointer & 1) {
            FramePointer++;
            FrameLength--;
        } else {
            FramePointer += 2;
            FrameLength -= 2;
        }

        if (FrameLength <= 0) {
            Status = NDIS_STATUS_FAILURE;
            goto RECEIVE_PPP_EXIT;
        }

        RecvDesc->CurrentBuffer = FramePointer;
        RecvDesc->CurrentLength = FrameLength;

        DoMultilinkProcessing(LinkCB, RecvDesc);

        Status = NDIS_STATUS_PENDING;

        goto RECEIVE_PPP_EXIT;
    }

    RecvDesc->CurrentBuffer = FramePointer;
    RecvDesc->CurrentLength = FrameLength;

    Status = ProcessPPPFrame(BundleCB, RecvDesc);

RECEIVE_PPP_EXIT:

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceivePPP: Exit Status %x", Status));

    return (Status);
}

NDIS_STATUS
ReceiveSLIP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    PBUNDLECB       BundleCB = LinkCB->BundleCB;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PUCHAR          FramePointer = RecvDesc->CurrentBuffer;
    ULONG           FrameLength = RecvDesc->CurrentLength;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveSLIP: Enter"));

    ASSERT(BundleCB->FramingInfo.RecvFramingBits & SLIP_FRAMING);

    BundleCB->Stats.FramesReceived++;


    if (!DoVJDecompression(BundleCB,    // Bundle
                           RecvDesc)) { // RecvDesc

        goto RECEIVE_SLIP_EXIT;
    }

    Status = IndicateRecvPacket(BundleCB, RecvDesc);

RECEIVE_SLIP_EXIT:

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveSLIP: Exit Status %x", Status));

    return (Status);
}

NDIS_STATUS
ReceiveRAS(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    PBUNDLECB       BundleCB = LinkCB->BundleCB;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PUCHAR          FramePointer = RecvDesc->CurrentBuffer;
    LONG            FrameLength = RecvDesc->CurrentLength;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveRAS: Enter"));

    ASSERT(BundleCB->FramingInfo.RecvFramingBits & RAS_FRAMING);

    BundleCB->Stats.FramesReceived++;

    // For normal NBF frames, first byte is always the DSAP
    // i.e 0xF0 followed by SSAP 0xF0 or 0xF1
    //
    //
    if (*FramePointer == 14) {

        //
        // Compression reset!
        //
        DoCompressionReset(BundleCB);

        goto RECEIVE_RAS_EXIT;
    }

    if (*FramePointer == 0xFD) {

        //
        // Skip over 0xFD
        //
        FramePointer++;
        FrameLength--;

        //
        // Decompress as if an NBF PPP Packet
        //
        if (!DoDecompDecryptProcessing(BundleCB,
                                       &FramePointer,
                                       &FrameLength)){

            //
            // There was an error get out!
            //
            goto RECEIVE_RAS_EXIT;
        }
    }

    //
    // Make frame look like an NBF PPP packet
    //
    RecvDesc->ProtocolID = PPP_PROTOCOL_NBF;
    RecvDesc->CurrentLength = FrameLength;
    RecvDesc->CurrentBuffer = FramePointer;

    Status = IndicateRecvPacket(BundleCB, RecvDesc);

RECEIVE_RAS_EXIT:

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveRAS: Exit Status %x",Status));

    return (Status);
}

NDIS_STATUS
ReceiveARAP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveARAP: Enter"));

    ASSERT(BundleCB->FramingInfo.RecvFramingBits & ARAP_FRAMING);

    BundleCB->Stats.FramesReceived++;

    RecvDesc->ProtocolID = PPP_PROTOCOL_APPLETALK;

    Status = IndicateRecvPacket(BundleCB, RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveARAP: Exit Status %x",Status));

    return (Status);
}

NDIS_STATUS
ReceiveLLC(
   PLINKCB          LinkCB,
   PRECV_DESC       RecvDesc
   )
{
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PUCHAR          FramePointer = RecvDesc->CurrentBuffer;
    LONG            FrameLength = RecvDesc->CurrentLength;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveLLC: Enter"));

    //
    // Skip over LLC
    //
    if (FrameLength < 4) {

    }
    if (*FramePointer != 0xFE || *(FramePointer + 1) != 0xFE ||
        *(FramePointer + 2) != 0x03 || *(FramePointer + 3) != 0xCF) {
        LinkCB->LinkInfo.RecvFramingBits = 0;
        LinkCB->RecvHandler = DetectBroadbandFraming;
        return (NDIS_STATUS_FAILURE);
    }

    FramePointer += 4;
    FrameLength -= 4;

    if (FrameLength <= 0) {
        return (NDIS_STATUS_FAILURE);
    }

    RecvDesc->CurrentBuffer = FramePointer;
    RecvDesc->CurrentLength = FrameLength;

    Status = ProcessPPPFrame(BundleCB, RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveLLC: Exit Status %x",Status));

    return (Status);
}


NDIS_STATUS
ReceiveForward(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveForward: Enter"));
    BundleCB->Stats.FramesReceived++;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveForward: Exit Status %x",Status));
    return (Status);
}

NDIS_STATUS
ProcessPPPFrame(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    )
{
    USHORT      PPPProtocolID;
    PUCHAR      FramePointer = RecvDesc->CurrentBuffer;
    LONG        FrameLength = RecvDesc->CurrentLength;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProcessPPPFrame: Enter"));

    BundleCB->Stats.FramesReceived++;

    //
    // Get the PPP Protocol id
    // 0xC1 is SPAP - Shiva hack!
    //
    if ((*FramePointer & 1) &&
        (*FramePointer != 0xC1) &&
        (*FramePointer != 0xCF)) {

        //
        // Field is compressed
        //
        PPPProtocolID = *FramePointer;
        FramePointer++;
        FrameLength--;

    } else {

        //
        // Field is not compressed
        //
        PPPProtocolID = (*FramePointer << 8) | *(FramePointer + 1);
        FramePointer += 2;
        FrameLength -= 2;
    }

    if (FrameLength <= 0) {
        
        goto PROCESS_PPP_EXIT;
    }

#if 0
    if (BundleCB->Stats.FramesReceived == 1) {
        if (PPPProtocolID != 0xC021) {
            DbgPrint("NDISWAN: Non-LCP first frame! %x %x\n",
                     BundleCB, RecvDesc);
            DbgBreakPoint();
        }
    }
#endif

    //
    // Is this a compressed frame?
    //
    if (PPPProtocolID == PPP_PROTOCOL_COMPRESSION) {

        if (!DoDecompDecryptProcessing(BundleCB,
                                       &FramePointer,
                                       &FrameLength)){

            goto PROCESS_PPP_EXIT;
        }

        //
        // Get the new PPPProtocolID
        //
        if ((*FramePointer & 1) && (FrameLength > 0)) {

            //
            // Field is compressed
            //

            PPPProtocolID = *FramePointer;
            FramePointer++;
            FrameLength--;

        } else if (FrameLength > 1) {
                
            PPPProtocolID = (*FramePointer << 8) | *(FramePointer + 1);
            FramePointer += 2;
            FrameLength -= 2;

        } else {
            //
            // Invalid frame!
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE, ("Invalid FrameLen %d", FrameLength));
            goto PROCESS_PPP_EXIT;
        }

    //end of PPP_PROTOCOL_COMPRESSED
    } else if ((PPPProtocolID == PPP_PROTOCOL_COMP_RESET) &&
               (*FramePointer == 14)) {

        if (NdisWanCB.PromiscuousAdapter != NULL) {

            UCHAR       Header[] = {' ', 'R', 'E', 'C', 'V', 0xFF};
            PUCHAR      HeaderPointer;
            USHORT      ProtocolID;
            
            RecvDesc->ProtocolID = PPPProtocolID;
            RecvDesc->CurrentBuffer = FramePointer;
            RecvDesc->CurrentLength = FrameLength;

            HeaderPointer = 
                RecvDesc->StartBuffer;

            ProtocolID = RecvDesc->ProtocolID;

            //
            // Fill the frame out, and queue the data
            //
            NdisMoveMemory(HeaderPointer,
                           Header,
                           sizeof(Header));

            NdisMoveMemory(&HeaderPointer[6],
                           Header,
                           sizeof(Header));

            HeaderPointer[5] =
            HeaderPointer[11] = (UCHAR)RecvDesc->LinkCB->hLinkHandle;

            HeaderPointer[12] = (UCHAR)(ProtocolID >> 8);
            HeaderPointer[13] = (UCHAR)ProtocolID;

            NdisMoveMemory(HeaderPointer + 14,
                           RecvDesc->CurrentBuffer,
                           RecvDesc->CurrentLength);

            RecvDesc->CurrentBuffer = RecvDesc->StartBuffer;
            RecvDesc->CurrentLength += 14;

            //
            // Queue the packet on the promiscous adapter
            //
            IndicatePromiscuousRecv(BundleCB, RecvDesc, RECV_BUNDLE_PPP);
        }

        //
        // Compression reset!
        //
        DoCompressionReset(BundleCB);

        goto PROCESS_PPP_EXIT;

    // end of compression reset
    } else {

        //
        // If we have negotiated encryption and we receive non-encrypted data
        // that is not a ppp control packet we will dump the frame!
        //
        if ((BundleCB->RecvFlags & DO_ENCRYPTION) &&
            (PPPProtocolID < 0x8000)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE, ("Received non-encrypted data with encryption negotiated!"));
            goto PROCESS_PPP_EXIT;
        }
    }
    

    RecvDesc->ProtocolID = PPPProtocolID;
    RecvDesc->CurrentLength = FrameLength;
    RecvDesc->CurrentBuffer = FramePointer;

    //
    // If this is slip or if the ProtocolID == PPP_PROTOCOL_COMPRESSED_TCP ||
    // ProtocolID == PPP_PROTOCOL_UNCOMPRESSED_TCP
    //
    if ((BundleCB->RecvFlags & DO_VJ) &&
        ((PPPProtocolID == PPP_PROTOCOL_COMPRESSED_TCP) ||
        (PPPProtocolID == PPP_PROTOCOL_UNCOMPRESSED_TCP))) {

        if (!DoVJDecompression(BundleCB,    // Bundle
                               RecvDesc)) { // RecvDesc

            goto PROCESS_PPP_EXIT;
        }
    }

    Status = IndicateRecvPacket(BundleCB, RecvDesc);

PROCESS_PPP_EXIT:

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProcessPPPFrame: Exit Status 0x%x", Status));

    return (Status);
}

NDIS_STATUS
IndicateRecvPacket(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    )
{
    PNDIS_PACKET    NdisPacket;
    PPROTOCOLCB     ProtocolCB;
    PMINIPORTCB     MiniportCB;
    USHORT          PPPProtocolID = RecvDesc->ProtocolID;
    PUCHAR          FramePointer = RecvDesc->CurrentBuffer;
    ULONG           FrameLength = RecvDesc->CurrentLength;
    PUCHAR          HeaderBuffer = RecvDesc->StartBuffer;
    NDIS_STATUS     Status = NDIS_STATUS_PENDING;
    PCM_VCCB        CmVcCB = NULL;
    KIRQL           OldIrql;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("IndicateRecvPacket: Enter"));

    if ((PPPProtocolID >= 0x8000) ||
        (BundleCB->ulNumberOfRoutes == 0)) {


        //
        // Either this frame is an LCP, NCP or we have no routes yet.
        // Indicate to PPP engine.
        //
        Status = CompleteIoRecvPacket(BundleCB, RecvDesc);

        return (Status);
    }

    if (!GetProtocolFromPPPId(BundleCB,
                              PPPProtocolID,
                              &ProtocolCB)) {

        return (NDIS_STATUS_SUCCESS);
    }

    REF_PROTOCOLCB(ProtocolCB);

    if (!IsListEmpty(&ProtocolCB->VcList)) {
        CmVcCB = (PCM_VCCB)ProtocolCB->VcList.Flink;
        REF_CMVCCB(CmVcCB);
    }

    MiniportCB = ProtocolCB->MiniportCB;

    //
    // We found a valid protocol to indicate this frame to!
    //

    //
    // We need to get a data buffer, a couple a ndis buffer, and
    // a ndis packet to indicate to the protocol
    //

    //
    // Fill the WanHeader dest address with the transports context
    //
    ETH_COPY_NETWORK_ADDRESS(HeaderBuffer, ProtocolCB->TransportAddress);

    if (PPPProtocolID == PPP_PROTOCOL_NBF) {

        //
        // For nbf fill the length field
        //
        HeaderBuffer[12] = (UCHAR)(FrameLength >> 8);
        HeaderBuffer[13] = (UCHAR)FrameLength;

        if (!(BundleCB->FramingInfo.RecvFramingBits & NBF_PRESERVE_MAC_ADDRESS)) {
            goto USE_OUR_ADDRESS;
        }

        //
        // For nbf and preserve mac address option (SHIVA_FRAMING)
        // we keep the source address.
        //
        ETH_COPY_NETWORK_ADDRESS(&HeaderBuffer[6], FramePointer + 6);

        FramePointer += 12;
        FrameLength -= 12;

        //
        // For nbf fill the length field
        //
        HeaderBuffer[12] = (UCHAR)(FrameLength >> 8);
        HeaderBuffer[13] = (UCHAR)FrameLength;

    } else {

        //
        // For other protocols fill the protocol type
        //
        HeaderBuffer[12] = (UCHAR)(ProtocolCB->ProtocolType >> 8);
        HeaderBuffer[13] = (UCHAR)ProtocolCB->ProtocolType;

        //
        // Use our address for the src address
        //
USE_OUR_ADDRESS:
        ETH_COPY_NETWORK_ADDRESS(&HeaderBuffer[6], ProtocolCB->NdisWanAddress);
    }

    if (FrameLength > BundleCB->FramingInfo.MaxRRecvFrameSize ||
        FrameLength + RecvDesc->HeaderLength > BundleCB->FramingInfo.MaxRRecvFrameSize) {
        NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("DataLen %d + HdrLen %d > MRRU %d",
        FrameLength, RecvDesc->HeaderLength, BundleCB->FramingInfo.MaxRRecvFrameSize));

        goto INDICATE_RECV_PACKET_EXIT;
    }

    RecvDesc->HeaderLength += MAC_HEADER_LENGTH;

    //
    // Build the NdisPacket
    // USE RtlMoveMemory because memory ranges may overlap.  NdisMoveMemory
    // actually does an rtlcopymemory which does not handle overlapping
    // src/dest ranges.
    //
    RtlMoveMemory(HeaderBuffer + RecvDesc->HeaderLength,
                  FramePointer,
                  FrameLength);

    RecvDesc->CurrentBuffer = HeaderBuffer;
    RecvDesc->CurrentLength = 
        RecvDesc->HeaderLength + FrameLength;

    if (NdisWanCB.PromiscuousAdapter != NULL) {
    
        //
        // Queue the packet on the promiscous adapter
        //
        IndicatePromiscuousRecv(BundleCB, 
                                RecvDesc, 
                                RECV_BUNDLE_DATA);
    }

    NdisPacket = 
        RecvDesc->NdisPacket;

    PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->RecvDesc = 
        RecvDesc;

    NdisAdjustBufferLength(RecvDesc->NdisBuffer,
                           RecvDesc->CurrentLength);

    NdisRecalculatePacketCounts(NdisPacket);

    //
    // Check for non-idle data
    //
    if (ProtocolCB->NonIdleDetectFunc != NULL) {
        PUCHAR  PHeaderBuffer = HeaderBuffer + MAC_HEADER_LENGTH;

        if (TRUE == ProtocolCB->NonIdleDetectFunc(PHeaderBuffer,
                                                  RecvDesc->HeaderLength + FrameLength,
                                                  RecvDesc->HeaderLength + FrameLength)) {
            NdisWanGetSystemTime(&ProtocolCB->LastNonIdleData);
            BundleCB->LastNonIdleData = ProtocolCB->LastNonIdleData;
        }
    } else {
        NdisWanGetSystemTime(&ProtocolCB->LastNonIdleData);
        BundleCB->LastNonIdleData = ProtocolCB->LastNonIdleData;
    }

    ReleaseBundleLock(BundleCB);

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    INSERT_DBG_RECV(PacketTypeNdis, 
                    MiniportCB, 
                    ProtocolCB, 
                    RecvDesc->LinkCB, 
                    NdisPacket);

    //
    // Indicate the packet
    //
    if (CmVcCB != NULL) {

        NdisMCoIndicateReceivePacket(CmVcCB->NdisVcHandle,
                                     &NdisPacket,
                                     1);

        DEREF_CMVCCB(CmVcCB);

    } else {

        NdisMIndicateReceivePacket(MiniportCB->MiniportHandle,
                                   &NdisPacket,
                                   1);
    }

    KeLowerIrql(OldIrql);

    AcquireBundleLock(BundleCB);

INDICATE_RECV_PACKET_EXIT:

    DEREF_PROTOCOLCB(ProtocolCB);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("IndicateRecvPacket: Exit Status %x",Status));

    return (Status);
}


VOID
DoMultilinkProcessing(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
/*++

Routine Name:

Routine Description:

Arguments:

                           0 1 2 3 4 5 6 7 8 9 1 1 1 1 1 1
                                               0 1 2 3 4 5
                          +-+-+-+-+------------------------+
    Short Sequence Number |B|E|0|0|    Sequence Number     |
                          +-+-+-+-+------------------------+
                          |             Data               |
                          +--------------------------------+

                          +-+-+-+-+-+-+-+-+----------------+
    Long Sequence Number  |B|E|0|0|0|0|0|0|Sequence Number |
                          +-+-+-+-+-+-+-+-+----------------+
                          |        Sequence Number         |
                          +--------------------------------+
                          |            Data                |
                          +--------------------------------+
                        
    MCML                  +-+-+-+-+------------------------+
    Short Sequence Number |B|E|Cls|    Sequence Number     |
                          +-+-+-+-+------------------------+
                          |             Data               |
                          +--------------------------------+

    MCML                  +-+-+-+-+-+-+-+-+----------------+
    Long Sequence Number  |B|E| Class |0|0|Sequence Number |
                          +-+-+-+-+-+-+-+-+----------------+
                          |        Sequence Number         |
                          +--------------------------------+
                          |            Data                |
                          +--------------------------------+
                        

Return Values:

--*/
{
    BOOLEAN Inserted = FALSE;
    ULONG   BundleFraming;
    ULONG   SequenceNumber, Flags;
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    PUCHAR      FramePointer = RecvDesc->CurrentBuffer;
    LONG        FrameLength = RecvDesc->CurrentLength;
    PRECV_DESC  RecvDescHole;
    UINT        Class = 0;
    PBUNDLE_RECV_INFO   BundleRecvInfo;
    PLINK_RECV_INFO     LinkRecvInfo;

    //
    // Get the flags
    //
    Flags = *FramePointer & MULTILINK_FLAG_MASK;

    //
    // Get the sequence number
    //
    if (BundleCB->FramingInfo.RecvFramingBits &
        PPP_SHORT_SEQUENCE_HDR_FORMAT) {
        //
        // Short sequence format
        //
        SequenceNumber =
            ((*FramePointer & 0x0F) << 8) | *(FramePointer + 1);

        if (BundleCB->FramingInfo.RecvFramingBits &
            PPP_MC_MULTILINK_FRAMING) {
            Class =
                ((*FramePointer & MCML_SHORTCLASS_MASK) >> 4);
        }

        FramePointer += 2;
        FrameLength -= 2;


    } else {

        //
        // Long sequence format
        //
        SequenceNumber = (*(FramePointer + 1) << 16) |
                         (*(FramePointer + 2) << 8)  |
                         *(FramePointer + 3);

        if (BundleCB->FramingInfo.RecvFramingBits &
            PPP_MC_MULTILINK_FRAMING) {
            Class =
                ((*FramePointer & MCML_LONGCLASS_MASK) >> 2);
        }

        FramePointer += 4;
        FrameLength -= 4;
    }

    if (Class >= MAX_MCML) {
        LinkCB->Stats.FramingErrors++;
        BundleCB->Stats.FramingErrors++;
        return;
    }

    BundleRecvInfo = &BundleCB->RecvInfo[Class];
    LinkRecvInfo = &LinkCB->RecvInfo[Class];

    if (FrameLength <= 0) {
        LinkCB->Stats.FramingErrors++;
        LinkRecvInfo->FragmentsLost++;

        BundleCB->Stats.FramingErrors++;
        BundleRecvInfo->FragmentsLost++;
        return;
    }

    RecvDescHole = BundleRecvInfo->RecvDescHole;

    NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV,
    ("r %x %x h: %x l: %d",SequenceNumber, Flags, RecvDescHole->SequenceNumber, LinkCB->hLinkHandle));

    //
    // Is the new receive sequence number smaller that the last
    // sequence number received on this link?  If so the increasing seq
    // number rule has been violated and we need to toss this one.
    //
    if (SEQ_LT(SequenceNumber,
               LinkRecvInfo->LastSeqNumber,
               BundleCB->RecvSeqTest)) {

        LinkCB->Stats.FramingErrors++;
        LinkRecvInfo->FragmentsLost++;

        BundleCB->Stats.FramingErrors++;
        BundleRecvInfo->FragmentsLost++;

        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
        ("dl s: %x %x lr: %x", SequenceNumber, Flags,
        LinkRecvInfo->LastSeqNumber));

        NdisWanFreeRecvDesc(RecvDesc);
        return;
        
    }

    //
    // Is the new receive sequence number smaller than the hole?  If so
    // we received a fragment across a slow link after it has been flushed
    //
    if (SEQ_LT(SequenceNumber,
               RecvDescHole->SequenceNumber,
               BundleCB->RecvSeqTest)) {

        LinkCB->Stats.FramingErrors++;
        LinkRecvInfo->FragmentsLost++;

        BundleCB->Stats.FramingErrors++;
        BundleRecvInfo->FragmentsLost++;

        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
        ("db s: %x %x h: %x", SequenceNumber, Flags,
        RecvDescHole->SequenceNumber));

        NdisWanFreeRecvDesc(RecvDesc);
        return;
    }

    //
    // Initialize the recv desc
    //
    RecvDesc->Flags |= Flags;
    RecvDesc->SequenceNumber =
    LinkRecvInfo->LastSeqNumber = SequenceNumber;

    if (RecvDesc->CopyRequired) {
        PUCHAR  StartData = 
            RecvDesc->StartBuffer + MAC_HEADER_LENGTH + PROTOCOL_HEADER_LENGTH;

        NdisMoveMemory(StartData,
                       FramePointer,
                       FrameLength);

        FramePointer = StartData;

        RecvDesc->CopyRequired = FALSE;
    }

    RecvDesc->CurrentBuffer = FramePointer;
    RecvDesc->CurrentLength = FrameLength;

    //
    // If this fills the hole
    //
    if (SEQ_EQ(SequenceNumber, RecvDescHole->SequenceNumber)) {

        //
        // Insert the hole filler in the current holes spot
        //
        RecvDesc->Linkage.Blink = (PLIST_ENTRY)RecvDescHole->Linkage.Blink;
        RecvDesc->Linkage.Flink = (PLIST_ENTRY)RecvDescHole->Linkage.Flink;

        RecvDesc->Linkage.Blink->Flink =
        RecvDesc->Linkage.Flink->Blink = (PLIST_ENTRY)RecvDesc;

        //
        // Find the next hole
        //
        FindHoleInRecvList(BundleCB, RecvDesc, Class);

        NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("r1"));

    } else {

        PRECV_DESC  BeginDesc, EndDesc;

        //
        // This does not fill a hole so we need to insert it into
        // the list at the right spot.  This spot will be someplace
        // between the hole and the end of the list.
        //
        BeginDesc = RecvDescHole;
        EndDesc = (PRECV_DESC)BeginDesc->Linkage.Flink;

        while ((PVOID)EndDesc != (PVOID)&BundleRecvInfo->AssemblyList) {

            //
            // Calculate the absolute delta between the begining sequence
            // number and the sequence number we are looking to insert.
            //
            ULONG   DeltaBegin =
                    ((RecvDesc->SequenceNumber - BeginDesc->SequenceNumber) &
                    BundleCB->RecvSeqMask);
            
            //
            // Calculate the absolute delta between the begining sequence
            // number and the end sequence number.
            //
            ULONG   DeltaEnd =
                    ((EndDesc->SequenceNumber - BeginDesc->SequenceNumber) &
                    BundleCB->RecvSeqMask);

            //
            // If the delta from the begin to current is less than
            // the delta from the end to current it is time to insert
            //
            if (DeltaBegin < DeltaEnd) {
                PLIST_ENTRY Flink, Blink;

                //
                // Insert the desc
                //
                RecvDesc->Linkage.Flink = (PLIST_ENTRY)EndDesc;
                RecvDesc->Linkage.Blink = (PLIST_ENTRY)BeginDesc;
                BeginDesc->Linkage.Flink =
                EndDesc->Linkage.Blink = (PLIST_ENTRY)RecvDesc;

                Inserted = TRUE;

                NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("r2"));
                break;

            } else {

                //
                // Get next pair of descriptors
                //
                BeginDesc = EndDesc;
                EndDesc = (PRECV_DESC)EndDesc->Linkage.Flink;
            }
        }

        if (!Inserted) {
            
            //
            // If we are here we have fallen through and we need to
            // add this at the end of the list
            //
            InsertTailList(&BundleRecvInfo->AssemblyList, &RecvDesc->Linkage);

            NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("r3"));
        }
    }

    //
    // Another recvdesc has been placed on the assembly list.
    //
    BundleRecvInfo->AssemblyCount++;

    //
    // Update the bundles minimum recv sequence number.  This is
    // used to detect lost fragments.
    //
    UpdateMinRecvSeqNumber(BundleCB, Class);

    //
    // See if we can complete some frames!!!!
    //
    TryToAssembleFrame(BundleCB, Class);

    //
    // Check for lost fragments.  If the minimum recv sequence number
    // over the bundle is greater than the hole sequence number we have
    // lost a fragment and need to flush the assembly list until we find
    // the first begin fragment after the hole.
    //
    if (SEQ_GT(BundleRecvInfo->MinSeqNumber,
               RecvDescHole->SequenceNumber,
               BundleCB->RecvSeqTest)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
            ("min %x > h %x b %p",
             BundleRecvInfo->MinSeqNumber,
             RecvDescHole->SequenceNumber,
             BundleCB));

        do {

            //
            // Flush the recv desc assembly window.
            //
            FlushRecvDescWindow(BundleCB, Class);

        } while (SEQ_GT(BundleRecvInfo->MinSeqNumber,
                        RecvDescHole->SequenceNumber,
                        BundleCB->RecvSeqTest));
    }

    //
    // If the number of recvdesc's is starting to stack up
    // we may have a link that is not sending so flush
    //
    if (BundleRecvInfo->AssemblyCount >
        (MAX_RECVDESC_COUNT + BundleCB->ulLinkCBCount)) {
        
        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
        ("%x AssemblyCount %d > %d", BundleCB,
         BundleRecvInfo->AssemblyCount, MAX_RECVDESC_COUNT + BundleCB->ulLinkCBCount));

        //
        // Flush the recv desc assembly window.
        //
        FlushRecvDescWindow(BundleCB, Class);
    }
}

VOID
UpdateMinRecvSeqNumber(
    PBUNDLECB   BundleCB,
    UINT        Class
    )
{
    PBUNDLE_RECV_INFO   BundleRecvInfo;
    PLINK_RECV_INFO     LinkRecvInfo;
    PLINKCB LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;

    BundleRecvInfo = &BundleCB->RecvInfo[Class];
    LinkRecvInfo = &LinkCB->RecvInfo[Class];

    NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV,
    ("MinReceived c %x", BundleRecvInfo->MinSeqNumber));

    BundleRecvInfo->MinSeqNumber = LinkRecvInfo->LastSeqNumber;

    for (LinkCB = (PLINKCB)LinkCB->Linkage.Flink;
        (PVOID)LinkCB != (PVOID)&BundleCB->LinkCBList;
        LinkCB = (PLINKCB)LinkCB->Linkage.Flink) {
        LinkRecvInfo = &LinkCB->RecvInfo[Class];

        if (SEQ_LT(LinkRecvInfo->LastSeqNumber,
                   BundleRecvInfo->MinSeqNumber,
                   BundleCB->RecvSeqTest)) {
            BundleRecvInfo->MinSeqNumber = LinkRecvInfo->LastSeqNumber;
        }
    }

    NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV,
    ("MinReceived n %x", BundleRecvInfo->MinSeqNumber));
}

VOID
FindHoleInRecvList(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc,
    UINT        Class
    )
/*++

Routine Name:

Routine Description:

    We want to start at the spot where the current hole was removed
    from and look for adjoining recv desc's in the list who have
    sequence numbers that differ by more than 1.

Arguments:

Return Values:

--*/
{
    PRECV_DESC  NextRecvDesc, RecvDescHole;
    ULONG       SequenceNumber;
    PLIST_ENTRY RecvList;
    PBUNDLE_RECV_INFO   BundleRecvInfo;

    BundleRecvInfo = &BundleCB->RecvInfo[Class];

    RecvDescHole = BundleRecvInfo->RecvDescHole;

    RecvList = &BundleRecvInfo->AssemblyList;

    NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV,
    ("h: %x", RecvDescHole->SequenceNumber));

    if (IsListEmpty(RecvList)) {
        //
        // Set the new sequence number
        //
        RecvDescHole->SequenceNumber += 1;
        RecvDescHole->SequenceNumber &= BundleCB->RecvSeqMask;

        //
        // Put the hole back on the list
        //
        InsertHeadList(RecvList, &RecvDescHole->Linkage);

    } else {

        //
        // Walk the list looking for two descriptors that have
        // sequence numbers differing by more than 1 or until we
        // get to the end of the list
        //
        NextRecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;
        SequenceNumber = RecvDesc->SequenceNumber;

        while (((PVOID)NextRecvDesc != (PVOID)RecvList) &&
               (((NextRecvDesc->SequenceNumber - RecvDesc->SequenceNumber) &
               BundleCB->RecvSeqMask) == 1)) {
            
            RecvDesc = NextRecvDesc;
            NextRecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;
            SequenceNumber = RecvDesc->SequenceNumber;
        }

        RecvDescHole->SequenceNumber = SequenceNumber + 1;
        RecvDescHole->SequenceNumber &= BundleCB->RecvSeqMask;

        RecvDescHole->Linkage.Flink = (PLIST_ENTRY)NextRecvDesc;
        RecvDescHole->Linkage.Blink = (PLIST_ENTRY)RecvDesc;

        RecvDesc->Linkage.Flink =
        NextRecvDesc->Linkage.Blink =
            (PLIST_ENTRY)RecvDescHole;
    }

    NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("nh: %x", RecvDescHole->SequenceNumber));
}

VOID
FlushRecvDescWindow(
    IN  PBUNDLECB   BundleCB,
    IN  UINT        Class
    )
/*++

Routine Name:

    FlushRecvDescWindow

Routine Description:

    This routine is called to flush recv desc's from the assembly list when
    a fragment loss is detected.  The idea is to flush fragments until we find
    a begin fragment that has a sequence number >= the minimum received fragment
    on the bundle.

Arguments:

--*/
{
    PRECV_DESC  RecvDescHole;
    PRECV_DESC  TempDesc;
    PBUNDLE_RECV_INFO   BundleRecvInfo;

    BundleRecvInfo = &BundleCB->RecvInfo[Class];

    RecvDescHole = BundleRecvInfo->RecvDescHole;

    //
    // Remove all recvdesc's until we find the hole
    //
    while (!IsListEmpty(&BundleRecvInfo->AssemblyList)) {

        TempDesc = (PRECV_DESC)
            RemoveHeadList(&BundleRecvInfo->AssemblyList);

        if (TempDesc == RecvDescHole) {
            break;
        }

        BundleRecvInfo->FragmentsLost++;

        BundleRecvInfo->AssemblyCount--;

        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
        ("flw %x %x h: %x", TempDesc->SequenceNumber,
        TempDesc->Flags, RecvDescHole->SequenceNumber));

        NdisWanFreeRecvDesc(TempDesc);
    }

    BundleCB->Stats.FramingErrors++;

    //
    // Now flush all recvdesc's until we find a begin fragment that has a
    // sequence number >= M or the list is empty.
    //
    while (!IsListEmpty(&BundleRecvInfo->AssemblyList)) {

        TempDesc = (PRECV_DESC)
            BundleRecvInfo->AssemblyList.Flink;

        if (TempDesc->Flags & MULTILINK_BEGIN_FRAME) {
            break;
        }

        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
        ("flw %x %x h: %x", TempDesc->SequenceNumber,
        TempDesc->Flags, RecvDescHole->SequenceNumber));

        RecvDescHole->SequenceNumber = TempDesc->SequenceNumber;

        RemoveHeadList(&BundleRecvInfo->AssemblyList);

        BundleRecvInfo->AssemblyCount--;
        BundleRecvInfo->FragmentsLost++;

        NdisWanFreeRecvDesc(TempDesc);
        TempDesc = NULL;
    }

    //
    // Now reinsert the hole desc.
    //
    NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
    ("h: %x", RecvDescHole->SequenceNumber));

    FindHoleInRecvList(BundleCB, TempDesc, Class);

    NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
    ("nh: %x", RecvDescHole->SequenceNumber));

    //
    // See if we can complete some frames!!!!
    //
    TryToAssembleFrame(BundleCB, Class);
}

VOID
FlushAssemblyLists(
    IN  PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PRECV_DESC  RecvDesc;
    UINT        Class;

    for (Class = 0; Class < MAX_MCML; Class++) {
        PBUNDLE_RECV_INFO RecvInfo = &BundleCB->RecvInfo[Class];
        
        while (!IsListEmpty(&RecvInfo->AssemblyList)) {
    
            RecvDesc = (PRECV_DESC)RemoveHeadList(&RecvInfo->AssemblyList);
            RecvInfo->AssemblyCount--;
            if (RecvDesc->Flags != MULTILINK_HOLE_FLAG) {
                NdisWanFreeRecvDesc(RecvDesc);
            }
        }
    }
}

VOID
TryToAssembleFrame(
    PBUNDLECB   BundleCB,
    UINT        Class
    )
/*++

Routine Name:

    TryToAssembleFrame

Routine Description:

    The goal here is to walk the recv list looking for a full frame
    (BeginFlag, EndFlag, no holes in between).  If we do not have a
    full frame we return FALSE.

    If we have a full frame we remove each desc from the assembly list
    copying the data into the first desc and returning all of the desc's
    except the first one to the free pool.  Once all of the data had been
    collected we process the frame.  After the frame has been processed
    we return the first desc to the free pool.

Arguments:

Return Values:

--*/
{
    PRECV_DESC  RecvDesc, RecvDescHole;
    PUCHAR      DataPointer;
    LINKCB      LinkCB;
    PBUNDLE_RECV_INFO   BundleRecvInfo;

    BundleRecvInfo = &BundleCB->RecvInfo[Class];

    RecvDesc = (PRECV_DESC)BundleRecvInfo->AssemblyList.Flink;
    RecvDescHole = BundleRecvInfo->RecvDescHole;

TryToAssembleAgain:

    while ((RecvDesc != RecvDescHole) &&
           (RecvDesc->Flags & MULTILINK_BEGIN_FRAME)) {

        PRECV_DESC  NextRecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;

        DataPointer = RecvDesc->CurrentBuffer + RecvDesc->CurrentLength;

        while ((NextRecvDesc != RecvDescHole) &&
               !(RecvDesc->Flags & MULTILINK_END_FRAME)) {

            RemoveEntryList(&NextRecvDesc->Linkage);
            BundleRecvInfo->AssemblyCount--;

            ASSERT(NextRecvDesc != RecvDescHole);
            ASSERT(RecvDesc != RecvDescHole);

            NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("c 0x%x -> 0x%x",
            NextRecvDesc->SequenceNumber, RecvDesc->SequenceNumber));

            NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("fl 0x%x -> 0x%x",
            NextRecvDesc->Flags, RecvDesc->Flags));

            NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("l %d -> %d",
            NextRecvDesc->CurrentLength, RecvDesc->CurrentLength));

            //
            // Update recvdesc info
            //
            RecvDesc->Flags |= NextRecvDesc->Flags;
            RecvDesc->SequenceNumber = NextRecvDesc->SequenceNumber;
            RecvDesc->CurrentLength += NextRecvDesc->CurrentLength;

            //
            // Make sure we don't assemble something too big!
            //
            if (RecvDesc->CurrentLength > (LONG)glMRRU) {

                NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
                ("Max receive size exceeded!"));

                //
                // Return the recv desc's
                //
                RemoveEntryList(&RecvDesc->Linkage);
                BundleRecvInfo->AssemblyCount--;

                BundleCB->Stats.FramingErrors++;

                NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
                ("dumping %x %x h: %x", RecvDesc->SequenceNumber,
                RecvDesc->Flags, RecvDescHole->SequenceNumber));

                NdisWanFreeRecvDesc(RecvDesc);

                NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
                ("dumping %x %x h: %x", NextRecvDesc->SequenceNumber,
                NextRecvDesc->Flags, RecvDescHole->SequenceNumber));

                NdisWanFreeRecvDesc(NextRecvDesc);

                //
                // Start at the list head and flush until we find either the hole
                // or a new begin fragment.
                //
                RecvDesc = (PRECV_DESC)BundleRecvInfo->AssemblyList.Flink;

                while (RecvDesc != RecvDescHole &&
                    !(RecvDesc->Flags & MULTILINK_BEGIN_FRAME)) {
                    
                    RemoveHeadList(&BundleRecvInfo->AssemblyList);
                    BundleRecvInfo->AssemblyCount--;

                    NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
                    ("dumping %x %x h: %x", RecvDesc->SequenceNumber,
                    RecvDesc->Flags, RecvDescHole->SequenceNumber));

                    NdisWanFreeRecvDesc(RecvDesc);
                }

                goto TryToAssembleAgain;
            }

            NdisMoveMemory(DataPointer,
                           NextRecvDesc->CurrentBuffer,
                           NextRecvDesc->CurrentLength);

            DataPointer += NextRecvDesc->CurrentLength;

            NdisWanFreeRecvDesc(NextRecvDesc);

            NextRecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;
        }

        //
        // We hit a hole before completion of the frame.
        // Get out.
        //
        if (!IsCompleteFrame(RecvDesc->Flags)) {
            return;
        }

        //
        // If we made it here we must have a begin flag, end flag, and
        // no hole in between. Let's build a frame.
        //
        RecvDesc = (PRECV_DESC)
            RemoveHeadList(&BundleRecvInfo->AssemblyList);

        BundleRecvInfo->AssemblyCount--;

        NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("a %x %x", RecvDesc->SequenceNumber, RecvDesc->Flags));

        RecvDesc->LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;

        if (NDIS_STATUS_PENDING != ProcessPPPFrame(BundleCB, RecvDesc)) {
            NdisWanFreeRecvDesc(RecvDesc);
        }

        RecvDesc = (PRECV_DESC)BundleRecvInfo->AssemblyList.Flink;

    } // end of while MULTILINK_BEGIN_FRAME
}

BOOLEAN
DoVJDecompression(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    )
{
    ULONG   BundleFraming;
    PUCHAR  FramePointer = RecvDesc->CurrentBuffer;
    LONG    FrameLength = RecvDesc->CurrentLength;
    UCHAR   VJCompType = 0;
    BOOLEAN DoDecomp = FALSE;
    BOOLEAN VJDetect = FALSE;

    BundleFraming = BundleCB->FramingInfo.RecvFramingBits;

    if (BundleFraming & SLIP_FRAMING) {

        VJCompType = *FramePointer & 0xF0;

        //
        // If the packet is compressed the header has to be atleast 3 bytes long.
        // If this is a regular IP packet we do not decompress it.
        //
        if ((FrameLength > 2) && (VJCompType != TYPE_IP)) {

            if (VJCompType & 0x80) {

                VJCompType = TYPE_COMPRESSED_TCP;
                
            } else if (VJCompType == TYPE_UNCOMPRESSED_TCP) {

                *FramePointer &= 0x4F;
            }

            //
            // If framing is set for detection, in order for this to be a good
            // frame for detection we need a type of UNCOMPRESSED_TCP and a
            // frame that is atleast 40 bytes long.
            //
            VJDetect = ((BundleFraming & SLIP_VJ_AUTODETECT) &&
                        (VJCompType == TYPE_UNCOMPRESSED_TCP) &&
                        (FrameLength > 39));

            if ((BundleFraming & SLIP_VJ_COMPRESSION) || VJDetect) {

                //
                // If VJ compression is set or if we are in
                // autodetect and this looks like a reasonable
                // frame
                //
                DoDecomp = TRUE;
                
            }
        }

    // end of SLIP_FRAMING
    } else {

        //
        // Must be PPP framing
        //
        if (RecvDesc->ProtocolID == PPP_PROTOCOL_COMPRESSED_TCP) {
            VJCompType = TYPE_COMPRESSED_TCP;
        } else {
            VJCompType = TYPE_UNCOMPRESSED_TCP;
        }

        DoDecomp = TRUE;
    }

    if (DoDecomp) {
        PUCHAR  HeaderBuffer;
        LONG    PostCompSize, PreCompSize;

        PreCompSize = RecvDesc->CurrentLength;

        HeaderBuffer =
            RecvDesc->StartBuffer + MAC_HEADER_LENGTH;

        if ((PostCompSize = sl_uncompress_tcp(&RecvDesc->CurrentBuffer,
                                              &RecvDesc->CurrentLength,
                                              HeaderBuffer,
                                              &RecvDesc->HeaderLength,
                                              VJCompType,
                                              BundleCB->VJCompress)) == 0) {
            
            NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE, ("Error in sl_uncompress_tcp!"));
            return(FALSE);
        }

        if (VJDetect) {
            BundleCB->FramingInfo.RecvFramingBits |= SLIP_VJ_COMPRESSION;
            BundleCB->FramingInfo.SendFramingBits |= SLIP_VJ_COMPRESSION;
        }

        ASSERT(PostCompSize == RecvDesc->HeaderLength + RecvDesc->CurrentLength);

#if DBG
        if (VJCompType == TYPE_COMPRESSED_TCP) {
            ASSERT(RecvDesc->HeaderLength > 0);
            NdisWanDbgOut(DBG_TRACE, DBG_RECV_VJ,("rvj b %d a %d",(RecvDesc->HeaderLength - (PostCompSize-PreCompSize)), RecvDesc->HeaderLength));
        }
#endif

        //
        // Calculate how much expansion we had
        //
        BundleCB->Stats.BytesReceivedCompressed +=
            (RecvDesc->HeaderLength - (PostCompSize - PreCompSize));

        BundleCB->Stats.BytesReceivedUncompressed += RecvDesc->HeaderLength;

    }

    RecvDesc->ProtocolID = PPP_PROTOCOL_IP;

    return(TRUE);
}

#define SEQ_TYPE_IN_ORDER           1
#define SEQ_TYPE_AFTER_EXPECTED     2
#define SEQ_TYPE_BEFORE_EXPECTED    3


BOOLEAN
DoDecompDecryptProcessing(
    PBUNDLECB   BundleCB,
    PUCHAR      *DataPointer,
    PLONG       DataLength
    )
{
    USHORT              Coherency, CurrCoherency;
    ULONG               Flags;
    PWAN_STATS          BundleStats;
    PUCHAR              FramePointer = *DataPointer;
    LONG                FrameLength = *DataLength;

    ULONG               PacketSeqType;
    LONG                OutOfOrderDepth;
    LONG                NumberMissed;


    Flags = BundleCB->RecvFlags;

    BundleStats = &BundleCB->Stats;

    if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {
        PUCHAR  SessionKey = BundleCB->RecvCryptoInfo.SessionKey;
        ULONG   SessionKeyLength = BundleCB->RecvCryptoInfo.SessionKeyLength;
        PVOID   RecvRC4Key = BundleCB->RecvCryptoInfo.RC4Key;
        PVOID   RecvCompressContext = BundleCB->RecvCompressContext;
        BOOLEAN SyncCoherency = FALSE;

        //
        // Get the coherency counter
        //
        Coherency = (*FramePointer << 8) | *(FramePointer + 1);
        FramePointer += 2;
        FrameLength -= 2;

        if (FrameLength <= 0) {
            goto RESYNC;
        }

        if (!(Flags & DO_HISTORY_LESS))
        {
            // history-based
            if (SEQ_LT(Coherency & 0x0FFF,
                BundleCB->RCoherencyCounter & 0x0FFF,
                0x0800)) {
                //
                // We received a sequence number that is less then the
                // expected sequence number so we must be way out of sync
                //
                NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_RECEIVE,
                    ("Recv old frame!!!! b %p rc %x < ec %x!!!!", BundleCB, Coherency & 0x0FFF,
                    BundleCB->RCoherencyCounter & 0x0FFF));
                goto RESYNC;
            }
        }
        else
        {
            // history-less
            if((Coherency & 0x0FFF) == (BundleCB->RCoherencyCounter & 0x0FFF)) 
            {
                PacketSeqType = SEQ_TYPE_IN_ORDER;
            }
            else
            {
                if (SEQ_GT(Coherency & 0x0FFF,
                    BundleCB->RCoherencyCounter & 0x0FFF,
                    0x0800)) 
                {
                    PacketSeqType = SEQ_TYPE_BEFORE_EXPECTED;
                    NumberMissed = ((Coherency & 0x0FFF) - (BundleCB->RCoherencyCounter & 0x0FFF)) & 0x0FFF;
                    ASSERT(NumberMissed > 0);
                }
                else 
                {
                    OutOfOrderDepth = ((BundleCB->RCoherencyCounter & 0x0FFF) - (Coherency & 0x0FFF)) & 0x0FFF;
                    if(OutOfOrderDepth <= (LONG)glMaxOutOfOrderDepth)
                    {
                        PacketSeqType = SEQ_TYPE_AFTER_EXPECTED;
                    }
                    else
                    {
                        //
                        // We received a sequence number that is either too earlier or too later
                        //
                        NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE,
                            ("Recv frame way out of order! b %p rc %x < ec %x!!!!", BundleCB, Coherency & 0x0FFF,
                            BundleCB->RCoherencyCounter & 0x0FFF));
                        return (FALSE);
                    }
                }
            }
        }

        //
        // See if this is a flush packet
        //
        if (Coherency & (PACKET_FLUSHED << 8)) {

            NdisWanDbgOut(DBG_INFO, DBG_RECEIVE,
            ("Recv Packet Flushed 0x%x", (Coherency & 0x0FFF)));

            SyncCoherency = TRUE;

            if ((Flags & DO_ENCRYPTION) &&
                !(Flags & DO_HISTORY_LESS)) {
        
                //
                // Re-Init the rc4 receive table
                //
                rc4_key(RecvRC4Key,
                        SessionKeyLength,
                        SessionKey);
            }
        
            if (Flags & DO_COMPRESSION) {
        
                //
                // Initialize the decompression history table
                //
                initrecvcontext(RecvCompressContext);
            }
        }  // end of packet flushed

        //
        // If we are in history-less mode and we get out of sync
        // we need to recreate all of the interim encryption
        // keys that we missed, cache the keys 
        // When a packet comes in later, look for the cached key 
        //
        if ((Flags & DO_HISTORY_LESS) &&
            PacketSeqType != SEQ_TYPE_IN_ORDER) {
            ULONG       count;
            LONG        index;
            PCACHED_KEY pKey;

            if(PacketSeqType == SEQ_TYPE_AFTER_EXPECTED)
            {
                if (Coherency & (PACKET_ENCRYPTED << 8)) 
                {
                    // This packet is encrypted
                    if (!(Flags & DO_ENCRYPTION)) {
                        //
                        // We are not configured to decrypt
                        //
                        return (FALSE);
                    }

                    // Find the cached key for this packet
                    pKey = BundleCB->RecvCryptoInfo.pCurrKey;
                    for(count = 0; count < glCachedKeyCount; count++)
                    {
                        // Walk through the keys
                        if(pKey > (PCACHED_KEY)BundleCB->RecvCryptoInfo.CachedKeyBuffer)
                        {
                            pKey = (PCACHED_KEY)((PUCHAR)pKey - (sizeof(USHORT)+ SessionKeyLength));
                        }
                        else
                        {
                            pKey = (PCACHED_KEY)BundleCB->RecvCryptoInfo.pLastKey;
                        }

                        if(pKey->Coherency == (Coherency & 0x0FFF))
                        {
                            //
                            // Re-Init the rc4 receive table
                            //
                            rc4_key(RecvRC4Key,
                                    SessionKeyLength,
                                    pKey->SessionKey);
                            pKey->Coherency = 0xffff;       // avoid duplication
                            
                            //
                            // Decrypt the data!
                            //
                            rc4(RecvRC4Key,
                                FrameLength,
                                FramePointer);

                            goto DECOMPRESS_DATA;
                        }
                    }

                    // Can't recover this packet, drop it
                    return (FALSE);
                }

                goto DECOMPRESS_DATA;
            }

            // This packet comes earlier than expected

            SyncCoherency = TRUE;

            if (Flags & DO_ENCRYPTION) {

#ifdef DBG_ECP
            DbgPrint("NDISWAN: Missed %d frames, regening keys...\n", NumberMissed);
            DbgPrint("NDISWAN: resync b %p rc %x ec %x\n", BundleCB, Coherency & 0x0FFF,
                BundleCB->RCoherencyCounter & 0x0FFF);
#endif

                CurrCoherency = BundleCB->RCoherencyCounter & 0x0FFF;
    
                while (NumberMissed--) {
                    
                    if (Flags & DO_LEGACY_ENCRYPTION) {
                        
                        //
                        // Change the session key
                        //
                        SessionKey[3] += 1;
                        SessionKey[4] += 3;
                        SessionKey[5] += 13;
                        SessionKey[6] += 57;
                        SessionKey[7] += 19;
    
                    } else {
    
                        //
                        // Change the session key
                        //
                        GetNewKeyFromSHA(&BundleCB->RecvCryptoInfo);
                    }
    
    
                    //
                    // We use rc4 to scramble and recover a new key
                    //
    
                    //
                    // Re-initialize the rc4 receive table to the
                    // intermediate value
                    //
                    rc4_key(RecvRC4Key, SessionKeyLength, SessionKey);
                
                    //
                    // Scramble the existing session key
                    //
                    rc4(RecvRC4Key, SessionKeyLength, SessionKey);
    
                    if (Flags & DO_40_ENCRYPTION) {
                        
                        //
                        // If this is 40 bit encryption we need to fix
                        // the first 3 bytes of the key.
                        //
                        SessionKey[0] = 0xD1;
                        SessionKey[1] = 0x26;
                        SessionKey[2] = 0x9E;
                
                    } else if (Flags & DO_56_ENCRYPTION) {
                        //
                        // If this is 56 bit encryption we need to fix
                        // the first byte of the key.
                        //
                        SessionKey[0] = 0xD1;
                    }
    
                    if(NumberMissed < (LONG)glCachedKeyCount)
                    {
                        BundleCB->RecvCryptoInfo.pCurrKey->Coherency = CurrCoherency;
                        NdisMoveMemory(BundleCB->RecvCryptoInfo.pCurrKey->SessionKey, 
                            SessionKey,
                            SessionKeyLength);
    
                        if(BundleCB->RecvCryptoInfo.pCurrKey < BundleCB->RecvCryptoInfo.pLastKey)
                        {
                            BundleCB->RecvCryptoInfo.pCurrKey = (PCACHED_KEY)((PUCHAR)BundleCB->RecvCryptoInfo.pCurrKey + 
                                sizeof(USHORT) + SessionKeyLength);
                            ASSERT(BundleCB->RecvCryptoInfo.pCurrKey <= BundleCB->RecvCryptoInfo.pLastKey);
                        }
                        else
                        {
                            BundleCB->RecvCryptoInfo.pCurrKey = (PCACHED_KEY)BundleCB->RecvCryptoInfo.CachedKeyBuffer;
                        }
                    }
    
                    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                    ("RC4 Recv encryption KeyLength %d", BundleCB->RecvCryptoInfo.SessionKeyLength));
                    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                    ("RC4 Recv encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
                        BundleCB->RecvCryptoInfo.SessionKey[0],
                        BundleCB->RecvCryptoInfo.SessionKey[1],
                        BundleCB->RecvCryptoInfo.SessionKey[2],
                        BundleCB->RecvCryptoInfo.SessionKey[3],
                        BundleCB->RecvCryptoInfo.SessionKey[4],
                        BundleCB->RecvCryptoInfo.SessionKey[5],
                        BundleCB->RecvCryptoInfo.SessionKey[6],
                        BundleCB->RecvCryptoInfo.SessionKey[7],
                        BundleCB->RecvCryptoInfo.SessionKey[8],
                        BundleCB->RecvCryptoInfo.SessionKey[9],
                        BundleCB->RecvCryptoInfo.SessionKey[10],
                        BundleCB->RecvCryptoInfo.SessionKey[11],
                        BundleCB->RecvCryptoInfo.SessionKey[12],
                        BundleCB->RecvCryptoInfo.SessionKey[13],
                        BundleCB->RecvCryptoInfo.SessionKey[14],
                        BundleCB->RecvCryptoInfo.SessionKey[15]));
    
                    // Re-initialize the rc4 receive table to the
                    // scrambled session key
                    //
                    rc4_key(RecvRC4Key, SessionKeyLength, SessionKey);
    
                    if(CurrCoherency < (USHORT)0x0FFF)
                    {
                        ++CurrCoherency;
                    }
                    else
                    {
                        CurrCoherency = 0;
                    }
                }
            }
        }

        if (SyncCoherency) {
            if ((BundleCB->RCoherencyCounter & 0x0FFF) >
                (Coherency & 0x0FFF)) {
                BundleCB->RCoherencyCounter += 0x1000;
            }
            
            BundleCB->RCoherencyCounter &= 0xF000;
            BundleCB->RCoherencyCounter |= (Coherency & 0x0FFF);
        }

        if ((Coherency & 0x0FFF) == (BundleCB->RCoherencyCounter & 0x0FFF)) {

            //
            // We are still in sync
            //

            BundleCB->RCoherencyCounter++;

            if (Coherency & (PACKET_ENCRYPTED << 8)) {

                //
                // This packet is encrypted
                //

                if (!(Flags & DO_ENCRYPTION)) {
                    //
                    // We are not configured to decrypt
                    //
                    return (FALSE);
                }

                //
                // Check for history less
                //

                if ((Flags & DO_HISTORY_LESS) ||
                    (BundleCB->RCoherencyCounter - BundleCB->LastRC4Reset)
                     >= 0x100) {
            
                    //
                    // It is time to change encryption keys
                    //
            
                    //
                    // Always align last reset on 0x100 boundary so as not to
                    // propagate error!
                    //
                    BundleCB->LastRC4Reset =
                        BundleCB->RCoherencyCounter & 0xFF00;
            
                    //
                    // Prevent ushort rollover
                    //
                    if ((BundleCB->LastRC4Reset & 0xF000) == 0xF000) {
                        BundleCB->LastRC4Reset &= 0x0FFF;
                        BundleCB->RCoherencyCounter &= 0x0FFF;
                    }

                    if (Flags & DO_LEGACY_ENCRYPTION) {
                        
                        //
                        // Change the session key
                        //
                        SessionKey[3] += 1;
                        SessionKey[4] += 3;
                        SessionKey[5] += 13;
                        SessionKey[6] += 57;
                        SessionKey[7] += 19;

                    } else {

                        //
                        // Change the session key
                        //
                        GetNewKeyFromSHA(&BundleCB->RecvCryptoInfo);
                    }


                    //
                    // We use rc4 to scramble and recover a new key
                    //

                    //
                    // Re-initialize the rc4 receive table to the
                    // intermediate value
                    //
                    rc4_key(RecvRC4Key, SessionKeyLength, SessionKey);
                
                    //
                    // Scramble the existing session key
                    //
                    rc4(RecvRC4Key, SessionKeyLength, SessionKey);

                    //
                    // If this is 40 bit encryption we need to fix
                    // the first 3 bytes of the key.
                    //

                    if (Flags & DO_40_ENCRYPTION) {
                        
                        //
                        // If this is 40 bit encryption we need to fix
                        // the first 3 bytes of the key.
                        //
                        SessionKey[0] = 0xD1;
                        SessionKey[1] = 0x26;
                        SessionKey[2] = 0x9E;
                
                    } else if (Flags & DO_56_ENCRYPTION) {
                        //
                        // If this is 56 bit encryption we need to fix
                        // the first byte of the key.
                        //
                        SessionKey[0] = 0xD1;
                    }

                    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                    ("RC4 Recv encryption KeyLength %d", BundleCB->RecvCryptoInfo.SessionKeyLength));
                    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                    ("RC4 Recv encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
                        BundleCB->RecvCryptoInfo.SessionKey[0],
                        BundleCB->RecvCryptoInfo.SessionKey[1],
                        BundleCB->RecvCryptoInfo.SessionKey[2],
                        BundleCB->RecvCryptoInfo.SessionKey[3],
                        BundleCB->RecvCryptoInfo.SessionKey[4],
                        BundleCB->RecvCryptoInfo.SessionKey[5],
                        BundleCB->RecvCryptoInfo.SessionKey[6],
                        BundleCB->RecvCryptoInfo.SessionKey[7],
                        BundleCB->RecvCryptoInfo.SessionKey[8],
                        BundleCB->RecvCryptoInfo.SessionKey[9],
                        BundleCB->RecvCryptoInfo.SessionKey[10],
                        BundleCB->RecvCryptoInfo.SessionKey[11],
                        BundleCB->RecvCryptoInfo.SessionKey[12],
                        BundleCB->RecvCryptoInfo.SessionKey[13],
                        BundleCB->RecvCryptoInfo.SessionKey[14],
                        BundleCB->RecvCryptoInfo.SessionKey[15]));

                    // Re-initialize the rc4 receive table to the
                    // scrambled session key
                    //
                    rc4_key(RecvRC4Key, SessionKeyLength, SessionKey);
            
            
                } // end of reset encryption key
            
                //
                // Decrypt the data!
                //
                rc4(RecvRC4Key,
                    FrameLength,
                    FramePointer);
                
            } // end of encryption


DECOMPRESS_DATA:

            if (Coherency & (PACKET_COMPRESSED << 8)) {

                //
                // This packet is compressed!
                //
                if (!(Flags & DO_COMPRESSION)) {
                    //
                    // We are not configured to decompress
                    //
                    return (FALSE);
                }

                //
                // Add up bundle stats
                //
                BundleStats->BytesReceivedCompressed += FrameLength;

                if (decompress(FramePointer,
                               FrameLength,
                               ((Coherency & (PACKET_AT_FRONT << 8)) >> 8),
                               &FramePointer,
                               &FrameLength,
                               RecvCompressContext) == FALSE) {

#if DBG
                    DbgPrint("dce1 %x\n", Coherency);
#endif
                    //
                    // Error decompressing!
                    //
                    if (!(Flags & DO_HISTORY_LESS)) {
                        BundleCB->RCoherencyCounter--;
                    }
                    goto RESYNC;

                }

                if (FrameLength <= 0 ||
                    FrameLength > (LONG)glMRRU) {
#if DBG
                    DbgPrint("dce2 %d %x\n", FrameLength, Coherency);
#endif
                    //
                    // Error decompressing!
                    //
                    if (!(Flags & DO_HISTORY_LESS)) {
                        BundleCB->RCoherencyCounter--;
                    }
                    goto RESYNC;
                    
                }

                BundleStats->BytesReceivedUncompressed += FrameLength;
                
            } // end of compression

        } else { // end of insync
RESYNC:


            NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE, ("oos r %x, e %x\n", (Coherency & 0x0FFF),
                     (BundleCB->RCoherencyCounter & 0x0FFF)));

            if (!(Flags & DO_HISTORY_LESS)) {

                //
                // We are out of sync!
                //
                do {
                    PLINKCB             LinkCB;
                    PNDISWAN_IO_PACKET  IoPacket;

                    if (BundleCB->ulLinkCBCount == 0) {
                        break;
                    }

                    NdisWanAllocateMemory(&IoPacket, 
                                          sizeof(NDISWAN_IO_PACKET) + 100, 
                                          IOPACKET_TAG);

                    if (IoPacket == NULL) {
                        break;
                    }

                    LinkCB = 
                        (PLINKCB)BundleCB->LinkCBList.Flink;

                    NdisDprAcquireSpinLock(&LinkCB->Lock);

                    if (LinkCB->State != LINK_UP) {
                        NdisDprReleaseSpinLock(&LinkCB->Lock);
                        NdisWanFreeMemory(IoPacket);
                        break;
                    }

                    REF_LINKCB(LinkCB);

                    NdisDprReleaseSpinLock(&LinkCB->Lock);

                    IoPacket->hHandle = BundleCB->hBundleHandle;
                    IoPacket->usHandleType = BUNDLEHANDLE;
                    IoPacket->usHeaderSize = 0;
                    IoPacket->usPacketSize = 6;
                    IoPacket->usPacketFlags = 0;
                    IoPacket->PacketData[0] = 0x80;
                    IoPacket->PacketData[1] = 0xFD;
                    IoPacket->PacketData[2] = 14;
                    IoPacket->PacketData[3] = (UCHAR)BundleCB->CCPIdentifier++;
                    IoPacket->PacketData[4] = 0x00;
                    IoPacket->PacketData[5] = 0x04;

                    LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;

                    BuildIoPacket(LinkCB, BundleCB, IoPacket, FALSE);

                    NdisWanFreeMemory(IoPacket);

                } while (FALSE);
            }

            return (FALSE);

        } // end of out of sync

    } else { // end of DoCompEncrypt

        //
        // For some reason we were not able to
        // decrypt/decompress!
        //
        return (FALSE);
    }

    *DataPointer = FramePointer;
    *DataLength = FrameLength;

    return (TRUE);
}

VOID
DoCompressionReset(
    PBUNDLECB   BundleCB
    )
{
    if (BundleCB->RecvCompInfo.MSCompType != 0) {
    
        //
        // The next outgoing packet will flush
        //
        BundleCB->Flags |= RECV_PACKET_FLUSH;
    }
}

VOID
NdisWanReceiveComplete(
    IN  NDIS_HANDLE NdisLinkContext
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("NdisWanReceiveComplete: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("NdisWanReceiveComplete: Exit"));
}

BOOLEAN
IpIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    )
{
    UINT        tcpheaderlength ;
    UINT        ipheaderlength ;
    UCHAR       *tcppacket;
    UCHAR       *ippacket = HeaderBuffer;
    UCHAR       SrcPort, DstPort;
    IPV4Header UNALIGNED *ipheader = (IPV4Header UNALIGNED *) HeaderBuffer;


#define TYPE_IGMP   2
    if (ipheader->ip_p == TYPE_IGMP) {

        if (gbIGMPIdle) {
            return FALSE;
        }

        return TRUE;
    }

    SrcPort = (UCHAR) *(ippacket + ((*ippacket & 0x0f)*4) + 1);
    DstPort = (UCHAR) *(ippacket + ((*ippacket & 0x0f)*4) + 3);

    if (DstPort == 53) {
        //
        // UDP/TCP port 53 - DNS
        //
        return FALSE;
    }

#define TYPE_UDP  17

#define UDPPACKET_SRC_PORT_137(x) ((UCHAR) *(x + ((*x & 0x0f)*4) + 1) == 137)
#define UDPPACKET_SRC_PORT_138(x) ((UCHAR) *(x + ((*x & 0x0f)*4) + 1) == 138)

    if (ipheader->ip_p == TYPE_UDP) {

        if ((SrcPort == 137) ||
            (SrcPort == 138)) {
    
            //
            // UDP port 137 - NETBIOS Name Service
            // UDP port 138 - NETBIOS Datagram Service
            //
            return FALSE ;
    
        } else {
    
            return TRUE ;
    
        }
    }

#define TYPE_TCP 6
#define TCPPACKET_SRC_OR_DEST_PORT_139(x,y) (((UCHAR) *(x + y + 1) == 139) || ((UCHAR) *(x + y + 3) == 139))

    //
    // TCP packets with SRC | DEST == 139 which are ACKs (0 data) or Session Alives
    // are considered as idle
    //
    if (ipheader->ip_p == TYPE_TCP) {

        ipheaderlength = ((UCHAR)*ippacket & 0x0f)*4 ;
        tcppacket = ippacket + ipheaderlength ;
        tcpheaderlength = (*(tcppacket + 10) >> 4)*4 ;

        //
        // If this is a PPTP keepalive packet then ignore
        //
        if (DstPort == 1723) {
            UNALIGNED PPTP_HEADER *PptpHeader;

            PptpHeader = (UNALIGNED PPTP_HEADER*)(tcppacket+tcpheaderlength);

            if (PptpHeader->PacketType == 1 &&
                (PptpHeader->MessageType == 5 ||
                 PptpHeader->MessageType == 6)) {

                return FALSE;

            }

            return TRUE;
        }

        if (!((SrcPort == 139) || (DstPort == 139)))
            return TRUE ;

        //
        //  NetBT traffic
        //
    
        //
        // if zero length tcp packet - this is an ACK on 139 - filter this.
        //
        if (TotalLength == (ipheaderlength + tcpheaderlength))
            return FALSE ;
    
        //
        // Session alives are also filtered.
        //
        if ((UCHAR) *(tcppacket+tcpheaderlength) == 0x85)
            return FALSE ;

        //
        // If this is a PPTP keep alive then ignore
        //

    }

    //
    // all other ip traffic is valid traffic
    //
    return TRUE ;
}

BOOLEAN
IpxIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    )
{

/*++

Routine Description:

    This routine is called when a frame is received on a WAN
    line. It returns TRUE unless:

    - The frame is from the RIP socket
    - The frame is from the SAP socket
    - The frame is a netbios keep alive
    - The frame is an NCP keep alive

Arguments:

    HeaderBuffer - points to a contiguous buffer starting at the IPX header.

    HeaderBufferLength - Length of the header buffer (could be same as totallength)

    TotalLength  - the total length of the frame

Return Value:

    TRUE - if this is a connection-based packet.

    FALSE - otherwise.

--*/

    IPX_HEADER UNALIGNED * IpxHeader = (IPX_HEADER UNALIGNED *)HeaderBuffer;
    USHORT SourceSocket;

    //
    // First get the source socket.
    //
    SourceSocket = IpxHeader->SourceSocket;

    //
    // Not connection-based
    //
    if ((SourceSocket == RIP_SOCKET) ||
        (SourceSocket == SAP_SOCKET)) {

         return FALSE;

    }

    //
    // See if there are at least two more bytes to look at.
    //
    if (TotalLength >= sizeof(IPX_HEADER) + 2) {

        if (SourceSocket == NB_SOCKET) {

            UCHAR ConnectionControlFlag;
            UCHAR DataStreamType;
            USHORT TotalDataLength;

            //
            // ConnectionControlFlag and DataStreamType will always follow
            // IpxHeader
            //
            ConnectionControlFlag = ((PUCHAR)(IpxHeader+1))[0];
            DataStreamType = ((PUCHAR)(IpxHeader+1))[1];

            //
            // If this is a SYS packet with or without a request for ACK and
            // has session data in it.
            //
            if (((ConnectionControlFlag == 0x80) || (ConnectionControlFlag == 0xc0)) &&
                (DataStreamType == 0x06)) {

                 //
                 // TotalDataLength is in the same buffer.
                 //
                 TotalDataLength = ((USHORT UNALIGNED *)(IpxHeader+1))[4];

                //
                // KeepAlive - return FALSE
                //
                if (TotalDataLength == 0) {
                    return FALSE;
                }
            }

        } else {

            //
            // Now see if it is an NCP keep alive. It can be from rip or from
            // NCP on this machine
            //
            if (TotalLength == sizeof(IPX_HEADER) + 2) {

                UCHAR KeepAliveSignature = ((PUCHAR)(IpxHeader+1))[1];

                if ((KeepAliveSignature == '?') ||
                    (KeepAliveSignature == 'Y')) {
                    return FALSE;
                }
            }
        }
    }

    //
    // This was a normal packet, so return TRUE
    //

    return TRUE;
}

BOOLEAN
NbfIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    )
{
/*++

Routine Description:

    This routine looks at a data packet from the net to deterimine if there is
    any data flowing on the connection.

Arguments:

    HeaderBuffer - Pointer to the dlc header for this packet.

    HeaderBufferLength - Length of the header buffer (could be same as totallength)

    TotalLength  - the total length of the frame

Return Value:

    True if this is a frame that indicates data traffic on the connection.
    False otherwise.

--*/

    PDLC_FRAME  DlcHeader = (PDLC_FRAME)HeaderBuffer;
    BOOLEAN Command = (BOOLEAN)!(DlcHeader->Ssap & DLC_SSAP_RESPONSE);
    PNBF_HDR_CONNECTION nbfHeader;

    if (TotalLength < sizeof(PDLC_FRAME)) {
        return(FALSE);
    }

    if (!(DlcHeader->Byte1 & DLC_I_INDICATOR)) {

        //
        // We have an I frame.
        //

        if (TotalLength < 4 + sizeof(NBF_HDR_CONNECTION)) {

            //
            // It's a runt I-frame.
            //

            return(FALSE);
        }

        nbfHeader = (PNBF_HDR_CONNECTION) ((PUCHAR)DlcHeader + 4);

        switch (nbfHeader->Command) {
            case NBF_CMD_DATA_FIRST_MIDDLE:
            case NBF_CMD_DATA_ONLY_LAST:
            case NBF_CMD_DATA_ACK:
            case NBF_CMD_SESSION_CONFIRM:
            case NBF_CMD_SESSION_INITIALIZE:
            case NBF_CMD_NO_RECEIVE:
            case NBF_CMD_RECEIVE_OUTSTANDING:
            case NBF_CMD_RECEIVE_CONTINUE:
                return(TRUE);
                break;

            default:
                return(FALSE);
                break;
        }
    }
    return(FALSE);

}

VOID
IndicatePromiscuousRecv(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc,
    RECV_TYPE   RecvType
    )
{
    UCHAR   Header1[] = {' ', 'W', 'A', 'N', 'R', 0xFF, ' ', 'W', 'A', 'N', 'R', 0xFF};
    PUCHAR  HeaderBuffer, DataBuffer;
    ULONG   HeaderLength, DataLength;
    PNDIS_BUFFER    NdisBuffer;
    PNDIS_PACKET    NdisPacket;
    PRECV_DESC      LocalRecvDesc;
    PLINKCB         LinkCB = RecvDesc->LinkCB;
    KIRQL           OldIrql;
    PMINIPORTCB     Adapter;

    NdisAcquireSpinLock(&NdisWanCB.Lock);
    Adapter = NdisWanCB.PromiscuousAdapter;
    NdisReleaseSpinLock(&NdisWanCB.Lock);

    if (Adapter == NULL) {
        return;
    }

    DataLength = (RecvDesc->CurrentLength > (LONG)glLargeDataBufferSize) ? 
        glLargeDataBufferSize : RecvDesc->CurrentLength;

    LocalRecvDesc = 
        NdisWanAllocateRecvDesc(DataLength + MAC_HEADER_LENGTH);

    if (LocalRecvDesc == NULL) {
        return;
    }

    HeaderBuffer = 
        LocalRecvDesc->StartBuffer;

    HeaderLength = 0;

    switch (RecvType) {
    case RECV_LINK:
        NdisMoveMemory(HeaderBuffer, Header1, sizeof(Header1));
        HeaderBuffer[5] =
        HeaderBuffer[11] = (UCHAR)LinkCB->hLinkHandle;
    
        HeaderBuffer[12] = (UCHAR)(DataLength >> 8);
        HeaderBuffer[13] = (UCHAR)DataLength;
        HeaderLength = MAC_HEADER_LENGTH;
        break;

    case RECV_BUNDLE_PPP:
    case RECV_BUNDLE_DATA:
        break;
        
    }

    DataBuffer = HeaderBuffer + HeaderLength;

    NdisMoveMemory(DataBuffer,
                   RecvDesc->CurrentBuffer,
                   DataLength);

    LocalRecvDesc->CurrentBuffer = HeaderBuffer;
    LocalRecvDesc->CurrentLength = HeaderLength + DataLength;

    if (LocalRecvDesc->CurrentLength > 1514) {
        LocalRecvDesc->CurrentLength = 1514;
    }

    //
    // Get an ndis packet
    //
    NdisPacket =
        LocalRecvDesc->NdisPacket;

    PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->RecvDesc = LocalRecvDesc;

    //
    // Attach the buffers
    //
    NdisAdjustBufferLength(LocalRecvDesc->NdisBuffer,
                           LocalRecvDesc->CurrentLength);

    NdisRecalculatePacketCounts(NdisPacket);

    ReleaseBundleLock(BundleCB);

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    NDIS_SET_PACKET_STATUS(NdisPacket, NDIS_STATUS_RESOURCES);

    INSERT_DBG_RECV(PacketTypeNdis,
                    Adapter,
                    NULL,
                    RecvDesc->LinkCB,
                    NdisPacket);

    //
    // Indicate the packet
    // This assumes that bloodhound is always a legacy transport
    //
    NdisMIndicateReceivePacket(Adapter->MiniportHandle,
                               &NdisPacket,
                               1);

    KeLowerIrql(OldIrql);

    AcquireBundleLock(BundleCB);

#if DBG
    {
    NDIS_STATUS     Status;

    Status = NDIS_GET_PACKET_STATUS(NdisPacket);

    ASSERT(Status == NDIS_STATUS_RESOURCES);

    REMOVE_DBG_RECV(PacketTypeNdis, Adapter, NdisPacket);

    }
#endif


    {
        PNDIS_BUFFER    NdisBuffer;

        NdisWanFreeRecvDesc(LocalRecvDesc);
    }

}

BOOLEAN
GetProtocolFromPPPId(
    PBUNDLECB   BundleCB,
    USHORT      Id,
    PPROTOCOLCB *ProtocolCB
    )
{
    PPROTOCOLCB     ppcb;
    BOOLEAN         Found;

    *ProtocolCB = NULL;

    ppcb = (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;
    Found = FALSE;

    while ((PVOID)ppcb != (PVOID)&BundleCB->ProtocolCBList) {

        if (ppcb->State == PROTOCOL_ROUTED) {
            if (ppcb->PPPProtocolID == Id) {
                *ProtocolCB = ppcb;
                Found = TRUE;
                break;
            }
        }

        ppcb = (PPROTOCOLCB)ppcb->Linkage.Flink;
    }

    return (Found);
}

#ifdef NT

NDIS_STATUS
CompleteIoRecvPacket(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    )
{
    KIRQL       Irql;
    USHORT      ProtocolID;
    UCHAR       Header[] = {' ', 'R', 'E', 'C', 'V', 0xFF};
    PNDISWAN_IO_PACKET  IoPacket;
    PIO_STACK_LOCATION IrpSp;
    PIRP    Irp;
    LONG    CopySize, BufferLength, DataLength;
    PLIST_ENTRY Entry;
    PUCHAR  HeaderPointer;
    PLINKCB LinkCB = RecvDesc->LinkCB;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("CompleteIoRecvPacket: Enter"));

    HeaderPointer = 
        RecvDesc->StartBuffer;

    ProtocolID = RecvDesc->ProtocolID;

    //
    // Fill the frame out, and queue the data
    //
    NdisMoveMemory(HeaderPointer,
                   Header,
                   sizeof(Header));

    NdisMoveMemory(&HeaderPointer[6],
                   Header,
                   sizeof(Header));

    HeaderPointer[5] =
    HeaderPointer[11] = (UCHAR)LinkCB->hLinkHandle;

    HeaderPointer[12] = (UCHAR)(ProtocolID >> 8);
    HeaderPointer[13] = (UCHAR)ProtocolID;

    NdisMoveMemory(HeaderPointer + 14,
                   RecvDesc->CurrentBuffer,
                   RecvDesc->CurrentLength);

    RecvDesc->CurrentBuffer = RecvDesc->StartBuffer;
    RecvDesc->CurrentLength += 14;

#if DBG
if (gbDumpRecv) {
    
    INT i;
    DbgPrint("RecvData:");
    for (i = 0; i < RecvDesc->CurrentLength; i++) {
        if (i % 16 == 0) {
            DbgPrint("\n");
        }
        DbgPrint("%2.2x ", RecvDesc->CurrentBuffer[i]);
    }
    DbgPrint("\n");
}
#endif

    ReleaseBundleLock(BundleCB);

    //
    // See if someone has registered a recv context
    // for this link or if there are any irps around
    // to complete take this receive
    //

    NdisAcquireSpinLock(&IoRecvList.Lock);

    NdisDprAcquireSpinLock(&LinkCB->Lock);

    Entry = IoRecvList.IrpList.Flink;
    Irp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

    if ((LinkCB->hLinkContext == NULL) ||
        (LinkCB->RecvDescCount > 0) ||
        (IoRecvList.ulIrpCount == 0) ||
        !IoSetCancelRoutine(Irp, NULL)) {
        NDIS_STATUS Status;

        //
        // We will only buffer 5 packets for each link to avoid
        // chewing up tons of non-paged memory if rasman is not
        // reading at all.
        //
        if ((LinkCB->State == LINK_UP) &&
            (LinkCB->RecvDescCount < 5)) {
            
            InsertTailList(&IoRecvList.DescList,
                           &RecvDesc->Linkage);

            LinkCB->RecvDescCount++;

            IoRecvList.ulDescCount++;

            if (IoRecvList.ulDescCount > IoRecvList.ulMaxDescCount) {
                IoRecvList.ulMaxDescCount = IoRecvList.ulDescCount;
            }

            Status = NDIS_STATUS_PENDING;

        } else {

            Status = NDIS_STATUS_FAILURE;
        }

        NdisDprReleaseSpinLock(&LinkCB->Lock);

        NdisReleaseSpinLock(&IoRecvList.Lock);

        AcquireBundleLock(BundleCB);

        return(Status);
    }

    RemoveHeadList(&IoRecvList.IrpList);
    IoRecvList.ulIrpCount--;

    INSERT_RECV_EVENT('a');

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
        
    BufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    DataLength = BufferLength - sizeof(NDISWAN_IO_PACKET) + 1;
        
    CopySize = (RecvDesc->CurrentLength > DataLength) ?
        DataLength : RecvDesc->CurrentLength;

    IoPacket = Irp->AssociatedIrp.SystemBuffer;
        
    IoPacket->hHandle = LinkCB->hLinkContext;
    IoPacket->usHandleType = LINKHANDLE;
    IoPacket->usHeaderSize = 14;
    IoPacket->usPacketSize = (USHORT)CopySize;
    IoPacket->usPacketFlags = 0;
    
#if DBG
if (gbDumpRecv) {
    INT i;
    for (i = 0; i < RecvDesc->CurrentLength; i++) {
        if (i % 16 == 0) {
            DbgPrint("\n");
        }
        DbgPrint("%x ", RecvDesc->CurrentBuffer[i]);
    }
    DbgPrint("\n");
}
#endif

    NdisMoveMemory(IoPacket->PacketData,
                   RecvDesc->CurrentBuffer,
                   CopySize);
    
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof(NDISWAN_IO_PACKET) - 1 + CopySize;

    IoRecvList.LastPacketNumber = IoPacket->PacketNumber;
    IoRecvList.LastIrp = Irp;
    IoRecvList.LastIrpStatus = STATUS_SUCCESS;
    IoRecvList.LastCopySize = (ULONG)Irp->IoStatus.Information;

    ASSERT((LONG_PTR)Irp->IoStatus.Information > 0);
    
    NdisDprReleaseSpinLock(&LinkCB->Lock);

    NdisReleaseSpinLock(&IoRecvList.Lock);

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    
    AcquireBundleLock(BundleCB);

    if (NdisWanCB.PromiscuousAdapter != NULL) {
    
        IndicatePromiscuousRecv(BundleCB, RecvDesc, RECV_BUNDLE_PPP);
    }
        
    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("CompleteIoRecvPacket: Exit"));

    return(NDIS_STATUS_SUCCESS);
}


#endif // end ifdef NT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\protocol.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Protocol.c

Abstract:

    This file contains the procedures that makeup most of the NDIS 4.0/5.0
    Protocol interface.  This interface is what NdisWan exposes to the
    WAN Miniports below.  NdisWan is not really a protocol and does not
    do TDI, but is a shim that sits between the protocols and the
    WAN Miniport drivers.


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#define __FILE_SIG__    PROTOCOL_FILESIG

#ifdef DBG_SENDARRAY
extern UCHAR SendArray[];
extern ULONG __si;
#endif

EXPORT
VOID
NdisTapiRegisterProvider(
    IN  NDIS_HANDLE,
    IN  PNDISTAPI_CHARACTERISTICS
    );

EXPORT
VOID
NdisTapiDeregisterProvider(
    IN  NDIS_HANDLE
    );

EXPORT
VOID
NdisTapiIndicateStatus(
    IN  NDIS_HANDLE BindingContext,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferLength
);

//
// Local functions...
//

VOID
CompleteSendDesc(
    PSEND_DESC  SendDesc,
    NDIS_STATUS Status
    );

VOID
CloseWanAdapterWorker(
    PNDIS_WORK_ITEM WorkItem,
    POPENCB pOpenCB
    );

#if 0
ULONG
CalcPPPHeaderLength(
    ULONG   FramingBits,
    ULONG   Flags
    );

#endif    

//
// Common functions used by both 4.0 and 5.0 miniports
//

NDIS_STATUS
ProtoOpenWanAdapter(
    IN  POPENCB pOpenCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS     Status, OpenErrorStatus;
    ULONG           SelectedMediumIndex;
    NDIS_MEDIUM     MediumArray[] = {NdisMediumWan, NdisMediumAtm, NdisMediumCoWan};

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoOpenAdapter: Enter - AdapterName %ls", pOpenCB->MiniportName.Buffer));

    //
    // This is the only initialization of this event
    //
    NdisWanInitializeNotificationEvent(&pOpenCB->NotificationEvent);

    NdisOpenAdapter(&Status,
                    &OpenErrorStatus,
                    &(pOpenCB->BindingHandle),
                    &SelectedMediumIndex,
                    MediumArray,
                    sizeof(MediumArray) / sizeof(NDIS_MEDIUM),
                    NdisWanCB.ProtocolHandle,
                    (NDIS_HANDLE)pOpenCB,
                    &(pOpenCB->MiniportName),
                    0,
                    NULL);

    if (Status == NDIS_STATUS_PENDING) {

        NdisWanWaitForNotificationEvent(&pOpenCB->NotificationEvent);

        Status = pOpenCB->NotificationStatus;

        NdisWanClearNotificationEvent(&pOpenCB->NotificationEvent);
    }

    if (Status == NDIS_STATUS_SUCCESS) {
        pOpenCB->MediumType = MediumArray[SelectedMediumIndex];
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoOpenAdapter: Exit"));

    return (Status);
}

//
// Enter with the opencb->lock held, exit with the lock released!
//
NDIS_STATUS
ProtoCloseWanAdapter(
    IN  POPENCB pOpenCB
)
{
    NDIS_STATUS Status;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoCloseWanAdapter: Enter %p", pOpenCB));

    pOpenCB->Flags |= OPEN_CLOSING;

    NdisReleaseSpinLock(&pOpenCB->Lock);

    //
    // NdisCloseAdapter must be called at IRQL PASSIVE_LEVEL!
    //
    if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

        NdisAcquireSpinLock(&pOpenCB->Lock);

        ASSERT(!(pOpenCB->Flags & CLOSE_SCHEDULED));

        NdisInitializeWorkItem(&pOpenCB->WorkItem,
                               CloseWanAdapterWorker,
                               pOpenCB);

        NdisScheduleWorkItem(&pOpenCB->WorkItem);

        pOpenCB->Flags |= CLOSE_SCHEDULED;

        NdisReleaseSpinLock(&pOpenCB->Lock);

        return (NDIS_STATUS_PENDING);
    }


    NdisCloseAdapter(&Status,
                     pOpenCB->BindingHandle);

    if (Status != NDIS_STATUS_PENDING) {
        ProtoCloseAdapterComplete(pOpenCB, Status);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoCloseWanAdapter: Exit"));

    return(Status);
}

VOID
CloseWanAdapterWorker(
    PNDIS_WORK_ITEM WorkItem,
    POPENCB pOpenCB
    )
{
    NDIS_STATUS Status;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("CloseWanAdapterWorker: Enter %p", pOpenCB));

    NdisCloseAdapter(&Status,
                     pOpenCB->BindingHandle);

    if (Status != NDIS_STATUS_PENDING) {
        ProtoCloseAdapterComplete(pOpenCB, Status);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("CloseWanAdapterWorker: Exit"));
}

VOID
ProtoOpenAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status,
    IN  NDIS_STATUS OpenErrorStatus
    )
/*++

Routine Name:

    ProtoOpenAdapterComplete

Routine Description:

    This function is called upon completion of an open of a miniport.
    The status of the openadapter call is stored and the notification
    event is signalled.

Arguments:

Return Values:

--*/
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoOpenAdapterComplete: Enter - OpenCB 0x%p", pOpenCB));

    pOpenCB->NotificationStatus = Status;

    NdisWanSetNotificationEvent(&pOpenCB->NotificationEvent);

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoOpenAdapterComplete: Exit"));
}

VOID
ProtoCloseAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    )
/*++

Routine Name:

    ProtoCloseAdapterComplete

Routine Description:

    This function is called upon completion of a close of a miniport.
    The status of the closeadapter call is stored and the notification
    event is signalled.

Arguments:

Return Values:

--*/
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoCloseAdapterComplete: Enter - OpenCB %p", pOpenCB));

    if (pOpenCB->UnbindContext != NULL) {
        NdisCompleteUnbindAdapter(pOpenCB->UnbindContext, Status);
    }

    if (pOpenCB->Flags & OPEN_IN_BIND) {
        //
        // We are attempting to close the adapter from
        // within our bind handler.  Per AliD we must wait
        // for the close to finish before we can return
        // from the bind handler thus we have to special case
        // this code and not free the OpenCB here.
        //
        NdisWanSetNotificationEvent(&pOpenCB->NotificationEvent);
    } else {
        NdisWanFreeOpenCB(pOpenCB);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoCloseAdapterComplete: Exit"));
}

VOID
ProtoResetComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoResetComplete: Enter - OpenCB %p", pOpenCB));

    pOpenCB->NotificationStatus = Status;

    NdisWanSetNotificationEvent(&pOpenCB->NotificationEvent);

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoResetComplete: Exit"));
}

VOID
ProtoReceiveComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;
    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProtoIndicateStatus: Enter - OpenCB %8.x8\n", pOpenCB));

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProtoIndicateStatus: Exit"));
}

VOID
ProtoIndicateStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;

    switch (GeneralStatus) {
        case NDIS_STATUS_WAN_LINE_UP:
            NdisWanLineUpIndication(pOpenCB,
                                    StatusBuffer,
                                    StatusBufferSize);
            break;

        case NDIS_STATUS_WAN_LINE_DOWN:
            NdisWanLineDownIndication(pOpenCB,
                                      StatusBuffer,
                                      StatusBufferSize);
            break;

        case NDIS_STATUS_WAN_FRAGMENT:
            NdisWanFragmentIndication(pOpenCB,
                                      StatusBuffer,
                                      StatusBufferSize);
            break;

        case NDIS_STATUS_TAPI_INDICATION:
            NdisWanTapiIndication(pOpenCB,
                                  StatusBuffer,
                                  StatusBufferSize);

            break;

        default:
            NdisWanDbgOut(DBG_INFO, DBG_PROTOCOL, ("Unknown Status Indication: 0x%x", GeneralStatus));
            break;
    }

}

VOID
ProtoIndicateStatusComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;
}

VOID
ProtoWanSendComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_WAN_PACKET    WanPacket,
    IN  NDIS_STATUS         Status
    )
{
    PSEND_DESC  SendDesc;
    PLINKCB     LinkCB, RefLinkCB;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("ProtoWanSendComplete: Enter - WanPacket %p", WanPacket));

    //
    // Get info from the WanPacket
    //
    SendDesc = (PSEND_DESC)WanPacket->ProtocolReserved1;

    LinkCB = SendDesc->LinkCB;

    if (!IsLinkValid(LinkCB->hLinkHandle, FALSE, &RefLinkCB)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_CL,
            ("NDISWAN: SendComplete after link has gone down NdisContext %p\n",
             LinkCB));

        return;
    }

    REMOVE_DBG_SEND(PacketTypeWan, LinkCB->OpenCB, WanPacket);

    ASSERT(RefLinkCB == LinkCB);

    NdisAcquireSpinLock(&LinkCB->Lock);

    CompleteSendDesc(SendDesc, Status);

    //
    // Deref for the ref applied in IsLinkValid
    //
    DEREF_LINKCB(LinkCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("ProtoWanSendComplete: Exit"));
}

NDIS_STATUS
ProtoWanReceiveIndication(
    IN  NDIS_HANDLE NdisLinkHandle,
    IN  PUCHAR      Packet,
    IN  ULONG       PacketSize
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PLINKCB     LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;
    PUCHAR      DataBuffer;
    ULONG       DataBufferSize;
    ULONG       BytesCopied;
    PNDIS_PACKET    NdisPacket;
    PNDIS_BUFFER    NdisBuffer;
    PRECV_DESC      RecvDesc;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProtoWanReceiveIndication: Enter - Context %x", NdisLinkHandle));

    do {

        if (!AreLinkAndBundleValid(NdisLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {
#if DBG
            DbgPrint("NDISWAN: Recv after link has gone down LinkContext %x\n",
                     NdisLinkHandle);
#endif

            break;
        }
    
        AcquireBundleLock(BundleCB);

        //
        // Make sure we don't try to process a receive indication
        // that is larger then our max data buffer size
        // winse 26544
        //

        if (PacketSize > glMRU) {
            break;
        }

        //
        // Build a receive descriptor for this receive.  We have
        // to allocate with a large size because this packet might
        // be compressed.
        //
        RecvDesc = 
            NdisWanAllocateRecvDesc(glLargeDataBufferSize);
    
        if (RecvDesc == NULL) {
            break;
        }
    
        //
        // Update the bandwidth on demand sample array with the latest send.
        // If we need to notify someone of a bandwidth event do it.
        //
        if (BundleCB->Flags & BOND_ENABLED) {
            UpdateBandwidthOnDemand(BundleCB->RUpperBonDInfo, PacketSize);
            CheckUpperThreshold(BundleCB);
            UpdateBandwidthOnDemand(BundleCB->RLowerBonDInfo, PacketSize);
            CheckLowerThreshold(BundleCB);
        }
    
        RecvDesc->CopyRequired = TRUE;
        RecvDesc->CurrentBuffer = Packet;
        RecvDesc->CurrentLength = PacketSize;
        RecvDesc->LinkCB = LinkCB;
        RecvDesc->BundleCB = BundleCB;
    
        //
        // Indicate to netmon if we are sniffing at
        // the link level
        //
        if (gbSniffLink &&
            (NdisWanCB.PromiscuousAdapter != NULL)) {
    
            //
            // Indicate a packet to netmon
            //
            IndicatePromiscuousRecv(BundleCB, RecvDesc, RECV_LINK);
        }
    
        //
        // Add up the statistics
        //
        LinkCB->Stats.BytesReceived += RecvDesc->CurrentLength;
        LinkCB->Stats.FramesReceived++;
        BundleCB->Stats.BytesReceived += RecvDesc->CurrentLength;
    
        LinkCB->Flags |= LINK_IN_RECV;
        BundleCB->Flags |= BUNDLE_IN_RECV;

        Status = (*LinkCB->RecvHandler)(LinkCB, RecvDesc);
    
        BundleCB->Flags &= ~BUNDLE_IN_RECV;
        LinkCB->Flags &= ~LINK_IN_RECV;

        if (Status != NDIS_STATUS_PENDING) {
            NdisWanFreeRecvDesc(RecvDesc);
        }

    } while ( 0 );

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProtoWanReceiveIndication: Exit"));


    //
    // Deref's for the ref's applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (NDIS_STATUS_SUCCESS);
}

VOID
ProtoRequestComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_REQUEST   NdisRequest,
    IN  NDIS_STATUS     Status
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;
    PWAN_REQUEST pWanRequest;

    pWanRequest = CONTAINING_RECORD(NdisRequest,
                                    WAN_REQUEST,
                                    NdisRequest);

    NdisWanDbgOut(DBG_VERBOSE, DBG_REQUEST, ("ProtoRequestComplete: Enter - pWanRequest: 0x%p", pWanRequest));

    pWanRequest->NotificationStatus = Status;

    switch (pWanRequest->Origin) {
    case NDISWAN:
        NdisWanSetNotificationEvent(&pWanRequest->NotificationEvent);
        break;

    default:
        ASSERT(pWanRequest->Origin == NDISTAPI);
        NdisWanTapiRequestComplete(pOpenCB, pWanRequest);
        break;

    }

    NdisWanDbgOut(DBG_VERBOSE, DBG_REQUEST, ("ProtoRequestComplete: Exit"));
}

VOID
ProtoBindAdapter(
    OUT PNDIS_STATUS    Status,
    IN  NDIS_HANDLE     BindContext,
    IN  PNDIS_STRING    DeviceName,
    IN  PVOID           SystemSpecific1,
    IN  PVOID           SystemSpecific2
    )
/*++

Routine Name:

    ProtoBindAdapter

Routine Description:

    This function is called by the NDIS wrapper to tell NdisWan
    to bind to an underlying miniport.  NdisWan will open the
    miniport and query information on the device.

Arguments:

    Status      -   Return status
    BindContext -   Used in NdisBindAdapterComplete
    DeviceName  -   Name of device we are opening
    SS1         -   Used in NdisOpenProtocolConfig
    SS2         -   Reserved

Return Values:

--*/
{
    POPENCB         pOpenCB;
    
    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoBindAdapter - Enter %ls", DeviceName->Buffer));

    pOpenCB = NdisWanAllocateOpenCB(DeviceName);

    if (pOpenCB == NULL) {
        *Status = NDIS_STATUS_RESOURCES;
        return;
    }

    pOpenCB->Flags |= OPEN_IN_BIND;

    NdisWanInitializeNotificationEvent(&pOpenCB->InitEvent);

    *Status = ProtoOpenWanAdapter(pOpenCB);

    if (*Status != NDIS_STATUS_SUCCESS) {

        RemoveEntryGlobalList(OpenCBList, &pOpenCB->Linkage);

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT, ("Failed to bind to %ls! Error 0x%x - %s",
        pOpenCB->MiniportName.Buffer, *Status, NdisWanGetNdisStatus(*Status)));

        NdisWanFreeOpenCB(pOpenCB);

        return;
    }

    //
    // Figure out if this is a legacy wan miniport.
    //
    if (pOpenCB->MediumType == NdisMediumWan) {
        pOpenCB->Flags |= OPEN_LEGACY;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("Successful Binding to %s miniport %ls!",
        (pOpenCB->Flags & OPEN_LEGACY) ? "Legacy" : "NDIS 5.0",
        pOpenCB->MiniportName.Buffer));

    //
    // Get the wan medium subtype
    //
    {
        WAN_REQUEST WanRequest;
    
        NdisZeroMemory(&WanRequest, sizeof(WanRequest));
        WanRequest.Type = SYNC;
        WanRequest.Origin = NDISWAN;
        WanRequest.OpenCB = pOpenCB;
        NdisWanInitializeNotificationEvent(&WanRequest.NotificationEvent);

        WanRequest.NdisRequest.RequestType =
            NdisRequestQueryInformation;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid =
            OID_WAN_MEDIUM_SUBTYPE;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
            &pOpenCB->MediumSubType;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(pOpenCB->MediumSubType);
    
        *Status = NdisWanSubmitNdisRequest(pOpenCB, &WanRequest);

        if (*Status != NDIS_STATUS_SUCCESS) {
            NdisWanDbgOut(DBG_FAILURE, DBG_INIT, ("Error returned from OID_WAN_MEDIUM_SUBTYPE! Error 0x%x - %s",
            *Status, NdisWanGetNdisStatus(*Status)));
            pOpenCB->MediumSubType = NdisWanMediumHub;
            *Status = NDIS_STATUS_SUCCESS;
        }
    }

    if (pOpenCB->Flags & OPEN_LEGACY) {
        NDIS_WAN_INFO   WanInfo;
        WAN_REQUEST WanRequest;
    
        //
        // This is a legacy wan miniport
        //

        NdisZeroMemory(&WanRequest, sizeof(WanRequest));
        WanRequest.Type = SYNC;
        WanRequest.Origin = NDISWAN;
        WanRequest.OpenCB = pOpenCB;
        NdisWanInitializeNotificationEvent(&WanRequest.NotificationEvent);

        //
        // Get more info...
        //
        NdisZeroMemory(&WanInfo, sizeof(WanInfo));

        WanRequest.NdisRequest.RequestType =
            NdisRequestQueryInformation;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid =
            OID_WAN_GET_INFO;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
            &WanInfo;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(WanInfo);
    
        *Status = NdisWanSubmitNdisRequest(pOpenCB, &WanRequest);

        if (*Status != NDIS_STATUS_SUCCESS) {
            NDIS_STATUS CloseStatus;

            NdisWanDbgOut(DBG_FAILURE, DBG_INIT, ("Error returned from OID_WAN_GET_INFO! Error 0x%x - %s",
            *Status, NdisWanGetNdisStatus(*Status)));

            NdisAcquireSpinLock(&pOpenCB->Lock);

            pOpenCB->Flags |= OPEN_CLOSING;

            NdisWanInitializeNotificationEvent(&pOpenCB->NotificationEvent);

            NdisReleaseSpinLock(&pOpenCB->Lock);

            NdisCloseAdapter(&CloseStatus,
                             pOpenCB->BindingHandle);

            if (CloseStatus == NDIS_STATUS_PENDING) {

                NdisWanWaitForNotificationEvent(&pOpenCB->NotificationEvent);
            }

            NdisWanFreeOpenCB(pOpenCB);

            return;
        }
    
        NdisMoveMemory(&pOpenCB->WanInfo, &WanInfo, sizeof(NDIS_WAN_INFO));

        if (pOpenCB->WanInfo.MaxTransmit == 0) {
            pOpenCB->WanInfo.MaxTransmit = 1;
        }

        if (pOpenCB->WanInfo.Endpoints == 0) {
            pOpenCB->WanInfo.Endpoints = 1000;
        }
    
        *Status = NdisWanAllocateSendResources(pOpenCB);

        if (*Status != NDIS_STATUS_SUCCESS) {
            NDIS_STATUS CloseStatus;

            NdisWanDbgOut(DBG_FAILURE, DBG_INIT, ("Error returned from AllocateSendResources! Error 0x%x - %s",
            *Status, NdisWanGetNdisStatus(*Status)));

            NdisAcquireSpinLock(&pOpenCB->Lock);

            pOpenCB->Flags |= OPEN_CLOSING;

            NdisWanInitializeNotificationEvent(&pOpenCB->NotificationEvent);

            NdisReleaseSpinLock(&pOpenCB->Lock);

            NdisCloseAdapter(&CloseStatus,
                             pOpenCB->BindingHandle);

            if (CloseStatus == NDIS_STATUS_PENDING) {

                NdisWanWaitForNotificationEvent(&pOpenCB->NotificationEvent);
            }

            NdisWanFreeOpenCB(pOpenCB);

            return;
        }

        //
        // Tell tapi about this device
        //
        if (pOpenCB->WanInfo.FramingBits & TAPI_PROVIDER) {
            NDISTAPI_CHARACTERISTICS    Chars;

            NdisMoveMemory(&Chars.Guid,
                           &pOpenCB->Guid,
                           sizeof(Chars.Guid));

            Chars.MediaType = pOpenCB->MediumSubType;
            Chars.RequestProc = NdisWanTapiRequestProc;

            NdisTapiRegisterProvider(pOpenCB, &Chars);
        }

    } else {
        //
        // This is a 5.0 miniport! We will do init work
        // when a call manager registers for this!
        //
    }

    pOpenCB->Flags &= ~OPEN_IN_BIND;

    NdisWanSetNotificationEvent(&pOpenCB->InitEvent);

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoBindAdapter - Exit"));
}

VOID
ProtoUnbindAdapter(
    OUT PNDIS_STATUS    Status,
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  NDIS_HANDLE     UnbindContext
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;
    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoUnbindAdapter: Enter - OpenCB %p", pOpenCB));

    NdisAcquireSpinLock(&pOpenCB->Lock);

    while (pOpenCB->AfRegisteringCount != 0) {
        NdisReleaseSpinLock(&pOpenCB->Lock);
        NdisWanWaitForNotificationEvent(&pOpenCB->AfRegisteringEvent);
        NdisAcquireSpinLock(&pOpenCB->Lock);
    }

    if (!(pOpenCB->Flags & OPEN_LEGACY)) {

        while (!IsListEmpty(&pOpenCB->AfSapCBList)) {
            PCL_AFSAPCB AfSapCB;
            NDIS_STATUS RetStatus;

            AfSapCB = 
                (PCL_AFSAPCB)RemoveHeadList(&pOpenCB->AfSapCBList);

            InsertTailList(&pOpenCB->AfSapCBClosing, &AfSapCB->Linkage);
    
            NdisReleaseSpinLock(&pOpenCB->Lock);

            NdisAcquireSpinLock(&AfSapCB->Lock);

            AfSapCB->Flags |= AFSAP_REMOVED_UNBIND;

            DEREF_CLAFSAPCB_LOCKED(AfSapCB);

            NdisAcquireSpinLock(&pOpenCB->Lock);
        }
    }

    pOpenCB->UnbindContext = UnbindContext;

    NdisReleaseSpinLock(&pOpenCB->Lock);

    if (pOpenCB->WanInfo.FramingBits & TAPI_PROVIDER) {
        NdisTapiDeregisterProvider(pOpenCB);
    }

    DEREF_OPENCB(pOpenCB);

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoUnbindAdapter: Exit"));

    *Status = NDIS_STATUS_PENDING;
}

VOID
ProtoUnload(
    VOID
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoUnload: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoUnload: Exit"));
}

NDIS_STATUS
ProtoPnPEvent(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNET_PNP_EVENT  NetPnPEvent
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;

    if (pOpenCB == NULL) {
        return (NDIS_STATUS_SUCCESS);
    }

    switch (NetPnPEvent->NetEvent) {
    case NetEventSetPower:
        {
        NET_DEVICE_POWER_STATE PowerState;

        PowerState = *((NET_DEVICE_POWER_STATE*)NetPnPEvent->Buffer);

        NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
            ("ProtoPnPEvent: OpenCB %p %s State %d",
                pOpenCB, "SetPower", PowerState));

        switch (PowerState) {
        case NetDeviceStateD0:
            break;
        case NetDeviceStateD1:
        case NetDeviceStateD2:
        case NetDeviceStateD3:

            //
            // If this is the open on asyncmac I do not want it to be closed.
            // I will succeed the set power which should keep ndis from
            // unbinding me.  If this is an open on any other miniport
            // I will return not supported so that I will get unbound from
            // the miniport.  This is required for correct tapi behavior.
            //
            if (pOpenCB->MediumType == NdisMediumWan &&
                pOpenCB->MediumSubType == NdisWanMediumSerial &&
                !(pOpenCB->WanInfo.FramingBits & TAPI_PROVIDER)) {
                Status = NDIS_STATUS_SUCCESS;
            } else {
                Status = NDIS_STATUS_NOT_SUPPORTED;
            }

            //
            // In the case of a Critical Power event we will not
            // receive a Query so we must tear the connection down
            // directly from the Set.
            //
            // If we have any active connections signal rasman to
            // tear them down.
            //
            if (InterlockedCompareExchange(&pOpenCB->ActiveLinkCount, 0, 0)) {
                PIRP    Irp;

                NdisAcquireSpinLock(&NdisWanCB.Lock);
                Irp = NdisWanCB.HibernateEventIrp;

                if ((Irp != NULL) &&
                    IoSetCancelRoutine(Irp, NULL)){

                    NdisWanCB.HibernateEventIrp = NULL;

                    NdisReleaseSpinLock(&NdisWanCB.Lock);

                    //
                    // The irp is not being canceled so
                    // lets do it!
                    //

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = 0;

                    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

                    NdisAcquireSpinLock(&NdisWanCB.Lock);
                }

                NdisReleaseSpinLock(&NdisWanCB.Lock);
            }
            break;

        default:
            break;
        }

        }
        break;

    case NetEventQueryPower:
        {
        NET_DEVICE_POWER_STATE PowerState;

        PowerState = *((NET_DEVICE_POWER_STATE*)NetPnPEvent->Buffer);

        NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
            ("ProtoPnPEvent: OpenCB %p %s State %d",
                pOpenCB, "QueryPower", PowerState));
        //
        // If there is an active connection
        // on this binding refuse to go away
        //
        switch (PowerState) {
        case NetDeviceStateD0:
            break;
        case NetDeviceStateD1:
        case NetDeviceStateD2:
        case NetDeviceStateD3:

            //
            // If we have any active connections signal rasman to
            // tear them down.
            //
            if (InterlockedCompareExchange(&pOpenCB->ActiveLinkCount, 0, 0)) {
                PIRP    Irp;

                NdisAcquireSpinLock(&NdisWanCB.Lock);
                Irp = NdisWanCB.HibernateEventIrp;

                if ((Irp != NULL) &&
                    IoSetCancelRoutine(Irp, NULL)) {

                    NdisWanCB.HibernateEventIrp = NULL;
                    NdisReleaseSpinLock(&NdisWanCB.Lock);

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = 0;

                    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

                    NdisAcquireSpinLock(&NdisWanCB.Lock);
                }

                NdisReleaseSpinLock(&NdisWanCB.Lock);
            }
            break;

        default:
            break;
        }

        }
        break;

    case NetEventQueryRemoveDevice:
    case NetEventCancelRemoveDevice:
    case NetEventReconfigure:
    case NetEventBindList:
    default:
        break;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoPnPEvent: Exit"));
    return (Status);
}

VOID
ProtoCoSendComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PNDIS_PACKET    Packet
    )
{
    PLINKCB         LinkCB;
    PBUNDLECB       BundleCB;
    PSEND_DESC      SendDesc;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND,
        ("ProtoCoSendComplete: Enter - VC %p Packet: %p", ProtocolVcContext, Packet));

    if (!IsLinkValid(ProtocolVcContext, FALSE, &LinkCB)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_CL,
            ("NDISWAN: SendComplete after link has gone down ProtocolVcContext %p\n",
             LinkCB));

        return;
    }

    REMOVE_DBG_SEND(PacketTypeNdis, LinkCB->OpenCB, Packet);

    //
    // Get Info from the NdisPacket
    //
    SendDesc = PPROTOCOL_RESERVED_FROM_NDIS(Packet)->SendDesc;

    NdisAcquireSpinLock(&LinkCB->Lock);

    ASSERT(SendDesc->LinkCB == LinkCB);

    CompleteSendDesc(SendDesc, Status);

    NdisAcquireSpinLock(&LinkCB->Lock);

    //
    // Remove ref that keeps the vc around
    //
    DerefVc(LinkCB);

    //
    // Deref for the ref applied in IsLinkValid
    //
    DEREF_LINKCB_LOCKED(LinkCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("ProtoCoSendComplete: Exit"));
}

VOID
ProtoCoIndicateStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext   OPTIONAL,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    )
{
    POPENCB     pOpenCB = (POPENCB)ProtocolBindingContext;
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;

    if (!AreLinkAndBundleValid(ProtocolVcContext, 
                               TRUE,
                               &LinkCB, 
                               &BundleCB)) {

        return;
    }

    switch (GeneralStatus) {
    case NDIS_STATUS_WAN_CO_FRAGMENT:
        NdisCoWanFragmentIndication(LinkCB,
                                    BundleCB,
                                    StatusBuffer,
                                    StatusBufferSize);

        break;

    case NDIS_STATUS_WAN_CO_LINKPARAMS:
        NdisCoWanLinkParamChange(LinkCB,
                                 BundleCB,
                                 StatusBuffer,
                                 StatusBufferSize);

    default:
        NdisWanDbgOut(DBG_INFO, DBG_PROTOCOL,
            ("Unknown Status Indication: 0x%x", GeneralStatus));
        break;
    }

    //
    // Deref's for ref's applied in AreLinkAndBundleValid
    //
    DEREF_LINKCB(LinkCB);
    DEREF_BUNDLECB(BundleCB);
}

UINT
ProtoCoReceivePacket(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PNDIS_PACKET    Packet
    )
{
    POPENCB         pOpenCB = (POPENCB)ProtocolBindingContext;
    PLINKCB         LinkCB = NULL;
    PBUNDLECB       BundleCB = NULL;
    NDIS_STATUS     Status;
    ULONG           BufferCount;
    LONG            PacketSize;
    PNDIS_BUFFER    FirstBuffer;
    PRECV_DESC      RecvDesc;
    UINT            RefCount = 0;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE,
        ("ProtoCoReceivePacket: Enter - OpenCB %p", pOpenCB));

    do {

        if (!AreLinkAndBundleValid(ProtocolVcContext,
                                   TRUE,
                                   &LinkCB,
                                   &BundleCB)) {
            break;
        }

#if DBG
        NdisAcquireSpinLock(&LinkCB->Lock);

        if (LinkCB->ClCallState != CL_CALL_CONNECTED) {
            DbgPrint("NDISWAN: Vc not fully active but indicating data!\n");
        }

        NdisReleaseSpinLock(&LinkCB->Lock);
#endif

        AcquireBundleLock(BundleCB);

        NdisQueryPacket(Packet,
                        NULL,
                        &BufferCount,
                        &FirstBuffer,
                        &PacketSize);

        if (PacketSize > (LONG)glMRU) {
            break;
        }

        PRECV_RESERVED_FROM_NDIS(Packet)->MagicNumber = MAGIC_EXTERNAL_RECV;

        RecvDesc = 
            NdisWanAllocateRecvDesc(glLargeDataBufferSize);

        if (RecvDesc == NULL) {
            break;
        }

        RecvDesc->LinkCB = LinkCB;
        RecvDesc->BundleCB = BundleCB;

        //
        // If the packet has only one buffer we are happy, if not
        // we have to allocate our own ndis packet and buffers
        // and copy the data from the miniports packet into our packet
        //
        if (BufferCount > 1 ||
            NDIS_GET_PACKET_STATUS(Packet) == NDIS_STATUS_RESOURCES) {

            RecvDesc->CurrentBuffer = RecvDesc->StartBuffer +
                                      MAC_HEADER_LENGTH +
                                      PROTOCOL_HEADER_LENGTH;

            //
            // Copy from the miniports packet to my packet
            //
            NdisWanCopyFromPacketToBuffer(Packet,
                                          0,
                                          PacketSize,
                                          RecvDesc->CurrentBuffer,
                                          &RecvDesc->CurrentLength);

            ASSERT(PacketSize == RecvDesc->CurrentLength);

        } else {
            NdisQueryBuffer(FirstBuffer,
                            &RecvDesc->CurrentBuffer,
                            &RecvDesc->CurrentLength);

            ASSERT(PacketSize == RecvDesc->CurrentLength);

            RecvDesc->CopyRequired = TRUE;

            RecvDesc->OriginalPacket = Packet;

            RefCount = 1;
        }

        //
        // Indicate to netmon if we are sniffing at
        // the link level
        //
        if (gbSniffLink &&
            (NdisWanCB.PromiscuousAdapter != NULL)) {

            //
            // Indicate a packet to netmon
            //
            IndicatePromiscuousRecv(BundleCB, RecvDesc, RECV_LINK);
        }

        //
        // Update the bandwidth on demand sample array with the latest send.
        // If we need to notify someone of a bandwidth event do it.
        //
        if (BundleCB->Flags & BOND_ENABLED) {
            UpdateBandwidthOnDemand(BundleCB->RUpperBonDInfo, PacketSize);
            CheckUpperThreshold(BundleCB);
            UpdateBandwidthOnDemand(BundleCB->RLowerBonDInfo, PacketSize);
            CheckLowerThreshold(BundleCB);
        }

        //
        // Add up the statistics
        //
        LinkCB->Stats.BytesReceived += RecvDesc->CurrentLength;
        LinkCB->Stats.FramesReceived++;
        BundleCB->Stats.BytesReceived += RecvDesc->CurrentLength;

        Status = (*LinkCB->RecvHandler)(LinkCB, RecvDesc);

        if (Status != NDIS_STATUS_PENDING) {
            RecvDesc->OriginalPacket = NULL;
            NdisWanFreeRecvDesc(RecvDesc);
            RefCount = 0;
        }

        NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProtoCoReceivePacket: Exit"));

    } while (0);

    //
    // Deref's for ref's applied by AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (RefCount);
}

NDIS_STATUS
ProtoCoRequest(
    IN  NDIS_HANDLE         ProtocolAfContext,
    IN  NDIS_HANDLE         ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE         ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST    NdisRequest
    )
{
    PCL_AFSAPCB AfSapCB = (PCL_AFSAPCB)ProtocolAfContext;
    NDIS_OID Oid;

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("ProtoCoRequest: Enter - AfContext %p", ProtocolAfContext));

    if (NdisRequest->RequestType == NdisRequestQueryInformation) {
        Oid = NdisRequest->DATA.QUERY_INFORMATION.Oid;
    } else {
        Oid = NdisRequest->DATA.SET_INFORMATION.Oid;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("Oid - %x", Oid));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    switch (Oid) {
        case OID_CO_AF_CLOSE:
            {
            POPENCB OpenCB;
            PCL_AFSAPCB tAfSapCB;

            OpenCB = AfSapCB->OpenCB;

            NdisAcquireSpinLock(&OpenCB->Lock);

            while (OpenCB->AfRegisteringCount != 0) {
                NdisReleaseSpinLock(&OpenCB->Lock);
                NdisWanWaitForNotificationEvent(&OpenCB->AfRegisteringEvent);
                NdisAcquireSpinLock(&OpenCB->Lock);
            }

            for (tAfSapCB = (PCL_AFSAPCB)OpenCB->AfSapCBList.Flink;
                (PVOID)tAfSapCB != (PVOID)&OpenCB->AfSapCBList;
                tAfSapCB = (PCL_AFSAPCB)AfSapCB->Linkage.Flink) {

                if (tAfSapCB == AfSapCB) {
                    break;
                }
            }

            if ((PVOID)tAfSapCB == (PVOID)&OpenCB->AfSapCBList) {
                NdisWanDbgOut(DBG_FAILURE, DBG_REQUEST, \
                              ("ProtoCoRequest: Af %p not on OpenCB %p list!", \
                               AfSapCB, OpenCB));

                NdisReleaseSpinLock(&OpenCB->Lock);

                break;
            }

            RemoveEntryList(&AfSapCB->Linkage);

            InsertTailList(&OpenCB->AfSapCBClosing,
                           &AfSapCB->Linkage);

            NdisReleaseSpinLock(&OpenCB->Lock);

            NdisAcquireSpinLock(&AfSapCB->Lock);

            ASSERT(!(AfSapCB->Flags & AFSAP_REMOVED_FLAGS));
            ASSERT(AfSapCB->Flags & SAP_REGISTERED);

            AfSapCB->Flags |= AFSAP_REMOVED_REQUEST;

            DEREF_CLAFSAPCB_LOCKED(AfSapCB);

            }
            break;

        default:
            break;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("ProtoCoRequest: Exit"));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return (NDIS_STATUS_SUCCESS);
}

VOID
ProtoCoRequestComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE     ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST   NdisRequest
    )
{
    PCL_AFSAPCB AfSapCB = (PCL_AFSAPCB)ProtocolAfContext;
    PWAN_REQUEST pWanRequest;
    POPENCB     pOpenCB;

    pWanRequest = CONTAINING_RECORD(NdisRequest,
                                    WAN_REQUEST,
                                    NdisRequest);

    pOpenCB = pWanRequest->OpenCB;

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("ProtoCoRequestComplete: Enter - WanRequest 0x%p", pWanRequest));

    pWanRequest->NotificationStatus = Status;

    switch (pWanRequest->Origin) {
    case NDISWAN:
        NdisWanSetNotificationEvent(&pWanRequest->NotificationEvent);
        break;

    default:
        ASSERT(pWanRequest->Origin == NDISTAPI);
        NdisWanTapiRequestComplete(pOpenCB, pWanRequest);
        break;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("ProtoCoRequestComplete: Exit"));
}

VOID
ProtoCoAfRegisterNotify(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily
    )
{
    POPENCB OpenCB = (POPENCB)ProtocolBindingContext;
    NDIS_CLIENT_CHARACTERISTICS ClCharacteristics;
    PCL_AFSAPCB     AfSapCB;
    NDIS_STATUS     Status;
    ULONG           GenericUlong;
    NDIS_HANDLE     AfHandle;
    WAN_REQUEST     WanRequest;
    NDIS_WAN_CO_INFO    WanInfo;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
    ("ProtoCoAfRegisterNotify: Enter - OpenCB %p AfType: %x", OpenCB, AddressFamily->AddressFamily));

    //
    // If this is a proxied address family we are interested,
    // so open the address family, register a sap and return success.
    //
    if (AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_TAPI) {
        NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
        ("ProtoCoAfRegisterNotify: Af not tapi do not open!"));
        return;
    }

    NdisAcquireSpinLock(&OpenCB->Lock);

    for (AfSapCB = (PCL_AFSAPCB)OpenCB->AfSapCBList.Flink;
        (PVOID)AfSapCB != (PVOID)&OpenCB->AfSapCBList;
        AfSapCB = (PCL_AFSAPCB)AfSapCB->Linkage.Flink) {

        if (AfSapCB->Af.AddressFamily == AddressFamily->AddressFamily) {
            //
            // we already have this addressfamily on this open block.
            //
            NdisReleaseSpinLock(&OpenCB->Lock);
            return;
        }
    }

    AfSapCB = 
        NdisWanAllocateClAfSapCB(OpenCB, AddressFamily);

    if (AfSapCB == NULL) {
        NdisReleaseSpinLock(&OpenCB->Lock);
        return;
    }

    //
    // Use this crude mechanism to keep us from unbinding while in the
    // middle of af notification.  The count is cleaned up either in
    // openafcomplete (if open failed) or in registersapcomplete.
    //
    if (OpenCB->AfRegisteringCount == 0) {
        NdisWanInitializeNotificationEvent(&OpenCB->AfRegisteringEvent);
    }

    OpenCB->AfRegisteringCount++;

    NdisReleaseSpinLock(&OpenCB->Lock);

    //
    // Open the address family
    //
    NdisZeroMemory(&ClCharacteristics, sizeof(NDIS_CLIENT_CHARACTERISTICS));

    ClCharacteristics.MajorVersion = NDISWAN_MAJOR_VERSION;
    ClCharacteristics.MinorVersion = NDISWAN_MINOR_VERSION;
    ClCharacteristics.ClCreateVcHandler = ClCreateVc;
    ClCharacteristics.ClDeleteVcHandler = ClDeleteVc;
    ClCharacteristics.ClRequestHandler = ProtoCoRequest;
    ClCharacteristics.ClRequestCompleteHandler = ProtoCoRequestComplete;
    ClCharacteristics.ClOpenAfCompleteHandler = ClOpenAfComplete;
    ClCharacteristics.ClCloseAfCompleteHandler = ClCloseAfComplete;
    ClCharacteristics.ClRegisterSapCompleteHandler = ClRegisterSapComplete;
    ClCharacteristics.ClDeregisterSapCompleteHandler = ClDeregisterSapComplete;
    ClCharacteristics.ClMakeCallCompleteHandler = ClMakeCallComplete;
    ClCharacteristics.ClModifyCallQoSCompleteHandler = ClModifyQoSComplete;
    ClCharacteristics.ClCloseCallCompleteHandler = ClCloseCallComplete;
    ClCharacteristics.ClAddPartyCompleteHandler = NULL;
    ClCharacteristics.ClDropPartyCompleteHandler = NULL;
    ClCharacteristics.ClIncomingCallHandler = ClIncomingCall;
    ClCharacteristics.ClIncomingCallQoSChangeHandler = ClIncomingCallQoSChange;
    ClCharacteristics.ClIncomingCloseCallHandler = ClIncomingCloseCall;
    ClCharacteristics.ClIncomingDropPartyHandler = NULL;
    ClCharacteristics.ClCallConnectedHandler        = ClCallConnected;

    Status =
    NdisClOpenAddressFamily(OpenCB->BindingHandle,
                            AddressFamily,
                            AfSapCB,
                            &ClCharacteristics,
                            sizeof(NDIS_CLIENT_CHARACTERISTICS),
                            &AfHandle);

    if (Status != NDIS_STATUS_PENDING) {
        ClOpenAfComplete(Status, AfSapCB, AfHandle);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
    ("ClOpenAddressFamily AfHandle 0x%x status: 0x%x", AfSapCB->AfHandle, Status));

    //
    // Do some OID's to the miniport.  This is a
    // CoNDIS miniport and are destined for the 
    // miniport so AfHandle and VcHandle = NULL!
    //
    NdisZeroMemory(&WanRequest, sizeof(WanRequest));

    WanRequest.Type = SYNC;
    WanRequest.Origin = NDISWAN;
    WanRequest.OpenCB = OpenCB;
    WanRequest.AfHandle = NULL;
    WanRequest.VcHandle = NULL;
    NdisWanInitializeNotificationEvent(&WanRequest.NotificationEvent);

    //
    // Get more info...
    //
    WanRequest.NdisRequest.RequestType =
        NdisRequestQueryInformation;

    WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid =
        OID_WAN_CO_GET_INFO;

    WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
        &WanInfo;

    WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
        sizeof(WanInfo);

    Status = NdisWanSubmitNdisRequest(OpenCB, &WanRequest);

    if (Status == NDIS_STATUS_SUCCESS) {
        OpenCB->WanInfo.MaxFrameSize = WanInfo.MaxFrameSize;
        OpenCB->WanInfo.MaxTransmit = WanInfo.MaxSendWindow;
        OpenCB->WanInfo.FramingBits = WanInfo.FramingBits;
        OpenCB->WanInfo.DesiredACCM = WanInfo.DesiredACCM;
        NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
            ("CO_GET_INFO: FrameSize %d SendWindow %d",
            WanInfo.MaxFrameSize, WanInfo.MaxSendWindow));
    } else {

        //
        // This guy will get default framing behaviour
        //
        OpenCB->WanInfo.FramingBits = PPP_FRAMING;
        OpenCB->WanInfo.DesiredACCM = 0;

        //
        // Find the send window
        //
        WanRequest.NdisRequest.RequestType =
            NdisRequestQueryInformation;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid =
            OID_GEN_MAXIMUM_SEND_PACKETS;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
            &GenericUlong;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(ULONG);

        Status = NdisWanSubmitNdisRequest(OpenCB, &WanRequest);

        OpenCB->WanInfo.MaxTransmit = (Status == NDIS_STATUS_SUCCESS &&
                                        GenericUlong > 0) ? GenericUlong : 10;

        //
        // Find the max transmit size
        //
        WanRequest.NdisRequest.RequestType =
            NdisRequestQueryInformation;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid =
            OID_GEN_MAXIMUM_TOTAL_SIZE;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
            &GenericUlong;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(ULONG);

        Status = NdisWanSubmitNdisRequest(OpenCB, &WanRequest);

        OpenCB->WanInfo.MaxFrameSize = (Status == NDIS_STATUS_SUCCESS) ?
                                        GenericUlong : 1500;

    }

    OpenCB->WanInfo.Endpoints = 1000;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoCoAfRegisterNotify: Exit"));
}

NDIS_STATUS
DoNewLineUpToProtocol(
    PPROTOCOLCB ProtocolCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PMINIPORTCB MiniportCB;
    NDIS_STATUS Status;
    PBUNDLECB   BundleCB = ProtocolCB->BundleCB;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("DoNewLineupToProtocol: Enter"));

    do {

        NdisAcquireSpinLock(&MiniportCBList.Lock);

        //
        // Find the adapter that this lineup is for.  Look for the adapter
        // that has the appropriate protocoltype.  If it is NBF we need
        // to look for a specific adapter.
        //
        for (MiniportCB = (PMINIPORTCB)MiniportCBList.List.Flink;
            (PVOID)MiniportCB != (PVOID)&MiniportCBList.List;
            MiniportCB = (PMINIPORTCB)MiniportCB->Linkage.Flink) {

            if (MiniportCB->ProtocolType == ProtocolCB->ProtocolType) {

                if (ProtocolCB->ProtocolType != PROTOCOL_NBF) {
                    break;
                }

                //
                // Must be NBF so verify the AdapterName!!!
                //
                if (NdisWanCompareNdisString(&MiniportCB->AdapterName,&ProtocolCB->BindingName)) {
                    break;
                }
            }
        }

        if ((PVOID)MiniportCB == (PVOID)&MiniportCBList.List) {
            //
            // The adapter was not found...
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_PROTOCOL, ("Adapter not found!"));

            NdisReleaseSpinLock(&MiniportCBList.Lock);

            Status = NDISWAN_ERROR_NO_ROUTE;

            break;
        }

        ASSERT(MiniportCB->ProtocolType == ProtocolCB->ProtocolType);

        ETH_COPY_NETWORK_ADDRESS(ProtocolCB->NdisWanAddress, MiniportCB->NetworkAddress);

        FillNdisWanIndices(ProtocolCB->NdisWanAddress,
                           BundleCB->hBundleHandle,
                           ProtocolCB->ProtocolHandle);

        NdisZeroMemory(ProtocolCB->TransportAddress, 6);

        NdisAcquireSpinLock(&MiniportCB->Lock);

        InsertTailList(&MiniportCB->ProtocolCBList,
                       &ProtocolCB->MiniportLinkage);

        ProtocolCB->MiniportCB = MiniportCB;

        REF_MINIPORTCB(MiniportCB);

        NdisReleaseSpinLock(&MiniportCB->Lock);

        NdisReleaseSpinLock(&MiniportCBList.Lock);

        Status = DoLineUpToProtocol(ProtocolCB);

        if (Status != NDIS_STATUS_SUCCESS) {

            NdisAcquireSpinLock(&MiniportCBList.Lock);

            NdisAcquireSpinLock(&MiniportCB->Lock);

            RemoveEntryList(&ProtocolCB->MiniportLinkage);

            if (MiniportCB->Flags & HALT_IN_PROGRESS) {
                NdisWanSetSyncEvent(&MiniportCB->HaltEvent);
            }

            NdisReleaseSpinLock(&MiniportCB->Lock);

            NdisReleaseSpinLock(&MiniportCBList.Lock);

            DEREF_MINIPORTCB(MiniportCB);
        }

    } while (FALSE);

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("DoNewLineupToProtocols: Exit"));

    return (Status);
}

NDIS_STATUS
DoLineUpToProtocol(
    IN  PPROTOCOLCB ProtocolCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   AllocationSize;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PNDIS_WAN_LINE_UP LineUpInfo;
    PMINIPORTCB MiniportCB = ProtocolCB->MiniportCB;
    PBUNDLECB   BundleCB = ProtocolCB->BundleCB;
    KIRQL       OldIrql;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("DoLineupToProtocol: Enter"));

    ASSERT(MiniportCB != NULL);

    AllocationSize = sizeof(NDIS_WAN_LINE_UP) +
                     ProtocolCB->ulLineUpInfoLength +
                     (sizeof(WCHAR) * (MAX_NAME_LENGTH + 1) +
                     (2 * sizeof(PVOID)));

    NdisWanAllocateMemory(&LineUpInfo, AllocationSize, LINEUPINFO_TAG);

    if (LineUpInfo != NULL) {
        ULONG LineUpHandle = ProtocolCB->ulTransportHandle;
        
        //
        // Needs to be in 1/100bps, we store in Bps
        //
        LineUpInfo->LinkSpeed = BundleCB->SFlowSpec.PeakBandwidth * 8 / 100;

        //
        // Set the MTU for this protocol
        //
        {
            POPENCB OpenCB = BundleCB->NextLinkToXmit->OpenCB;

            //
            // If this connection is running over a VPN we will downsize
            // the MTU
            //
            if ((OpenCB->MediumSubType == NdisWanMediumPPTP ||
                 OpenCB->MediumSubType == NdisWanMediumL2TP)) {
                LineUpInfo->MaximumTotalSize = ProtocolCB->TunnelMTU;
            } else {
                LineUpInfo->MaximumTotalSize = ProtocolCB->MTU;
            }

            if (LineUpInfo->MaximumTotalSize > BundleCB->SFlowSpec.MaxSduSize) {
                LineUpInfo->MaximumTotalSize = 
                    BundleCB->SFlowSpec.MaxSduSize;
            }

#if 0            
            //
            // Figure out the size of the ppp header...
            //
            BundleCB->FramingInfo.PPPHeaderLength = 
                CalcPPPHeaderLength(BundleCB->FramingInfo.SendFramingBits,
                                    BundleCB->SendFlags);

            if (LineUpInfo->MaximumTotalSize > BundleCB->FramingInfo.PPPHeaderLength) {
                LineUpInfo->MaximumTotalSize -= BundleCB->FramingInfo.PPPHeaderLength;
            } else {
                LineUpInfo->MaximumTotalSize = 0;
            }
#endif        
        }

        LineUpInfo->Quality = NdisWanReliable;
        LineUpInfo->SendWindow = (USHORT)BundleCB->SendWindow;
        LineUpInfo->ProtocolType = ProtocolCB->ProtocolType;
        LineUpInfo->DeviceName.Length = ProtocolCB->InDeviceName.Length;
        LineUpInfo->DeviceName.MaximumLength = MAX_NAME_LENGTH + 1;
        LineUpInfo->DeviceName.Buffer = (PWCHAR)((PUCHAR)LineUpInfo +
                                                 sizeof(NDIS_WAN_LINE_UP) + 
                                                 sizeof(PVOID));
        (ULONG_PTR)LineUpInfo->DeviceName.Buffer &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        if (ProtocolCB->InDeviceName.Length != 0) {

            NdisMoveMemory(LineUpInfo->DeviceName.Buffer,
                           ProtocolCB->InDeviceName.Buffer,
                           ProtocolCB->InDeviceName.Length);
        }


        LineUpInfo->ProtocolBuffer = (PUCHAR)LineUpInfo +
                                     sizeof(NDIS_WAN_LINE_UP) +
                                     (sizeof(WCHAR) * (MAX_NAME_LENGTH + 1) +
                                     sizeof(PVOID));
        (ULONG_PTR)LineUpInfo->ProtocolBuffer &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        //
        //
        // The Remote address (DEST address in a send) is what we use to
        // mutilplex sends across our single adapter/binding context.
        // The address has the following format:
        //
        // XX XX XX YY YY ZZ
        //
        // XX = Randomly generated OUI
        // YY = Index into the active bundle connection table to get bundlecb
        // ZZ = Index into the protocol table of a bundle to get protocolcb
        //
        ETH_COPY_NETWORK_ADDRESS(LineUpInfo->RemoteAddress,ProtocolCB->NdisWanAddress);
        ETH_COPY_NETWORK_ADDRESS(LineUpInfo->LocalAddress,ProtocolCB->TransportAddress);

        //
        // Fill in the protocol specific information
        //
        LineUpInfo->ProtocolBufferLength = ProtocolCB->ulLineUpInfoLength;
        if (ProtocolCB->ulLineUpInfoLength > 0) {
            NdisMoveMemory(LineUpInfo->ProtocolBuffer,
                           ProtocolCB->LineUpInfo,
                           ProtocolCB->ulLineUpInfoLength);
        }

//        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

        // DbgPrint("LineUp: %x, MTU %d\n",
        //    LineUpInfo->ProtocolType, LineUpInfo->MaximumTotalSize);

        //
        // Do the line up indication
        //
        NdisMIndicateStatus(MiniportCB->MiniportHandle,
                            NDIS_STATUS_WAN_LINE_UP,
                            LineUpInfo,
                            AllocationSize);

//        KeLowerIrql(OldIrql);

        //
        // Update protocol queue depth
        //
        {
            PROTOCOL_INFO   ProtocolInfo = {0};
            ULONG           ByteDepth;
            ULONG           i;

            AcquireBundleLock(BundleCB);

            ProtocolInfo.ProtocolType = ProtocolCB->ProtocolType;
            GetProtocolInfo(&ProtocolInfo);

            //
            // Set the send queue byte depth.
            //
            ByteDepth =
                ProtocolInfo.PacketQueueDepth;

            //
            // If the byte depth is less then 4
            // full packets, then set it to 4 full
            // packets.
            //
            if (ByteDepth < (ProtocolInfo.MTU * 4)) {
                ByteDepth = ProtocolInfo.MTU * 4;
            }

            for (i = 0; i <= MAX_MCML; i++) {
                ProtocolCB->PacketQueue[i].MaxByteDepth =
                    ByteDepth;
            }

            ReleaseBundleLock(BundleCB);
        }

        //
        // If this was the first line up for this protocolcb and
        // this lineup was answered we need to collect some info
        //
        if (ProtocolCB->ulTransportHandle == 0) {

            *((ULONG UNALIGNED *)(&LineUpHandle)) =
                *((ULONG UNALIGNED *)(&LineUpInfo->LocalAddress[2]));

            if (LineUpHandle != 0) {

                AcquireBundleLock(BundleCB);

                ETH_COPY_NETWORK_ADDRESS(ProtocolCB->TransportAddress, LineUpInfo->LocalAddress);

                ProtocolCB->ulTransportHandle = LineUpHandle;

                if (LineUpInfo->DeviceName.Length != 0) {
                    NdisWanStringToNdisString(&ProtocolCB->OutDeviceName,
                                              LineUpInfo->DeviceName.Buffer);
                }

                ReleaseBundleLock(BundleCB);

                //
                // If this is an nbf adapter
                //
                if (ProtocolCB->ProtocolType == (USHORT)PROTOCOL_NBF) {
        
                    ASSERT(MiniportCB->ProtocolType == (USHORT)PROTOCOL_NBF);
        
                    MiniportCB->NbfProtocolCB = ProtocolCB;
                }

            } else {
                Status = NDISWAN_ERROR_NO_ROUTE;
            }
        }

        NdisWanFreeMemory(LineUpInfo);

    } else {

        Status = NDIS_STATUS_RESOURCES;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("DoLineupToProtocol: Exit"));

    return (Status);
}

NDIS_STATUS
DoLineDownToProtocol(
    PPROTOCOLCB ProtocolCB
    )
{
    NDIS_WAN_LINE_DOWN  WanLineDown;
    PNDIS_WAN_LINE_DOWN LineDownInfo = &WanLineDown;

    PMINIPORTCB         MiniportCB = ProtocolCB->MiniportCB;
    PBUNDLECB           BundleCB = ProtocolCB->BundleCB;

    KIRQL   OldIrql;

    //
    // The Remote address (DEST address) is what we use to mutilplex
    // sends across our single adapter/binding context.  The address
    // has the following format:
    //
    // XX XX YY YY YY YY
    //
    // XX = Randomly generated OUI
    // YY = ProtocolCB
    //
    ETH_COPY_NETWORK_ADDRESS(LineDownInfo->RemoteAddress, ProtocolCB->NdisWanAddress);
    ETH_COPY_NETWORK_ADDRESS(LineDownInfo->LocalAddress, ProtocolCB->TransportAddress);

    //
    // If this is an nbf adapter
    //
    if (ProtocolCB->ProtocolType == PROTOCOL_NBF) {

        MiniportCB->NbfProtocolCB = NULL;
    }

    ProtocolCB->ulTransportHandle = 0;
    ProtocolCB->State = PROTOCOL_UNROUTED;

    ReleaseBundleLock(BundleCB);

    NdisMIndicateStatus(MiniportCB->MiniportHandle,
                        NDIS_STATUS_WAN_LINE_DOWN,
                        LineDownInfo,
                        sizeof(NDIS_WAN_LINE_DOWN));

    NdisAcquireSpinLock(&MiniportCB->Lock);

    RemoveEntryList(&ProtocolCB->MiniportLinkage);

    if (MiniportCB->Flags & HALT_IN_PROGRESS) {
        NdisWanSetSyncEvent(&MiniportCB->HaltEvent);
    }

    NdisReleaseSpinLock(&MiniportCB->Lock);

    DEREF_MINIPORTCB(MiniportCB);

    AcquireBundleLock(BundleCB);

    return (NDIS_STATUS_SUCCESS);
}

VOID
CompleteSendDesc(
    PSEND_DESC  SendDesc,
    NDIS_STATUS Status
    )
{
    PLINKCB         LinkCB;
    PBUNDLECB       BundleCB;
    PPROTOCOLCB     ProtocolCB;
    PNDIS_PACKET    OriginalPacket;
    BOOLEAN         FreeLink = FALSE, FreeBundle = FALSE;
    BOOLEAN         LegacyLink;
    PULONG          pulRefCount;
    PCM_VCCB        CmVcCB;
    INT             Class;
    ULONG           DescFlags;

    LinkCB = SendDesc->LinkCB;
    ProtocolCB = SendDesc->ProtocolCB;
    OriginalPacket = SendDesc->OriginalPacket;
    Class = SendDesc->Class;
    DescFlags = SendDesc->Flags;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND,
        ("SendDesc: 0x%p, OriginalPacket: 0x%p, Status: %x",
        SendDesc, OriginalPacket, Status));

    NdisWanFreeSendDesc(SendDesc);

    //
    // Bundle that this link is on
    //
    BundleCB = LinkCB->BundleCB;

    //
    // Deref for the ref applied when a senddesc
    // was retrieved for this link. We don't need to do
    // the full deref here because we are keeping the
    // link from going away with the ref applied when
    // we got the sendcomplete.
    //
    --LinkCB->RefCount;

#ifdef DBG_SENDARRAY
{
    SendArray[__si] = 'c';
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    NdisReleaseSpinLock(&LinkCB->Lock);

    AcquireBundleLock(BundleCB);

    LegacyLink = (LinkCB->OpenCB->Flags & OPEN_LEGACY) ? 1 : 0;

    //
    // If the sendwindow is currently full, this completion
    // opens the sendwindow.
    //
    if (LinkCB->OutstandingFrames == LinkCB->SendWindow) {
        LinkCB->SendWindowOpen = TRUE;
        if (LinkCB->LinkActive) {
            BundleCB->SendingLinks++;
        }
    }

    LinkCB->OutstandingFrames--;

    if (DescFlags & SEND_DESC_FRAG) {
        InterlockedDecrement(&ProtocolCB->PacketQueue[Class].OutstandingFrags);
    }

    pulRefCount =
        &(PMINIPORT_RESERVED_FROM_NDIS(OriginalPacket)->RefCount);

    ASSERT(*pulRefCount > 0);

    //
    // See if the reference count is zero, if it is not
    // we just return.
    //
    if (InterlockedDecrement(pulRefCount) != 0) {

        SendPacketOnBundle(BundleCB);

        return;
    }

    ReleaseBundleLock(BundleCB);

    //
    // Complete this NdisPacket back to the transport
    //
    NDIS_SET_PACKET_STATUS(OriginalPacket, Status);
    CompleteNdisPacket(ProtocolCB->MiniportCB,
                       ProtocolCB,
                       OriginalPacket);

    AcquireBundleLock(BundleCB);

    BundleCB->OutstandingFrames--;

    if ((BundleCB->Flags & FRAMES_PENDING_EVENT) &&
        (BundleCB->OutstandingFrames == 0)) {

        NdisWanSetSyncEvent(&BundleCB->OutstandingFramesEvent);
    }

    //
    // Called with bundle lock help but returns with lock released
    //
    SendPacketOnBundle(BundleCB);

    //
    // Deref for ref applied when sent a packet to be framed.
    //
    DEREF_BUNDLECB(BundleCB);
}

#if 0
ULONG
CalcPPPHeaderLength(
    ULONG   FramingBits,
    ULONG   Flags
    )
{
    ULONG   HeaderLength = 0;

    if (FramingBits & PPP_FRAMING) {

        if (!(FramingBits & PPP_COMPRESS_ADDRESS_CONTROL)) {
            //
            // If there is no address/control compression
            // we need a pointer and a length
            //

            if (FramingBits & LLC_ENCAPSULATION) {
                HeaderLength += 4;
            } else {
                HeaderLength += 2;
            }
        }

        //
        // If this is not from our private I/O interface we will
        // build the rest of the header.
        //
        if (FramingBits & PPP_MULTILINK_FRAMING) {

            if (!(FramingBits & PPP_COMPRESS_PROTOCOL_FIELD)) {
                //
                // No protocol compression
                //
                HeaderLength += 1;
            }

            HeaderLength += 1;

            if (!(FramingBits & PPP_SHORT_SEQUENCE_HDR_FORMAT)) {
                //
                // We are using long sequence number
                //
                HeaderLength += 2;
            }

            HeaderLength += 2;
        }

        if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {
            //
            // We are doing compression/encryption so we need
            // a length
            //

            //
            // It appears that legacy ras (< NT 4.0) requires that
            // the PPP protocol field in a compressed packet not
            // be compressed, ie has to have the leading 0x00
            //
            if (!(FramingBits & PPP_COMPRESS_PROTOCOL_FIELD)) {
                //
                // No protocol compression
                //
                HeaderLength += 1;
            }

            //
            // Add protocol and coherency bytes
            //
            HeaderLength += 3;
        }


        if (!(FramingBits & PPP_COMPRESS_PROTOCOL_FIELD) ||
            (Flags & (DO_COMPRESSION | DO_ENCRYPTION))) {
            HeaderLength += 1;
        }

        HeaderLength += 1;

    } else if (FramingBits & RAS_FRAMING) {
        //
        // If this is old ras framing:
        //
        // Alter the framing so that 0xFF 0x03 is not added
        // and that the first byte is 0xFD not 0x00 0xFD
        //
        // So basically, a RAS compression looks like
        // <0xFD> <2 BYTE COHERENCY> <NBF DATA FIELD>
        //
        // Whereas uncompressed looks like
        // <NBF DATA FIELD> which always starts with 0xF0
        //
        // If this is ppp framing:
        //
        // A compressed frame will look like (before address/control
        // - multilink is added)
        // <0x00> <0xFD> <2 Byte Coherency> <Compressed Data>
        //
        if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {

            //
            // Coherency bytes
            //
            HeaderLength += 3;
        }
    }

    // DbgPrint("PPPHeaderLength %d\n", HeaderLength);

    return (HeaderLength);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\request.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Request.c

Abstract:


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe  06/06/95    Created

--*/

#include "wan.h"

#define __FILE_SIG__    REQUEST_FILESIG

static UINT CoSupportedOids[] =
{
    OID_GEN_CO_SUPPORTED_LIST,
    OID_GEN_CO_HARDWARE_STATUS,
    OID_GEN_CO_MEDIA_SUPPORTED,
    OID_GEN_CO_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_CO_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_CO_VENDOR_ID,
    OID_GEN_CO_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_CO_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_CO_PROTOCOL_OPTIONS,
    OID_GEN_CO_MAC_OPTIONS,
    OID_GEN_CO_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_CO_VENDOR_DRIVER_VERSION,
    OID_GEN_CO_MINIMUM_LINK_SPEED,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_WAN_PERMANENT_ADDRESS,
    OID_WAN_CURRENT_ADDRESS,
    OID_WAN_QUALITY_OF_SERVICE,
    OID_WAN_MEDIUM_SUBTYPE,
    OID_WAN_PROTOCOL_TYPE,
    OID_WAN_HEADER_FORMAT,
    OID_WAN_LINE_COUNT,
    OID_QOS_ISSLOW_FRAGMENT_SIZE
};

NDIS_STATUS
NdisWanCoOidProc(
    IN  PMINIPORTCB         pMiniportCB,
    IN  PCM_VCCB            CmVcCB OPTIONAL,
    IN OUT PNDIS_REQUEST    NdisRequest
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    NDIS_MEDIUM MediumType;
    ULONG       GenericULong = 0, i;
    USHORT      GenericUShort = 0;
    UCHAR       GenericArray[6];
    PVOID       MoveSource = (PVOID)&GenericULong;
    ULONG       MoveBytes = sizeof(ULONG);
    NDIS_HARDWARE_STATUS    HardwareStatus;
    ULONG       Filter = 0, Oid, OidCat;
    ULONG       InformationBufferLength;
    PUCHAR      InformationBuffer;
    PROTOCOL_INFO   ProtocolInfo = {0};


    Oid = NdisRequest->DATA.QUERY_INFORMATION.Oid;
    OidCat = Oid & 0xFF000000;
    InformationBufferLength =
        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength;
    InformationBuffer =
        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;

    NdisAcquireSpinLock(&pMiniportCB->Lock);

    //
    // We will break the OID's down into smaller categories
    //
    switch (OidCat) {

        //
        // Swith on General Oid's
        //
        case OID_CO_GEN:
            switch (Oid) {
                case OID_GEN_CO_SUPPORTED_LIST:
                    MoveSource = (PVOID)CoSupportedOids;
                    MoveBytes = sizeof(CoSupportedOids);
                    break;

                case OID_GEN_CO_HARDWARE_STATUS:
                    HardwareStatus = pMiniportCB->HardwareStatus;
                    MoveSource = (PVOID)&HardwareStatus;
                    MoveBytes = sizeof(HardwareStatus);
                    break;

                case OID_GEN_CO_MEDIA_SUPPORTED:
                case OID_GEN_CO_MEDIA_IN_USE:
                    MediumType = pMiniportCB->MediumType;
                    MoveSource = (PVOID)&MediumType;
                    MoveBytes = sizeof(MediumType);
                    break;

                case OID_GEN_MAXIMUM_LOOKAHEAD:
                case OID_GEN_CURRENT_LOOKAHEAD:
                    GenericULong = glMRRU;
                    break;
    
                case OID_GEN_MAXIMUM_FRAME_SIZE:
                    ProtocolInfo.ProtocolType = pMiniportCB->ProtocolType;
                    GetProtocolInfo(&ProtocolInfo);
                    GenericULong =
                        (ProtocolInfo.MTU == 0) ? glMaxMTU : ProtocolInfo.MTU;
                    break;

                case OID_GEN_MAXIMUM_TOTAL_SIZE:
                    ProtocolInfo.ProtocolType = pMiniportCB->ProtocolType;
                    GetProtocolInfo(&ProtocolInfo);
                    GenericULong =
                        (ProtocolInfo.MTU == 0) ? glMaxMTU : ProtocolInfo.MTU;
                    GenericULong += 14;
                    break;

                case OID_GEN_CO_LINK_SPEED:
                    //
                    // Who knows what the initial link speed is?
                    // This should not be called, right?
                    //
                    GenericULong = (ULONG)288;
                    break;

                case OID_GEN_TRANSMIT_BUFFER_SPACE:
                case OID_GEN_RECEIVE_BUFFER_SPACE:
                    ProtocolInfo.ProtocolType = pMiniportCB->ProtocolType;
                    GetProtocolInfo(&ProtocolInfo);
                    GenericULong =
                        (ProtocolInfo.MTU == 0) ?
                        (ULONG)(glMaxMTU * MAX_OUTSTANDING_PACKETS) :
                        (ULONG)(ProtocolInfo.MTU * MAX_OUTSTANDING_PACKETS);
                    break;
    
                case OID_GEN_TRANSMIT_BLOCK_SIZE:
                    ProtocolInfo.ProtocolType = pMiniportCB->ProtocolType;
                    GetProtocolInfo(&ProtocolInfo);
                    GenericULong =
                        (ProtocolInfo.MTU == 0) ? glMaxMTU : ProtocolInfo.MTU;
                    break;
    
                case OID_GEN_RECEIVE_BLOCK_SIZE:
                    GenericULong = glMRRU;
                    break;

                case OID_GEN_CO_VENDOR_ID:
                    GenericULong = 0xFFFFFFFF;
                    MoveBytes = 3;
                    break;

                case OID_GEN_CO_VENDOR_DESCRIPTION:
                    MoveSource = (PVOID)"NdisWan Adapter";
                    MoveBytes = 16;
                    break;

                case OID_GEN_CURRENT_PACKET_FILTER:
                    if (NdisRequest->RequestType == NdisRequestSetInformation) {
                        if (InformationBufferLength > 3) {
                            NdisMoveMemory(&Filter, InformationBuffer, 4);
    
                            NdisAcquireSpinLock(&NdisWanCB.Lock);
                            if (Filter &
                                (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) {
                                NdisWanCB.PromiscuousAdapter = pMiniportCB;
                            } else if (NdisWanCB.PromiscuousAdapter == pMiniportCB) {
                                NdisWanCB.PromiscuousAdapter = NULL;
                            }
    
                            NdisReleaseSpinLock(&NdisWanCB.Lock);

                        } else {
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded = 4;
                        }
                    }
                    break;

                case OID_GEN_CO_DRIVER_VERSION:
                    GenericUShort = 0x0500;
                    MoveSource = (PVOID)&GenericUShort;
                    MoveBytes = sizeof(USHORT);
                    break;

                case OID_GEN_CO_MAC_OPTIONS:
                    GenericULong = (ULONG)(NDIS_MAC_OPTION_RECEIVE_SERIALIZED |
                                           NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                                           NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA |
                                           NDIS_MAC_OPTION_RESERVED |
                                           NDIS_MAC_OPTION_NDISWAN);
                    break;

                case OID_GEN_CO_MEDIA_CONNECT_STATUS:
                    GenericULong = (ULONG)NdisMediaStateConnected;
                    break;

                case OID_GEN_CO_XMIT_PDUS_OK:
                    //
                    // 
                    //
                    break;

                case OID_GEN_CO_RCV_PDUS_OK:
                    //
                    // 
                    //
                    break;

                case OID_GEN_CO_XMIT_PDUS_ERROR:
                    //
                    // 
                    //
                    break;

                case OID_GEN_CO_RCV_PDUS_ERROR:
                    //
                    // 
                    //
                    break;

                case OID_GEN_CO_RCV_PDUS_NO_BUFFER:
                    //
                    // 
                    //
                    break;

                case OID_GEN_CO_TRANSMIT_QUEUE_LENGTH:
                    //
                    // 
                    //
                    break;

                default:
                    Status = NDIS_STATUS_INVALID_OID;
                    break;
            }
            break;

        //
        // Switch on ethernet media specific Oid's
        //
        case OID_802_3:
            switch (Oid) {
                case OID_802_3_PERMANENT_ADDRESS:
                case OID_802_3_CURRENT_ADDRESS:
                    ETH_COPY_NETWORK_ADDRESS(GenericArray, pMiniportCB->NetworkAddress);
                    MoveSource = (PVOID)GenericArray;
                    MoveBytes = ETH_LENGTH_OF_ADDRESS;
                    break;

                case OID_802_3_MULTICAST_LIST:
                    MoveBytes = 0;
                    break;

                case OID_802_3_MAXIMUM_LIST_SIZE:
                    GenericULong = 1;
                    break;

                default:
                    Status = NDIS_STATUS_INVALID_OID;
                    break;
            }
            break;

        //
        // Switch on WAN specific Oid's
        //
        case OID_WAN:
            switch (Oid) {
                case OID_WAN_PERMANENT_ADDRESS:
                case OID_WAN_CURRENT_ADDRESS:
                    ETH_COPY_NETWORK_ADDRESS(GenericArray, pMiniportCB->NetworkAddress);
                    MoveSource = (PVOID)GenericArray;
                    MoveBytes = ETH_LENGTH_OF_ADDRESS;
                    break;

                case OID_WAN_QUALITY_OF_SERVICE:
                    GenericULong = NdisWanReliable;
                    break;

                case OID_WAN_MEDIUM_SUBTYPE:
                    GenericULong = NdisWanMediumHub;
                    break;

                case OID_WAN_PROTOCOL_TYPE:
                    {
                        PMINIPORTCB mcb;
                        BOOLEAN     Found = FALSE;

                        if (InformationBufferLength > 5) {

                            pMiniportCB->ProtocolType =
                            (((PUCHAR)InformationBuffer)[4] << 8) |
                            ((PUCHAR)InformationBuffer)[5];

                            pMiniportCB->NumberofProtocols++;
                            MoveBytes = 6;

                            NdisReleaseSpinLock(&pMiniportCB->Lock);
                            //
                            // Walk the miniportcb list and see if this is the only
                            // instance of this protocol.  If it is we need to notify
                            // user-mode that a new protocol is available.
                            //
                            NdisAcquireSpinLock(&MiniportCBList.Lock);

                            mcb = (PMINIPORTCB)MiniportCBList.List.Flink;

                            while ((PVOID)mcb != (PVOID)&MiniportCBList.List) {
                                if (mcb != pMiniportCB) {

                                    if (mcb->ProtocolType ==
                                        pMiniportCB->ProtocolType) {
                                        Found = TRUE;
                                    }
                                }

                                mcb = (PMINIPORTCB)mcb->Linkage.Flink;
                            }

                            NdisReleaseSpinLock(&MiniportCBList.Lock);

                            if (Found == FALSE) {
                                PROTOCOL_INFO   pinfo;

                                NdisZeroMemory(&pinfo, sizeof(pinfo));
                                pinfo.ProtocolType = pMiniportCB->ProtocolType;
                                pinfo.Flags = PROTOCOL_BOUND;
                                SetProtocolInfo(&pinfo);
                            }

                            NdisAcquireSpinLock(&pMiniportCB->Lock);

                        } else {
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded = 6;
                        }
                    }
                    break;

                case OID_WAN_HEADER_FORMAT:
                    GenericULong = NdisWanHeaderEthernet;
                    break;

                case OID_WAN_LINE_COUNT:
                    GenericULong = NdisWanCB.NumberOfLinks;
                    break;

                case OID_WAN_PROTOCOL_CAPS:
                    do {
                        PNDIS_WAN_PROTOCOL_CAPS pcaps;

                        if (InformationBufferLength < sizeof(NDIS_WAN_PROTOCOL_CAPS)) {
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded =
                                sizeof(NDIS_WAN_PROTOCOL_CAPS);
                            break;
                        }

                        pcaps = (PNDIS_WAN_PROTOCOL_CAPS)InformationBuffer;

                        if (pcaps->Flags & WAN_PROTOCOL_KEEPS_STATS) {
                            pMiniportCB->Flags |= PROTOCOL_KEEPS_STATS;
                        }

                        MoveBytes = sizeof(NDIS_WAN_PROTOCOL_CAPS);

                    } while (FALSE);
                    break;

                default:
                    Status = NDIS_STATUS_INVALID_OID;
                    break;
            }
            break;

        case OID_PNP:
            switch (Oid) {
            case OID_PNP_CAPABILITIES:
                break;
            case OID_PNP_SET_POWER:
                break;
            case OID_PNP_QUERY_POWER:
                break;
            case OID_PNP_ENABLE_WAKE_UP:
                break;
            default:
                Status = NDIS_STATUS_INVALID_OID;
                break;
            }
            break;

        case OID_QOS:
            switch (Oid) {
                case OID_QOS_ISSLOW_FRAGMENT_SIZE:

                    do {
                        PBUNDLECB   BundleCB;
                        PSEND_FRAG_INFO FragInfo;

                        if (InformationBufferLength < 4) {
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded = 4;
                            break;
                        }

                        if (((PLONG)InformationBuffer)[0] < 0) {
                            Status = NDIS_STATUS_INVALID_DATA;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded = 4;
                            break;
                        }

                        if (((PULONG)InformationBuffer)[0] == 0) {
                            Status = NDIS_STATUS_INVALID_DATA;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded = 4;
                            break;
                        }

                        if (CmVcCB == NULL) {

                            if (((PULONG)InformationBuffer)[0] < glMaxFragSize) {
                                glMaxFragSize = ((PULONG)InformationBuffer)[0];
                            }

                            if (glMaxFragSize < glMinFragSize) {
                                glMinFragSize = glMaxFragSize;
                            }

                        } else {
                            BundleCB = CmVcCB->ProtocolCB->BundleCB;

                            AcquireBundleLock(BundleCB);

                            FragInfo = &BundleCB->SendFragInfo[0];

                            if (((PULONG)InformationBuffer)[0] < FragInfo->MaxFragSize) {

                                FragInfo->MaxFragSize =
                                    ((PULONG)InformationBuffer)[0];
                            }

                            if (FragInfo->MaxFragSize < glMinFragSize) {
                                FragInfo->MaxFragSize = glMinFragSize;
                            }

                            if (FragInfo->MaxFragSize > glMaxFragSize) {
                                FragInfo->MaxFragSize = glMaxFragSize;
                            }

                            ReleaseBundleLock(BundleCB);

                        }


                        MoveBytes = 4;

                    } while (FALSE);

                    break;

                default:
                    Status = NDIS_STATUS_INVALID_OID;
                    break;
            }
            break;

        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    if (Status == NDIS_STATUS_SUCCESS) {

        if (NdisRequest->RequestType == NdisRequestSetInformation) {
            NdisRequest->DATA.SET_INFORMATION.BytesRead = MoveBytes;
        } else if (NdisRequest->RequestType == NdisRequestQueryInformation ||
                   NdisRequest->RequestType == NdisRequestQueryStatistics) {
            
            if (MoveBytes > InformationBufferLength) {
    
                //
                // Not enough room in the information buffer
                //
                NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded =
                    MoveBytes;
    
                Status = NDIS_STATUS_INVALID_LENGTH;
    
            } else {
    
                NdisRequest->DATA.QUERY_INFORMATION.BytesWritten =
                    MoveBytes;
    
                NdisMoveMemory(InformationBuffer,
                               MoveSource,
                               MoveBytes);
            }
        } else {
            Status = NDIS_STATUS_INVALID_OID;
        }
    }

    NdisReleaseSpinLock(&pMiniportCB->Lock);

    return (Status);
}

NDIS_STATUS
NdisWanSubmitNdisRequest(
    IN  POPENCB         pOpenCB,
    IN  PWAN_REQUEST    WanRequest
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status;
    BOOLEAN     SyncRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("SubmitNdisRequest: Enter - WanRequest %p", WanRequest));

    NdisAcquireSpinLock(&pOpenCB->Lock);

    if (pOpenCB->Flags & OPEN_CLOSING) {

        NdisReleaseSpinLock(&pOpenCB->Lock);

        return (NDIS_STATUS_FAILURE);
    }

    REF_OPENCB(pOpenCB);

    NdisReleaseSpinLock(&pOpenCB->Lock);

    SyncRequest = (WanRequest->Type == SYNC);

    if (pOpenCB->Flags & OPEN_LEGACY ||
        WanRequest->VcHandle == NULL) {
        NdisRequest(&Status,
                    pOpenCB->BindingHandle,
                    &WanRequest->NdisRequest);
    } else {
        Status =
        NdisCoRequest(pOpenCB->BindingHandle,
                      WanRequest->AfHandle,
                      WanRequest->VcHandle,
                      NULL,
                      &WanRequest->NdisRequest);
    }

    //
    // We will only wait for request that are to complete
    // synchronously with respect to this function.  We will
    // wait here for completion.
    //
    if ((SyncRequest == TRUE) &&
        (Status == NDIS_STATUS_PENDING)) {

        NdisWanWaitForNotificationEvent(&WanRequest->NotificationEvent);

        Status = WanRequest->NotificationStatus;

        NdisWanClearNotificationEvent(&WanRequest->NotificationEvent);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, 
                  ("SubmitNdisRequest: Exit Status 0x%x", Status));

    DEREF_OPENCB(pOpenCB);

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\sources.inc ===
SOURCES_USED=..\sources.inc
TARGETTYPE=DRIVER

C_DEFINES=$(C_DEFINES) -DNT -DNDIS50 -DNDIS50_MINIPORT -D_WAN50_ \
    -DNDIS_MINIPORT_DRIVER -DBINARY_COMPATIBLE=0 -D_PNP_POWER_ \
    -DUSE_RW_CONNTBLLOCK -DEAP_ON
    
PRECOMPILED_INCLUDE=..\wan.h
PRECOMPILED_PCH=wan.pch
PRECOMPILED_OBJ=wan.obj

TARGETLIBS=\
    $(DDK_LIB_PATH)\ndis.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    ..\..\ndistapi\$(O)\ndistapi.lib

INCLUDES=..;..\..\inc;..\..\..\inc;$(DS_INC_PATH)\crypto

SOURCES=\
    ..\ccp.c \
    ..\cl.c \
    ..\cm.c \
    ..\compress.c \
    ..\indicate.c \
    ..\init.c \
    ..\io.c \
    ..\loopback.c \
    ..\memory.c \
    ..\miniport.c \
    ..\ndiswan.rc \
    ..\protocol.c \
    ..\receive.c \
    ..\request.c \
    ..\send.c \
    ..\tapi.c \
    ..\util.c \
    ..\vjslip.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\send.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Send.c

Abstract:

    This file contains the procedures for doing a send from a protocol, bound
    to the upper interface of NdisWan, to a Wan Miniport link, bound to the
    lower interfaceof NdisWan.  The upper interface of NdisWan conforms to the
    NDIS 3.1 Miniport specification.  The lower interface of NdisWan conforms
    to the NDIS 3.1 Extentions for Wan Miniport drivers.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#ifdef DBG_SENDARRAY
UCHAR   SendArray[MAX_BYTE_DEPTH] = {0};
ULONG   __si = 0;
#endif

#define __FILE_SIG__    SEND_FILESIG

//
// Local function prototypes
//
USHORT
DoVJHeaderCompression(
    PBUNDLECB   BundleCB,
    PNDIS_PACKET    NdisPacket,
    PUCHAR      *CurrentBuffer,
    PULONG      CurrentLength,
    PULONG      PacketOffset
    );

VOID
DoCompressionEncryption(
    PBUNDLECB               BundleCB,
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              *SendDesc
    );

VOID
FragmentAndQueue(
    PBUNDLECB               BundleCB,
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              SendDesc,
    PLIST_ENTRY             LinkCBList,
    ULONG                   SendingLinks
    );

ULONG
GetSendingLinks(
    PBUNDLECB   BundleCB,
    INT         Class,
    PLIST_ENTRY lcbList
    );

VOID
GetNextProtocol(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB *ProtocolCB,
    PULONG      SendMask
    );

VOID
BuildLinkHeader(
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              SendDesc
    );

//
// end of local function prototypes
//
VOID
NdisWanQueueSend(
    IN  PMINIPORTCB     MiniportCB,
    IN  PNDIS_PACKET    NdisPacket
    )
{
    PNDIS_BUFFER    NdisBuffer;
    UINT            BufferCount, PacketLength;
    PETH_HEADER     EthernetHeader;
    BOOLEAN         SendOnWire = FALSE;
    BOOLEAN         CompletePacket = FALSE;
    ULONG           BufferLength;
    PUCHAR          DestAddr, SrcAddr;
    PBUNDLECB       BundleCB = NULL;
    PPROTOCOLCB     ProtocolCB = NULL;
    PCM_VCCB        CmVcCB = NULL;
    INT             Class;
    PPACKET_QUEUE   PacketQueue;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("NdisWanQueueSend: Enter"));

    NdisWanInterlockedInc(&glSendCount);

    NdisQueryPacket(NdisPacket,
        NULL,
        &BufferCount,
        &NdisBuffer,
        &PacketLength);

    NdisQueryBuffer(NdisBuffer,
                    &EthernetHeader,
                    &BufferLength);

    CmVcCB = PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->CmVcCB;

    if (BufferCount == 0 || BufferLength < 14) {

        //
        // Malformed packet!
        //
        CompletePacket = TRUE;

        goto QUEUE_SEND_EXIT;
    }

    //
    // Check the ndis packet flags to make sure this is not just a loopback
    // packet.  If it is we will just complete it back to the stack per 
    // winse 22881.
    //
    if (NdisGetPacketFlags(NdisPacket) & NDIS_FLAGS_LOOPBACK_ONLY) {

        //
        // Complete the packet back to the stack without sending on
        // the wire.  We might need to do loopback for these packets
        // at somepoint.
        //
        CompletePacket = TRUE;

        goto QUEUE_SEND_EXIT;
    }

    DestAddr = EthernetHeader->DestAddr;
    SrcAddr = EthernetHeader->SrcAddr;

    //
    // Is this destined for the wire or is it self directed?
    // If SendOnWire is FALSE this is a self directed packet.
    //
    ETH_COMPARE_NETWORK_ADDRESSES_EQ(DestAddr, SrcAddr, &SendOnWire);

    //
    // Do we need to do loopback?  We can check for both multicast
    // and broadcast with one check because we don't differentiate
    // between the two.
    //
    if (!SendOnWire || (DestAddr[0] & 1)) {
        NdisWanIndicateLoopbackPacket(MiniportCB, NdisPacket);
    }

    //
    // We don't want to send packets from bloodhound
    //
    if (!SendOnWire ||
        (MiniportCB == NdisWanCB.PromiscuousAdapter)) {

        CompletePacket = TRUE;

        goto QUEUE_SEND_EXIT;
    }

    //
    // We play special tricks with NBF because NBF is
    // guaranteed to have a one-to-one mapping between
    // an adapter and a bundle.  We need to do this because
    // we may need the mac address information.
    //
    if (MiniportCB->ProtocolType == PROTOCOL_NBF) {

        ProtocolCB = MiniportCB->NbfProtocolCB;

        if (ProtocolCB == NULL) {

            //
            // This should just fall through and complete successfully.
            //
            NdisWanDbgOut(DBG_TRACE, DBG_SEND,
                ("NdisWanSend: Invalid ProtocolCB %x! Miniport %p, ProtoType %x",
                ProtocolCB, MiniportCB, MiniportCB->ProtocolType));

            CompletePacket = TRUE;

            goto QUEUE_SEND_EXIT;
        }

        BundleCB = ProtocolCB->BundleCB;

        if (BundleCB == NULL) {
            //
            // This should just fall through and complete successfully.
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: Invalid Bundle!"));

            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: MiniportCB: 0x%p, ProtocolType: 0x%x!", MiniportCB, MiniportCB->ProtocolType));

            CompletePacket = TRUE;

            goto QUEUE_SEND_EXIT;
        }

        AcquireBundleLock(BundleCB);

        if (BundleCB->State != BUNDLE_UP) {

            //
            // This should just fall through and complete successfully.
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: Invalid BundleState 0x%x", BundleCB->State));

            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: MiniportCB: 0x%p, ProtocolType: 0x%x!", MiniportCB, MiniportCB->ProtocolType));

            CompletePacket = TRUE;

            ReleaseBundleLock(BundleCB);

            BundleCB = NULL;

            goto QUEUE_SEND_EXIT;
        }

        REF_BUNDLECB(BundleCB);

    } else {
        ULONG_PTR   BIndex, PIndex;

        //
        // Get the ProtocolCB from the DestAddr
        //
        GetNdisWanIndices(DestAddr, BIndex, PIndex);

        if (!IsBundleValid((NDIS_HANDLE)BIndex, 
                           TRUE,
                           &BundleCB)) {
            //
            // This should just fall through and complete successfully.
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: BundleCB is not valid!, BundleHandle: 0x%x", BIndex));
            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: MiniportCB: 0x%p, ProtocolType: 0x%x!", MiniportCB, MiniportCB->ProtocolType));

            CompletePacket = TRUE;

            goto QUEUE_SEND_EXIT;
        }

        AcquireBundleLock(BundleCB);

        PROTOCOLCB_FROM_PROTOCOLH(BundleCB, ProtocolCB, PIndex);
    }

    if (ProtocolCB == NULL ||
        ProtocolCB == RESERVED_PROTOCOLCB) {
        //
        // This should just fall through and complete successfully.
        //
        NdisWanDbgOut(DBG_TRACE, DBG_SEND,
            ("NdisWanSend: Invalid ProtocolCB %x! Miniport %p, ProtoType %x",
            ProtocolCB, MiniportCB, MiniportCB->ProtocolType));

        CompletePacket = TRUE;

        ReleaseBundleLock(BundleCB);

        goto QUEUE_SEND_EXIT;
    }

    if (ProtocolCB->State != PROTOCOL_ROUTED) {

        NdisWanDbgOut(DBG_FAILURE, DBG_SEND,("NdisWanSend: Problem with route!"));

        NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
            ("NdisWanSend: ProtocolCB: 0x%p, State: 0x%x",
            ProtocolCB, ProtocolCB->State));

        CompletePacket = TRUE;

        ReleaseBundleLock(BundleCB);

        goto QUEUE_SEND_EXIT;
    }

    //
    // For the packet that we are inserting
    //
    REF_PROTOCOLCB(ProtocolCB);

    NdisInterlockedIncrement(&ProtocolCB->OutstandingFrames);

    //
    // Queue the packet on the ProtocolCB NdisPacketQueue
    //
    Class = (CmVcCB != NULL) ? CmVcCB->FlowClass : 0;

    NDIS_SET_PACKET_STATUS(NdisPacket, NDIS_STATUS_PENDING);

    ASSERT(Class <= MAX_MCML);

    PacketQueue = &ProtocolCB->PacketQueue[Class];

    INSERT_DBG_SEND(PacketTypeNdis,
                    MiniportCB,
                    ProtocolCB,
                    NULL,
                    NdisPacket);

    InsertTailPacketQueue(PacketQueue, NdisPacket, PacketLength);

#ifdef DBG_SENDARRAY
{
    if (Class < MAX_MCML) {
        SendArray[__si] = 'P';
    } else {
        SendArray[__si] = 'Q';
    }
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    if (PacketQueue->ByteDepth > PacketQueue->MaxByteDepth) {
        //
        // We have queue more then we should so lets flush
        // This alogrithm should be fancied up at some point
        // to use Random Early Detection!!!!!
        //
        NdisPacket =
            RemoveHeadPacketQueue(PacketQueue);

        if (NdisPacket != NULL) {
            PacketQueue->DumpedPacketCount++;
            PacketQueue->DumpedByteCount +=
                (NdisPacket->Private.TotalLength - 14);
            ReleaseBundleLock(BundleCB);
            CompleteNdisPacket(ProtocolCB->MiniportCB,
                               ProtocolCB,
                               NdisPacket);
            AcquireBundleLock(BundleCB);
        }
    }

    //
    // If we are cleared to send data then
    // try to process the protocol queues
    //
    if (!(BundleCB->Flags & PAUSE_DATA)) {
        SendPacketOnBundle(ProtocolCB->BundleCB);
    } else {
        ReleaseBundleLock(BundleCB);
    }


QUEUE_SEND_EXIT:

    if (CompletePacket) {
        NDIS_SET_PACKET_STATUS(NdisPacket, NDIS_STATUS_SUCCESS);

        if (CmVcCB != NULL) {
            NdisMCoSendComplete(NDIS_STATUS_SUCCESS,
                CmVcCB->NdisVcHandle,
                NdisPacket);

            DEREF_CMVCCB(CmVcCB);

        } else {
            NdisMSendComplete(MiniportCB->MiniportHandle,
                NdisPacket,
                NDIS_STATUS_SUCCESS);
        }

        NdisWanInterlockedInc(&glSendCompleteCount);
    }

    //
    // Deref for ref applied in IsBundleValid
    //
    DEREF_BUNDLECB(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("NdisWanQueueSend: Exit"));
}


VOID
SendPacketOnBundle(
    PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

    Called with bundle lock held but returns with lock released!!!

Arguments:

Return Values:

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_PENDING;
    ULONG           SendMask;
    PPROTOCOLCB     ProtocolCB, IOProtocolCB;
    BOOLEAN         PPPSent;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendPacketOnBundle: Enter"));

    //
    // Are we already involved in a send on this bundlecb?
    //
    if (BundleCB->Flags & IN_SEND) {

        //
        // If so flag that we should try back later
        // and get the out.
        //
        BundleCB->Flags |= TRY_SEND_AGAIN;

        ReleaseBundleLock(BundleCB);

        return;
    }

    BundleCB->Flags |= IN_SEND;

    IOProtocolCB = BundleCB->IoProtocolCB;

TryAgain:

    SendMask = BundleCB->SendMask;

    //
    // If the bundle is not up we will not send!
    //
    if (BundleCB->State != BUNDLE_UP) {
        goto TryNoMore;
    }

    do {
        BOOLEAN PacketSent = FALSE;
        BOOLEAN CouldSend;

        //
        // First try to send from the PPP send queue
        //
        do {

            CouldSend =
                SendFromPPP(BundleCB, IOProtocolCB, &PPPSent);

        } while (PPPSent);


        //
        // If we could not send a PPP frame get out
        //
        if (!CouldSend) {
            break;
        }

        //
        // This will force round-robin sends
        //
        GetNextProtocol(BundleCB, &ProtocolCB, &SendMask);

        if (ProtocolCB != NULL) {

            REF_PROTOCOLCB(ProtocolCB);

            if (BundleCB->Flags & QOS_ENABLED) {

                if (BundleCB->Flags & SEND_FRAGMENT) {
SendQosFrag:
                    //
                    // Send a single fragment from the fragment queue
                    //
                    CouldSend =
                        SendFromFragQueue(BundleCB,
                                          TRUE,
                                          &PacketSent);
                    if (CouldSend) {
                        BundleCB->Flags &= ~(SEND_FRAGMENT);
                    }
                }

                //
                // If we sent a fragment let the completion
                // handler send the next frame.
                //
                if (!PacketSent) {

                    //
                    // Now try the protocol's packet queues
                    //
                    if (SendMask != 0) {
                        INT Class;
                        INT i;

                        for (i = 0; i <= MAX_MCML; i++) {

                            CouldSend =
                                SendFromProtocol(BundleCB,
                                                 ProtocolCB,
                                                 &Class,
                                                 &SendMask,
                                                 &PacketSent);

                            if (!CouldSend) {
                                break;
                            }

                            BundleCB->Flags |= (SEND_FRAGMENT);

                            if (PacketSent) {
                                break;
                            }
                        }

                        if (!PacketSent ||
                            (PacketSent && (Class != MAX_MCML))) {

                            goto SendQosFrag;
                        }
                    }
                }

            } else {

                //
                // Now try the protocol's packet queues
                //
                if (SendMask != 0) {
                    INT Class;
                    INT i;

                    for (i = 0; i <= MAX_MCML; i++) {

                        CouldSend =
                            SendFromProtocol(BundleCB,
                                             ProtocolCB,
                                             &Class,
                                             &SendMask,
                                             &PacketSent);

                    }
                }

                SendFromFragQueue(BundleCB,
                                  FALSE,
                                  &PacketSent);
            }

            DEREF_PROTOCOLCB(ProtocolCB);
        }

    } while ((SendMask != 0) &&
             (BundleCB->State == BUNDLE_UP));

TryNoMore:

    //
    // Did someone try to do a send while we were already
    // sending on this bundle?
    //
    if (BundleCB->Flags & TRY_SEND_AGAIN) {

        //
        // If so clear the flag and try another send.
        //
        BundleCB->Flags &= ~TRY_SEND_AGAIN;

        goto TryAgain;

    }

#ifdef DBG_SENDARRAY
{
    SendArray[__si] = 'Z';
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    //
    // Clear the in send flag.
    //
    BundleCB->Flags &= ~IN_SEND;

    ReleaseBundleLock(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendPacketOnBundle: Exit"));
}

BOOLEAN
SendFromPPP(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB,
    PBOOLEAN    PacketSent
    )
{
    PLINKCB         LinkCB;
    PNDIS_PACKET    NdisPacket;
    PPACKET_QUEUE   PacketQueue;
    INT             SendingClass;
    BOOLEAN         CouldSend;
    ULONG           BytesSent;

    PacketQueue = &ProtocolCB->PacketQueue[MAX_MCML];

    CouldSend = TRUE;
    *PacketSent = FALSE;

    while (!IsPacketQueueEmpty(PacketQueue)) {
        LIST_ENTRY  LinkCBList;
        ULONG       SendingLinks;

        NdisPacket = PacketQueue->HeadQueue;

        LinkCB = 
            PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->LinkCB;

        NdisAcquireSpinLock(&LinkCB->Lock);

        if (LinkCB->State != LINK_UP) {

            NdisReleaseSpinLock(&LinkCB->Lock);

            NdisReleaseSpinLock(&BundleCB->Lock);

            DEREF_LINKCB(LinkCB);

            NdisAcquireSpinLock(&BundleCB->Lock);

            //
            // The link has gone down since this send was
            // queued so destroy the packet
            //
            RemoveHeadPacketQueue(PacketQueue);
            FreeIoNdisPacket(NdisPacket);
            continue;
        }

        if (!LinkCB->SendWindowOpen) {
            //
            // We can not send from the I/O queue because the send
            // window for this link is closed.  We will not send
            // any data until the link has resources!
            //
            CouldSend = FALSE;

            NdisReleaseSpinLock(&LinkCB->Lock);

            break;
        }

        NdisReleaseSpinLock(&LinkCB->Lock);

        //
        // Build the linkcb send list
        //
        InitializeListHead(&LinkCBList);
        InsertHeadList(&LinkCBList, &LinkCB->SendLinkage);
        SendingLinks = 1;

        //
        // We are sending this packet so take it off of the list
        //
        RemoveHeadPacketQueue(PacketQueue);

        SendingClass = MAX_MCML;

        ASSERT(NdisPacket != NULL);
        ASSERT(ProtocolCB != NULL);

        //
        // We we get here we should have a valid NdisPacket with at least one link
        // that is accepting sends
        //

        //
        // We will get the packet into a contiguous buffer, and do framing,
        // compression and encryption.
        //
        REF_BUNDLECB(BundleCB);
        BytesSent = FramePacket(BundleCB,
                                ProtocolCB,
                                NdisPacket,
                                &LinkCBList,
                                SendingLinks,
                                SendingClass);
        *PacketSent = TRUE;
    }

    return (CouldSend);
}

BOOLEAN
SendFromProtocol(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB,
    PINT        RetClass,
    PULONG      SendMask,
    PBOOLEAN    PacketSent
    )
{
    ULONG           BytesSent;
    BOOLEAN         CouldSend;
    PNDIS_PACKET    NdisPacket;
    PPACKET_QUEUE   PacketQueue;
    INT             Class;
    LIST_ENTRY      LinkCBList;
    ULONG           SendingLinks;

    CouldSend = TRUE;
    *PacketSent = FALSE;
    InitializeListHead(&LinkCBList);

    ASSERT(ProtocolCB != NULL);

    do {

        Class = ProtocolCB->NextPacketClass;

        *RetClass = Class;

        *SendMask &= ~(ProtocolCB->SendMaskBit);

        PacketQueue =
            &ProtocolCB->PacketQueue[Class];

        if (IsPacketQueueEmpty(PacketQueue)) {
            break;
        }

        if (BundleCB->Flags & QOS_ENABLED) {

            if ((Class < MAX_MCML) &&
                (PacketQueue->OutstandingFrags != 0)) {
                break;
            }

        } else {

            if (BundleCB->SendingLinks == 0) {
                break;
            }
        }

        //
        // Build a list of linkcb's that can be sent over
        //

        SendingLinks =
            GetSendingLinks(BundleCB, Class, &LinkCBList);

        //
        // If there are no links/resources available
        // to send over then get out
        //
        if (SendingLinks == 0) {
            CouldSend = FALSE;
            break;
        }

        NdisPacket =
            RemoveHeadPacketQueue(PacketQueue);

        ASSERT(NdisPacket != NULL);

        *PacketSent = TRUE;

        if (!(BundleCB->Flags & QOS_ENABLED)) {
            *SendMask |= ProtocolCB->SendMaskBit;
        }

        //
        // We we get here we should have a valid NdisPacket with at least one link
        // that is accepting sends
        //
        //
        // We will get the packet into a contiguous buffer, and do framing,
        // compression and encryption.
        //
        REF_BUNDLECB(BundleCB);
        BytesSent = FramePacket(BundleCB,
                                ProtocolCB,
                                NdisPacket,
                                &LinkCBList,
                                SendingLinks,
                                Class);
#ifdef DBG_SENDARRAY
{
    if (Class < MAX_MCML) {
        SendArray[__si] = 'p';
    } else {
        SendArray[__si] = 'q';
    }
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    } while (FALSE);

    if (CouldSend) {
        ProtocolCB->NextPacketClass += 1;

        if (ProtocolCB->NextPacketClass > MAX_MCML) {
            ProtocolCB->NextPacketClass = 0;
        }
    }

    //
    // If there are any LinkCB's still on the send list
    // we have to remove the reference from them
    //
    if (!IsListEmpty(&LinkCBList)) {
        PLIST_ENTRY le;
        PLINKCB lcb;

        ReleaseBundleLock(BundleCB);

        //
        // unroll the loop so that the correct link
        // is setup for the next link to xmit
        //
        le = RemoveHeadList(&LinkCBList);
        lcb = CONTAINING_RECORD(le, LINKCB, SendLinkage);

        BundleCB->NextLinkToXmit = lcb;

        DEREF_LINKCB(lcb);

        while (!IsListEmpty(&LinkCBList)) {

            le = RemoveHeadList(&LinkCBList);
            lcb = CONTAINING_RECORD(le, LINKCB, SendLinkage);

            DEREF_LINKCB(lcb);

        }

        AcquireBundleLock(BundleCB);
    }

    return (CouldSend);
}

BOOLEAN
SendFromFragQueue(
    PBUNDLECB   BundleCB,
    BOOLEAN     SendOne,
    PBOOLEAN    FragSent
    )
{
    ULONG           i;
    BOOLEAN         CouldSend;

    CouldSend = TRUE;
    *FragSent = FALSE;

    for (i = 0; i < MAX_MCML; i++) {
        PSEND_DESC  SendDesc;
        PSEND_FRAG_INFO FragInfo;
        PLINKCB         LinkCB;

        FragInfo =
            &BundleCB->SendFragInfo[BundleCB->NextFragClass];

        BundleCB->NextFragClass += 1;

        if (BundleCB->NextFragClass == MAX_MCML) {
            BundleCB->NextFragClass = 0;
        }

        if (FragInfo->FragQueueDepth == 0) {
            continue;
        }

        SendDesc = (PSEND_DESC)FragInfo->FragQueue.Flink;

        LinkCB = SendDesc->LinkCB;

        while ((PVOID)SendDesc != (PVOID)&FragInfo->FragQueue) {
            ULONG   BytesSent;

            if (!LinkCB->SendWindowOpen) {
                //
                // We can't send on this link!
                //
                CouldSend = FALSE;
                SendDesc = (PSEND_DESC)SendDesc->Linkage.Flink;
                LinkCB = SendDesc->LinkCB;
                FragInfo->WinClosedCount++;
                continue;
            }

            CouldSend = TRUE;

            RemoveEntryList(&SendDesc->Linkage);

            FragInfo->FragQueueDepth--;

            *FragSent = TRUE;

            ASSERT((LONG)FragInfo->FragQueueDepth >= 0);

            BytesSent =
                (*LinkCB->SendHandler)(SendDesc);

#ifdef DBG_SENDARRAY
{
            SendArray[__si] = 0x40 + (UCHAR)LinkCB->hLinkHandle;
            if (++__si == MAX_BYTE_DEPTH) {
                __si = 0;
            }
}
#endif
            //
            // Update the bandwidth on demand sample array with the latest send.
            // If we need to notify someone of a bandwidth event do it.
            //
            if (BundleCB->Flags & BOND_ENABLED) {
                UpdateBandwidthOnDemand(BundleCB->SUpperBonDInfo, BytesSent);
                CheckUpperThreshold(BundleCB);
                UpdateBandwidthOnDemand(BundleCB->SLowerBonDInfo, BytesSent);
                CheckLowerThreshold(BundleCB);
            }

            SendDesc =
                (PSEND_DESC)FragInfo->FragQueue.Flink;
            LinkCB = SendDesc->LinkCB;

            //
            // If we are only supposed to send a single
            // fragment then we need to get out
            //
            if (SendOne) {
                break;
            }
        }

        //
        // If we are only supposed to send a single
        // fragment then we need to get out
        //
        if (SendOne) {
            break;
        }
    }

    return (CouldSend);
}

UINT
FramePacket(
    PBUNDLECB       BundleCB,
    PPROTOCOLCB     ProtocolCB,
    PNDIS_PACKET    NdisPacket,
    PLIST_ENTRY     LinkCBList,
    ULONG           SendingLinks,
    INT             Class
    )
{
    ULONG       Flags, BytesSent;
    ULONG       PacketOffset = 0, CurrentLength = 0;
    PUCHAR      CurrentData;
    PLINKCB     LinkCB = NULL;
    USHORT      PPPProtocolID;
    PSEND_DESC  SendDesc;
    HEADER_FRAMING_INFO FramingInfoBuffer;
    PHEADER_FRAMING_INFO FramingInfo = &FramingInfoBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendPacket: Enter"));

    ASSERT(!IsListEmpty(LinkCBList));

    Flags = BundleCB->SendFlags;

    PPPProtocolID = 
        ProtocolCB->PPPProtocolID;

    //
    // If this is a directed PPP packet then send to
    // the link indicated in the packet
    //
    if (PPPProtocolID == PPP_PROTOCOL_PRIVATE_IO) {
        Flags |= IO_PROTOCOLID;
        Flags &= ~(DO_COMPRESSION | DO_ENCRYPTION | DO_MULTILINK);
    }

    //
    // Did the last receive cause us to flush?
    //
    if ((Flags & (DO_COMPRESSION | DO_ENCRYPTION)) &&
        (BundleCB->Flags & RECV_PACKET_FLUSH)) {
        BundleCB->Flags &= ~RECV_PACKET_FLUSH;
        Flags |= DO_FLUSH;
    }

    Flags |= FIRST_FRAGMENT;

    if (Class == MAX_MCML) {

        Flags &= ~(DO_COMPRESSION | DO_ENCRYPTION | DO_MULTILINK);
    }

    //
    // Get a linkcb to send over
    //
    {
        PLIST_ENTRY  Entry;

        Entry = RemoveHeadList(LinkCBList);

        LinkCB =
            CONTAINING_RECORD(Entry, LINKCB, SendLinkage);
    }

    //
    // Get a send desc
    //
    {
        ULONG   PacketLength;

        NdisQueryPacket(NdisPacket,
                        NULL,
                        NULL,
                        NULL,
                        &PacketLength);
        SendDesc =
            NdisWanAllocateSendDesc(LinkCB, PacketLength);

        if (SendDesc == NULL) {

            ASSERT(SendDesc != NULL);

            ReleaseBundleLock(BundleCB);

            NDIS_SET_PACKET_STATUS(NdisPacket, NDIS_STATUS_RESOURCES);
            CompleteNdisPacket(ProtocolCB->MiniportCB,
                               ProtocolCB,
                               NdisPacket);
            AcquireBundleLock(BundleCB);

            goto FramePacketExit;
        }
    }
    

    BundleCB->OutstandingFrames++;

    SendDesc->ProtocolCB = ProtocolCB;
    SendDesc->OriginalPacket = NdisPacket;
    SendDesc->Class = Class;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND,
        ("SendDesc: %p NdisPacket: %p", SendDesc, NdisPacket));

    //
    // Build a PPP Header in the buffer and update
    // current pointer
    //
    FramingInfo->FramingBits =
        LinkCB->LinkInfo.SendFramingBits;
    FramingInfo->Flags = Flags;
    FramingInfo->Class = Class;

    BuildLinkHeader(FramingInfo, SendDesc);

    CurrentData =
        SendDesc->StartBuffer + FramingInfo->HeaderLength;

    //
    // If we are in promiscuous mode we should indicate this
    // baby back up.
    //
    if (NdisWanCB.PromiscuousAdapter != NULL) {
        IndicatePromiscuousSendPacket(LinkCB, NdisPacket);
    }

    //
    // Copy MAC Header into buffer if needed and update
    // current pointer
    //
    if ((Flags & SAVE_MAC_ADDRESS) &&
        (PPPProtocolID == PPP_PROTOCOL_NBF)) {
        ULONG   BytesCopied;

        NdisWanCopyFromPacketToBuffer(NdisPacket,
                                      PacketOffset,
                                      12,
                                      CurrentData,
                                      &BytesCopied);

        ASSERT(BytesCopied == 12);

        CurrentData += BytesCopied;
        CurrentLength += BytesCopied;
    }

    //
    // We are beyond the mac header
    // (also skip the length/protocoltype field)
    //
    if (Flags & IO_PROTOCOLID) {
        PacketOffset = 12;
    } else {
        PacketOffset = 14;
    }

    if ((Flags & DO_VJ) &&
        PPPProtocolID == PPP_PROTOCOL_IP) {

        //
        // Do protocol header compression into buffer and
        // update current pointer.
        //
        PPPProtocolID =
            DoVJHeaderCompression(BundleCB,
                                  NdisPacket,
                                  &CurrentData,
                                  &CurrentLength,
                                  &PacketOffset);
    }

    //
    // Copy the rest of the data!
    //
    {
        ULONG   BytesCopied;
        NdisWanCopyFromPacketToBuffer(NdisPacket,
                                      PacketOffset,
                                      0xFFFFFFFF,
                                      CurrentData,
                                      &BytesCopied);

        SendDesc->DataLength =
            CurrentLength + BytesCopied;
    }

    AddPPPProtocolID(FramingInfo, PPPProtocolID);

    if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {

        DoCompressionEncryption(BundleCB,
                                FramingInfo,
                                &SendDesc);
    }

    //
    // At this point we have our framinginfo structure initialized,
    // SendDesc->StartData pointing to the begining of the frame,
    // FramingInfo.HeaderLength is the length of the header,
    // SendDesc->DataLength is the length of the data.
    //
    if (Flags & DO_MULTILINK) {

        //
        // Fragment the data and place fragments
        // on bundles frag queue.
        //
        FragmentAndQueue(BundleCB,
                         FramingInfo,
                         SendDesc,
                         LinkCBList,
                         SendingLinks);

        BytesSent = 0;

    } else {

        //
        // This send descriptor is not to be fragmented
        // so just send it!
        //
        SendDesc->HeaderLength = FramingInfo->HeaderLength;

        InterlockedExchange(&(PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->RefCount), 1);

        BytesSent =
            (*LinkCB->SendHandler)(SendDesc);

    }

    if ((BundleCB->Flags & BOND_ENABLED) &&
        (BytesSent != 0)) {

        //
        // Update the bandwidth on demand sample array with the latest send.
        // If we need to notify someone of a bandwidth event do it.
        //
        UpdateBandwidthOnDemand(BundleCB->SUpperBonDInfo, BytesSent);
        CheckUpperThreshold(BundleCB);
        UpdateBandwidthOnDemand(BundleCB->SLowerBonDInfo, BytesSent);
        CheckLowerThreshold(BundleCB);
    }

FramePacketExit:


    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendPacket: Exit - BytesSent %d", BytesSent));

    return (BytesSent);
}

UINT
SendOnLegacyLink(
    PSEND_DESC  SendDesc
    )
{
    UINT        SendLength;
    PLINKCB     LinkCB = SendDesc->LinkCB;
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    PPROTOCOLCB ProtocolCB  = SendDesc->ProtocolCB;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PNDIS_WAN_PACKET    WanPacket = SendDesc->WanPacket;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendOnLegacyLink: LinkCB: 0x%p, SendDesc: 0x%p, WanPacket: 0x%p", LinkCB, SendDesc, WanPacket));

    LinkCB->OutstandingFrames++;
    if (LinkCB->SendWindow == LinkCB->OutstandingFrames) {
        LinkCB->SendWindowOpen = FALSE;
        BundleCB->SendingLinks--;
    }

#if 0
    if (LinkCB->Stats.FramesTransmitted == 0) {
        PUCHAR  pd;

        if (*(WanPacket->CurrentBuffer) != 0xFF) {
            pd = WanPacket->CurrentBuffer;
        } else {
            pd = (WanPacket->CurrentBuffer + 2);
        }

        if (*(pd) != 0xC0 ||
            *(pd+1) != 0x21 ||
            *(pd+2) != 0x01) {
            DbgPrint("NDISWAN: SLL-FirstFrame not LCP ConfigReq bcb %p, lcb %p\n",
                     BundleCB, LinkCB);
            DbgBreakPoint();
        }
    }
#endif

    SendLength =
    WanPacket->CurrentLength =
        SendDesc->HeaderLength + SendDesc->DataLength;

    WanPacket->ProtocolReserved1 = (PVOID)SendDesc;

    //
    // DoStats
    //
    LinkCB->Stats.FramesTransmitted++;
    BundleCB->Stats.FramesTransmitted++;
    LinkCB->Stats.BytesTransmitted += SendLength;
    BundleCB->Stats.BytesTransmitted += SendLength;

    INSERT_DBG_SEND(PacketTypeWan,
                    LinkCB->OpenCB,
                    ProtocolCB,
                    LinkCB,
                    WanPacket);

    ReleaseBundleLock(BundleCB);

    //
    // If the link is up send the packet
    //
    NdisAcquireSpinLock(&LinkCB->Lock);


    if (LinkCB->State == LINK_UP) {

        KIRQL   OldIrql;

        NdisReleaseSpinLock(&LinkCB->Lock);

        if (gbSniffLink &&
            (NdisWanCB.PromiscuousAdapter != NULL)) {

            IndicatePromiscuousSendDesc(LinkCB, SendDesc, SEND_LINK);
        }

        //
        // There is a problem in ndis right now where
        // the miniport lock is not acquired before sending
        // to the wan miniport.  This opens a window when
        // the miniport does a sendcomplete from within
        // it's send handler since sendcomplete expects
        // to be running at dpc.
        //
        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

        WanMiniportSend(&Status,
                        LinkCB->OpenCB->BindingHandle,
                        LinkCB->NdisLinkHandle,
                        WanPacket);

        KeLowerIrql(OldIrql);

    } else {
        NdisReleaseSpinLock(&LinkCB->Lock);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendOnLegacyLink: Status: 0x%x", Status));

    //
    // If we get something other than pending back we need to
    // do the send complete.
    //
    if (Status != NDIS_STATUS_PENDING) {

        ProtoWanSendComplete(NULL,
                             WanPacket,
                             NDIS_STATUS_SUCCESS);
    }

    AcquireBundleLock(BundleCB);

    return (SendLength);
}

UINT
SendOnLink(
    PSEND_DESC  SendDesc
    )
{
    PLINKCB         LinkCB;
    PBUNDLECB       BundleCB;
    PPROTOCOLCB     ProtocolCB;
    PNDIS_PACKET    NdisPacket;
    PNDIS_BUFFER    NdisBuffer;
    UINT            SendLength;
    NDIS_STATUS     Status;


    LinkCB =
        SendDesc->LinkCB;

    ProtocolCB =
        SendDesc->ProtocolCB;

    NdisPacket =
        SendDesc->NdisPacket;

    NdisBuffer =
        SendDesc->NdisBuffer;

    BundleCB =
        LinkCB->BundleCB;


    NdisWanDbgOut(DBG_TRACE, DBG_SEND,
        ("SendOnLink: LinkCB: 0x%p, NdisPacket: 0x%p",
        LinkCB, NdisPacket));

    LinkCB->OutstandingFrames++;
    if (LinkCB->SendWindow == LinkCB->OutstandingFrames) {
        LinkCB->SendWindowOpen = FALSE;
        BundleCB->SendingLinks--;
    }

    PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->SendDesc = SendDesc;

    INSERT_DBG_SEND(PacketTypeNdis,
                    LinkCB->OpenCB,
                    ProtocolCB,
                    LinkCB,
                    NdisPacket);

    SendLength =
        SendDesc->HeaderLength + SendDesc->DataLength;


    //
    // Fixup the bufferlength and chain at front
    //
    NdisAdjustBufferLength(NdisBuffer, SendLength);
    NdisRecalculatePacketCounts(NdisPacket);

    //
    // Do Stats
    //
    LinkCB->Stats.FramesTransmitted++;
    BundleCB->Stats.FramesTransmitted++;
    LinkCB->Stats.BytesTransmitted += SendLength;
    BundleCB->Stats.BytesTransmitted += SendLength;

    ReleaseBundleLock(BundleCB);

    //
    // If the link is up send the packet
    //
    NdisAcquireSpinLock(&LinkCB->Lock);

    LinkCB->VcRefCount++;

    if (LinkCB->State == LINK_UP) {

        NdisReleaseSpinLock(&LinkCB->Lock);

        if (gbSniffLink &&
            (NdisWanCB.PromiscuousAdapter != NULL)) {

            IndicatePromiscuousSendDesc(LinkCB, SendDesc, SEND_LINK);
        }

        NdisCoSendPackets(LinkCB->NdisLinkHandle,
                          &NdisPacket,
                          1);

    } else {

        NdisReleaseSpinLock(&LinkCB->Lock);

        ProtoCoSendComplete(NDIS_STATUS_SUCCESS,
                            LinkCB->hLinkHandle,
                            NdisPacket);
    }

    AcquireBundleLock(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendOnLink: Exit"));

    return (SendLength);
}

USHORT
DoVJHeaderCompression(
    PBUNDLECB   BundleCB,
    PNDIS_PACKET    NdisPacket,
    PUCHAR      *CurrentBuffer,
    PULONG      CurrentLength,
    PULONG      PacketOffset
    )
{
    UCHAR   CompType = TYPE_IP;
    PUCHAR  Header = *CurrentBuffer;
    ULONG   CopyLength;
    ULONG   HeaderLength;
    ULONG   PreCompHeaderLen = 0, PostCompHeaderLen = 0;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    ASSERT(BundleCB->FramingInfo.SendFramingBits &
        (SLIP_VJ_COMPRESSION | PPP_FRAMING));

    NdisQueryPacket(NdisPacket,
        NULL,
        NULL,
        NULL,
        &CopyLength);

    CopyLength -= *PacketOffset;

    if (CopyLength > PROTOCOL_HEADER_LENGTH) {
        CopyLength = PROTOCOL_HEADER_LENGTH;
    }

    NdisWanCopyFromPacketToBuffer(NdisPacket,
        *PacketOffset,
        CopyLength,
        Header,
        &HeaderLength);

    ASSERT(CopyLength == HeaderLength);

    *PacketOffset += HeaderLength;

    //
    // Are we compressing TCP/IP headers?  There is a nasty
    // hack in VJs implementation for attempting to detect
    // interactive TCP/IP sessions.  That is, telnet, login,
    // klogin, eklogin, and ftp sessions.  If detected,
    // the traffic gets put on a higher TypeOfService (TOS).  We do
    // no such hack for RAS.  Also, connection ID compression
    // is negotiated, but we always don't compress it.
    //
    CompType =
        sl_compress_tcp(&Header,
        &HeaderLength,
        &PreCompHeaderLen,
        &PostCompHeaderLen,
        BundleCB->VJCompress,
        0);

    if (BundleCB->FramingInfo.SendFramingBits & SLIP_FRAMING) {
        Header[0] |= CompType;
    }

#if DBG
    if (CompType == TYPE_COMPRESSED_TCP) {
        NdisWanDbgOut(DBG_TRACE, DBG_SEND_VJ,("svj b %d a %d",PreCompHeaderLen, PostCompHeaderLen));
    }
#endif

    BundleCB->Stats.BytesTransmittedUncompressed +=
        PreCompHeaderLen;

    BundleCB->Stats.BytesTransmittedCompressed +=
        PostCompHeaderLen;

    if (CompType == TYPE_COMPRESSED_TCP) {
        PNDIS_BUFFER    MyBuffer;

        //
        // Source/Dest overlap so must use RtlMoveMemory
        //
        RtlMoveMemory(*CurrentBuffer, Header, HeaderLength);

        *CurrentBuffer += HeaderLength;
        *CurrentLength += HeaderLength;

        return (PPP_PROTOCOL_COMPRESSED_TCP);
    }

    *CurrentBuffer += HeaderLength;
    *CurrentLength += HeaderLength;

    switch (CompType) {
        case TYPE_IP:
            return (PPP_PROTOCOL_IP);
        case TYPE_UNCOMPRESSED_TCP:
            return (PPP_PROTOCOL_UNCOMPRESSED_TCP);
        default:
            DbgBreakPoint();
    }

    return (PPP_PROTOCOL_IP);
}

VOID
DoCompressionEncryption(
    PBUNDLECB               BundleCB,
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              *SendDesc
    )
{
    ULONG   Flags = FramingInfo->Flags;
    PSEND_DESC  SendDesc1 = *SendDesc;
    PLINKCB LinkCB = SendDesc1->LinkCB;
    PUCHAR  DataBuffer, DataBuffer1;
    ULONG   DataLength;
    union {
        USHORT  uShort;
        UCHAR   uChar[2];
    }CoherencyCounter;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("DoCompressionEncryption: Enter"));

    //
    // If we are compressing/encrypting, the ProtocolID
    // is part of the compressed data so fix the pointer
    // and the length;
    //
    FramingInfo->HeaderLength -=
        FramingInfo->ProtocolID.Length;

    SendDesc1->DataLength += FramingInfo->ProtocolID.Length;

    DataBuffer = DataBuffer1 =
        SendDesc1->StartBuffer + FramingInfo->HeaderLength;

    DataLength =
        SendDesc1->DataLength;

    //
    // Get the coherency counter
    //
    CoherencyCounter.uShort = BundleCB->SCoherencyCounter;
    CoherencyCounter.uChar[1] &= 0x0F;

    //
    // Bump the coherency count
    //
    BundleCB->SCoherencyCounter++;

    if (Flags & DO_COMPRESSION) {
        PSEND_DESC  SendDesc2;
        PUCHAR  DataBuffer2;

        //
        // We need to get the max size here to protect
        // against expansion of the data
        //
        SendDesc2 =
            NdisWanAllocateSendDesc(LinkCB, glLargeDataBufferSize);

        if (SendDesc2 == NULL) {
            //
            // Just don't compress!
            //
            BundleCB->SCoherencyCounter--;
            return;
        }

        DataBuffer2 =
            SendDesc2->StartBuffer + FramingInfo->HeaderLength;

        BundleCB->Stats.BytesTransmittedUncompressed += DataLength;

        if (Flags & DO_FLUSH ||
            Flags & DO_HISTORY_LESS) {
            //
            // Init the compression history table and tree
            //
            initsendcontext(BundleCB->SendCompressContext);
        }

        //
        // We are doing the copy to get things into a contiguous buffer before
        // compression occurs
        //
        CoherencyCounter.uChar[1] |=
            compress(DataBuffer1,
                     DataBuffer2,
                     &DataLength,
                     BundleCB->SendCompressContext);

        if (CoherencyCounter.uChar[1] & PACKET_FLUSHED) {

            NdisWanFreeSendDesc(SendDesc2);

            //
            // If encryption is enabled this will force a
            // reinit of the table
            //
            Flags |= DO_FLUSH;

        } else {
            //
            // We compressed the packet so now the data is in
            // the CopyBuffer. We need to copy the PPP header
            // from DataBuffer to CopyBuffer.  The header
            // includes everything except for the protocolid field.
            //
            NdisMoveMemory(SendDesc2->StartBuffer,
                           SendDesc1->StartBuffer,
                           FramingInfo->HeaderLength);

            FramingInfo->ProtocolID.Length = 0;

            UpdateFramingInfo(FramingInfo, SendDesc2->StartBuffer);

            SendDesc2->DataLength = DataLength;
            SendDesc2->ProtocolCB = SendDesc1->ProtocolCB;
            SendDesc2->OriginalPacket = SendDesc1->OriginalPacket;
            SendDesc2->Class = SendDesc1->Class;
            NdisWanFreeSendDesc(SendDesc1);

            *SendDesc = SendDesc2;
            DataBuffer = DataBuffer2;
        }

        BundleCB->Stats.BytesTransmittedCompressed += DataLength;
    }

    //
    // If encryption is enabled encrypt the data in the
    // buffer.  Encryption is done inplace so additional
    // buffers are not needed.
    //
    // Do data encryption
    //
    if (Flags & DO_ENCRYPTION) {
        PUCHAR  SessionKey = BundleCB->SendCryptoInfo.SessionKey;
        ULONG   SessionKeyLength = BundleCB->SendCryptoInfo.SessionKeyLength;
        PVOID   SendRC4Key = BundleCB->SendCryptoInfo.RC4Key;

        //
        // We may need to reinit the rc4 table
        //
        if ((Flags & DO_FLUSH) &&
            !(Flags & DO_HISTORY_LESS)) {
            rc4_key(SendRC4Key, SessionKeyLength, SessionKey);
        }

        //
        // Mark this as being encrypted
        //
        CoherencyCounter.uChar[1] |= PACKET_ENCRYPTED;

        //
        // If we are in history-less mode we will
        // change the RC4 session key for every
        // packet, otherwise every 256 frames
        // change the RC4 session key
        //
        if ((Flags & DO_HISTORY_LESS) ||
            (BundleCB->SCoherencyCounter & 0xFF) == 0) {

            if (Flags & DO_LEGACY_ENCRYPTION) {
                //
                // Simple munge for legacy encryption
                //
                SessionKey[3] += 1;
                SessionKey[4] += 3;
                SessionKey[5] += 13;
                SessionKey[6] += 57;
                SessionKey[7] += 19;

            } else {

                //
                // Use SHA to get new sessionkey
                //
                GetNewKeyFromSHA(&BundleCB->SendCryptoInfo);

            }

            //
            // We use rc4 to scramble and recover a new key
            //

            //
            // Re-initialize the rc4 receive table to the
            // intermediate value
            //
            rc4_key(SendRC4Key, SessionKeyLength, SessionKey);

            //
            // Scramble the existing session key
            //
            rc4(SendRC4Key, SessionKeyLength, SessionKey);

            if (Flags & DO_40_ENCRYPTION) {

                //
                // If this is 40 bit encryption we need to fix
                // the first 3 bytes of the key.
                //
                SessionKey[0] = 0xD1;
                SessionKey[1] = 0x26;
                SessionKey[2] = 0x9E;

            } else if (Flags & DO_56_ENCRYPTION) {

                //
                // If this is 56 bit encryption we need to fix
                // the first byte of the key.
                //
                SessionKey[0] = 0xD1;
            }

            NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                ("RC4 Send encryption KeyLength %d", BundleCB->SendCryptoInfo.SessionKeyLength));
            NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                ("RC4 Send encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
                BundleCB->SendCryptoInfo.SessionKey[0],
                BundleCB->SendCryptoInfo.SessionKey[1],
                BundleCB->SendCryptoInfo.SessionKey[2],
                BundleCB->SendCryptoInfo.SessionKey[3],
                BundleCB->SendCryptoInfo.SessionKey[4],
                BundleCB->SendCryptoInfo.SessionKey[5],
                BundleCB->SendCryptoInfo.SessionKey[6],
                BundleCB->SendCryptoInfo.SessionKey[7],
                BundleCB->SendCryptoInfo.SessionKey[8],
                BundleCB->SendCryptoInfo.SessionKey[9],
                BundleCB->SendCryptoInfo.SessionKey[10],
                BundleCB->SendCryptoInfo.SessionKey[11],
                BundleCB->SendCryptoInfo.SessionKey[12],
                BundleCB->SendCryptoInfo.SessionKey[13],
                BundleCB->SendCryptoInfo.SessionKey[14],
                BundleCB->SendCryptoInfo.SessionKey[15]));

            //
            // Re-initialize the rc4 receive table to the
            // scrambled session key
            //
            rc4_key(SendRC4Key, SessionKeyLength, SessionKey);
        }

        //
        // Encrypt the data
        //
        rc4(SendRC4Key, DataLength, DataBuffer);
    }


    //
    // Did the last receive cause us to flush?
    //
    if (Flags & (DO_FLUSH | DO_HISTORY_LESS)) {
        CoherencyCounter.uChar[1] |= PACKET_FLUSHED;
    }

    //
    // Add the coherency bytes to the frame
    //
    AddCompressionInfo(FramingInfo, CoherencyCounter.uShort);

    ASSERT(((CoherencyCounter.uShort + 1) & 0x0FFF) ==
        (BundleCB->SCoherencyCounter & 0x0FFF));

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("DoCompressionEncryption: Exit"));
}

VOID
FragmentAndQueue(
    PBUNDLECB               BundleCB,
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              SendDesc,
    PLIST_ENTRY             LinkCBList,
    ULONG                   SendingLinks
    )
{
    ULONG       DataLeft;
    ULONG       FragmentsSent;
    ULONG       FragmentsLeft;
    ULONG       Flags;
    PLINKCB     LinkCB;
    PUCHAR      DataBuffer;
    ULONG       DataLength;
    PPROTOCOLCB ProtocolCB;
    PNDIS_PACKET    NdisPacket;
    PSEND_FRAG_INFO FragInfo;
    INT         Class;
#if DBG
    ULONG   MaxFragments;
#endif

    Class = SendDesc->Class;

    ASSERT(Class >= 0 && Class < MAX_MCML);

    FragInfo =
        &BundleCB->SendFragInfo[Class];

    DataBuffer =
        SendDesc->StartBuffer + FramingInfo->HeaderLength;

    DataLeft =
    DataLength = SendDesc->DataLength;

    FragmentsSent = 0;
    Flags = FramingInfo->Flags;
    LinkCB = SendDesc->LinkCB;
    ProtocolCB = SendDesc->ProtocolCB;
    NdisPacket = SendDesc->OriginalPacket;

    if (BundleCB->Flags & QOS_ENABLED) {

        FragmentsLeft = 
            (DataLength/FragInfo->MaxFragSize == 0) ?
            1 : DataLength/FragInfo->MaxFragSize;

        if (DataLength > FragInfo->MaxFragSize * FragmentsLeft) {
            FragmentsLeft += 1;
        }

        if (FragmentsLeft > BundleCB->SendResources) {
            FragmentsLeft = BundleCB->SendResources;
        }

    } else {

        FragmentsLeft = SendingLinks;
    }

#if DBG
    MaxFragments = FragmentsLeft;
#endif

    //
    // For all fragments we loop fixing up the multilink header
    // if multilink is on, fixing up pointers in the wanpacket,
    // and queuing the wanpackets for further processing.
    //
    while (DataLeft) {
        ULONG   FragDataLength;

        if (!(Flags & FIRST_FRAGMENT)) {
            PLIST_ENTRY  Entry;

            //
            // We had more than one fragment, get the next
            // link to send over and a wanpacket from the
            // link.
            //
            //
            // Get a linkcb to send over
            //
            if (IsListEmpty(LinkCBList)) {
                ULONG   Count;

                Count = 
                    GetSendingLinks(BundleCB, Class, LinkCBList);

                if (Count == 0) {
                    //
                    //
                    //
                    DbgPrint("NDISWAN: FragmentAndQueue LinkCBCount %d\n", Count);
                    continue;
                }
            }

            Entry = RemoveHeadList(LinkCBList);

            LinkCB =
                CONTAINING_RECORD(Entry, LINKCB, SendLinkage);

            SendDesc =
                NdisWanAllocateSendDesc(LinkCB, DataLeft + 6);

            if (SendDesc == NULL) {
                //
                // 
                //
                InsertTailList(LinkCBList, &LinkCB->SendLinkage);

                DbgPrint("NDISWAN: FragmentAndQueue SendDesc == NULL! LinkCB: 0x%p\n", LinkCB);
                continue;
            }

            SendDesc->ProtocolCB = ProtocolCB;
            SendDesc->OriginalPacket = NdisPacket;
            SendDesc->Class = Class;

            //
            // Get new framing information and build a new
            // header for the new link.
            //
            FramingInfo->FramingBits = 
                LinkCB->LinkInfo.SendFramingBits;
            FramingInfo->Flags = Flags;

            BuildLinkHeader(FramingInfo, SendDesc);
        }

        if (FragmentsLeft > 1) {

            //
            // Calculate the length of this fragment
            //
            FragDataLength = (DataLength * LinkCB->SBandwidth / 100);

            if (BundleCB->Flags & QOS_ENABLED) {

                FragDataLength = (FragDataLength > FragInfo->MaxFragSize) ?
                    FragInfo->MaxFragSize : FragDataLength;

            } else {

                FragDataLength = (FragDataLength < FragInfo->MinFragSize) ?
                    FragInfo->MinFragSize : FragDataLength;
            }

            if ((FragDataLength > DataLeft) ||
                ((LONG)DataLeft - FragDataLength < FragInfo->MinFragSize)) {
                //
                // This will leave a fragment of less than min frag size
                // so send all of the data
                //
                FragDataLength = DataLeft;
                FragmentsLeft = 1;
            }

        } else {
            //
            // We either have one fragment left or this link has
            // more than 85 percent of the bundle so send what
            // data is left
            //
            FragDataLength = DataLeft;
            FragmentsLeft = 1;
        }

        if (!(Flags & FIRST_FRAGMENT)) {
            //
            // Copy the data to the new buffer from the old buffer.
            //
            NdisMoveMemory(SendDesc->StartBuffer + FramingInfo->HeaderLength,
                           DataBuffer,
                           FragDataLength);
        }

        //
        // Update the data pointer and the length left to send
        //
        DataBuffer += FragDataLength;
        DataLeft -= FragDataLength;

        {
            UCHAR   MultilinkFlags = 0;

            //
            // Multlink is on so create flags for this
            // fragment.
            //
            if (Flags & FIRST_FRAGMENT) {
                MultilinkFlags = MULTILINK_BEGIN_FRAME;
                Flags &= ~FIRST_FRAGMENT;
            }

            if (FragmentsLeft == 1) {
                MultilinkFlags |= MULTILINK_END_FRAME;
            }

            //
            // Add the multilink header information and
            // take care of the sequence number.
            //
            AddMultilinkInfo(FramingInfo,
                             MultilinkFlags,
                             FragInfo->SeqNumber,
                             BundleCB->SendSeqMask);

            NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_SEND, ("sf %x %x %d",
                FragInfo->SeqNumber, MultilinkFlags, FragDataLength));

            FragInfo->SeqNumber++;
        }

        //
        // Setup the SEND_DESC
        //
        SendDesc->HeaderLength = FramingInfo->HeaderLength;
        SendDesc->DataLength = FragDataLength;
        SendDesc->Flags |= SEND_DESC_FRAG;

        //
        // Queue for further processing.
        //
        InsertTailList(&FragInfo->FragQueue, &SendDesc->Linkage);

        FragInfo->FragQueueDepth++;

        FragmentsSent++;
        FragmentsLeft--;

    }   // end of the fragment loop

    ASSERT(FragmentsLeft == 0);

    InterlockedExchangeAdd(&ProtocolCB->PacketQueue[Class].OutstandingFrags, (LONG)FragmentsSent);

#ifdef DBG_SENDARRAY
{
    SendArray[__si] = '0' + (UCHAR)FragmentsSent;
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    //
    // Get the mac reserved structure from the ndispacket.  This
    // is where we will keep the reference count on the packet.
    //
    ASSERT(((LONG)FragmentsSent > 0) && (FragmentsSent <= MaxFragments));

    InterlockedExchange(&(PMINIPORT_RESERVED_FROM_NDIS(SendDesc->OriginalPacket)->RefCount), FragmentsSent);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("NdisPacket: 0x%p RefCount %d", SendDesc->OriginalPacket, FragmentsSent));
}

ULONG
GetSendingLinks(
    PBUNDLECB   BundleCB,
    INT         Class,
    PLIST_ENTRY lcbList
    )
{
    ULONG   SendingLinks;
    PLINKCB LinkCB, StartLinkCB, LastLinkCB;

    StartLinkCB = LinkCB = LastLinkCB =
        BundleCB->NextLinkToXmit;

    SendingLinks = 0;

    //
    // If this is a fragmented send...
    // If QOS is enabled we just need some send resources
    // If QOS is not enabled we need sending links
    // If this is a non-fragmented send...
    // We need sending links
    //

    if (LinkCB != NULL) {

        if (Class == MAX_MCML) {

            do {

                NdisDprAcquireSpinLock(&LinkCB->Lock);

                if ((LinkCB->State == LINK_UP) &&
                    LinkCB->LinkActive && 
                    LinkCB->SendWindowOpen) {

                    InsertTailList(lcbList, &LinkCB->SendLinkage);

                    REF_LINKCB(LinkCB);

                    SendingLinks += 1;
                    LastLinkCB = LinkCB;
                }

                NdisDprReleaseSpinLock(&LinkCB->Lock);

                LinkCB = (PLINKCB)LinkCB->Linkage.Flink;

                if ((PVOID)LinkCB == (PVOID)&BundleCB->LinkCBList) {
                    LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
                }

            } while (LinkCB != StartLinkCB);

        } else {
            if (BundleCB->Flags& QOS_ENABLED) {

                do {

                    NdisDprAcquireSpinLock(&LinkCB->Lock);

                    if ((LinkCB->State == LINK_UP) &&
                        LinkCB->LinkActive && 
                        (LinkCB->SendResources != 0)) {
                        InsertTailList(lcbList, &LinkCB->SendLinkage);

                        REF_LINKCB(LinkCB);

                        SendingLinks += 1;
                        LastLinkCB = LinkCB;
                    }

                    NdisDprReleaseSpinLock(&LinkCB->Lock);

                    LinkCB = (PLINKCB)LinkCB->Linkage.Flink;

                    if ((PVOID)LinkCB == (PVOID)&BundleCB->LinkCBList) {
                        LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
                    }

                } while (LinkCB != StartLinkCB);

            } else {

                do {

                    NdisDprAcquireSpinLock(&LinkCB->Lock);

                    if ((LinkCB->State == LINK_UP) &&
                        LinkCB->LinkActive && 
                        LinkCB->SendWindowOpen) {
                        InsertTailList(lcbList, &LinkCB->SendLinkage);

                        REF_LINKCB(LinkCB);

                        SendingLinks += 1;
                        LastLinkCB = LinkCB;
                    }

                    NdisDprReleaseSpinLock(&LinkCB->Lock);

                    LinkCB = (PLINKCB)LinkCB->Linkage.Flink;

                    if ((PVOID)LinkCB == (PVOID)&BundleCB->LinkCBList) {
                        LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
                    }

                } while (LinkCB != StartLinkCB);
            }
        }

        BundleCB->NextLinkToXmit =
            (LastLinkCB->Linkage.Flink == &BundleCB->LinkCBList) ?
            (PLINKCB)BundleCB->LinkCBList.Flink : 
            (PLINKCB)LastLinkCB->Linkage.Flink;
    }

#ifdef DBG_SENDARRAY
{
    if (SendingLinks == 0) {
        SendArray[__si] = 'g';
    } else {
        SendArray[__si] = 'G';
    }
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    return (SendingLinks);
}

VOID
GetNextProtocol(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB *ProtocolCB,
    PULONG      SendMask
    )
{
    PLIST_ENTRY     ppcblist;
    PPROTOCOLCB     ppcb;
    ULONG           mask;
    ULONG           i;
    BOOLEAN         Found;

    *ProtocolCB = NULL;
    mask = *SendMask;
    *SendMask = 0;

    ppcb = BundleCB->NextProtocol;

    if (ppcb == NULL) {
        return;
    }

    //
    // There is a window where we could have set the initial
    // send mask and had a protocol removed without clearing
    // it's send bit.  If we 'and' the temp mask with the 
    // bundle's mask we should clear out any bits that are
    // left dangling.
    //
    mask &= BundleCB->SendMask;

    //
    // Starting with the next flagged protocol
    // see if it can send.  If not clear its
    // sendbit from the mask and go to the next.
    // If none can send mask will be 0 and
    // protocol will be NULL.  We know that there
    // are only ulnumberofroutes in table so only
    // look for that many.
    //

    i = BundleCB->ulNumberOfRoutes;
    Found = FALSE;

    do {

        if (ppcb->State == PROTOCOL_ROUTED) {
            *ProtocolCB = ppcb;
            Found = TRUE;
        } else {
            mask &= ~ppcb->SendMaskBit;
        }

        ppcb = (PPROTOCOLCB)ppcb->Linkage.Flink;

        if ((PVOID)ppcb == (PVOID)&BundleCB->ProtocolCBList) {

            ppcb = (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;
        }

        if (Found) {
            BundleCB->NextProtocol = ppcb;
            break;
        }

    } while ( --i );

    if (*ProtocolCB != NULL) {
        *SendMask = mask;
    }
}

NDIS_STATUS
BuildIoPacket(
    IN  PLINKCB             LinkCB,
    IN  PBUNDLECB           BundleCB,
    IN  PNDISWAN_IO_PACKET  pWanIoPacket,
    IN  BOOLEAN             SendImmediate
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_RESOURCES;
    ULONG   Stage = 0;
    ULONG   DataLength;
    PUCHAR  DataBuffer, pSrcAddr, pDestAddr;
    PNDIS_PACKET    NdisPacket;
    PNDIS_BUFFER    NdisBuffer;
    PPROTOCOLCB     IoProtocolCB;
    PSEND_DESC      SendDesc;
    UCHAR   SendHeader[] = {' ', 'S', 'E', 'N', 'D', 0xFF};

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("BuildIoPacket: Enter!"));
    //
    // Some time in the future this should be redone so that
    // there is a pool of packets and buffers attached to a
    // BundleCB.  This pool could be grown and shrunk as needed
    // but some minimum number would live for the lifetime of
    // the BundleCB.

    //
    // Allocate needed resources
    //
    {
        ULONG   SizeNeeded;

        //
        // Need max of 18 bytes; 4 bytes for ppp/llc header and
        // 14 for MAC address
        //
        SizeNeeded = 18;

        //
        // The header will either be given to us or
        // it will be added by us (ethernet mac header)
        //
        SizeNeeded += (pWanIoPacket->usHeaderSize > 0) ?
            pWanIoPacket->usHeaderSize : MAC_HEADER_LENGTH;

        //
        // Amount of data we need to send
        //
        SizeNeeded += pWanIoPacket->usPacketSize;

        Status = 
            AllocateIoNdisPacket(SizeNeeded,
                                 &NdisPacket,
                                 &NdisBuffer, 
                                 &DataBuffer);

        if (Status != NDIS_STATUS_SUCCESS) {

            NdisWanDbgOut(DBG_FAILURE, DBG_SEND, 
                          ("BuildIoPacket: Error Allocating IoNdisPacket!"));

            DEREF_LINKCB(LinkCB);

            return (NDIS_STATUS_RESOURCES);
        }
    }

    PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->LinkCB = LinkCB;

    //
    // We only support ethernet headers right now so the supplied header
    // either has to be ethernet or none at all!
    //
    pDestAddr = &DataBuffer[0];
    pSrcAddr = &DataBuffer[6];

    //
    // If no header build a header
    //
    if (pWanIoPacket->usHeaderSize == 0) {

        //
        // Header will look like " S XXYYYY" where
        // XX is the ProtocolCB index and YYYY is the
        // BundleCB index.  Both the Src and Dst addresses
        // look the same.
        //
        NdisMoveMemory(pDestAddr,
                       SendHeader,
                       sizeof(SendHeader));

        NdisMoveMemory(pSrcAddr,
                       SendHeader,
                       sizeof(SendHeader));

        //
        // Fill the BundleCB Index for the Src and Dest Address
        //
        pDestAddr[5] = pSrcAddr[5] = 
            (UCHAR)LinkCB->hLinkHandle;

        DataLength = 12;

    } else {
        //
        // Header supplied so go ahead and move it.
        //
        NdisMoveMemory(pDestAddr,
                       pWanIoPacket->PacketData,
                       pWanIoPacket->usHeaderSize);

        DataLength = pWanIoPacket->usHeaderSize;
    }

    //
    // Copy the data to the buffer
    //
    NdisMoveMemory(&DataBuffer[12],
                   &pWanIoPacket->PacketData[pWanIoPacket->usHeaderSize],
                   pWanIoPacket->usPacketSize);

    DataLength += pWanIoPacket->usPacketSize;

    //
    // Adjust buffer length and chain buffer to ndis packet
    //
    NdisAdjustBufferLength(NdisBuffer, DataLength);
    NdisRecalculatePacketCounts(NdisPacket);

    //
    // Queue the packet on the bundlecb
    //
    IoProtocolCB = BundleCB->IoProtocolCB;

    ASSERT(IoProtocolCB != NULL);

    if (SendImmediate) {
        InsertHeadPacketQueue(&IoProtocolCB->PacketQueue[MAX_MCML],
                              NdisPacket, DataLength);
    } else {
        InsertTailPacketQueue(&IoProtocolCB->PacketQueue[MAX_MCML],
                              NdisPacket, DataLength);
    }

    InterlockedIncrement(&IoProtocolCB->OutstandingFrames);

    //
    // Try to send
    //
    // Called with lock held and returns with
    // lock released
    //
    SendPacketOnBundle(BundleCB);

    AcquireBundleLock(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("BuildIoPacket: Exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

VOID
BuildLinkHeader(
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              SendDesc
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   LinkFraming = FramingInfo->FramingBits;
    ULONG   Flags = FramingInfo->Flags;
    PUCHAR  CurrentPointer = SendDesc->StartBuffer;

    FramingInfo->HeaderLength =
        FramingInfo->AddressControl.Length =
        FramingInfo->Multilink.Length =
        FramingInfo->Compression.Length =
        FramingInfo->ProtocolID.Length = 0;

    if (LinkFraming & PPP_FRAMING) {

        if (!(LinkFraming & PPP_COMPRESS_ADDRESS_CONTROL)) {
            //
            // If there is no address/control compression
            // we need a pointer and a length
            //

            if (LinkFraming & LLC_ENCAPSULATION) {
                FramingInfo->AddressControl.Pointer = CurrentPointer;
                *CurrentPointer++ = 0xFE;
                *CurrentPointer++ = 0xFE;
                *CurrentPointer++ = 0x03;
                *CurrentPointer++ = 0xCF;
                FramingInfo->AddressControl.Length = 4;
                FramingInfo->HeaderLength += FramingInfo->AddressControl.Length;

            } else {
                FramingInfo->AddressControl.Pointer = CurrentPointer;
                *CurrentPointer++ = 0xFF;
                *CurrentPointer++ = 0x03;
                FramingInfo->AddressControl.Length = 2;
                FramingInfo->HeaderLength += FramingInfo->AddressControl.Length;
            }
        }

        if (!(Flags & IO_PROTOCOLID)) {

            //
            // If this is not from our private I/O interface we will
            // build the rest of the header.
            //
            if ((Flags & DO_MULTILINK) && (LinkFraming & PPP_MULTILINK_FRAMING)) {

                //
                // We are doing multilink so we need a pointer
                // and a length
                //
                FramingInfo->Multilink.Pointer = CurrentPointer;

                if (!(LinkFraming & PPP_COMPRESS_PROTOCOL_FIELD)) {
                    //
                    // No protocol compression
                    //
                    *CurrentPointer++ = 0x00;
                    FramingInfo->Multilink.Length++;
                }

                *CurrentPointer++ = 0x3D;
                FramingInfo->Multilink.Length++;

                if (!(LinkFraming & PPP_SHORT_SEQUENCE_HDR_FORMAT)) {
                    //
                    // We are using long sequence number
                    //
                    FramingInfo->Multilink.Length += 2;
                    CurrentPointer += 2;

                }

                FramingInfo->Multilink.Length += 2;
                CurrentPointer += 2;

                FramingInfo->HeaderLength += FramingInfo->Multilink.Length;

            }

            if (Flags & FIRST_FRAGMENT) {

                if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {
                    //
                    // We are doing compression/encryption so we need
                    // a pointer and a length
                    //
                    FramingInfo->Compression.Pointer = CurrentPointer;

                    //
                    // It appears that legacy ras (< NT 4.0) requires that
                    // the PPP protocol field in a compressed packet not
                    // be compressed, ie has to have the leading 0x00
                    //
                    if (!(LinkFraming & PPP_COMPRESS_PROTOCOL_FIELD)) {
                        //
                        // No protocol compression
                        //
                        *CurrentPointer++ = 0x00;
                        FramingInfo->Compression.Length++;
                    }

                    *CurrentPointer++ = 0xFD;
                    FramingInfo->Compression.Length++;

                    //
                    // Add coherency bytes
                    //
                    FramingInfo->Compression.Length += 2;
                    CurrentPointer += 2;

                    FramingInfo->HeaderLength += FramingInfo->Compression.Length;
                }


                FramingInfo->ProtocolID.Pointer = CurrentPointer;

                if (!(LinkFraming & PPP_COMPRESS_PROTOCOL_FIELD) ||
                    (Flags & (DO_COMPRESSION | DO_ENCRYPTION))) {
                    FramingInfo->ProtocolID.Length++;
                    CurrentPointer++;
                }

                FramingInfo->ProtocolID.Length++;
                FramingInfo->HeaderLength += FramingInfo->ProtocolID.Length;
                CurrentPointer++;
            }
        }


    } else if ((LinkFraming & RAS_FRAMING)) {
        //
        // If this is old ras framing:
        //
        // Alter the framing so that 0xFF 0x03 is not added
        // and that the first byte is 0xFD not 0x00 0xFD
        //
        // So basically, a RAS compression looks like
        // <0xFD> <2 BYTE COHERENCY> <NBF DATA FIELD>
        //
        // Whereas uncompressed looks like
        // <NBF DATA FIELD> which always starts with 0xF0
        //
        // If this is ppp framing:
        //
        // A compressed frame will look like (before address/control
        // - multilink is added)
        // <0x00> <0xFD> <2 Byte Coherency> <Compressed Data>
        //
        if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {
            FramingInfo->Compression.Pointer = CurrentPointer;

            *CurrentPointer++ = 0xFD;
            FramingInfo->Compression.Length++;

            //
            // Coherency bytes
            //
            FramingInfo->Compression.Length += 2;
            CurrentPointer += 2;

            FramingInfo->HeaderLength += FramingInfo->Compression.Length;
        }
    }
}

VOID
IndicatePromiscuousSendPacket(
    PLINKCB         LinkCB,
    PNDIS_PACKET    NdisPacket
    )
{
    PNDIS_BUFFER    NdisBuffer;
    PNDIS_PACKET    LocalNdisPacket;
    NDIS_STATUS     Status;
    PRECV_DESC      RecvDesc;
    PBUNDLECB       BundleCB = LinkCB->BundleCB;
    KIRQL           OldIrql;
    PMINIPORTCB     Adapter;
    ULONG           PacketLength;

    NdisAcquireSpinLock(&NdisWanCB.Lock);
    Adapter = NdisWanCB.PromiscuousAdapter;
    NdisReleaseSpinLock(&NdisWanCB.Lock);

    if (Adapter == NULL) {
        return;
    }

    NdisQueryPacket(NdisPacket, 
                    NULL, 
                    NULL, 
                    NULL, 
                    &PacketLength);

    RecvDesc =
        NdisWanAllocateRecvDesc(PacketLength);

    if (RecvDesc == NULL) {
        return;
    }

    //
    // Get an ndis packet
    //
    LocalNdisPacket =
        RecvDesc->NdisPacket;

    NdisWanCopyFromPacketToBuffer(NdisPacket,
        0,
        0xFFFFFFFF,
        RecvDesc->StartBuffer,
        &RecvDesc->CurrentLength);

    PPROTOCOL_RESERVED_FROM_NDIS(LocalNdisPacket)->RecvDesc = RecvDesc;

    //
    // Attach the buffers
    //
    NdisAdjustBufferLength(RecvDesc->NdisBuffer,
                           RecvDesc->CurrentLength);

    NdisRecalculatePacketCounts(LocalNdisPacket);

    ReleaseBundleLock(BundleCB);

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    NDIS_SET_PACKET_STATUS(LocalNdisPacket, NDIS_STATUS_RESOURCES);

    INSERT_DBG_RECV(PacketTypeNdis, 
                    Adapter, 
                    NULL, 
                    LinkCB, 
                    LocalNdisPacket);

    //
    // Indicate the packet
    // This assumes that bloodhound is always a legacy transport
    //
    NdisMIndicateReceivePacket(Adapter->MiniportHandle,
                               &LocalNdisPacket,
                               1);

    KeLowerIrql(OldIrql);

    Status = NDIS_GET_PACKET_STATUS(LocalNdisPacket);

    ASSERT(Status == NDIS_STATUS_RESOURCES);

    REMOVE_DBG_RECV(PacketTypeNdis, Adapter, LocalNdisPacket);

    {
        PNDIS_BUFFER    NdisBuffer;

        NdisWanFreeRecvDesc(RecvDesc);
    }

    AcquireBundleLock(BundleCB);
}

VOID
IndicatePromiscuousSendDesc(
    PLINKCB     LinkCB,
    PSEND_DESC  SendDesc,
    SEND_TYPE   SendType
    )
{
    UCHAR   Header1[] = {' ', 'W', 'A', 'N', 'S', 0xFF, ' ', 'W', 'A', 'N', 'S', 0xFF};
    PUCHAR  HeaderBuffer, DataBuffer;
    ULONG   HeaderLength, DataLength;
    PNDIS_BUFFER    NdisBuffer;
    PNDIS_PACKET    NdisPacket;
    NDIS_STATUS     Status;
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    PRECV_DESC  RecvDesc;
    KIRQL       OldIrql;
    PMINIPORTCB     Adapter;

    AcquireBundleLock(BundleCB);

    NdisAcquireSpinLock(&NdisWanCB.Lock);
    Adapter = NdisWanCB.PromiscuousAdapter;
    NdisReleaseSpinLock(&NdisWanCB.Lock);

    if (Adapter == NULL) {
        ReleaseBundleLock(BundleCB);
        return;
    }

    DataLength = 
        SendDesc->HeaderLength + SendDesc->DataLength;

    RecvDesc = 
        NdisWanAllocateRecvDesc(DataLength + MAC_HEADER_LENGTH);

    if (RecvDesc == NULL) {
        ReleaseBundleLock(BundleCB);
        return;
    }

    HeaderBuffer = RecvDesc->StartBuffer;
    HeaderLength = 0;

    switch (SendType) {
        case SEND_LINK:
            NdisMoveMemory(HeaderBuffer, Header1, sizeof(Header1));
            HeaderBuffer[5] =
                HeaderBuffer[11] = (UCHAR)LinkCB->hLinkHandle;

            HeaderBuffer[12] = (UCHAR)(DataLength >> 8);
            HeaderBuffer[13] = (UCHAR)DataLength;
            HeaderLength = MAC_HEADER_LENGTH;
            break;

        case SEND_BUNDLE_PPP:
        case SEND_BUNDLE_DATA:
            break;


    }

    DataBuffer = HeaderBuffer + HeaderLength;

    NdisMoveMemory(DataBuffer,
                   SendDesc->StartBuffer,
                   DataLength);

    RecvDesc->CurrentBuffer = HeaderBuffer;
    RecvDesc->CurrentLength = HeaderLength + DataLength;
    if (RecvDesc->CurrentLength > 1514) {
        RecvDesc->CurrentLength = 1514;
    }

    //
    // Get an ndis packet
    //
    NdisPacket = 
        RecvDesc->NdisPacket;

    PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->RecvDesc = RecvDesc;

    //
    // Attach the buffers
    //
    NdisAdjustBufferLength(RecvDesc->NdisBuffer,
                           RecvDesc->CurrentLength);

    NdisRecalculatePacketCounts(NdisPacket);

    ReleaseBundleLock(BundleCB);

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    NDIS_SET_PACKET_STATUS(NdisPacket, NDIS_STATUS_RESOURCES);

    INSERT_DBG_RECV(PacketTypeNdis, Adapter, NULL, LinkCB, NdisPacket);

    //
    // Indicate the packet
    // This assumes that bloodhound is always a legacy transport
    //
    NdisMIndicateReceivePacket(Adapter->MiniportHandle,
                               &NdisPacket,
                               1);

    KeLowerIrql(OldIrql);

    Status = NDIS_GET_PACKET_STATUS(NdisPacket);

    ASSERT(Status == NDIS_STATUS_RESOURCES);

    REMOVE_DBG_RECV(PacketTypeNdis, Adapter, NdisPacket);

    {
        PNDIS_BUFFER    NdisBuffer;

        NdisWanFreeRecvDesc(RecvDesc);
    }
}

VOID
CompleteNdisPacket(
    PMINIPORTCB     MiniportCB,
    PPROTOCOLCB     ProtocolCB,
    PNDIS_PACKET    NdisPacket
    )
{
    PBUNDLECB   BundleCB = ProtocolCB->BundleCB;
    PCM_VCCB    CmVcCB;

    InterlockedDecrement(&ProtocolCB->OutstandingFrames);

    if (ProtocolCB->ProtocolType == PROTOCOL_PRIVATE_IO) {
        //
        // If this is a packet that we created we need to free
        // the resources
        //
        FreeIoNdisPacket(NdisPacket);
        return;
    }

    AcquireBundleLock(BundleCB);

    DEREF_PROTOCOLCB(ProtocolCB);

    ReleaseBundleLock(BundleCB);

    REMOVE_DBG_SEND(PacketTypeNdis, MiniportCB, NdisPacket);

    CmVcCB =
        PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->CmVcCB;

    if (CmVcCB != NULL) {
        NdisMCoSendComplete(NDIS_STATUS_SUCCESS,
                            CmVcCB->NdisVcHandle,
                            NdisPacket);

        DEREF_CMVCCB(CmVcCB);

    } else {

        NdisMSendComplete(MiniportCB->MiniportHandle,
                          NdisPacket,
                          NDIS_STATUS_SUCCESS);
    }

    //
    // Increment global count
    //
    NdisWanInterlockedInc(&glSendCompleteCount);
}

#if DBG
VOID
InsertDbgPacket(
    PDBG_PKT_CONTEXT   DbgContext
    )
{
    PDBG_PACKET DbgPacket, temp;
    PBUNDLECB   BundleCB = DbgContext->BundleCB;
    PPROTOCOLCB ProtocolCB = DbgContext->ProtocolCB;
    PLINKCB     LinkCB = DbgContext->LinkCB;

    DbgPacket =
        NdisAllocateFromNPagedLookasideList(&DbgPacketDescList);

    if (DbgPacket == NULL) {
        return;
    }

    DbgPacket->Packet = DbgContext->Packet;
    DbgPacket->PacketType = DbgContext->PacketType;
    DbgPacket->BundleCB = BundleCB;
    if (BundleCB) {
        DbgPacket->BundleState = BundleCB->State;
        DbgPacket->BundleFlags = BundleCB->Flags;
    }

    DbgPacket->ProtocolCB = ProtocolCB;
    if (ProtocolCB) {
        DbgPacket->ProtocolState = ProtocolCB->State;
    }

    DbgPacket->LinkCB = LinkCB;
    if (LinkCB) {
        DbgPacket->LinkState = LinkCB->State;
    }

    DbgPacket->SendCount = glSendCount;

    NdisAcquireSpinLock(DbgContext->ListLock);

    temp = (PDBG_PACKET)DbgContext->ListHead->Flink;

    while ((PVOID)temp != (PVOID)DbgContext->ListHead) {
        if (temp->Packet == DbgPacket->Packet) {
            DbgPrint("NDISWAN: Packet on list twice l %x desc %x pkt %x\n",
                     DbgContext->ListHead, DbgPacket, DbgPacket->Packet);
            DbgBreakPoint();
        }
        temp = (PDBG_PACKET)temp->Linkage.Flink;
    }

    InsertTailList(DbgContext->ListHead, &DbgPacket->Linkage);

    NdisReleaseSpinLock(DbgContext->ListLock);
}

BOOLEAN
RemoveDbgPacket(
    PDBG_PKT_CONTEXT DbgContext
    )
{
    PDBG_PACKET DbgPacket = NULL;
    BOOLEAN     Found = FALSE;

    NdisAcquireSpinLock(DbgContext->ListLock);

    if (!IsListEmpty(DbgContext->ListHead)) {
        for (DbgPacket = (PDBG_PACKET)DbgContext->ListHead->Flink;
            (PVOID)DbgPacket != (PVOID)DbgContext->ListHead;
            DbgPacket = (PDBG_PACKET)DbgPacket->Linkage.Flink) {

            if (DbgPacket->Packet == DbgContext->Packet) {
                RemoveEntryList(&DbgPacket->Linkage);
                NdisFreeToNPagedLookasideList(&DbgPacketDescList,
                    DbgPacket);
                Found = TRUE;
                break;
            }
        }
    }

    ASSERT(Found == TRUE);

    NdisReleaseSpinLock(DbgContext->ListLock);

    return (Found);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\tcpip.h ===
// TCP control bits

#ifndef _TCPIP_
#define _TCPIP_

#define TH_SYN      0x02    // Synchronize sequence numbers
#define TH_FIN      0x01    // Sender has reached end of his stream
#define TH_RST      0x04    // Reset the connection
#define TH_PUSH     0x08    // Push data to above level
#define TH_ACK      0x10    // Acknowledgement field is valid
#define TH_URG      0x20    // Urgent pointer is valid

struct tcphdr {
    USHORT  th_sport;
    USHORT  th_dport;
    ULONG   th_seq;
    ULONG   th_ack;
    UCHAR   th_off;
    UCHAR   th_flags;
    USHORT  th_win;
    UCHAR   th_sumhi;
    UCHAR   th_sumlo;
    USHORT  th_urp;
    UCHAR   th_data[1];
};

#define IP_ALEN 4

typedef struct IPaddr {
    ULONG   s_addr;
} IPaddr;

#define IPPROTO_TCP 6

struct ip_v4 {

    UCHAR   ip_hl;
    UCHAR   ip_tos;
    USHORT  ip_len;
    USHORT  ip_id;
    USHORT  ip_off;
    UCHAR   ip_ttl;
    UCHAR   ip_p;
    USHORT  ip_sum;
    IPaddr  ip_src;
    IPaddr  ip_dst;
    UCHAR   ip_data[1];
};

typedef struct ip_v4 IPV4Header, *PIPV4Header;

typedef struct _PPTP_HEADER {
    USHORT  Length;
    USHORT  PacketType;
    ULONG   Cookie;
    USHORT  MessageType;
    USHORT  Reserved1;
} PPTP_HEADER, *PPPTP_HEADER;


#endif // _TCPIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\tapi.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Tapi.c

Abstract:


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

//
// We want to initialize all of the global variables now!
//
#include "wan.h"

#define __FILE_SIG__    TAPI_FILESIG

EXPORT
VOID
NdisTapiCompleteRequest(
    IN  NDIS_HANDLE Handle,
    IN  PVOID       NdisRequest,
    IN  NDIS_STATUS Status
    );

EXPORT
VOID
NdisTapiIndicateStatus(
    IN  NDIS_HANDLE Handle,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

NDIS_STATUS
NdisWanTapiRequestProc(
    POPENCB OpenCB,
    PNDIS_REQUEST   NdisRequest
    )
/*++

Routine Name:

    NdisWanTapiRequestProc

Routine Description:

    Procedure is called by the NdisTapi.sys driver to send
    requests to the WanMiniport driver.  We intercept this
    just to moderate.  NdisTapi could call the miniport directly
    if we wanted but we don't.

Arguments:

Return Values:

--*/
{
    NDIS_STATUS     Status;
    PWAN_REQUEST    WanRequest;
    PNDIS_REQUEST   MyNdisRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_TAPI, ("NdisWanTapiRequestProc - Enter"));
    NdisWanDbgOut(DBG_INFO, DBG_TAPI, ("NdisRequest: Type: 0x%x OID: 0x%x",
    NdisRequest->RequestType,NdisRequest->DATA.QUERY_INFORMATION.Oid));

    WanRequest =
        NdisAllocateFromNPagedLookasideList(&WanRequestList);

    if (WanRequest == NULL) {
        return (NDIS_STATUS_RESOURCES);
    }

    WanRequest->Type = ASYNC;
    WanRequest->Origin = NDISTAPI;
    WanRequest->OpenCB = OpenCB;
    WanRequest->OriginalRequest = NdisRequest;

    NdisWanInitializeNotificationEvent(&WanRequest->NotificationEvent);

    MyNdisRequest = &WanRequest->NdisRequest;
    MyNdisRequest->RequestType =
        NdisRequest->RequestType;
    if (NdisRequest->RequestType == NdisRequestQueryInformation) {
        MyNdisRequest->DATA.QUERY_INFORMATION.Oid =
            NdisRequest->DATA.QUERY_INFORMATION.Oid;
        MyNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
            NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;
        MyNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
            NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength;
        MyNdisRequest->DATA.QUERY_INFORMATION.BytesWritten =
            NdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
    } else if (NdisRequest->RequestType == NdisRequestSetInformation) {
        MyNdisRequest->DATA.SET_INFORMATION.Oid =
            NdisRequest->DATA.SET_INFORMATION.Oid;
        MyNdisRequest->DATA.SET_INFORMATION.InformationBuffer =
            NdisRequest->DATA.SET_INFORMATION.InformationBuffer;
        MyNdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
            NdisRequest->DATA.SET_INFORMATION.InformationBufferLength;
        MyNdisRequest->DATA.SET_INFORMATION.BytesRead =
            NdisRequest->DATA.SET_INFORMATION.BytesRead;
    }
        
    Status = NdisWanSubmitNdisRequest(OpenCB, WanRequest);

    NdisWanDbgOut(DBG_INFO, DBG_TAPI, ("Status: 0x%x", Status));
    NdisWanDbgOut(DBG_TRACE, DBG_TAPI, ("NdisWanTapiRequestProc - Exit"));

    return (Status);
}

VOID
NdisWanTapiRequestComplete(
    POPENCB OpenCB,
    PWAN_REQUEST    WanRequest
    )
{
    PNDIS_REQUEST   NdisRequest, MyNdisRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_TAPI,
        ("NdisWanTapiRequestComplete - Enter"));

    NdisRequest = WanRequest->OriginalRequest;

    MyNdisRequest = &WanRequest->NdisRequest;
    if (NdisRequest->RequestType == NdisRequestQueryInformation) {
        NdisRequest->DATA.QUERY_INFORMATION.BytesWritten =
            MyNdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
    } else if (NdisRequest->RequestType == NdisRequestSetInformation) {
        NdisRequest->DATA.SET_INFORMATION.BytesRead =
            MyNdisRequest->DATA.SET_INFORMATION.BytesRead;
    }

    NdisWanDbgOut(DBG_INFO, DBG_TAPI,
        ("NdisRequest: Type: 0x%x OID: 0x%x",
        NdisRequest->RequestType,
        NdisRequest->DATA.QUERY_INFORMATION.Oid));

    NdisWanDbgOut(DBG_INFO, DBG_TAPI,
        ("Status: 0x%x", WanRequest->NotificationStatus));

    NdisTapiCompleteRequest(OpenCB,
                            NdisRequest,
                            WanRequest->NotificationStatus);

    NdisFreeToNPagedLookasideList(&WanRequestList, WanRequest);
}

VOID
NdisWanTapiIndication(
    POPENCB OpenCB,
    PUCHAR          StatusBuffer,
    ULONG           StatusBufferSize
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_TAPI, ("NdisWanTapiIndication - Enter"));

    //
    // If tapi is present and this miniport has registered for
    // connectionwrapper services give this to tapi
    //
    if (OpenCB->WanInfo.FramingBits & TAPI_PROVIDER) {

        NdisTapiIndicateStatus(OpenCB,
                               StatusBuffer,
                               StatusBufferSize);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_TAPI, ("NdisWanTapiIndication - Exit"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\util.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Util.c

Abstract:

This file contains utility functions used by NdisWan.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#define __FILE_SIG__    UTIL_FILESIG

VOID
NdisWanCopyFromPacketToBuffer(
    IN  PNDIS_PACKET    pNdisPacket,
    IN  ULONG           Offset,
    IN  ULONG           BytesToCopy,
    OUT PUCHAR          Buffer,
    OUT PULONG          BytesCopied
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   NdisBufferCount;
    PNDIS_BUFFER    CurrentBuffer;
    PVOID   VirtualAddress;
    ULONG   CurrentLength, AmountToMove;
    ULONG   LocalBytesCopied = 0, PacketLength;

    *BytesCopied = 0;

    //
    // Take care of zero byte copy
    //
    if (!BytesToCopy) {
        return;
    }

    //
    // Get the buffer count
    //
    NdisQueryPacket(pNdisPacket,
                    NULL,
                    &NdisBufferCount,
                    &CurrentBuffer,
                    &PacketLength);

    //
    // Could be a null packet
    //
    if (!NdisBufferCount ||
        Offset == PacketLength) {
        return;
    }


    NdisQueryBuffer(CurrentBuffer,
                    &VirtualAddress,
                    &CurrentLength);

    while (LocalBytesCopied < BytesToCopy &&
           LocalBytesCopied < PacketLength) {

        //
        // No more bytes left in this buffer
        //
        if (!CurrentLength) {

            //
            // Get the next buffer
            //
            NdisGetNextBuffer(CurrentBuffer,
                              &CurrentBuffer);

            //
            // End of the packet, copy what we can
            //
            if (CurrentBuffer == NULL) {
                break;
            }

            //
            //
            //
            NdisQueryBuffer(CurrentBuffer,
                            &VirtualAddress,
                            &CurrentLength);

            if (!CurrentLength) {
                continue;
            }

        }

        //
        // Get to the point where we can start copying
        //
        if (Offset) {

            if (Offset > CurrentLength) {

                //
                // Not in this buffer, go to the next one
                //
                Offset -= CurrentLength;
                CurrentLength = 0;
                continue;

            } else {

                //
                // At least some in this buffer
                //
                VirtualAddress = (PUCHAR)VirtualAddress + Offset;
                CurrentLength -= Offset;
                Offset = 0;
            }
        }

        if (!CurrentLength) {
            continue;
        }

        //
        // We can copy some data.  If we need more data than is available
        // in this buffer we can copy what we need and go back for more.
        //
        AmountToMove = (CurrentLength > (BytesToCopy - LocalBytesCopied)) ?
                       (BytesToCopy - LocalBytesCopied) : CurrentLength;

        NdisMoveMemory(Buffer, VirtualAddress, AmountToMove);

        Buffer = (PUCHAR)Buffer + AmountToMove;

        VirtualAddress = (PUCHAR)VirtualAddress + AmountToMove;

        LocalBytesCopied += AmountToMove;

        CurrentLength -= AmountToMove;
    }

    *BytesCopied = LocalBytesCopied;
}

VOID
NdisWanCopyFromBufferToPacket(
    PUCHAR  Buffer,
    ULONG   BytesToCopy,
    PNDIS_PACKET    NdisPacket,
    ULONG   PacketOffset,
    PULONG  BytesCopied
    )
{
    PNDIS_BUFFER    NdisBuffer;
    ULONG   NdisBufferCount, NdisBufferLength;
    PVOID   VirtualAddress;
    ULONG   LocalBytesCopied = 0;

    *BytesCopied = 0;

    //
    // Make sure we actually want to do something
    //
    if (BytesToCopy == 0) {
        return;
    }

    //
    // Get the buffercount of the packet
    //
    NdisQueryPacket(NdisPacket,
                    NULL,
                    &NdisBufferCount,
                    &NdisBuffer,
                    NULL);

    //
    // Make sure this is not a null packet
    //
    if (NdisBufferCount == 0) {
        return;
    }

    //
    // Get first buffer and buffer length
    //
    NdisQueryBuffer(NdisBuffer,
                    &VirtualAddress,
                    &NdisBufferLength);

    while (LocalBytesCopied < BytesToCopy) {

        if (NdisBufferLength == 0) {

            NdisGetNextBuffer(NdisBuffer,
                              &NdisBuffer);

            if (NdisBuffer == NULL) {
                break;
            }

            NdisQueryBuffer(NdisBuffer,
                            &VirtualAddress,
                            &NdisBufferLength);

            continue;
        }

        if (PacketOffset != 0) {

            if (PacketOffset > NdisBufferLength) {

                PacketOffset -= NdisBufferLength;

                NdisBufferLength = 0;

                continue;

            } else {
                VirtualAddress = (PUCHAR)VirtualAddress + PacketOffset;
                NdisBufferLength -= PacketOffset;
                PacketOffset = 0;
            }
        }

        //
        // Copy the data
        //
        {
            ULONG   AmountToMove;
            ULONG   AmountRemaining;

            AmountRemaining = BytesToCopy - LocalBytesCopied;

            AmountToMove = (NdisBufferLength < AmountRemaining) ?
                            NdisBufferLength : AmountRemaining;

            NdisMoveMemory((PUCHAR)VirtualAddress,
                           Buffer,
                           AmountToMove);

            Buffer += AmountToMove;
            LocalBytesCopied += AmountToMove;
            NdisBufferLength -= AmountToMove;
        }
    }

    *BytesCopied = LocalBytesCopied;
}

BOOLEAN
IsLinkValid(
    NDIS_HANDLE LinkHandle,
    BOOLEAN     CheckState,
    PLINKCB     *LinkCB
    )
{
    PLINKCB     plcb;
    LOCK_STATE  LockState;
    BOOLEAN     Valid;

    *LinkCB = NULL;
    Valid = FALSE;

    NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &LockState);

    do {

        if (PtrToUlong(LinkHandle) > ConnectionTable->ulArraySize) {
            break;
        }

        plcb = *(ConnectionTable->LinkArray + PtrToUlong(LinkHandle));

        if (plcb == NULL) {
            break;
        }

        NdisDprAcquireSpinLock(&plcb->Lock);

        if (CheckState &&
            (plcb->State != LINK_UP)) {

            NdisDprReleaseSpinLock(&plcb->Lock);
            break;
        }

        REF_LINKCB(plcb);
        NdisDprReleaseSpinLock(&plcb->Lock);

        *LinkCB = plcb;

        Valid = TRUE;

    } while (FALSE);


    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    return (Valid);
}

BOOLEAN
IsBundleValid(
    NDIS_HANDLE BundleHandle,
    BOOLEAN     CheckState,
    PBUNDLECB   *BundleCB
    )
{
    PBUNDLECB   pbcb;
    LOCK_STATE  LockState;
    BOOLEAN     Valid;

    *BundleCB = NULL;
    Valid = FALSE;

    NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &LockState);

    do {
        if (PtrToUlong(BundleHandle) > ConnectionTable->ulArraySize) {
            break;
        }

        pbcb = *(ConnectionTable->BundleArray + PtrToUlong(BundleHandle));

        if (pbcb == NULL) {
            break;
        }

        NdisDprAcquireSpinLock(&pbcb->Lock);

        if (CheckState &&
            (pbcb->State != BUNDLE_UP)) {

            NdisDprReleaseSpinLock(&pbcb->Lock);
            break;
        }

        REF_BUNDLECB(pbcb);
        NdisDprReleaseSpinLock(&pbcb->Lock);

        *BundleCB = pbcb;

        Valid = TRUE;

    } while (FALSE);

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    return (Valid);
}


BOOLEAN
AreLinkAndBundleValid(
    NDIS_HANDLE LinkHandle,
    BOOLEAN     CheckState,
    PLINKCB     *LinkCB,
    PBUNDLECB   *BundleCB
    )
{
    PLINKCB     plcb;
    PBUNDLECB   pbcb;
    LOCK_STATE  LockState;
    BOOLEAN     Valid;

    *LinkCB = NULL;
    *BundleCB = NULL;
    Valid = FALSE;

    NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &LockState);

    do {

        if (PtrToUlong(LinkHandle) > ConnectionTable->ulArraySize) {
            break;
        }

        plcb = *(ConnectionTable->LinkArray + PtrToUlong(LinkHandle));

        if (plcb == NULL) {
            break;
        }

        NdisDprAcquireSpinLock(&plcb->Lock);

        if (CheckState &&
            (plcb->State != LINK_UP)) {

            NdisDprReleaseSpinLock(&plcb->Lock);
            break;
        }

        pbcb = plcb->BundleCB;

        if (pbcb == NULL) {
            NdisDprReleaseSpinLock(&plcb->Lock);
            break;
        }

        REF_LINKCB(plcb);
        NdisDprReleaseSpinLock(&plcb->Lock);

        NdisDprAcquireSpinLock(&pbcb->Lock);
        REF_BUNDLECB(pbcb);
        NdisDprReleaseSpinLock(&pbcb->Lock);

        *LinkCB = plcb;
        *BundleCB = pbcb;

        Valid = TRUE;

    } while (FALSE);

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    return (Valid);
}

//
// Called with BundleCB->Lock held
//
VOID
DoDerefBundleCBWork(
    PBUNDLECB   BundleCB
    )
{
    ASSERT(BundleCB->State == BUNDLE_GOING_DOWN);
    ASSERT(BundleCB->OutstandingFrames == 0);
    ASSERT(BundleCB->ulNumberOfRoutes == 0);
    ASSERT(BundleCB->ulLinkCBCount == 0);
    ReleaseBundleLock(BundleCB);
    RemoveBundleFromConnectionTable(BundleCB);
    NdisWanFreeBundleCB(BundleCB);
}

//
// Called with LinkCB->Lock held
//
VOID
DoDerefLinkCBWork(
    PLINKCB     LinkCB
    )
{
    PBUNDLECB   _pbcb = LinkCB->BundleCB;

    ASSERT(LinkCB->State == LINK_GOING_DOWN);
    ASSERT(LinkCB->OutstandingFrames == 0);
    NdisReleaseSpinLock(&LinkCB->Lock);
    RemoveLinkFromBundle(_pbcb, LinkCB, FALSE);
    RemoveLinkFromConnectionTable(LinkCB);
    NdisWanFreeLinkCB(LinkCB);
}

//
//
//
VOID
DoDerefCmVcCBWork(
    PCM_VCCB    VcCB
    )
{
    InterlockedExchange((PLONG)&(VcCB)->State, CMVC_DEACTIVE);
    NdisMCmDeactivateVc(VcCB->NdisVcHandle);
    NdisMCmCloseCallComplete(NDIS_STATUS_SUCCESS, 
                             VcCB->NdisVcHandle, 
                             NULL);
}

//
// Called with ClAfSap->Lock held
//
VOID
DoDerefClAfSapCBWork(
    PCL_AFSAPCB AfSapCB
    )
{
    NDIS_STATUS Status;

    ASSERT(AfSapCB->Flags & SAP_REGISTERED);

    if (AfSapCB->Flags & SAP_REGISTERED) {

        AfSapCB->Flags &= ~(SAP_REGISTERED);
        AfSapCB->Flags |= (SAP_DEREGISTERING);

        NdisReleaseSpinLock(&AfSapCB->Lock);

        Status = NdisClDeregisterSap(AfSapCB->SapHandle);
    
        if (Status != NDIS_STATUS_PENDING) {
            ClDeregisterSapComplete(Status, AfSapCB);
        }

    } else {

        NdisReleaseSpinLock(&AfSapCB->Lock);

    }
}

VOID
DerefVc(
    PLINKCB LinkCB
    )
{
    //
    // Ref applied when we sent the packet to the underlying
    // miniport
    //
    LinkCB->VcRefCount--;

    if ((LinkCB->ClCallState == CL_CALL_CLOSE_PENDING) &&
        (LinkCB->VcRefCount == 0) ) {

        NDIS_STATUS CloseStatus;

        LinkCB->ClCallState = CL_CALL_CLOSED;

        NdisReleaseSpinLock(&LinkCB->Lock);

        CloseStatus =
            NdisClCloseCall(LinkCB->NdisLinkHandle,
                            NULL,
                            NULL,
                            0);

        if (CloseStatus != NDIS_STATUS_PENDING) {
            ClCloseCallComplete(CloseStatus,
                                LinkCB,
                                NULL);
        }

        NdisAcquireSpinLock(&LinkCB->Lock);
    }
}

VOID
DeferredWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    )
{
    NdisAcquireSpinLock(&DeferredWorkList.Lock);

    while (!(IsListEmpty(&DeferredWorkList.List))) {
        PLIST_ENTRY Entry;
        PBUNDLECB   BundleCB;

        Entry = RemoveHeadList(&DeferredWorkList.List);
        DeferredWorkList.ulCount--;

        NdisReleaseSpinLock(&DeferredWorkList.Lock);

        BundleCB =
            CONTAINING_RECORD(Entry, BUNDLECB, DeferredLinkage);

        AcquireBundleLock(BundleCB);

        BundleCB->Flags &= ~DEFERRED_WORK_QUEUED;

        //
        // Do all of the deferred work items for this Bundle
        //
        SendPacketOnBundle(BundleCB);

        //
        // Deref for the ref applied when we inserted this item on
        // the worker queue.
        //
        DEREF_BUNDLECB(BundleCB);

        NdisAcquireSpinLock(&DeferredWorkList.Lock);
    }

    DeferredWorkList.TimerScheduled = FALSE;

    NdisReleaseSpinLock(&DeferredWorkList.Lock);
}

NTSTATUS
TransformRegister(
    PVOID                       ClientOpenContext,
    ULONG                       CharsSize,
    PTRANSFORM_CHARACTERISTICS  Chars,
    ULONG                       CapsSize,
    PTRANSFORM_INFO             Caps
    )
{
    PTRANSDRVCB TransDrvCB = (PTRANSDRVCB)ClientOpenContext;
    PTRANSDRVCB tTransDrvCB;
    PTRANSFORM_IE   Ie = (PTRANSFORM_IE)(Caps->InfoElements);
    PTRANSFORM_IE   tIe;
    UINT    i, FoundCount = 0, MemoryNeeded = 0;

#if 0
    InterlockedExchange((PLONG)&TransDrvCB->State, TRANSDRV_REGISTERING);

    for (i = 0; i < Caps->InfoElementCount; i++) {

        if (Ie->IEType == TRANS_PPP_COMPRESSION ||
            Ie->IEType == TRANS_PPP_ENCRYPTION) {
            //
            // This is an IEType that we are interested in
            // but we have some requirements...
            // 1. It must support the framed interface unless it is
            //    MPPC/MPPE.
            // 2. If we already have a driver registered that supports
            //    this scheme we will not add this in again.
            // 3. We will give priority to drivers that have hardware
            //    assisted data transformation.
            //

            //
            // Walk the transform driver list and see if
            // this scheme is already registered by another
            // driver.  If it is, see if either has hardware
            // support.  If they have the same level of support
            // just use the one currently registered.  If the new
            // ie has a higher level of support mark the old ie
            // as not being used
            //
            NdisAcquireSpinLock(&TransformDrvList.Lock);
            for (tTransDrvCB = (PTRANSDRVCB)TransformDrvList.List.Flink;
                 (PVOID)tTransDrvCB != (PVOID)&TransformDrvList.List;
                 tTransDrvCB = (PTRANSDRVCB)tTransDrvCB->Linkage.Flink) {

                tIe = (PTRANSFORM_IE)tTransDrvCB->Caps->InfoElements;
                for (i = 0; i < tTransDrvCB->Caps->InfoElementCount; i++) {

                    if (tIe->Flags & IE_IN_USE) {

                    }

                }
            }
            NdisReleaseSpinLock(&TransformDrvList.Lock);

            MemoryNeeded += Ie->IESize;
        }

        Ie = (PTRANSFORM_IE)((PUCHAR)Ie + Ie->IESize);
    }

    if (FoundCount == 0) {
        return (STATUS_UNSUCCESSFUL);
    }

    NdisWanAllocateMemory(&TransDrvCB->Caps,
                          MemoryNeeded,
                          TRANSDRV_TAG);

    if (TransDrvCB->Caps == NULL) {
        return (STATUS_UNSUCCESSFUL);
    }

    TransDrvCB->Caps->InfoElementCount = FoundCount;
    tIe = (PTRANSFORM_IE)(TransDrvCB->Caps->InfoElements);

    for (i = 0; i < Caps->InfoElementCount; i++) {

        if (Ie->IEType == TRANS_PPP_COMPRESSION ||
            Ie->IEType == TRANS_PPP_ENCRYPTION) {
            NdisMoveMemory(tIe, Ie, Ie->IESize);
        }

        Ie = (PTRANSFORM_IE)((PUCHAR)Ie + Ie->IESize);
        tIe = (PTRANSFORM_IE)((PUCHAR)tIe + tIe->IESize);
    }

    NdisMoveMemory(&TransDrvCB->Chars, Chars, CharsSize);
#endif

    return (STATUS_SUCCESS);
}

VOID
TransformTxComplete(
    NTSTATUS    Status,
    PVOID       TxCtx,
    PMDL        InData,
    PMDL        OutData,
    ULONG       OutDataOffset,
    ULONG       OutDataLength
    )
{

}

VOID
TransformRxComplete(
    NTSTATUS    Status,
    PVOID       RxCtx,
    PMDL        InData,
    PMDL        OutData,
    ULONG       OutDataOffset,
    ULONG       OutDataLength
    )
{

}

NTSTATUS
TransformSendCtrlPacket(
    PVOID   TxCtx,
    ULONG   DataLength,
    PUCHAR  Data
    )
{

    return (STATUS_SUCCESS);
}


#ifdef NT

VOID
NdisWanStringToNdisString(
    PNDIS_STRING    pDestString,
    PWSTR           pSrcBuffer
    )
{
    PWSTR   Dest, Src = pSrcBuffer;
    NDIS_STRING SrcString;

    NdisWanInitUnicodeString(&SrcString, pSrcBuffer);
    NdisWanAllocateMemory(&pDestString->Buffer, SrcString.MaximumLength, NDISSTRING_TAG);
    if (pDestString->Buffer == NULL) {
        return;
    }
    pDestString->MaximumLength = SrcString.MaximumLength;
    pDestString->Length = SrcString.Length;
    NdisWanCopyUnicodeString(pDestString, &SrcString);
}

VOID
NdisWanInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The NdisWanInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}


VOID
NdisWanCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString OPTIONAL
    )

/*++

Routine Description:

    The NdisWanCopyUnicodeString function copies the SourceString 
    to the DestinationString.  If SourceString is not specified, 
    then the Length field of DestinationString is set to zero.  The
    MaximumLength and Buffer fields of DestinationString are not
    modified by this function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Optional pointer to the source string.

Return Value:

    None.

--*/

{
    UNALIGNED WCHAR *src, *dst;
    ULONG n;

    if (ARGUMENT_PRESENT(SourceString)) {
        dst = DestinationString->Buffer;
        src = SourceString->Buffer;
        n = SourceString->Length;
        if ((USHORT)n > DestinationString->MaximumLength) {
            n = DestinationString->MaximumLength;
        }

        DestinationString->Length = (USHORT)n;
        RtlCopyMemory(dst, src, n);
        if (DestinationString->Length < DestinationString->MaximumLength) {
            dst[n / sizeof(WCHAR)] = UNICODE_NULL;
        }

    } else {
        DestinationString->Length = 0;
    }

    return;
}


VOID
NdisWanFreeNdisString(
    PNDIS_STRING    NdisString
    )
{
    if (NdisString->Buffer != NULL) {
        NdisWanFreeMemory(NdisString->Buffer);
    }
}

VOID
NdisWanAllocateAdapterName(
    PNDIS_STRING    Dest,
    PNDIS_STRING    Src
    )
{
    NdisWanAllocateMemory(&Dest->Buffer, Src->MaximumLength, NDISSTRING_TAG);
    if (Dest->Buffer != NULL) {
        Dest->MaximumLength = Src->MaximumLength;
        Dest->Length = Src->Length;
        RtlUpcaseUnicodeString(Dest, Src, FALSE);
    }
}

BOOLEAN
NdisWanCompareNdisString(
    PNDIS_STRING    NdisString1,
    PNDIS_STRING    NdisString2
    )
{
    USHORT  l1 = NdisString1->Length;
    USHORT  l2 = NdisString2->Length;
    PWSTR   s1 = NdisString1->Buffer;
    PWSTR   s2 = NdisString2->Buffer;
    PWSTR   EndCompare;

    ASSERT(l1 != 0);
    ASSERT(l2 != 0);

    if (l1 == l2) {

        EndCompare = (PWSTR)((PUCHAR)s1 + l1);

        while (s1 < EndCompare) {

            if (*s1++ != *s2++) {
                return (FALSE);
                
            }
        }

        return (TRUE);
    }

    return(FALSE);
}


//VOID
//NdisWanFreeNdisString(
//  PNDIS_STRING    NdisString
//  )
//{
//  NdisFreeMemory(NdisString->Buffer,
//                 NdisString->MaximumLength * sizeof(WCHAR),
//                 0);
//}

VOID
NdisWanNdisStringToInteger(
    PNDIS_STRING    Source,
    PULONG          Value
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PWSTR   s = Source->Buffer;
    ULONG   Digit;

    *Value = 0;

    while (*s != UNICODE_NULL) {

        if (*s >= L'0' && *s < L'9') {
            Digit = *s - L'0';
        } else if (*s >= L'A' && *s <= L'F') {
            Digit = *s - L'A' + 10;
        } else if (*s >= L'a' && *s <= L'f') {
            Digit = *s - L'a' + 10;
        } else {
            break;
        }

        *Value = (*Value << 4) | Digit;

        s++;
    }
}

VOID
NdisWanCopyNdisString(
    PNDIS_STRING Dest,
    PNDIS_STRING Src
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PWSTR   SrcBuffer = Src->Buffer;
    PWSTR   DestBuffer = Dest->Buffer;

    while (*SrcBuffer != UNICODE_NULL) {

        *DestBuffer = *SrcBuffer;

        SrcBuffer++;
        DestBuffer++;
    }

    *DestBuffer = UNICODE_NULL;

    Dest->Length = Src->Length;

}

VOID
BonDWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    )
{
    PLIST_ENTRY Entry;

    NdisAcquireSpinLock(&BonDWorkList.Lock);

    for (Entry = BonDWorkList.List.Flink;
        Entry != &BonDWorkList.List;
        Entry = Entry->Flink) {
        PBUNDLECB   BundleCB;

        BundleCB = CONTAINING_RECORD(Entry, BUNDLECB, BonDLinkage);

        NdisReleaseSpinLock(&BonDWorkList.Lock);

        AcquireBundleLock(BundleCB);

        if (BundleCB->State != BUNDLE_UP ||
            !(BundleCB->Flags & BOND_ENABLED)) {
            ReleaseBundleLock(BundleCB);
            NdisAcquireSpinLock(&BonDWorkList.Lock);
            continue;
        }

        AgeSampleTable(&BundleCB->SUpperBonDInfo->SampleTable);
        CheckUpperThreshold(BundleCB);
    
        AgeSampleTable(&BundleCB->SLowerBonDInfo->SampleTable);
        CheckLowerThreshold(BundleCB);
    
        AgeSampleTable(&BundleCB->RUpperBonDInfo->SampleTable);
        CheckUpperThreshold(BundleCB);
    
        AgeSampleTable(&BundleCB->RLowerBonDInfo->SampleTable);
        CheckUpperThreshold(BundleCB);

        ReleaseBundleLock(BundleCB);

        NdisAcquireSpinLock(&BonDWorkList.Lock);
    }

    NdisReleaseSpinLock(&BonDWorkList.Lock);
}

#if 0
VOID
CheckBonDInfo(
    PKDPC       Dpc,
    PBUNDLECB   BundleCB,
    PVOID       SysArg1,
    PVOID       SysArg2
    )
{
    if (!(BundleCB->Flags & BOND_ENABLED)) {
        return;
    }

    AgeSampleTable(&BundleCB->SUpperBonDInfo.SampleTable);
    CheckUpperThreshold(BundleCB);

    AgeSampleTable(&BundleCB->SLowerBonDInfo.SampleTable);
    CheckLowerThreshold(BundleCB);

    AgeSampleTable(&BundleCB->RUpperBonDInfo.SampleTable);
    CheckUpperThreshold(BundleCB);

    AgeSampleTable(&BundleCB->RLowerBonDInfo.SampleTable);
    CheckUpperThreshold(BundleCB);
}
#endif

VOID
AgeSampleTable(
    PSAMPLE_TABLE   SampleTable
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    WAN_TIME    CurrentTime, TimeDiff;
    ULONG       HeadIndex = SampleTable->ulHead;

    //
    // Should return CurrentTime in 100ns units
    //
    NdisWanGetSystemTime(&CurrentTime);

    //
    // We will search through the sample indexing over samples that are more than
    // one second older than the current time.
    //
    while (!IsSampleTableEmpty(SampleTable) ) {
        PBOND_SAMPLE    FirstSample;

        FirstSample = &SampleTable->SampleArray[SampleTable->ulHead];

        NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &FirstSample->TimeStamp);

        if (NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SamplePeriod))
            break;
            
        SampleTable->ulCurrentSampleByteCount -= FirstSample->ulBytes;

        ASSERT((LONG)SampleTable->ulCurrentSampleByteCount >= 0);

        FirstSample->ulReferenceCount = 0;

        if (++SampleTable->ulHead == SampleTable->ulSampleArraySize) {
            SampleTable->ulHead = 0;            
        }

        SampleTable->ulSampleCount--;
    }

    if (IsSampleTableEmpty(SampleTable)) {
        ASSERT((LONG)SampleTable->ulCurrentSampleByteCount == 0);
        SampleTable->ulHead = SampleTable->ulCurrent;
    }
}

VOID
UpdateSampleTable(
    PSAMPLE_TABLE   SampleTable,
    ULONG           Bytes
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    WAN_TIME    CurrentTime, TimeDiff;
    ULONG   CurrentIndex = SampleTable->ulCurrent;
    PBOND_SAMPLE    CurrentSample = &SampleTable->SampleArray[CurrentIndex];

    NdisWanGetSystemTime(&CurrentTime);

    NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &CurrentSample->TimeStamp);

    if (NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SampleRate) ||
        IsSampleTableFull(SampleTable)) {
        //
        // Add this send on the previous sample
        //
        CurrentSample->ulBytes += Bytes;
        CurrentSample->ulReferenceCount++;
    } else {
        ULONG   NextIndex;

        //
        // We need a new sample
        //
        if (IsSampleTableEmpty(SampleTable)) {
            NextIndex = SampleTable->ulHead;
            ASSERT(NextIndex == SampleTable->ulCurrent);
        } else {
            NextIndex = SampleTable->ulCurrent + 1;
        }

        if (NextIndex == SampleTable->ulSampleArraySize) {
            NextIndex = 0;
        }

        SampleTable->ulCurrent = NextIndex;

        CurrentSample = &SampleTable->SampleArray[NextIndex];
        CurrentSample->TimeStamp = CurrentTime;
        CurrentSample->ulBytes = Bytes;
        CurrentSample->ulReferenceCount = 1;
        SampleTable->ulSampleCount++;

        ASSERT(SampleTable->ulSampleCount <= SampleTable->ulSampleArraySize);
    }

    SampleTable->ulCurrentSampleByteCount += Bytes;
}

VOID
UpdateBandwidthOnDemand(
    PBOND_INFO  BonDInfo,
    ULONG       Bytes
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PSAMPLE_TABLE   SampleTable = &BonDInfo->SampleTable;

    //
    // Age and update the sample table
    //
    AgeSampleTable(SampleTable);
    UpdateSampleTable(SampleTable, Bytes);
}

VOID
CheckUpperThreshold(
    PBUNDLECB       BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    WAN_TIME    CurrentTime, TimeDiff;
    PBOND_INFO  BonDInfo;
    PSAMPLE_TABLE   SampleTable;
    ULONGLONG   Bps;
    BOOLEAN     SSignal, RSignal;

    //
    // First check send side
    //
    BonDInfo = BundleCB->SUpperBonDInfo;
    SSignal = FALSE;
    SampleTable = &BonDInfo->SampleTable;
    Bps = SampleTable->ulCurrentSampleByteCount;

    //
    // Switch on the current state
    //
    switch (BonDInfo->State) {

        case BonDSignaled:
            break;

        case BonDIdle:
            //
            // We are currently below the upper threshold.  If we
            // go over the upperthreshold we will set the time and
            // transition to the monitor state.
            //
            if (Bps >= BonDInfo->ulBytesThreshold) {
                NdisWanGetSystemTime(&BonDInfo->StartTime);
                BonDInfo->State = BonDMonitor;
                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-S: i -> m, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
            }
            break;

        case BonDMonitor:

            //
            // We are currently in the monitor state which means that
            // we have gone above the upper threshold.  If we fall below
            // the upper threshold we will go back to the idle state.
            //
            if (Bps < BonDInfo->ulBytesThreshold) {

                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-S: m -> i, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
                BonDInfo->State = BonDIdle;

            } else {

                NdisWanGetSystemTime(&CurrentTime);

                NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &BonDInfo->StartTime);

                if (!NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SamplePeriod))  {

                    SSignal = TRUE;
                }
            }
            break;
    }

    //
    // Now check the receive side
    //
    BonDInfo = BundleCB->RUpperBonDInfo;
    RSignal = FALSE;
    SampleTable = &BonDInfo->SampleTable;
    Bps = SampleTable->ulCurrentSampleByteCount;

    switch (BonDInfo->State) {

        case BonDSignaled:
            break;

        case BonDIdle:
            //
            // We are currently below the upper threshold.  If we
            // go over the upperthreshold we will set the time and
            // transition to the monitor state.
            //
            if (Bps >= BonDInfo->ulBytesThreshold) {
                NdisWanGetSystemTime(&BonDInfo->StartTime);
                BonDInfo->State = BonDMonitor;
                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-R: i -> m, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
            }
            break;

        case BonDMonitor:

            //
            // We are currently in the monitor state which means that
            // we have gone above the upper threshold.  If we fall below
            // the upper threshold we will go back to the idle state.
            //
            if (Bps < BonDInfo->ulBytesThreshold) {

                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-R: m -> i, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
                BonDInfo->State = BonDIdle;

            } else {

                NdisWanGetSystemTime(&CurrentTime);

                NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &BonDInfo->StartTime);

                if (!NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SamplePeriod))  {

                    RSignal = TRUE;
                }
            }
            break;
    }

    if (SSignal || RSignal) {

        //
        // We have been above the threshold for time greater than the
        // threshold sample period so we need to notify someone of this
        // historic event!
        //
        CompleteThresholdEvent(BundleCB, BonDInfo->DataType, UPPER_THRESHOLD);
    
        BundleCB->SUpperBonDInfo->State = BonDSignaled;
        BundleCB->RUpperBonDInfo->State = BonDSignaled;

#if DBG
        {
            ULONGLONG   util;

            util = BundleCB->SUpperBonDInfo->SampleTable.ulCurrentSampleByteCount;
            util *= 100;
            util /= BundleCB->SUpperBonDInfo->ulBytesInSamplePeriod;
            NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-S: Bps %I64d Threshold %I64d Util %I64d",
                     Bps, BundleCB->SUpperBonDInfo->ulBytesThreshold, util));

            util = BundleCB->RUpperBonDInfo->SampleTable.ulCurrentSampleByteCount;
            util *= 100;
            util /= BundleCB->RUpperBonDInfo->ulBytesInSamplePeriod;
            NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-R: Bps %I64d Threshold %I64d Util %I64d",
                     Bps, BundleCB->RUpperBonDInfo->ulBytesThreshold, util));
        }
#endif

    }
}

VOID
CheckLowerThreshold(
    PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    WAN_TIME    CurrentTime, TimeDiff;
    PBOND_INFO  BonDInfo;
    PSAMPLE_TABLE   SampleTable;
    ULONGLONG   Bps;
    BOOLEAN     SSignal, RSignal;

    if (!(BundleCB->Flags & BOND_ENABLED)) {
        return;
    }

    //
    // First check send side
    //
    BonDInfo = BundleCB->SLowerBonDInfo;
    SampleTable = &BonDInfo->SampleTable;
    Bps = SampleTable->ulCurrentSampleByteCount;
    SSignal = FALSE;

    //
    // Switch on the current state
    //
    switch (BonDInfo->State) {

        case BonDIdle:
            //
            // We are currently above the lower threshold.  If we
            // go under the lowerthreshold we will set the time and
            // transition to the monitor state.
            //
            if (Bps <= BonDInfo->ulBytesThreshold) {
                NdisWanGetSystemTime(&BonDInfo->StartTime);
                BonDInfo->State = BonDMonitor;
                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-S: i -> m, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
            }
            break;

        case BonDMonitor:

            //
            // We are currently in the monitor state which means that
            // we have gone below the lower threshold.  If we climb above
            // the lower threshold we will go back to the idle state.
            //
            if (Bps > BonDInfo->ulBytesThreshold) {

                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-S: m -> i, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
                BonDInfo->State = BonDIdle;

            } else {

                NdisWanGetSystemTime(&CurrentTime);

                NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &BonDInfo->StartTime);

                if (!NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SamplePeriod))  {

                    SSignal = TRUE;
                }
            }
            break;

        case BonDSignaled:
            break;
    }

    //
    // Now check the receive side
    //
    BonDInfo = BundleCB->RLowerBonDInfo;
    RSignal = FALSE;
    SampleTable = &BonDInfo->SampleTable;
    Bps = SampleTable->ulCurrentSampleByteCount;

    switch (BonDInfo->State) {

        case BonDIdle:
            //
            // We are currently above the lower threshold.  If we
            // go below the lowerthreshold we will set the time and
            // transition to the monitor state.
            //
            if (Bps <= BonDInfo->ulBytesThreshold) {
                NdisWanGetSystemTime(&BonDInfo->StartTime);
                BonDInfo->State = BonDMonitor;
                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-R: i -> m, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
            }
            break;

        case BonDMonitor:

            //
            // We are currently in the monitor state which means that
            // we have gone below the lower threshold.  If we climb above
            // the lower threshold we will go back to the idle state.
            //
            if (Bps > BonDInfo->ulBytesThreshold) {

                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-R: m -> i, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
                BonDInfo->State = BonDIdle;

            } else {

                NdisWanGetSystemTime(&CurrentTime);

                NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &BonDInfo->StartTime);

                if (!NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SamplePeriod))  {

                    RSignal = TRUE;
                }
            }
            break;

        case BonDSignaled:
            break;
    }

    if (SSignal && RSignal) {
        //
        // We have been above the threshold for time greater than the
        // threshold sample period so we need to notify someone of this
        // historic event!
        //
        CompleteThresholdEvent(BundleCB, BonDInfo->DataType, LOWER_THRESHOLD);
    
        BundleCB->SLowerBonDInfo->State = BonDSignaled;
        BundleCB->RLowerBonDInfo->State = BonDSignaled;

#if DBG
        {
            ULONGLONG   util;

            util = BundleCB->SLowerBonDInfo->SampleTable.ulCurrentSampleByteCount;
            util *= 100;
            util /= BundleCB->SLowerBonDInfo->ulBytesInSamplePeriod;
            NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-S: Bps %I64d Threshold %I64d Util %I64d",
                     Bps, BundleCB->SLowerBonDInfo->ulBytesThreshold, util));

            util = BundleCB->RLowerBonDInfo->SampleTable.ulCurrentSampleByteCount;
            util *= 100;
            util /= BundleCB->RLowerBonDInfo->ulBytesInSamplePeriod;
            NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-R: Bps %I64d Threshold %I64d Util %I64d",
                     Bps, BundleCB->RLowerBonDInfo->ulBytesThreshold, util));
        }
#endif
    }
}

#endif  // end of ifdef NT

#if DBG
VOID
InsertSendTrc(
    PSEND_TRC_INFO  SendTrcInfo,
    ULONG           DataLength,
    PUCHAR          Data
    )
{
    PWAN_TRC_EVENT  NewTrcEvent;
    PSEND_TRC_INFO  TrcInfo;

    if (WanTrcCount == 4096) {
        NewTrcEvent = (PWAN_TRC_EVENT)
            RemoveTailList(&WanTrcList);

        NdisWanFreeMemory(NewTrcEvent->TrcInfo);

        NdisZeroMemory(NewTrcEvent, sizeof(WAN_TRC_EVENT));

    } else {
        NdisWanAllocateMemory(&NewTrcEvent, 
                              sizeof(WAN_TRC_EVENT), 
                              WANTRCEVENT_TAG);

        if (NewTrcEvent == NULL) {
            return;
        }
    }

    WanTrcCount += 1;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\transdrv.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    transfdrv.h

Abstract:

    This file contains defines for the NdisWan driver.

Author:

    Tony Bell	(TonyBe) January 36, 1998

Environment:

    Kernel Mode

Revision History:

    TonyBe		01/26/98		Created

--*/

#ifndef _TRANSDRV_
#define _TRANSDRV_

//
// Transform Driver client handlers
//
typedef
    NTSTATUS
    (*CL_TRANS_REGISTER)(
    IN  PVOID   ClientOpenContext,
    IN  ULONG   CharacteristicsSize,
    IN  struct _TRANSFORM_CHARACTERISTICS   *Characteristics,
    IN  ULONG   TransformCapsSize,
    IN  struct _TRANSFORM_INFO  *TransformCaps
    );

typedef
    VOID
    (*CL_TRANS_TX_COMPLETE)(
    IN  NTSTATUS    Status,
    IN  PVOID       ClientTxContext,
    IN  PMDL        InData,
    IN  PMDL        OutData,
    IN ULONG        OutDataOffset,
    IN ULONG        OutDataLength
    );

typedef
    VOID
    (*CL_TRANS_RX_COMPLETE)(
    IN  NTSTATUS    Status,
    IN  PVOID       ClientRxContext,
    IN  PMDL        InData,
    IN  PMDL        OutData,
    IN ULONG        OutDataOffset,
    IN ULONG        OutDataLength
    );

typedef
    NTSTATUS
    (*CL_TRANS_SEND_CTRL)(
    IN  PVOID       ClientTxContext,
    IN  ULONG       DataLength,
    IN  UCHAR       Data[1]
    );

//
// Transform Driver handlers
//
typedef
    NTSTATUS
    (*TRANS_ALLOC_CTX)(
    IN  PVOID   ClientTxContext,
    OUT PVOID   *TransformTxContext,
    IN  ULONG   MaxInputDataSize,
    OUT PULONG  MaxOutputDataSize,
    IN  ULONG   TransformInfoSize,
    IN  struct _TRANSFORM_INFO  *TransformInfo
    );

typedef
    NTSTATUS
    (*TRANS_ALLOC_CTX)(
    IN  PVOID   ClientRxContext,
    OUT PVOID   *TransformRxContext,
    IN  ULONG   MaxInputDataSize,
    OUT PULONG  MaxOutputDataSize,
    IN  ULONG   TransformInfoSize,
    IN  struct _TRANSFORM_INFO  *TransformInfo
    );

typedef
    VOID
    (*TRANS_FREE_CTX)(
    IN PVOID    TransformContext
    );

typedef
    VOID
    (*TRANS_SET_TXCTX_INFO)(
    IN  PVOID   TransformTxContext,
    IN  ULONG   Cmd,
    IN  ULONG   CmdInfoSize,
    IN  PUCHAR  CmdInfo
    );

typedef
    VOID
    (*TRANS_SET_RXCTX_INFO)(
    IN  PVOID   TransformRxContext,
    IN  ULONG   Cmd,
    IN  ULONG   CmdInfoSize,
    IN  PUCHAR  CmdInfo
    );

typedef
    NTSTATUS
    (*TRANS_TRANSFORM_TX_DATA)(
    IN      PVOID   TransformTxContext,
    IN      PMDL    InData,
    IN      ULONG   InDataOffset,
    IN      ULONG   InDataLength,
    IN OUT  PMDL    OutData,
    IN OUT  ULONG   OutDataOffset,
    IN OUT  PULONG  OutDataLength
    );

typedef
    NTSTATUS
    (*TRANS_TRANSFORM_RX_DATA)(
    IN      PVOID   TransformRxContext,
    IN      PMDL    InData,
    IN      ULONG   InDataOffset,
    IN      ULONG   InDataLength,
    IN OUT  PMDL    OutData,
    IN OUT  ULONG   OutDataOffset,
    IN OUT  PULONG  OutDataLength
    );

typedef
    NTSTATUS
    (*TRANS_RECV_CTRL)(
    IN  PVOID       TransformRxContext,
    IN  ULONG       DataLength,
    IN  UCHAR       Data[1]
    );

#define FILE_DEVICE_TRANSFORM_DRIVER	0x066
#define FUNC_TRANSFORM_OPEN				0
#define FUNC_TRANSFORM_CLOSE			1

#define TRANSFORM_CTL_CODE(_Function) \
	CTL_CODE(FILE_DEVICE_TRANSFORM_DRIVER, _Function, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_TRANSFORM_OPEN \
	TRANSFORM_CTL_CODE(FUNC_TRANSFORM_OPEN)

#define IOCTL_TRANSFORM_CLOSE \
	TRANSFORM_CTL_CODE(FUNC_TRANSFORM_CLOSE)

#define HARDWARE_ACCELERATED	0x00000001

#define FRAMING_MODE			0x00000001
#define RAW_MODE				0x00000002
#define DATA_EXPANSION			0x00000004

typedef enum _TRANSFOR_IE_TYPE {
    TRANS_PPP_COMPRESSION = 1,
    TRANS_PPP_ENCRYPTION,
    TRANS_IPSEC_ENCRYPTION,
    TRANS_IPSEC_HASHING
} TRANSFORM_IE_TYPE;

typedef struct  _TRANSFORM_OPEN {
    IN  PVOID                   ClientOpenContext;
    OUT PVOID                   *TransformOpenContext;
    IN  UCHAR                   MajorVersion;
    IN  UCHAR                   MinorVersion;
    IN  CL_TRANS_REGISTER       TransformRegisterHandler;
    IN  CL_TRANS_TX_COMPLETE    TransformTxCompleteHandler;
    IN  CL_TRANS_RX_COMPLETE    TransformRxCompleteHandler;
    IN  CL_TRANS_SEND_CTRL      SendCtrlPacketHandler;
} TRANSFORM_OPEN, *PTRANSFORM_OPEN;

typedef struct  _TRANSFORM_CLOSE {
    IN  PVOID   TransformOpenContext;
} TRANSFORM_CLOSE, *PTRANSFORM_CLOSE;


typedef struct _TRANSFORM_CHARACTERISTICS {
    UCHAR                       MajorVersion;
    UCHAR                       MinorVersion;
    USHORT                      Reserved;
    ULONG                       Flags;
//	TRANS_GET_INFO				GetInfoHandler;
    TRANS_ALLOC_CTX             AllocTxCtxHandler;
    TRANS_ALLOC_CTX             AllocateRxCtxHandle;
    TRANS_FREE_CTX              FreeCtxHandler;
    TRANS_SET_TXCTX_INFO        SetTxCtxInfoHandler;
    TRANS_SET_RXCTX_INFO        SetRxCtxInfoHandler;
    TRANS_TRANSFORM_TX_DATA     TransformTxDataHandler;
    TRANS_TRANSFORM_RX_DATA     TransformRxDataHandler;
    TRANS_RECV_CTRL             RecvCtrlPacketHandler;
} TRANSFORM_CHARACTERISTICS, *PTRANSFORM_CHARACTERISTICS;


typedef struct _TRANSFORM_INFO {
    ULONG       InfoElementCount;
    UCHAR       InfoElements[1];
} TRANSFORM_INFO, *PTRANSFORM_INFO;


typedef struct _TRANSFORM_IE {
    TRANSFORM_IE_TYPE   IEType;
    ULONG               IESize;
    ULONG               Flags;
    UCHAR               IEData[1];
} TRANSFORM_IE, *PTRANSFORM_IE;

//
// Encryption key sizes
//
#ifndef MAX_SESSIONKEY_SIZE
#define MAX_SESSIONKEY_SIZE		8
#endif

#ifndef MAX_USERSESSIONKEY_SIZE
#define MAX_USERSESSIONKEY_SIZE	16
#endif

#ifndef MAX_CHALLENGE_SIZE
#define MAX_CHALLENGE_SIZE		8
#endif

typedef struct _IE_CCP {
    //
    // MPPC/MPPE specific fields
    //
	UCHAR	LMSessionKey[MAX_SESSIONKEY_SIZE];
	UCHAR	UserSessionKey[MAX_USERSESSIONKEY_SIZE];
	UCHAR	Challenge[MAX_CHALLENGE_SIZE];
	ULONG	MSCompType;
    //
    // End of MPPC/MPPE specifc fields
    //

	UCHAR	CompType;
	USHORT	CompLength;

	union {
		struct {
			UCHAR	CompOUI[3];
			UCHAR	CompSubType;
			UCHAR	CompValues[32];
		} Proprietary;

		struct {
			UCHAR	CompValues[32];
		} Public;
	};

}IE_CCP, *PIE_CCP;

typedef struct IE_ECP{
	UCHAR	EncryptType;
	USHORT	EncryptLength;

	union {
		struct {
			UCHAR	EncryptOUI[3];
			UCHAR	EncryptSubtype;
			UCHAR	EncryptValues[1];
		} Proprietary;

		struct {
			UCHAR	EncryptValues[1];
		} Public;
	};

} IE_ECP, *PIE_ECP;

#endif // _TRANSDRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\vjslip.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vjslip.c

Abstract:

Author:

    Thomas J. Dimitri  (TommyD)

Environment:

Revision History:

--*/

#include "wan.h"

#define __FILE_SIG__    VJ_FILESIG

#if 0
NPAGED_LOOKASIDE_LIST   VJCtxList; // List of free vj context descs
#endif

#define INCR(counter) ++comp->counter;

//   A.2  Compression
//
//   This routine looks daunting but isn't really.  The code splits into four
//   approximately equal sized sections:  The first quarter manages a
//   circularly linked, least-recently-used list of `active' TCP
//   connections./47/  The second figures out the sequence/ack/window/urg
//   changes and builds the bulk of the compressed packet.  The third handles
//   the special-case encodings.  The last quarter does packet ID and
//   connection ID encoding and replaces the original packet header with the
//   compressed header.
//
//   The arguments to this routine are a pointer to a packet to be
//   compressed, a pointer to the compression state data for the serial line,
//   and a flag which enables or disables connection id (C bit) compression.
//
//   Compression is done `in-place' so, if a compressed packet is created,
//   both the start address and length of the incoming packet (the off and
//   len fields of m) will be updated to reflect the removal of the original
//   header and its replacement by the compressed header.  If either a
//   compressed or uncompressed packet is created, the compression state is
//   updated.  This routines returns the packet type for the transmit framer
//   (TYPE_IP, TYPE_UNCOMPRESSED_TCP or TYPE_COMPRESSED_TCP).
//
//   Because 16 and 32 bit arithmetic is done on various header fields, the
//   incoming IP packet must be aligned appropriately (e.g., on a SPARC, the
//   IP header is aligned on a 32-bit boundary).  Substantial changes would
//   have to be made to the code below if this were not true (and it would
//   probably be cheaper to byte copy the incoming header to somewhere
//   correctly aligned than to make those changes).
//
//   Note that the outgoing packet will be aligned arbitrarily (e.g., it
//   could easily start on an odd-byte boundary).
//

UCHAR
sl_compress_tcp(
    PUUCHAR UNALIGNED   *m_off,         // Frame start (points to IP header)
    ULONG               *m_len,         // Length of entire frame
    ULONG               *precomph_len,  // Length of TCP/IP header pre-comp
    ULONG               *postcomph_len, // Length of TCP/IP header post-comp
    struct slcompress   *comp,          // Compression struct for this link
    ULONG compress_cid) {               // Compress connection id boolean

    struct cstate *cs = comp->last_cs->cs_next;
    struct ip_v4 UNALIGNED *ip = (struct ip_v4 UNALIGNED *)*m_off;
    struct ip_v4 UNALIGNED *csip;
    ULONG hlen = ip->ip_hl & 0x0F;      // last 4 bits are the length
    struct tcphdr UNALIGNED *oth;       /* last TCP header */
    struct tcphdr UNALIGNED *th;        /* current TCP header */

//   ----------------------------
//    47. The two most common operations on the connection list are a `find'
//   that terminates at the first entry (a new packet for the most recently
//   used connection) and moving the last entry on the list to the head of
//   the list (the first packet from a new connection).  A circular list
//   efficiently handles these two operations.

    ULONG deltaS, deltaA;     /* general purpose temporaries */
    ULONG changes = 0;        /* change mask */
    UCHAR new_seq[16];       /* changes from last to current */
    UCHAR UNALIGNED *cp = new_seq;
    USHORT ip_len;

    /*
     * Bail if this is an IP fragment or if the TCP packet isn't
     * `compressible' (i.e., ACK isn't set or some other control bit is
     * set).  Or if it does not contain the TCP protocol.
     */
    if ((ip->ip_off & 0xff3f) || *m_len < 40 || ip->ip_p != IPPROTO_TCP)
         return (TYPE_IP);

    th = (struct tcphdr UNALIGNED *) & ((ULONG UNALIGNED *) ip)[hlen];
    if ((th->th_flags & (TH_SYN | TH_FIN | TH_RST | TH_ACK)) != TH_ACK)
         return (TYPE_IP);

    //
    // The TCP/IP stack is propagating the padding bytes that it
    // is receiving off of the LAN.  This shows up here as a
    // packet that has a length that is greater than the IP datagram
    // length.  We will add this work around for now.
    //
    if (*m_len > ntohs(ip->ip_len)) {
        *m_len = ntohs(ip->ip_len);
    }

    /*
     * Packet is compressible -- we're going to send either a
     * COMPRESSED_TCP or UNCOMPRESSED_TCP packet.  Either way we need to
     * locate (or create) the connection state.  Special case the most
     * recently used connection since it's most likely to be used again &
     * we don't have to do any reordering if it's used.
     */

    //
    // Keep stats here
    //
    INCR(OutPackets);

    csip = (struct ip_v4 UNALIGNED*)&cs->cs_ip;

    if (ip->ip_src.s_addr != csip->ip_src.s_addr ||
        ip->ip_dst.s_addr != csip->ip_dst.s_addr ||
        *(ULONG UNALIGNED *) th != ((ULONG UNALIGNED *) csip)[csip->ip_hl & 0x0F]) {

         /*
          * Wasn't the first -- search for it.
          *
          * States are kept in a circularly linked list with last_cs
          * pointing to the end of the list.  The list is kept in lru
          * order by moving a state to the head of the list whenever
          * it is referenced.  Since the list is short and,
          * empirically, the connection we want is almost always near
          * the front, we locate states via linear search.  If we
          * don't find a state for the datagram, the oldest state is
          * (re-)used.
          */
         struct cstate *lcs;
         struct cstate *lastcs = comp->last_cs;

         do {
              lcs = cs;
              cs = cs->cs_next;
              INCR(OutSearches);

              csip = (struct ip_v4 UNALIGNED*)&cs->cs_ip;

              if (ip->ip_src.s_addr == csip->ip_src.s_addr &&
                  ip->ip_dst.s_addr == csip->ip_dst.s_addr &&
                  *(ULONG UNALIGNED *) th == ((ULONG UNALIGNED *) csip)[cs->cs_ip.ip_hl & 0x0F])

                   goto found;

         } while (cs != lastcs);

         /*
          * Didn't find it -- re-use oldest cstate.  Send an
          * uncompressed packet that tells the other side what
          * connection number we're using for this conversation. Note
          * that since the state list is circular, the oldest state
          * points to the newest and we only need to set last_cs to
          * update the lru linkage.
          */

         INCR(OutMisses);

         //
         // A miss!
         //
         comp->last_cs = lcs;
         hlen += (th->th_off >> 4);
         hlen <<= 2;

         if (hlen > *m_len) {
             return(TYPE_IP);
         }

         goto uncompressed;

found:
         /* Found it -- move to the front on the connection list. */
         if (cs == lastcs)
              comp->last_cs = lcs;
         else {
              lcs->cs_next = cs->cs_next;
              cs->cs_next = lastcs->cs_next;
              lastcs->cs_next = cs;
         }
    }

    /*
     * Make sure that only what we expect to change changed. The first
     * line of the `if' checks the IP protocol version, header length &
     * type of service.  The 2nd line checks the "Don't fragment" bit.
     * The 3rd line checks the time-to-live and protocol (the protocol
     * check is unnecessary but costless).  The 4th line checks the TCP
     * header length.  The 5th line checks IP options, if any.  The 6th
     * line checks TCP options, if any.  If any of these things are
     * different between the previous & current datagram, we send the
     * current datagram `uncompressed'.
     */
    oth = (struct tcphdr UNALIGNED *) & ((ULONG UNALIGNED *) csip)[hlen];
    deltaS = hlen;
    hlen += (th->th_off >> 4);
    hlen <<= 2;

    //
    // Bug fix?  It's in cslip.tar.Z
    //
    if (hlen > *m_len) {
        NdisWanDbgOut(DBG_FAILURE, DBG_VJ,("Bad TCP packet length"));
        return(TYPE_IP);
    }

    if (((USHORT UNALIGNED *) ip)[0] != ((USHORT UNALIGNED *) csip)[0] ||
        ((USHORT UNALIGNED *) ip)[3] != ((USHORT UNALIGNED *) csip)[3] ||
        ((USHORT UNALIGNED *) ip)[4] != ((USHORT UNALIGNED *) csip)[4] ||
        (th->th_off >> 4) != (oth->th_off >> 4) ||
        (deltaS > 5 &&
         memcmp((UCHAR UNALIGNED *)(ip + 1), (UCHAR UNALIGNED *)(csip + 1), (deltaS - 5) << 2)) ||
        ((th->th_off >> 4) > 5 &&
         memcmp((UCHAR UNALIGNED *)(th + 1), (UCHAR UNALIGNED *)(oth + 1), ((th->th_off >> 4) - 5) << 2))) {

        goto uncompressed;
    }

    /*
     * Figure out which of the changing fields changed.  The receiver
     * expects changes in the order: urgent, window, ack, seq.
     */
    if (th->th_flags & TH_URG) {
         deltaS = ntohs(th->th_urp);
         ENCODEZ(deltaS);
         changes |= NEW_U;
    } else if (th->th_urp != oth->th_urp) {
    
         /*
          * argh! URG not set but urp changed -- a sensible
          * implementation should never do this but RFC793 doesn't
          * prohibit the change so we have to deal with it.
          */
         goto uncompressed;
    }

    if (deltaS = (USHORT) (ntohs(th->th_win) - ntohs(oth->th_win))) {
         ENCODE(deltaS);
         changes |= NEW_W;
    }
    if (deltaA = ntohl(th->th_ack) - ntohl(oth->th_ack)) {
        if (deltaA > 0xffff) {
            goto uncompressed;
        }

         ENCODE(deltaA);
         changes |= NEW_A;
    }
    if (deltaS = ntohl(th->th_seq) - ntohl(oth->th_seq)) {
        if (deltaS > 0xffff) {
            goto uncompressed;
        }

         ENCODE(deltaS);
         changes |= NEW_S;
    }

    ip_len = ntohs(csip->ip_len);

    /*
     * Look for the special-case encodings.
     */
    switch (changes) {

    case 0:
         /*
          * Nothing changed. If this packet contains data and the last
          * one didn't, this is probably a data packet following an
          * ack (normal on an interactive connection) and we send it
          * compressed.  Otherwise it's probably a retransmit,
          * retransmitted ack or window probe.  Send it uncompressed
          * in case the other side missed the compressed version.
          */
         if (ip->ip_len != csip->ip_len &&
             ip_len == hlen)

              break;

         /* (fall through) */

    case SPECIAL_I:
    case SPECIAL_D:
         /*
          * Actual changes match one of our special case encodings --
          * send packet uncompressed.
          */
         goto uncompressed;

    case NEW_S | NEW_A:
         if (deltaS == deltaA &&
             deltaS == (ip_len - hlen)) {
              /* special case for echoed terminal traffic */
              changes = SPECIAL_I;
              cp = new_seq;
         }
         break;

    case NEW_S:
         if (deltaS == (ip_len - hlen)) {
              /* special case for data xfer */
              changes = SPECIAL_D;
              cp = new_seq;
         }
         break;
    }

    deltaS = ntohs(ip->ip_id) - ntohs(csip->ip_id);

    if (deltaS != 1) {
         ENCODEZ(deltaS);
         changes |= NEW_I;
    }

    if (th->th_flags & TH_PUSH)
         changes |= TCP_PUSH_BIT;
    /*
     * Grab the cksum before we overwrite it below.  Then update our
     * state with this packet's header.
     */
    deltaA = (th->th_sumhi << 8) + th->th_sumlo;

    NdisMoveMemory((UCHAR UNALIGNED *)csip,
                   (UCHAR UNALIGNED *)ip,
                   hlen);

    /*
     * We want to use the original packet as our compressed packet. (cp -
     * new_seq) is the number of bytes we need for compressed sequence
     * numbers.  In addition we need one byte for the change mask, one
     * for the connection id and two for the tcp checksum. So, (cp -
     * new_seq) + 4 bytes of header are needed.  hlen is how many bytes
     * of the original packet to toss so subtract the two to get the new
     * packet size.
     */
    deltaS = (ULONG)(cp - new_seq);
    cp = (UCHAR UNALIGNED *) ip;
    *precomph_len = hlen;

    if (compress_cid == 0 || comp->last_xmit != cs->cs_id) {
         comp->last_xmit = cs->cs_id;
         hlen -= deltaS + 4;
         *postcomph_len = deltaS + 4;
         cp += hlen;
         *cp++ = (UCHAR)(changes | NEW_C);
         *cp++ = cs->cs_id;
    } else {
         hlen -= deltaS + 3;
         *postcomph_len = deltaS + 3;
         cp += hlen;
         *cp++ = (UCHAR)changes;
    }

    *m_len -= hlen;
    *m_off += hlen;
    *cp++ = (UCHAR)(deltaA >> 8);
    *cp++ = (UCHAR)(deltaA);

    NdisMoveMemory((UCHAR UNALIGNED *)cp,
                   (UCHAR UNALIGNED *)new_seq,
                   deltaS);

    INCR(OutCompressed);
    return (TYPE_COMPRESSED_TCP);

uncompressed:
    /*
     * Update connection state cs & send uncompressed packet
     * ('uncompressed' means a regular ip/tcp packet but with the
     * 'conversation id' we hope to use on future compressed packets in
     * the protocol field).
     */

    NdisMoveMemory((UCHAR UNALIGNED *)csip,
                   (UCHAR UNALIGNED *)ip,
                   hlen);

    ip->ip_p = cs->cs_id;
    comp->last_xmit = cs->cs_id;
    return (TYPE_UNCOMPRESSED_TCP);
}





//   A.3  Decompression
//
//   This routine decompresses a received packet.  It is called with a
//   pointer to the packet, the packet length and type, and a pointer to the
//   compression state structure for the incoming serial line.  It returns a
//   pointer to the resulting packet or zero if there were errors in the
//   incoming packet.  If the packet is COMPRESSED_TCP or UNCOMPRESSED_TCP,
//   the compression state will be updated.
//
//   The new packet will be constructed in-place.  That means that there must
//   be 128 bytes of free space in front of bufp to allow room for the
//   reconstructed IP and TCP headers.  The reconstructed packet will be
//   aligned on a 32-bit boundary.
//

//LONG
//sl_uncompress_tcp(
//    PUUCHAR UNALIGNED  *bufp,
//    LONG len,
//    UCHAR type,
//    struct slcompress  *comp) {
LONG
sl_uncompress_tcp(
    PUUCHAR UNALIGNED *InBuffer,
    PLONG   InLength,
    UCHAR   UNALIGNED *OutBuffer,
    PLONG   OutLength,
    UCHAR   type,
    struct slcompress *comp
    )
{
    UCHAR UNALIGNED *cp;
    LONG inlen;
    LONG hlen, changes;
    struct tcphdr UNALIGNED *th;
    struct cstate *cs;
    struct ip_v4 UNALIGNED *ip;

    inlen = *InLength;

    switch (type) {

    case TYPE_ERROR:
    default:
        NdisWanDbgOut(DBG_FAILURE, DBG_VJ, ("Packet transmission error type 0x%.2x",type));
         goto bad;

    case TYPE_IP:
         break;

    case TYPE_UNCOMPRESSED_TCP:
         /*
          * Locate the saved state for this connection.  If the state
          * index is legal, clear the 'discard' flag.
          */
         ip = (struct ip_v4 UNALIGNED *) *InBuffer;
         if (ip->ip_p >= comp->MaxStates) {
            NdisWanDbgOut(DBG_FAILURE, DBG_VJ, ("Max state exceeded %u", ip->ip_p));
            goto bad;
         }

         cs = &comp->rstate[comp->last_recv = ip->ip_p];
         comp->flags &= ~SLF_TOSS;

         /*
          * Restore the IP protocol field then save a copy of this
          * packet header.  (The checksum is zeroed in the copy so we
          * don't have to zero it each time we process a compressed
          * packet.
          */
         hlen = ip->ip_hl & 0x0F;
         hlen += ((struct tcphdr UNALIGNED *) & ((ULONG UNALIGNED *) ip)[hlen])->th_off >> 4;
         hlen <<= 2;

         if (hlen > inlen) {
             NdisWanDbgOut(DBG_FAILURE, DBG_VJ, ("recv'd runt uncompressed packet %d %d", hlen, inlen));
             goto bad;
         }

         NdisMoveMemory((PUCHAR)&cs->cs_ip,
                        (PUCHAR)ip,
                        hlen);

         cs->cs_ip.ip_p = IPPROTO_TCP;

         NdisMoveMemory((PUCHAR)OutBuffer,
                        (PUCHAR)&cs->cs_ip,
                        hlen);

         cs->cs_ip.ip_sum = 0;
         cs->cs_hlen = (USHORT)hlen;

         *InBuffer = (PUCHAR)ip + hlen;
         *InLength = inlen - hlen;
         *OutLength = hlen;

         INCR(InUncompressed);
         return (inlen);

    case TYPE_COMPRESSED_TCP:
         break;
    }

    /* We've got a compressed packet. */
    INCR(InCompressed);
    cp = *InBuffer;
    changes = *cp++;

    if (changes & NEW_C) {
         /*
          * Make sure the state index is in range, then grab the
          * state. If we have a good state index, clear the 'discard'
          * flag.
          */
         if (*cp >= comp->MaxStates) {
            NdisWanDbgOut(DBG_FAILURE, DBG_VJ, ("MaxState of %u too big", *cp));                
            goto bad;
         }

         comp->flags &= ~SLF_TOSS;
         comp->last_recv = *cp++;
    } else {
         /*
          * This packet has an implicit state index.  If we've had a
          * line error since the last time we got an explicit state
          * index, we have to toss the packet.
          */
         if (comp->flags & SLF_TOSS) {
            NdisWanDbgOut(DBG_FAILURE, DBG_VJ,("Packet has state index, have to toss it"));
            INCR(InTossed);
            return (0);
        }
    }

    /*
     * Find the state then fill in the TCP checksum and PUSH bit.
     */

    cs = &comp->rstate[comp->last_recv];

    //
    // If there was a line error and we did not get notified we could
    // miss a TYPE_UNCOMPRESSED_TCP which would leave us with an
    // un-init'd cs!
    //
    if (cs->cs_hlen == 0) {
        NdisWanDbgOut(DBG_FAILURE, DBG_VJ,("Un-Init'd state!"));
        goto bad;
    }

    hlen = (cs->cs_ip.ip_hl & 0x0F) << 2;
    th = (struct tcphdr UNALIGNED  *) & ((UCHAR UNALIGNED  *) &cs->cs_ip)[hlen];

    th->th_sumhi = cp[0];
    th->th_sumlo = cp[1];

    cp += 2;
    if (changes & TCP_PUSH_BIT)
         th->th_flags |= TH_PUSH;
    else
         th->th_flags &= ~TH_PUSH;

    /*
     * Fix up the state's ack, seq, urg and win fields based on the
     * changemask.
     */
    switch (changes & SPECIALS_MASK) {
    case SPECIAL_I:
         {
            UCHAR UNALIGNED *   piplen=(UCHAR UNALIGNED *)&(cs->cs_ip.ip_len);
            UCHAR UNALIGNED *   ptcplen;
            ULONG   tcplen;
            ULONG   i;

            i = ((piplen[0] << 8) + piplen[1]) - cs->cs_hlen;

//          th->th_ack = htonl(ntohl(th->th_ack) + i);

            ptcplen=(UCHAR UNALIGNED *)&(th->th_ack);
            tcplen=(ptcplen[0] << 24) + (ptcplen[1] << 16) +
                    (ptcplen[2] << 8) + ptcplen[3] + i;
            ptcplen[3]=(UCHAR)(tcplen);
            ptcplen[2]=(UCHAR)(tcplen >> 8);
            ptcplen[1]=(UCHAR)(tcplen >> 16);
            ptcplen[0]=(UCHAR)(tcplen >> 24);


//          th->th_seq = htonl(ntohl(th->th_seq) + i);

            ptcplen=(UCHAR UNALIGNED *)&(th->th_seq);
            tcplen=(ptcplen[0] << 24) + (ptcplen[1] << 16) +
                    (ptcplen[2] << 8) + ptcplen[3] + i;
            ptcplen[3]=(UCHAR)(tcplen);
            ptcplen[2]=(UCHAR)(tcplen >> 8);
            ptcplen[1]=(UCHAR)(tcplen >> 16);
            ptcplen[0]=(UCHAR)(tcplen >> 24);

         }
         break;

    case SPECIAL_D:
         {
//          th->th_seq = htonl(ntohl(th->th_seq) + ntohs(cs->cs_ip.ip_len)
//                      - cs->cs_hlen);

            UCHAR   UNALIGNED *piplen=(UCHAR UNALIGNED *)&(cs->cs_ip.ip_len);
            UCHAR   UNALIGNED *ptcplen;
            ULONG   tcplen;
            ULONG   i;

            i = ((piplen[0] << 8) + piplen[1]) - cs->cs_hlen;

            ptcplen=(UCHAR UNALIGNED *)&(th->th_seq);
            tcplen=(ptcplen[0] << 24) + (ptcplen[1] << 16) +
                    (ptcplen[2] << 8) + ptcplen[3] + i;

            ptcplen[3]=(UCHAR)(tcplen);
            ptcplen[2]=(UCHAR)(tcplen >> 8);
            ptcplen[1]=(UCHAR)(tcplen >> 16);
            ptcplen[0]=(UCHAR)(tcplen >> 24);


         }

         break;

    default:
         if (changes & NEW_U) {
              th->th_flags |= TH_URG;
              DECODEU(th->th_urp)
         } else
              th->th_flags &= ~TH_URG;

         if (changes & NEW_W)
            DECODES(th->th_win);
         if (changes & NEW_A)
            DECODEL(th->th_ack)
         if (changes & NEW_S)
            DECODEL(th->th_seq)

         break;
    }
    /* Update the IP ID */
    if (changes & NEW_I) {
    
         DECODES(cs->cs_ip.ip_id)

    } else {

        USHORT id;
        UCHAR UNALIGNED *pid = (UCHAR UNALIGNED *)&(cs->cs_ip.ip_id);

//        cs->cs_ip.ip_id = htons(ntohs(cs->cs_ip.ip_id) + 1);
        id=(pid[0] << 8) + pid[1] + 1;
        pid[0]=(UCHAR)(id >> 8);
        pid[1]=(UCHAR)(id);
    }


    /*
     * At this point, cp points to the first byte of data in the packet.
     * If we're not aligned on a 4-byte boundary, copy the data down so
     * the IP & TCP headers will be aligned.  Then back up cp by the
     * TCP/IP header length to make room for the reconstructed header (we
     * assume the packet we were handed has enough space to prepend 128
     * bytes of header).  Adjust the lenth to account for the new header
     * & fill in the IP total length.
     */
//    len -= (cp - *bufp);
    inlen -= (ULONG)(cp - *InBuffer);

    if (inlen < 0) {
    
         /*
          * we must have dropped some characters (crc should detect
          * this but the old slip framing won't)
          */
        NdisWanDbgOut(DBG_FAILURE, DBG_VJ,("len has dropped below 0!"));
         goto bad;
    }
//
//  Who Cares about 4 byte alignement!  It's just a useless big copy!
//
//    if ((ULONG) cp & 3) {
//         if (len > 0)
//          //
//          // BUG BUG we want OVBCOPY..
//          //
//            NdisMoveMemory(
//              (PUCHAR)((ULONG) cp & ~3),
//              cp,
//              len);
//         cp = (PUCHAR) ((ULONG) cp & ~3);
//    }

//    cp -= cs->cs_hlen;
//    len += cs->cs_hlen;

//    cs->cs_ip.ip_len = htons(len);
    cs->cs_ip.ip_len = htons(inlen + cs->cs_hlen);

//  NdisMoveMemory(
//      (PUCHAR)cp,
//      (PUCHAR)&cs->cs_ip,
//      cs->cs_hlen);

  NdisMoveMemory((PUCHAR)OutBuffer,
                 (PUCHAR)&cs->cs_ip,
                 cs->cs_hlen);

//  *bufp = cp;
    *InBuffer = cp;
    *InLength = inlen;
    *OutLength = cs->cs_hlen;

    /* recompute the ip header checksum */
    {
//         USHORT UNALIGNED * bp = (USHORT UNALIGNED *) cp;
         USHORT UNALIGNED * bp = (USHORT UNALIGNED *) OutBuffer;

         for (changes = 0; hlen > 0; hlen -= 2)
              changes += *bp++;

         changes = (changes & 0xffff) + (changes >> 16);
         changes = (changes & 0xffff) + (changes >> 16);
//         ((struct ip_v4 UNALIGNED *) cp)->ip_sum = (USHORT)~changes;
         ((struct ip_v4 UNALIGNED *) OutBuffer)->ip_sum = (USHORT)~changes;
    }

    return (inlen + cs->cs_hlen);

bad:
    comp->flags |= SLF_TOSS;
    INCR(InErrors);
    return (0);
}




//   A.4  Initialization
//
//   This routine initializes the state structure for both the transmit and
//   receive halves of some serial line.  It must be called each time the
//   line is brought up.
//

VOID
WanInitVJ(
    VOID
)
{
#if 0
    NdisInitializeNPagedLookasideList(&VJCtxList,
                                      NULL,
                                      NULL,
                                      0,
                                      sizeof(slcompress),
                                      VJCTX_TAG,
                                      0);
#endif
}

VOID
WanDeleteVJ(
    VOID
    )
{
#if 0
    NdisDeleteNPagedLookasideList(&VJCtxList);
#endif
}

NDIS_STATUS
sl_compress_init(
    struct slcompress **retcomp,
    UCHAR  MaxStates
    )
{
    ULONG i;
    struct cstate *tstate; // = comp->tstate;
    struct slcompress *comp;

    comp = *retcomp;

    //
    // Do we need to allocate memory for this bundle
    //

    if (comp == NULL) {

        NdisWanAllocateMemory(&comp, sizeof(slcompress), VJCOMPRESS_TAG);

        //
        // If there was no memory to allocate
        //
        if (comp == NULL) {
    
            return(NDIS_STATUS_RESOURCES);
        }
    }

    tstate = comp->tstate;

    /*
     * Clean out any junk left from the last time line was used.
     */
    NdisZeroMemory(
        (PUCHAR) comp,
        sizeof(*comp));

    /*
     * Link the transmit states into a circular list.
     */
    for (i = MaxStates - 1; i > 0; --i) {
        tstate[i].cs_id = (UCHAR)i;
        tstate[i].cs_next = &tstate[i - 1];
    }

    tstate[0].cs_next = &tstate[MaxStates - 1];
    tstate[0].cs_id = 0;
    comp->last_cs = &tstate[0];

    /*
     * Make sure we don't accidentally do CID compression
     * (assumes MAX_VJ_STATES < 255).
     */
    comp->last_recv = 255;
    comp->last_xmit = 255;
    comp->flags = SLF_TOSS;
    comp->MaxStates=MaxStates;

    *retcomp = comp;

    return (NDIS_STATUS_SUCCESS);
}

VOID
sl_compress_terminate(
    struct slcompress **comp
    )
{
    if (*comp != NULL) {
        NdisWanFreeMemory(*comp);
        *comp = NULL;
    }
}

//   A.5  Berkeley Unix dependencies
//
//   Note:  The following is of interest only if you are trying to bring the
//   sample code up on a system that is not derived from 4BSD (Berkeley
//   Unix).
//
//   The code uses the normal Berkeley Unix header files (from
//   /usr/include/netinet) for definitions of the structure of IP and TCP
//   headers.  The structure tags tend to follow the protocol RFCs closely
//   and should be obvious even if you do not have access to a 4BSD
//   system./48/
//
//   ----------------------------
//    48. In the event they are not obvious, the header files (and all the
//   Berkeley networking code) can be anonymous ftp'd from host
//
//
//   The macro BCOPY(src, dst, amt) is invoked to copy amt bytes from src to
//   dst.  In BSD, it translates into a call to BCOPY.  If you have the
//   misfortune to be running System-V Unix, it can be translated into a call
//   to memcpy.  The macro OVBCOPY(src, dst, amt) is used to copy when src
//   and dst overlap (i.e., when doing the 4-byte alignment copy).  In the
//   BSD kernel, it translates into a call to ovbcopy.  Since AT&T botched
//   the definition of memcpy, this should probably translate into a copy
//   loop under System-V.
//
//   The macro BCMP(src, dst, amt) is invoked to compare amt bytes of src and
//   dst for equality.  In BSD, it translates into a call to bcmp.  In
//   System-V, it can be translated into a call to memcmp or you can write a
//   routine to do the compare.  The routine should return zero if all bytes
//   of src and dst are equal and non-zero otherwise.
//
//   The routine ntohl(dat) converts (4 byte) long dat from network byte
//   order to host byte order.  On a reasonable cpu this can be the no-op
//   macro:
//                           #define ntohl(dat) (dat)
//
//   On a Vax or IBM PC (or anything with Intel byte order), you will have to
//   define a macro or routine to rearrange bytes.
//
//   The routine ntohs(dat) is like ntohl but converts (2 byte) shorts
//   instead of longs.  The routines htonl(dat) and htons(dat) do the inverse
//   transform (host to network byte order) for longs and shorts.
//
//   A struct mbuf is used in the call to sl_compress_tcp because that
//   routine needs to modify both the start address and length if the
//   incoming packet is compressed.  In BSD, an mbuf is the kernel's buffer
//   management structure.  If other systems, the following definition should
//   be sufficient:
//
//            struct mbuf {
//                    UCHAR  *m_off; /* pointer to start of data */
//                    int     m_len;  /* length of data */
//            };
//
//            #define mtod(m, t) ((t)(m->m_off))
//
//
//   B  Compatibility with past mistakes
//
//
//   When combined with the modern PPP serial line protocol[9], the use of
//   header compression is automatic and invisible to the user.
//   Unfortunately, many sites have existing users of the SLIP described in
//   [12] which doesn't allow for different protocol types to distinguish
//   header compressed packets from IP packets or for version numbers or an
//   option exchange that could be used to automatically negotiate header
//   compression.
//
//   The author has used the following tricks to allow header compressed SLIP
//   to interoperate with the existing servers and clients.  Note that these
//   are hacks for compatibility with past mistakes and should be offensive
//   to any right thinking person.  They are offered solely to ease the pain
//   of running SLIP while users wait patiently for vendors to release PPP.
//
//
//   B.1  Living without a framing `type' byte
//
//   The bizarre packet type numbers in sec. A.1 were chosen to allow a
//   `packet type' to be sent on lines where it is undesirable or impossible
//   to add an explicit type byte.  Note that the first byte of an IP packet
//   always contains `4' (the IP protocol version) in the top four bits.  And
//   that the most significant bit of the first byte of the compressed header
//   is ignored.  Using the packet types in sec. A.1, the type can be encoded
//   in the most significant bits of the outgoing packet using the code
//
//                    p->dat[0] |= sl_compress_tcp(p, comp);
//
//    and decoded on the receive side by
//
//                  if (p->dat[0] & 0x80)
//                          type = TYPE_COMPRESSED_TCP;
//                  else if (p->dat[0] >= 0x70) {
//                          type = TYPE_UNCOMPRESSED_TCP;
//                          p->dat[0] &=~ 0x30;
//                  } else
//                          type = TYPE_IP;
//                  status = sl_uncompress_tcp(p, type, comp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\wan.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Wan.h

Abstract:

    This file contains all include files for the NdisWan driver.



Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <xfilter.h>
#include <ntddk.h>
#include <ndisprv.h>

#include "wandefs.h"
#include "debug.h"
#include "wanpub.h"
#include "transdrv.h"
#include "wantypes.h"
#include "adapter.h"
#include "global.h"
#include "wanproto.h"

#include <rc4.h>
#include "compress.h"
#include "tcpip.h"
#include "vjslip.h"

#include "isnipx.h"
#include "nbfconst.h"
#include "nbfhdrs.h"

//
// The contents of the following header files
// need to be added to appropriate header files
//
//#include "ndisadd.h"        // ndis.h
#include "transdrv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\vjslip.h ===
#ifndef _VJSLIP_
#define _VJSLIP_

/*
 * Copyright (c) 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are
 * permitted provided that the above copyright notice and this
 * paragraph are duplicated in all such forms and that any
 * documentation, advertising materials, and other materials
 * related to such distribution and use acknowledge that the
 * software was developed by the University of California,
 * Berkeley.  The name of the University may not be used to
 * endorse or promote products derived from this software
 * without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
 * IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE.
 */


// A.1  Definitions and State Data

#define MAX_VJ_STATES 16   /* must be >2 and <255 */
#define MAX_HDR 128     /* max TCP+IP hdr length (by protocol def) */


//
// NT is little endian, so we follow these rules
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define ntohs(x) _byteswap_ushort((USHORT)(x))
#define ntohl(x) _byteswap_ulong((ULONG)(x))
#else
#define ntohs(x) (USHORT)( ((x) >> 8) + (((x) & 0xFF)  << 8) )

#define ntohl(x) (ULONG) ( ((x) >> 24) + (((x) & 0xFF0000) >> 8) +\
                 (((x) & 0xFF00) << 8) + (((x) & 0xFF) << 24) )
#endif

#define htons(x) ntohs(x)
#define htonl(x) ntohl(x)


/* packet types */
#define TYPE_IP                 0x40
#define TYPE_UNCOMPRESSED_TCP   0x70
#define TYPE_COMPRESSED_TCP     0x80
#define TYPE_ERROR              0x00
                     /* this is not a type that ever appears on
                      * the wire.  The receive framer uses it to
                      * tell the decompressor there was a packet
                      * transmission error. */
/*
 * Bits in first octet of compressed packet
 */

/* flag bits for what changed in a packet */

#define NEW_C  0x40
#define NEW_I  0x20
#define TCP_PUSH_BIT 0x10

#define NEW_S  0x08
#define NEW_A  0x04
#define NEW_W  0x02
#define NEW_U  0x01


/* reserved, special-case values of above */
#define SPECIAL_I (NEW_S|NEW_W|NEW_U)        /* echoed interactive traffic */
#define SPECIAL_D (NEW_S|NEW_A|NEW_W|NEW_U)  /* unidirectional data */
#define SPECIALS_MASK (NEW_S|NEW_A|NEW_W|NEW_U)


/*
 * "state" data for each active tcp conversation on the wire.  This is
 * basically a copy of the entire IP/TCP header from the last packet together
 * with a small identifier the transmit & receive ends of the line use to
 * locate saved header.
 */

struct cstate {
     struct cstate *cs_next;  /* next most recently used cstate (xmit only) */
     USHORT cs_hlen;         /* size of hdr (receive only) */
     UCHAR cs_id;            /* connection # associated with this state */
     UCHAR cs_filler;
     union {
          UCHAR hdr[MAX_HDR];
          struct ip_v4 csu_ip;   /* ip/tcp hdr from most recent packet */
     } slcs_u;
};

#define cs_ip slcs_u.csu_ip

#define cs_hdr slcs_u.csu_hdr

/*
 * all the state data for one serial line (we need one of these per line).
 */
typedef struct slcompress slcompress;

struct slcompress {
     struct cstate *last_cs;           /* most recently used tstate */
     UCHAR last_recv;                  /* last rcvd conn. id */
     UCHAR last_xmit;                  /* last sent conn. id */
     USHORT flags;
     UCHAR  MaxStates;
//
// Some Statistics
//
     ULONG  OutPackets;
     ULONG  OutCompressed;
     ULONG  OutSearches;
     ULONG  OutMisses;
     ULONG  InUncompressed;
     ULONG  InCompressed;
     ULONG  InErrors;
     ULONG  InTossed;

     struct cstate tstate[MAX_VJ_STATES];  /* xmit connection states */
     struct cstate rstate[MAX_VJ_STATES];  /* receive connection states */
};

struct mbuf {
    PUCHAR  m_off;          // pointer to start of data
    UINT    m_len;          // length of data
};

#define mtod(m,t)  ((t)(m->m_off))

/* flag values */
#define SLF_TOSS    1       /* tossing rcvd frames because of input err */

/*
 * The following macros are used to encode and decode numbers.  They all
 * assume that `cp' points to a buffer where the next byte encoded (decoded)
 * is to be stored (retrieved).  Since the decode routines do arithmetic,
 * they have to convert from and to network byte order.
 */

/*
 * ENCODE encodes a number that is known to be non-zero.  ENCODEZ checks for
 * zero (zero has to be encoded in the long, 3 byte form).
 */
#define ENCODE(n) { \
     if ((USHORT)(n) >= 256) { \
          *cp++ = 0; \
          cp[1] = (UCHAR)(n); \
          cp[0] = (UCHAR)((n) >> 8); \
          cp += 2; \
     } else { \
          *cp++ = (UCHAR)(n); \
     } \
}

#define ENCODEZ(n) { \
     if ((USHORT)(n) >= 256 || (USHORT)(n) == 0) { \
          *cp++ = 0; \
          cp[1] = (UCHAR)(n); \
          cp[0] = (UCHAR)((n) >> 8); \
          cp += 2; \
     } else { \
          *cp++ = (UCHAR)(n); \
     } \
}

/*
 * DECODEL takes the (compressed) change at byte cp and adds it to the
 * current value of packet field 'f' (which must be a 4-byte (long) integer
 * in network byte order).  DECODES does the same for a 2-byte (short) field.
 * DECODEU takes the change at cp and stuffs it into the (short) field f.
 * 'cp' is updated to point to the next field in the compressed header.
 */

#define DECODEL(f) { \
     ULONG _x_ = ntohl(f); \
     if (*cp == 0) {\
          _x_ += ((cp[1] << 8) + cp[2]); \
          (f) = htonl(_x_); \
          cp += 3; \
     } else { \
          _x_ += *cp; \
          (f) = htonl(_x_); \
          cp++; \
     } \
}

#define DECODES(f) { \
     USHORT _x_= ntohs(f); \
     if (*cp == 0) {\
          _x_ += ((cp[1] << 8) + cp[2]); \
          (f) = htons(_x_); \
          cp += 3; \
     } else { \
          _x_ += *cp; \
          (f) = htons(_x_); \
          cp++; \
     } \
}

#define DECODEU(f) { \
     USHORT _x_; \
     if (*cp == 0) {\
          _x_=(cp[1] << 8) + cp[2]; \
          (f) = htons(_x_); \
          cp += 3; \
     } else { \
          _x_=*cp; \
          (f) = htons(_x_); \
          cp++; \
     } \
}

typedef UCHAR UNALIGNED * PUUCHAR;


UCHAR
sl_compress_tcp(
    PUUCHAR UNALIGNED *m_off,       // Frame start (points to IP header)
    PULONG m_len,                   // Length of entire frame
    PULONG precomph_len,            // Length of tcp/ip header pre-comp
    PULONG postcomph_len,           // Length of tcp/ip header post-comp
    struct slcompress *comp,        // Compression struct for this link
    ULONG compress_cid);            // Compress connection id boolean

//LONG
//sl_uncompress_tcp(
//    PUUCHAR UNALIGNED *bufp,
//    LONG len,
//    UCHAR type,
//    struct slcompress *comp);
LONG
sl_uncompress_tcp(
    PUUCHAR UNALIGNED *InBuffer,
    PLONG   InLength,
    UCHAR   UNALIGNED *OutBuffer,
    PLONG   OutLength,
    UCHAR   type,
    struct slcompress *comp
    );

NDIS_STATUS
sl_compress_init(
    struct slcompress **comp,
    UCHAR MaxStates);

VOID
sl_compress_terminate(
    struct slcompress **comp
    );

#endif // _VJSLIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\wanadd.h ===
//
// NDIS WAN Information structures used
// by NDIS 5.0 Miniport drivers
//

//
// Defines for the individual fields are the
// same as for NDIS 3.x/4.x Wan miniports.
//
// See the DDK.
//

//
// Information that applies to all VC's on
// this adapter.
//
// OID: OID_WAN_CO_GET_INFO
//
typedef struct _NDIS_WAN_CO_INFO {
	OUT ULONG			MaxFrameSize;
	OUT	ULONG			MaxSendWindow;
	OUT ULONG			FramingBits;
	OUT ULONG			DesiredACCM;
} NDIS_WAN_CO_INFO, *PNDIS_WAN_CO_INFO;

//
// Set VC specific PPP framing information.
//
// OID: OID_WAN_CO_SET_LINK_INFO
//
typedef struct _NDIS_WAN_CO_SET_LINK_INFO {
	IN	ULONG			MaxSendFrameSize;
	IN	ULONG			MaxRecvFrameSize;
	IN	ULONG			SendFramingBits;
	IN	ULONG			RecvFramingBits;
	IN	ULONG			SendCompressionBits;
	IN	ULONG			RecvCompressionBits;
	IN	ULONG			SendACCM;
	IN	ULONG			RecvACCM;
} NDIS_WAN_CO_SET_LINK_INFO, *PNDIS_WAN_CO_SET_LINK_INFO;

//
// Get VC specific PPP framing information.
//
// OID: OID_WAN_CO_GET_LINK_INFO
//
typedef struct _NDIS_WAN_CO_GET_LINK_INFO {
	OUT ULONG			MaxSendFrameSize;
	OUT ULONG			MaxRecvFrameSize;
	OUT ULONG			SendFramingBits;
	OUT ULONG			RecvFramingBits;
	OUT ULONG			SendCompressionBits;
	OUT ULONG			RecvCompressionBits;
	OUT ULONG			SendACCM;
	OUT ULONG			RecvACCM;
} NDIS_WAN_CO_GET_LINK_INFO, *PNDIS_WAN_CO_GET_LINK_INFO;

//
// Get VC specific PPP compression information
//
// OID: OID_WAN_CO_GET_COMP_INFO
//
typedef struct _NDIS_WAN_CO_GET_COMP_INFO {
	OUT NDIS_WAN_COMPRESS_INFO	SendCapabilities;
	OUT NDIS_WAN_COMPRESS_INFO	RecvCapabilities;
} NDIS_WAN_CO_GET_COMP_INFO, *PNDIS_WAN_CO_GET_COMP_INFO;


//
// Set VC specific PPP compression information
//
// OID: OID_WAN_CO_SET_COMP_INFO
//
typedef struct _NDIS_WAN_CO_SET_COMP_INFO {
	IN	NDIS_WAN_COMPRESS_INFO	SendCapabilities;
	IN	NDIS_WAN_COMPRESS_INFO	RecvCapabilities;
} NDIS_WAN_CO_SET_COMP_INFO, *PNDIS_WAN_CO_SET_COMP_INFO;


//
// Get VC specific statistics
//
// OID: OID_WAN_CO_GET_STATS_INFO
//
typedef struct _NDIS_WAN_CO_GET_STATS_INFO {
	OUT ULONG		BytesSent;
	OUT ULONG		BytesRcvd;
	OUT ULONG		FramesSent;
	OUT ULONG		FramesRcvd;
	OUT ULONG		CRCErrors;						// Serial-like info only
	OUT ULONG		TimeoutErrors;					// Serial-like info only
	OUT ULONG		AlignmentErrors;				// Serial-like info only
	OUT ULONG		SerialOverrunErrors;			// Serial-like info only
	OUT ULONG		FramingErrors;					// Serial-like info only
	OUT ULONG		BufferOverrunErrors;			// Serial-like info only
	OUT ULONG		BytesTransmittedUncompressed;	// Compression info only
	OUT ULONG		BytesReceivedUncompressed;		// Compression info only
	OUT ULONG		BytesTransmittedCompressed;	 	// Compression info only
	OUT ULONG		BytesReceivedCompressed;		// Compression info only
} NDIS_WAN_CO_GET_STATS_INFO, *PNDIS_WAN_CO_GET_STATS_INFO;

//
// Used to notify NdisWan of Errors.  See error
// bit mask in ndiswan.h
//
// NDIS_STATUS:	NDIS_STATUS_WAN_CO_FRAGMENT
//
typedef struct _NDIS_WAN_CO_FRAGMENT {
	IN	ULONG			Errors;
} NDIS_WAN_CO_FRAGMENT, *PNDIS_WAN_CO_FRAGMENT;

//
// Used to notify NdisWan of changes in link speed and
// send window.  Can be given at any time.  NdisWan will honor
// any send window (even zero).  NdisWan will default zero
// TransmitSpeed/ReceiveSpeed settings to 28.8Kbs.
//
// NDIS_STATUS:	NDIS_STATUS_WAN_CO_LINKPARAMS
//
typedef struct _WAN_CO_LINKPARAMS {
	ULONG	TransmitSpeed;				// Transmit speed of the VC in Bps
	ULONG	ReceiveSpeed;				// Receive speed of the VC in Bps
	ULONG	SendWindow;					// Current send window for the VC
} WAN_CO_LINKPARAMS, *PWAN_CO_LINKPARAMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\wandefs.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Wandefs.h

Abstract:

    This file contains defines for the NdisWan driver.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#ifndef _NDISWAN_DEFS_
#define _NDISWAN_DEFS_

//
// This needs to be added into ndis.h
//
#define SAP_TYPE_NDISWAN_PPP            0x00000004

//
// Device class currently used by RAS to query TAPI
// miniports for the connection wrapper ID
//
#define DEVICECLASS_NDISWAN_SAP         L"NDIS"

//
// Define if we are going to pull the miniport name out of
// an ndis wrapper control structure!!!!!! (kinda dirty)
//
#define MINIPORT_NAME           1

//
// Version stuff
//
#define NDISWAN_MAJOR_VERSION   5
#define NDISWAN_MINOR_VERSION   0

//
// Maximum number of protocols we can support
//
#define MAX_PROTOCOLS           32

//
// Identifiers for protocol type being added to the
// protocol lookup table
//
#define PROTOCOL_TYPE           0
#define PPP_TYPE                1

//
// Flags for Send packet properties
//
#define SEND_ON_WIRE            0x00000001
#define SELF_DIRECTED           0x00000002

#define MAC_HEADER_LENGTH       14
#define PROTOCOL_HEADER_LENGTH  128

//
// Maximum length possible for a ppp header
// No addr/ctrl comp (2)
// No proto id comp 
// multilink large sequence #'s (6)
// MPPC/MPPE (6)
// Protocol (2)
//
#define MAX_PPP_HEADER_LENGTH       14

// No addr/ctrl comp (4)
// No proto id comp 
// multilink large sequence #'s (6)
// MPPC/MPPE (6)
// Protocol (2)
//
#define MAX_PPP_LLC_HEADER_LENGTH   16

//
// Known protocol ID's
//
#define PROTOCOL_PRIVATE_IO     0xAB00
#define PROTOCOL_IP             0x0800
#define PROTOCOL_IPX            0x8137
#define PROTOCOL_NBF            0x80D5
#define PROTOCOL_APPLETALK      0x80F3

//
// Returned from protocol table lookup if value is
// not found
//
#define RESERVED_PROTOCOLCB     (IntToPtr(0xFFFFFFFF))

//
// OID Masks
//
#define OID_GEN                 0x00000000
#define OID_CO_GEN              0x00000000
#define OID_802_3               0x01000000
#define OID_WAN                 0x04000000
#define OID_PNP                 0xFD000000
#define OID_QOS                 0xFB000000

#define DEFAULT_MRU             1614
#define DEFAULT_MRRU            1614
#define DEFAULT_TUNNEL_MTU      1400
#define MAX_RECVDESC_COUNT      64

//
// Known PPP protocol ID's
//
#define PPP_PROTOCOL_PRIVATE_IO         0x00AB
#define PPP_PROTOCOL_IP                 0x0021
#define PPP_PROTOCOL_APPLETALK          0x0029
#define PPP_PROTOCOL_UNCOMPRESSED_TCP   0x002F
#define PPP_PROTOCOL_COMPRESSED_TCP     0x002D
#define PPP_PROTOCOL_IPX                0x002B
#define PPP_PROTOCOL_NBF                0x003F
#define PPP_PROTOCOL_COMPRESSION        0x00FD
#define PPP_PROTOCOL_COMP_RESET         0x80FD


//
//
//                                      
#define DEFAULT_MTU                 1500
#define MAX_OUTSTANDING_PACKETS     10
#define ONE_HUNDRED_MILS            1000000
#define ONE_SECOND                  10000000
#define TEN_SECONDS                 100000000
#define MILS_TO_100NANOS            10000
#define SAMPLE_ARRAY_SIZE           10
#define DEFAULT_PACKETQUEUE_DEPTH   128*1024
#define DEFAULT_MIN_FRAG_SIZE       64

//
// Multilink defines
//
#define MULTILINK_BEGIN_FRAME       0x80
#define MULTILINK_END_FRAME         0x40
#define MULTILINK_COMPLETE_FRAME    0xC0
#define MULTILINK_FLAG_MASK         0xC0
#define MULTILINK_HOLE_FLAG         0x01
#define SHORT_SEQ_MASK              0x0FFF
#define TEST_SHORT_SEQ              0x0800
#define LONG_SEQ_MASK               0x0FFFFFF
#define TEST_LONG_SEQ               0x00800000
#define MCML_SHORTCLASS_MASK        0x30
#define MCML_LONGCLASS_MASK         0x3C
#define MAX_MCML                    1


//
// Memory tags
//
#define BUNDLECB_TAG        'AnaW'
#define LINKPROTOCB_TAG     'BnaW'
#define SMALLDATADESC_TAG   'CnaW'
#define MEDIUMDATADESC_TAG  'DnaW'
#define LARGEDATADESC_TAG   'EnaW'
#define WANREQUEST_TAG      'FnaW'
#define LOOPBACKDESC_TAG    'GnaW'
#define VJCOMPRESS_TAG      'HnaW'
#define MINIPORTCB_TAG      'InaW'
#define OPENCB_TAG          'JnaW'
#define IOPACKET_TAG        'KnaW'
#define LINEUPINFO_TAG      'Lnaw'
#define NDISSTRING_TAG      'MnaW'
#define PROTOCOLTABLE_TAG   'NnaW'
#define CONNECTIONTABLE_TAG 'OnaW'
#define POOLDESC_TAG        'PnaW'
#define DATABUFFER_TAG      'QnaW'
#define WANPACKET_TAG       'RnaW'
#define AFSAPVCCB_TAG       'SnaW'
#define TRANSDRV_TAG        'TnaW'
#define BONDALLOC_TAG       'UnaW'
#define ENCRYPTCTX_TAG      'VnaW'
#define COMPCTX_TAG         'XnaW'
#define PROTOCOLCB_TAG      'ZnaW'

#define CACHEDKEY_TAG       'ANaW'

#if DBG
#define DBGPACKET_TAG       'znaW'
#define WANTRCEVENT_TAG     'ynaW'
#endif

#define RECVDESC_SIG        'vceR'
#define SENDESC_SIG         'dneS'
#define CLAFSAP_SIG         '  lC'
#define CMAFSAP_SIG         '  mC'
#define CMVC_SIG            'cVmC'
#define LINKCB_SIG          'kniL'
#define PROTOCB_SIG         'torP'

#define SEQ_EQ(_a, _b)  ((int)((_a) - (_b)) == 0)
#define SEQ_LT(_a, _b, _t)  (!SEQ_EQ(_a, _b) && ((int)((_a) - (_b)) & _t))
#define SEQ_LTE(_a, _b, _t) (SEQ_EQ(_a, _b) || ((int)((_a) - (_b)) & _t))
#define SEQ_GT(_a, _b, _t)  (!SEQ_EQ(_a, _b) && !((int)((_a) - (_b)) & _t))
#define SEQ_GTE(_a, _b, _t) (SEQ_EQ(_a, _b) || !((int)((_a) - (_b)) & _t))


//
// Link State's
//
typedef enum _LinkState {
    LINK_DOWN,
    LINK_GOING_DOWN,
    LINK_UP
} LinkState;

//
// Bundle State's
//
typedef enum _BundleState {
    BUNDLE_DOWN,
    BUNDLE_GOING_DOWN,
    BUNDLE_UP
} BundleState;

//
// Protocol State's
//
typedef enum _ProtocolState {
    PROTOCOL_UNROUTED,
    PROTOCOL_UNROUTING,
    PROTOCOL_ROUTING,
    PROTOCOL_ROUTED
} ProtocolState;

//
// Cm Vc State's
//
typedef enum _CmVcState {
    CMVC_CREATED,
    CMVC_ACTIVE,
    CMVC_CLOSE_DISPATCHED,
    CMVC_CLOSING,
    CMVC_DEACTIVE
} CmVcState;

typedef enum _ClCallState {
    CL_CALL_CLOSED,
    CL_CALL_CLOSE_PENDING,
    CL_CALL_CONNECTED
} ClCallState;

typedef enum _TransDrvState {
    TRANSDRV_OPENING,
    TRANSDRV_REGISTERING,
    TRANSDRV_OPENED,
    TRANSDRV_CLOSED
} TransDrvState;

//
// Wan request types
//
typedef enum _WanRequestType {
    ASYNC,
    SYNC
} WanRequestType;

typedef enum _WanRequestOrigin {
    NDISWAN,
    NDISTAPI
} WanRequestOrigin;

typedef enum _RECV_TYPE {
    RECV_LINK,
    RECV_BUNDLE_PPP,
    RECV_BUNDLE_DATA
} RECV_TYPE;

typedef enum _SEND_TYPE {
    SEND_LINK,
    SEND_BUNDLE_PPP,
    SEND_BUNDLE_DATA
} SEND_TYPE;

typedef enum _BandwidthOnDemandState {
    BonDSignaled,
    BonDIdle,
    BonDMonitor
} BandwithOnDemandState;

#ifdef CHECK_BUNDLE_LOCK
#define AcquireBundleLock(_pbcb)            \
{                                           \
    NdisAcquireSpinLock(&(_pbcb)->Lock);    \
    ASSERT(!(_pbcb)->LockAcquired);         \
    (_pbcb)->LockLine = __LINE__;           \
    (_pbcb)->LockFile = __FILE_SIG__;       \
    (_pbcb)->LockAcquired = TRUE;           \
}

#define ReleaseBundleLock(_pbcb)            \
{                                           \
    (_pbcb)->LockLine = __LINE__;           \
    (_pbcb)->LockAcquired = FALSE;          \
    NdisReleaseSpinLock(&(_pbcb)->Lock);    \
}

#else
#define AcquireBundleLock(_pbcb)            \
    NdisAcquireSpinLock(&(_pbcb)->Lock)
    
#define ReleaseBundleLock(_pbcb)            \
    NdisReleaseSpinLock(&(_pbcb)->Lock)
#endif

#define REF_NDISWANCB()\
    InterlockedIncrement(&NdisWanCB.RefCount)

#define DEREF_NDISWANCB()   \
    NdisWanInterlockedDec(&NdisWanCB.RefCount)

#define REF_BUNDLECB(_pbcb)                                     \
{                                                               \
    (_pbcb)->RefCount++;                                        \
}

//
// Decrement the reference count on the bundle.  If the count
// goes to zero we need to remove the bundle from the connection
// table and free it.
//
#define DEREF_BUNDLECB(_pbcb)                                   \
{                                                               \
    if ((_pbcb) != NULL) {                                      \
        AcquireBundleLock(_pbcb);                               \
        ASSERT((_pbcb)->RefCount > 0);                          \
        if (--(_pbcb)->RefCount == 0) {                         \
            DoDerefBundleCBWork(_pbcb);                         \
        } else {                                                \
            ReleaseBundleLock(_pbcb);                           \
        }                                                       \
    }                                                           \
}

//
// Decrement the reference count on the bundle.  If the count
// goes to zero we need to remove the bundle from the connection
// table and free it.
//
// Called with BundleCB->Lock held but returns with it released!
//
#define DEREF_BUNDLECB_LOCKED(_pbcb)                            \
{                                                               \
    if ((_pbcb) != NULL) {                                      \
        ASSERT((_pbcb)->RefCount > 0);                          \
        if (--(_pbcb)->RefCount == 0) {                         \
            DoDerefBundleCBWork(_pbcb);                         \
        } else {                                                \
            ReleaseBundleLock(_pbcb);                           \
        }                                                       \
    }                                                           \
}

#define REF_LINKCB(_plcb)                                       \
{                                                               \
    ASSERT((_plcb)->RefCount > 0);                              \
    (_plcb)->RefCount++;                                        \
}

//
// Decrement the reference count on the link.  If the count
// goes to zero we need to remove the link from the connection
// table and free it.
//
#define DEREF_LINKCB(_plcb)                                     \
{                                                               \
    if ((_plcb) != NULL) {                                      \
        NdisAcquireSpinLock(&(_plcb)->Lock);                    \
        ASSERT((_plcb)->RefCount > 0);                          \
        if (--(_plcb)->RefCount == 0) {                         \
            DoDerefLinkCBWork(_plcb);                           \
        } else {                                                \
            NdisReleaseSpinLock(&(_plcb)->Lock);                \
        }                                                       \
    }                                                           \
}

//
// Decrement the reference count on the link.  If the count
// goes to zero we need to remove the link from the connection
// table and free it.
//
// Called with LinkCB->Lock held but returns with it released!
//
#define DEREF_LINKCB_LOCKED(_plcb)                              \
{                                                               \
    if ((_plcb) != NULL) {                                      \
        PBUNDLECB   _pbcb = (_plcb)->BundleCB;                  \
        ASSERT((_plcb)->RefCount > 0);                          \
        if (--(_plcb)->RefCount == 0) {                         \
            DoDerefLinkCBWork(_plcb);                           \
        } else {                                                \
            NdisReleaseSpinLock(&(_plcb)->Lock);                \
        }                                                       \
    }                                                           \
}

#define REF_PROTOCOLCB(_ppcb)                                   \
{                                                               \
    ASSERT((_ppcb)->RefCount > 0);                              \
    (_ppcb)->RefCount++;                                        \
}

#define DEREF_PROTOCOLCB(_ppcb)                                 \
{                                                               \
    ASSERT((_ppcb)->RefCount > 0);                              \
    if (--(_ppcb)->RefCount == 0) {                             \
        ASSERT((_ppcb)->OutstandingFrames == 0);                \
        ASSERT((_ppcb)->State == PROTOCOL_UNROUTING);           \
        NdisWanSetSyncEvent(&(_ppcb)->UnrouteEvent);            \
        RemoveProtocolCBFromBundle(ProtocolCB);                 \
    }                                                           \
}

#define REF_OPENCB(_pocb)                                       \
    InterlockedIncrement(&(_pocb)->RefCount)

#define DEREF_OPENCB(_pocb)                                     \
{                                                               \
    if (InterlockedDecrement(&(_pocb)->RefCount) == 0) {        \
        NdisAcquireSpinLock(&(_pocb)->Lock);                    \
        ProtoCloseWanAdapter(_pocb);                            \
    }                                                           \
}

#define REF_MINIPORTCB(_pmcb)                                   \
    InterlockedIncrement(&(_pmcb)->RefCount)

#define DEREF_MINIPORTCB(_pmcb)                                 \
{                                                               \
    if (InterlockedDecrement(&(_pmcb)->RefCount) == 0) {        \
        NdisWanFreeMiniportCB(_pmcb);                           \
    }                                                           \
}

#define REF_CMVCCB(_pvccb)                                      \
    InterlockedIncrement(&(_pvccb)->RefCount)

#define DEREF_CMVCCB(_pvccb)                                    \
{                                                               \
    if (InterlockedDecrement(&(_pvccb)->RefCount) == 0) {       \
        DoDerefCmVcCBWork(_pvccb);                              \
    }                                                           \
}

#define REF_CLAFSAPCB(_pclaf)                                   \
    (_pclaf)->RefCount++;
    
#define DEREF_CLAFSAPCB(_pclaf)                                 \
{                                                               \
    NdisAcquireSpinLock(&((_pclaf)->Lock));                     \
    if (--(_pclaf)->RefCount == 0) {                            \
        DoDerefClAfSapCBWork(_pclaf);                           \
    } else {                                                    \
        NdisReleaseSpinLock(&((_pclaf)->Lock));                 \
    }                                                           \
}
    
#define DEREF_CLAFSAPCB_LOCKED(_pclaf)                          \
{                                                               \
    if (--(_pclaf)->RefCount == 0) {                            \
        DoDerefClAfSapCBWork(_pclaf);                           \
    } else {                                                    \
        NdisReleaseSpinLock(&((_pclaf)->Lock));                 \
    }                                                           \
}

#define BUNDLECB_FROM_LINKCB(_ppbcb, _plcb)                     \
{                                                               \
    *(_ppbcb) = (PBUNDLECB)_plcb->BundleCB;                     \
}

#define BUNDLECB_FROM_BUNDLEH(_ppbcb, _bh)                      \
{                                                               \
    LOCK_STATE  _ls;                                            \
    PBUNDLECB   _bcb = NULL;                                    \
    NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &_ls);      \
    if ((ULONG_PTR)(_bh) <= ConnectionTable->ulArraySize) {     \
        _bcb = *(ConnectionTable->BundleArray + (ULONG_PTR)(_bh));\
    }                                                           \
    if (_bcb != NULL) {                                         \
        NdisDprAcquireSpinLock(&(_bcb)->Lock);                  \
        REF_BUNDLECB(_bcb);                                     \
        NdisDprReleaseSpinLock(&(_bcb)->Lock);                  \
    }                                                           \
    NdisReleaseReadWriteLock(&ConnTableLock, &_ls);             \
    *(_ppbcb) = _bcb;                                           \
}

#define LINKCB_FROM_LINKH(_pplcb, _lh)                          \
{                                                               \
    LOCK_STATE _ls;                                             \
    PLINKCB _lcb = NULL;                                        \
    NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &_ls);      \
    if ((ULONG_PTR)(_lh) <= ConnectionTable->ulArraySize) {     \
        _lcb = *(ConnectionTable->LinkArray + (ULONG_PTR)(_lh));\
    }                                                           \
    if (_lcb != NULL) {                                         \
        NdisDprAcquireSpinLock(&(_lcb)->Lock);                  \
        REF_LINKCB(_lcb);                                       \
        NdisDprReleaseSpinLock(&(_lcb)->Lock);                  \
    }                                                           \
    NdisReleaseReadWriteLock(&ConnTableLock, &_ls);             \
    *(_pplcb) = _lcb;                                           \
}

#define InsertTailGlobalList(_gl, _ple)                         \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    InsertTailList(&(_gl.List), (_ple));                        \
    _gl.ulCount++;                                              \
    if (_gl.ulCount > _gl.ulMaxCount) {                         \
        _gl.ulMaxCount = _gl.ulCount;                           \
    }                                                           \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#define InsertTailGlobalListEx(_gl, _ple, _t, _pt)              \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    InsertTailList(&(_gl.List), (_ple));                        \
    _gl.ulCount++;                                              \
    if (_gl.ulCount > _gl.ulMaxCount) {                         \
        _gl.ulMaxCount = _gl.ulCount;                           \
    }                                                           \
    if (!_gl.TimerScheduled) {                                  \
        LARGE_INTEGER   _ft;                                    \
        _gl.TimerScheduled = TRUE;                              \
        _ft.QuadPart = Int32x32To64(_t, -10000);                \
        KeSetTimerEx(&_gl.Timer, _ft, _pt, &_gl.Dpc);           \
    }                                                           \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#define InsertHeadGlobalList(_gl, _ple)                         \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    InsertHeadList(&(_gl.List), (_ple));                        \
    _gl.ulCount++;                                              \
    if (_gl.ulCount > _gl.ulMaxCount) {                         \
        _gl.ulMaxCount = _gl.ulCount;                           \
    }                                                           \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#define InsertHeadGlobalListEx(_gl, _ple, _t, _pt)              \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    InsertHeadList(&(_gl.List), (_ple));                        \
    _gl.ulCount++;                                              \
    if (_gl.ulCount > _gl.ulMaxCount) {                         \
        _gl.ulMaxCount = _gl.ulCount;                           \
    }                                                           \
    if (!_gl.TimerScheduled) {                                  \
        LARGE_INTEGER   _ft;                                    \
        _gl.TimerScheduled = TRUE;                              \
        _ft.QuadPart = Int32x32To64(_t, -10000);                \
        KeSetTimerEx(&_gl.Timer, _ft, _pt, &_gl.Dpc);           \
    }                                                           \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#define RemoveHeadGlobalList(_gl, _pple)                        \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    *(_pple) = RemoveHeadList(&(_gl.List));                     \
    _gl.ulCount--;                                              \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#define RemoveEntryGlobalList(_gl, _ple)                        \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    RemoveEntryList(_ple);                                      \
    _gl.ulCount--;                                              \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#if 0
//
// The Remote address (DEST address) is what we use to mutilplex
// sends across our single adapter/binding context.  The address
// has the following format:
//
// XX XX YY YY YY YY
//
// XX = Randomly generated OUI
// YY = ProtocolCB
//
#define FillNdisWanHdrContext(_pAddr, _ppcb)    \
    *((ULONG UNALIGNED*)(&_pAddr[2])) = *((ULONG UNALIGNED*)(&_ppcb))

#define GetNdisWanHdrContext(_pAddr, _pppcb)    \
    *((ULONG UNALIGNED*)(_pppcb)) = *((ULONG UNALIGNED*)(&_pAddr[2]))
#endif

//
// The Remote address (DEST address) is what we use to mutilplex
// sends across our single adapter/binding context.  The address
// has the following format:
//
// XX XX XX YY YY ZZ
//
// XX = Randomly generated OUI
// YY = Index into the active bundle connection table to get bundlecb
// ZZ = Index into the protocol table of a bundle to get protocolcb
//
#define FillNdisWanIndices(_pAddr, _bI, _pI)    \
{                                               \
    _pAddr[3] = (UCHAR)((USHORT)_bI >> 8);      \
    _pAddr[4] = (UCHAR)_bI;                     \
    _pAddr[5] = (UCHAR)_pI;                     \
}

#define GetNdisWanIndices(_pAddr, _bI, _pI)         \
{                                                   \
    _bI = ((USHORT)_pAddr[3] << 8) | _pAddr[4];     \
    _pI = _pAddr[5];                                \
    ASSERT(_pI < MAX_PROTOCOLS);                    \
}

//
// In the Src address (from a NdisSend) the bundle index
// is stashed in the two high order bytes as shown below
// with the mask of valid bits given by the x's.  The
// high byte is shifted to the left one bit so the number
// of possible bundles is now 0x7FFF
//
// XX XX YY YY YY YY
//
// XX = Bytes described below owned by NdisWan
// YY = Transports Receive context
//
//       0                1
// 0 1 2 3 4 5 6 7  0 1 2 3 4 5 6 7
// x x x x x x x 0  x x x x x x x x
//
#define FillTransportBundleIndex(_pAddr, _Index)            \
{                                                           \
    _pAddr[0] = (UCHAR)((USHORT)_Index >> 7) & 0xFE;        \
    _pAddr[1] = (UCHAR)_Index;                              \
}

#define GetTransportBundleIndex(_pAddr)                     \
    (((USHORT)_pAddr[0] << 7) & 0x7F) | _pAddr[1]


#define GetProtocolCBFromProtocolList(_pl, _pt, _pppcb)     \
{                                                           \
    PPROTOCOLCB _pP;                                        \
    for (_pP = (PPROTOCOLCB)(_pl)->Flink;                   \
        (PLIST_ENTRY)_pP != _pl;                            \
        _pP = (PPROTOCOLCB)(_pP)->Linkage.Flink) {          \
                                                            \
        if (_pP->ProtocolType == _pt) {                     \
            *(_pppcb) = _pP;                                \
            break;                                          \
        }                                                   \
    }                                                       \
    if ((PVOID)_pP == (PVOID)_pl) {                         \
        *(_pppcb) = NULL;                                   \
    }                                                       \
}

#define PROTOCOLCB_FROM_PROTOCOLH(_pBCB, _pPCB, _hP)    \
{                                                       \
    if (_hP < MAX_PROTOCOLS) {                          \
        _pPCB = _pBCB->ProtocolCBTable[_hP];            \
    } else {                                            \
        _pPCB = NULL;                                   \
    }                                                   \
}

#define NetToHostShort(_ns) ( ((_ns & 0x00FF) << 8) | ((_ns & 0xFF00) >> 8) )
#define HostToNetShort(_hs) ( ((_hs & 0x00FF) << 8) | ((_hs & 0xFF00) >> 8) )

#define IsLinkSendWindowOpen(_plcb) \
    ((_plcb)->SendWindow > (_plcb)->OutstandingFrames)

#define IsSampleTableFull(_pST) ((_pST)->ulSampleCount == (_pST)->ulSampleArraySize)
#define IsSampleTableEmpty(_pST) ((_pST)->ulSampleCount == 0)

#define PMINIPORT_RESERVED_FROM_NDIS(_packet) \
    ((PNDISWAN_MINIPORT_RESERVED)((_packet)->MiniportReserved))

#define PPROTOCOL_RESERVED_FROM_NDIS(_packet) \
    ((PNDISWAN_PROTOCOL_RESERVED)((_packet)->ProtocolReserved))

#define PRECV_RESERVED_FROM_NDIS(_packet) \
    ((PNDISWAN_RECV_RESERVED)((_packet)->ProtocolReserved))

#define IsCompleteFrame(_fl) \
    ((_fl & MULTILINK_BEGIN_FRAME) && (_fl & MULTILINK_END_FRAME))

#define AddPPPProtocolID(_finf, _usID)                              \
{                                                                   \
    PUCHAR  _cp = _finf->ProtocolID.Pointer;                        \
    if (_finf->ProtocolID.Length != 0) {                            \
        ASSERT(_cp);                                                \
        if (!(_finf->FramingBits & PPP_COMPRESS_PROTOCOL_FIELD) ||  \
            (_finf->Flags & (DO_COMPRESSION | DO_ENCRYPTION))) {    \
            *_cp++ = (UCHAR)(_usID >> 8);                           \
        }                                                           \
        *_cp = (UCHAR)_usID;                                        \
    }                                                               \
}

#define AddMultilinkInfo(_finf, _f, _seq, _mask)                    \
{                                                                   \
    PUCHAR  _cp = _finf->Multilink.Pointer;                         \
    if (_finf->Multilink.Length != 0) {                             \
        ASSERT(_cp);                                                \
        if (!(_finf->FramingBits & PPP_COMPRESS_PROTOCOL_FIELD)) {  \
            _cp++;                                                  \
        }                                                           \
        _cp++;                                                      \
        _seq &= _mask;                                              \
        if (_finf->FramingBits & PPP_SHORT_SEQUENCE_HDR_FORMAT) {   \
            *_cp++ = _f | (UCHAR)(_finf->Class << 4) | (UCHAR)((_seq >> 8) & SHORT_SEQ_MASK);   \
            *_cp++ = (UCHAR)_seq;                                   \
        } else {                                                    \
            *_cp++ = _f | (UCHAR)(_finf->Class << 2);               \
            *_cp++ = (UCHAR)(_seq >> 16);                           \
            *_cp++ = (UCHAR)(_seq >> 8);                            \
            *_cp = (UCHAR)_seq;                                     \
        }                                                           \
    }                                                               \
}

#define AddCompressionInfo(_finf, _usCC)                            \
{                                                                   \
    PUCHAR  _cp = _finf->Compression.Pointer;                       \
    if (_finf->Compression.Length != 0) {                           \
        ASSERT(_cp);                                                \
        if (!(_finf->FramingBits & PPP_COMPRESS_PROTOCOL_FIELD)) {  \
            _cp++;                                                  \
        }                                                           \
        _cp++;                                                      \
        *_cp++ = (UCHAR)(_usCC >> 8);                               \
        *_cp = (UCHAR)_usCC;                                        \
    }                                                               \
}

#define UpdateFramingInfo(_finf, _pd)               \
{                                                   \
    PUCHAR  _sdb = (_pd);                           \
    (_finf)->AddressControl.Pointer = (_sdb);       \
    (_sdb) += (_finf)->AddressControl.Length;       \
    (_finf)->Multilink.Pointer = (_sdb);            \
    (_sdb) += (_finf)->Multilink.Length;            \
    (_finf)->Compression.Pointer = (_sdb);          \
    (_sdb) += (_finf)->Compression.Length;          \
    (_finf)->ProtocolID.Pointer = (_sdb);           \
}

#define NdisWanChangeMiniportAddress(_a, _addr)                             \
{                                                                           \
    PNDIS_MINIPORT_BLOCK    Miniport;                                       \
                                                                            \
    Miniport = (PNDIS_MINIPORT_BLOCK)((_a)->MiniportHandle);                \
    ETH_COPY_NETWORK_ADDRESS(Miniport->EthDB->AdapterAddress, _addr);       \
}

//
// Queue routines for the ProtocolCB's NdisPacket queues
//
#define InsertHeadPacketQueue(_ppq, _pnp, _pl)      \
{                                                   \
    PMINIPORT_RESERVED_FROM_NDIS(_pnp)->Next =      \
    (_ppq)->HeadQueue;                              \
    if ((_ppq)->HeadQueue == NULL) {                \
        (_ppq)->TailQueue = _pnp;                   \
    }                                               \
    (_ppq)->HeadQueue = _pnp;                       \
    (_ppq)->ByteDepth += (_pl-14);                  \
    (_ppq)->PacketDepth += 1;                       \
    if ((_ppq)->PacketDepth > (_ppq)->MaxPacketDepth) { \
        (_ppq)->MaxPacketDepth = (_ppq)->PacketDepth; \
    }                                               \
}

#define InsertTailPacketQueue(_ppq, _pnp, _pl)      \
{                                                   \
    PMINIPORT_RESERVED_FROM_NDIS(_pnp)->Next = NULL;\
    if ((_ppq)->HeadQueue == NULL) {                \
        (_ppq)->HeadQueue = _pnp;                   \
    } else {                                        \
        PMINIPORT_RESERVED_FROM_NDIS((_ppq)->TailQueue)->Next = _pnp;   \
    }                                               \
    (_ppq)->TailQueue = _pnp;                       \
    (_ppq)->ByteDepth += (_pl-14);                  \
    (_ppq)->PacketDepth += 1;                       \
    if ((_ppq)->PacketDepth > (_ppq)->MaxPacketDepth) { \
        (_ppq)->MaxPacketDepth = (_ppq)->PacketDepth; \
    }                                               \
}

#define RemoveHeadPacketQueue(_ppq)                             \
    (_ppq)->HeadQueue;                                          \
    {                                                           \
        PNDIS_PACKET _cp = (_ppq)->HeadQueue;                   \
        PNDIS_PACKET _np =                                      \
        PMINIPORT_RESERVED_FROM_NDIS(_cp)->Next;                \
        if (_np == NULL) {                                      \
            (_ppq)->TailQueue = NULL;                           \
        }                                                       \
        (_ppq)->HeadQueue = _np;                                \
        (_ppq)->ByteDepth -= ((_cp)->Private.TotalLength-14);   \
        (_ppq)->PacketDepth -= 1;                               \
    }

#define IsPacketQueueEmpty(_ppq) ((_ppq)->HeadQueue == NULL)

#define NdisWanDoReceiveComplete(_pa)   \
{                                       \
    NdisReleaseSpinLock(&(_pa)->Lock);  \
    NdisMEthIndicateReceiveComplete((_pa)->MiniportHandle); \
    NdisAcquireSpinLock(&(_pa)->Lock);  \
}



//
// OS specific code
//
#ifdef NT

//
// NT stuff
//
#define NdisWanInitializeNotificationEvent(_pEvent) \
        KeInitializeEvent(_pEvent, NotificationEvent, FALSE)

#define NdisWanSetNotificationEvent(_pEvent) \
        KeSetEvent(_pEvent, 0, FALSE)

#define NdisWanClearNotificationEvent(_pEvent) \
        KeClearEvent(_pEvent)

#define NdisWanWaitForNotificationEvent(_pEvent) \
        KeWaitForSingleObject(_pEvent, Executive, KernelMode, TRUE, NULL)

#define NdisWanInitializeSyncEvent(_pEvent) \
        KeInitializeEvent(_pEvent, SynchronizationEvent, FALSE)

#define NdisWanSetSyncEvent(_pEvent) \
        KeSetEvent(_pEvent, 1, FALSE)

#define NdisWanClearSyncEvent(_pEvent) \
        KeClearEvent(_pEvent)

#define NdisWanWaitForSyncEvent(_pEvent) \
        KeWaitForSingleObject(_pEvent, UserRequest, KernelMode, FALSE, NULL)

#if 0
#if DBG && !defined(_WIN64)
#define CheckDataBufferList(_e)                             \
{                                                           \
    PSINGLE_LIST_ENTRY   _le;                               \
    KIRQL               _irql;                              \
    KeAcquireSpinLock(&DataBufferList.Lock, &_irql);        \
    _le = DataBufferList.L.ListHead.Next.Next;              \
    while (_le != NULL) {                                   \
        if ((PSINGLE_LIST_ENTRY)_e == _le) {                \
            DbgPrint("NDISWAN: Corrupt DataBufferList Free!\n"); \
            DbgPrint("NDISWAN: List %x Entry %x\n", &DataBufferList, _e);\
            DbgBreakPoint();                                \
        }                                                   \
        _le = _le->Next;                                    \
    }                                                       \
    KeReleaseSpinLock(&DataBufferList.Lock, _irql);         \
}
#else
#define CheckDataBufferList(_e)
#endif
#endif

#if 0
#define NdisWanFreeDataBuffer(_e)                           \
{                                                           \
    NdisFreeToNPagedLookasideList(&DataBufferList, _e);     \
}

#define NdisWanAllocateDataBuffer() \
        NdisAllocateFromNPagedLookasideList(&DataBufferList)
#endif


#define NdisWanAllocateMemory(_AllocatedMemory, _Size, _t)                                  \
{                                                                                           \
    (PVOID)*(_AllocatedMemory) = (PVOID)ExAllocatePoolWithTag(NonPagedPool, _Size, _t);     \
    if ((PVOID)*(_AllocatedMemory) != NULL) {                                               \
        NdisZeroMemory((PUCHAR)*(_AllocatedMemory), _Size);                                 \
    }                                                                                       \
}

#define NdisWanAllocatePriorityMemory(_AllocatedMemory, _Size, _t, _p)                      \
{                                                                                           \
    (PVOID)*(_AllocatedMemory) = (PVOID)ExAllocatePoolWithTagPriority(NonPagedPool, _Size, _t, _p);\
    if ((PVOID)*(_AllocatedMemory) != NULL) {                                               \
        NdisZeroMemory((PUCHAR)*(_AllocatedMemory), _Size);                                 \
    }                                                                                       \
}

#define NdisWanFreeMemory(_AllocatedMemory) \
        ExFreePool(_AllocatedMemory)

#define NdisWanAllocateNdisBuffer(_ppnb, _pd, _dl)      \
{                                                       \
    NDIS_STATUS _s;                                     \
    NdisAllocateBuffer(&(_s), _ppnb, NULL, _pd, _dl);   \
    if (_s != NDIS_STATUS_SUCCESS) {                    \
        *(_ppnb) = NULL;                                \
    }                                                   \
}

#define NdisWanFreeNdisBuffer(_pnb) NdisFreeBuffer(_pnb)

#define NdisWanMoveMemory(_Dest, _Src, _Length) \
        RtlMoveMemory(_Dest, _Src, _Length)

#define NdisWanGetSystemTime(_pTime)                    \
{                                                       \
    LARGE_INTEGER   _tc;                                \
    ULONG           _ti;                                \
    KeQueryTickCount(&_tc);                             \
    _ti = KeQueryTimeIncrement();                       \
    (_pTime)->QuadPart = _tc.QuadPart * _ti;            \
}

#define NdisWanCalcTimeDiff(_pDest, _pEnd, _pBegin) \
        (_pDest)->QuadPart = (_pEnd)->QuadPart - (_pBegin)->QuadPart

#define NdisWanInitWanTime(_pTime, _Val) \
        (_pTime)->QuadPart = _Val

#define NdisWanMultiplyWanTime(_pDest, _pMulti1, _pMulti2)  \
        (_pDest)->QuadPart = (_pMulti1)->QuadPart * (_pMulti2)->QuadPart

#define NdisWanDivideWanTime(_pDest, _pDivi1, _pDivi2)  \
        (_pDest)->QuadPart = (_pDivi1)->QuadPart / (_pDivi2)->QuadPart

#define NdisWanIsTimeDiffLess(_pTime1, _pTime2) \
        ((_pTime1)->QuadPart < (_pTime2)->QuadPart)

#define NdisWanIsTimeDiffGreater(_pTime1, _pTime2) \
        ((_pTime1)->QuadPart > (_pTime2)->QuadPart)

#define NdisWanIsTimeEqual(_pTime1, _pTime2) \
        ((_pTime1)->QuadPart == (_pTime2)->QuadPart)

#define NdisWanUppercaseNdisString(_pns1, _pns2, _b) \
        RtlUpcaseUnicodeString(_pns1, _pns2, _b)

#define MDL_ADDRESS(_MDL_)  MmGetSystemAddressForMdl(_MDL_)

#define NdisWanInterlockedInc(_pul) \
        InterlockedIncrement(_pul)

#define NdisWanInterlockedDec(_pul) \
        InterlockedDecrement(_pul)

#define NdisWanInterlockedExchange(_pul, _ul) \
        InterlockedExchange(_pul, _ul)

#define NdisWanInterlockedExchangeAdd(_pul, _ul) \
        InterlockedExchangeAdd(_pul, _ul)

#define NdisWanInterlockedInsertTailList(_phead, _pentry, _plock) \
        ExInterlockedInsertTailList(_phead, _pentry, _plock)

#define NdisWanInterlockedInsertHeadList(_phead, _pentry, _plock) \
        ExInterlockedInsertHeadList(_phead, _pentry, _plock)

#define NdisWanInterlockedRemoveHeadList(_phead, _plock) \
        ExInterlockedRemoveHeadList(_phead, _plock)

#define NdisWanRaiseIrql(_pirql) \
        KeRaiseIrql(DISPATCH_LEVEL, _pirql)

#define NdisWanLowerIrql(_irql) \
        KeLowerIrql(_irql)

//
// Wait for event structure.  Used for async completion notification.
//
typedef KEVENT      WAN_EVENT;
typedef WAN_EVENT   *PWAN_EVENT;

typedef LARGE_INTEGER   WAN_TIME;
typedef WAN_TIME        *PWAN_TIME;

typedef KIRQL       WAN_IRQL;
typedef WAN_IRQL    *PWAN_IRQL;

#else   // end NT stuff
//
// Win95 stuff
//

typedef ULONG       WAN_TIME;
typedef WAN_TIME    *PWAN_TIME;

#endif // end of Win95 stuff

#endif // end of _NDISWAN_DEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\wantypes.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Wantypes.h

Abstract:

    This file contains data structures used by the NdisWan driver
    


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "packet.h"

#ifndef _NDISWAN_TYPES_
#define _NDISWAN_TYPES_

//
// OS specific structures
//
#ifdef NT

#endif
//
// end of OS specific structures
//

//
// WanRequest structure used to queue requests to the WAN Miniports
//
typedef struct _WAN_REQUEST {
    LIST_ENTRY          Linkage;
    WanRequestType      Type;           // Sync or Async
    WanRequestOrigin    Origin;         // Is this tapi
    struct _OPENCB      *OpenCB;
    NDIS_HANDLE         AfHandle;
    NDIS_HANDLE         VcHandle;
    NDIS_REQUEST        NdisRequest;        // Ndis Request
    PNDIS_REQUEST       OriginalRequest;
    NDIS_STATUS         NotificationStatus; // Request status
    WAN_EVENT           NotificationEvent;  // Request pending event
} WAN_REQUEST, *PWAN_REQUEST;

//
// Used for
//
typedef struct _WAN_GLOBAL_LIST {
    NDIS_SPIN_LOCK  Lock;           // Access lock
    ULONG           ulCount;        // Count of nodes on list
    ULONG           ulMaxCount;     // Max allowed on list
    LIST_ENTRY      List;           // Doubly-Linked list of nodes
} WAN_GLOBAL_LIST, *PWAN_GLOBAL_LIST;

typedef struct _WAN_GLOBAL_LIST_EX {
    NDIS_SPIN_LOCK  Lock;           // Access lock
    ULONG           ulCount;        // Count of nodes on list
    ULONG           ulMaxCount;     // Max allowed on list
    LIST_ENTRY      List;           // Doubly-Linked list of nodes
    KDPC            Dpc;
    KTIMER          Timer;
    BOOLEAN         TimerScheduled;
} WAN_GLOBAL_LIST_EX, *PWAN_GLOBAL_LIST_EX;

//
// Ethernet Header
//
typedef struct _ETH_HEADER {
    UCHAR   DestAddr[6];
    UCHAR   SrcAddr[6];
    USHORT  Type;
} ETH_HEADER, *PETH_HEADER;

//
// If any of the fields of this structure are removed
// check private\inc\wanpub.h to make sure that the
// corresponding field is removed from WAN_PROTOCOL_INFO
//
typedef struct _PROTOCOL_INFO {
    USHORT  ProtocolType;
    USHORT  PPPId;
    ULONG   Flags;
    ULONG   MTU;
    ULONG   TunnelMTU;
    ULONG   PacketQueueDepth;
}PROTOCOL_INFO, *PPROTOCOL_INFO;

//
// The ProtocolType to PPPProtocolID Lookup Table
//
typedef struct _PROTOCOL_INFO_TABLE {
    NDIS_SPIN_LOCK  Lock;               // Table access lock
    ULONG           ulAllocationSize;   // Size of memory allocated
    ULONG           ulArraySize;        // MAX size of the two arrays
    ULONG           Flags;
    PIRP            EventIrp;
    PPROTOCOL_INFO  ProtocolInfo;
} PROTOCOL_INFO_TABLE, *PPROTOCOL_INFO_TABLE;

//
// ProtocolInfo and Table flags
//
#define PROTOCOL_UNBOUND            0x00000001
#define PROTOCOL_BOUND              0x00000002
#define PROTOCOL_REBOUND            0x00000004
#define PROTOCOL_EVENT_OCCURRED     0x00000008
#define PROTOCOL_EVENT_SIGNALLED    0x00000010


typedef struct _IO_RECV_LIST {
    ULONG           ulIrpCount;     // Count of nodes on list
    LIST_ENTRY      IrpList;        // Doubly-Linked list of nodes
    PIRP            LastIrp;
    NTSTATUS        LastIrpStatus;
    ULONG           LastPacketNumber;
    ULONG           LastCopySize;
    ULONG           ulDescCount;    // Count of nodes on list
    ULONG           ulMaxDescCount; // Max# of nodes on list
    LIST_ENTRY      DescList;       // Doubly-Linked list of nodes
    KDPC            Dpc;
    KTIMER          Timer;
    BOOLEAN         TimerScheduled;
    NDIS_SPIN_LOCK  Lock;           // Access lock
} IO_RECV_LIST, *PIO_RECV_LIST;


//
// Active connections Table
//
typedef struct _CONNECTION_TABLE {
    ULONG               ulAllocationSize;   // Size of memory allocated
    ULONG               ulArraySize;        // Number of possible connections in table
    ULONG               ulNumActiveLinks;   // Number of links in link array
    ULONG               ulNextLink;         // Index to insert next link
    ULONG               ulNumActiveBundles; // Number of bundles in bundle array
    ULONG               ulNextBundle;       // Index to insert next bundle
    LIST_ENTRY          BundleList;         // List of bundlecbs in table
    LIST_ENTRY          LinkList;           // List of linkcbs in the table
    struct  _LINKCB     **LinkArray;        // Pointer to the LinkArray
    struct _BUNDLECB    **BundleArray;      // Pointer to the BundleArray
} CONNECTION_TABLE, *PCONNECTION_TABLE;

typedef struct _IO_DISPATCH_TABLE {
    ULONG       ulFunctionCode;
    NTSTATUS    (*Function)();
}IO_DISPATCH_TABLE, *PIO_DISPATCH_TABLE;

typedef struct _HEADER_FIELD_INFO {
    ULONG   Length;
    PUCHAR  Pointer;
}HEADER_FIELD_INFO, *PHEADER_FIELD_INFO;

typedef struct _HEADER_FRAMING_INFO {
    ULONG               FramingBits;            // Framing bits
    INT                 Class;
    ULONG               HeaderLength;           // Total length of the header
    ULONG               Flags;                  // Framing flags
#define DO_MULTILINK            0x00000001
#define DO_COMPRESSION          0x00000002
#define DO_ENCRYPTION           0x00000004
#define IO_PROTOCOLID           0x00000008
#define FIRST_FRAGMENT          0x00000010
#define DO_FLUSH                0x00000020
#define DO_LEGACY_ENCRYPTION    0x00000040      // Legacy encryption NT 3.0/3.5/3.51
#define DO_40_ENCRYPTION        0x00000080      // Pseudo fixed 40 bit encryption NT 4.0
#define DO_128_ENCRYPTION       0x00000100      // 128 bit encryption NT 4.0 encryption update
#define DO_VJ                   0x00000200
#define SAVE_MAC_ADDRESS        0x00000400
#define DO_HISTORY_LESS         0x00000800
#define DO_56_ENCRYPTION        0x00001000
    HEADER_FIELD_INFO   AddressControl;         // Info about the address/control field
    HEADER_FIELD_INFO   Multilink;              // Info about the multlink field
    HEADER_FIELD_INFO   Compression;            // Info about compression
    HEADER_FIELD_INFO   ProtocolID;             // Info about the protocol id field
}HEADER_FRAMING_INFO, *PHEADER_FRAMING_INFO;

//
// Used for receive data processing
//
typedef struct _RECV_DESC {
    LIST_ENTRY          Linkage;
    ULONG               Signature;
    struct _LINKCB      *LinkCB;
    struct _BUNDLECB    *BundleCB;
    ULONG               SequenceNumber;
    ULONG               Flags;
    USHORT              ProtocolID;
    BOOLEAN             CopyRequired;
    BOOLEAN             Reserved;
    PUCHAR              CurrentBuffer;
    LONG                CurrentLength;
    PUCHAR              StartBuffer;
    LONG                StartLength;
    LONG                HeaderLength;
    PUCHAR              DataBuffer;
    PNDIS_BUFFER        NdisBuffer;
    PNDIS_PACKET        NdisPacket;
    PNDIS_PACKET        OriginalPacket;
} RECV_DESC, *PRECV_DESC;

//
// Used for send data processing
//
typedef struct _SEND_DESC {
    LIST_ENTRY          Linkage;
    ULONG               Signature;
    ULONG               RefCount;
    ULONG               Flags;
#define SEND_DESC_FRAG  0x00000001
    INT                 Class;
    struct _LINKCB      *LinkCB;
    struct _PROTOCOLCB  *ProtocolCB;
    PNDIS_WAN_PACKET    WanPacket;
    PNDIS_BUFFER        NdisBuffer;
    PNDIS_PACKET        NdisPacket;
    PUCHAR              StartBuffer;
    ULONG               HeaderLength;
    ULONG               DataLength;
    PNDIS_PACKET        OriginalPacket;
} SEND_DESC, *PSEND_DESC;

//
// This structure contains every necessary
// to completely describe send or recv in ndiswan
//
typedef struct _DATA_DESC {
    union {
        SEND_DESC   SendDesc;
        RECV_DESC   RecvDesc;
    };
    PNPAGED_LOOKASIDE_LIST  LookasideList;
    PNDIS_PACKET            NdisPacket;
    PNDIS_BUFFER            NdisBuffer;
    ULONG                   DataBufferLength;
    PUCHAR                  DataBuffer;
} DATA_DESC, *PDATA_DESC;

#define DATADESC_SIZE   sizeof(DATA_DESC) + sizeof(PVOID)

//
// BundleInfo is information needed by the bundle for framing decisions.
// This information is the combined information of all links that are part
// of this bundle.
//
typedef struct _BUNDLE_FRAME_INFO {
    ULONG   SendFramingBits;        // Send framing bits
    ULONG   RecvFramingBits;        // Receive framing bits
    ULONG   MaxRSendFrameSize;      // Max size of send frame
    ULONG   MaxRRecvFrameSize;      // Max size of receive frame
    ULONG   PPPHeaderLength;
} BUNDLE_FRAME_INFO, *PBUNDLE_FRAME_INFO;

typedef struct _BOND_SAMPLE {
    ULONG           ulBytes;
    ULONG           ulReferenceCount;
    WAN_TIME        TimeStamp;
} BOND_SAMPLE, *PBOND_SAMPLE;

typedef struct _SAMPLE_TABLE {
    ULONG           ulHead;                     // Index to 1st sample in current period
    ULONG           ulCurrent;                  // Index to latest insertion in table
    ULONG           ulSampleCount;              // Count of samples in table
    ULONGLONG       ulCurrentSampleByteCount;   // Count of bytes sent in this sample period
    ULONG           ulSampleArraySize;          // Sample array size
    WAN_TIME        SampleRate;                 // Time between each sample
    WAN_TIME        SamplePeriod;               // Time between 1st sample and last sample
    BOND_SAMPLE     SampleArray[SAMPLE_ARRAY_SIZE];     // SampleArray
} SAMPLE_TABLE, *PSAMPLE_TABLE;

typedef struct _BOND_INFO {
    ULONGLONG   ulBytesThreshold;           // Threshold in BytesPerSamplePeriod
    ULONGLONG   ulBytesInSamplePeriod;      // Max bytes in sample period
    USHORT      usPercentBandwidth;         // Threshold as % of total bandwidth
    ULONG       ulSecondsInSamplePeriod;    // # of seconds in a sample period
    ULONG       State;                      // Current state
    ULONG       DataType;
    WAN_TIME    StartTime;                  // Start time for threshold event
    SAMPLE_TABLE    SampleTable;
} BOND_INFO, *PBOND_INFO;

#define BONDALLOC_SIZE  \
    (sizeof(BOND_INFO) * 4) +\
    (sizeof(PVOID) * 3)
    
typedef struct _CACHED_KEY{
    USHORT  Coherency;
    UCHAR   SessionKey[1];
} CACHED_KEY, *PCACHED_KEY;

//
// This information is used to describe the encryption that is being
// done on the bundle.  At some point this should be moved into
// wanpub.h and ndiswan.h.
//
typedef struct _CRYPTO_INFO{
#define CRYPTO_IS_SERVER     0x00000001
    ULONG   Flags;                  //
    UCHAR   StartKey[16];           // Start key
    UCHAR   SessionKey[16];         // Session key used for encrypting
    ULONG   SessionKeyLength;       // Session key length
    PVOID   Context;                // Working key encryption context
    PVOID   RC4Key;                 // RC4 encryption context
    PVOID   CachedKeyBuffer;        // cached key array, for receive only
    PCACHED_KEY pCurrKey;           // pointer to save the next cached key
    PCACHED_KEY pLastKey;           // the last key in the buffer, to speed up lookup
} CRYPTO_INFO, *PCRYPTO_INFO;

#define ENCRYPTCTX_SIZE \
    sizeof(struct RC4_KEYSTRUCT) +\
    sizeof(A_SHA_CTX) +\
    (sizeof(PVOID))
    
typedef struct _BUNDLE_RECV_INFO {
    LIST_ENTRY  AssemblyList;   // List head for assembly of recv descriptors
    ULONG       AssemblyCount;  // # of descriptors on the assembly list
    PRECV_DESC  RecvDescHole;   // Pointer to 1st hole in recv desc list
    ULONG       MinSeqNumber;   // Minimum recv sequence number
    ULONG       FragmentsLost;  // Count of recv fragments flushed
} BUNDLE_RECV_INFO, *PBUNDLE_RECV_INFO;

typedef struct _SEND_FRAG_INFO {
    LIST_ENTRY      FragQueue;          //
    ULONG           FragQueueDepth;
    ULONG           SeqNumber;      // Current send sequence number (multilink)
    ULONG           MinFragSize;
    ULONG           MaxFragSize;
    ULONG           WinClosedCount;
} SEND_FRAG_INFO, *PSEND_FRAG_INFO;

//
// This is the control block that defines a bundle (connection).
// This block is created when a WAN Miniport driver gives a lineup
// indicating a new connection has been established.  This control
// block will live as long as the connection is up (until a linedown
// is received) or until the link associated with the bundle is
// added to a different bundle.  BundleCB's live in the global bundle
// array with their hBundleHandle as their index into the array.
//
typedef struct _BUNDLECB {
    LIST_ENTRY      Linkage;            // Linkage for the global free list
    ULONG           Flags;              // Flags
#define IN_SEND                 0x00000001
#define TRY_SEND_AGAIN          0x00000002
#define RECV_PACKET_FLUSH       0x00000004
#define PROTOCOL_PRIORITY       0x00000008
#define INDICATION_EVENT        0x00000010
#define FRAMES_PENDING_EVENT    0x00000020
#define BOND_ENABLED            0x00000040
#define DEFERRED_WORK_QUEUED    0x00000080
#define DISABLE_IDLE_DETECT     0x00000100
#define CCP_ALLOCATED           0x00000200
#define QOS_ENABLED             0x00000400
#define DO_DEFERRED_WORK        0x00000800
#define BUNDLE_IN_RECV          0x00001000
#define PAUSE_DATA              0x00002000
#define SEND_CCP_ALLOCATED      0x00004000
#define RECV_CCP_ALLOCATED      0x00008000
#define SEND_ECP_ALLOCATED      0x00010000
#define RECV_ECP_ALLOCATED      0x00020000
#define SEND_FRAGMENT           0x00040000

    BundleState     State;
    ULONG           RefCount;           // Reference count for this structure

    NDIS_HANDLE     hBundleHandle;      // ConnectionTable index
    NDIS_HANDLE     hBundleContext;     // Usermode context

    LIST_ENTRY      LinkCBList;         // List head for links
    ULONG           ulLinkCBCount;      // Count of links

    BUNDLE_FRAME_INFO   FramingInfo;    // Framing information

    //
    // Send section
    //
    struct _LINKCB  *NextLinkToXmit;    // Next link to send data over
    ULONG           SendSeqMask;        // Mask for send sequence numbers
    ULONG           SendSeqTest;        // Test for sequence number diff
    ULONG           SendFlags;
    SEND_FRAG_INFO  SendFragInfo[MAX_MCML];
    ULONG           NextFragClass;

    ULONG           SendingLinks;       // Number of links with open send windows
    ULONG           SendResources;      // # of avail packets for fragmented sends
    ULONG           SendWindow;         // # of sends that can be sent to miniport
    ULONG           OutstandingFrames;  // # outstanding sends
    WAN_EVENT       OutstandingFramesEvent; // Async notification event for pending sends
    NDIS_STATUS     IndicationStatus;

    //
    // Receive section
    //
    BUNDLE_RECV_INFO    RecvInfo[MAX_MCML]; // Array of ML recv info
    ULONG       RecvSeqMask;            // Mask for receive sequence number
    ULONG       RecvSeqTest;            // Test for sequence number diff
    ULONG       RecvFlags;

    //
    // Protocol information
    //
    struct _PROTOCOLCB  **ProtocolCBTable;  // ProctocolCB table
    ULONG               ulNumberOfRoutes;   // ProtocolCB table count
    LIST_ENTRY          ProtocolCBList;     // List head for routed ProtocolCB's
    struct _PROTOCOLCB  *NextProtocol;
    struct _PROTOCOLCB  *IoProtocolCB;
    ULONG               SendMask;           // Send Mask for all send queues
    WAN_TIME            LastNonIdleData;

    FLOWSPEC    SFlowSpec;
    FLOWSPEC    RFlowSpec;

    //
    // VJ information
    //
    VJ_INFO SendVJInfo;                 // Send VJ compression options
    VJ_INFO RecvVJInfo;                 // Recv VJ compression options
    struct slcompress *VJCompress;      // VJ compression table

    //
    // MS Compression
    //
    COMPRESS_INFO   SendCompInfo;       // Send compression options
    PVOID   SendCompressContext;        // Sendd compressor context

    COMPRESS_INFO   RecvCompInfo;       // Recv compression options
    PVOID   RecvCompressContext;        // Recv decompressor context

    //
    // MS Encryption
    //
    CRYPTO_INFO SendCryptoInfo;
    CRYPTO_INFO RecvCryptoInfo;

    USHORT  SCoherencyCounter;          // Coherency counters
    USHORT  SReserved1;
    USHORT  RCoherencyCounter;          //
    USHORT  RReseved1;
    USHORT  LastRC4Reset;               // Encryption key reset
    USHORT  LReserved1;
    ULONG   CCPIdentifier;              //

    //
    // Bandwidth on Demand
    //
    PVOID       BonDAllocation;
    LIST_ENTRY  BonDLinkage;
    PBOND_INFO  SUpperBonDInfo;
    PBOND_INFO  SLowerBonDInfo;
    PBOND_INFO  RUpperBonDInfo;
    PBOND_INFO  RLowerBonDInfo;

    //
    // Deferred Linkage
    //
    LIST_ENTRY  DeferredLinkage;

    //
    // Bundle Name
    //
    ULONG   ulNameLength;                   // Bundle name length
    UCHAR   Name[MAX_NAME_LENGTH];          // Bundle name

    //
    // Bundle statistics
    //
    WAN_STATS   Stats;                      // Bundle statistics

    NDIS_SPIN_LOCK  Lock;                   // Structure access lock

#ifdef CHECK_BUNDLE_LOCK
    ULONG           LockFile;
    ULONG           LockLine;
    BOOLEAN         LockAcquired;
#endif
} BUNDLECB, *PBUNDLECB;

#define BUNDLECB_SIZE \
    (sizeof(BUNDLECB) + (sizeof(PPROTOCOLCB) * MAX_PROTOCOLS) +\
    sizeof(PROTOCOLCB) + (2 * sizeof(PVOID)))

//
// Link receive handlers defined for:
// PPP, RAS, ARAP, Forward
//
typedef
NDIS_STATUS
(*LINK_RECV_HANDLER)(
    IN  struct _LINKCB  *LinkCB,
    IN  PRECV_DESC      RecvDesc
    );

//
// Link send handlers defined for:
// PPP, RAS, ARAP, Forward
//
typedef
UINT
(*LINK_SEND_HANDLER)(
    IN  PSEND_DESC      SendDesc
    );

typedef struct _LINK_RECV_INFO {
    ULONG   LastSeqNumber;  // Last recv sequence number
    ULONG   FragmentsLost;  // Number of lost fragments
} LINK_RECV_INFO, *PLINK_RECV_INFO;

//
// This control blocks defines an active link that is part
// of a bundle (connection).  This block is created when a
// WAN Miniport driver gives a lineup indicating that a new
// connection has been established or when a new vc/call is
// created by the proxy.  The control block lives until a
// linedown indication is received for the link or the vc/call
// is dropped by the proxy.  The control block lives linked
// into a bundle control block.
//
typedef struct _LINKCB {
    LIST_ENTRY          Linkage;                // bundle linkage
    ULONG               Signature;
    LinkState           State;
    ClCallState         ClCallState;
    ULONG               RefCount;               // Reference count
    ULONG               VcRefCount;

#define LINK_IN_RECV    0x00000001
    ULONG               Flags;

    NDIS_HANDLE         hLinkHandle;            // connection table index

    NDIS_HANDLE         hLinkContext;           // usermode context
    NDIS_HANDLE         NdisLinkHandle;
    NDIS_HANDLE         ConnectionWrapperID;
    struct _OPENCB      *OpenCB;                // OpenCB
    struct _BUNDLECB    *BundleCB;              // BundleCB
    struct _CL_AFSAPCB  *AfSapCB;

    ULONG               RecvDescCount;          // # of Desc's on the list

    LINK_RECV_INFO      RecvInfo[MAX_MCML];

    LINK_SEND_HANDLER   SendHandler;
    LINK_RECV_HANDLER   RecvHandler;

    FLOWSPEC            SFlowSpec;
    FLOWSPEC            RFlowSpec;
    ULONG               SBandwidth;             // % of the bundle send bandwidth
    ULONG               RBandwidth;             // % of the bundle recv bandwidth
    BOOLEAN             LinkActive;             // TRUE if Link has > minBandwidth of Bundle
    BOOLEAN             SendWindowOpen;         // TRUE if send window is open
    ULONG               SendResources;          // # of avail packets for fragmented sends
    ULONG               SendWindow;             // Max # of Outstanding sends allowed
    ULONG               OutstandingFrames;      // Number of outstanding frames on the link
    WAN_EVENT           OutstandingFramesEvent; // Async notification event for pending sends
    LIST_ENTRY          SendLinkage;
    LIST_ENTRY          ConnTableLinkage;

    WAN_LINK_INFO       LinkInfo;               // Framing information

    ULONG               ulNameLength;           // Name length
    UCHAR               Name[MAX_NAME_LENGTH];  // Name

    WAN_STATS           Stats;                  // statistics
    NDIS_SPIN_LOCK      Lock;
} LINKCB, *PLINKCB;

#define LINKCB_SIZE (sizeof(LINKCB))

//
// The protocol control block defines a protocol that is routed to a bundle
//
typedef struct _PROTOCOLCB {
    LIST_ENTRY          Linkage;                // bundle linkage
    ULONG               Signature;
    ProtocolState       State;
    ULONG               RefCount;
    ULONG               Flags;

    NDIS_HANDLE         ProtocolHandle;         // Index of this protocol in
                                                // the bundle protocol array
    struct _MINIPORTCB  *MiniportCB;            // Pointer to the adaptercb
    struct _BUNDLECB    *BundleCB;              // Pointer to the bundlecb

    LIST_ENTRY          VcList;                 // List of attached Vc's
    LIST_ENTRY          MiniportLinkage;        // Link into miniportcb
    LIST_ENTRY          RefLinkage;             // Link into outstanding ref list

    ULONG               OutstandingFrames;
    ULONG               SendMaskBit;            // Send bit mask
    PACKET_QUEUE        PacketQueue[MAX_MCML+1];
    ULONG               NextPacketClass;

    USHORT              ProtocolType;           // EtherType of this protocol
    USHORT              PPPProtocolID;          // PPP Protocol ID
    ULONG               MTU;                    // MTU for this protocol
    ULONG               TunnelMTU;
    WAN_TIME            LastNonIdleData;        // Time at which last
                                                // non-idle packet was recv'd
    BOOLEAN             (*NonIdleDetectFunc)(); // Function to sniff for
                                                // non-idle data
    ULONG               ulTransportHandle;      // Transport's connection
                                                // identifier
    UCHAR               NdisWanAddress[6];      // MAC address used for
                                                // this protocol
    UCHAR               TransportAddress[6];    // MAC address used for
                                                // indications to transport
    NDIS_STRING         BindingName;
    NDIS_STRING         InDeviceName;
    NDIS_STRING         OutDeviceName;
    WAN_EVENT           UnrouteEvent;           // Async notification for pending unroute
    ULONG               ulLineUpInfoLength;     // Length of protocol
                                                // specific lineup info
    PUCHAR              LineUpInfo;             // Pointer to protocol
                                                // specific lineup info
//  NDIS_SPIN_LOCK      Lock;                   // Structure access lock
} PROTOCOLCB, *PPROTOCOLCB;

#define PROTOCOLCB_SIZE (sizeof(PROTOCOLCB))

union _LINKPROTOCB{
    PROTOCOLCB  ProtocolCB;
    LINKCB      LinkCB;
} LINKPROTOCB;

#define LINKPROTOCB_SIZE (sizeof(LINKPROTOCB))

//
// This control block is allocated for every address family that
// ndiswan's client component opens and registers a sap with.
// They are threaded up on the open control block.
//
typedef struct _CL_AFSAPCB {
    LIST_ENTRY          Linkage;
    ULONG               Signature;
    ULONG               RefCount;
    ULONG               Flags;
    struct  _OPENCB     *OpenCB;            // OpenCB
    CO_ADDRESS_FAMILY   Af;                 // Af info
    NDIS_HANDLE         AfHandle;           // Ndis's Af handle
    NDIS_HANDLE         SapHandle;          // Ndis's Sap handle
    LIST_ENTRY          LinkCBList;         // List of Links (VCs) on this Af
    NDIS_SPIN_LOCK      Lock;
} CL_AFSAPCB, *PCL_AFSAPCB;

#define AF_OPENING              0x00000001
#define AF_OPENED               0x00000002
#define AF_OPEN_FAILED          0x00000004
#define AF_CLOSING              0x00000008
#define AF_CLOSED               0x00000010
#define SAP_REGISTERING         0x00000020
#define SAP_REGISTERED          0x00000040
#define SAP_REGISTER_FAILED     0x00000080
#define SAP_DEREGISTERING       0x00000100
#define AFSAP_REMOVED_UNBIND    0x00000200
#define AFSAP_REMOVED_REQUEST   0x00000400
#define AFSAP_REMOVED_OPEN      0x00000800

#define AFSAP_REMOVED_FLAGS     (SAP_REGISTER_FAILED | \
                                AFSAP_REMOVED_UNBIND | \
                                AFSAP_REMOVED_REQUEST | \
                                AFSAP_REMOVED_OPEN)
#define CLSAP_BUFFERSIZE    (sizeof(CO_SAP) +  \
                             sizeof(DEVICECLASS_NDISWAN_SAP))

//
// This control block is allocated for every open on the
// CO_ADDRESS_FAMILY_PPP and is threaded up on the miniport
// control block.
//
typedef struct _CM_AFSAPCB {
    LIST_ENTRY          Linkage;
    ULONG               Signature;
    ULONG               RefCount;
    struct _MINIPORTCB  *MiniportCB;
    NDIS_HANDLE         AfHandle;
    LIST_ENTRY          ProtocolCBList;
    WAN_EVENT           NotificationEvent;
    NDIS_STATUS         NotificationStatus;
    NDIS_SPIN_LOCK      Lock;
} CM_AFSAPCB, *PCM_AFSAPCB;

//
// This control block is allocated for every call
// to CmCreateVc
typedef struct _CM_VCCB {
    LIST_ENTRY          Linkage;
    ULONG               Signature;
    CmVcState           State;
    ULONG               RefCount;
    ULONG               Flags;
#define NO_FRAGMENT 0x00000001
    INT                 FlowClass;
    NDIS_HANDLE         NdisVcHandle;
    struct _PROTOCOLCB  *ProtocolCB;
    struct _CM_AFSAPCB  *AfSapCB;
    NDIS_SPIN_LOCK      Lock;
} CM_VCCB, *PCM_VCCB;

union _AFSAPVCCB{
    CL_AFSAPCB  ClAfSapCB;
    CM_AFSAPCB  CmAfSapCB;
    CM_VCCB     CmVcCB;
} AFSAPVCCB;

#define AFSAPVCCB_SIZE sizeof(AFSAPVCCB)
    
#if 0
typedef struct _PS_MEDIA_PARAMETERS{

    CO_MEDIA_PARAMETERS StdMediaParameters;
    UCHAR LinkId[6]; // Used by NdisWan
    NDIS_STRING InstanceName;

} PS_MEDIA_PARAMETERS, *PPS_MEDIA_PARAMETERS;

#endif

#define IE_IN_USE       0x00010000

typedef struct _TRANSDRVCB {
    LIST_ENTRY                  Linkage;
    TransDrvState               State;
    ULONG                       Flags;
#define TRANSDRV_INTERNAL       0x00000001
    PDEVICE_OBJECT              DObj;
    PFILE_OBJECT                FObj;
    TRANSFORM_OPEN              Open;
    TRANSFORM_CHARACTERISTICS   Chars;
    PTRANSFORM_INFO             Caps;
    NDIS_STRING                 Name;
    NDIS_SPIN_LOCK              Lock;
} TRANSDRVCB, *PTRANSDRVCB;

#endif          // WAN_TYPES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\wanproto.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Wanproto.h

Abstract:

    This file contains the prototypes for functions that NdisWan uses.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe  06/06/95    Created

--*/

#ifndef _NDISWAN_PROTO
#define _NDISWAN_PROTO

//
// Functions from cl.c
//
NDIS_STATUS
ClCreateVc(
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     NdisVcHandle,
    OUT PNDIS_HANDLE    ProtocolVcContext
    );

NDIS_STATUS
ClDeleteVc(
    IN  NDIS_HANDLE     ProtocolVcContext
    );

VOID
ClOpenAfComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     NdisAfHandle
    );

VOID
ClCloseAfComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext
    );

VOID
ClRegisterSapComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolSapContext,
    IN  PCO_SAP         Sap,
    IN  NDIS_HANDLE     NdisSapHandle
    );

VOID
ClDeregisterSapComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolSapContext
    );

VOID
ClMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
ClModifyQoSComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
ClCloseCallComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  NDIS_HANDLE     ProtocolPartyContext OPTIONAL
    );

NDIS_STATUS
ClIncomingCall(
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    );

VOID
ClIncomingCallQoSChange(
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
ClIncomingCloseCall(
    IN  NDIS_STATUS     CloseStatus,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PVOID           CloseData   OPTIONAL,
    IN  UINT            Size        OPTIONAL
    );

VOID
ClCallConnected(
    IN  NDIS_HANDLE     ProtocolVcContext
    );

//
// Functions from cm.c
//
NDIS_STATUS
CmCreateVc(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    );

NDIS_STATUS
CmDeleteVc(
    IN  NDIS_HANDLE             ProtocolVcContext
    );

NDIS_STATUS
CmOpenAf(
    IN  NDIS_HANDLE             CallMgrBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             NdisAfHandle,
    OUT PNDIS_HANDLE            CallMgrAfContext
    );

NDIS_STATUS
CmCloseAf(
    IN  NDIS_HANDLE             CallMgrAfContext
    );

NDIS_STATUS
CmRegisterSap(
    IN  NDIS_HANDLE             CallMgrAfContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    );

NDIS_STATUS
CmDeregisterSap(
    IN  NDIS_HANDLE             CallMgrSapContext
    );

NDIS_STATUS
CmMakeCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    OUT PNDIS_HANDLE            CallMgrPartyContext OPTIONAL
    );

NDIS_STATUS
CmCloseCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
    IN  PVOID                   CloseData           OPTIONAL,
    IN  UINT                    Size                OPTIONAL
    );

NDIS_STATUS
CmModifyCallQoS(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
CmIncomingCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
CmActivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
CmDeactivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext
    );

NDIS_STATUS
CmRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

//
// Functions from ccp.c
//
VOID
WanInitECP(
    VOID
    );

VOID
WanDeleteECP(
    VOID
    );

NTSTATUS
WanAllocateECP(
    PBUNDLECB           BundleCB,
    PCOMPRESS_INFO      CompInfo,
    PCRYPTO_INFO        CryptoInfo,
    BOOLEAN             IsSend
    );

VOID
WanDeallocateECP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo
    );

NTSTATUS
WanAllocateCCP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    BOOLEAN         IsSend
    );

VOID
WanDeallocateCCP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    BOOLEAN         IsSend
    );

//
// Functions from indicate.c
//
VOID
NdisWanLineUpIndication(
    IN  POPENCB OpenCB,
    IN  PUCHAR  Buffer,
    IN  ULONG   BufferSize
    );

VOID
NdisWanLineDownIndication(
    IN  POPENCB OpenCB,
    IN  PUCHAR  Buffer,
    IN  ULONG   BufferSize
    );

VOID
NdisWanFragmentIndication(
    IN  POPENCB OpenCB,
    IN  PUCHAR  Buffer,
    IN  ULONG   BufferSize
    );

VOID
NdisCoWanFragmentIndication(
    IN  PLINKCB     LinkCB,
    IN  PBUNDLECB   BundleCB,
    IN  PUCHAR      Buffer,
    IN  ULONG       BufferSize
    );

VOID
NdisCoWanLinkParamChange(
    IN  PLINKCB     LinkCB,
    IN  PBUNDLECB   BundleCB,
    IN  PUCHAR      Buffer,
    IN  ULONG       BufferSize
    );

VOID
UpdateBundleInfo(
    IN  PBUNDLECB   BundleCB
    );

VOID
AddLinkToBundle(
    IN  PBUNDLECB   BundleCB,
    IN  PLINKCB     LinkCB
    );

VOID
RemoveLinkFromBundle(
    IN  PBUNDLECB   BundleCB,
    IN  PLINKCB     LinkCB,
    IN  BOOLEAN     Locked
    );

VOID
FreeBundleResources(
    PBUNDLECB   BundleCB
    );

//
// Functions from init.c
//

//
// Functions from io.c
//
VOID
SetBundleFlags(
    PBUNDLECB   BundleCB
    );

#ifdef NT

NTSTATUS
NdisWanIoctl(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

NTSTATUS
NdisWanCreate(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

NTSTATUS
NdisWanCleanup(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

NTSTATUS
NdisWanPnPPower(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

VOID
NdisWanCancelRoutine(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

NTSTATUS
NdisWanIrpStub(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

VOID
FlushProtocolPacketQueue(
    PPROTOCOLCB ProtocolCB
    );

VOID
IoRecvIrpWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    );

#endif // NT

VOID
RemoveProtocolCBFromBundle(
    PPROTOCOLCB ProtocolCB
    );

//
// Functions from loopback.c
//
VOID
NdisWanIndicateLoopbackPacket(
    PMINIPORTCB     MiniportCB,
    PNDIS_PACKET    NdisPacket
    );

//
// Functions from memory.c
//
PMINIPORTCB
NdisWanAllocateMiniportCB(
    IN  PNDIS_STRING AdapterName
    );

VOID
NdisWanFreeMiniportCB(
    IN  PMINIPORTCB pMiniportCB
    );

POPENCB
NdisWanAllocateOpenCB(
    IN  PNDIS_STRING BindName
    );

VOID
NdisWanFreeOpenCB(
    IN  POPENCB pOpenCB
    );

PPROTOCOLCB
NdisWanAllocateProtocolCB(
    IN  PNDISWAN_ROUTE  Route
    );

VOID
NdisWanFreeProtocolCB(
    IN  PPROTOCOLCB ProtocolCB
    );

PLINKCB
NdisWanAllocateLinkCB(
    IN  POPENCB OpenCB,
    IN  ULONG   SendWindow
    );

VOID
NdisWanFreeLinkCB(
    IN  PLINKCB LinkCB
    );

PBUNDLECB
NdisWanAllocateBundleCB(
    VOID
    );

VOID
NdisWanFreeBundleCB(
    IN  PBUNDLECB BundleCB
    );

PNDIS_PACKET
NdisWanAllocateNdisPacket(
    ULONG   MagicNumber
    );

VOID
NdisWanFreeNdisPacket(
    PNDIS_PACKET    NdisPacket
    );

PVOID
AllocateDataDesc(
    POOL_TYPE   PoolType,
    SIZE_T      NumberOfBytes,
    ULONG       Tag
    );

VOID
FreeDataDesc(
    PVOID   Buffer
    );

PRECV_DESC
NdisWanAllocateRecvDesc(
    ULONG   SizeNeeded
    );

VOID
NdisWanFreeRecvDesc(
    PRECV_DESC  RecvDesc
    );

PSEND_DESC
NdisWanAllocateSendDesc(
    PLINKCB LinkCB,
    ULONG   SizeNeeded
    );

VOID
NdisWanFreeSendDesc(
    PSEND_DESC  SendDesc
    );

NDIS_STATUS
NdisWanAllocateSendResources(
    POPENCB OpenCB
    );

VOID
NdisWanFreeSendResources(
    POPENCB OpenCB
    );

NDIS_STATUS
NdisWanCreateProtocolInfoTable(
    VOID
    );

VOID
NdisWanDestroyProtocolInfoTable(
    VOID
    );

NDIS_STATUS
NdisWanCreateConnectionTable(
    ULONG   TableSize
    );

VOID
CompleteThresholdEvent(
    PBUNDLECB   BundleCB,
    ULONG       DataType,
    ULONG       ThresholdType
    );

PCL_AFSAPCB
NdisWanAllocateClAfSapCB(
    POPENCB OpenCB,
    PCO_ADDRESS_FAMILY AddressFamily
    );

VOID
NdisWanFreeClAfSapCB(
    PCL_AFSAPCB AfSapCB
    );

PCM_AFSAPCB
NdisWanAllocateCmAfSapCB(
    PMINIPORTCB MiniportCB
    );

VOID
NdisWanFreeCmAfSapCB(
    PCM_AFSAPCB AfSapCB
    );

PCM_VCCB
NdisWanAllocateCmVcCB(
    PCM_AFSAPCB AfSapCB,
    NDIS_HANDLE NdisVcHandle
    );

VOID
NdisWanFreeCmVcCB(
    PCM_VCCB    CmVcCB
    );

NDIS_STATUS
AllocateIoNdisPacket(
    ULONG           SizeNeeded,
    PNDIS_PACKET    *NdisPacket,
    PNDIS_BUFFER    *NdisBuffer, 
    PUCHAR          *DataBuffer
    );

VOID
FreeIoNdisPacket(
    PNDIS_PACKET    NdisPacket
);

//
// Functions from ndiswan.c
//
NDIS_STATUS
DoMiniportInit(
    VOID
    );

NDIS_STATUS
DoProtocolInit(
    IN  PUNICODE_STRING RegistryPath
    );

NDIS_STATUS
DoWanMiniportInit(
    VOID
    );

VOID
NdisWanReadRegistry(
    IN  PUNICODE_STRING RegistryPath
    );

VOID
NdisWanBindMiniports(
    IN  PUNICODE_STRING RegistryPath
    );

VOID
NdisWanGlobalCleanup(
    VOID
    );

VOID
SetProtocolInfo(
    IN  PPROTOCOL_INFO  ProtocolInfo
    );

BOOLEAN
GetProtocolInfo(
    IN OUT  PPROTOCOL_INFO ProtocolInfo
    );

NDIS_HANDLE
InsertLinkInConnectionTable(
    IN  PLINKCB LinkCB
    );

VOID
RemoveLinkFromConnectionTable(
    IN  PLINKCB LinkCB
    );

NDIS_HANDLE
InsertBundleInConnectionTable(
    IN  PBUNDLECB   BundleCB
    );

VOID
RemoveBundleFromConnectionTable(
    IN  PBUNDLECB   BundleCB
    );

NTSTATUS
OpenTransformDriver(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    );

NTSTATUS
BindQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    );

BOOLEAN
IsHandleValid(
    USHORT  usHandleType,
    NDIS_HANDLE hHandle
    );

#if DBG

PUCHAR
NdisWanGetNdisStatus(
    IN  NDIS_STATUS GeneralStatus
    );

#endif


//
// Functions from miniport.c
//

BOOLEAN
MPCheckForHang(
    IN  NDIS_HANDLE MiniportAdapterContext
    );

#if 0
NDIS_STATUS
MPQueryInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    );

NDIS_STATUS
MPSetInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    );
#endif

VOID
MPHalt(
    IN  NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
MPInitialize(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN  PNDIS_MEDIUM    MediumArray,
    IN  UINT            MediumArraySize,
    IN  NDIS_HANDLE     MiniportAdapterHandle,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    );

NDIS_STATUS
MPReconfigure(
    OUT PNDIS_STATUS    OpenErrorStatus,
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    );

NDIS_STATUS
MPReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    );

VOID
MPReturnPacket(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PNDIS_PACKET    Packet
    );

VOID
MPSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets
    );

NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET NdisPacket,
    OUT PUINT BytesTransferred,
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportReceiveContext,
    IN UINT ByteOffset,
    IN UINT BytesToTransfer
    );

NDIS_STATUS
MPCoCreateVc(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     NdisVcHandle,
    OUT PNDIS_HANDLE    MiniportVcContext
    );

NDIS_STATUS
MPCoDeleteVc(
    IN  NDIS_HANDLE MiniportVcContext
           );

NDIS_STATUS
MPCoActivateVc(
    IN  NDIS_HANDLE             MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    );

NDIS_STATUS
MPCoDeactivateVc(
    IN  NDIS_HANDLE MiniportVcContext
    );

VOID
MPCoSendPackets(
    IN  NDIS_HANDLE     MiniportVcContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets
    );

NDIS_STATUS
MPCoRequest(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportVcContext   OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

//
// Functions from protocol.c
//

NDIS_STATUS
ProtoOpenWanAdapter(
    POPENCB pOpenCB
    );

NDIS_STATUS
ProtoCloseWanAdapter(
    IN  POPENCB pOpenCB
);

VOID
ProtoOpenAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status,
    IN  NDIS_STATUS OpenErrorStatus
    );

VOID
ProtoCloseAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

VOID
ProtoResetComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

VOID
ProtoReceiveComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    );

VOID
ProtoIndicateStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

VOID
ProtoIndicateStatusComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    );

VOID
ProtoWanSendComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_WAN_PACKET    Packet,
    IN  NDIS_STATUS         Status
    );

NDIS_STATUS
ProtoWanReceiveIndication(
    IN  NDIS_HANDLE NdisLinkHandle,
    IN  PUCHAR      Packet,
    IN  ULONG       PacketSize
    );

VOID
ProtoRequestComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_REQUEST   NdisRequest,
    IN  NDIS_STATUS     Status
    );

VOID
ProtoBindAdapter(
    OUT PNDIS_STATUS    Status,
    IN  NDIS_HANDLE     BindContext,
    IN  PNDIS_STRING    DeviceName,
    IN  PVOID           SystemSpecific1,
    IN  PVOID           SystemSpecific2
    );

VOID
ProtoUnbindAdapter(
    OUT PNDIS_STATUS    Status,
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  NDIS_HANDLE     UnbindContext
    );

VOID
ProtoUnload(
    VOID
    );

NDIS_STATUS
ProtoPnPEvent(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNET_PNP_EVENT  NetPnPEvent
    );

VOID
ProtoCoSendComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PNDIS_PACKET    Packet
    );

VOID
ProtoCoIndicateStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext   OPTIONAL,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

UINT
ProtoCoReceivePacket(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PNDIS_PACKET    Packet
    );

NDIS_STATUS
ProtoCoRequest(
    IN  NDIS_HANDLE         ProtocolAfContext,
    IN  NDIS_HANDLE         ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE         ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST    NdisRequest
    );

VOID
ProtoCoRequestComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE     ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST   NdisRequest
    );

VOID
ProtoCoAfRegisterNotify(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily
    );

NDIS_STATUS
DoNewLineUpToProtocol(
    IN  PPROTOCOLCB ProtocolCB
    );

NDIS_STATUS
DoLineUpToProtocol(
    IN  PPROTOCOLCB ProtocolCB
    );

NDIS_STATUS
DoLineDownToProtocol(
    PPROTOCOLCB ProtocolCB
    );

VOID
NdisWanProcessStatusIndications(
    PMINIPORTCB MiniportCB
    );

//
// Functions from receive.c
//
NDIS_STATUS
DetectBroadbandFraming(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
DetectFraming(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceivePPP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceiveSLIP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceiveRAS(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceiveARAP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceiveForward(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceiveLLC(
   PLINKCB          LinkCB,
   PRECV_DESC       RecvDesc
   );

VOID
FlushAssemblyLists(
    IN  PBUNDLECB   BundleCB
    );

BOOLEAN
IpIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    );

BOOLEAN
IpxIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    );

BOOLEAN
NbfIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    );

VOID
IndicatePromiscuousRecv(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc,
    RECV_TYPE   RecvType
    );

//
// Functions from request.c
//

NDIS_STATUS
NdisWanSubmitNdisRequest(
    IN  POPENCB             pOpenCB,
    IN  PWAN_REQUEST        WanRequest
    );

NDIS_STATUS
NdisWanOidProc(
    IN  PMINIPORTCB         pMiniportCB,
    IN OUT PNDIS_REQUEST    NdisRequest
    );

NDIS_STATUS
NdisWanCoOidProc(
    IN  PMINIPORTCB         pMiniportCB,
    IN  PCM_VCCB            CmVcCB OPTIONAL,
    IN OUT PNDIS_REQUEST    NdisRequest
    );
//
// Functions from send.c
//
VOID
NdisWanQueueSend(
    IN  PMINIPORTCB     MiniportCB,
    IN  PNDIS_PACKET    NdisPacket
    );

VOID
SendPacketOnBundle(
    PBUNDLECB   BundleCB
    );

BOOLEAN
SendFromPPP(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB,
    PBOOLEAN    PacketSent
    );

BOOLEAN
SendFromProtocol(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB,
    PINT        RetClass,
    PULONG      SendMask,
    PBOOLEAN    PacketSent
    );

BOOLEAN
SendFromFragQueue(
    PBUNDLECB   BundleCB,
    BOOLEAN     SendOne,
    PBOOLEAN    PacketSent
    );

UINT
FramePacket(
    PBUNDLECB       BundleCB,
    PPROTOCOLCB     ProtocolCB,
    PNDIS_PACKET    NdisPacket,
    PLIST_ENTRY     LinkCBList,
    ULONG           SendingLinks,
    INT             Class
    );

UINT
SendOnLegacyLink(
    PSEND_DESC  SendDesc
    );

UINT
SendOnLink(
    PSEND_DESC  SendDesc
    );

NDIS_STATUS
BuildIoPacket(
    IN  PLINKCB             LinkCB,
    IN  PBUNDLECB           BundleCB,
    IN  PNDISWAN_IO_PACKET  pWanIoPacket,
    IN  BOOLEAN             SendImmediate
    );

VOID
CompleteNdisPacket(
    PMINIPORTCB     MiniportCB,
    PPROTOCOLCB     ProtocolCB,
    PNDIS_PACKET    NdisPacket
    );

VOID
IndicatePromiscuousSendPacket(
    PLINKCB         LinkCB,
    PNDIS_PACKET    NdisPacket
    );

VOID
IndicatePromiscuousSendDesc(
    PLINKCB LinkCB,
    PSEND_DESC  SendDesc,
    SEND_TYPE   SendType
    );

VOID
DestroyIoPacket(
    PNDIS_PACKET    NdisPacket
    );

//
// Functions from tapi.c
//

NDIS_STATUS
NdisWanTapiRequestProc(
    POPENCB OpenCB,
    PNDIS_REQUEST   NdisRequest
    );

VOID
NdisWanTapiRequestComplete(
    POPENCB OpenCB,
    PWAN_REQUEST    WanRequest
    );

VOID
NdisWanTapiIndication(
    POPENCB OpenCB,
    PUCHAR          StatusBuffer,
    ULONG           StatusBufferSize
    );

//
// Function from util.c
//

VOID
NdisWanStringToNdisString(
    IN  PNDIS_STRING    pDestString,
    IN  PWSTR           pSrcBuffer
    );

VOID
NdisWanInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    );

VOID
NdisWanCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString OPTIONAL
    );

VOID
NdisWanAllocateAdapterName(
    PNDIS_STRING    Dest,
    PNDIS_STRING    Src
    );

VOID
NdisWanFreeNdisString(
    IN  PNDIS_STRING    NdisString
    );

BOOLEAN
NdisWanCompareNdisString(
    PNDIS_STRING    NdisString1,
    PNDIS_STRING    NdisString2
    );

VOID
NdisWanNdisStringToInteger(
    IN  PNDIS_STRING    Source,
    IN  PULONG          Value
    );

VOID
NdisWanCopyNdisString(
    OUT PNDIS_STRING Dest,
    IN  PNDIS_STRING Src
    );

VOID
NdisWanCopyFromPacketToBuffer(
    IN  PNDIS_PACKET    NdisPacket,
    IN  ULONG           Offset,
    IN  ULONG           BytesToCopy,
    OUT PUCHAR          Buffer,
    OUT PULONG          BytesCopied
    );
    
VOID
NdisWanCopyFromBufferToPacket(
    PUCHAR  Buffer,
    ULONG   BytesToCopy,
    PNDIS_PACKET    NdisPacket,
    ULONG   PacketOffset,
    PULONG  BytesCopied
    );

BOOLEAN
IsLinkValid(
    NDIS_HANDLE LinkHandle,
    BOOLEAN     CheckState,
    PLINKCB     *LinkCB
    );

BOOLEAN
IsBundleValid(
    NDIS_HANDLE BundleHandle,
    BOOLEAN     CheckState,
    PBUNDLECB   *BundleCB
    );

BOOLEAN
AreLinkAndBundleValid(
    NDIS_HANDLE LinkHandle,
    BOOLEAN     CheckState,
    PLINKCB     *LinkCB,
    PBUNDLECB   *BundleCB
    );

VOID
DoDerefBundleCBWork(
    PBUNDLECB   BundleCB
    );

VOID
DoDerefLinkCBWork(
    PLINKCB     LinkCB
    );

VOID
DoDerefClAfSapCBWork(
    PCL_AFSAPCB AfSapCB
    );

VOID
DoDerefCmVcCBWork(
    PCM_VCCB    VcCB
    );

VOID
DerefVc(
    PLINKCB LinkCB
    );

VOID
DeferredWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    );

VOID
BonDWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    );

VOID
CheckBonDInfo(
    PKDPC       Dpc,
    PBUNDLECB   BundleCB,
    PVOID       SysArg1,
    PVOID       SysArg2
    );

VOID
AgeSampleTable(
    PSAMPLE_TABLE   SampleTable
    );

VOID
UpdateSampleTable(
    PSAMPLE_TABLE   SampleTable,
    ULONG           BytesSent
    );

VOID
UpdateBandwidthOnDemand(
    PBOND_INFO  BonDInfo,
    ULONG       Bytes
    );

VOID
CheckUpperThreshold(
    PBUNDLECB       BundleCB
    );

VOID
CheckLowerThreshold(
    PBUNDLECB   BundleCB
    );

NTSTATUS
TransformRegister(
    PVOID                       ClientOpenContext,
    ULONG                       CharsSize,
    PTRANSFORM_CHARACTERISTICS  Chars,
    ULONG                       CapsSize,
    PTRANSFORM_INFO             Caps
    );

VOID
TransformTxComplete(
    NTSTATUS    Status,
    PVOID       TxCtx,
    PMDL        InData,
    PMDL        OutData,
    ULONG       OutDataOffset,
    ULONG       OutDataLength
    );

VOID
TransformRxComplete(
    NTSTATUS    Status,
    PVOID       RxCtx,
    PMDL        InData,
    PMDL        OutData,
    ULONG       OutDataOffset,
    ULONG       OutDataLength
    );

NTSTATUS
TransformSendCtrlPacket(
    PVOID   TxCtx,
    ULONG   DataLength,
    PUCHAR  Data
    );

//
// Functions from vjslip.c
//  
VOID
WanInitVJ(
    VOID
    );

VOID
WanDeleteVJ(
    VOID
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\kdext\api.c ===
#include <wanhelp.h>

DECLARE_API(ndiswancb)
{
	DWORD		Address, BytesRead;
	NDISWANCB	NdisWanCB;

	Address = GetExpression("ndiswan!ndiswancb");

	if (!ReadMemory(Address, &NdisWanCB, sizeof(NDISWANCB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(NDISWANCB)) {

		DisplayNdisWanCB(Address, &NdisWanCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(NdisWanCB));
	}

	return;
}

DECLARE_API(enumwanadaptercb)
{
	DWORD	Address, BytesRead;
	WAN_GLOBAL_LIST	AdapterList;
	PWAN_GLOBAL_LIST	Address1;

	Address = GetExpression("ndiswan!wanadaptercblist");
	Address1 = (PWAN_GLOBAL_LIST)Address;

	if (!ReadMemory(Address, &AdapterList, sizeof(WAN_GLOBAL_LIST), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(WAN_GLOBAL_LIST)) {
		dprintf("WanAdapterCBList: 0x%8.8x\n",Address);
		dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n",
		        AdapterList.Lock.SpinLock, AdapterList.Lock.OldIrql);
		dprintf("   Count: %ld MaxCount: %ld\n",
		        AdapterList.ulCount, AdapterList.ulMaxCount);

		Address = AdapterList.List.Flink;

		while ((PVOID)Address != (PVOID)&Address1->List) {
			WAN_ADAPTERCB	WanAdapterCB;

			if (ReadMemory(Address, &WanAdapterCB, sizeof(WAN_ADAPTERCB), &BytesRead)) {
				DisplayWanAdapterCB(Address, &WanAdapterCB);
			}

			Address = (DWORD)WanAdapterCB.Linkage.Flink;
		}

	} else {

		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(WAN_GLOBAL_LIST));
	}
}

DECLARE_API(wanadaptercb)
{
	DWORD			Address, BytesRead;
	WAN_ADAPTERCB	WanAdapterCB;
	PUCHAR			s = (PSTR)args;
	BOOLEAN			Verbose = FALSE;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("wanadapter <PWANADAPTERCB>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &WanAdapterCB, sizeof(WAN_ADAPTERCB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(WAN_ADAPTERCB)) {

		DisplayWanAdapterCB(Address, &WanAdapterCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(WanAdapterCB));
	}
}

DECLARE_API(enumadaptercb)
{
	DWORD	Address, BytesRead;
	WAN_GLOBAL_LIST	AdapterList;
	PWAN_GLOBAL_LIST	Address1;


	Address = GetExpression("ndiswan!adaptercblist");
	Address1 = (PWAN_GLOBAL_LIST)Address;

	if (!ReadMemory(Address, &AdapterList, sizeof(WAN_GLOBAL_LIST), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(WAN_GLOBAL_LIST)) {

		dprintf("AdapterCBList: 0x%8.8x\n",Address);
		dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n",
		        AdapterList.Lock.SpinLock, AdapterList.Lock.OldIrql);
		dprintf("   Count: %ld MaxCount: %ld\n",
		        AdapterList.ulCount, AdapterList.ulMaxCount);

		Address = AdapterList.List.Flink;

		while ((PVOID)Address != (PVOID)&Address1->List) {
			ADAPTERCB	AdapterCB;

			if (ReadMemory(Address, &AdapterCB, sizeof(ADAPTERCB), &BytesRead)) {
				DisplayAdapterCB(Address, &AdapterCB);
			}

			Address = (DWORD)AdapterCB.Linkage.Flink;
		}
	} else {

		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(WAN_GLOBAL_LIST));
	}
}

DECLARE_API(adaptercb)
{
	DWORD			Address, BytesRead;
	ADAPTERCB		AdapterCB;
	PUCHAR			s = (PSTR)args;
	BOOLEAN			Verbose = FALSE;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("adapter <PADAPTERCB>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &AdapterCB, sizeof(ADAPTERCB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(ADAPTERCB)) {

		DisplayAdapterCB(Address, &AdapterCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(AdapterCB));
	}
}

DECLARE_API(connectiontable)
{
	DWORD		Address, Address1, BytesRead, i, j;
	CONNECTION_TABLE	ConnectionTable;

	Address = GetExpression("ndiswan!connectiontable");

	if (!ReadMemory(Address, &Address1, sizeof(DWORD), &BytesRead)) {
		return;
	}

	if (!ReadMemory(Address1, &ConnectionTable, sizeof(CONNECTION_TABLE), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(CONNECTION_TABLE)) {
		DisplayConnectionTable(Address, &ConnectionTable);

		for (i = 0, j = 0; j < ConnectionTable.ulNumActiveLinks; i++) {
			LINKCB	LinkCB;

			//
			// Get pointer to location in Linktable
			//
			Address = ConnectionTable.LinkArray + i;

			if (!ReadMemory(Address, &Address1, sizeof(DWORD), &BytesRead)) {
				continue;
			}

			if (Address1 != NULL) {

				if (ReadMemory(Address1, &LinkCB, sizeof(LINKCB), &BytesRead)) {
					DisplayLinkCB(Address1, &LinkCB);
					j++;
				}

			}

		}

		for (i = 0, j = 0; j < ConnectionTable.ulNumActiveBundles; i++) {
			BUNDLECB	BundleCB;

			//
			// Get pointer to location in bundletable
			//
			Address = ConnectionTable.BundleArray + i;


			if (!ReadMemory(Address, &Address1, sizeof(DWORD), &BytesRead)) {
				continue;
			}

			if (Address1 != NULL) {

				if (ReadMemory(Address1, &BundleCB, sizeof(BUNDLECB), &BytesRead)) {
					DisplayBundleCB(Address1, &BundleCB);
					j++;
				}
			}

		}

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(CONNECTION_TABLE));
	}
}

DECLARE_API(bundlecb)
{
	DWORD		Address, BytesRead;
	BUNDLECB	BundleCB;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("bundlecb <PBUNDLECB>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &BundleCB, sizeof(BUNDLECB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(BUNDLECB)) {

		DisplayBundleCB(Address, &BundleCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(BUNDLECB));
	}
}

DECLARE_API(linkcb)
{
	DWORD	Address, BytesRead;
	LINKCB	LinkCB;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("linkcb <PLINKCB>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &LinkCB, sizeof(LINKCB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(LINKCB)) {

		DisplayLinkCB(Address, &LinkCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(LINKCB));
	}
}

DECLARE_API(protocolcb)
{
	DWORD		Address, BytesRead;
	PROTOCOLCB	ProtocolCB;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("protocolcb <PPROTOCOLCB>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &ProtocolCB, sizeof(PROTOCOLCB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(PROTOCOLCB)) {

		DisplayProtocolCB(Address, &ProtocolCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(PROTOCOLCB));
	}
}

DECLARE_API(wanpacket)
{
	DWORD		Address, BytesRead;
	NDIS_WAN_PACKET	Packet;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("wanpacket <PNDIS_WAN_PACKET>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &Packet, sizeof(NDIS_WAN_PACKET), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(NDIS_WAN_PACKET)) {

		DisplayWanPacket(Address, &Packet);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(NDIS_WAN_PACKET));
	}
}

DECLARE_API(ndispacket)
{
	DWORD		Address, BytesRead;
	NDIS_PACKET	Packet;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("ndispacket <PNDIS_PACKET>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &Packet, sizeof(NDIS_PACKET), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(NDIS_PACKET)) {

		DisplayNdisPacket(Address, &Packet);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(NDIS_PACKET));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\kdext\display.h ===
VOID
DisplayNdisWanCB(
	DWORD	Address,
	PNDISWANCB	NdisWanCB
	);

VOID
DisplayWanAdapterCB(
	ULONG	Address,
	PWAN_ADAPTERCB	WanAdapterCB
	);

VOID
DisplayAdapterCB(
	ULONG	Address,
	PADAPTERCB	AdapterCB
	);

VOID
DisplayConnectionTable(
	DWORD	Address,
	PCONNECTION_TABLE	ConnectionTable
	);

VOID
DisplayBundleCB(
	DWORD	Address,
	PBUNDLECB	BundleCB
	);

VOID
DisplayProtocolCB(
	DWORD	Address,
	PPROTOCOLCB	ProtocolCB
	);

VOID
DisplayLinkCB(
	DWORD	Address,
	PLINKCB	LinkCB
	);

VOID
DisplayWanPacket(
	DWORD	Address,
	PNDIS_WAN_PACKET	Packet
	);

VOID
DisplayNdisPacket(
	DWORD	Address,
	PNDIS_PACKET	Packet
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\kdext\wanhelp.h ===
/*++

   Copyright (c) 1993  Microsoft Corporation

   Module Name:

      wanhelp

   Abstract:


   Author:

      Thanks - Kyle Brandon

   History:

--*/

#ifndef __WANHELP_H
#define __WANHELP_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <stdio.h>
#include <wdbgexts.h>

#include <srb.h>
#include <io.h>

#include <qos.h>

//#include <imagehlp.h>
//#include <stdlib.h>
//#include <ntverp.h>
//#include <ndismain.h>
//#include <ndismac.h>
//#include <ndismini.h>
//#include <ndiswan.h>
#include "wan.h"
#include "display.h"

//
// support routines.
//
VOID UnicodeToAnsi(PWSTR pws, PSTR ps, ULONG cbLength);


//
// Internal definitions
//

#define	NOT_IMPLEMENTED				0xFACEFEED


#endif // __WANHELP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\kdext\wanhelp.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:


Environment:

    User Mode

--*/

#include <wanhelp.h>

//
// globals
//
EXT_API_VERSION        	ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  	ExtensionApis;
ULONG                  	STeip;
ULONG                  	STebp;
ULONG                  	STesp;
USHORT                 	SavedMajorVersion;
USHORT					SavedMinorVersion;
VOID	UnicodeToAnsi(PWSTR	pws,PSTR ps, ULONG cbLength);
CHAR	Name[1024];

PSTR	gApiDescriptions[] =
{
    "help             - What do you think your reading?\n",
    "ndiswancb        - Dump the contents of the main NdisWan control structure\n",
	"enumwanadaptercb - Dump the head of the WanAdapterCB list\n",
	"wanadaptercb     - Dump the contents of a Wan Miniport Adapter structure\n",
	"enumadaptercb    - Dump the head of the AdapterCB list\n",
	"adaptercb        - Dump the contents of a NdisWan Adapter structure\n",
	"connectiontable  - Dump the connetion table\n",
	"bundlecb         - Dump the bundlecb\n",
	"linkcb           - Dump the linkcb\n",
	"protocolcb       - Dump the protocolcb\n",
	"wanpacket        - Dump the wanpacket\n",
	"ndispacket       - Dump the ndispacket\n",
};

#define MAX_APIS 12

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
BOOLEAN
DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
		case DLL_THREAD_ATTACH:
			DbgBreakPoint();
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

/*++
   Try and keep an accurate list of commands.
--*/
DECLARE_API(help)
{
   UINT  c;

	if (0 == args[0]) {
		for (c = 0; c < MAX_APIS; c++)
			dprintf(gApiDescriptions[c]);
		return;
	}
}

VOID
UnicodeToAnsi(
	PWSTR	pws,
	PSTR	ps,
	ULONG	cbLength
	)
{
	PSTR	Dest = ps;
	PWSTR	Src = pws;
	ULONG	Length = cbLength;

	dprintf("Enter UnicodeToAnsi\n");

	while (Length--) {
		*Dest++ = (CHAR)*Src++;
	}

	dprintf("Exit UnicodeToAnsi\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndiswan\kdext\display.c ===
#include <wanhelp.h>

PSTR MediumType[] =
{
	"NdisMedium802_3",
	"NdisMedium802_5",
	"NdisMediumFddi",
	"NdisMediumWan",
	"NdisMediumLocalTalk",
	"NdisMediumDix",
	"NdisMediumArcnetRaw",
	"NdisMediumArcnet878_2",
	"NdisMediumAtm",
	"NdisMediumWirelessWan",
	"NdisMediumIrda"
};

PSTR WanMediumSubtype[] =
{
    "NdisWanMediumHub",
    "NdisWanMediumX_25",
    "NdisWanMediumIsdn",
    "NdisWanMediumSerial",
    "NdisWanMediumFrameRelay",
    "NdisWanMediumAtm",
    "NdisWanMediumSonet",
    "NdisWanMediumSW56K"
};

PSTR WanHeaderFormat[] =
{
	"NdisWanHeaderNative",       // src/dest based on subtype, followed by NLPID
	"NdisWanHeaderEthernet"      // emulation of ethernet header
};

PSTR HardwareStatus[] =
{
    "NdisHardwareStatusReady",
    "NdisHardwareStatusInitializing",
    "NdisHardwareStatusReset",
    "NdisHardwareStatusClosing",
    "NdisHardwareStatusNotReady"
};

PSTR LinkCBStates[] =
{
	"LinkDown",
	"LinkGoingDown",
	"LinkUp"
};

PSTR BundleCBStates[] =
{
	"BundleDown",
	"BundleGowingDown",
	"BundleUp",
	"BundleRouted",
	"BundleUnrouting"
};

PSTR WanQuality[] =
{
	"NdisWanRaw",
	"NdisWanErrorControl",
	"NdisWanReliable"
};

PSTR DeferredQueueDesc[] =
{
	"ReceiveIndication",
	"SendComplete",
	"StatusIndication",
	"Loopback"
};

VOID
DisplayNdisWanCB(
	DWORD	Address,
	PNDISWANCB	NdisWanCB
	)
{
	dprintf("NdisWanCB: 0x%8.8x\n\n", Address);
	dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n", NdisWanCB->Lock.SpinLock, NdisWanCB->Lock.OldIrql);
	dprintf("   NdisWrapperHandle: 0x%8.8x\n", NdisWanCB->hNdisWrapperHandle);
	dprintf("   ProtocolHandle: 0x%8.8x\n", NdisWanCB->hProtocolHandle);
	dprintf("   NumberOfProtocols: %ld\n", NdisWanCB->ulNumberOfProtocols);
	dprintf("   NumberOfLinks: %ld\n", NdisWanCB->ulNumberOfLinks);
	dprintf("   MiniumFragmentSize: 0x%8.8x\n", NdisWanCB->ulMinFragmentSize);
	dprintf("   TraceLevel: 0x%8.8x\n", NdisWanCB->ulTraceLevel);
	dprintf("   TraceMask: 0x%8.8x\n", NdisWanCB->ulTraceMask);
	dprintf("   DriverObject: 0x%8.8x\n", NdisWanCB->pDriverObject);
	dprintf("   DeviceObject: 0x%8.8x\n", NdisWanCB->pDeviceObject);
	dprintf("   PacketsSent: %ld\n", NdisWanCB->SendCount);
	dprintf("   PacketsCompleted: %ld\n", NdisWanCB->SendCompleteCount);
	dprintf("   IORecvQueueEmpty: %ld\n", NdisWanCB->IORecvError1);
	dprintf("   IORecvBeforMap: %ld\n", NdisWanCB->IORecvError2);
	dprintf("   PromiscuousAdapter: 0x%8.8x\n",NdisWanCB->PromiscuousAdapter);
}

VOID
DisplayWanAdapterCB(
	DWORD	Address,
	PWAN_ADAPTERCB	WanAdapterCB
	)
{
	dprintf("\n\nWanAdapterCB: 0x%8.8x\n", Address);

	dprintf("   Linkage:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
			WanAdapterCB->Linkage.Flink, WanAdapterCB->Linkage.Blink);

	dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n",
			WanAdapterCB->Lock.SpinLock, WanAdapterCB->Lock.OldIrql);

	dprintf("   FreeLinkCBList:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
			WanAdapterCB->FreeLinkCBList.Flink, WanAdapterCB->FreeLinkCBList.Blink);

	dprintf("   NdisBindingHandle: 0x%8.8x\n", WanAdapterCB->hNdisBindingHandle);

	dprintf("   WanRequest: 0x%8.8x\n", WanAdapterCB->pWanRequest);
	dprintf("   LastRequest: 0x%8.8x\n", WanAdapterCB->pLastWanRequest);

	dprintf("   MiniportName: Buffer: 0x%8.8x Length: %ld\n",
			WanAdapterCB->MiniportName.Buffer, WanAdapterCB->MiniportName.Length);

	dprintf("   MediumType: %s\n", MediumType[WanAdapterCB->MediumType]);

	dprintf("   MediumSubType: %s\n", WanMediumSubtype[WanAdapterCB->MediumSubType]);

	dprintf("   WanHeaderFormat: %s\n", WanHeaderFormat[WanAdapterCB->WanHeaderFormat]);

	dprintf("   MaxFrameSize: %ld\n", WanAdapterCB->WanInfo.MaxFrameSize);

	dprintf("   MaxTransmit: %ld\n", WanAdapterCB->WanInfo.MaxTransmit);

	dprintf("   HeaderPadding: %ld\n",WanAdapterCB->WanInfo.HeaderPadding);

	dprintf("   TailPadding: %ld\n",WanAdapterCB->WanInfo.TailPadding);

	dprintf("   Endpoints: %ld\n",WanAdapterCB->WanInfo.Endpoints);

	dprintf("   MemoryFlags: 0x%8.8x\n",WanAdapterCB->WanInfo.MemoryFlags);

	dprintf("   HighestAddress: 0x%8.8x 0x%8.8x\n",
				WanAdapterCB->WanInfo.HighestAcceptableAddress.HighPart,
				WanAdapterCB->WanInfo.HighestAcceptableAddress.LowPart);

	dprintf("   FramingBits: 0x%8.8x\n",WanAdapterCB->WanInfo.FramingBits);

	dprintf("   DesiredACCM: 0x%8.8x\n",WanAdapterCB->WanInfo.DesiredACCM);
}

VOID
DisplayAdapterCB(
	DWORD	Address,
	PADAPTERCB	AdapterCB
	)
{
	DWORD	i;

	dprintf("\n\nAdapterCB: 0x%8.8x\n", Address);

	dprintf("   Linkage:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
			AdapterCB->Linkage.Flink, AdapterCB->Linkage.Blink);

	dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n",
			AdapterCB->Lock.SpinLock, AdapterCB->Lock.OldIrql);

	dprintf("   ReferenceCount: %ld\n", AdapterCB->ulReferenceCount);

	dprintf("   MiniportAdapterHandle: 0x%8.8x\n", AdapterCB->hMiniportHandle);

	dprintf("   Flags: 0x%8.8x\n", AdapterCB->Flags);

	dprintf("   FreeDeferredQueue:\n");
	dprintf("      Head: 0x%8.8x\n", AdapterCB->FreeDeferredQueue.Head);
	dprintf("      Tail: 0x%8.8x\n", AdapterCB->FreeDeferredQueue.Tail);
	dprintf("      Count: %ld\n", AdapterCB->FreeDeferredQueue.Count);
	dprintf("      MaxCount: %ld\n", AdapterCB->FreeDeferredQueue.MaxCount);
	for (i = 0; i < MAX_DEFERRED_QUEUE_TYPES; i++) {
		dprintf("   DeferredQueue: %s\n", DeferredQueueDesc[i]);
		dprintf("      Head: 0x%8.8x\n", AdapterCB->DeferredQueue[i].Head);
		dprintf("      Tail: 0x%8.8x\n", AdapterCB->DeferredQueue[i].Tail);
		dprintf("      Count: %ld\n", AdapterCB->DeferredQueue[i].Count);
		dprintf("      MaxCount: %ld\n", AdapterCB->DeferredQueue[i].MaxCount);
	}

	dprintf("   MediumType: %s\n", MediumType[AdapterCB->MediumType]);

	dprintf("   HardwareStatus: %s\n", HardwareStatus[AdapterCB->HardwareStatus]);

	dprintf("   AdapterName: Buffer: 0x%8.8x Length: %d\n",
			AdapterCB->AdapterName.Buffer, AdapterCB->AdapterName.Length);

	dprintf("   NetworkAddress: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
			AdapterCB->NetworkAddress[0], AdapterCB->NetworkAddress[1], AdapterCB->NetworkAddress[2],
			AdapterCB->NetworkAddress[3], AdapterCB->NetworkAddress[4], AdapterCB->NetworkAddress[5]);

	dprintf("   NumberOfProtocols: %ld\n", AdapterCB->ulNumberofProtocols);

	dprintf("   ProtocolType: 0x%4.4x\n", AdapterCB->ProtocolType);

	dprintf("   NbfBundleCB: 0x%8.8x\n", AdapterCB->NbfBundleCB);
	dprintf("   NbfProtocolHandle: 0x%8.8x\n", AdapterCB->NbfProtocolHandle);

}

VOID
DisplayConnectionTable(
	DWORD	Address,
	PCONNECTION_TABLE	ConnectionTable
	)
{
	dprintf("\n\nConnectionTable: 0x%8.8x\n", Address);
	dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n",
			ConnectionTable->Lock.SpinLock, ConnectionTable->Lock.OldIrql);
	dprintf("   AllocationSize: %ld\n", ConnectionTable->ulAllocationSize);
	dprintf("   ArraySize: %ld\n", ConnectionTable->ulArraySize);
	dprintf("   Number Of Active Links: %ld\n", ConnectionTable->ulNumActiveLinks);
	dprintf("   Number Of Active Bundles: %ld\n", ConnectionTable->ulNumActiveBundles);
	dprintf("   LinkArray: 0x%8.8x\n", ConnectionTable->LinkArray);
	dprintf("   BundleArray: 0x%8.8x\n", ConnectionTable->BundleArray);
}

VOID
DisplayLinkCB(
	DWORD	Address,
	PLINKCB	LinkCB
	)
{
	dprintf("\n\nLinkCB: 0x%8.8x\n", Address);
	dprintf("   Linkage:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	LinkCB->Linkage.Flink, LinkCB->Linkage.Blink);
	dprintf("   Handle: 0x%8.8x\n", LinkCB->hLinkHandle);
	dprintf("   User Context: 0x%8.8x\n", LinkCB->hLinkContext);
	dprintf("   ReferenceCount: %ld\n", LinkCB->ulReferenceCount);
	dprintf("   State: %s\n", LinkCBStates[LinkCB->State]);
	dprintf("   WanAdapterCB: 0x%8.8x\n", LinkCB->WanAdapterCB);
	dprintf("   BundleCB: 0x%8.8x\n", LinkCB->BundleCB);
	dprintf("   WanMiniport Lineup Context: 0x%8.8x\n", LinkCB->NdisLinkHandle);
	dprintf("   WanPacketPool:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	LinkCB->WanPacketPool.Flink, LinkCB->WanPacketPool.Blink);
	dprintf("   WanPacketCount: %ld\n", LinkCB->ulWanPacketCount);
	dprintf("   OutstandingFrames: %ld\n", LinkCB->OutstandingFrames);
	dprintf("   LastRecvSeqNumber: 0x%8.8x\n", LinkCB->LastRecvSeqNumber);
	dprintf("   RecvFragmentsLost: 0x%8.8x\n", LinkCB->RecvFragmentsLost);
	dprintf("   LinkBandwidth: %ld\n", LinkCB->ulBandwidth);
	dprintf("   LinkInfo:\n");
	dprintf("      MaxSendFrameSize: %ld\n", LinkCB->LinkInfo.MaxSendFrameSize);
	dprintf("      MaxRecvFrameSize: %ld\n", LinkCB->LinkInfo.MaxRecvFrameSize);
	dprintf("      HeaderPadding: %ld\n", LinkCB->LinkInfo.HeaderPadding);
	dprintf("      TailPadding: %ld\n", LinkCB->LinkInfo.TailPadding);
	dprintf("      SendFramingBits: 0x%8.8x\n", LinkCB->LinkInfo.SendFramingBits);
	dprintf("      RecvFramingBits: 0x%8.8x\n", LinkCB->LinkInfo.RecvFramingBits);
	dprintf("      SendCompressionBits: 0x%8.8x\n", LinkCB->LinkInfo.SendCompressionBits);
	dprintf("      RecvCompressionBits: 0x%8.8x\n", LinkCB->LinkInfo.RecvCompressionBits);
	dprintf("      SendACCM: 0x%8.8x\n", LinkCB->LinkInfo.SendACCM);
	dprintf("      RecvACCM: 0x%8.8x\n", LinkCB->LinkInfo.RecvACCM);
	dprintf("      MaxRSendFrameSize: %ld\n", LinkCB->LinkInfo.MaxRSendFrameSize);
	dprintf("      MaxRRecvFrameSize: %ld\n", LinkCB->LinkInfo.MaxRRecvFrameSize);
	dprintf("   LineUpInfo:\n");
	dprintf("      LinkSpeed: %ld\n", LinkCB->LineUpInfo.LinkSpeed);
	dprintf("      Quality: 0x%8.8x\n", LinkCB->LineUpInfo.Quality);
	dprintf("      SendWindow: %d\n", LinkCB->LineUpInfo.SendWindow);
	dprintf("      ConnectionWrapperID: 0x%8.8x\n", LinkCB->LineUpInfo.ConnectionWrapperID);
	dprintf("      NdisLinkHandle: 0x%8.8x\n", LinkCB->LineUpInfo.NdisLinkHandle);
	dprintf("      NdisLinkContext: 0x%8.8x\n", LinkCB->LineUpInfo.NdisLinkContext);
	dprintf("   FriendlyName: %s\n", LinkCB->Name);
	dprintf("   LinkStats:\n");
	dprintf("      BytesTransmitted: %ld\n", LinkCB->LinkStats.BytesTransmitted);
	dprintf("      BytesReceived: %ld\n", LinkCB->LinkStats.BytesReceived);
	dprintf("      FramesTransmitted: %ld\n", LinkCB->LinkStats.FramesTransmitted);
	dprintf("      FramesReceived: %ld\n", LinkCB->LinkStats.FramesReceived);

	dprintf("      CRCErrors: %ld\n", LinkCB->LinkStats.CRCErrors);
	dprintf("      TimeoutErrors: %ld\n", LinkCB->LinkStats.TimeoutErrors);
	dprintf("      AlignmentErrors: %ld\n", LinkCB->LinkStats.AlignmentErrors);
	dprintf("      SerialOverrunErrors: %ld\n", LinkCB->LinkStats.SerialOverrunErrors);
	dprintf("      FramingErrors: %ld\n", LinkCB->LinkStats.FramingErrors);
	dprintf("      BufferOverrunErrors: %ld\n", LinkCB->LinkStats.BufferOverrunErrors);
	dprintf("      ByteTransmittedUncompressed: %ld\n", LinkCB->LinkStats.BytesTransmittedUncompressed);
	dprintf("      BytesReceivedUncompressed: %ld\n", LinkCB->LinkStats.BytesReceivedUncompressed);
	dprintf("      BytesTransmittedCompressed: %ld\n", LinkCB->LinkStats.BytesTransmittedCompressed);
	dprintf("      BytesReceivedCompressed: %ld\n", LinkCB->LinkStats.BytesReceivedCompressed);
}

VOID
DisplayBundleCB(
	DWORD	Address,
	PBUNDLECB	BundleCB
	)
{
	DWORD	i;
	ENCRYPTION_INFO *EncryptInfo;
	A_SHA_CTX	*SHAContext;
	A_SHA_COMM_CTX	*SHACommon;
	PUCHAR	LMSessionKey, UserSessionKey, Challenge;


	dprintf("\n\nBundleCB: 0x%8.8x\n", Address);
	dprintf("   Handle: 0x%8.8x\n",BundleCB->hBundleHandle);
	dprintf("   ReferenceCount: %ld\n",BundleCB->ulReferenceCount);
	dprintf("   State: %s\n",BundleCBStates[BundleCB->State]);
	dprintf("   LinkCBList:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	BundleCB->LinkCBList.Flink, BundleCB->LinkCBList.Blink);
	dprintf("   LinkCBCount: %ld\n",BundleCB->ulLinkCBCount);
	dprintf("   FramingInfo:\n");
	dprintf("      SendFramingBits: 0x%8.8x\n", BundleCB->FramingInfo.SendFramingBits);
	dprintf("      RecvFramingBits: 0x%8.8x\n", BundleCB->FramingInfo.RecvFramingBits);
	dprintf("      MaxRSendFrameSize: %ld\n", BundleCB->FramingInfo.MaxRSendFrameSize);
	dprintf("      MaxRRecvFrameSize: %ld\n", BundleCB->FramingInfo.MaxRRecvFrameSize);
	dprintf("   NextLinkToXmit: 0x%8.8x\n",BundleCB->NextLinkToXmit);
	dprintf("   SendingLinks: %d\n", BundleCB->SendingLinks);
	dprintf("   SendPacketQueue:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	BundleCB->SendPacketQueue.Flink, BundleCB->SendPacketQueue.Blink);
	dprintf("   SendSequenceNumber: 0x%8.8x\n", BundleCB->SendSeqNumber);
	dprintf("   SendSequenceMask: 0x%8.8x\n", BundleCB->SendSeqMask);
	dprintf("   SendSequenceTest: 0x%8.8x\n", BundleCB->SendSeqTest);
	dprintf("   Flags: 0x%8.8x\n",BundleCB->Flags);
	dprintf("   OutstandingFrames: %ld\n",BundleCB->OutstandingFrames);
	dprintf("   RecvDescPool:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	BundleCB->RecvDescPool.Flink, BundleCB->RecvDescPool.Blink);
	dprintf("   RecvDesc Count: %ld\n", BundleCB->RecvDescCount);
	dprintf("   RecvDesc Max Count: %ld\n", BundleCB->RecvDescMax);
	dprintf("   RecvDescAssemblyList:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	BundleCB->RecvDescAssemblyList.Flink, BundleCB->RecvDescAssemblyList.Blink);
	dprintf("   RecvDescHole: 0x%8.8x\n", BundleCB->RecvDescHole);
	dprintf("   MinReceivedSeqNumber: 0x%8.8x\n", BundleCB->MinReceivedSeqNumber);
	dprintf("   RecvSeqMask: 0x%8.8x\n", BundleCB->RecvSeqMask);
	dprintf("   RecvSeqTest: 0x%8.8x\n", BundleCB->RecvSeqTest);
	dprintf("   RecvFragmentsLost: %ld\n", BundleCB->RecvFragmentsLost);
	dprintf("   LastRecvNonIdleData: %ld%ld\n", BundleCB->LastRecvNonIdleData.HighPart, BundleCB->LastRecvNonIdleData.LowPart);
	dprintf("   ProtocolCBTable: 0x%8.8x\n",BundleCB->ProtocolCBTable);
	dprintf("   Number Of Routes: %ld\n",BundleCB->ulNumberOfRoutes);
	dprintf("   ProtocolCBList:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	BundleCB->ProtocolCBList.Flink, BundleCB->ProtocolCBList.Blink);
	dprintf("   SendMask: 0x%8.8x\n",BundleCB->SendMask);
	dprintf("   LineUpInfo:\n");
	dprintf("      BundleSpeed: %ld\n", BundleCB->LineUpInfo.BundleSpeed);
	dprintf("      MaxSendSize: %ld\n", BundleCB->LineUpInfo.ulMaximumTotalSize);
	dprintf("      LinkQuality: %s\n", WanQuality[BundleCB->LineUpInfo.Quality]);
	dprintf("      SendWindow: %d\n", BundleCB->LineUpInfo.usSendWindow);
	dprintf("   SendVJInfo:\n");
	dprintf("      IPCompressionProtocol: 0x%4.4x\n", BundleCB->SendVJInfo.IPCompressionProtocol);
	dprintf("      MaxSlotID: %d\n", BundleCB->SendVJInfo.MaxSlotID);
	dprintf("      CompSlotID: %d\n", BundleCB->SendVJInfo.CompSlotID);
	dprintf("   RecvVJInfo:\n");
	dprintf("      IPCompressionProtocol: 0x%4.4x\n", BundleCB->RecvVJInfo.IPCompressionProtocol);
	dprintf("      MaxSlotID: %d\n", BundleCB->RecvVJInfo.MaxSlotID);
	dprintf("      CompSlotID: %d\n", BundleCB->RecvVJInfo.CompSlotID);
	dprintf("   VJCompress: 0x%8.8x\n", BundleCB->VJCompress);

	LMSessionKey = BundleCB->SendCompInfo.LMSessionKey;
	UserSessionKey = BundleCB->SendCompInfo.UserSessionKey;
	Challenge = BundleCB->SendCompInfo.Challenge;

	dprintf("   SendCompInfo:\n");
	dprintf("      MSCompType: 0x%8.8x\n", BundleCB->SendCompInfo.MSCompType);
	dprintf("      CompType: 0x%2.2x\n", BundleCB->SendCompInfo.CompType);
	dprintf("      CompLength: 0x%4.4x\n", BundleCB->SendCompInfo.CompLength);
	dprintf("      LMSessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	LMSessionKey[0], LMSessionKey[1], LMSessionKey[2], LMSessionKey[3],
    LMSessionKey[4], LMSessionKey[5], LMSessionKey[6], LMSessionKey[7]);
	dprintf("      UserSessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	UserSessionKey[0], UserSessionKey[1], UserSessionKey[2], UserSessionKey[3],
    UserSessionKey[4], UserSessionKey[5], UserSessionKey[6], UserSessionKey[7]);
	dprintf("                      0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	UserSessionKey[8], UserSessionKey[9], UserSessionKey[10], UserSessionKey[11],
    UserSessionKey[12], UserSessionKey[13], UserSessionKey[14], UserSessionKey[15]);
	dprintf("      Challenge: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	Challenge[0], Challenge[1], Challenge[2], Challenge[3],
    Challenge[4], Challenge[5], Challenge[6], Challenge[7]);
	dprintf("   SendCompressContext: 0x%8.8x\n", BundleCB->SendCompressContext);

	LMSessionKey = BundleCB->RecvCompInfo.LMSessionKey;
	UserSessionKey = BundleCB->RecvCompInfo.UserSessionKey;
	Challenge = BundleCB->RecvCompInfo.Challenge;

	dprintf("   RecvCompInfo:\n");
	dprintf("      MSCompType: 0x%8.8x\n", BundleCB->RecvCompInfo.MSCompType);
	dprintf("      CompType: 0x%2.2x\n", BundleCB->RecvCompInfo.CompType);
	dprintf("      CompLength: 0x%4.4x\n", BundleCB->RecvCompInfo.CompLength);
	dprintf("      LMSessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	LMSessionKey[0], LMSessionKey[1], LMSessionKey[2], LMSessionKey[3],
    LMSessionKey[4], LMSessionKey[5], LMSessionKey[6], LMSessionKey[7]);
	dprintf("      UserSessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	UserSessionKey[0], UserSessionKey[1], UserSessionKey[2], UserSessionKey[3],
    UserSessionKey[4], UserSessionKey[5], UserSessionKey[6], UserSessionKey[7]);
	dprintf("                      0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	UserSessionKey[8], UserSessionKey[9], UserSessionKey[10], UserSessionKey[11],
    UserSessionKey[12], UserSessionKey[13], UserSessionKey[14], UserSessionKey[15]);
	dprintf("      Challenge: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	Challenge[0], Challenge[1], Challenge[2], Challenge[3],
    Challenge[4], Challenge[5], Challenge[6], Challenge[7]);
	dprintf("   RecvCompressContext: 0x%8.8x\n", BundleCB->RecvCompressContext);

	EncryptInfo = &BundleCB->SendEncryptInfo;
	dprintf("   SendEncryptInfo:\n");
	dprintf("      StartKey  : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->StartKey[0],EncryptInfo->StartKey[1],
	EncryptInfo->StartKey[2],EncryptInfo->StartKey[3],
	EncryptInfo->StartKey[4],EncryptInfo->StartKey[5],
	EncryptInfo->StartKey[6],EncryptInfo->StartKey[7]);
	dprintf("                : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->StartKey[8],EncryptInfo->StartKey[9],
	EncryptInfo->StartKey[10],EncryptInfo->StartKey[11],
	EncryptInfo->StartKey[12],EncryptInfo->StartKey[13],
	EncryptInfo->StartKey[14],EncryptInfo->StartKey[15]);
	dprintf("      SessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->SessionKey[0],EncryptInfo->SessionKey[1],
	EncryptInfo->SessionKey[2],EncryptInfo->SessionKey[3],
	EncryptInfo->SessionKey[4],EncryptInfo->SessionKey[5],
	EncryptInfo->SessionKey[6],EncryptInfo->SessionKey[7]);
	dprintf("                : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->SessionKey[8], EncryptInfo->SessionKey[9],
	EncryptInfo->SessionKey[10],EncryptInfo->SessionKey[11],
	EncryptInfo->SessionKey[12],EncryptInfo->SessionKey[13],
	EncryptInfo->SessionKey[14],EncryptInfo->SessionKey[15]);
	dprintf("      SessionKeyLength: %ld\n", EncryptInfo->SessionKeyLength);

#if 0
	SHAContext = (A_SHA_CTX*)&EncryptInfo->Context;
	SHACommon = &SHAContext->commonContext;
	dprintf("      SHAContext:\n");
	dprintf("         FinishFlag: 0x%8.8x\n", SHAContext->FinishFlag);
	dprintf("         HashVal: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHAContext->HashVal[0], SHAContext->HashVal[1], SHAContext->HashVal[2], SHAContext->HashVal[3], SHAContext->HashVal[4],
	SHAContext->HashVal[5], SHAContext->HashVal[6], SHAContext->HashVal[7], SHAContext->HashVal[8], SHAContext->HashVal[9]);
	dprintf("                  0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHAContext->HashVal[10], SHAContext->HashVal[11], SHAContext->HashVal[12], SHAContext->HashVal[13], SHAContext->HashVal[14],
	SHAContext->HashVal[15], SHAContext->HashVal[16], SHAContext->HashVal[17], SHAContext->HashVal[18], SHAContext->HashVal[19]);
	dprintf("         state: 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x\n",
	SHACommon->state[0], SHACommon->state[1], SHACommon->state[2], SHACommon->state[3], SHACommon->state[4]);
	dprintf("         count: %ld %ld\n", SHACommon->count[0], SHACommon->count[1]);
	dprintf("         buffer: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[0], SHACommon->buffer[1], SHACommon->buffer[2], SHACommon->buffer[3], SHACommon->buffer[4],
	SHACommon->buffer[5], SHACommon->buffer[6], SHACommon->buffer[7]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[8], SHACommon->buffer[9], SHACommon->buffer[10], SHACommon->buffer[11], SHACommon->buffer[12],
	SHACommon->buffer[13], SHACommon->buffer[14], SHACommon->buffer[15]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[16], SHACommon->buffer[17], SHACommon->buffer[18], SHACommon->buffer[19], SHACommon->buffer[20],
	SHACommon->buffer[21], SHACommon->buffer[22], SHACommon->buffer[23]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[24], SHACommon->buffer[25], SHACommon->buffer[26], SHACommon->buffer[27], SHACommon->buffer[28],
	SHACommon->buffer[29], SHACommon->buffer[30], SHACommon->buffer[31]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[32], SHACommon->buffer[33], SHACommon->buffer[34], SHACommon->buffer[35], SHACommon->buffer[36],
	SHACommon->buffer[37], SHACommon->buffer[38], SHACommon->buffer[39]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[40], SHACommon->buffer[41], SHACommon->buffer[42], SHACommon->buffer[43], SHACommon->buffer[44],
	SHACommon->buffer[45], SHACommon->buffer[46], SHACommon->buffer[47]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[48], SHACommon->buffer[49], SHACommon->buffer[50], SHACommon->buffer[51], SHACommon->buffer[52],
	SHACommon->buffer[53], SHACommon->buffer[54], SHACommon->buffer[55]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[56], SHACommon->buffer[57], SHACommon->buffer[58], SHACommon->buffer[59], SHACommon->buffer[60],
	SHACommon->buffer[61], SHACommon->buffer[62], SHACommon->buffer[63]);
	dprintf("   SendRC4Key: 0x%8.8x\n", BundleCB->SendRC4Key);
#endif

	EncryptInfo = &BundleCB->RecvEncryptInfo;
	dprintf("   RecvEncryptInfo:\n");
	dprintf("      StartKey  : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->StartKey[0],EncryptInfo->StartKey[1],
	EncryptInfo->StartKey[2],EncryptInfo->StartKey[3],
	EncryptInfo->StartKey[4],EncryptInfo->StartKey[5],
	EncryptInfo->StartKey[6],EncryptInfo->StartKey[7]);
	dprintf("                : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->StartKey[8],EncryptInfo->StartKey[9],
	EncryptInfo->StartKey[10],EncryptInfo->StartKey[11],
	EncryptInfo->StartKey[12],EncryptInfo->StartKey[13],
	EncryptInfo->StartKey[14],EncryptInfo->StartKey[15]);
	dprintf("      SessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->SessionKey[0],EncryptInfo->SessionKey[1],
	EncryptInfo->SessionKey[2],EncryptInfo->SessionKey[3],
	EncryptInfo->SessionKey[4],EncryptInfo->SessionKey[5],
	EncryptInfo->SessionKey[6],EncryptInfo->SessionKey[7]);
	dprintf("                : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->SessionKey[8], EncryptInfo->SessionKey[9],
	EncryptInfo->SessionKey[10],EncryptInfo->SessionKey[11],
	EncryptInfo->SessionKey[12],EncryptInfo->SessionKey[13],
	EncryptInfo->SessionKey[14],EncryptInfo->SessionKey[15]);
	dprintf("      SessionKeyLength: %ld\n", EncryptInfo->SessionKeyLength);

#if 0
	SHAContext = (A_SHA_CTX*)&EncryptInfo->Context;
	SHACommon = &SHAContext->commonContext;
	dprintf("      SHAContext:\n");
	dprintf("         FinishFlag: 0x%8.8x\n", SHAContext->FinishFlag);
	dprintf("         HashVal: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHAContext->HashVal[0], SHAContext->HashVal[1], SHAContext->HashVal[2], SHAContext->HashVal[3], SHAContext->HashVal[4],
	SHAContext->HashVal[5], SHAContext->HashVal[6], SHAContext->HashVal[7], SHAContext->HashVal[8], SHAContext->HashVal[9]);
	dprintf("                  0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHAContext->HashVal[10], SHAContext->HashVal[11], SHAContext->HashVal[12], SHAContext->HashVal[13], SHAContext->HashVal[14],
	SHAContext->HashVal[15], SHAContext->HashVal[16], SHAContext->HashVal[17], SHAContext->HashVal[18], SHAContext->HashVal[19]);
	dprintf("         state: 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x\n",
	SHACommon->state[0], SHACommon->state[1], SHACommon->state[2], SHACommon->state[3], SHACommon->state[4]);
	dprintf("         count: %ld %ld\n", SHACommon->count[0], SHACommon->count[1]);
	dprintf("         buffer: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[0], SHACommon->buffer[1], SHACommon->buffer[2], SHACommon->buffer[3], SHACommon->buffer[4],
	SHACommon->buffer[5], SHACommon->buffer[6], SHACommon->buffer[7]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[8], SHACommon->buffer[9], SHACommon->buffer[10], SHACommon->buffer[11], SHACommon->buffer[12],
	SHACommon->buffer[13], SHACommon->buffer[14], SHACommon->buffer[15]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[16], SHACommon->buffer[17], SHACommon->buffer[18], SHACommon->buffer[19], SHACommon->buffer[20],
	SHACommon->buffer[21], SHACommon->buffer[22], SHACommon->buffer[23]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[24], SHACommon->buffer[25], SHACommon->buffer[26], SHACommon->buffer[27], SHACommon->buffer[28],
	SHACommon->buffer[29], SHACommon->buffer[30], SHACommon->buffer[31]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[32], SHACommon->buffer[33], SHACommon->buffer[34], SHACommon->buffer[35], SHACommon->buffer[36],
	SHACommon->buffer[37], SHACommon->buffer[38], SHACommon->buffer[39]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[40], SHACommon->buffer[41], SHACommon->buffer[42], SHACommon->buffer[43], SHACommon->buffer[44],
	SHACommon->buffer[45], SHACommon->buffer[46], SHACommon->buffer[47]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[48], SHACommon->buffer[49], SHACommon->buffer[50], SHACommon->buffer[51], SHACommon->buffer[52],
	SHACommon->buffer[53], SHACommon->buffer[54], SHACommon->buffer[55]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[56], SHACommon->buffer[57], SHACommon->buffer[58], SHACommon->buffer[59], SHACommon->buffer[60],
	SHACommon->buffer[61], SHACommon->buffer[62], SHACommon->buffer[63]);
#endif
	dprintf("   RecvRC4Key: 0x%8.8x\n", BundleCB->RecvRC4Key);

	dprintf("   SCoherencyCounter: 0x%4.4x\n", BundleCB->SCoherencyCounter);
	dprintf("   RCoherencyCounter: 0x%4.4x\n", BundleCB->RCoherencyCounter);
	dprintf("   LastRC4Reset: 0x%4.4x\n", BundleCB->LastRC4Reset);
	dprintf("   CCPIdentifier: 0x%4.4x\n", BundleCB->CCPIdentifier);

#ifdef BANDWIDTH_ON_DEMAND
	dprintf("   UpperBonDInfo:\n");
	dprintf("      BytesThreshold: %ld\n", BundleCB->UpperBonDInfo.ulBytesThreshold);
	dprintf("      PercentBandwidth: %d\n", BundleCB->UpperBonDInfo.usPercentBandwidth);
	dprintf("      SecondsInSamplePeriod: %ld\n", BundleCB->UpperBonDInfo.ulSecondsInSamplePeriod);
	dprintf("      State: 0x%8.8x\n", BundleCB->UpperBonDInfo.State);
	dprintf("      StartTime: 0x%8.8x%8.8x\n",
	BundleCB->UpperBonDInfo.StartTime.HighPart, BundleCB->UpperBonDInfo.StartTime.LowPart);
	dprintf("      SampleTable:\n");
	dprintf("         FirstIndex: %ld\n", BundleCB->UpperBonDInfo.SampleTable.ulFirstIndex);
	dprintf("         CurrentIndex: %ld\n", BundleCB->UpperBonDInfo.SampleTable.ulCurrentIndex);
	dprintf("         CurrentSampleByteCount: %ld\n", BundleCB->UpperBonDInfo.SampleTable.ulCurrentSampleByteCount);
	dprintf("         SampleArraySize: %ld\n", BundleCB->UpperBonDInfo.SampleTable.ulSampleArraySize);
	dprintf("         SampleRate: 0x%8.8x%8.8x\n",
	BundleCB->UpperBonDInfo.SampleTable.SampleRate.HighPart, BundleCB->UpperBonDInfo.SampleTable.SampleRate.LowPart);
	dprintf("         SamplePeriod: 0x%8.8x%8.8x\n",
	BundleCB->UpperBonDInfo.SampleTable.SamplePeriod.HighPart, BundleCB->UpperBonDInfo.SampleTable.SamplePeriod.LowPart);
	dprintf("         SampleTable:\n");
	for (i = 0; i < SAMPLE_ARRAY_SIZE; i++) {
		dprintf("         Sample %d:\n", i);
		dprintf("            BytesThisSend: %ld\n",BundleCB->UpperBonDInfo.SampleTable.SampleArray[i].ulBytesThisSend);
		dprintf("            ReferenceCount: %ld\n",BundleCB->UpperBonDInfo.SampleTable.SampleArray[i].ulReferenceCount);
		dprintf("            TimeStample: 0x%8.8x%8.8x\n",
		BundleCB->UpperBonDInfo.SampleTable.SampleArray[i].TimeStamp.HighPart, BundleCB->UpperBonDInfo.SampleTable.SampleArray[i].TimeStamp.LowPart);
	}
	dprintf("   LowerBonDInfo:\n");
	dprintf("      BytesThreshold: %ld\n", BundleCB->LowerBonDInfo.ulBytesThreshold);
	dprintf("      PercentBandwidth: %d\n", BundleCB->LowerBonDInfo.usPercentBandwidth);
	dprintf("      SecondsInSamplePeriod: %ld\n", BundleCB->LowerBonDInfo.ulSecondsInSamplePeriod);
	dprintf("      State: 0x%8.8x\n", BundleCB->LowerBonDInfo.State);
	dprintf("      StartTime: 0x%8.8x%8.8x\n",
	BundleCB->LowerBonDInfo.StartTime.HighPart, BundleCB->LowerBonDInfo.StartTime.LowPart);
	dprintf("      SampleTable:\n");
	dprintf("         FirstIndex: %ld\n", BundleCB->LowerBonDInfo.SampleTable.ulFirstIndex);
	dprintf("         CurrentIndex: %ld\n", BundleCB->LowerBonDInfo.SampleTable.ulCurrentIndex);
	dprintf("         CurrentSampleByteCount: %ld\n", BundleCB->LowerBonDInfo.SampleTable.ulCurrentSampleByteCount);
	dprintf("         SampleArraySize: %ld\n", BundleCB->LowerBonDInfo.SampleTable.ulSampleArraySize);
	dprintf("         SampleRate: 0x%8.8x%8.8x\n",
	BundleCB->LowerBonDInfo.SampleTable.SampleRate.HighPart, BundleCB->LowerBonDInfo.SampleTable.SampleRate.LowPart);
	dprintf("         SamplePeriod: 0x%8.8x%8.8x\n",
	BundleCB->LowerBonDInfo.SampleTable.SamplePeriod.HighPart, BundleCB->LowerBonDInfo.SampleTable.SamplePeriod.LowPart);
	dprintf("         SampleArray:\n");
	for (i = 0; i < SAMPLE_ARRAY_SIZE; i++) {
		dprintf("         Sample %d:\n", i);
		dprintf("            BytesThisSend: %ld\n",BundleCB->LowerBonDInfo.SampleTable.SampleArray[i].ulBytesThisSend);
		dprintf("            ReferenceCount: %ld\n",BundleCB->LowerBonDInfo.SampleTable.SampleArray[i].ulReferenceCount);
		dprintf("            TimeStample: 0x%8.8x%8.8x\n",
		BundleCB->LowerBonDInfo.SampleTable.SampleArray[i].TimeStamp.HighPart, BundleCB->LowerBonDInfo.SampleTable.SampleArray[i].TimeStamp.LowPart);
	}
#endif

	dprintf("   FriendlyName: %s\n", BundleCB->Name);
	dprintf("   BundleStats:\n");
	dprintf("      BytesTransmitted: %ld\n", BundleCB->BundleStats.BytesTransmitted);
	dprintf("      BytesReceived: %ld\n", BundleCB->BundleStats.BytesReceived);
	dprintf("      FramesTransmitted: %ld\n", BundleCB->BundleStats.FramesTransmitted);
	dprintf("      FramesReceived: %ld\n", BundleCB->BundleStats.FramesReceived);

	dprintf("      CRCErrors: %ld\n", BundleCB->BundleStats.CRCErrors);
	dprintf("      TimeoutErrors: %ld\n", BundleCB->BundleStats.TimeoutErrors);
	dprintf("      AlignmentErrors: %ld\n", BundleCB->BundleStats.AlignmentErrors);
	dprintf("      SerialOverrunErrors: %ld\n", BundleCB->BundleStats.SerialOverrunErrors);
	dprintf("      FramingErrors: %ld\n", BundleCB->BundleStats.FramingErrors);
	dprintf("      BufferOverrunErrors: %ld\n", BundleCB->BundleStats.BufferOverrunErrors);
	dprintf("      ByteTransmittedUncompressed: %ld\n", BundleCB->BundleStats.BytesTransmittedUncompressed);
	dprintf("      BytesReceivedUncompressed: %ld\n", BundleCB->BundleStats.BytesReceivedUncompressed);
	dprintf("      BytesTransmittedCompressed: %ld\n", BundleCB->BundleStats.BytesTransmittedCompressed);
	dprintf("      BytesReceivedCompressed: %ld\n", BundleCB->BundleStats.BytesReceivedCompressed);
}

VOID
DisplayProtocolCB(
	DWORD	Address,
	PPROTOCOLCB	ProtocolCB
	)
{
	DWORD	i;

	dprintf("\n\nProtocolCB: 0x%8.8x\n", Address);
	dprintf("   Linkage:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	ProtocolCB->Linkage.Flink, ProtocolCB->Linkage.Blink);
	dprintf("   ProtocolHandle: 0x%8.8x\n", ProtocolCB->hProtocolHandle);
	dprintf("   ReferenceCount: %ld\n", ProtocolCB->ulReferenceCount);
	dprintf("   HeadNdisPacketQueue: 0x%8.8x\n", ProtocolCB->HeadNdisPacketQueue);
	dprintf("   TailNdisPacketQueue: 0x%8.8x\n", ProtocolCB->TailNdisPacketQueue);
	dprintf("   SendMaskBit: 0x%8.8x\n", ProtocolCB->SendMaskBit);
	dprintf("   AdapterCB: 0x%8.8x\n", ProtocolCB->AdapterCB);
	dprintf("   BundleCB: 0x%8.8x\n", ProtocolCB->BundleCB);
	dprintf("   Flags: 0x%8.8x\n", ProtocolCB->Flags);
	dprintf("   ProtocolType: 0x%4.4x\n", ProtocolCB->usProtocolType);
	dprintf("   PPP ProtocolID: 0x%4.4x\n", ProtocolCB->usPPPProtocolID);
	dprintf("   LastRecvNonIdleData: %ld%ld\n", ProtocolCB->LastRecvNonIdleData.HighPart, ProtocolCB->LastRecvNonIdleData.LowPart);
	dprintf("	NonIdleDetectFunc: 0x%8.8x\n", ProtocolCB->NonIdleDetectFunc);

#ifdef BANDWIDTH_ON_DEMAND
	dprintf("   Priority: %ld\n", ProtocolCB->usPriority);
	dprintf("   Bytes Quota: %ld\n", ProtocolCB->ulByteQuota);
	dprintf("      SampleTable:\n");
	dprintf("         FirstIndex: %ld\n", ProtocolCB->SampleTable.ulFirstIndex);
	dprintf("         CurrentIndex: %ld\n", ProtocolCB->SampleTable.ulCurrentIndex);
	dprintf("         CurrentSampleByteCount: %ld\n", ProtocolCB->SampleTable.ulCurrentSampleByteCount);
	dprintf("         SampleArraySize: %ld\n", ProtocolCB->SampleTable.ulSampleArraySize);
	dprintf("         SampleRate: 0x%8.8x%8.8x\n",
	ProtocolCB->SampleTable.SampleRate.HighPart, ProtocolCB->SampleTable.SampleRate.LowPart);
	dprintf("         SamplePeriod: 0x%8.8x%8.8x\n",
	ProtocolCB->SampleTable.SamplePeriod.HighPart, ProtocolCB->SampleTable.SamplePeriod.LowPart);
	dprintf("         SampleArray:\n");
	for (i = 0; i < SAMPLE_ARRAY_SIZE; i++) {
		dprintf("         Sample %d:\n", i);
		dprintf("            BytesThisSend: %ld\n",ProtocolCB->SampleTable.SampleArray[i].ulBytesThisSend);
		dprintf("            ReferenceCount: %ld\n",ProtocolCB->SampleTable.SampleArray[i].ulReferenceCount);
		dprintf("            TimeStample: 0x%8.8x%8.8x\n",
		ProtocolCB->SampleTable.SampleArray[i].TimeStamp.HighPart, ProtocolCB->SampleTable.SampleArray[i].TimeStamp.LowPart);
	}
#endif

	dprintf("   TransportHandle: 0x%8.8x\n", ProtocolCB->hTransportHandle);
	dprintf("   NdisWanAddress: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
			ProtocolCB->NdisWanAddress[0], ProtocolCB->NdisWanAddress[1], ProtocolCB->NdisWanAddress[2],
			ProtocolCB->NdisWanAddress[3], ProtocolCB->NdisWanAddress[4], ProtocolCB->NdisWanAddress[5]);
	dprintf("   TransportAddress: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
			ProtocolCB->TransportAddress[0], ProtocolCB->TransportAddress[1], ProtocolCB->TransportAddress[2],
			ProtocolCB->TransportAddress[3], ProtocolCB->TransportAddress[4], ProtocolCB->TransportAddress[5]);
	dprintf("   DeviceName: Buffer: 0x%8.8x Length: %ld\n",
			ProtocolCB->DeviceName.Buffer, ProtocolCB->DeviceName.Length);
}

VOID
DisplayWanPacket(
	DWORD	Address,
	PNDIS_WAN_PACKET	Packet
	)
{

	dprintf("\n\nWanPacket: 0x%8.8x\n", Address);
	dprintf("   WanPacketQueue:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	Packet->WanPacketQueue.Flink, Packet->WanPacketQueue.Blink);
	dprintf("   CurrentBuffer: 0x%8.8x\n", Packet->CurrentBuffer);
	dprintf("   CurrentLength: %ld\n", Packet->CurrentLength);
	dprintf("   StartBuffer: 0x%8.8x\n", Packet->StartBuffer);
	dprintf("   EndBuffer: 0x%8.8x\n", Packet->EndBuffer);
	dprintf("   PR1 (LinkCB): 0x%8.8x\n", Packet->ProtocolReserved1);
	dprintf("   PR2 (NdisPacket): 0x%8.8x\n", Packet->ProtocolReserved2);
	dprintf("   PR3 (ProtocolCB): 0x%8.8x\n", Packet->ProtocolReserved3);
	dprintf("   PR4 (BytesSent): %ld\n", Packet->ProtocolReserved4);
	dprintf("   MR1: 0x%8.8x\n", Packet->MacReserved1);
	dprintf("   MR2: 0x%8.8x\n", Packet->MacReserved2);
	dprintf("   MR3: 0x%8.8x\n", Packet->MacReserved3);
	dprintf("   MR4: 0x%8.8x\n", Packet->MacReserved4);
}

VOID
DisplayNdisPacket(
	DWORD	Address,
	PNDIS_PACKET	Packet
	)
{

	dprintf("\n\nNdisPacket: 0x%8.8x\n", Address);
	dprintf("   Private:\n");
	dprintf("      PhysicalCount: 0x%8.8x\n", Packet->Private.PhysicalCount);
	dprintf("      TotalLength: %ld\n", Packet->Private.TotalLength);
	dprintf("      BufferHead: 0x%8.8x\n", Packet->Private.Head);
	dprintf("      BufferTail: 0x%8.8x\n", Packet->Private.Tail);
	dprintf("      Pool: 0x%8.8x\n", Packet->Private.Pool);
	dprintf("      Count: 0x%8.8x\n", Packet->Private.Count);
	dprintf("      Flags: 0x%8.8x\n", Packet->Private.Flags);
	dprintf("      ValidCounts: %d\n", Packet->Private.ValidCounts);
	dprintf("   MR1 (Next/MagicNumber): 0x%8.8x\n", *((PDWORD)&Packet->MiniportReserved[0]));
	dprintf("   MR2 (ReferenceCount): 0x%4.4x (Flags): 0x%4.4x\n",
	*((PWORD)&Packet->MiniportReserved[4]),*((PWORD)&Packet->MiniportReserved[6]));
	dprintf("   WR1: 0x%8.8x\n", *((PDWORD)&Packet->WrapperReserved[0]));
	dprintf("   WR2: 0x%8.8x\n", *((PDWORD)&Packet->WrapperReserved[4]));
}

#if 0
VOID
DisplayVJContext(
	DWORD	Address,
	struct slcompress *context
	)
{
	dprintf("\n\nVJ Compress: 0x%8.8x\n", Address);
	dprintf("   last_cs (tstate): 0x%8.8x\n", context->last_cs);
	dprintf("   last_recv: %d\n", context->last_recv);
	dprintf("   last_xmit: %d\n", context->last_xmit);
	dprintf("   flags: 0x%4.4x\n", context->flags);
	dprintf("   MaxStates: %d\n", context->MaxStates);
	dprintf("   OutPackets: %ld\n", context->OutPackets);
	dprintf("   OutCompressed: %ld\n", context->OutCompressed);
	dprintf("   OutMisses: %ld\n", context->OutMisses);
	dprintf("   InUncompressed: %ld\n", context->InUncompressed);
	dprintf("   InCompressed: %ld\n", context->InCompressed);
	dprintf("   InErrors: %ld\n", context->InErrors);
	dprintf("   InTossed: %ld\n", context->InTossed);
	dprintf("   TxStates:\n");
	for (i = 0; i < MAX_VJ_STATES; i++) {
		cstate *state = &context->tstate[i];
		dprintf("      next  : 0x%8.x8\n", state->cs_next);
		dprintf("      hlen  : %d\n", state->cs_hlen);
		dprintf("      id    : %d\n", state->cs_id);
		dprintf("      ip_hl : %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_tos: %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_len: %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_id : %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_off: %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_ttl: %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_p  : %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_sum: %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_hl : %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_hl : %d\n", state->slcs_u.ip_hl);
	}

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\precomp.h ===
#define NDIS_TAPI_CURRENT_VERSION 0x00030000
#include "ndis.h"
#include <ndisprv.h>
#include "ntddndis.h"
#include "ndisprv.h"
#include "pxdebug.h"
#include "ndiswan.h"
//#include "ndisadd.h"
#include "pxuser.h"
#include "proxy.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\proxy.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    Proxy.h

Abstract:

    Fuction prototypes and globals


Author:

    Tony Bell


Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    TonyBe      03/04/99        Created

--*/

#ifndef _PROXY__H
#define _PROXY__H

#include "pxtapi.h"
#include "pxdefs.h"
#include "pxtypes.h"
#include "ndpif.h"

//
// Global data
//
extern NPAGED_LOOKASIDE_LIST    ProviderEventLookaside;
extern NPAGED_LOOKASIDE_LIST    VcLookaside;
extern TAPI_LINE_TABLE          LineTable;
extern VC_TABLE                 VcTable;
extern TAPI_TSP_CB              TspCB;
extern PX_DEVICE_EXTENSION      *DeviceExtension;
extern TSP_EVENT_LIST           TspEventList;

//
// Functions from pxntinit.c
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PxCancelSetQuery(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Functions from pxinit.c
//

BOOLEAN
InitNDISProxy(
    VOID
    );

VOID
GetRegistryParameters(
    IN PUNICODE_STRING  RegistryPath
    );

NDIS_STATUS
GetConfigDword(
    NDIS_HANDLE Handle,
    PWCHAR      ParameterName,
    PULONG      Destination,
    ULONG       MinValue,
    ULONG       MaxValue
    );

//
// From pxcm.c
//
NDIS_STATUS
PxCmCreateVc(
    IN  NDIS_HANDLE         ProtocolAfContext,
    IN  NDIS_HANDLE         NdisVcHandle,
    OUT PNDIS_HANDLE        pProtocolVcContext
    );

NDIS_STATUS
PxCmDeleteVc(
    IN  NDIS_HANDLE         ProtocolVcContext
    );

NDIS_STATUS
PxCmOpenAf(
    IN  NDIS_HANDLE         CallMgrBindingContext,
    IN  PCO_ADDRESS_FAMILY  pAddressFamily,
    IN  NDIS_HANDLE         NdisAfHandle,
    OUT PNDIS_HANDLE        pCallMgrAfContext
    );

NDIS_STATUS
PxCmCloseAf(
    IN NDIS_HANDLE       CallMgrAfContext
    );

NDIS_STATUS
PxCmRegisterSap(
    IN  NDIS_HANDLE     CallMgrAfContext,
    IN  PCO_SAP         pCoSap,
    IN  NDIS_HANDLE     NdisSapHandle,
    OUT PNDIS_HANDLE    pCallMgrSapContext
    );

NDIS_STATUS
PxCmDeRegisterSap(
    IN  NDIS_HANDLE       CallMgrSapContext
    );

NDIS_STATUS
PxCmMakeCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  pCallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle         OPTIONAL,
    OUT PNDIS_HANDLE            pCallMgrPartyContext    OPTIONAL
    );

NDIS_STATUS
PxCmCloseCall(
    IN  NDIS_HANDLE     CallMgrVcContext,
    IN  NDIS_HANDLE     CallMgrPartyContext OPTIONAL,
    IN  PVOID           Buffer  OPTIONAL,
    IN  UINT            Size    OPTIONAL
    );

VOID
PxCmIncomingCallComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         CallMgrVcContext,
    IN PCO_CALL_PARAMETERS pCallParameters
    );

NDIS_STATUS
PxCmAddParty(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  pCallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle,
    OUT PNDIS_HANDLE            pCallMgrPartyContext
    );

NDIS_STATUS
PxCmDropParty(
    IN  NDIS_HANDLE             CallMgrPartyContext,
    IN  PVOID                   Buffer  OPTIONAL,
    IN  UINT                    Size    OPTIONAL
    );

VOID
PxCmActivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     pCallParameters
    );

VOID
PxCmDeActivateVcComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         CallMgrVcContext
    );

NDIS_STATUS
PxCmModifyCallQos(
    IN  NDIS_HANDLE         CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS pCallParameters
    );

NDIS_STATUS
PxCmRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

VOID
PxCmRequestComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE ProtocolVcContext,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN PNDIS_REQUEST NdisRequest
    );

NDIS_STATUS
PxCmMakeCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  pCallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle         OPTIONAL,
    OUT PNDIS_HANDLE            pCallMgrPartyContext    OPTIONAL
    );

//
// From pxutils.c
//
BOOLEAN
PxIsAdapterAlreadyBound(
    PNDIS_STRING    pDeviceName
    );


PPX_ADAPTER
PxAllocateAdapter(
    ULONG   ulAdditionalLength
    );

VOID
PxFreeAdapter(
    PPX_ADAPTER pAdapter
    );

PPX_CM_AF
PxAllocateCmAf(
    IN  PCO_ADDRESS_FAMILY  pFamily
    );

VOID
PxFreeCmAf(
    PPX_CM_AF    pCmAf
    );

PPX_CL_AF
PxAllocateClAf(
    IN  PCO_ADDRESS_FAMILY  pFamily,
    IN  PPX_ADAPTER         pAdapter
    );

VOID
PxFreeClAf(
    PPX_CL_AF    pAfBlock
    );

PPX_CM_SAP
PxAllocateCmSap(
    PCO_SAP     Sap
    );

VOID
PxFreeCmSap(
    PPX_CM_SAP   pCmSap
    );

VOID
PxFreeClSap(
    PPX_CL_SAP   pClSap
    );

PPX_VC
PxAllocateVc(
    IN PPX_CL_AF    pClAf
    );

VOID
PxFreeVc(
    PPX_VC  pVc
    );

#if 0
NDIS_STATUS
GenericGetNdisCallParams(
    IN  PPX_VC                  pProxyVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    TapiBuffer,
    OUT PCO_CALL_PARAMETERS     *pNdisCallParameters
    );

NDIS_STATUS
GenericGetTapiCallParams(
    IN PPX_VC               pProxyVc,
    IN PCO_CALL_PARAMETERS  pCallParams
    );

PPX_CL_SAP
GenericTranslateTapiSap(
    IN  PPX_CL_AF       pClAf,
    IN  PPX_TAPI_LINE   TapiLine
    );

VOID
GenericFreeNdisSap(
    IN  PPX_CL_AF       pAfBlock,
    IN  PCO_SAP         pCoSap
    );
#endif

NDIS_STATUS
PxAfXyzTranslateTapiCallParams(
    IN  PPX_VC                  pProxyVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    pTapiParams,
    OUT PCO_CALL_PARAMETERS *   ppNdisCallParams
    );

NDIS_STATUS
PxAfXyzTranslateNdisCallParams(
    IN  PPX_VC              pProxyVc,
    IN  PCO_CALL_PARAMETERS pNdisCallParams
    );

PPX_CL_SAP
PxAfXyzTranslateTapiSap(
    IN  PPX_CL_AF       pClAf,
    IN  PPX_TAPI_LINE   TapiLine
    );

NDIS_STATUS
PxAfTapiTranslateTapiCallParams(
    IN  PPX_VC                  pProxyVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    pTapiParams,
    OUT PCO_CALL_PARAMETERS *   ppNdisCallParams
    );

ULONG
PxCopyLineCallParams(
    IN  LINE_CALL_PARAMS *pSrcLineCallParams,
    OUT LINE_CALL_PARAMS *pDstLineCallParams
    );

NDIS_STATUS
PxAfTapiTranslateNdisCallParams(
    IN  PPX_VC                  pProxyVc,
    IN  PCO_CALL_PARAMETERS     pNdisCallParams
    );

PPX_CL_SAP
PxAfTapiTranslateTapiSap(
    IN  PPX_CL_AF       pClAf,
    IN  PPX_TAPI_LINE   TapiLine
    );

VOID
PxAfTapiFreeNdisSap(
    IN  PPX_CL_AF   pClAf,
    IN  PCO_SAP     pCoSap
    );

PCO_CALL_PARAMETERS
PxCopyCallParameters(
    IN  PCO_CALL_PARAMETERS pCallParameters
    );

VOID
PxStartIncomingCallTimeout(
    IN  PPX_VC  pProxyVc
    );

VOID
PxStopIncomingCallTimeout(
    IN  PPX_VC  pProxyVc
    );

VOID
PxIncomingCallTimeout(
    IN  PVOID   SystemSpecific1,
    IN  PVOID   FunctionContext,
    IN  PVOID   SystemSpecific2,
    IN  PVOID   SystemSpecific3
    );

ULONG
PxMapNdisStatusToTapiDisconnectMode(
    IN  NDIS_STATUS NdisStatus,
    IN  BOOLEAN     bMakeCallStatus
    );

NTSTATUS
IntegerToChar (
    IN ULONG    Value,
    IN LONG     OutputLength,
    OUT PSZ     String
    );

NTSTATUS
IntegerToWChar (
    IN  ULONG Value,
    IN  LONG OutputLength,
    OUT PWCHAR String
    );

BOOLEAN
PxAfAndSapFromDevClass(
    PPX_ADAPTER pAdapter,
    LPCWSTR     DevClass,
    PPX_CM_AF   *pCmAf,
    PPX_CM_SAP  *pCmSap
    );

VOID
GetAllDevClasses(
    PPX_ADAPTER pAdapter,
    LPCWSTR     DevClass,
    PULONG      DevClassSize
    );

VOID
PxCloseCallWithCm(
    PPX_VC      pVc
    );

NDIS_STATUS
PxCloseCallWithCl(
    PPX_VC      pVc
    );

VOID
DoDerefVcWork(
    PPX_VC  pVc
    );

VOID
DoDerefClAfWork(
    PPX_CL_AF   pClAf
    );

VOID
DoDerefCmAfWork(
    PPX_CM_AF   pCmAf
    );

//
// Functions from pxco.c
//
VOID
PxCoBindAdapter(
    OUT PNDIS_STATUS    pStatus,
    IN  NDIS_HANDLE     BindContext,
    IN  PNDIS_STRING    DeviceName,
    IN  PVOID           SystemSpecific1,
    IN  PVOID           SystemSpecific2
    );

VOID
PxCoOpenAdaperComplete(
    NDIS_HANDLE BindingContext,
    NDIS_STATUS Status,
    NDIS_STATUS OpenErrorStatus
    );

VOID
PxCoUnbindAdapter(
    OUT PNDIS_STATUS    pStatus,
    IN  NDIS_HANDLE     ProtocolBindContext,
    IN  PNDIS_HANDLE    UnbindContext
    );

VOID
PxCoCloseAdaperComplete(
    NDIS_HANDLE BindingContext,
    NDIS_STATUS Status
    );

VOID
PxCoRequestComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS Status
    );

VOID
PxCoNotifyAfRegistration(
     IN  NDIS_HANDLE        BindingContext,
     IN  PCO_ADDRESS_FAMILY pFamily
     );

VOID
PxCoUnloadProtocol(
    VOID
    );

NDIS_STATUS
PxCoPnPEvent(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

NDIS_STATUS
PxPnPSetPower(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

NDIS_STATUS
PxPnPQueryPower(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

NDIS_STATUS
PxPnPQueryRemove(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

NDIS_STATUS
PxPnPCancelRemove(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

NDIS_STATUS
PxPnPReconfigure(
    IN  PPX_ADAPTER     pAdapter        OPTIONAL,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

VOID
PxCoSendComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
    );

VOID
PxCoTransferDataComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status,
    IN UINT BytesTransferred
    );

VOID
PxCoResetComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_STATUS Status
    );

VOID
PxCoStatusComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    );

VOID
PxCoReceiveComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    );

VOID
PxCoStatus(
    IN   NDIS_HANDLE             ProtocolBindingContext,
    IN   NDIS_HANDLE             ProtocolVcContext   OPTIONAL,
    IN   NDIS_STATUS             GeneralStatus,
    IN   PVOID                   StatusBuffer,
    IN   UINT                    StatusBufferSize
    );

UINT
PxCoReceivePacket(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PNDIS_PACKET pNdisPacket
    );

VOID 
PxTerminateDigitDetection(
                          IN    PPX_VC              pVc,
                          IN    PNDISTAPI_REQUEST   pNdisTapiRequest,
                          IN    ULONG               ulReason
                          );

VOID 
PxDigitTimerRoutine(
                    IN PVOID SystemSpecific1,
                    IN PVOID FunctionContext,
                    IN PVOID SystemSpecific2,
                    IN PVOID SystemSpecific3
                    );

NDIS_STATUS
PxStopDigitReporting(
                     PPX_VC pVc
                     );


VOID 
PxHandleReceivedDigit(
    IN    PPX_VC  pVc,
    IN    PVOID   Buffer,
    IN    UINT    BufferSize
    );

VOID
PxHandleWanLinkParams(
    IN    PPX_VC  pVc,
    IN    PVOID   Buffer,
    IN    UINT    BufferSize
    );

//
// Functions from pxcl.c
//
NDIS_STATUS
PxClCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext
    );


NDIS_STATUS
PxClDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext
    );


NDIS_STATUS
PxClRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

VOID
PxClRequestComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE ProtocolVcContext,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN PNDIS_REQUEST NdisRequest
    );

VOID
PxClOpenAfComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE NdisAfHandle
    );

VOID
PxClCloseAfComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolAfContext
    );

VOID
PxClRegisterSapComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolSapContext,
    IN  PCO_SAP Sap,
    IN  NDIS_HANDLE NdisSapHandle
    );

VOID
PxClDeregisterSapComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolSapContext
    );

VOID
PxClMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
PxClModifyCallQosComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
PxClCloseCallComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN NDIS_HANDLE ProtocolPartyContext OPTIONAL
    );

VOID
PxClAddPartyComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN NDIS_HANDLE NdisPartyHandle,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
PxClDropPartyComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolPartyContext
    );

NDIS_STATUS
PxClIncomingCall(
    IN NDIS_HANDLE ProtocolSapContext,
    IN NDIS_HANDLE ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS pCallParams
    );

VOID
PxClIncomingCallQosChange(
    IN NDIS_HANDLE ProtocolVcContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
PxClIncomingCloseCall(
    IN NDIS_STATUS closeStatus,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PVOID CloseData OPTIONAL,
    IN UINT Size OPTIONAL
    );

VOID
PxClIncomingDropParty(
    IN NDIS_STATUS DropStatus,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN PVOID CloseData OPTIONAL,
    IN UINT Size OPTIONAL
    );

VOID
PxClCallConnected(
    IN NDIS_HANDLE  ProtocolVcContext
    );

//
// Functions from pxtapi.c
//

ULONG
GetLineEvents(
    PCHAR   EventBuffer,
    ULONG   BufferSize
    );

NDIS_STATUS
PxTapiPlaceHolder(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiMakeCall(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetDevCaps(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiAccept(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiAnswer(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiLineGetID (
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiClose(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiCloseCall(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiConditionalMediaDetection(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiConfigDialog(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiDevSpecific(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiDial(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiDrop(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetAddressCaps(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetAddressID(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetAddressStatus(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetCallInfo(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetCallStatus(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetDevConfig(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetExtensionID(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetID(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetLineDevStatus(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiNegotiateExtVersion(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSendUserUserInfo(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetAppSpecific(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetCallParams(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetDefaultMediaDetection(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetDevConfig(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetMediaMode(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetStatusMessages (
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetCallAddressID(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiOpen(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiProviderInit(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiProviderShutdown(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSecureCall(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSelectExtVersion(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGatherDigits(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiMonitorDigits(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );  

VOID
PxTapiCompleteDropIrps(
    IN PPX_VC   pVc,
    IN ULONG    Status
    );

VOID
PxTapiCompleteAllIrps(
    IN PPX_VC   pVc,
    IN ULONG    Status
    );

VOID
PxIndicateStatus(
    IN  PVOID   StatusBuffer,
    IN  UINT    StatusBufferSize
    );


NDIS_STATUS
AllocateTapiResources(
    IN  PPX_ADAPTER ClAdapter,
    IN  PPX_CL_AF   pClAf
    );

PPX_TAPI_PROVIDER
AllocateTapiProvider(
    IN PPX_ADAPTER  ClAdapter,
    IN PPX_CL_AF    pClAf
    );

VOID
MarkProviderOnline(
   PPX_TAPI_PROVIDER   TapiProvider
   );

VOID
MarkProviderOffline(
    PPX_TAPI_PROVIDER   TapiProvider
    );

VOID
MarkProviderConnected(
    PPX_TAPI_PROVIDER   TapiProvider
    );

VOID
MarkProviderDisconnected(
    PPX_TAPI_PROVIDER   TapiProvider
    );

VOID
ClearSapWithTapiLine(
    PPX_CL_SAP  pClSap
  );

VOID
FreeTapiProvider(
    PPX_TAPI_PROVIDER   TapiProvider
    );


PPX_TAPI_LINE
AllocateTapiLine(
    IN PPX_TAPI_PROVIDER    TapiProvider,
    IN ULONG                LineID
    );

VOID
FreeTapiLine(
    IN PPX_TAPI_LINE    TapiLine
    );

PPX_TAPI_ADDR
AllocateTapiAddr(
    IN PPX_TAPI_PROVIDER    TapiProvider,
    IN PPX_TAPI_LINE        TapiLine,
    IN ULONG                AddrID
    );

VOID
FreeTapiAddr(
    IN  PPX_TAPI_ADDR   TapiAddr
    );

NDIS_STATUS
AllocateTapiCallInfo(
    PPX_VC          pVC,
    LINE_CALL_INFO  UNALIGNED *LineCallInfo
    );

BOOLEAN
InsertVcInTable(
    PPX_VC          pVc
    );

VOID
RemoveVcFromTable(
    PPX_VC          pVc
    );

BOOLEAN
IsTapiLineValid(
    ULONG           hdLine,
    PPX_TAPI_LINE   *TapiLine
    );

BOOLEAN
IsTapiDeviceValid(
    ULONG           ulDeviceID,
    PPX_TAPI_LINE   *TapiLine
    );

BOOLEAN
IsVcValid(
    ULONG_PTR       CallId,
    PPX_VC          *pVc
    );

VOID
GetVcFromCtx(
    NDIS_HANDLE     VcCtx,
    PPX_VC          *pVc
    );

BOOLEAN
IsAddressValid(
    PPX_TAPI_LINE   TapiLine,
    ULONG           AddressId,
    PPX_TAPI_ADDR   *TapiAddr
    );

BOOLEAN
GetLineFromCmLineID(
    PPX_TAPI_PROVIDER   TapiProvider,
    ULONG               CmLineID,
    PPX_TAPI_LINE       *TapiLine
    );

PPX_TAPI_ADDR
GetAvailAddrFromProvider(
    PPX_TAPI_PROVIDER   TapiProvider
    );

PPX_TAPI_ADDR
GetAvailAddrFromLine(
    PPX_TAPI_LINE   TapiLine
    );

BOOLEAN
GetAvailLineFromProvider(
    PPX_TAPI_PROVIDER   TapiProvider,
    PPX_TAPI_LINE       *TapiLine,
    PPX_TAPI_ADDR       *TapiAddr
    );

BOOLEAN
InsertLineInTable(
    PPX_TAPI_LINE   TapiLine
    );

VOID
RemoveTapiLineFromTable(
    PPX_TAPI_LINE   TapiLine
    );

NDIS_STATUS
PxVcCleanup(
    PPX_VC  pVc,
    ULONG   DropPending
    );


#endif  // _PROXY__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\pxdebug.c ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    PXDebug.c

Abstract:

    This module contains all debug-related code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    rmachin     11-01-96    stolen from ArvindM's cmadebug file
    TonyBe      02-21-99    re-work/re-write

Notes:

--*/


#include <precomp.h>

#define MODULE_NUMBER MODULE_DEBUG
#define _FILENUMBER 'BDXP'

#if DBG

ULONG   PXDebugLevel = PXD_ERROR;
ULONG   PXDebugMask = PXM_ALL;

LIST_ENTRY  PxdMemoryList;
ULONG       PxdAllocCount = 0;  // how many allocated so far (unfreed)

NDIS_SPIN_LOCK    PxdMemoryLock;
BOOLEAN           PxdInitDone = FALSE;


PVOID
PxAuditAllocMem(
    PVOID   pPointer,
    ULONG   Size,
    ULONG   Tag,
    ULONG   FileNumber,
    ULONG   LineNumber
    )
{
    PVOID               pBuffer = NULL;
    PPXD_ALLOCATION     pAllocInfo;
    NDIS_STATUS         Status;

    if(!PxdInitDone) {
        NdisAllocateSpinLock(&(PxdMem