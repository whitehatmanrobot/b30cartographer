1
 * scanline functions for all bit depths
 */
void
X_CopyScanline(LPBYTE lpSrc, LPBYTE lpDst, int count)
{
	int i;

	/*
	 * if the alignment of lpSrc and lpDst is the same, then
	 * we can get them aligned and do a faster copy
	 */
        if (((DWORD) lpSrc & 0x3) == ( (DWORD) lpDst & 0x3)) {
		
		/* align on WORD boundary */
		if ( (DWORD) lpSrc & 0x1) {
			*lpDst++ = *lpSrc++;
			count--;
		}

		/* align on DWORD boundary */
		if ((DWORD) lpSrc & 0x2) {
			* ((LPWORD) lpDst) = *((LPWORD) lpSrc);
			lpDst += sizeof(WORD);
			lpSrc += sizeof(WORD);
			count -= sizeof(WORD);
		}

		/* copy whole DWORDS */
		for ( i = (count / 4); i > 0; i--) {
			*((LPDWORD) lpDst) =  *((LPDWORD) lpSrc);
			lpSrc += sizeof(DWORD);
			lpDst += sizeof(DWORD);
		}
	} else {
		/* the lpSrc and lpDst pointers are different
		 * alignment, so leave them unaligned and
		 * copy all the whole DWORDs
		 */
                for (i = (count / 4); i> 0; i--) {
			*( (DWORD UNALIGNED FAR *) lpDst) =
				*((DWORD UNALIGNED FAR *) lpSrc);
			lpSrc += sizeof(DWORD);
			lpDst += sizeof(DWORD);
		}
	}

	/* in either case, copy last (up to 3) bytes. */
	for ( i = count % 4; i > 0; i--) {
		*lpDst++ = *lpSrc++;
	}
}
		
/*
 * X_Stretch_1_1_8Bits
 *
 * copy a scanline with no change (1:1)
 */
void
X_Stretch_1_1_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	X_CopyScanline(lpSrc, lpDst, DstXE);
}


/*
 * X_Stretch_1_2_8Bits
 *
 * copy a scanline, doubling all the pixels (1:2)
 */
void
X_Stretch_1_2_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
   	WORD wPix;
	int i;

	for (i = 0; i < SrcXE; i++) {
		
		/* get a pixel and double it */
		wPix = *lpSrc++;
		wPix |= (wPix << 8);
		* ((WORD UNALIGNED *) lpDst) = wPix;
		lpDst += sizeof(WORD);
	}
}


/*
 * X_Stretch_1_4_8Bits
 *
 * copy a scanline, quadrupling all the pixels (1:4)
 */
void
X_Stretch_1_4_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	DWORD dwPix;
	int i;

	for (i = 0; i < SrcXE; i++) {

		/* get a pixel and make four copies of it */
		dwPix = *lpSrc++;
		dwPix |= (dwPix <<8);
		dwPix |= (dwPix << 16);
		* ((DWORD UNALIGNED *) lpDst) = dwPix;
		lpDst += sizeof(DWORD);
	}
}


/*  -- 16-bit X functions -----------------------------------------------*/

/*
 * copy one scan-line of 16 bits with no change (1:1)
 */
void
X_Stretch_1_1_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	X_CopyScanline(lpSrc, lpDst, DstXE * sizeof(WORD));

}


/*
 * copy one scanline of 16 bpp duplicating each pixel
 */
void
X_Stretch_1_2_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

   	DWORD dwPix;
	int i;

	for (i = 0; i < SrcXE; i++) {
		
		/* get a pixel and double it */
		dwPix = * ((WORD *)lpSrc);
		dwPix |= (dwPix << 16);
		* ((DWORD UNALIGNED *) lpDst) = dwPix;

		lpDst += sizeof(DWORD);
		lpSrc += sizeof(WORD);
	}

}

/*
 * copy one scanline of 16 bits, stretching 1:n (dest > source)
 */
void
X_Stretch_1_N_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = DstXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one pixel and advance dest */
		*((WORD *) lpDst) = *((WORD *) lpSrc);

		lpDst += sizeof(WORD);

		/* should we advance source pointer this time ? */
		if ( (xdelta -= SrcXE) < 0) {
			xdelta += DstXE;
			lpSrc += sizeof(WORD);
		}
	}
}

/*
 * copy one scanline of 16bits, shrinking n:1 (dest < source)
 */
void
X_Stretch_N_1_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	int xdelta;
	int i;

	xdelta = SrcXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one pixel and advance dest */
		*((WORD *) lpDst) = *((WORD *)lpSrc);

		lpDst += sizeof(WORD);

		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc += sizeof(WORD);
			xdelta -= DstXE;
		} while (xdelta >= 0);

		xdelta += SrcXE;
	}

}


/* 24-bits ---------------------------------------------------------*/

/*
 * copy one 24-bpp scanline as is (1:1)
 */
void
X_Stretch_1_1_24Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	X_CopyScanline(lpSrc, lpDst, DstXE * 3);
}

/*
 * copy one 24-bpp scanline stretching 1:n (dest > source)
 */
void
X_Stretch_1_N_24Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	int xdelta;
	int i;

	xdelta = DstXE -1;

	for (i = 0; i < DstXE; i++) {
		/* copy first word of pixel and advance dest */
		*((WORD UNALIGNED *) lpDst) = *((WORD UNALIGNED *) lpSrc);

		lpDst += sizeof(WORD);

		/* copy third byte and advance dest */
		*lpDst++ = lpSrc[sizeof(WORD)];

		/* should we advance source pointer this time ? */
		if ( (xdelta -= SrcXE) < 0) {
			xdelta += DstXE;
			lpSrc += 3;
		}
	}
}

/*
 * copy one scanline of 24 bits, shrinking n:1 (dest < source)
 */
void
X_Stretch_N_1_24Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = SrcXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy first word of pixel and advance dest */
		*((WORD UNALIGNED *) lpDst) = *((WORD UNALIGNED *) lpSrc);

		lpDst += sizeof(WORD);

		/* copy third byte and advance dest */
		*lpDst++ = lpSrc[sizeof(WORD)];


		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc += 3;
			xdelta -= DstXE;
		} while (xdelta >= 0);

		xdelta += SrcXE;
	}
}		

/* -- special-case 1:2 -------------------------------------------*/

/*
 * stretch 1:2 in both directions, for 8 bits.
 *
 * An experiment was done on x86 to only write every other line during
 * the stretch and when the whole frame was done to use memcpy to fill
 * in the gaps.  This is slower than doing the stretch in a single pass.
 */
void
Stretch_1_2_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract)
{

	int SrcInc, DstInc;
	int i, j;
	WORD wPix;
	DWORD dwPix4;

	/* amount to advance source by at the end of each scan */
	SrcInc = SrcWidth - SrcXE;


	/* amount to advance dest by at the end of each scan - note
	 * that we write two scans at once, so advance past the next
	 * scan line
	 */
	DstInc = (DstWidth * 2) - DstXE;

	/*
	 * we would like to copy the pixels DWORD at a time. this means
	 * being aligned. if we are currently aligned on a WORD boundary,
	 * then copy one pixel to get aligned. If we are on a byte
	 * boundary, we can never get aligned, so use the slower loop.
	 */
	if ( ((DWORD)lpDst) & 1) {

		/*
		 * dest is byte aligned - so we can never align it
		 * by writing WORDs - use slow loop.
		 */
		for (i = 0; i < SrcYE; i++) {
	
			for (j = 0; j < SrcXE; j++) {
	
				/* get a pixel and double it */
	
				wPix = *lpSrc++;
				wPix |= (wPix<<8);
	
	
				/* write doubled pixel to this scanline */
	
				*( (WORD UNALIGNED *) lpDst) = wPix;
	
				/* write double pixel to next scanline */
				*( (WORD UNALIGNED *) (lpDst + DstWidth)) = wPix;
	
				lpDst += sizeof(WORD);
			}
			lpSrc += SrcInc;
			lpDst += DstInc;
		}
		return;
	}

	/*
	 * this will be the aligned version. align each scan line
	 */
	for ( i = 0; i < SrcYE; i++) {

		/* count of pixels remaining */
		j = SrcXE;

		/* align this scan line */
		if (((DWORD)lpDst) & 2) {

			/* word aligned - copy one doubled pixel and we are ok */
			wPix = *lpSrc++;
			wPix |= (wPix << 8);
	
			*( (WORD *) lpDst) = wPix;
  			*( (WORD *) (lpDst + DstWidth)) = wPix;
			lpDst += sizeof(WORD);

			j -= 1;
		}


		/* now dest is aligned - so loop eating two pixels at a time
		 * until there is at most one left
		 */
               	for ( ; j > 1; j -= 2) {

			/* read two pixels and double them */
			wPix = * ((WORD UNALIGNED *) lpSrc);
			lpSrc += sizeof(WORD);

			dwPix4 = (wPix & 0xff) | ((wPix & 0xff) << 8);
			dwPix4 |= ((wPix & 0xff00) << 8) | ((wPix & 0xff00) << 16);
			*((DWORD *) lpDst) = dwPix4;
  			*((DWORD *) (lpDst + DstWidth)) = dwPix4;

			lpDst += sizeof(DWORD);
		}

		/* odd byte remaining ? */
		if (j > 0) {
			/* word aligned - copy one doubled pixel and we are ok */
			wPix = *lpSrc++;
			wPix |= (wPix << 8);
	
			*( (WORD *) lpDst) = wPix;
			*( (WORD *) (lpDst + DstWidth)) = wPix;
			lpDst += sizeof(WORD);

			j -= 1;
		}
		lpSrc += SrcInc;
		lpDst += DstInc;
	}
}



/* ----------------------------------------------------------------*/

/*
 * stretch 1:2 in both directions, for 16-bits
 */

void
Stretch_1_2_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract)

{
	int SrcInc, DstInc;
	int i, j;
	DWORD dwPix;

	/* amount to advance source by at the end of each scan */
	SrcInc = SrcWidth - (SrcXE * sizeof(WORD));


	/* amount to advance dest by at the end of each scan - note
	 * that we write two scans at once, so advance past the next
	 * scan line
	 */
	DstInc = (DstWidth * 2) - (DstXE * sizeof(WORD));

	for (i = 0; i < SrcYE; i++) {

		for (j = 0; j < SrcXE; j++) {

			/* get a pixel and double it */

			dwPix = *((WORD *)lpSrc);
			dwPix |= (dwPix<<16);

			lpSrc += sizeof(WORD);

			/* write doubled pixel to this scanline */

			*( (DWORD UNALIGNED *) lpDst) = dwPix;

			/* write double pixel to next scanline */
			*( (DWORD UNALIGNED *) (lpDst + DstWidth)) = dwPix;

			lpDst += sizeof(DWORD);
		}
	        lpSrc += SrcInc;
		lpDst += DstInc;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\setdi8.asm ===
page    ,132
;----------------------------Module-Header------------------------------;
; Module Name: SETDI8.ASM
;
; move bits from one DIB format into another. doing color conversion if
; needed.
;
;   convert_8_8
;   convert_16_8
;   convert_24_8
;   convert_32_8
;   copy_8_8
;   dither_8_8
;
; NOTES:
;
;  dither needs to work!
;
;  AUTHOR: ToddLa (Todd Laney) Microsoft
;
;-----------------------------------------------------------------------;
?PLM=1
?WIN=0
	.xlist
        include cmacro32.inc
;       include cmacros.inc
        include windows.inc
        .list

sBegin  Data
sEnd    Data

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        .386
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;--------------------------------------------------------------------------;
;--------------------------------------------------------------------------;

nxtscan macro reg, next_scan, fill_bytes
ifb <fill_bytes>
        add     e&reg,next_scan
else
        mov     eax,e&reg
        add     e&reg,next_scan
        cmp     ax,reg
        sbb     eax,eax
        and     eax,fill_bytes
        add     e&reg,eax
endif
        endm

;--------------------------------------------------------------------------;
;
;   convert_8_8
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_8_8,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count           ; pixel count.
        ParmD   scan_count          ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        xor     ebx,ebx
        lfs     si,src_ptr
        les     di,dst_ptr
        lds     bx,xlat_table

        add     esi,src_offset
        add     edi,dst_offset

        mov     eax,pel_count
        sub     src_next_scan,eax
        sub     dst_next_scan,eax

	mov	edx,pel_count
	xor	ebx,ebx
align 4
convert_8_8_start:
	mov	ecx,edx ;pel_count
	shr	ecx,2
        jz      short convert_8_8_ack
align 4
convert_8_8_loop:
        mov     eax,fs:[esi]        ; grab 4 pixels

	mov	bl,al		    ; get pel
	mov	al,[ebx]	    ; translate pel
	mov	bl,ah		    ; get pel
	mov	ah,[ebx]	    ; translate pel

        rol     eax,16

	mov	bl,al		    ; get pel
	mov	al,[ebx]	    ; translate pel
	mov	bl,ah		    ; get pel
	mov	ah,[ebx]	    ; translate pel

        rol     eax,16
        mov     es:[edi],eax        ; store four

        add     esi,4
        add     edi,4
	dec	ecx
	jnz	short convert_8_8_loop

convert_8_8_ack:
	mov	ecx,edx ;pel_count
	and	ecx,3
	jnz	short convert_8_8_odd

convert_8_8_next:
	nxtscan si,src_next_scan
	nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     short convert_8_8_start
cEnd

convert_8_8_odd:
@@:	mov	bl,fs:[esi]
	mov	bl,[ebx]
        mov     es:[edi],bl
        inc     esi
        inc     edi
	dec	ecx
	jnz	short convert_8_8_odd
        jz      short convert_8_8_next

;--------------------------------------------------------------------------;
;
;   copy_8_8
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   copy_8_8,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        lds     si,src_ptr
        les     di,dst_ptr

        add     esi,src_offset
        add     edi,dst_offset

        mov     eax,pel_count
        sub     src_next_scan,eax
        sub     dst_next_scan,eax

        mov     eax,src_next_scan
        or      eax,dst_next_scan
        or      eax,dst_fill_bytes
	jz	short copy_8_8_all

copy_8_8_rect:
        mov     ebx,pel_count
        mov     edx,ebx

        shr     ebx,2
        and     edx,3
align 4
copy_8_8_start:
        mov     ecx,ebx
        rep     movs dword ptr es:[edi], dword ptr ds:[esi]
        mov     ecx,edx
        rep     movs byte ptr es:[edi], byte ptr ds:[esi]
	nxtscan si,src_next_scan
	nxtscan di,dst_next_scan,dst_fill_bytes
        dec     scan_count
        jnz     short copy_8_8_start
copy_8_8_exit:
cEnd

copy_8_8_all:
        mov     eax,pel_count
        mul     scan_count
        mov     ecx,eax
        shr     ecx,2
        rep     movs dword ptr es:[edi], dword ptr ds:[esi]
        mov     ecx,eax
        and     ecx,3
        rep     movs byte ptr es:[edi], byte ptr ds:[esi]
        jmp     short copy_8_8_exit

;--------------------------------------------------------------------------;
;
;   dither_8_8
;
;       pel = xlat[y&7][pel][x&7]
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   dither_8_8,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
        xor     esi,esi
        xor     edi,edi
        xor     ebx,ebx
        lfs     si,src_ptr
        les     di,dst_ptr
        lds     bx,xlat_table

ifdef DEBUG
        or      ebx,ebx
        jz      @f
        int 3
@@:
endif
        add     esi,src_offset
        add     edi,dst_offset

        and     pel_count,not 3     ;;!!! round down to multiple of 4

        mov     eax,pel_count
        sub     src_next_scan,eax
        sub     dst_next_scan,eax

        shr     eax,2
        jz      short dither_8_8_exit
        mov     pel_count,eax

        xor     edx,edx             ; y = 0
align 4
dither_8_8_start:
        mov     ecx,pel_count
        xor     ebx,ebx             ; x = 0
align 4
dither_8_8_loop:
        mov     eax,fs:[esi]        ; grab 4 pixels

        mov     dl,al               ; get pel
        mov     al,[edx*8+ebx]      ; get dithered version of the pixel.
        inc     bl

        mov     dl,ah               ; get pel
        mov     ah,[edx*8+ebx]      ; get dithered version of the pixel.
        inc     bl

        rol     eax,16

        mov     dl,al               ; get pel
        mov     al,[edx*8+ebx]      ; get dithered version of the pixel.
        inc     bl

        mov     dl,ah               ; get pel
        mov     ah,[edx*8+ebx]      ; get dithered version of the pixel.
        inc     bl
        and     bl,7

        rol     eax,16
        mov     es:[edi],eax

        add     esi,4
        add     edi,4
        dec     ecx
        jnz     short dither_8_8_loop

dither_8_8_next:
        inc     dh
        and     dh,7
	nxtscan si,src_next_scan
	nxtscan di,dst_next_scan,dst_fill_bytes

        dec     scan_count
        jnz     short dither_8_8_start

dither_8_8_exit:
cEnd

;--------------------------------------------------------------------------;
;
;   convert_16_8
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_16_8,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
	ParmD	pel_count	    ; pixel count.
	ParmD	scan_count	    ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
	; we need dither code here!
cEnd

;--------------------------------------------------------------------------;
;
;   convert_24_8
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_24_8,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
	; we need dither code here!
cEnd

;--------------------------------------------------------------------------;
;
;   convert_32_8
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   convert_32_8,<FAR,PUBLIC,PASCAL>,<esi,edi,ds>
        ParmD   dst_ptr             ; --> dst.
        ParmD   dst_offset          ; offset to start at
        ParmD   dst_next_scan       ; dst_next_scan.
        ParmD   dst_fill_bytes      ; dst_fill_bytes
        ParmD   src_ptr             ; --> src.
        ParmD   src_offset          ; offset to start at
        ParmD   src_next_scan       ; dst_next_scan.
        ParmD   pel_count               ; pixel count.
        ParmD   scan_count              ; scan count.
        ParmD   xlat_table          ; pixel convert table.
cBegin
	; we need dither code here!
cEnd

sEnd    CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dcilib.c ===
/*
 *
 *
 * !!!!!!!!! THIS FILE IS NOT USED !!!!!!!!!!!!!!!
 *
 *
 */
#error THIS FILE IS NOT USED
#include <windows.h>

#undef WINAPI
#define WINAPI FAR PASCAL _loadds

#include "dciman.h"

static char szSystemIni[] = "system.ini";
static char szDrivers[]   = "Drivers";
static char szDCI[]       = "dci";
static char szDISPLAY[]   = "display";
static char szDCISVGA[]   = "dcisvga";

static BOOL fDVA;
extern LONG DVAEscape(HDC hdc, UINT function, UINT size, LPVOID lp_in_data, LPVOID lp_out_data);

/****************************************************************************
 ***************************************************************************/

HDC WINAPI DCIOpenProvider(void)
{
    char ach[128];
    HDC hdc;
    UINT u;

    //
    //  get the DCI provider, default to the display driver
    //
    GetPrivateProfileString(szDrivers, szDCI, szDISPLAY, ach, sizeof(ach), szSystemIni);

    //
    // if dci=dcisvga in system.ini, ignore it and try the display driver first.
    //
    if (lstrcmpi(ach, szDCISVGA) == 0) {
	lstrcpy(ach, szDISPLAY);
    }

again:
    u = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hdc = CreateDC(ach, NULL, NULL, NULL);
    SetErrorMode(u);

    if (hdc == NULL)
    {
fail:
        if (lstrcmpi(ach, szDCISVGA) == 0) {
            return NULL;
	}

        if (lstrcmpi(ach, szDISPLAY) == 0) {
	    lstrcpy(ach, szDISPLAY);
	    goto again;
	}

        lstrcpy(ach, szDISPLAY);
        goto again;
    }

    //
    //  now check for the Escape
    //
    u = DCICOMMAND;
    if (Escape(hdc, QUERYESCSUPPORT,sizeof(u),(LPCSTR)&u,NULL) == 0)
    {
        //
        // driver does not do escape, punt it, try old DVA first though
        //
        if (lstrcmpi(ach, szDISPLAY) == 0)
        {
            if (DVAEscape(hdc,QUERYESCSUPPORT,sizeof(u),(LPCSTR)&u,NULL) != 0)
            {
                fDVA = TRUE;
                return hdc;
            }
        }

        DeleteDC(hdc);
        goto fail;
    }

    return hdc;

}

/****************************************************************************
 ***************************************************************************/

void WINAPI DCICloseProvider(HDC hdc)
{
    if (hdc)
        DeleteDC(hdc);
}

/****************************************************************************
 ***************************************************************************/

int WINAPI DCISendCommand(HDC hdc, DCICMD FAR *pcmd, VOID FAR * FAR * lplpOut)
{
    if (lplpOut)            // in case it fails, make sure this is NULL
        *lplpOut = NULL;

    if (fDVA)
        return DVAEscape(hdc, DCICOMMAND, sizeof(DCICMD),(LPCSTR)pcmd, lplpOut);
    else
        return Escape(hdc, DCICOMMAND, sizeof(DCICMD),(LPCSTR)pcmd, lplpOut);
}

/****************************************************************************
 ***************************************************************************/

extern int WINAPI DCICreatePrimary(HDC hdc, DCISURFACEINFO FAR * FAR *lplpSurface)
{
    DCICMD  cmd;

    cmd.dwCommand   = DCICREATEPRIMARYSURFACE;
    cmd.dwParam1    = 0;
    cmd.dwParam2    = 0;
    cmd.dwVersion   = DCI_VERSION;
    cmd.dwReserved  = 0;

    return DCISendCommand(hdc, &cmd, lplpSurface);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dciddi.h ===
/*******************************************************************
 *
 *	FILE:		dciman.h
 *	
 *	DESCRIPTION:	definitions for MS/Intel-defined DCI interface
 *
 *	Copyright (c) 1994 Intel/Microsoft Corporation
 *
 *******************************************************************/

#ifndef _INC_DCIDDI
#define _INC_DCIDDI

#ifdef __cplusplus
extern "C" {
#endif

/* DCI Command Escapes */                                                               
#define DCICOMMAND			3075
#define DCI_VERSION			0x0100

#define DCICREATEPRIMARYSURFACE		1 
#define DCICREATEOFFSCREENSURFACE       2 
#define DCICREATEOVERLAYSURFACE         3
#define DCIENUMSURFACE                  4 
#define DCIESCAPE                       5

/* DCI-Defined error codes */
#define DCI_OK                              	0 /* success */

/* Hard errors -- DCI will be unavailable */
#define DCI_FAIL_GENERIC                     -1
#define DCI_FAIL_UNSUPPORTEDVERSION          -2
#define DCI_FAIL_INVALIDSURFACE              -3
#define DCI_FAIL_UNSUPPORTED                 -4    

/* Soft errors -- DCI may be available later */
#define DCI_ERR_CURRENTLYNOTAVAIL           -5
#define DCI_ERR_INVALIDRECT                 -6
#define DCI_ERR_UNSUPPORTEDFORMAT           -7
#define DCI_ERR_UNSUPPORTEDMASK             -8
#define DCI_ERR_TOOBIGHEIGHT                -9
#define DCI_ERR_TOOBIGWIDTH                 -10
#define DCI_ERR_TOOBIGSIZE                  -11
#define DCI_ERR_OUTOFMEMORY                 -12
#define DCI_ERR_INVALIDPOSITION             -13
#define DCI_ERR_INVALIDSTRETCH              -14
#define DCI_ERR_INVALIDCLIPLIST             -15
#define DCI_ERR_SURFACEISOBSCURED           -16
#define DCI_ERR_XALIGN			    -18
#define DCI_ERR_YALIGN			    -19
#define DCI_ERR_XYALIGN			    -20
#define DCI_ERR_WIDTHALIGN		    -21
#define DCI_ERR_HEIGHTALIGN		    -22
											 
/* success messages -- DCI call succeeded, but specified item changed */
#define DCI_STATUS_POINTERCHANGED           1
#define DCI_STATUS_STRIDECHANGED            2
#define DCI_STATUS_FORMATCHANGED            4
#define DCI_STATUS_SURFACEINFOCHANGED       8
#define DCI_STATUS_CHROMAKEYCHANGED        16				
#define DCI_STATUS_WASSTILLDRAWING         32


/* DCI Capability Flags */
#define DCI_SURFACE_TYPE			0x0000000F
#define DCI_PRIMARY                 		0x00000000
#define DCI_OFFSCREEN               		0x00000001
#define DCI_OVERLAY                 		0x00000002

#define DCI_VISIBLE                 		0x00000010
#define DCI_CHROMAKEY               		0x00000020
#define DCI_1632_ACCESS             		0x00000040
#define DCI_DWORDSIZE               		0x00000080
#define DCI_DWORDALIGN              		0x00000100
#define DCI_WRITEONLY               		0x00000200
#define DCI_ASYNC                   		0x00000400

#define DCI_CAN_STRETCHX            		0x00001000
#define DCI_CAN_STRETCHY            		0x00002000
#define DCI_CAN_STRETCHXY           		(DCI_CAN_STRETCHX | DCI_CAN_STRETCHY)

#define DCI_CAN_STRETCHXN           		0x00004000
#define DCI_CAN_STRETCHYN           		0x00008000
#define DCI_CAN_STRETCHXYN          		(DCI_CAN_STRETCHXN | DCI_CAN_STRETCHYN)


#define DCI_CANOVERLAY                          0x00010000

/*
 * Win32 RGNDATA structure.  This will be used for  cliplist info. passing.
 */
#if (WINVER < 0x0400)

#ifndef RDH_RECTANGLES

typedef struct tagRECTL
{                      
   LONG     left;      
   LONG     top;       
   LONG     right;     
   LONG     bottom;    
                       
} RECTL;               
typedef RECTL*       PRECTL; 
typedef RECTL NEAR*  NPRECTL; 
typedef RECTL FAR*   LPRECTL;  
typedef const RECTL FAR* LPCRECTL;

#define RDH_RECTANGLES  0

typedef struct tagRGNDATAHEADER {
   DWORD   dwSize;                              /* size of structure             */
   DWORD   iType;                               /* Will be RDH_RECTANGLES        */
   DWORD   nCount;                              /* # of clipping rectangles      */
   DWORD   nRgnSize;                            /* size of buffer -- can be zero */
   RECTL   rcBound;                             /* bounding  rectangle for region*/
} RGNDATAHEADER;
typedef RGNDATAHEADER*       PRGNDATAHEADER;
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;

typedef struct tagRGNDATA {
   RGNDATAHEADER   rdh;
   char            Buffer[1];
} RGNDATA;
typedef RGNDATA*       PRGNDATA;
typedef RGNDATA NEAR*  NPRGNDATA;
typedef RGNDATA FAR*   LPRGNDATA;
typedef const RGNDATA FAR* LPCRGNDATA;

#endif
#endif

typedef int     DCIRVAL;                /* return for callbacks */

/**************************************************************************
 *	input structures
 **************************************************************************/

/*
 * Used by a DCI client to provide input parameters for the 
 * DCICREATEPRIMARYSURFACE escape.
 */
typedef struct _DCICMD {
	DWORD	dwCommand;
	DWORD	dwParam1;
	DWORD 	dwParam2;
	DWORD	dwVersion;
	DWORD	dwReserved;
} DCICMD;

/*
 * This structure is used by a DCI client to provide input parameters for 
 * the DCICREATE... calls.  The fields that are actually relevant differ for 
 * each of the three calls.  Details are in the DCI Spec chapter providing 
 * the function specifications.
 */
typedef struct _DCICREATEINPUT {
	DCICMD	cmd;							/* common header structure */
	DWORD   dwCompression;          		/* format of surface to be created                      */
	DWORD   dwMask[3];                      /* for  nonstandard RGB (e.g. 5-6-5, RGB32) */
	DWORD   dwWidth;                        /* height of the surface to be created          */
	DWORD   dwHeight;                       /* width of input surfaces                                      */
	DWORD	dwDCICaps;						/* capabilities of surface wanted */
	LPVOID  lpSurface;                      /* pointer to an associated surface             */      
} DCICREATEINPUT, FAR *LPDCICREATEINPUT;
		

/*
 * This structure is used by a DCI client to provide input parameters for the 
 * DCIEnumSurface call.
 */
typedef struct _DCIENUMINPUT {
	DCICMD	cmd;							/* common header structure */
	RECT    rSrc;                           /* source rect. for stretch  */
	RECT    rDst;                           /* dest. rect. for stretch       */
	void    (CALLBACK *EnumCallback)(LPDCISURFACEINFO, LPVOID);        /* callback for supported formats */
	LPVOID  lpContext;
} DCIENUMINPUT, FAR *LPDCIENUMINPUT;

/**************************************************************************
 *	surface info. structures
 **************************************************************************/

/*
 * This structure is used to return information about available support
 * during a DCIEnumSurface call.  It is also used to create a primary 
 * surface, and as a member of the larger structures returned by the 
 * offscreen and overlay calls.
 */
 typedef struct _DCISURFACEINFO {
        DWORD   dwSize;                         /* size of structure                                            */
        DWORD   dwDCICaps;                  /* capability flags (stretch, etc.)             */
        DWORD   dwCompression;                  /* format of surface to be created                      */
        DWORD   dwMask[3];                  /* for BI_BITMASK surfaces                                      */

        DWORD   dwWidth;                    /* width of surface                                             */
        DWORD   dwHeight;                   /* height of surface                                            */
        LONG    lStride;                    /* distance in bytes betw. one pixel            */
                                                                                /* and the pixel directly below it                      */
        DWORD   dwBitCount;                 /* Bits per pixel for this dwCompression    */
        DWORD   dwOffSurface;               /* offset of surface pointer                            */
        WORD    wSelSurface;                /* selector of surface pointer                          */
        WORD    wReserved;

        DWORD   dwReserved1;                /* reserved for provider */
        DWORD   dwReserved2;                /* reserved for DCIMAN */
        DWORD   dwReserved3;                /* reserved for future */
        DCIRVAL (CALLBACK *BeginAccess) (LPVOID, LPRECT);    /* BeginAccess callback         */
        void (CALLBACK *EndAccess) (LPVOID);                   /* EndAcess callback            */
        void (CALLBACK *DestroySurface) (LPVOID);               /* Destroy surface callback     */
} DCISURFACEINFO, FAR *LPDCISURFACEINFO;

/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEPRIMARYSURFACE call.
 */
 typedef DCISURFACEINFO DCIPRIMARY, FAR *LPDCIPRIMARY;
								   
/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEOFFSCREENSURFACE call.
 */
 typedef struct _DCIOFFSCREEN {

	DCISURFACEINFO  dciInfo;                                                           /* surface info                  */
        DCIRVAL (CALLBACK *Draw) (LPVOID);                                            /* copy to onscreen buffer   */
        DCIRVAL (CALLBACK *SetClipList) (LPVOID, LPRGNDATA);          /* SetCliplist callback              */
        DCIRVAL (CALLBACK *SetDestination) (LPVOID, LPRECT, LPRECT);  /* SetDestination callback       */
} DCIOFFSCREEN, FAR *LPDCIOFFSCREEN;


/*
 * This structure must be allocated and returned by the DCI provider in response
 * to a DCICREATEOVERLAYSURFACE call.
 */
 typedef struct _DCIOVERLAY{

	DCISURFACEINFO  dciInfo;                                                /* surface info                  */
	DWORD   dwChromakeyValue;                                               /* chromakey color value                 */
	DWORD   dwChromakeyMask;                                                /* specifies valid bits of value */
} DCIOVERLAY, FAR *LPDCIOVERLAY;


/* DCI FOURCC def.s for extended DIB formats */                    

#ifndef YVU9
#define YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef Y411
#define Y411                        mmioFOURCC('Y','4','1','1')                                             
#endif
#ifndef YUY2
#define YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef YVYU
#define YVYU                        mmioFOURCC('Y','V','Y','U')
#endif
#ifndef UYVY
#define UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef Y211
#define Y211                        mmioFOURCC('Y','2','1','1')
#endif

#ifdef __cplusplus
}
#endif

#endif // _INC_DCIDDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dciddi.inc ===
;----------------------------------------------------------------------------
;
; DCIDDI.INC
;
; Copyright (c) 1994 Microsoft Corporation
;
; DCI 1.0 Interface Definitions
;
;----------------------------------------------------------------------------

ifndef _INC_DCIDDI
_INC_DCIDDI equ 1

DCICOMMAND      		equ 3075    ; GDI Escape for DCI
DCI_VERSION     		equ 0x0100  ; version number of DCI 1.0

;----------------------------------------------------------------------------
;  DCI command codes.
;----------------------------------------------------------------------------
DCICREATEPRIMARYSURFACE        	equ 1       ; used to create primary surface
DCICREATEOFFSCREENSURFACE      	equ 2       ; used to create offscreen surface
DCICREATEOVERLAYSURFACE		equ 3
DCIENUMSURFACE                 	equ 4       ; used to enumerate
DCIESCAPE			equ 5

;----------------------------------------------------------------------------
;  error codes
;----------------------------------------------------------------------------
DCI_OK                      	equ 0

DCI_FAIL_GENERIC             	equ (-1)
DCI_FAIL_UNSUPPORTEDVERSION  	equ (-2)
DCI_FAIL_INVALIDSURFACE      	equ (-3)
DCI_FAIL_NOTSUPPORTED        	equ (-4)

DCI_ERR_CURRENTLYNOTAVAIL   	equ (-5)
DCI_ERR_INVALIDRECT         	equ (-6)
DCI_ERR_UNSUPPORTEDFORMAT   	equ (-7)
DCI_ERR_UNSUPPORTEDMASK     	equ (-8)
DCI_ERR_TOOBIGHEIGHT        	equ (-9)
DCI_ERR_TOOBIGWIDTH         	equ (-10)
DCI_ERR_TOOBIGSIZE          	equ (-11)
DCI_ERR_OUTOFMEMORY         	equ (-12)
DCI_ERR_INVALIDPOSITION     	equ (-13)
DCI_ERR_INVALIDSTRETCH      	equ (-14)
DCI_ERR_INVALIDCLIPLIST     	equ (-15)
DCI_ERR_SURFACEISOBSCURED   	equ (-16)
DCI_ERR_XALIGN			equ (-18)
DCI_ERR_YALIGN			equ (-19)
DCI_ERR_XYALIGN			equ (-20)
DCI_ERR_WIDTHALIGN		equ (-21)
DCI_ERR_HEIGHTALIGN		equ (-22)
									 
DCI_STATUS_POINTERCHANGED    	equ 1
DCI_STATUS_STRIDECHANGED        equ 2
DCI_STATUS_FORMATCHANGED        equ 4
DCI_STATUS_SURFACEINFOCHANGED   equ 8
DCI_STATUS_CHROMAKEYCHANGED     equ 16
DCI_STATUS_WASSTILLDRAWING     	equ 32

;----------------------------------------------------------------------------
; Definitions for DCISURFACE::dwFlags
;----------------------------------------------------------------------------
DCI_SURFACE_TYPE   equ 0000000Fh  ; 16 types
DCI_PRIMARY        equ 00000000h  ; primary surface
DCI_OFFSCREEN      equ 00000001h  ; offscreen surface
DCI_OVERLAY        equ 00000002h  ; overlay surface

DCI_VISIBLE        equ 00000010h  ; surface is visible
DCI_CHROMAKEY	   equ 00000020h  ; chroma key surface
DCI_1632_ACCESS    equ 00000040h  ; must access using 16:32 pointers
DCI_DWORDSIZE      equ 00000080h  ; support only aligned dest. sizes
DCI_DWORDALIGN     equ 00000100h  ; support only aligned dest. positions
DCI_WRITEONLY      equ 00000200h  ; write access only.
DCI_ASYNC          equ 00000400h  ; supports async draw

DCI_CAN_STRETCHX   equ 00001000h  ; can stretchX
DCI_CAN_STRETCHY   equ 00002000h  ; can stretchY
DCI_CAN_STRETCHXY  equ 00003000h  ; can stretchXY
DCI_CAN_STRETCHXN  equ 00004000h  ; can stretchX by integer
DCI_CAN_STRETCHYN  equ 00008000h  ; can stretchY by integer
DCI_CAN_STRETCHXYN equ 0000C000h  ; can stretchXY by integer

DCI_CAN_OVERLAY    equ 00010000h  ; supports overlay.

;----------------------------------------------------------------------------
; common DCI command structure
;----------------------------------------------------------------------------
DCICMD  struc
	dciCommandCode  dd ?         ; DCI command
	dciDWParam1     dd ?         ; dwParam1
	dciDWParam2     dd ?         ; dwParam2
	dciVersion      dd ?         ; version
			dd ?         ; reserved
DCICMD  ends

;----------------------------------------------------------------------------
; used in DCICREATE... calls
;----------------------------------------------------------------------------
DCICREATEINPUT struc
	dcicCmd			db size DCICMD dup (?)
	dcicDWCompression  	dd ?                ; biCompression
	dcicDWMask         	dd 3 dup(?)         ; BI_BITFIELD masks
	dcicDWWidth        	dd ?                ; width in pixels
	dcicDWHeight       	dd ?                ; height in pixels
	dcicDWDCICaps	   	dd ?
	dcicDWSurface	   	dd ?
DCICREATEINPUT ends

;----------------------------------------------------------------------------
; used with DCIENUMINPUT
;----------------------------------------------------------------------------
DCIENUMINPUT struc
	dcieCmd             	db size DCICMD dup(?)
	dcieSourceRect      	dw 4 dup(?)         ; source
	dcieDestRect        	dw 4 dup(?)         ; dest
	dcieDWCallback         	dd ?                ; callback
	dcieDWCallbackParam    	dd ?                ; callback lParam
DCIENUMINPUT ends

;----------------------------------------------------------------------------
; DCISURFACE structure
;----------------------------------------------------------------------------
DCISURFACEINFO  struc
	dciDWSize                	dd  ?
	dciDWDCICaps                	dd  ?
	dciDWCompression          	dd  ?
	dciDWMasks                	dd  3 dup(?)
	dciDWWidth                	dd  ?
	dciDWHeight               	dd  ?
	dciLStride            		dd  ?
	dciDWBitCount             	dd  ?
	dciDWOffSurface        		dd  ?
	dciWSelSurface           	dw  ?
	dciWReserved             	dw  ?
	dciDWReserved1           	dd  ?
	dciDWReserved2           	dd  ?
	dciDWReserved3           	dd  ?
	dciDWBeginAccess         	dd  ?
	dciDWEndAccess            	dd  ?
	dciDWDestroySurface         	dd  ?
DCISURFACEINFO ends

;----------------------------------------------------------------------------
; used with DCICREATEOFFSCREENSURFACE
;----------------------------------------------------------------------------
DCIOFFSCREEN struc
	dcioInfo		 	db size DCISURFACEINFO dup (?)
	dcioDWDraw                 	dd  ?
	dcioDWSetClipList           	dd  ?
	dcioDWSetDestination       	dd  ?
DCIOFFSCREEN ends

;----------------------------------------------------------------------------
; used with DCICREATEOVERLAYSURFACE
;----------------------------------------------------------------------------
DCIOVERLAY struc
	dcivInfo			db size DCISURFACEINFO dup (?)
	dcivDWChromaKeyValue 		dd (?)
	dcivDWChromaKeyMask		dd (?)
DCIOVERLAY ends

endif	; _INC_DCIDDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\stretch.asm ===
page    ,132
;----------------------------Module-Header------------------------------;
; Module Name: STRETCH32.ASM
;
; StretchBLT for DIBs
;
; NOTES:
;       - Does not handle mirroring in x or y.
;       - Does not handle pixel translation
;       - will not work "in place"
;
;       - This is the 32 bit version (32 bit code seg that is...)
;
;  AUTHOR: ToddLa (Todd Laney) Microsoft
;
;-----------------------------------------------------------------------;
?PLM=1
?WIN=0
	.xlist
        include cmacro32.inc
;       include cmacros.inc
        include windows.inc
	.list

sBegin  Data
sEnd    Data

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        .386
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;--------------------------------------------------------------------------;
;
;   DDA type constants returned from stretch_init_dda
;
;--------------------------------------------------------------------------;

STRETCH_1to1    equ     (0*4)       ;   dst = src
STRETCH_1to2    equ     (1*4)       ;   dst = src * 2
STRETCH_1to4    equ     (2*4)       ;   dst = src * 4
STRETCH_1toN    equ     (3*4)       ;   dst > src
STRETCH_2to1    equ     (4*4)       ;   dst = src / 2
STRETCH_4to1    equ     (5*4)       ;   dst = src / 4
STRETCH_Nto1    equ     (6*4)       ;   dst < src
STRETCH_VOID    equ     (7*4)       ;   not used.

;--------------------------------------------------------------------------;
;
; x_stretch_functions
;
;     functions for stretching a single scanline, this table is indexed
;     by the x dda type (see above) and the bit depth
;
;--------------------------------------------------------------------------;

x_stretch_functions label dword             ;function table for x_stretch

x_stretch_8_functions label dword           ;function table for x_stretch
        dd      x_stretch_1to1              ; STRETCH_1to1
        dd      x_stretch_8_1to2            ; STRETCH_1to2
        dd      x_stretch_8_1to4            ; STRETCH_1to4
        dd      x_stretch_8_1toN            ; STRETCH_1toN
        dd      x_stretch_8_Nto1            ; STRETCH_2to1
        dd      x_stretch_8_Nto1            ; STRETCH_4to1
        dd      x_stretch_8_Nto1            ; STRETCH_Nto1
        dd      0

x_stretch_16_functions label dword          ;function table for x_stretch
        dd      x_stretch_1to1              ; STRETCH_1to1
        dd      x_stretch_16_1to2           ; STRETCH_1to2
        dd      x_stretch_16_1toN           ; STRETCH_1to4
        dd      x_stretch_16_1toN           ; STRETCH_1toN
        dd      x_stretch_16_Nto1           ; STRETCH_2to1
        dd      x_stretch_16_Nto1           ; STRETCH_4to1
        dd      x_stretch_16_Nto1           ; STRETCH_Nto1
        dd      0

x_stretch_24_functions label dword          ;function table for x_stretch
        dd      x_stretch_1to1              ; STRETCH_1to1
        dd      x_stretch_24_1toN           ; STRETCH_1to2
        dd      x_stretch_24_1toN           ; STRETCH_1to4
        dd      x_stretch_24_1toN           ; STRETCH_1toN
        dd      x_stretch_24_Nto1           ; STRETCH_2to1
        dd      x_stretch_24_Nto1           ; STRETCH_4to1
        dd      x_stretch_24_Nto1           ; STRETCH_Nto1
        dd      0

x_stretch_32_functions label dword          ;function table for x_stretch
        dd      x_stretch_1to1              ; STRETCH_1to1
        dd      x_stretch_32_1to2           ; STRETCH_1to2
        dd      x_stretch_32_1toN           ; STRETCH_1to4
        dd      x_stretch_32_1toN           ; STRETCH_1toN
        dd      x_stretch_32_Nto1           ; STRETCH_2to1
        dd      x_stretch_32_Nto1           ; STRETCH_4to1
        dd      x_stretch_32_Nto1           ; STRETCH_Nto1
        dd      0

;--------------------------------------------------------------------------;
;
; y_stretch_functions
;
;     functions for stretching in the y direction, indexed by the y dda type
;
;--------------------------------------------------------------------------;

y_stretch_functions label dword             ;function table for y_stretch
        dd      y_stretch_1toN              ; STRETCH_1to1
        dd      y_stretch_1toN              ; STRETCH_1to2
        dd      y_stretch_1toN              ; STRETCH_1to4
        dd      y_stretch_1toN              ; STRETCH_1toN
        dd      y_stretch_Nto1              ; STRETCH_2to1
        dd      y_stretch_Nto1              ; STRETCH_4to1
        dd      y_stretch_Nto1              ; STRETCH_Nto1

;--------------------------------------------------------------------------;
;
; stretch_functions
;
;   special case stretching routines, used if (y dda type) = (x dda type)
;   (and entry exists in this table)
;
;   these functions stretch the entire image.
;
;--------------------------------------------------------------------------;

stretch_functions label dword

stretch_8_functions label dword
        dd      0                           ; STRETCH_1to1
        dd      stretch_8_1to2              ; STRETCH_1to2
        dd      0                           ; STRETCH_1to4
        dd      0                           ; STRETCH_1toN
        dd      0                           ; STRETCH_2to1
        dd      0                           ; STRETCH_4to1
        dd      0                           ; STRETCH_Nto1
        dd      0

stretch_16_functions label dword
        dd      0                           ; STRETCH_1to1
        dd      stretch_16_1to2             ; STRETCH_1to2
        dd      0                           ; STRETCH_1to4
        dd      0                           ; STRETCH_1toN
        dd      0                           ; STRETCH_2to1
        dd      0                           ; STRETCH_4to1
        dd      0                           ; STRETCH_Nto1
        dd      0

stretch_24_functions label dword
        dd      0                           ; STRETCH_1to1
        dd      0                           ; STRETCH_1to2
        dd      0                           ; STRETCH_1to4
        dd      0                           ; STRETCH_1toN
        dd      0                           ; STRETCH_2to1
        dd      0                           ; STRETCH_4to1
        dd      0                           ; STRETCH_Nto1
        dd      0

stretch_32_functions label dword
        dd      0                           ; STRETCH_1to1
        dd      0                           ; STRETCH_1to2
        dd      0                           ; STRETCH_1to4
        dd      0                           ; STRETCH_1toN
        dd      0                           ; STRETCH_2to1
        dd      0                           ; STRETCH_4to1
        dd      0                           ; STRETCH_Nto1
        dd      0

;--------------------------------------------------------------------------;
;
;   StretchDIB()
;
;   Entry:
;       Stack based parameters as described below.
;
;   Returns:
;       none
;
;   Registers Preserved:
;       DS,ES,ESI,EDI,EBP
;
;--------------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing        

cProc   StretchDIB,<FAR,PUBLIC,PASCAL>,<>
        parmD   biDst                   ;--> BITMAPINFO of dest
        parmD   lpDst                   ;--> to destination bits
        parmW   DstX                    ;Destination origin - x coordinate
        parmW   DstY                    ;Destination origin - y coordinate
        parmW   DstXE                   ;x extent of the BLT
        parmW   DstYE                   ;y extent of the BLT
        parmD   biSrc                   ;--> BITMAPINFO of source
        parmD   lpSrc                   ;--> to source bits
        parmW   SrcX                    ;Source origin - x coordinate
        parmW   SrcY                    ;Source origin - y coordinate
        parmW   SrcXE                   ;x extent of the BLT
        parmW   SrcYE                   ;y extent of the BLT

        localD  x_stretch               ;X stretch function
        localD  y_stretch               ;Y stretch function

        localD  x_stretch_dda           ;X stretch DDA
        localD  x_stretch_dda_fract     ;X stretch DDA fract

        localD  y_stretch_dda           ;Y stretch DDA
        localD  y_stretch_dda_fract     ;Y stretch DDA fract

        localD  ScanCount               ;number of scans left to do
        localD  Yerr                    ;Y dda error

        localD  SrcWidth                ;width of source dib in bytes
        localD  DstWidth                ;width of dest in bytes

        localD  SrcBytes                ;width of source blt in bytes
        localD  DstBytes                ;width of dest blt in bytes

        localD  SrcInc
        localD  DstInc

        localD  lDstXE                  ;x extent of the BLT
        localD  lDstYE                  ;y extent of the BLT
        localD  lSrcXE                  ;x extent of the BLT
        localD  lSrcYE                  ;y extent of the BLT
cBegin
        cld

        push    esi
        push    edi
        push    ds

	call	stretch_init	; init all the frame variables
        jc      short StretchDIBExit

        call    y_stretch       ; do it!

StretchDIBExit:
        pop     ds
        pop     edi
        pop     esi
cEnd

;--------------------------------------------------------------------------;
;
;   stretch_init_dda
;
;       initialize the parameters of a DDA from ax to dx.
;
;   Entry:
;       eax         - source coord
;       edx         - dest coord
;   Returns:
;       eax         - STRETCH_1to1
;                     STRETCH_1to2
;                     STRETCH_1to4
;                     STRETCH_1toN
;                     STRETCH_2to1
;                     STRETCH_4to1
;                     STRETCH_Nto1
;
;       edx         - src / dst
;       ebx         - src / dst fraction
;
;--------------------------------------------------------------------------;

stretch_init_dda proc near

        cmp     eax,edx
        je      short stretch_init_dda_1to1
        ja      short stretch_init_dda_Nto1
        errn$   stretch_init_dda_1toN

stretch_init_dda_1toN:
        mov     ebx,eax
        add     ebx,ebx
        cmp     ebx,edx
        je      short stretch_init_dda_1to2
        add     ebx,ebx
        cmp     ebx,edx
        je      short stretch_init_dda_1to4

        mov     ebx,edx             ; ebx = dest
        mov     edx,eax             ; edx = src
        xor     eax,eax             ; edx:eax = src<<32
        div     ebx                 ; eax = (src<<32)/dst

        mov     ebx,eax
        xor     edx,edx
        mov     eax,STRETCH_1toN
        ret

stretch_init_dda_Nto1:
        mov     ebx,edx
        add     ebx,ebx
        cmp     eax,ebx
        je      short stretch_init_dda_2to1
        add     ebx,ebx
        cmp     eax,ebx
        je      short stretch_init_dda_4to1

        mov     ebx,edx             ; ebx = dst
        xor     edx,edx             ; edx:eax = src
        mov     eax,eax
        div     ebx                 ; eax = src/dst edx = rem
        push    eax
        xor     eax,eax             ; edx:eax = rem<<32
        div     ebx                 ; eax = rem<<32/dst
        mov     ebx,eax
        pop     edx
        mov     eax,STRETCH_Nto1
        ret

stretch_init_dda_1to1:
        mov     edx, 1
        xor     ebx, ebx
        mov     eax, STRETCH_1to1
        ret

stretch_init_dda_1to2:
        xor     edx, edx
        mov     ebx, 80000000h
        mov     eax, STRETCH_1to2
        ret

stretch_init_dda_1to4:
        xor     edx, edx
        mov     ebx, 40000000h
        mov     eax, STRETCH_1to4
        ret

stretch_init_dda_2to1:
        mov     edx, 2
        xor     ebx, ebx
        mov     eax, STRETCH_2to1
        ret

stretch_init_dda_4to1:
        mov     edx, 4
        xor     ebx, ebx
        mov     eax, STRETCH_4to1
        ret

stretch_init_dda endp

;--------------------------------------------------------------------------;
;
;   stretch_init
;
;   init local frame vars for StretchDIB
;
;   ENTRY:
;       ss:bp   --> stretchdib frame
;
;--------------------------------------------------------------------------;

stretch_init_error:
        stc
        ret

stretch_init proc near

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   expand word params to dwords
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        movzx   eax,DstXE
        movzx   ebx,DstYE
        movzx   ecx,SrcXE
        movzx   edx,SrcYE

        mov     lDstXE,eax
        mov     lDstYE,ebx
        mov     lSrcXE,ecx
        mov     lSrcYE,edx

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; Make sure they didn't give us an extent of zero anywhere
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        or      eax,eax
        jz      short stretch_init_error

        or      ebx,ebx
        jz      short stretch_init_error

        or      ecx,ecx
        jz      short stretch_init_error

        or      edx,edx
        jz      short stretch_init_error

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;   make sure the bit depth of the source and dest match and are valid
;   we only handle 8,16,24 bit depths.
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        xor     edi,edi                     ; be sure the high words are clear.
	xor	esi,esi
        xor     ecx,ecx

        lds     si, biSrc
        les     di, biDst

        mov     cx, [esi].biBitCount        ; get the bit depth
        cmp     cx, es:[edi].biBitCount     ; make sure they are the same.
        jne     short stretch_init_error

        cmp     ecx,8
        je      short stretch_init_bit_depth_ok

        cmp     ecx,16
        je      short stretch_init_bit_depth_ok

        cmp     ecx,24
        je      short stretch_init_bit_depth_ok

        cmp     ecx,32
        jne     short stretch_init_error
        errn$   stretch_init_bit_depth_ok

stretch_init_bit_depth_ok:

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Set up the initial source pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        mov     eax,[esi].biWidth
        mul     ecx
        add     eax,31
        and     eax,not 31
        shr     eax,3
        mov     SrcWidth,eax
        mov     SrcInc,eax

        lds     si,lpSrc

        movzx   edx,SrcY
        mul     edx
	add	esi,eax

        movzx   eax,SrcX
        mul     ecx
        shr     eax,3
        add     esi,eax

        mov     eax,lSrcXE
        mul     ecx
        shr     eax,3
        mov     SrcBytes,eax
        sub     SrcInc,eax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Set up the initial dest pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        mov     eax,es:[edi].biWidth
        mul     ecx
        add     eax,31
        and     eax,not 31
        shr     eax,3
        mov     DstWidth,eax
        mov     DstInc,eax

        cmp     es:[edi].biHeight,0            ; init a upside down DIB
        jge     short @f
        movsx   ebx,DstY
        add     ebx,es:[edi].biHeight
        not     ebx
        mov     DstY,bx
        neg     DstWidth
        neg     DstInc
@@:
        les     di,lpDst

        movsx   edx,DstY
        mul     edx
	add	edi,eax

        movsx   eax,DstX
        mul     ecx
        shr     eax,3
        add     edi,eax

        mov     eax,lDstXE
        mul     ecx
        shr     eax,3
        mov     DstBytes,eax
        sub     DstInc,eax

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  conver the bit depth (in cx) to a table index
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        sub     ecx,8                   ; cx = 0,8,16,24
        shl     ecx,2                   ; cx = (0,1,2,3) * 32

        errnz   <stretch_16_functions - stretch_8_functions - 32>
        errnz   <stretch_24_functions - stretch_16_functions - 32>
        errnz   <stretch_32_functions - stretch_24_functions - 32>

        errnz   <x_stretch_16_functions - x_stretch_8_functions - 32>
        errnz   <x_stretch_24_functions - x_stretch_16_functions - 32>
        errnz   <x_stretch_32_functions - x_stretch_24_functions - 32>

        errnz   <STRETCH_1to2 - STRETCH_1to1 - 4>

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Setup y_stretch function pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        mov     eax,lSrcYE
        mov     edx,lDstYE
        call    stretch_init_dda
        mov     y_stretch_dda,edx
        mov     y_stretch_dda_fract,ebx

        mov     ebx,eax
        mov     edx,y_stretch_functions[ebx]
        mov     y_stretch,edx

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  Setup x_stretch function pointer
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        push    eax                     ; Save Y stretch type
        mov     eax,lSrcXE
        mov     edx,lDstXE

        call    stretch_init_dda
        mov     x_stretch_dda,edx
        mov     x_stretch_dda_fract,ebx

        mov     ebx,eax                 ; get x stretch
        or      ebx,ecx                 ; or in bit depth
        mov     edx,x_stretch_functions[ebx]
        mov     x_stretch,edx

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
;
;  check for a special case stretch routine
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
        pop     edx                     ; get y stretch back
        cmp     eax,edx                 ; is x stretch == to y stretch?
        jne     short stretch_init_exit

        or      ebx,ecx
        mov     edx,stretch_functions[ebx]
        or      edx,edx
        jz      short stretch_init_exit

        mov     y_stretch,edx           ; we have special case routine.
        errn$   stretch_init_exit

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

stretch_init_exit:
        clc
        ret

stretch_init endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------------------------------------------------------;
;
;   y_stretch_1toN
;
;   do the entire stretch, y stretching  (DstYE > SrcYE)
;
;   Entry:
;       ds:esi  --> (SrcX, SrcY) in source
;       es:edi  --> (DstX, DstY) in destination
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       none. (stretch is done.)
;--------------------------------------------------------------------------;
y_stretch_1toN proc near
        mov     ecx,lDstYE
        mov     ScanCount,ecx

        mov     edx,lDstYE          ; dda error
        dec     edx
        mov     Yerr,edx

y_stretch_1toN_loop:
        push    esi
        push    edi
        call    x_stretch
        pop     edi
        pop     esi

        add     edi, DstWidth       ; next dest scan.

        mov     eax,lSrcYE
        sub     Yerr,eax
        jnc     short y_stretch_1toN_next

        mov     eax,lDstYE
        add     Yerr,eax

        add     esi, SrcWidth       ; next source scan.

y_stretch_1toN_next:
        dec     ScanCount
        jnz     short y_stretch_1toN_loop

        ret

y_stretch_1toN endp

;--------------------------------------------------------------------------;
;
;   y_stretch_Nto1
;
;   do the entire stretch, y shrinking   (DstYE < SrcYE)
;
;   Entry:
;       ds:esi  --> (SrcX, SrcY) in source
;       es:edi  --> (DstX, DstY) in destination
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       none. (stretch is done.)
;--------------------------------------------------------------------------;
y_stretch_Nto1 proc near
        mov     ecx,lDstYE
        mov     ScanCount,ecx

        mov     edx,lSrcYE          ; dda error
        dec     edx
        mov     Yerr,edx

y_stretch_Nto1_loop:
        push    esi
        push    edi
        call    x_stretch
        pop     edi
        pop     esi

        add     edi, DstWidth       ; next dest scan.

        mov     eax, lDstYE
@@:     add     esi, SrcWidth       ; next source scan.
        sub     Yerr, eax
        jnc     short @b

        mov     eax,lSrcYE
        add     Yerr,eax

y_stretch_Nto1_next:
        dec     ScanCount
        jnz     short y_stretch_Nto1_loop

        ret

y_stretch_Nto1 endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------------------------------------------------------;
;
;   x_stretch_1to1
;
;   handle a stretch of a scanline  (DstXE == SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_1to1 proc near

        mov     ecx,DstBytes        ; number of bytes to copy
        mov     ebx,ecx

        shr     ecx,2               ; get count in DWORDs
        rep     movs dword ptr es:[edi], dword ptr ds:[esi]
        mov     ecx,ebx
        and     ecx,3
	rep	movs byte ptr es:[edi], byte ptr ds:[esi]
        ret

x_stretch_1to1 endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8 BIT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------------------------------------------------------;
;
;   x_stretch_8_1toN
;
;   handle a stretch of a scanline  (DstXE > SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_8_1toN proc near

        mov     ebx,x_stretch_dda_fract
        xor     edx,edx
        mov     ecx,lDstXE          ; # bytes to store
        shr     ecx,2               ; unroll by 4
        jz      short x_stretch_8_1toN_next
align 4
x_stretch_8_1toN_loop:
rept 2
        mov     al,byte ptr ds:[esi]
        add     edx,ebx
        adc     esi,0
        mov     ah,byte ptr ds:[esi]
        add     edx,ebx
        adc     esi,0
        ror     eax,16
endm
        mov     dword ptr es:[edi],eax
        add     edi,4
        dec     ecx
        jnz     short x_stretch_8_1toN_loop

x_stretch_8_1toN_next:
        mov     ecx,lDstXE
        and     ecx,3
        jnz     short x_stretch_8_1toN_odd
        ret

x_stretch_8_1toN_odd:
        mov     al,byte ptr ds:[esi]
        mov     byte ptr es:[edi],al
        add     edx,ebx
        adc     esi,0
        inc     edi
        dec     ecx
        jnz     short x_stretch_8_1toN_odd
        ret

x_stretch_8_1toN endp

;--------------------------------------------------------------------------;
;
;   x_stretch_8_1to2
;
;   handle a stretch of a scanline  (DstXE > SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_8_1to2 proc near
        mov     ecx,lSrcXE          ; loop cout
        mov     ebx,ecx
        shr     ecx,1
        jz      short x_stretch_8_1to2_next
align 4
x_stretch_8_1to2_loop:
        mov     ax, word ptr ds:[esi]   ; get 2 pixels
        add     esi,2

        mov     edx,eax
        mov     al,ah
        shl     eax,16
        mov     al,dl
        mov     ah,dl
        mov     dword ptr es:[edi], eax ; store 4
        add     edi,4
        dec     ecx
        jnz     short x_stretch_8_1to2_loop

x_stretch_8_1to2_next:
        test    ebx,1
        jnz     short x_stretch_8_1to2_done
        ret

x_stretch_8_1to2_done:
        mov     al,byte ptr ds:[esi]
        mov     ah,al
        mov     word ptr es:[edi],ax
        inc     esi
        add     edi,2
        ret

x_stretch_8_1to2 endp

;--------------------------------------------------------------------------;
;
;   x_stretch_8_1to4
;
;   handle a stretch of a scanline  (DstXE > SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;
;--------------------------------------------------------------------------;
align 4
x_stretch_8_1to4 proc near
        mov     ecx,lSrcXE           ; loop cout
        mov     ebx,ecx
        shr     ecx,1
        jz      short x_stretch_8_1to4_next
align 4
x_stretch_8_1to4_loop:
;       lods    word ptr ds:[esi]   ; get 2 pixels
        mov     ax,word ptr ds:[esi]   ; get 2 pixels
        add     esi,2

        mov     edx,eax
        mov     ah,al
        shl     eax,16
        mov     al,dl
        mov     ah,dl
;       stos    dword ptr es:[edi]  ; store 4
        mov     dword ptr es:[edi],eax
        add     edi,4

        mov     ax,dx
        mov     al,ah
        shl     eax,16
        mov     ax,dx
        mov     al,ah
;       stos    dword ptr es:[edi]  ; store 4
        mov     dword ptr es:[edi],eax  ; store 4
        add     edi,4

        dec     ecx
        jnz     short x_stretch_8_1to4_loop

x_stretch_8_1to4_next:
        test    ebx,1
        jnz     short x_stretch_8_1to4_done
        ret

x_stretch_8_1to4_done:
        mov     al,byte ptr ds:[esi]
        mov     ah,al
        mov     dx,ax
        shl     eax,16
        mov     ax,dx
        mov     dword ptr es:[edi],eax
        inc     esi
        add     edi,4
        ret

x_stretch_8_1to4 endp

;--------------------------------------------------------------------------;
;
;   x_stretch_8_Nto1
;
;   handle a shrink of a scanline  (DstXE < SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ecx     -   destination pixels to write
;       edx     -   source pixels to copy
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_8_Nto1 proc near
        mov     ebx,x_stretch_dda_fract
        xor     edx,edx

        mov     ecx,lDstXE                      ; # bytes to store
        shr     ecx,2
        jz      short x_stretch_8_Nto1_cleanup

        push    ebp
        mov     ebp,x_stretch_dda
align 4
x_stretch_8_Nto1_loop:
rept    4
        mov     al,byte ptr ds:[esi]
        ror     eax,8
        add     edx,ebx
        adc     esi,ebp
endm
        mov     dword ptr es:[edi],eax
        add     edi,4
        dec     ecx
        jnz     short x_stretch_8_Nto1_loop
        pop     ebp

x_stretch_8_Nto1_cleanup:
        mov     ecx,lDstXE
        and     ecx,011b
        jnz     short x_stretch_8_Nto1_loop2
        ret

x_stretch_8_Nto1_loop2:
        mov     al,byte ptr ds:[esi]
        mov     byte ptr es:[edi],al
        inc     edi
        add     edx,ebx
        adc     esi,x_stretch_dda
        dec     ecx
        jnz     short x_stretch_8_Nto1_loop2
        ret

x_stretch_8_Nto1 endp

;--------------------------------------------------------------------------;
;
;   stretch_8_1to2
;
;   handle a x2 stretch of a entire image
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
stretch_8_1to2 proc near
        mov     eax, DstWidth
        add     DstInc, eax

        mov     ecx, lSrcXE
        mov     ebx, DstWidth
align 4
stretch_8_1to2_outer_loop:
        mov     ecx,lSrcXE          ; loop cout (/4)
        shr     ecx,2
        jz      short stretch_8_1to2_next
align 4
stretch_8_1to2_loop:
        mov     edx, dword ptr ds:[esi]   ; get 4 pixels
        mov     al,dh
        mov     ah,dh
        shl     eax,16
        mov     al,dl
        mov     ah,dl
        mov     dword ptr es:[edi], eax     ; store 4
        mov     dword ptr es:[edi+ebx], eax ; store 4

        shr     edx,16

        mov     al,dh
        mov     ah,dh
        shl     eax,16
        mov     al,dl
        mov     ah,dl
        mov     dword ptr es:[edi+4], eax     ; store 4
        mov     dword ptr es:[edi+4+ebx], eax ; store 4

        add     edi,8
        add     esi,4

        dec     ecx
        jnz     short stretch_8_1to2_loop

stretch_8_1to2_next:
        mov     ecx,lSrcXE
        and     ecx,3
        jnz     short stretch_8_1to2_odd

stretch_8_1to2_even:
        add     edi, DstInc
        add     esi, SrcInc

        dec     lSrcYE
        jnz     short stretch_8_1to2_outer_loop
        ret

stretch_8_1to2_odd:
        mov     al,byte ptr ds:[esi]
        mov     ah,al
        mov     word ptr es:[edi],ax
        mov     word ptr es:[edi+ebx],ax
        inc     esi
        add     edi,2
        dec     ecx
        jnz     short stretch_8_1to2_odd
        jz      short stretch_8_1to2_even

stretch_8_1to2 endp


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;16 BIT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------------------------------------------------------;
;
;   x_stretch_16_1toN
;
;   handle a stretch of a scanline  (DstXE > SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_16_1toN proc near
        xor     edx,edx

        mov     ecx,lDstXE
        shr     ecx,1
        jz      short x_stretch_16_1toN_cleanup

align 4
x_stretch_16_1toN_loop:
rept 2
        mov     ax,word ptr ds:[esi]
        ror     eax,16

        add     edx, x_stretch_dda_fract
        sbb     ebx, ebx                ; ebx = CF ? -1 : 0
        and     ebx, 2
        add     esi, ebx
endm
        mov     dword ptr es:[edi],eax
        add     edi,4

        dec     ecx
        jnz     short x_stretch_16_1toN_loop

x_stretch_16_1toN_cleanup:
        test    byte ptr DstXE, 1
        jnz     short x_stretch_16_1toN_odd
        ret

x_stretch_16_1toN_odd:
        mov     ax,word ptr ds:[esi]
        mov     word ptr es:[edi],ax
        add     esi,2
        add     edi,2
        ret

x_stretch_16_1toN endp

;--------------------------------------------------------------------------;
;
;   x_stretch_16_1to2
;
;   handle a stretch of a scanline  (DstXE > SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_16_1to2 proc near
        mov     ecx,lSrcXE          ; loop cout
        mov     ebx,ecx
        shr     ecx,1
        jz      short x_stretch_16_1to2_done
align 4
x_stretch_16_1to2_loop:
	mov	eax, dword ptr ds:[esi] ; get 2 pixels
	add	esi,4

	mov	edx,eax
        shl     eax,16
        mov     ax,dx
	mov	dword ptr es:[edi], eax ; store 2
	add	edi,4

	mov	eax,edx
	shr	edx,16
        mov     ax,dx
	mov	dword ptr es:[edi], eax ; store 2
	add	edi,4

        dec     ecx
        jnz     short x_stretch_16_1to2_loop

x_stretch_16_1to2_done:
        test    ebx,1
        jnz     short x_stretch_16_1to2_odd
        ret

x_stretch_16_1to2_odd:
        mov     bx,word ptr ds:[esi]
        mov     eax,ebx
        shl     eax,16
        mov     ax,bx
        mov     dword ptr es:[edi],eax
        add     esi,2
        add     edi,4
        ret

x_stretch_16_1to2 endp

;--------------------------------------------------------------------------;
;
;   x_stretch_16_Nto1
;
;   handle a shrink of a scanline  (DstXE < SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ecx     -   destination pixels to write
;       edx     -   source pixels to copy
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_16_Nto1 proc near
        mov     ecx,lDstXE            ; # loop count
        mov     ebx,x_stretch_dda_fract
        xor     edx,edx

        push    ebp
        mov     ebp,x_stretch_dda
        dec     ebp
        add     ebp,ebp
align 4
x_stretch_16_Nto1_loop:
        movs    word ptr es:[edi], word ptr ds:[esi]
        add     esi,ebp
        add     edx,ebx
        sbb     eax,eax
        and     eax,2
        add     esi,eax

        dec     ecx
        jnz     short x_stretch_16_Nto1_loop
        pop     ebp

x_stretch_16_Nto1_exit:
        ret

x_stretch_16_Nto1 endp

;--------------------------------------------------------------------------;
;
;   stretch_16_1to2
;
;   handle a x2 stretch of a entire image
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
stretch_16_1to2 proc near
        mov     ebx, DstWidth
        add     DstInc, ebx
align 4
stretch_16_1to2_outer_loop:
        mov     ecx,lSrcXE                 ; loop cout (/2)
        shr     ecx,1
        jz      short stretch_16_1to2_next
align 4
stretch_16_1to2_loop:
        mov     edx, dword ptr ds:[esi]   ; get 2 pixels

        mov     ax,dx
        shl     eax,16
        mov     ax,dx
        mov     dword ptr es:[edi], eax     ; store 2
        mov     dword ptr es:[edi+ebx], eax ; store 2

        shr     edx,16

        mov     ax,dx
        shl     eax,16
        mov     ax,dx
        mov     dword ptr es:[edi+4], eax     ; store 2
        mov     dword ptr es:[edi+4+ebx], eax ; store 2

        add     edi,8
        add     esi,4

        dec     ecx
        jnz     short stretch_16_1to2_loop

stretch_16_1to2_next:
        test    lSrcXE,1
        jnz     short stretch_16_1to2_odd

stretch_16_1to2_even:
        add     edi, DstInc
        add     esi, SrcInc

        dec     SrcYE
        jnz     short stretch_16_1to2_outer_loop
        ret

stretch_16_1to2_odd:
        mov     dx,word ptr ds:[esi]
        mov     ax,dx
        shl     eax,16
        mov     ax,dx
        mov     dword ptr es:[edi],eax
        mov     dword ptr es:[edi+ebx],eax
        add     esi,2
        add     edi,4
        jmp     short stretch_16_1to2_even

stretch_16_1to2 endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;24 BIT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------------------------------------------------------;
;
;   x_stretch_24_1toN
;
;   handle a stretch of a scanline  (DstXE > SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_24_1toN proc near

        mov     ecx,lDstXE            ; # loop count
        mov     ebx,x_stretch_dda_fract
        xor     edx,edx
align 4
x_stretch_24_1toN_loop:
        movs    word ptr es:[edi], word ptr ds:[esi]
        movs    byte ptr es:[edi], byte ptr ds:[esi]
        add     edx,ebx
        sbb     eax,eax
        not     eax
        and     eax,-3
        add     esi,eax

        dec     ecx
        jnz     short x_stretch_24_1toN_loop

x_stretch_24_1toN_exit:
        ret

x_stretch_24_1toN endp

;--------------------------------------------------------------------------;
;
;   x_stretch_24_Nto1
;
;   handle a shrink of a scanline  (DstXE < SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ecx     -   destination pixels to write
;       edx     -   source pixels to copy
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_24_Nto1 proc near
        mov     ecx,lDstXE            ; # loop count
        mov     ebx,x_stretch_dda_fract
        xor     edx,edx

        push    ebp
        mov     ebp,x_stretch_dda
        dec     ebp
        mov     eax,ebp
        add     ebp,ebp
        add     ebp,eax
align 4
x_stretch_24_Nto1_loop:
        movs    word ptr es:[edi], word ptr ds:[esi]
        movs    byte ptr es:[edi], byte ptr ds:[esi]
        add     esi,ebp
        add     edx,ebx
        sbb     eax,eax
        and     eax,3
        add     esi,eax

        dec     ecx
        jnz     short x_stretch_24_Nto1_loop
        pop     ebp

x_stretch_24_Nto1_exit:
        ret

x_stretch_24_Nto1 endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;32 BIT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------------------------------------------------------;
;
;   x_stretch_32_1toN
;
;   handle a stretch of a scanline  (DstXE > SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_32_1toN proc near
        xor     edx,edx

        mov     ecx,lDstXE
align 4
x_stretch_32_1toN_loop:
        mov     eax,word ptr ds:[esi]
        add     edx, x_stretch_dda_fract
        sbb     ebx, ebx                ; ebx = CF ? -1 : 0
        and     ebx, 4
        add     esi, ebx
        mov     dword ptr es:[edi],eax
        add     edi,4

        dec     ecx
        jnz     short x_stretch_32_1toN_loop

        ret

x_stretch_32_1toN endp

;--------------------------------------------------------------------------;
;
;   x_stretch_32_1to2
;
;   handle a stretch of a scanline  (DstXE > SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_32_1to2 proc near
        mov     ecx,lSrcXE          ; loop cout
align 4
x_stretch_32_1to2_loop:
        mov     eax, dword ptr ds:[esi]     ; get a pel
        mov     dword ptr es:[edi], eax     ; store it
        add     esi,4
        mov     dword ptr es:[edi+4], eax   ; store it again
        add     edi,8

        dec     ecx
        jnz     short x_stretch_32_1to2_loop

x_stretch_32_1to2_done:
        ret

x_stretch_32_1to2 endp

;--------------------------------------------------------------------------;
;
;   x_stretch_32_Nto1
;
;   handle a shrink of a scanline  (DstXE < SrcXE)
;
;   Entry:
;       ds:esi  --> begining of scan
;       es:edi  --> destination scan
;       ecx     -   destination pixels to write
;       edx     -   source pixels to copy
;       ss:bp   --> stack frame of StretchDIB
;   Returns:
;       ds:esi  --> at end of scan
;       es:edi  --> at end of scan
;   
;--------------------------------------------------------------------------;
align 4
x_stretch_32_Nto1 proc near
        mov     ecx,lDstXE            ; # loop count
        mov     ebx,x_stretch_dda_fract
        xor     edx,edx

        push    ebp
        mov     ebp,x_stretch_dda
        dec     ebp
        add     ebp,ebp
        add     ebp,ebp
align 4
x_stretch_32_Nto1_loop:
        movs    dword ptr es:[edi], dword ptr ds:[esi]
        add     esi,ebp
        add     edx,ebx
        sbb     eax,eax
        and     eax,4
        add     esi,eax

        dec     ecx
        jnz     short x_stretch_32_Nto1_loop
        pop     ebp

x_stretch_32_Nto1_exit:
        ret

x_stretch_32_Nto1 endp

sEnd    CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dvaati.c ===
/****************************************************************************

    DVA surface provider for a ATI Mach32 card.

    assumes a linear frame buffer

    assumes a hardware cursor

 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "lockbm.h"

extern NEAR PASCAL DetectATI(void);

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK ati_open_surface(LPVOID pv)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK ati_close_surface(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK ati_begin_access(LPVOID pv, int x, int y, int dx, int dy)
{
    //
    // ATI Mach32 has a HW cursor so we dont do anything
    // !!!we may need to check for the sysVM in background
    //
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK ati_end_access(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL ati_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    DWORD SizeImage;
    IBITMAP FAR *pbm;
    UINT sel;
    DWORD off;
    LPBITMAPINFOHEADER lpbi;

    if (nSurface != 0)
        return FALSE;

    pbm = GetPDevice(hdc);

    if (pbm == NULL || pbm->bmType == 0)
        return FALSE;

    if (pbm->bmType != 0x2000)
        return FALSE;

    if (!DetectATI())
        return FALSE;

    sel = ((WORD FAR  *)&pbm->bmBits)[2];
    off = ((DWORD FAR *)&pbm->bmBits)[0];

    SizeImage = (DWORD)(UINT)pbm->bmWidthBytes * (DWORD)(UINT)pbm->bmHeight;

    if (GetSelectorLimit(sel) != 0xFFFFFFFF || off < 4*1024*1024l)
        return FALSE;

    sel = 0;    // off is the linear offset.

    lpbi = &pdva->BitmapInfo;

    lpbi->biSize            = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth           = pbm->bmWidthBytes*8/pbm->bmBitsPixel;
    lpbi->biHeight          = -(int)pbm->bmHeight;
    lpbi->biPlanes          = pbm->bmPlanes;
    lpbi->biBitCount        = pbm->bmBitsPixel;
    lpbi->biCompression     = 0;
    lpbi->biSizeImage       = SizeImage;
    lpbi->biXPelsPerMeter   = pbm->bmWidthBytes;
    lpbi->biYPelsPerMeter   = 0;
    lpbi->biClrUsed         = 0;
    lpbi->biClrImportant    = 0;

    pdva->selSurface   = sel;
    pdva->offSurface   = off;
    pdva->Version      = 0x0100;
    pdva->Flags        = 0;
    pdva->lpSurface    = (LPVOID)42;

#ifdef DEBUG
{
//
// in DEBUG use the VGA's begin/end access routines so the mouse will flicker!
//
extern BOOL FAR PASCAL _loadds vga_open_surface(LPVOID pv);
extern void FAR PASCAL _loadds vga_close_surface(LPVOID pv);
extern BOOL FAR PASCAL _loadds vga_begin_access(LPVOID pv, int x, int y, int dx, int dy);
extern BOOL FAR PASCAL _loadds vga_end_access(LPVOID pv);
    (FARPROC)pdva->OpenSurface  = (FARPROC)vga_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vga_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)vga_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)vga_end_access;
}
#else
    (FARPROC)pdva->OpenSurface  = (FARPROC)ati_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)ati_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)ati_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)ati_end_access;
#endif
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dvaddi.inc ===
;----------------------------------------------------------------------------
; DVADDDI.INC
;
; Copyright (c) 1993 Microsoft Corporation
;
; DVA 1.0 Interface Definitions
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; E Q U A T E S
;----------------------------------------------------------------------------

DVAGETSURFACE       equ     3074d   ; GDI Escape for DVA
DVA_VERSION         equ     0100h   ; version number of DVA 1.0

;----------------------------------------------------------------------------
; DVASURFACEINFO structure
;----------------------------------------------------------------------------
DVASURFACEINFO  struc
  dvaBitmapInfo     db  40 dup(?)       ; BITMAPINFO of surface
  dvaMasks          dd  3 dup(?)        ; masks for BI_BITFIELDS
  dvaOffSurface     dd  ?               ; surface offset
  dvaSelSurface     dw  ?               ; surface selector
  dvaVersion        dw  ?               ; DVA Version
  dvaFlags          dd  ?               ; Flags
  dvaSurface        dd  ?               ; driver use.
  dvaOpenSurface    dd  ?               ; OpenSurface callback
  dvaCloseSurface   dd  ?               ; CloseSurface callback
  dvaBeginAccess    dd  ?               ; BeginAccess callback
  dvaEndAccess      dd  ?               ; EndAccess callback
  dvaShowSurface    dd  ?               ; ShowSurface callback
DVASURFACEINFO  ends

;----------------------------------------------------------------------------
; Definitions for DVASURFACEINFO.dvaFlags
;----------------------------------------------------------------------------

DVAF_1632_ACCESS    equ     0001h   ; must access using 16:32 pointers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dva.c ===
#include <windows.h>

#undef WINAPI
#define WINAPI FAR PASCAL _loadds

#include "dva.h"
#include "dciman.h"
#include "lockbm.h"

/****************************************************************************
 ***************************************************************************/

extern BOOL vga_get_surface(HDC, int, DVASURFACEINFO FAR *);
extern BOOL ati_get_surface(HDC, int, DVASURFACEINFO FAR *);

#ifdef DEBUG
//extern BOOL dib_get_surface(HDC, int, DVASURFACEINFO FAR *);
extern BOOL thun_get_surface(HDC,int, DVASURFACEINFO FAR *);
extern BOOL vlb_get_surface(HDC, int, DVASURFACEINFO FAR *);
#endif

#define GetDS() SELECTOROF((LPVOID)&ScreenSel)
static short ScreenSel;

static BOOL InitSurface(DVASURFACEINFO FAR *pdva);
static BOOL TestSurface(DVASURFACEINFO FAR *pdva);
static void SetSelLimit(UINT sel, DWORD limit);

/****************************************************************************
 ***************************************************************************/

static void FAR PASCAL DVAInit()
{
}

/****************************************************************************
 ***************************************************************************/

static void FAR PASCAL DVATerm()
{
    //
    // free screen alias
    //
    if (ScreenSel)
    {
        SetSelLimit(ScreenSel, 0);
        FreeSelector(ScreenSel);
        ScreenSel = 0;
    }
}

/****************************************************************************
 ***************************************************************************/

BOOL WINAPI DVAGetSurface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    //
    // should this be a function table? list?
    //
    if (!ati_get_surface(hdc, nSurface, pdva) &&
#ifdef DEBUG
//      !dib_get_surface(hdc, nSurface, pdva) &&
        !vlb_get_surface(hdc, nSurface, pdva) &&
        !thun_get_surface(hdc, nSurface, pdva) &&
#endif
        !vga_get_surface(hdc, nSurface, pdva))

        return FALSE;

    return InitSurface(pdva);
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK default_open_surface(LPVOID pv)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK default_close_surface(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK default_begin_access(LPVOID pv, int x, int y, int dx, int dy)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK default_end_access(LPVOID pv)
{
}


/****************************************************************************
 ***************************************************************************/

UINT CALLBACK default_show_surface(LPVOID pv, HWND hwnd, LPRECT src, LPRECT dst)
{
    return 1;
}

/****************************************************************************
 ***************************************************************************/

static BOOL InitSurface(DVASURFACEINFO FAR *pdva)
{
    LPBITMAPINFOHEADER lpbi;

    if (pdva->Version != 0x0100)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
        return FALSE;

    if (lpbi->biPlanes != 1)
        return FALSE;

    //
    // make the pointer a 16:16 pointer
    //
    if (pdva->offSurface >= 0x10000 &&
        !(pdva->Flags & DVAF_1632_ACCESS))
    {
        if (ScreenSel == NULL)
            ScreenSel = AllocSelector(GetDS());

        if (pdva->selSurface != 0)
            pdva->offSurface += GetSelectorBase(pdva->selSurface);

        SetSelectorBase(ScreenSel,pdva->offSurface);
        SetSelLimit(ScreenSel,lpbi->biSizeImage-1);

        pdva->offSurface = 0;
        pdva->selSurface = ScreenSel;
    }

    //
    // fill in defaults.
    //
    if (pdva->OpenSurface == NULL)
        pdva->OpenSurface = default_open_surface;

    if (pdva->CloseSurface == NULL)
        pdva->CloseSurface = default_close_surface;

    if (pdva->ShowSurface == NULL)
        pdva->ShowSurface = default_show_surface;

    if (pdva->BeginAccess == NULL)
    {
        pdva->BeginAccess = default_begin_access;
        pdva->EndAccess   = default_end_access;
    }

    //
    // only test RGB surfaces.
    //
    if (lpbi->biCompression == 0 ||
        lpbi->biCompression == BI_BITFIELDS ||
        lpbi->biCompression == BI_1632)
    {
        if (!TestSurface(pdva))
            return FALSE;
    }

    //
    // set BI_1632 if needed
    //
    if (pdva->Flags & DVAF_1632_ACCESS)
    {
        lpbi->biCompression = BI_1632;
    }

    return TRUE;
}

/****************************************************************************
 ***************************************************************************/
#pragma optimize("", off)
static void SetSelLimit(UINT sel, DWORD limit)
{
    if (limit >= 1024*1024l)
        limit = ((limit+4096) & ~4095) - 1;

    _asm
    {
        mov     ax,0008h            ; DPMI set limit
        mov     bx,sel
        mov     dx,word ptr limit[0]
        mov     cx,word ptr limit[2]
        int     31h
    }
}
#pragma optimize("", on)

/****************************************************************************
 ***************************************************************************/

#define ASM66 _asm _emit 0x66 _asm
#define DB    _asm _emit

#pragma optimize("", off)
static BYTE ReadByte(PDVA pdva, LPVOID lpBits, DWORD dw)
{
    BYTE b=42;

    DVABeginAccess(pdva, 0, 0, 1024, 1024);

    _asm {
        ASM66   xor     bx,bx
                les     bx,lpBits
        ASM66   add     bx,word ptr dw
                mov     ax,es
        ASM66   lsl     ax,ax
        ASM66   cmp     bx,ax
                ja      exit
        DB 26h ;mov     al,es:[ebx]
        DB 67h
        DB 8Ah
        DB 03h
                mov b,al
exit:
    }

    DVAEndAccess(pdva);

    return b;
}
#pragma optimize("", on)

/////////////////////////////////////////////////////////////////////////////
//
//  SetPixel
//
//  some cards cant't seam to do SetPixel right it is amazing they work at all
//
/////////////////////////////////////////////////////////////////////////////

static void SetPixelX(HDC hdc, int x, int y, COLORREF rgb)
{
    RECT rc;

    rc.left = x;
    rc.top  = y;
    rc.right = x+1;
    rc.bottom = y+1;

    SetBkColor(hdc, rgb);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}

#define SetPixel SetPixelX

/****************************************************************************
 ***************************************************************************/

static BOOL TestSurface(DVASURFACEINFO FAR *pdva)
{
    HDC hdc;
    int x,y,h,w,wb;
    COLORREF rgb,rgb0,rgb1,rgb2,rgb3,rgb4;
    DWORD dw;
    BYTE  b0,b1;
    UINT  uType=0;
    LPBITMAPINFOHEADER lpbi;
    LPVOID lpBits;
    HCURSOR hcur;

    if (!pdva->OpenSurface(pdva->lpSurface))
        return FALSE;

    lpbi = DVAGetSurfaceFmt(pdva);
    lpBits = DVAGetSurfacePtr(pdva);

    h = abs((int)lpbi->biHeight);
    w = (int)lpbi->biWidth;
    wb = (w * ((UINT)lpbi->biBitCount/8) + 3) & ~3;
    dw = (DWORD)(UINT)(h-1) * (DWORD)(UINT)wb;

    if ((int)lpbi->biHeight < 0)
        y = 0;
    else
        y = h-1;

#ifdef XDEBUG
    x = (int)lpbi->biWidth - 5;
    ((LPBYTE)lpBits) += x * (UINT)lpbi->biBitCount/8;
#else
    x = 0;
#endif

    hcur = SetCursor(NULL);
    hdc = GetDC(NULL);

    rgb = GetPixel(hdc, x, h-1-y);
    SetPixel(hdc, x, h-1-y, RGB(0,0,0));       GetPixel(hdc, x, h-1-y); b0 = ReadByte(pdva, lpBits, dw);
    SetPixel(hdc, x, h-1-y, RGB(255,255,255)); GetPixel(hdc, x, h-1-y); b1 = ReadByte(pdva, lpBits, dw);
    SetPixel(hdc, x, h-1-y,rgb);

    if (b0 != 0x00 || b1 == 0x00)
        goto done;

    rgb0 = GetPixel(hdc, x+0, y);
    rgb1 = GetPixel(hdc, x+1, y);
    rgb2 = GetPixel(hdc, x+2, y);
    rgb3 = GetPixel(hdc, x+3, y);
    rgb4 = GetPixel(hdc, x+4, y);

    TestSurfaceType(hdc, x, y);

    DVABeginAccess(pdva, x, y, 5, 1);
    uType = GetSurfaceType(lpBits);
    DVAEndAccess(pdva);

    SetPixel(hdc, x+0, y,rgb0);
    SetPixel(hdc, x+1, y,rgb1);
    SetPixel(hdc, x+2, y,rgb2);
    SetPixel(hdc, x+3, y,rgb3);
    SetPixel(hdc, x+4, y,rgb4);

done:
    ReleaseDC(NULL, hdc);
    SetCursor(hcur);

    pdva->CloseSurface(pdva->lpSurface);

    switch (uType)
    {
        case BM_8BIT:
            break;

        case BM_16555:
            ((LPDWORD)(lpbi+1))[0] = 0x007C00;
            ((LPDWORD)(lpbi+1))[1] = 0x0003E0;
            ((LPDWORD)(lpbi+1))[2] = 0x00001F;
            break;

        case BM_24BGR:
        case BM_32BGR:
            ((LPDWORD)(lpbi+1))[0] = 0xFF0000;
            ((LPDWORD)(lpbi+1))[1] = 0x00FF00;
            ((LPDWORD)(lpbi+1))[2] = 0x0000FF;
            break;

        case BM_16565:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x00F800;
            ((LPDWORD)(lpbi+1))[1] = 0x0007E0;
            ((LPDWORD)(lpbi+1))[2] = 0x00001F;
            break;

	case BM_24RGB:
        case BM_32RGB:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x0000FF;
            ((LPDWORD)(lpbi+1))[1] = 0x00FF00;
            ((LPDWORD)(lpbi+1))[2] = 0xFF0000;
            break;
    }

    return uType != 0;
}

/****************************************************************************
 map DCI escapes to old DVA stuff.
 ***************************************************************************/

UINT CALLBACK dci_begin_access(DCISURFACEINFO FAR *pdci, RECT FAR *prc)
{
    DVASURFACEINFO FAR *pdva = (DVASURFACEINFO FAR *)pdci->dwReserved1;

    if (pdva->BeginAccess(pdva->lpSurface,prc->left,prc->top,prc->right-prc->left,prc->bottom-prc->top))
        return 0;
    else
        return (UINT)-1;
}

void CALLBACK dci_end_access(DCISURFACEINFO FAR *pdci)
{
    DVASURFACEINFO FAR *pdva = (DVASURFACEINFO FAR *)pdci->dwReserved1;

    pdva->EndAccess(pdva->lpSurface);
}

void CALLBACK dci_destroy(DCISURFACEINFO FAR *pdci)
{
    DVASURFACEINFO FAR *pdva = (DVASURFACEINFO FAR *)pdci->dwReserved1;

    pdva->CloseSurface(pdva->lpSurface);
}

LONG DVAEscape(HDC hdc, UINT function, UINT size, LPVOID lp_in_data, LPVOID lp_out_data)
{
    DCICMD FAR *pcmd;

    static DVASURFACEINFO dva;
    static DCISURFACEINFO dci;

    switch (function)
    {
	case QUERYESCSUPPORT:

            switch (*((UINT FAR *)lp_in_data))
            {
                case QUERYESCSUPPORT:
                    return TRUE;

                case DCICOMMAND:
                    return TRUE;

                default:
                    return FALSE;
            }

        case DCICOMMAND:
            pcmd = (DCICMD FAR *)lp_in_data;

            switch (pcmd->dwCommand)
            {
                case DCICREATEPRIMARYSURFACE:

                    if (!DVAGetSurface(hdc, 0, &dva))
                        return DCI_FAIL_UNSUPPORTED;

                    dci.dwSize          = sizeof(dci);
                    dci.dwDCICaps       = DCI_PRIMARY | DCI_VISIBLE | DCI_1632_ACCESS;
                    dci.dwCompression   = dva.BitmapInfo.biCompression;
                    dci.dwMask[0]       = dva.dwMask[0];
                    dci.dwMask[1]       = dva.dwMask[1];
                    dci.dwMask[2]       = dva.dwMask[2];
                    dci.dwWidth         = dva.BitmapInfo.biWidth;
                    dci.dwHeight        = abs(dva.BitmapInfo.biHeight);
                    dci.dwBitCount      = dva.BitmapInfo.biBitCount;
                    dci.lStride         = dci.dwWidth * dci.dwBitCount / 8;
                    dci.dwOffSurface    = dva.offSurface;
                    dci.wSelSurface     = dva.selSurface;
                    dci.wReserved       = 0;
                    dci.dwReserved1     = (DWORD)(LPVOID)&dva;
                    dci.dwReserved2     = 0;
                    dci.dwReserved3     = 0;
                    dci.BeginAccess     = dci_begin_access;
                    dci.EndAccess       = dci_end_access;
                    dci.DestroySurface  = dci_destroy;

                    *((DCISURFACEINFO FAR * FAR *)lp_out_data) = &dci;
                    return DCI_OK;

                default:
                    return DCI_FAIL_UNSUPPORTED;
            }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dciman.c ===
#include <windows.h>

#undef WINAPI
#define WINAPI FAR PASCAL _loadds

#include "dciman.h"

static char szSystemIni[] = "system.ini";
static char szWinIni[] = "win.ini";
static char szDrivers[]   = "Drivers";
static char szDrawDib[]	  = "DrawDib";
static char szDCI[]       = "dci";
static char szDVA[]       = "dva";
static char szDISPLAY[]   = "display";
static char szDCISVGA[]   = "dcisvga";
static char szDCIDVA[]   = "dcidva";

static BOOL fDVA;
extern LONG DVAEscape(HDC hdc, UINT function, UINT size, LPVOID lp_in_data, LPVOID lp_out_data);

/****************************************************************************
 ***************************************************************************/

#define USE_DCI_EQUALS	0x01
#define USE_DRIVER	0x02
#define USE_DCISVGA	0x04

HDC WINAPI DCIOpenProvider(void)
{
    char 	ach[128];
    HDC 	hdc;
    UINT	u;
    int		dva;
    int		dcidva;
    BOOL	try_dcisvga = 0;
    BOOL	try_display = 0;
    BOOL	try_driver = 0;

    //
    // get dcidva variable.
    // 1 = use DCI= line
    // 2 = use display drivetr
    // 4 = use DCISVGA
    //
    dcidva = USE_DCI_EQUALS | USE_DRIVER | USE_DCISVGA;
    dcidva = GetPrivateProfileInt( szDrawDib, szDCIDVA, dcidva, szWinIni );
    if( dcidva == 0 ) {
	return NULL;
    }

    /*
     *	get the DCI provider, order of attempts
     *	1) try DCI=
     *	2) try display driver
     *	3) try DCISVGA
     */
    if( dcidva & USE_DCI_EQUALS ) {
	GetPrivateProfileString(szDrivers, szDCI, "", ach, sizeof(ach), szSystemIni);
    } else if( dcidva & USE_DRIVER ) {
	try_driver = 1;
	lstrcpy( ach,szDISPLAY );
    } else {
	try_dcisvga = 1;
	lstrcpy( ach,szDCISVGA );
    }

again:
    u = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hdc = CreateDC(ach, NULL, NULL, NULL);
    SetErrorMode(u);

    if (hdc == NULL)
    {
fail:
	if( try_dcisvga ) {
	    goto LastResort;
	}
	if( !try_driver ) {
	    if( dcidva & USE_DRIVER ) {
		try_driver = 1;
		lstrcpy(ach, szDISPLAY);
	    } else if( dcidva & USE_DCISVGA ) {
		try_dcisvga = 1;
		lstrcpy(ach, szDCISVGA);
	    } else {
		goto LastResort;
	    }
	} else { 
	    if( dcidva & USE_DCISVGA ) {
		try_dcisvga = 1;
		lstrcpy(ach, szDCISVGA);
	    } else {
		goto LastResort;
	    }
	}
	goto again;
    }

    //
    //  now check for the Escape.  If not, continue looping
    //
    u = DCICOMMAND;
    if (Escape(hdc, QUERYESCSUPPORT,sizeof(u),(LPCSTR)&u,NULL) == 0)
    {
        DeleteDC(hdc);
        goto fail;
    }

    return hdc;

LastResort:
    //
    // driver does not do escape, punt it, try old DVA first though
    //
    if (DVAEscape(hdc,QUERYESCSUPPORT,sizeof(u),(LPVOID)&u,NULL) != 0)
    {
	fDVA = TRUE;
	return hdc;
    }

    return NULL;
}

/****************************************************************************
 ***************************************************************************/

void WINAPI DCICloseProvider(HDC hdc)
{
    if (hdc)
        DeleteDC(hdc);
}

/****************************************************************************
 ***************************************************************************/

int WINAPI DCISendCommand(HDC hdc, DCICMD FAR *pcmd, VOID FAR * FAR * lplpOut)
{
    if (lplpOut)            // in case it fails, make sure this is NULL
        *lplpOut = NULL;

    if (fDVA)
        return DVAEscape(hdc, DCICOMMAND, sizeof(DCICMD),(LPVOID)pcmd, lplpOut);
    else
        return Escape(hdc, DCICOMMAND, sizeof(DCICMD),(LPCSTR)pcmd, lplpOut);
}

/****************************************************************************
 ***************************************************************************/

extern int WINAPI DCICreatePrimary(HDC hdc, DCISURFACEINFO FAR * FAR *lplpSurface)
{
    DCICMD  cmd;

    cmd.dwCommand   = DCICREATEPRIMARYSURFACE;
    cmd.dwParam1    = 0;
    cmd.dwParam2    = 0;
    cmd.dwVersion   = DCI_VERSION;
    cmd.dwReserved  = 0;

    return DCISendCommand(hdc, &cmd, lplpSurface);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dibeng.inc ===
;/*
;----------------------------------------------------------------------------
; DIBENG.INC
; Copyright (c) 1992 Microsoft Corporation
;
; Dib Engine Interface Definitions
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; General Comments:
; The DIB Engine is non-palettized from GDI's perspective.  When an app
; selects a DIB into a memory DC, GDI will create a DIB Engine PDevice 
; (see definition below) and will stuff in a 'DI' in the deType field.
; Subsequent operations on this DC will result in calls to the DIB Engine
; with this PDevice.  
; Device drivers can also use the DIB Engine to handle most, if not all,
; of their rendering work.  A device driver exports the DIB Engine PDevice
; as it's own PDevice to GDI.  This PDevice contains a pointer to a 
; BitmapInfo header in the driver's data segment. Immediately following
; this is an optional color table for devices less than 16 bpp.
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
; E Q U A T E S
;----------------------------------------------------------------------------
BRUSHSIZE	equ	8		;height and width in pixels.
VER_DIBENG      equ     400h            ;version = 4.0
comment ~
*/
#define BRUSHSIZE       8
#define VER_DIBENG      0x400
/*
end comment ~
;----------------------------------------------------------------------------
; S T R U C T U R E S
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PDevice Structure for the DIB Engine.  deType will contain 'DI' when GDI
; calls the DIB Engine to perform graphics operations on the dib.  deType 
; will contain a 0 or a Selector if a mini-driver is calling the DIB Engine 
; to do graphics operations. 
;----------------------------------------------------------------------------
DIBENGINE	    struc						      ;*/ typedef struct {                        /*
  deType	    dw	?		; contains 'DI', 0 or ScreenSelector  ;*/ WORD         deType;                    /*
  deWidth	    dw	?		; Width of dib in pixels	      ;*/ WORD         deWidth;                   /*
  deHeight	    dw	?		; Height of dib in pixels	      ;*/ WORD         deHeight;                  /*
  deWidthBytes	    dw	?		; #bytes per scan line		      ;*/ WORD         deWidthBytes;              /*
  dePlanes	    db	?		; # of planes in bitmap 	      ;*/ BYTE         dePlanes;                  /*
  deBitsPixel	    db	?		; # of bits per pixel		      ;*/ BYTE         deBitsPixel;               /*
  deReserved1	    dd	?		; cannot be used.		      ;*/ DWORD        deReserved1;               /*
  deDeltaScan       dd  ?               ; + or -. Displacement to next scan.  ;*/ DWORD        deDeltaScan;               /*
  delpPDevice	    dd	?		; Pointer to associated PDevice       ;*/ LPBYTE       delpPDevice;               /*
  deBits	    df	?		; fword offset to bits of dib	      ;*/ DWORD        deBitsOffset;              /*
                                        ;                                     ;*/ WORD         deBitsSelector;            /*
  deFlags	    dw	?		; additional flags		      ;*/ WORD         deFlags;                   /*
  deVersion	    dw  ?		; lsb=minor, msb=major (0400h = 4.0)  ;*/ WORD         deVersion;                 /*
  deBitmapInfo	    dd	?		; pointer to the bitmapinfo header    ;*/ LPBITMAPINFO deBitmapInfo;              /*
  deCursorExclude   dd	?		; Cursor Exclude call back	      ;*/ void         (FAR *deCursorExclude)();  /*
  deCursorUnexclude dd	?		; Cursor Unexclude call back	      ;*/ void         (FAR *deCursorUnexclude)();/*
  deReserved2	    dd  ?		; Reserved.                           ;*/ DWORD        deReserved2;               /*
DIBENGINE	    ends		                                      ;*/ } DIBENGINE, FAR *LPDIBENGINE;          /*
;----------------------------------------------------------------------------
; Definitions for DIBEngine.deFlags
;----------------------------------------------------------------------------
MINIDRIVER   	equ     0000000000000001b
PALETTIZED   	equ     0000000000000010b				      
SELECTEDDIB  	equ     0000000000000100b				      
CURSOREXCLUDE	equ     0000000000001000b                                      
DISABLED        equ     0000000000010000b
VRAM		equ     1000000000000000b                                      
BANKEDVRAM	equ     0100000000000000b                                      
BANKEDSCAN	equ     0010000000000000b                                      
comment ~
*/
#define MINIDRIVER      0x0001	  
#define PALETTIZED      0x0002	  
#define SELECTEDDIB     0x0004	  
#define CURSOREXCLUDE   0x0008	  
#define DISABLED        0x0010	  
#define VRAM            0x8000	  
#define BANKEDVRAM      0x4000	  
#define BANKEDSCAN      0x2000
/*
end comment ~
;----------------------------------------------------------------------------
; Definitions for most significant byte of a physical color.
;----------------------------------------------------------------------------
MONO_BIT	equ	00000001b	;0=Black, 1=White                     
PHYS_BIT	equ	10000000b	;1=physical color, 0=logical color    
GREY_BIT        equ     01000000b       ;color is grey (r=g=b)
comment ~
*/
#define MONO_BIT        0x01	  
#define PHYS_BIT        0x80	  
#define GREY_BIT        0x40	  
/*
end comment ~
;----------------------------------------------------------------------------
; DIB Engine Color Table entry structure. This structure is used by device
; drivers that are using DIB Engine services for rendering.  This structure
; is identical to the RGBQuad structure except for some bit definitions
; in the 4th byte.
;----------------------------------------------------------------------------
DIBColorEntry	struc							      ;*/ typedef struct {		  /*
  dceBlue	    db	?                                                     ;*/ BYTE dceBlue;	                  /*
  dceGreen	    db	?                                                     ;*/ BYTE dceGreen;                  /*
  dceRed	    db	?                                                     ;*/ BYTE dceRed;	                  /*
  dceFlags          db  ?                                                     ;*/ BYTE dceFlags;                  /*
DIBColorEntry	ends                                                          ;*/ } DIBColorEntry;                /*
;----------------------------------------------------------------------------
; Definitions for DIBColorEntry.dceFlags
;----------------------------------------------------------------------------
NONSTATIC	equ	10000000b      ;Inhibits color matching to this entry.
MAPTOWHITE	equ	00000001b      ;0=Black, 1=White
comment ~
*/
#define NONSTATIC       0x80	  
#define MAPTOWHITE      0x01	  
/*
end comment ~
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; DIB Engine Physical Object Definitions
;----------------------------------------------------------------------------

DIB_Pen	struc                                                                 ;*/ typedef struct {                /*  
dpPenStyle	dw	?                                                     ;*/ WORD  dpPenStyle;               /*  
dpPenFlags	db	?		;currently none undefined.            ;*/ BYTE  dpPenFlags;               /*
dpPenBpp	db	?	                                              ;*/ BYTE  dpPenBpp;                 /*
dpPenMono	dd	?                                                     ;*/ DWORD dpPenMono;                /*
dpPenColor	dd	?                                                     ;*/ DWORD dpPenColor;               /*
DIB_Pen	ends                                                                  ;*/ } DIB_Pen;                      /*

DIB_Brush1	struc                                                         ;*/ typedef struct {                /*  
dp1BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp1BrushFlags;            /*
dp1BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp1BrushBpp;              /*
dp1BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp1BrushStyle;            /*
dp1FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp1FgColor;               /*
dp1Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp1Hatch;                 /*
dp1BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp1BgColor;               /*
dp1BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp1BrushMono [BRUSHSIZE*4];/*
dp1BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp1BrushMask [BRUSHSIZE*4];/*
dp1BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 1 bit/pixel ;*/ BYTE dp1BrushBits [BRUSHSIZE*4];/* 
DIB_Brush1	ends                                                          ;*/ } DIB_Brush1;                   /*  

DIB_Brush4	struc                                                         ;*/ typedef struct {                /*  
dp4BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp4BrushFlags;            /*
dp4BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp4BrushBpp;              /*
dp4BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp4BrushStyle;            /*
dp4FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp4FgColor;               /*
dp4Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp4Hatch;                 /*
dp4BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp4BgColor;               /*
dp4BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp4BrushMono [BRUSHSIZE*4];/*
dp4BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp4BrushMask [BRUSHSIZE*4];/*
dp4BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 4 bit/pixel ;*/ BYTE dp4BrushBits [BRUSHSIZE*4];/* 
DIB_Brush4	ends                                                          ;*/ } DIB_Brush4;                   /*  

DIB_Brush8	struc                                                         ;*/ typedef struct {                /*  
dp8BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp8BrushFlags;            /*
dp8BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp8BrushBpp;              /*
dp8BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp8BrushStyle;            /*
dp8FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp8FgColor;               /*
dp8Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp8Hatch;                 /*
dp8BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp8BgColor;               /*
dp8BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp8BrushMono [BRUSHSIZE*4];/*
dp8BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp8BrushMask [BRUSHSIZE*4];/*
dp8BrushBits	db	BRUSHSIZE*8 dup (?) ;8 rows,8 columns of 8 bit/pixel  ;*/ BYTE dp8BrushBits [BRUSHSIZE*8];/* 
DIB_Brush8	ends                                                          ;*/ } DIB_Brush8;                   /*  

DIB_Brush16	struc                                                         ;*/ typedef struct {                /*  
dp16BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp16BrushFlags;            /*
dp16BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp16BrushBpp;              /*
dp16BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp16BrushStyle;            /*
dp16FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp16FgColor;               /*
dp16Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp16Hatch;                 /*
dp16BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp16BgColor;               /*
dp16BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp16BrushMono [BRUSHSIZE*4];/*
dp16BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp16BrushMask [BRUSHSIZE*4];/*
dp16BrushBits	db	BRUSHSIZE*16 dup (?);8 rows,8 columns of 16 bit/pixel;*/ BYTE dp16BrushBits [BRUSHSIZE*16];/* 
DIB_Brush16	ends                                                          ;*/ } DIB_Brush16;                   /*  

DIB_Brush24	struc                                                         ;*/ typedef struct {                /*  
dp24BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp24BrushFlags;            /*
dp24BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp24BrushBpp;              /*
dp24BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp24BrushStyle;            /*
dp24FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp24FgColor;               /*
dp24Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp24Hatch;                 /*
dp24BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp24BgColor;               /*
dp24BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp24BrushMono [BRUSHSIZE*4];/*
dp24BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp24BrushMask [BRUSHSIZE*4];/*
dp24BrushBits	db	BRUSHSIZE*24 dup (?);8 rows,8 columns of 24 bit/pixel ;*/ BYTE dp24BrushBits [BRUSHSIZE*24];/* 
DIB_Brush24	ends                                                          ;*/ } DIB_Brush24;                   /*  

DIB_Brush32	struc                                                         ;*/ typedef struct {                /*  
dp32BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp32BrushFlags;            /*
dp32BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp32BrushBpp;              /*
dp32BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp32BrushStyle;            /*
dp32FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp32FgColor;               /*
dp32Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp32Hatch;                 /*
dp32BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp32BgColor;               /*
dp32BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp32BrushMono [BRUSHSIZE*4];/*
dp32BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp32BrushMask [BRUSHSIZE*4];/*
dp32BrushBits	db	BRUSHSIZE*32 dup (?);8 rows,8 columns of 32 bit/pixel ;*/ BYTE dp32BrushBits [BRUSHSIZE*32];/* 
DIB_Brush32	ends                                                          ;*/ } DIB_Brush32;                   /*  

;----------------------------------------------------------------------------
; Definitions for DIB_Brushxx.dpxxBrushFlags
;----------------------------------------------------------------------------                                      
COLORSOLID     equ      00000001b ;Color part is solid.                        
MONOSOLID      equ      00000010b ;Mono part is solid.                         
PATTERNMONO    equ      00000100b ;Pattern brush came from a mono bitmap.      
MONOVALID      equ      00001000b ;Mono part is valid.                         
MASKVALID      equ      00010000b ;Transparency Mask part is valid.
comment ~
*/
#define  COLORSOLID     0x01         
#define  MONOSOLID      0x02         
#define  PATTERNMONO    0x04         
#define  MONOVALID      0x08         
#define  MASKVALID      0x10
/*
end comment ~
;----------------------------------------------------------------------------
; M A C R O S
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; Cycle24 i
;
; This macro cycle a replicated 24 bit color in register eax, 'i' times.
; If 'i' is blank, the cycle is done one time, else it is done twice
;----------------------------------------------------------------------------
Cycle24 macro i

ifb <i>                                 ;assume eax = 'brgb'
        mov     al,ah                   ;eax = 'brgg'
        ror     eax,8                   ;eax = 'gbrg'
else
        rol     eax,16                  ;eax = 'gbbr'
        mov     ah,al                   ;eax = 'gbrr'
        ror     eax,8                   ;eax = 'rgbr'
endif
        endm
;----------------------------------------------------------------------------
; ColorToMono
; Entry: red, green, blue
; Exit:  blue = intensity.
;----------------------------------------------------------------------------
ColorToMono	macro	red, green, blue
	add	blue,red		;R+B
        rcr     blue,1                  ;(R+B)/2
	add	blue,green		;pitch in Green
        rcr     blue,1                  ;G/2 + (R+B)/4
endm	ColorToMono

;----------------------------------------------------------------------------
; ColorToMonoBit
; Entry: red, green, blue
; Exit:  blue = 0 if color maps to black
;        blue = 1 if color maps to white
;----------------------------------------------------------------------------
ColorToMonoBit	macro	red, green, blue
	ColorToMono red,green,blue    ; Call ColorToMono to derive intensity.
	cmp	blue,127
	setnc	blue
endm ColorToMonoBit

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dciman.h ===
/****************************************************************************

 DCIMAN.H

 Copyright (c) 1993 Microsoft Corporation

 DCIMAN 1.0 client interface definitions

 ***************************************************************************/

#ifndef _INC_DCIMAN
#define _INC_DCIMAN

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dciddi.h"     // interface to the DCI provider

/****************************************************************************
 ***************************************************************************/

/****************************************************************************
 ***************************************************************************/

extern HDC  WINAPI DCIOpenProvider(void);
extern void WINAPI DCICloseProvider(HDC hdc);

extern int WINAPI DCISendCommand(HDC hdc, DCICMD FAR *pcmd, VOID FAR * FAR * lplpOut);

extern int WINAPI DCICreatePrimary(HDC hdc, DCISURFACEINFO FAR * FAR *lplpSurface);
extern int WINAPI DCICreateOffscreen(HDC hdc, int width, int height, int bits, DCISURFACEINFO FAR * FAR *lplpSurface);

/****************************************************************************
 ***************************************************************************/

__inline void DCIDestroy(DCISURFACEINFO FAR *pdci)
{
    pdci->DestroySurface(pdci);
}

__inline void DCIEndAccess(DCISURFACEINFO FAR *pdci)
{
    pdci->EndAccess(pdci);
}

__inline int DCIBeginAccess(DCISURFACEINFO FAR *pdci, int x, int y, int dx, int dy)
{
    RECT rc;

    rc.left=x;
    rc.top=y;
    rc.right = rc.left+dx;
    rc.bottom = rc.top+dy;
    return pdci->BeginAccess(pdci, &rc);
}

/****************************************************************************
 ***************************************************************************/

#ifdef __cplusplus
    }
#endif

#endif // _INC_DCIMAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dvaclip.c ===
#define TestWF(hwnd, f) (GetWindowLong(hwnd, GWL_STYLE) & (f))
#define TestWX(hwnd, f) (GetWindowLong(hwnd, GWL_EX_STYLE) & (f))

BOOL DVAIsClipped(HDC hdc, RECT& rc)
{
    RECT rcClip;

    if (GetClipBox(hdc, &rcClip) != SIMPLEREGION)
        return TRUE;

    if (rc.left   < rcClip.left  ||
        rc.top    < rcClip.top   ||
        rc.right  > rcClip.right ||
        rc.bottom > rcClip.bottom)

        return TRUE;

    return FALSE;
}

int DVAGetClipList(HWND hwnd, LPRECT prc, LPRECT RectList, int RectCount)
{
    RECT rc;
    HWND hwndP;
    HWND hwndT;

    if (RectCount == 0 || !IsVisible(hwnd))
        return 0;

    //
    // get the client area of the window
    //
    GetClientRect(hwnd, RectList);

    if (prc)
        IntersectRect(RectList, RectList, prc);

    ClientToScreen(hwnd, (LPPOINT)RectList);
    ClientToScreen(hwnd, (LPPOINT)RectList + 1);

    RectCount = 1;
    RectList[1] = RectList[0];

    //
    // walk all children of hwnd and remove them if needed
    //
    if (TestWF(hwnd, WS_CLIPCHILDREN))
    {
        RectCount = ExcludeWindowRects(RectList, RectCount,
            GetWindow(hwnd, GW_CHILD), NULL);

        if (RectCount == 0)
            return 0;
    }

    //
    // walk all the siblings of hwnd and exclude them from the list.
    //
    for (; (hwndP = GetWindow(hwnd, GW_PARENT)) != NULL; hwnd = hwndP)
    {
        GetWindowRect(hwndP, &rc);
        RectCount = IntersectRectList(RectList, RectCount, &rc;

        if (RectCount == 0)
            return 0;

        if (TestWF(hwnd, WS_CLIPSIBLINGS))
        {
            RectCount = ExcludeWindowRects(RectList, RectCount,
                GetWindow(hwndP, GW_CHILD), hwnd);

            if (RectCount == 0)
                return 0;
        }
    }

    return RectCount;
}

int ExcludeWindowRects(LPRECT RectList, int RectCount, HWND hwndA, HWND hwndB)
{
    RECT rc;

    for (hwnd = hwndA; hwnd != NULL && hwnd != hwndB; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        if (!IsWindowVisible(hwnd))
	    continue;

        //
	// Don't subtract off transparent windows...
	//
        if (TestWX(hwnd, WS_EX_TRANSPARENT))
            continue;

        GetWindowRect(hwnd, &rc);

        RectCount = ExcludeRectList(RectList, RectCount, &rc);

        if (RectCount == 0)
            return 0;
    }

    return RectCount;
}


int ExcludeRectList(LPRECT RectList, int RectCount, LPRECT prc)
{
    int i;
    int n;
    RECT rc;

    if (RectCount == 0)
        return 0;

    SubtractRect(RectList, prc);

    for (i=1; i <= RectCount; i++)
    {
        if (!IntersectRect(&rc, &RectList[i], prc))
            continue;

        //
        //
        //

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dvavga.c ===
/****************************************************************************

    DVA surface provider for SVGA card, using dva.386

 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "lockbm.h"

extern UINT PASCAL __A000h;
#define A000h   (WORD)(&__A000h)

// stuff in VFlat.asm
//
extern LPVOID NEAR PASCAL VFlatInit(void);
extern void   NEAR PASCAL VFlatBegin(void);
extern void   NEAR PASCAL VFlatEnd(void);

#define GETAPI(mod, api) GetProcAddress(GetModuleHandle(mod),MAKEINTATOM(api))

static HCURSOR hcur;
static FARPROC CheckCursor;
       HDC     hdcScreen;
static int     open_count;

static BOOL (FAR PASCAL *XIsWinoldAppTask)(HTASK hTask);

#define IsWinoldAppTask XIsWinoldAppTask

/****************************************************************************
 ***************************************************************************/

BOOL FAR PASCAL _loadds vga_open_surface(LPVOID pv)
{
    if (open_count++ == 0)
    {
        (FARPROC)CheckCursor = GETAPI("DISPLAY", MAKEINTATOM(104));
        (FARPROC)XIsWinoldAppTask = GETAPI("KERNEL", MAKEINTATOM(158));

        hdcScreen = CreateDC("DISPLAY", NULL, NULL, NULL);
    }

    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL _loadds vga_close_surface(LPVOID pv)
{
    if (open_count && --open_count == 0)
    {
        DeleteDC(hdcScreen);
        hdcScreen = NULL;
    }
}

/****************************************************************************
 ***************************************************************************/

BOOL FAR PASCAL _loadds vga_begin_access(LPVOID pv, int x, int y, int dx, int dy)
{
    RECT rc;
    POINT pt;
    HWND  hwndA;

    //
    //  if windows is in the background dont draw to the screen.
    //
    hwndA = GetActiveWindow();
    if (IsWinoldAppTask(GetWindowTask(hwndA)) && IsIconic(hwndA))
        return FALSE;

    //
    //  on some SVGAs with 8514 like accelerators, a command Que may need to
    //  be flushed before touching video memory.
    //
    if (hdcScreen)
        GetPixel(hdcScreen, x, y);

//!!! we realy should hook the mouse callback.

    GetCursorPos(&pt);

    #define CUR 40

    if ((pt.x >= x-CUR && pt.x <= x+dx+CUR) &&
        (pt.y >= y-CUR && pt.y <= y+dy+CUR))
    {
        hcur = SetCursor(NULL);
    }
    else
    {
        hcur = NULL;

        rc.left = pt.x;
        rc.top = pt.y;
        rc.right = pt.x+1;
        rc.bottom = pt.y+1;

        ClipCursor(&rc);
    }

    if (CheckCursor)
        CheckCursor();

    VFlatBegin();
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL _loadds vga_end_access(LPVOID pv)
{
    VFlatEnd();

    if (hcur)
        SetCursor(hcur);
    else
        ClipCursor(NULL);
}

/****************************************************************************
 ***************************************************************************/

BOOL vga_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    LPBITMAPINFOHEADER lpbi;
    int BitDepth;
    LPVOID lpScreen=NULL;
    IBITMAP FAR *pbm;

    if (nSurface != 0)
        return FALSE;

    BitDepth = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);

    if (BitDepth < 8)       // forget VGA or mono.
        return FALSE;

    pbm = GetPDevice(hdc);

    if (pbm == NULL || pbm->bmType == 0)
        return FALSE;

    if (HIWORD(pbm->bmBits) != A000h)
        return FALSE;

    lpScreen = VFlatInit();

    if (lpScreen == NULL)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    lpbi->biSize           = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth          = pbm->bmWidthBytes*8/pbm->bmBitsPixel;
    lpbi->biHeight         = -(int)pbm->bmHeight;
    lpbi->biPlanes         = pbm->bmPlanes;
    lpbi->biBitCount       = pbm->bmBitsPixel;
    lpbi->biCompression    = 0;
    lpbi->biSizeImage      = (DWORD)pbm->bmWidthBytes * (DWORD)pbm->bmHeight;
    lpbi->biXPelsPerMeter  = pbm->bmWidthBytes;
    lpbi->biYPelsPerMeter  = 0;
    lpbi->biClrUsed        = 0;
    lpbi->biClrImportant   = 0;

    pdva->selSurface   = SELECTOROF(lpScreen);
    pdva->offSurface   = OFFSETOF(lpScreen);
    pdva->Version      = 0x0100;
    pdva->Flags        = DVAF_1632_ACCESS;
    pdva->lpSurface    = (LPVOID)(DWORD)pbm->bmHeight;
    (FARPROC)pdva->OpenSurface  = (FARPROC)vga_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vga_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)vga_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)vga_end_access;
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dvaddi.h ===
//
// DVADDDI.H
//
// Copyright (c) 1993 Microsoft Corporation
//
// DVA 1.0 Interface Definitions
//

#define DVAGETSURFACE       3074    // GDI Escape for DVA
#define DVA_VERSION         0x0100  // version number of DVA 1.0

//
// DVASURFACEINFO structure
//
typedef struct {                                               //
    BITMAPINFOHEADER BitmapInfo;                               // BITMAPINFO of surface
    DWORD            dwMask[3];                                // masks for BI_BITFIELDS
    DWORD            offSurface;                               // surface offset
    WORD             selSurface;                               // surface selector
    WORD             Version;                                  // DVA Version
    DWORD            Flags;                                    // Flags
    LPVOID           lpSurface;                                // driver use.
    BOOL (CALLBACK *OpenSurface) (LPVOID);                     // OpenSurface callback
    void (CALLBACK *CloseSurface)(LPVOID);                     // CloseSurface callback
    BOOL (CALLBACK *BeginAccess) (LPVOID,int,int,int,int);     // BeginAccess callback
    void (CALLBACK *EndAccess)   (LPVOID);                     // EndAccess callback
    UINT (CALLBACK *ShowSurface) (LPVOID,HWND,LPRECT,LPRECT);  // ShowSurface callback
} DVASURFACEINFO, FAR *LPDVASURFACEINFO;                       //

//
// Definitions for DVASURFACEINFO.dvaFlags
//
#define DVAF_1632_ACCESS    0x0001  // must access using 16:32 pointers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dva.h ===
/****************************************************************************

 DVA.H

 Copyright (c) 1993 Microsoft Corporation

 DVA 1.0 Interface Definitions

 ***************************************************************************/

#ifndef _INC_DVA
#define _INC_DVA

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dvaddi.h"     // interface to the display driver

/****************************************************************************
 ***************************************************************************/

typedef DVASURFACEINFO FAR *PDVA;
typedef PDVA HDVA;

/****************************************************************************
 ***************************************************************************/

//
// this code in biCompression means the frame buffer must be accesed via
// 48 bit pointers! using *ONLY* the given selector
//
// BI_1632 has bitmasks (just like BI_BITFIELDS) for biBitCount == 16,24,32
//
#ifndef BI_1632
#define BI_1632  0x32333631     // '1632'
#endif

#ifndef BI_BITFIELDS
#define BI_BITFIELDS 3
#endif

/****************************************************************************
 ***************************************************************************/

extern BOOL WINAPI DVAGetSurface(HDC hdc, int nSurface, DVASURFACEINFO FAR *lpSurfaceInfo);

/****************************************************************************
 ***************************************************************************/

__inline PDVA DVAOpenSurface(HDC hdc, int nSurface)
{
    PDVA pdva;

    pdva = (PDVA)GlobalLock(GlobalAlloc(GHND|GMEM_SHARE, sizeof(DVASURFACEINFO)));

    if (pdva == NULL)
        return NULL;

    if (!DVAGetSurface(hdc, nSurface, pdva) ||
        !pdva->OpenSurface(pdva->lpSurface))
    {
        GlobalFree((HGLOBAL)SELECTOROF(pdva));
        return NULL;
    }

    return pdva;
}

/****************************************************************************
 ***************************************************************************/

__inline void DVACloseSurface(PDVA pdva)
{
    if (pdva == NULL)
        return;

    pdva->CloseSurface(pdva->lpSurface);

    GlobalFree((HGLOBAL)SELECTOROF(pdva));
}

/****************************************************************************
 ***************************************************************************/

__inline BOOL DVABeginAccess(PDVA pdva, int x, int y, int dx, int dy)
{
    return pdva->BeginAccess(pdva->lpSurface, x, y, dx, dy);
}

/****************************************************************************
 ***************************************************************************/

__inline void DVAEndAccess(PDVA pdva)
{
    pdva->EndAccess(pdva->lpSurface);
}

/****************************************************************************
 ***************************************************************************/

__inline LPBITMAPINFOHEADER DVAGetSurfaceFmt(PDVA pdva)
{
    if (pdva == NULL)
        return NULL;

    return &pdva->BitmapInfo;
}

/****************************************************************************
 ***************************************************************************/

__inline LPVOID DVAGetSurfacePtr(PDVA pdva)
{
    if (pdva == NULL)
        return NULL;

    return (LPVOID)MAKELONG(pdva->offSurface, pdva->selSurface);
}

#ifdef __cplusplus
    }
#endif

#endif // _INC_DVA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dvadib.c ===
/****************************************************************************

    DVA surface provider for Chicago DIBENG

 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "dibeng.inc"
#include "lockbm.h"

#define RP_TYPE     0x5250  // 'RP'

// stuff in DVAVGA.C
extern HDC  hdcScreen;
extern BOOL FAR PASCAL _loadds vga_open_surface(LPVOID pv);
extern void FAR PASCAL _loadds vga_close_surface(LPVOID pv);

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK dib_open_surface(LPVOID pv)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK dib_close_surface(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK dib_begin_access(LPVOID pv, int x, int y, int AccessDX, int AccessDY)
{
    //
    //  on some SVGAs with 8514 like accelerators, a command Que may need to
    //  be flushed before touching video memory.
    //
    //  mini drivers should not need this "handholding" but the S3 driver
    //  does
    //
//  if (hdcScreen)
//      GetPixel(hdcScreen, x, y);

    _asm {
        push    ds
;       push    si
;       push    di

	lds	bx,pv

	xor	ax,ax
        test    [bx].deFlags,DISABLED
	jnz	exit

        mov     cx,x
        mov     dx,y
        mov     si,cx
        add     si,AccessDX
        mov     di,y
        add     di,AccessDY
	call	dword ptr [bx].deCursorExclude
	mov	ax,1
exit:
;       pop     di
;       pop     si
        pop     ds
    }
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL dib_end_access(LPVOID pv)
{
    _asm {
	push	ds
	lds	bx,pv
	call	dword ptr [bx].deCursorUnexclude
	pop	ds
    }
}

/****************************************************************************
 ***************************************************************************/

BOOL dib_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    DIBENGINE FAR *pde;
    LPBITMAPINFOHEADER lpbi;

    if (nSurface != 0)
        return FALSE;

    pde = (DIBENGINE FAR *)GetPDevice(hdc);

    if (pde == NULL ||
        pde->deType != RP_TYPE ||
        pde->dePlanes != 1 ||
        pde->deBitsSelector == NULL ||
        pde->deBitmapInfo == NULL ||
        pde->deVersion != 0x0400)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    hmemcpy(lpbi, pde->deBitmapInfo, sizeof(BITMAPINFOHEADER));

    if (lpbi->biCompression != 0 &&
        lpbi->biCompression != BI_BITFIELDS)
	return FALSE;

    pdva->selSurface   = pde->deBitsSelector;
    pdva->offSurface   = pde->deBitsOffset;
    pdva->Flags        = 0;
    pdva->Version      = 0x0100;
    pdva->lpSurface    = (LPVOID)pde;
    (FARPROC)pdva->OpenSurface  = (FARPROC)vga_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vga_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)dib_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)dib_end_access;
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    if (!(pde->deFlags & CURSOREXCLUDE))
    {
        pdva->BeginAccess = NULL;
        pdva->EndAccess   = NULL;
    }

    if (pde->deDeltaScan > 0)
    {
        lpbi->biWidth  = (int)pde->deDeltaScan * 8 / (int)pde->deBitsPixel;
        lpbi->biHeight =-(int)pde->deHeight;
        lpbi->biSizeImage = pde->deDeltaScan * pde->deHeight;
    }
    else
    {
        lpbi->biWidth  = -(int)pde->deDeltaScan * 8 / (int)pde->deBitsPixel;
        lpbi->biHeight =  (int)pde->deHeight;
        lpbi->biSizeImage = -(int)pde->deDeltaScan * pde->deHeight;

	pdva->offSurface += (long)pde->deDeltaScan * (long)pde->deHeight-1;
    }

    //
    // mark the surface as 16:32 pointer access ONLY!
    //
    if (pde->deFlags & BANKEDVRAM)
	pdva->Flags |= DVAF_1632_ACCESS;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dvathun.c ===
/****************************************************************************
 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "lockbm.h"

extern BOOL FAR PASCAL _loadds vga_open_surface(LPVOID pv);
extern void FAR PASCAL _loadds vga_close_surface(LPVOID pv);
extern BOOL FAR PASCAL _loadds vga_begin_access(LPVOID pv, int x, int y, int dx, int dy);
extern void FAR PASCAL _loadds vga_end_access(LPVOID pv);

/****************************************************************************
 ***************************************************************************/

BOOL thun_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    DWORD SizeImage;
    IBITMAP FAR *pbm;
    UINT sel;
    DWORD off;
    LPBITMAPINFOHEADER lpbi;

    if (nSurface != 0)
        return FALSE;

    pbm = GetPDevice(hdc);

    if (pbm == NULL || pbm->bmType == 0)
        return FALSE;

    if (pbm->bmType != 0xFFFF)
        return FALSE;

    sel = ((WORD FAR *)&pbm->bmBits)[1];
    off = ((WORD FAR *)&pbm->bmBits)[0];

    SizeImage = (DWORD)(UINT)pbm->bmWidthBytes * (DWORD)(UINT)pbm->bmHeight;

    if (GetSelectorLimit(sel) != 0x3FFFFF)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    lpbi->biSize            = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth           = pbm->bmWidthBytes/(pbm->bmBitsPixel/8);
    lpbi->biHeight          = -(int)pbm->bmHeight;
    lpbi->biPlanes          = pbm->bmPlanes;
    lpbi->biBitCount        = pbm->bmBitsPixel;
    lpbi->biCompression     = 0;
    lpbi->biSizeImage       = SizeImage;
    lpbi->biXPelsPerMeter   = pbm->bmWidthBytes;
    lpbi->biYPelsPerMeter   = 0;
    lpbi->biClrUsed         = 0;
    lpbi->biClrImportant    = 0;

    pdva->selSurface   = sel;
    pdva->offSurface   = off;
    pdva->Version      = 0x0100;
    pdva->Flags        = 0;
    pdva->lpSurface    = 0;
    (FARPROC)pdva->OpenSurface  = (FARPROC)vga_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vga_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)vga_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)vga_end_access;
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\lockbm.c ===
#include <windows.h>
#include <windowsx.h>
#include "lockbm.h"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#ifndef BI_BITFIELDS
    #define BI_BITFIELDS 3
#endif

#ifndef BI_BITMAP
    #define BI_BITMAP   0x4D544942      // 'BITM'
#endif

/////////////////////////////////////////////////////////////////////////////
//
//  SetPixel
//
//  some cards cant't seam to do SetPixel right it is amazing they work at all
//
/////////////////////////////////////////////////////////////////////////////

static void SetPixelX(HDC hdc, int x, int y, COLORREF rgb)
{
    RECT rc;

    rc.left = x;
    rc.top  = y;
    rc.right = x+1;
    rc.bottom = y+1;

    SetBkColor(hdc, rgb);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}

#define SetPixel SetPixelX

///////////////////////////////////////////////////////////////////////////////
//
//  GetSurfaceType
//
//  determine the physical format of a framebuffer by seting pixels and
//  reading them back to see what we got.
//
///////////////////////////////////////////////////////////////////////////////

#define BCODE _based(_segname("_CODE"))

static BYTE  BCODE bits8[]   = {0x00,0xF9,0xFA,0xFC,0xFF};
static WORD  BCODE bits555[] = {0x0000,0x7C00,0x03E0,0x001F,0x7FFF};
static WORD  BCODE bits5551[]= {0x8000,0xFC00,0x83E0,0x801F,0xFFFF};
static WORD  BCODE bits565[] = {0x0000,0xF800,0x07E0,0x001F,0xFFFF};
static BYTE  BCODE bitsBGR[] = {0x00,0x00,0x00, 0x00,0x00,0xFF, 0x00,0xFF,0x00, 0xFF,0x00,0x00, 0xFF,0xFF,0xFF};
static BYTE  BCODE bitsRGB[] = {0x00,0x00,0x00, 0xFF,0x00,0x00, 0x00,0xFF,0x00, 0x00,0x00,0xFF, 0xFF,0xFF,0xFF};
static DWORD BCODE bitsRGBX[]= {0x000000, 0x0000FF, 0x00FF00, 0xFF0000, 0xFFFFFF};
static DWORD BCODE bitsBGRX[]= {0x000000, 0xFF0000, 0x00FF00, 0x0000FF, 0xFFFFFF};

void FAR TestSurfaceType(HDC hdc, int x, int y)
{
    PatBlt(hdc, x, y, 5, 1, BLACKNESS);

    SetPixel(hdc, x+0, y, RGB(000,000,000));
    SetPixel(hdc, x+1, y, RGB(255,000,000));
    SetPixel(hdc, x+2, y, RGB(000,255,000));
    SetPixel(hdc, x+3, y, RGB(000,000,255));
    SetPixel(hdc, x+4, y, RGB(255,255,255));

    GetPixel(hdc, x, y);
}

UINT FAR GetSurfaceType(LPVOID lpBits)
{
    #define TESTFMT(a,n) \
        if (_fmemcmp(lpBits, (LPVOID)a, sizeof(a)) == 0) return n;

    TESTFMT(bits8,    BM_8BIT);
    TESTFMT(bits555,  BM_16555);
    TESTFMT(bits5551, BM_16555);
    TESTFMT(bits565,  BM_16565);
    TESTFMT(bitsRGB,  BM_24RGB);
    TESTFMT(bitsBGR,  BM_24BGR);
    TESTFMT(bitsRGBX, BM_32RGB);
    TESTFMT(bitsBGRX, BM_32BGR);

    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
//  returns the PDevice of the given physical or memory DC
//
//  return the bitmap type that the display driver uses
//
///////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetPDevice(HDC hdc)
{               
    HANDLE h;
    HBITMAP hbm;
    HBITMAP hbmT;
    HDC hdcT=NULL;
    IBITMAP FAR *pbm;
    LPVOID lpPDevice = NULL;

    // GDI.403
    static HANDLE (FAR PASCAL *Gdi403)(HBITMAP hbm, HANDLE h);

    if (Gdi403 == NULL)
        (FARPROC)Gdi403 = GetProcAddress(GetModuleHandle("GDI"),MAKEINTATOM(403));

    if (Gdi403 == NULL)
        return NULL;

    hbm = CreateBitmap(1,1,1,1,NULL);

    //
    //  first try the passed DC if it is a bitmap/DC
    //
    hbmT = SelectBitmap(hdc, hbm);

    if (hbmT != NULL)
    {
        //
        // it is a memory DC.
        //
        h = Gdi403(hbmT, 0);
    }
    else
    {
        //
        // it is a physical DC.
        //

        hdcT = CreateCompatibleDC(hdc);
        hbmT = SelectBitmap(hdcT, hbm);

        h = Gdi403(hbm, 0);
    }

    if (h == NULL)
        goto exit;

    pbm = (IBITMAP FAR *)GlobalLock(h);

    if (IsBadReadPtr(pbm, sizeof(IBITMAP)))
        goto exit;

    if (pbm)
        pbm = (IBITMAP FAR *)pbm->bmlpPDevice;
    else
        pbm = NULL;

    if (IsBadReadPtr(pbm, 2))
        goto exit;

    lpPDevice = (LPVOID)pbm;

exit:
    if (hdcT)
    {
        SelectObject(hdcT, hbmT);
        DeleteObject(hdcT);
    }
    else
    {
        SelectObject(hdc, hbmT);
    }

    DeleteObject(hbm);

    return lpPDevice;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\ddt\ddt.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\dvavlb.c ===
/****************************************************************************

    DVA surface provider for a Viper VLB card.

    assumes a linear frame buffer

    assumes a hardware cursor

 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "lockbm.h"

extern NEAR PASCAL DetectViper(void);

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK vlb_open_surface(LPVOID pv)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK vlb_close_surface(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK vlb_begin_access(LPVOID pv, int x, int y, int dx, int dy)
{
    //
    // VIPER has a HW cursor so we dont do anything
    // !!!we may need to check for the sysVM in background
    //
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK vlb_end_access(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL vlb_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    DWORD SizeImage;
    IBITMAP FAR *pbm;
    UINT sel;
    DWORD off;
    LPBITMAPINFOHEADER lpbi;

    if (nSurface != 0)
        return FALSE;

    pbm = GetPDevice(hdc);

    if (pbm == NULL || pbm->bmType == 0)
        return FALSE;

//  if (pbm->bmType != 0x2000)
//      return FALSE;

    if (!DetectViper())
        return FALSE;

    sel = ((WORD FAR *)&pbm->bmBits)[1];
    off = ((WORD FAR *)&pbm->bmBits)[0];

    SizeImage = (DWORD)(UINT)pbm->bmWidthBytes * (DWORD)(UINT)pbm->bmHeight;

    if (GetSelectorLimit(sel) != 0x1FFFFF)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    lpbi->biSize            = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth           = pbm->bmWidthBytes*8/pbm->bmBitsPixel;
    lpbi->biHeight          = -(int)pbm->bmHeight;
    lpbi->biPlanes          = pbm->bmPlanes;
    lpbi->biBitCount        = pbm->bmBitsPixel;
    lpbi->biCompression     = 0;
    lpbi->biSizeImage       = SizeImage;
    lpbi->biXPelsPerMeter   = pbm->bmWidthBytes;
    lpbi->biYPelsPerMeter   = 0;
    lpbi->biClrUsed         = 0;
    lpbi->biClrImportant    = 0;

    pdva->selSurface   = sel;
    pdva->offSurface   = off;
    pdva->Version      = 0x0100;
    pdva->Flags        = 0;
    pdva->lpSurface    = 0;
    (FARPROC)pdva->OpenSurface  = (FARPROC)vlb_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vlb_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)vlb_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)vlb_end_access;
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\vflat.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  VFLAT.ASM
;
;   module for doing direct video access under windows.
;
;   we will talk to VflatD to get the linear address of the video buffer.
;
;   we MUST not use these API in the background, how do we do this?
;
;   we support the following modes: (same as SVGA256...)
;
;        VRAM II 640x480x8bpp
;        VRAM II 720x512x8bpp
;        VRAM II 800x600x8bpp
;        VRAM II 1024x768x8bpp
;
;        V7 VGA 640x480x8bpp
;        V7 VGA 720x512x8bpp
;        V7 VGA 800x600x8bpp
;        V7 VGA 1024x768x8bpp
;
;        WD VGA 640x480x8bpp
;        WD VGA 800x600x8bpp
;        WD VGA 1024x768x8bpp
;        WD VGA 640x480x16bpp
;        WD VGA 800x600x16bpp
;
;        Trident 640x480x8bpp
;        Trident 800x600x8bpp
;        Trident 1024x768x8bpp
;
;        Oak 640x480x8bpp
;        Oak 800x600x8bpp
;        Oak 1024x768x8bpp
;
;        ATI 640x480x8bpp
;        ATI 800x600x8bpp
;        ATI 1024x768x8bpp
;        ATI 640x480x24bpp
;
;        Compaq AVGA 640x480x8bpp
;
;        Compaq QVision 640x480x8bpp
;        Compaq QVision 800x600x8bpp
;        Compaq QVision 1024x768x8bpp
;
;        Compaq QVision 640x480x16bpp
;        Compaq QVision 800x600x16bpp
;        Compaq QVision 1024x768x16bpp
;
;        Tseng ET4000 640x480x8bpp
;        Tseng ET4000 800x600x8bpp
;        Tseng ET4000 1024x768x8bpp
;        Tseng ET4000 640x480x16bpp
;        Tseng ET4000 800x600x16bpp
;
;        Everex 640x480x8bpp
;        Everex 800x600x8bpp
;        Everex 1024x768x8bpp
;
;        Cirrus 542x 640x480x8bpp
;        Cirrus 542x 800x600x8bpp
;        Cirrus 542x 1024x768x8bpp
;
;        Cirrus 6420 640x480x8bpp
;        Cirrus 6420 800x600x8bpp
;        Cirrus 6420 1024x768x8bpp
;
; Created:  03-20-90
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1994 Microsoft Corporation
;
; Public Functions:
;
;       VFlatInit()
;
; Public Data:
;
; General Description:
;
; Restrictions:
;
;-----------------------------------------------------------------------;

?PLM = 1
?WIN = 0
.386
	.xlist
	include cmacros.inc
        include windows.inc
        WIN31=1
        include VflatD.inc
        .list

        externFP        GetDC
        externFP        ReleaseDC
        externFP        GetDeviceCaps
        externFP        OutputDebugString
        externFP        WriteProfileString

        externA         __C000h
        externA         __A000h

sBegin  Data

        ScreenMode  dw      0                   ; current mode (index)
        VflatD_Proc dd      0                   ; VflatD entry point

        bank_save           dw      0           ; saved bank...

sEnd    Data

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ifdef DEBUG
DPF     macro   text
        local   string, string_end
        jmp short string_end
string label byte
        db      "&text&",13,10,0
string_end label byte
        pusha
        push    es
        push    cs
        push    offset string
        call    OutputDebugString
        pop     es
        popa
        endm
else
DPF     macro text
        endm
endif

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin CodeSeg
        .386p
        assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ifdef DEBUG
szDebug     db "Debug", 0
szDrawDib   db "DrawDib", 0
szDetect    db "detect", 0
szDetectDVA db "DetectDVA: ", 0
szNone      db "None", 0
endif

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ModeInfo STRUC

    ModeNext            dw      ?
    ModeDetect          dw      ?
    ModeNum             dw      ?
    ModeWidth           dw      ?
    ModeHeight          dw      ?
    ModeDepth           dw      ?
    ModeSetBank         dw      ?
    ModeGetBank         dw      ?
    ModeSetBank32       dw      ?
    ModeSetBank32Size   dw      ?
    ModeName            db      ?

ModeInfo ENDS

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

Mode macro y, n, w, h, b, x, name
        local   l1,l2
l1:
        dw      l2 - l1
        dw      Detect&y, n, w, h, b, SetBank&x, GetBank&x, SetBank32&x, SetBank32&x&Size

ifdef DEBUG
        db      name
        db      0
endif

l2:
        endm

ModeInfoTable label byte

        Mode VRAM, 67h, 640, 480, 8, VRAM, "VRAM II 640x480x8bpp"
        Mode VRAM, 68h, 720, 512, 8, VRAM, "VRAM II 720x512x8bpp"
        Mode VRAM, 69h, 800, 600, 8, VRAM, "VRAM II 800x600x8bpp"
        Mode VRAM, 6Ah, 1024,768, 8, VRAM, "VRAM II 1024x768x8bpp"

        Mode V7,   67h, 640, 480, 8, V7, "V7 VGA 640x480x8bpp"
        Mode V7,   68h, 720, 512, 8, V7, "V7 VGA 720x512x8bpp"
        Mode V7,   69h, 800, 600, 8, V7, "V7 VGA 800x600x8bpp"
        Mode V7,   6Ah, 1024,768, 8, V7, "V7 VGA 1024x768x8bpp"

        Mode WD,   5Fh, 640, 480, 8, WD, "WD VGA 640x480x8bpp"
        Mode WD,   5Ch, 800, 600, 8, WD, "WD VGA 800x600x8bpp"
        Mode WD,   60h, 1024,768, 8, WD, "WD VGA 1024x768x8bpp"
        Mode WD,   64h, 640, 480,16, WD, "WD VGA 640x480x16bpp"
        Mode WD,   65h, 800, 600,16, WD, "WD VGA 800x600x16bpp"

        Mode Trident, 5Dh, 640, 480, 8, Trident, "Trident 640x480x8bpp"
        Mode Trident, 5Eh, 800, 600, 8, Trident, "Trident 800x600x8bpp"
        Mode Trident, 62h, 1024,768, 8, Trident, "Trident 1024x768x8bpp"

        Mode Oak,  53h, 640, 480, 8, Oak, "Oak 640x480x8bpp"
        Mode Oak,  54h, 800, 600, 8, Oak, "Oak 800x600x8bpp"
        Mode Oak,  59h, 1024,768, 8, Oak, "Oak 1024x768x8bpp"

        Mode ATI,  12h, 640, 480, 8, ATI, "ATI 640x480x8bpp"
        Mode ATI,  12h, 800, 600, 8, ATI, "ATI 800x600x8bpp"
        Mode ATI,  12h, 1024,768, 8, ATI, "ATI 1024x768x8bpp"
        Mode ATI,  12h, 2048,1024,8, ATI, "ATI 2048x1024x8bpp"

        Mode ATI,  12h, 640, 480,16, ATI, "ATI 640x480x16bpp"
        Mode ATI,  12h, 800, 600,16, ATI, "ATI 800x600x16bpp"
        Mode ATI,  12h, 1024,768,16, ATI, "ATI 1024x768x16bpp"
        Mode ATI,  12h, 2048,1024,16,ATI, "ATI 2048x1024x16bpp"

        Mode ATI,  12h, 640, 480,24, ATI, "ATI 640x480x24bpp"
        Mode ATI,  12h, 800, 600,24, ATI, "ATI 800x600x24bpp"
        Mode ATI,  12h, 1024,768,24, ATI, "ATI 1024x768x24bpp"
        Mode ATI,  12h, 2048,1024,24,ATI, "ATI 2048x1024x24bpp"

        Mode ATI,  62h, 640, 480, 8, ATI, "ATI 640x480x8bpp"
        Mode ATI,  63h, 800, 600, 8, ATI, "ATI 800x600x8bpp"
        Mode ATI,  64h, 1024,768, 8, ATI, "ATI 1024x768x8bpp"
        Mode ATI,  75h, 640, 480,24, ATI, "ATI 640x480x24bpp"

        Mode Compaq,2Eh, 640, 480, 8, Compaq, "Compaq AVGA 640x480x8bpp"
        Mode Compaq,12h, 640, 480, 8, Compaq, "Compaq AVGA 640x480x8bpp"

        Mode Compaq,06h, 640, 480, 8, Compaq, "Compaq QVision 640x480x8bpp"
        Mode Compaq,06h, 800, 600, 8, Compaq, "Compaq QVision 800x600x8bpp"
        Mode Compaq,06h, 1024,768, 8, Compaq, "Compaq QVision 1024x768x8bpp"

        Mode Compaq,06h, 640, 480, 16, Compaq, "Compaq QVision 640x480x16bpp"
        Mode Compaq,06h, 800, 600, 16, Compaq, "Compaq QVision 800x600x16bpp"
        Mode Compaq,06h, 1024,768, 16, Compaq, "Compaq QVision 1024x768x16bpp"

        Mode Tseng, 2Eh, 640, 480, 8, Tseng, "Tseng ET4000 640x480x8bpp"
        Mode Tseng, 30h, 800, 600, 8, Tseng, "Tseng ET4000 800x600x8bpp"
        Mode Tseng, 38h, 1024,768, 8, Tseng, "Tseng ET4000 1024x768x8bpp"
        Mode Tseng, 2Eh, 640, 480,16, Tseng, "Tseng ET4000 640x480x16bpp"
        Mode Tseng, 30h, 800, 600,16, Tseng, "Tseng ET4000 800x600x16bpp"

        Mode Everex, 2Eh, 640, 480, 8, Tseng, "Everex 640x480x8bpp"
        Mode Everex, 30h, 800, 600, 8, Tseng, "Everex 800x600x8bpp"
        Mode Everex, 38h, 1024,768, 8, Tseng, "Everex 1024x768x8bpp"

; Until we get a detect routine for Cirrus, we won't include these.

        ;Mode C542x, 5Fh, 640, 480, 8, C542x, "C542x 640x480x8bpp"
        ;Mode C542x, 5Ch, 800, 600, 8, C542x, "C542x 800x600x8bpp"
        ;Mode C542x, 60h, 1024,768, 8, C542x, "C542x 1024x768x8bpp"

        ;Mode C6420, 2Eh, 640, 480, 8, C6420, "C6420 640x480x8bpp"
        ;Mode C6420, 30h, 800, 600, 8, C6420, "C6420 800x600x8bpp"
        ;Mode C6420, 38h, 1024,768, 8, C6420, "C6420 1024x768x8bpp"

ModeInfoTableEnd label byte

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;

szTseng:    db  "Tseng", 0
szOAK:      db  " OAK", 0
szTrident:  db  "TRIDENT", 0
szEverex:   db  "Everex", 0
szParadise: db  "PARADISE", 0
szWD:       db  "WESTERN DIGITAL", 0
szWeitek:   db  "WEITEK",0
szViper:    db  "VIPER VLB",0

;---------------------------Public-Routine------------------------------;
; VFlatInit
;
;       initialize for a banked display
;
; Returns:
;       C       if error
;       NC      if success
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   VFlatInit, <NEAR, PASCAL, PUBLIC>, <si,di,ds>
        localW  hdc
        localW  ScreenWidth
        localW  ScreenHeight
        localW  ScreenDepth
        localW  BiosMode
cBegin

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;   get a display DC and get resolution info
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
        cCall   GetDC, <0>
        mov     hdc,ax

        cCall   GetDeviceCaps, <hdc,HORZRES>
        mov     ScreenWidth,ax

        cCall   GetDeviceCaps, <hdc,VERTRES>
        mov     ScreenHeight,ax

        cCall   GetDeviceCaps, <hdc,BITSPIXEL>
        push    ax
        cCall   GetDeviceCaps, <hdc,PLANES>
        pop     dx
        mul     dx
        mov     ScreenDepth,ax

        cCall   ReleaseDC, <0, hdc>

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;   scan our mode table
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;

        mov     ax, 6F04h               ;Get V7 mode
        int     10h
        cmp     al,04h
        jne     short @f
	mov	ax,0F00h		;Call BIOS to get mode back.
	int	10h			;al = mode we are in.
@@:     xor     ah,ah
        mov     BiosMode,ax

        lea     bx,ModeInfoTable

mode_search:
        mov     ax,BiosMode
        cmp     cs:[bx].ModeNum,ax
        jne     short mode_search_next

        mov     ax,ScreenWidth
        cmp     cs:[bx].ModeWidth,ax
        jne     short mode_search_next

        mov     ax,ScreenHeight
        cmp     cs:[bx].ModeHeight,ax
        jne     short mode_search_next

        mov     ax,ScreenDepth
        cmp     cs:[bx].ModeDepth,ax
        jne     short mode_search_next

        push    bx
        call    cs:[bx].ModeDetect
        pop     bx
        or      ax,ax
        jnz     short mode_search_found
        errn$   mode_search_next

mode_search_next:
        add     bx,cs:[bx].ModeNext
        cmp     bx,offset ModeInfoTableEnd
        jl      mode_search
        jge     mode_search_fail

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_found:
        mov     ScreenMode,bx               ; save this for later.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;   this is a banked display, we need to talk to VflatD in order for
;   anything to work.
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
	xor	di,di
	mov	es,di
	mov	ax,1684h
        mov     bx,VflatD_Windows_ID
	int	2fh			    ;returns with es:di-->VFlatD Entry point
        mov     word ptr [VflatD_Proc][0],di
        mov     word ptr [VflatD_Proc][2],es
	mov	ax,es
        or      ax,di
        jne     short mode_search_vflat

	xor	di,di
	mov	es,di
	mov	ax,1684h
        mov     bx,VflatD_Chicago_ID
	int	2fh			    ;returns with es:di-->VFlatD Entry point
        mov     word ptr [VflatD_Proc][0],di
        mov     word ptr [VflatD_Proc][2],es
	mov	ax,es
        or      ax,di
        jz      short mode_search_fail

mode_search_vflat:
	xor	ax,ax
	mov	dx,VflatD_Get_Version
	call	[VflatD_Proc]
        cmp     ax,0100h
        jb      short mode_search_fail

        ;
        ;   estimate the required framebuffer memory
        ;
        mov     ax,ScreenDepth              ; bitdepth
        mul     ScreenWidth                 ; * width = bit width
        shr     ax,3                        ; / 8 = width bytes
        add     ax,1024-1                   ; round up to nearest K
        and     ax,not (1024-1)             ; now we have scan width
        mul     ScreenHeight                ; * number of scans = total bytes
        add     ax,0FFFFh                   ; round up to nearest MB
        adc     dx,0000Fh
        and     dx,0FFF0h
        shl     dx,4                        ; convert to 4K pages.
        mov     ax,dx

        mov     dx,VflatD_Get_Sel           ; get selector
;;;;;;;;mov     ax,512                      ; size in pages of video memory?
	mov	bx,ScreenMode
        mov     cx,cs:[bx].ModeSetBank32Size; size of bank code.
        mov     di,cs:[bx].ModeSetBank32    ; point es:di to bank code.
	push	cs
	pop	es
        call    [VflatD_Proc]               ; let VflatD init things.
        jc      short mode_search_fail
        or      ax,ax
        jz      short mode_search_fail

        errn$   mode_search_ok

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_ok:

ifdef DEBUG
        pusha
        mov     bx,ScreenMode
        lea     ax,[bx].ModeName
        lea     bx,szDrawDib
        lea     cx,szDetect

        cCall   WriteProfileString, <cs,bx, cs,cx, cs,ax>
        popa
endif
        mov     dx, ax
        xor     ax, ax
        jmp     short mode_search_exit

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_fail:
ifdef DEBUG
        pusha
        lea     ax,szDrawDib
        lea     bx,szDetect
        lea     cx,szNone
        cCall   WriteProfileString, <cs,ax, cs,bx, cs,cx>
        popa
endif
        xor     ax,ax
        mov     dx,ax
        mov     ScreenMode,ax
        mov     word ptr [VflatD_Proc][0],ax
        mov     word ptr [VflatD_Proc][2],ax
        errn$   mode_search_exit

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_exit:

cEnd

;---------------------------Public-Routine------------------------------;
; VFlatBegin - start direct frame buffer access
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   VFlatBegin, <NEAR, PUBLIC>, <>
cBegin
        mov     bx, ScreenMode
        or      bx, bx
        jz      short BeginExit

%out is CLI/STI needed?
;;;;;;;;cli
        call    cs:[bx].ModeGetBank
        xchg    bank_save,ax
        mov     dx,ax
        call    cs:[bx].ModeSetBank
;;;;;;;;sti
BeginExit:
cEnd

;---------------------------Public-Routine------------------------------;
; VFlatEnd - end direct frame buffer access
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   VFlatEnd, <NEAR, PUBLIC>, <>
cBegin
        mov     bx, ScreenMode
        or      bx, bx
        jz      short EndExit

%out is CLI/STI needed?
;;;;;;;;cli
        call    cs:[bx].ModeGetBank
        xchg    bank_save,ax
        mov     dx,ax
        call    cs:[bx].ModeSetBank
;;;;;;;;sti
EndExit:
cEnd

;---------------------------Public-Routine------------------------------;
; ScanROM   - scan the video bios ROM looking for a string
;
; Entry:
;       cs:ax   - string to look for.
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

ScanROM proc near
        push    si
        mov     si,ax

        mov     ax,__C000h
        mov     es,ax

        xor     bx,bx               ; start at zero
        mov     cx,512              ; search first 512 bytes.

        mov     dx,si
scan_start:
        mov     si,dx
        mov     al,cs:[si]
scan_cmp:
        cmp     byte ptr es:[bx], al
        je      short scan_found
        inc     bx
        loop    scan_start
        xor     ax,ax
        pop     si
        ret

scan_next:
        inc     bx
        loop    scan_cmp
        xor     ax,ax
        pop     si
        ret

scan_found:
        inc     si
        mov     al,cs:[si]
        or      al,al
        jnz     scan_next
        inc     ax
        pop     si
        ret

ScanROM  endp

;----------------------------------------------------------------------------
; BANK SWITCH TEMPLATES
;  Each template is given to vflatd.386 which copies it inline in to the 
;  page fault handling code.
; NOTE: This code runs at ring 0 in a USE32 code segment, so be carefull!!!
; ALL REGISTERS MUST BE PRESERVED (except for dx)
;----------------------------------------------------------------------------

;****************************************************************************
; V7
;****************************************************************************

DetectV7 proc near

        mov     ax,6f00h                ;Test for Video 7
	xor	bx,bx
	cld
        int     10h
        xor     ax,ax
        cmp     bx,'V7'
        jne     short @f
        inc     ax
@@:     ret

DetectV7 endp

SetBank32V7 label byte
	push	ax
	push	bx

        mov     bl,al
        and     bl,1                    ; BL = extended page select

        mov     ah,al
        and     ah,2
        shl     ah,4                    ; AH = page select bit

        and     al,00ch
        mov     bh,al
        shr     al,2
        or      bh,al                   ; BH = 256K bank select

        db      66h,0bah,0cch,03h       ;mov dx, 3CCh
        in      al,dx                   ; Get Miscellaneous Output Register
        and     al,not 20h              ; Clear page select bit
        or      al,ah                   ; Set page select bit (maybe)
        mov     dl,0c2h                 ; Write Miscellaneous Output Register
        out     dx,al

        mov     dl,0c4h                 ; Sequencer
        mov     al,0f9h                 ; Extended page select register
        mov     ah,bl                   ; Extended page select value
        out     dx,eax			; out dx,ax

        mov     al,0f6h                 ; 256K bank select
        out     dx,al
        inc     dx                      ; Point to data
        in      al,dx
        and     al,0f0h                 ; Clear out bank select banks
        or      al,bh                   ; Set bank select banks (maybe)
        out     dx,al
	pop	bx
        pop     ax
SetBank32V7Size = $ - SetBank32V7

SetBankV7 proc near
        mov     bl,dl
        and     bl,1                    ; BL = extended page select

        mov     ah,dl
        and     ah,2
        shl     ah,4                    ; AH = page select bit

        and     dl,00ch
        mov     bh,dl
        shr     dl,2
        or      bh,dl                   ; BH = 256K bank select

        mov     dx,03cch
        in      al,dx                   ; Get Miscellaneous Output Register
        and     al,not 20h              ; Clear page select bit
        or      al,ah                   ; Set page select bit (maybe)
        mov     dl,0c2h                 ; Write Miscellaneous Output Register
        out     dx,al

        mov     dl,0c4h                 ; Sequencer
        mov     al,0f9h                 ; Extended page select register
        mov     ah,bl                   ; Extended page select value
        out     dx,ax

        mov     al,0f6h                 ; 256K bank select
        out     dx,al
        inc     dx                      ; Point to data
        in      al,dx
        and     al,0f0h                 ; Clear out bank select banks
        or      al,bh                   ; Set bank select banks (maybe)
        out     dx,al
	ret
SetBankV7 endp

GetBankV7      proc    near
	mov	dx,3cch
        in      al,dx
        and     al,20h                  ; page select bit
        shr     al,4
        mov     ah,al

	mov	dx,3C4h
	mov	al,0f9h
	out	dx,al
	inc	dx
        in      al,dx
        and     al,1
        or      ah,al

	dec	dx
	mov	al,0F6h
	out	dx,al
	inc	dx
        in      al,dx
        and     al,0ch
        or      al,ah
        xor     ah,ah
	ret
GetBankV7      endp

;****************************************************************************
; V7 II
;****************************************************************************

DetectVRAM proc near
if 0    ; ack!
        call    DetectV7
        or      ax,ax
        jz      short novram

	mov	dx,03C4H
	mov	al,08FH
	out	dx,al
	inc	dx
	in	al,dx
	mov	ah,al

	dec	dx
	mov	al,08EH
	out	dx,al
	inc	dx
	in	al,dx

        cmp     ax,07151H               ;VRAMII rev B id
        je      short isvram
        cmp     ax,07152H               ;VRAMII rev C and D id
        je      short isvram
;       cmp     ax,07760H               ;HT216 rev B and C
;       je      short isvram
;       cmp     ax,07763H               ;HT216 rev B, C, and D
;       je      short isvram
;       cmp     ax,07764H               ;HT216 rev E
;       je      short isvram
endif
novram:
        xor     ax,ax
        ret
isvram:
        mov     ax,1
        ret

DetectVRAM endp

SetBank32VRAM label byte
        push    ax                      ;push eax
        shl     dl,4
        mov     ah,dl
        db      66h,0bah,0c4h,03h       ; mov dx, 3C4h
	mov	al,0e8h
        out     dx,eax			; out dx,ax
        pop     ax                      ; pop eax
SetBank32VRAMSize = $ - SetBank32VRAM

SetBankVRAM proc near
        shl     dl,4
        mov     ah,dl
	mov	dx,03c4h
	mov	al,0e8h
        out     dx,ax
        ret
SetBankVRAM endp

GetBankVRAM proc near
        mov     dx,3c4h
        mov     al,0e8h
	out	dx,al
	inc	dx
        in      al,dx
        shr     al,4
        ret
GetBankVRAM endp

;****************************************************************************
; ATI
;****************************************************************************

public DetectATI
DetectATI proc near
        mov     ax,__C000h              ;ATI VGA detect (largely from ATI example code)
        mov     es,ax
        xor     ax,ax
	cmp	word ptr es:[40h],'13'	;ATI Signiture on the Video BIOS
        jne     short @f
        inc     ax
@@:     ret
DetectATI endp

SetBank32ATI label byte
	push	ax
	mov	ah,al
	shl	ah,1
	mov	al,0B2h
        db      66h,0bah,0ceh,01h       ;mov dx, 1CEh
	out	dx,eax
	pop	ax
SetBank32ATISize = $ - SetBank32ATI

SetBankATI proc near
	mov	ah,dl
	shl	ah,1
	mov	al,0b2h		;Page select register index
	mov	dx,1ceh		;
	out	dx,ax		;
	ret
SetBankATI endp

GetBankATI     proc    near
	mov	dx,1ceh
	mov	al,0b2h
	out	dx,al
	inc	dx
        in      al,dx
        shr     al,1
	ret
GetBankATI     endp

;****************************************************************************
; OAK
;****************************************************************************

DetectOAK   proc    near

        lea     ax,szOAK
        jmp     ScanROM

DetectOAK   endp

SetBank32Oak label byte
	push	ax
	mov	ah,al
	shl	al,4
	or	ah,al
        db      66h,0bah,0deh,03h       ;mov dx, 3DEh
	mov	al,11h
	out	dx,eax
	pop	ax
SetBank32OakSize = $ - SetBank32Oak

SetBankOAK proc near
	mov	al,dl
	mov	ah,al
	shl	al,4
	or	ah,al
	mov	dx,3deh
	mov	al,11h
	out	dx,ax
	ret
SetBankOAK endp

GetBankOAK     proc    near
	mov	dx,3deh
	mov	al,11h
	out	dx,al
	inc	dx
        in      al,dx
        and     al,0Fh
	ret
GetBankOAK        endp

;****************************************************************************
; Everex
;****************************************************************************

DetectEverex  proc    near

        lea     ax,szEverex
        jmp     ScanROM

DetectEverex    endp

;****************************************************************************
; Tseng
;****************************************************************************

DetectTseng  proc    near

        lea     ax,szTseng
        jmp     ScanROM

DetectTseng   endp

SetBank32Tseng label byte
	mov	dx, ax                  ;mov edx,eax
	shl	al, 4
	or	al, dl
        db      66h,0bah,0cdh,03h       ;mov dx, 3CDh
	out	dx, al                              
	shr	al, 4                   ;shr al,4
SetBank32TsengSize = $ - SetBank32Tseng

SetBankTseng proc near
        and     al,0fh
	mov	al,dl
	mov	ah,al
	shl	al,4
	or	al,ah
	mov	dx,3cdh
	out	dx,al
	ret
SetBankTseng endp

GetBankTseng proc near
	mov	dx,3cdh
        in      al,dx
	shr	al, 4                   ;shr al,4
	ret
GetBankTseng endp

;****************************************************************************
; WD
;****************************************************************************

DetectWD  proc    near

        lea     ax,szWD
        call    ScanROM
        or      ax,ax
        jz      short @f
        ret

@@:     lea     ax,szParadise
        jmp     ScanROM

DetectWD endp

SetBank32WD label byte
        push    ax
	mov	ah,al			;ah = bank number
        mov     al,9                    ;select the primary "bank adder" reg
        shl     ah,4
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax                  ;out dx,ax (write 3cf:09, desired bank)
        pop     ax
SetBank32WDSize = $ - SetBank32WD

SetBankWD proc near
        mov     al,9                    ;select the primary "bank adder" reg
        mov     ah,dl
        shl     ah,4
        mov     dx,3ceh
        out     dx,ax                   ;write 3cf:09, desired bank
        ret
SetBankWD endp

GetBankWD      proc near
	mov	dx,3ceh
        mov     al,9
	out	dx,al
	inc	dx
        in      al,dx
        shr     al,4
	ret
GetBankWD      endp

;****************************************************************************
; Weitek
;****************************************************************************

DetectWeitek  proc    near

        lea     ax,szWeitek
        jmp     ScanROM

DetectWeitek   endp

;****************************************************************************
; Trident
;****************************************************************************

DetectTrident proc    near

        lea     ax,szTrident
        jmp     ScanROM

DetectTrident endp

SetBank32Trident label byte
	push	ax
	mov	ah,al
	xor	ah,2
	mov	al,0EH
        db      66h,0bah,0c4h,03h       ;mov dx, 3C4h
	out	dx,eax			
;;      db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
;;	out	dx,eax			;for 8900c or better only.
	pop	ax
SetBank32TridentSize = $ - SetBank32Trident

SetBankTrident proc near
	mov	ah,dl
	xor	ah,2
	mov	al,0EH
	mov	dx,3c4h
	out	dx,ax
;;	mov	dx,3ceh
;;	out	dx,ax			;for 8900c or better only.
	ret
SetBankTrident endp

GetBankTrident proc near
	mov	dx,3c4h
	mov	al,0eh
	out	dx,al
	inc	dx
	in	al,dx
;;      xor     al,2			; removed for build 190!
	ret
GetBankTrident endp

;****************************************************************************
; Compaq
;****************************************************************************

DetectCompaq proc near
        mov     ax,__C000h
        mov     es,ax
        xor     ax,ax
        cmp     word ptr es:[2],0E930h
        jne     short @f
        inc     ax
@@:     ret
DetectCompaq endp

SetBank32Compaq label byte
        push    ax
        mov     ah,al
        shl     ah,4
        mov     al,45h
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax
        inc     al
        add     ah,08h
        out     dx,eax
	pop	ax
SetBank32CompaqSize = $ - SetBank32Compaq

SetBankCompaq proc near
        mov     ah,dl
        shl     ah,4
        mov     dx,03CEh
        mov     al,45h
        out     dx,ax
        inc     al
        add     ah,08h
        out     dx,ax
	ret
SetBankCompaq endp

GetBankCompaq proc near
        mov     dx,03CEh
        mov     al,45h
	out	dx,al
	inc	dx
	in	al,dx
        shr     al,4
	ret
GetBankCompaq endp

;****************************************************************************
; Cirrus 6420
;****************************************************************************

DetectC6420 proc near
        %out *** need a Detect function for Cirrus 6420
        mov     ax,1        ;!!!
        ret
DetectC6420 endp

SetBank32C6420 label byte
        push    ax
        mov     ah,al
	shl	ah,4
        mov     al,0eh
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax                  ;
        pop     ax

SetBank32C6420Size = $ - SetBank32C6420

SetBankC6420    proc near
        mov     ah,dl
	shl	ah,4
        mov     al,0eh
        mov     dx, 3CEh
        out     dx,ax
        ret

SetBankC6420    endp

GetBankC6420    proc near
        mov     dx,03CEh
        mov     al,0Eh
	out	dx,al
	inc	dx
	in	al,dx
        shr     al,4
	ret

GetBankC6420    endp

;****************************************************************************
; Cirrus 542x
;****************************************************************************

DetectC542x proc near
        %out *** need a Detect function for Cirrus 542x
        mov     ax,1        ;!!!
        ret
DetectC542x endp

SetBank32C542x label byte
        push    ax
        mov     ah,al
	shl	ah,4
        mov     al,09h
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax
        pop     ax

SetBank32C542xSize = $ - SetBank32C542x

SetBankC542x    proc near
        mov     ah,dl
	shl	ah,4
        mov     al,09h
        mov     dx,3CEh
        out     dx,ax
        ret

SetBankC542x    endp

GetBankC542x    proc near
        mov     dx,03CEh
        mov     al,09h
	out	dx,al
	inc	dx
	in	al,dx
        shr     al,4
	ret

GetBankC542x    endp

;****************************************************************************
; Viper Vesa Local bus
;****************************************************************************

public DetectViper
DetectViper proc near
        lea     ax,szViper
        jmp     ScanROM
DetectViper endp

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\dvaati.c ===
/****************************************************************************

    DVA surface provider for a ATI Mach32 card.

    assumes a linear frame buffer

    assumes a hardware cursor

 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "lockbm.h"

extern NEAR PASCAL DetectATI(void);

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK ati_open_surface(LPVOID pv)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK ati_close_surface(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK ati_begin_access(LPVOID pv, int x, int y, int dx, int dy)
{
    //
    // ATI Mach32 has a HW cursor so we dont do anything
    // !!!we may need to check for the sysVM in background
    //
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK ati_end_access(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL ati_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    DWORD SizeImage;
    IBITMAP FAR *pbm;
    UINT sel;
    DWORD off;
    LPBITMAPINFOHEADER lpbi;

    if (nSurface != 0)
        return FALSE;

    pbm = GetPDevice(hdc);

    if (pbm == NULL || pbm->bmType == 0)
        return FALSE;

    if (pbm->bmType != 0x2000)
        return FALSE;

    if (!DetectATI())
        return FALSE;

    sel = ((WORD FAR  *)&pbm->bmBits)[2];
    off = ((DWORD FAR *)&pbm->bmBits)[0];

    SizeImage = (DWORD)(UINT)pbm->bmWidthBytes * (DWORD)(UINT)pbm->bmHeight;

    if (GetSelectorLimit(sel) != 0xFFFFFFFF || off < 4*1024*1024l)
        return FALSE;

    sel = 0;    // off is the linear offset.

    lpbi = &pdva->BitmapInfo;

    lpbi->biSize            = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth           = pbm->bmWidthBytes*8/pbm->bmBitsPixel;
    lpbi->biHeight          = -(int)pbm->bmHeight;
    lpbi->biPlanes          = pbm->bmPlanes;
    lpbi->biBitCount        = pbm->bmBitsPixel;
    lpbi->biCompression     = 0;
    lpbi->biSizeImage       = SizeImage;
    lpbi->biXPelsPerMeter   = pbm->bmWidthBytes;
    lpbi->biYPelsPerMeter   = 0;
    lpbi->biClrUsed         = 0;
    lpbi->biClrImportant    = 0;

    pdva->selSurface   = sel;
    pdva->offSurface   = off;
    pdva->Version      = 0x0100;
    pdva->Flags        = 0;
    pdva->lpSurface    = (LPVOID)42;

#ifdef DEBUG
{
//
// in DEBUG use the VGA's begin/end access routines so the mouse will flicker!
//
extern BOOL FAR PASCAL _loadds vga_open_surface(LPVOID pv);
extern void FAR PASCAL _loadds vga_close_surface(LPVOID pv);
extern BOOL FAR PASCAL _loadds vga_begin_access(LPVOID pv, int x, int y, int dx, int dy);
extern BOOL FAR PASCAL _loadds vga_end_access(LPVOID pv);
    (FARPROC)pdva->OpenSurface  = (FARPROC)vga_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vga_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)vga_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)vga_end_access;
}
#else
    (FARPROC)pdva->OpenSurface  = (FARPROC)ati_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)ati_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)ati_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)ati_end_access;
#endif
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\dvaclip.c ===
#define TestWF(hwnf, f) (GetWindowLong(hwnd, GWL_STYLE) & (f))

BOOL DVAIsClipped(HDC hdc, RECT& rc)
{
    RECT rcClip;

    if (GetClipBox(hdc, &rcClip) != SIMPLEREGION)
        return TRUE;

    if (rc.left   < rcClip.left  ||
        rc.top    < rcClip.top   ||
        rc.right  > rcClip.right ||
        rc.bottom > rcClip.bottom)

        return TRUE;

    return FALSE;
}

int DVAGetClipList(HWND hwnd, LPRECT prc, LPRECT RectList, int RectCount)
{
    RECT rc;
    HWND hwndP;
    HWND hwndT;

    if (RectCount == 0 || !IsVisible(hwnd))
        return 0;

    //
    // get the client area of the window
    //
    GetClientRect(hwnd, RectList);

    if (prcTest)
        IntersectRect(RectList, RectList, prc);

    ClientToScreen(hwnd, (LPPOINT)RectList);
    ClientToScreen(hwnd, (LPPOINT)RectList + 1);

    RectCount = 1;
    RectList[1] = RectList[0];

    //
    // walk all children of hwnd and remove them if needed
    //
    if (TestWF(hwnd WS_CLIPCHILDREN))
    {
        RectCount = ExcludeWindowRects(RectList, RectCount,
            GetWindow(hwnd, GW_CHILD), NULL);

        if (RectCount == 0)
            return 0;
    }

    //
    // walk all the siblings of hwnd and exclude them from the list.
    //
    for (; (hwndP = GetWindow(hwnd, GW_PARENT)) != NULL; hwnd = hwndP)
    {
        GetWindowRect(hwndP, &rc);
        RectCount = IntersectRectList(RectList, RectCount, &rc;

        if (RectCount == 0)
            return 0;

        if (TestWF(hwnd, WS_CLIPSIBLINGS))
        {
            RectCount = ExcludeWindowRects(RectList, RectCount,
                GetWindow(hwndP, GW_CHILD), hwnd);

            if (RectCount == 0)
                return 0;
        }
    }

    return RectCount;
}

int ExcludeWindowRects(LPRECT RectList, int RectCount, HWND hwndA, HWND hwndB)
{
    RECT rc;

    for (hwnd = hwndA; hwnd != NULL && hwnd != hwndB; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        if (!IsWindowVisible(hwnd))
	    continue;

	// Don't subtract off transparent windows...
	//
	if (TestWF(hwnd, WEFTRANSPARENT))
            continue;

        GetWindowRect(hwnd, &rc);

        RectCount = ExcludeRectList(RectList, RectCount, &rc);

        if (RectCount == 0)
            return 0;
    }

    return RectCount;
}


int ExcludeRectList(LPRECT RectList, int RectCount, LPRECT prc)
{
    int i;
    int n;
    RECT rc;

    if (RectCount == 0)
        return 0;

    SubtractRect(RectList, prc);

    for (i=1; i <= RectCount; i++)
    {
        if (!IntersectRect(&rc, &RectList[i], prc))
            continue;

        //
        //
        //

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\lockbm.h ===
#define BM_NULL         0
#define BM_TYPE         0x0F        // type mask
#define BM_8BIT         0x01        // all SVGA, and other 256 color
#define BM_16555        0x02        // some HiDAC cards
#define BM_24BGR        0x03        // just like a DIB
#define BM_32BGR        0x04        // 32 bit BGR
#define BM_VGA          0x05        // VGA style bitmap.
#define BM_16565        0x06        // most HiDAC cards
#define BM_24RGB        0x07        // 24 bit RGB
#define BM_32RGB        0x08        // 32 bit RGB
#define BM_1BIT         0x09        // mono bitmap
#define BM_4BIT         0x0A        // 4 bit packed pixel.

//
//  this is a physical BITMAP in memory, this is just like a  BITMAP
//  structure, but with extra fields staring at bmWidthPlanes
//
typedef struct {
    short  bmType;
    short  bmWidth;
    short  bmHeight;
    short  bmWidthBytes;
    BYTE   bmPlanes;
    BYTE   bmBitsPixel;
    LPVOID bmBits;
    long   bmWidthPlanes;
    long   bmlpPDevice;
    short  bmSegmentIndex;
    short  bmScanSegment;
    short  bmFillBytes;
    short  reserved1;
    short  reserved2;
} IBITMAP;

LPVOID FAR GetPDevice(HDC hdc);
void   FAR TestSurfaceType(HDC hdc, int x, int y);
UINT   FAR GetSurfaceType(LPVOID lpBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dcilib\vflatd.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1993-1994
;
;   Title:	Virtual Flat Device Exported Services
;
;   Version:	2.00
;
;   Date:	8-Nov-1993
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   08-Nov-1993 RAP Original
;
;==============================================================================

IFDEF VMM_TRUE
Begin_Service_Table VFLATD

VFLATD_Service VFLATD_Get_Version, LOCAL
VFLATD_Service VFLATD_Unmap_Flat_Selector, LOCAL

End_Service_Table VFLATD
ENDIF

VflatD_Chicago_ID   equ     011Fh           ; OEM #8 Device #31
VflatD_Windows_ID   equ     (0440h + 29d)   ; MMSYS OEM# device 30

ifdef WIN31
VflatD_Device_ID    equ     VflatD_Windows_ID
VflatD_Version      equ     0160h           ; 1.60
else
VflatD_Device_ID    equ     VflatD_Chicago_ID
VflatD_Version      equ     0200h           ; 2.00
endif

;
;   PM API defines
;
VflatD_Query                        equ 0
VflatD_Get_Version                  equ 0
VflatD_Get_Sel                      equ 1
VflatD_Reset                        equ 2
VflatD_Create_Virtual_Frame_Buffer  equ 3
VflatD_Create_Physical_Frame_Buffer equ 4

;******************************************************************************
;
;   VFLATD_PM_API_Query
;
;   DESCRIPTION:
;       Query VFlatD info
;
;   ENTRY:
;       Client_DX = 0
;
;   EXIT:
;       Client_EAX = VFlatD version
;       Client_EBX = selector to the frame buffer
;       Client_ECX = size of frame buffer
;       Client_EDX = Bank size + flags?
;
;==============================================================================

;******************************************************************************
;
;   VFLATD_PM_API_Get_Video_Base
;
;   DESCRIPTION:
;       Return a GDT selector to the flat video buffer
;
;   ENTRY:
;       Client_DX = 1
;       Client_AX = # of pages of video memory
;       Client_CX = size of bank switch code
;       Client_ES:DI -> bank switch code
;
;   EXIT:
;       Client_AX  = Selector to flat video buffer
;       Client_EDX = Linear base of flat video buffer
;       Client carry flag clear
;
;==============================================================================

;******************************************************************************
;
;   VFLATD_PM_API_Create_Physical_Frame_Buffer
;
;   DESCRIPTION:
;       Return a GDT selector to a flat video buffer
;
;   ENTRY:
;       Client_DL    = 4
;       Client_DH    = flags
;       Client_EAX   = physical base of frame buffer
;       Client_ECX   = size of frame buffer (in bytes)
;
;   EXIT:
;       Client_AX  = Selector to flat video buffer
;       Client_EDX = Linear base of flat video buffer
;       Client carry flag clear
;
;==============================================================================

;******************************************************************************
;
;   VFLATD_PM_API_Create_Virtual_Frame_Buffer
;
;   DESCRIPTION:
;       Return a GDT selector to the flat video buffer
;
;   ENTRY:
;       Client_DL    = 3
;       Client_DH    = flags
;       Client_EAX   = size of frame buffer (in bytes)
;       Client_EBX   = size of a bank (in bytes)
;       Client_ESI   = location of bank
;       Client_CX    = size of bank switch code
;       Client_ES:DI = ptr to bank switch code
;
;   EXIT:
;       Client_AX  = Selector to flat video buffer
;       Client_EDX = Linear base of flat video buffer
;       Client carry flag clear
;
;==============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\ddt\ddt.c ===
#include <windows.h>
#include <drawdib.h>
#include <mmsystem.h>
#include "ddt.h"

static  char    szAppName[]="Display Test";
static  HANDLE  hInstApp;
static  int     fhLog;

static UINT (FAR *displayFPS)[3][2];

void LogMsg (LPSTR sz,...);
void ErrMsg (LPSTR sz,...);

DWORD VideoForWindowsVersion()
{
    HINSTANCE h;
    DWORD (FAR PASCAL *Version)(void);
    DWORD ver=0;

    SetErrorMode(SEM_NOOPENFILEERRORBOX);
    h = LoadLibrary("MSVIDEO");
    SetErrorMode(0);

    if (h <= HINSTANCE_ERROR)
        return ver;

    (FARPROC)Version = GetProcAddress(h, "VideoForWindowsVersion");

    if (Version != NULL)
        ver = Version();

    FreeLibrary(h);
    return ver;
}

#define BI_CRAM     mmioFOURCC('C','R','A','M')

#ifndef QUERYDIBSUPPORT
    #define QUERYDIBSUPPORT     3073
    #define QDI_SETDIBITS       0x0001
    #define QDI_GETDIBITS       0x0002
    #define QDI_DIBTOSCREEN     0x0004
    #define QDI_STRETCHDIB      0x0008
#endif

DWORD QueryDibSupport(LPBITMAPINFOHEADER lpbi)
{
    HDC hdc;
    DWORD dw = 0;

    hdc = GetDC(NULL);

    //
    // send the Escape to see if they support this DIB
    //
    if (!Escape(hdc, QUERYDIBSUPPORT, (int)lpbi->biSize, (LPVOID)lpbi, (LPVOID)&dw) > 0)
        dw = -1;

    ReleaseDC(NULL, hdc);
    return dw;
}

static void TestDisplay(void)
{
    (LPVOID)displayFPS = (LPVOID)DrawDibProfileDisplay(NULL);

#define SUCK(bpp,n) \
    displayFPS[bpp/8][n][0]/10, displayFPS[bpp/8][n][0]%10, \
    displayFPS[bpp/8][n][1]/10, displayFPS[bpp/8][n][1]%10, \
    (LPSTR)(displayFPS[bpp/8][n][0] < displayFPS[bpp/8][n][1] ? "** POOR **" : "")

#define SUCKS(bpp) \
    SUCK(bpp,0), \
    SUCK(bpp,1), \
    SUCK(bpp,2)  \

    ErrMsg(
            "   8 Bit DIBs     \tStretchDI    \tSetDI+BitBlt\n"
            "       Stretch x1 \t%03d.%01d fps\t%03d.%01d fps %s\n"
            "       Stretch x2 \t%03d.%01d fps\t%03d.%01d fps %s\n"
            "       Stretch xN \t%03d.%01d fps\t%03d.%01d fps %s\n\n"

            "   16 Bit DIBs\n"
            "       Stetch  x1 \t%03d.%01d fps\t%03d.%01d fps %s\n"
            "       Stretch x2 \t%03d.%01d fps\t%03d.%01d fps %s\n"
            "       Stretch xN \t%03d.%01d fps\t%03d.%01d fps %s\n\n"

            "   24 Bit DIBs\n"
            "       Stetch  x1 \t%03d.%01d fps\t%03d.%01d fps %s\n"
            "       Stretch x2 \t%03d.%01d fps\t%03d.%01d fps %s\n"
            "       Stretch xN \t%03d.%01d fps\t%03d.%01d fps %s",
            SUCKS(8),
            SUCKS(16),
            SUCKS(24)
            );
}

void Sleep(UINT uSleep)
{
    MSG msg;
    int id;

    id = SetTimer(NULL, 42, uSleep, NULL);

    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (msg.message == WM_TIMER && msg.wParam == (WORD)id)
            break;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    KillTimer(NULL, id);
}

#pragma optimize("", off)
void GetNetName(char *pBuffer)
{
    _asm
    {
        mov     bx, pBuffer     ; ds:bx -> pBuffer

        xor     ax,ax           ; zero the buffer
        mov     [bx],ax
        mov     [bx+2],ax
        mov     [bx+4],ax
        mov     [bx+8],ax
        mov     [bx+10],ax
        mov     [bx+12],ax
        mov     [bx+14],ax

        mov     dx, bx          ; ds:dx -> pBuffer
        mov     ax, 5E00h       ; get machine name
        int     21h
        cmc
        sbb     ax,ax
    }
}
#pragma optimize("", on)

void NetName(char *achNetName)
{
    int i;

    GetNetName(achNetName);

    for (i=15; i>=0 && (achNetName[i] == ' ' || achNetName[i] == 0); i--)
        achNetName[i] = 0;

    if (achNetName[0] == 0)
        lstrcpy(achNetName, "(Unknown)");
}

void DisplayName(char *szDisplay)
{
    char achDriver[128];
    char achDriverName[128];
    HDC hdc;

    GetPrivateProfileString("boot",            "display.drv","",achDriver, sizeof(achDriver),"system.ini");
    GetPrivateProfileString("boot.description","display.drv","",achDriverName, sizeof(achDriverName),"system.ini");

    hdc = GetDC(NULL);
    wsprintf(szDisplay, "%dx%dx%d, %s, %s",
        GetSystemMetrics(SM_CXSCREEN),
        GetSystemMetrics(SM_CYSCREEN),
        GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL),
        (LPSTR)achDriver, (LPSTR)achDriverName);
    ReleaseDC(NULL, hdc);
}

BOOL WriteLog()
{
    char     ach[128];
    OFSTRUCT of;
    int i;
    BITMAPINFOHEADER bi;
    DWORD f;
    DWORD VfW;
    WORD  Win;

    // Open log file, keep trying for a while.

    GetModuleFileName(hInstApp, ach, sizeof(ach));
    lstrcpy(ach+lstrlen(ach)-4,".log");

    SetErrorMode(SEM_FAILCRITICALERRORS);
    for (i=0; i<100; i++)
    {
        fhLog = OpenFile(ach, &of, OF_READWRITE|OF_SHARE_DENY_WRITE);

        if (fhLog == -1)    //!!! should we do this?
            fhLog = OpenFile(ach, &of, OF_READWRITE|OF_CREATE|OF_SHARE_DENY_WRITE);

        if (fhLog != -1)
            break;

        Sleep(2000);        // sleep for a while
    }
    SetErrorMode(0);

    if (fhLog == -1)
        return FALSE;

    _llseek(fhLog, 0, SEEK_END);

    LogMsg("Display Test Results 1.0 *******************************************\r\n");

    NetName(ach);
    LogMsg("User:   \t%s\r\n",(LPSTR)ach);

    VfW = VideoForWindowsVersion();
    Win = (WORD)GetVersion();

    LogMsg("Windows:\t%d.%02d %s\r\n",LOBYTE(Win), HIBYTE(Win), (LPSTR)(GetSystemMetrics(SM_DEBUG) ? "(Debug)" : ""));
    LogMsg("VfW:    \t%d.%02d.%02d.%02d\r\n",HIBYTE(HIWORD(VfW)),LOBYTE(HIWORD(VfW)),HIBYTE(VfW),LOBYTE(VfW));

    DisplayName(ach);
    LogMsg("Display:\t%s\r\n",(LPSTR)ach);

#define SDIB(f) \
    (LPSTR)((f != -1) ? ((f & QDI_SETDIBITS   ) ? "Yes" : "No") : "Not Supported" )

    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = 100;
    bi.biHeight = 100;
    bi.biPlanes = 1;
    bi.biBitCount = 0;
    bi.biCompression = 0;
    bi.biSizeImage = 0;
    bi.biXPelsPerMeter = 0;
    bi.biYPelsPerMeter = 0;
    bi.biClrUsed = 0;
    bi.biClrImportant = 0;

    bi.biBitCount = 16;
    bi.biCompression = 0;
    f = QueryDibSupport(&bi);
    LogMsg("RGB555:   \t%s\r\n",SDIB(f));

    bi.biBitCount = 32;
    bi.biCompression = 0;
    f = QueryDibSupport(&bi);
    LogMsg("RGB32:    \t%s\r\n",SDIB(f));

    bi.biBitCount = 16;
    bi.biCompression = BI_CRAM;
    f = QueryDibSupport(&bi);
    LogMsg("Cram16:   \t%s\r\n",SDIB(f));

    bi.biBitCount = 8;
    bi.biCompression = BI_CRAM;
    f = QueryDibSupport(&bi);
    LogMsg("Cram8:    \t%s\r\n",SDIB(f));

    LogMsg("\r\n");

    LogMsg(
            "\t8 Bit DIBs \tStretchDI\tSetDI+BitBlt\r\n"
            "\tStretch x1 \t%03d.%01d   \t%03d.%01d\t%s\r\n"
            "\tStretch x2 \t%03d.%01d   \t%03d.%01d\t%s\r\n"
            "\tStretch xN \t%03d.%01d   \t%03d.%01d\t%s\r\n\r\n"

            "\t16 Bit DIBs\r\n"
            "\tStetch  x1 \t%03d.%01d   \t%03d.%01d\t%s\r\n"
            "\tStretch x2 \t%03d.%01d   \t%03d.%01d\t%s\r\n"
            "\tStretch xN \t%03d.%01d   \t%03d.%01d\t%s\r\n\r\n"

            "\t24 Bit DIBs\r\n"
            "\tStetch  x1 \t%03d.%01d   \t%03d.%01d\t%s\r\n"
            "\tStretch x2 \t%03d.%01d   \t%03d.%01d\t%s\r\n"
            "\tStretch xN \t%03d.%01d   \t%03d.%01d\t%s\r\n\r\n",
            SUCKS(8),
            SUCKS(16),
            SUCKS(24)
            );

    LogMsg("\r\n");
    _lclose(fhLog);

    return TRUE;
}

/*----------------------------------------------------------------------------*\
|   WinMain( hInst, hPrev, lpszCmdLine, cmdShow )			       |
|                                                                              |
|   Description:                                                               |
|       The main procedure for the App.  After initializing, it just goes      |
|       into a message-processing loop until it gets a WM_QUIT message         |
|       (meaning the app was closed).                                          |
|                                                                              |
|   Arguments:                                                                 |
|	hInst		instance handle of this instance of the app	       |
|	hPrev		instance handle of previous instance, NULL if first    |
|       szCmdLine       ->null-terminated command line                         |
|       cmdShow         specifies how the window is initially displayed        |
|                                                                              |
|   Returns:                                                                   |
|       The exit code as specified in the WM_QUIT message.                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
int PASCAL WinMain(HANDLE hInst, HANDLE hPrev, LPSTR szCmdLine, WORD sw)
{
    hInstApp = hInst;

    TestDisplay();

    if (hPrev == NULL)
        WriteLog();

    return 0;
}

void ErrMsg (LPSTR sz,...)
{
    static char ach[2000];

    wvsprintf (ach,sz,(LPSTR)(&sz+1));	 /* Format the string */
    MessageBox(NULL,ach,szAppName,
#ifdef BIDI
		MB_RTL_READING |
#endif

MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL);
}

void LogMsg (LPSTR sz,...)
{
    static char ach[2000];
    int len;

    len = wvsprintf (ach,sz,(LPSTR)(&sz+1));   /* Format the string */

    if (fhLog != -1)
        _lwrite(fhLog, ach, len);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\dvaddi.h ===
//
// DVADDDI.H
//
// Copyright (c) 1993 Microsoft Corporation
//
// DVA 1.0 Interface Definitions
//

#define DVAGETSURFACE       3074    // GDI Escape for DVA
#define DVA_VERSION         0x0100  // version number of DVA 1.0

//
// DVASURFACEINFO structure
//
typedef struct {                                               //
    BITMAPINFOHEADER BitmapInfo;                               // BITMAPINFO of surface
    DWORD            dwMask[3];                                // masks for BI_BITFIELDS
    DWORD            offSurface;                               // surface offset
    WORD             selSurface;                               // surface selector
    WORD             Version;                                  // DVA Version
    DWORD            Flags;                                    // Flags
    LPVOID           lpSurface;                                // driver use.
    BOOL (CALLBACK *OpenSurface) (LPVOID);                     // OpenSurface callback
    void (CALLBACK *CloseSurface)(LPVOID);                     // CloseSurface callback
    BOOL (CALLBACK *BeginAccess) (LPVOID,int,int,int,int);     // BeginAccess callback
    void (CALLBACK *EndAccess)   (LPVOID);                     // EndAccess callback
    UINT (CALLBACK *ShowSurface) (LPVOID,HWND,LPRECT,LPRECT);  // ShowSurface callback
} DVASURFACEINFO, FAR *LPDVASURFACEINFO;                       //

//
// Definitions for DVASURFACEINFO.dvaFlags
//
#define DVAF_1632_ACCESS    0x0001  // must access using 16:32 pointers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\dvaddi.inc ===
;----------------------------------------------------------------------------
; DVADDDI.INC
;
; Copyright (c) 1993 Microsoft Corporation
;
; DVA 1.0 Interface Definitions
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; E Q U A T E S
;----------------------------------------------------------------------------

DVAGETSURFACE       equ     3074d   ; GDI Escape for DVA
DVA_VERSION         equ     0100h   ; version number of DVA 1.0

;----------------------------------------------------------------------------
; DVASURFACEINFO structure
;----------------------------------------------------------------------------
DVASURFACEINFO  struc
  dvaBitmapInfo     db  40 dup(?)       ; BITMAPINFO of surface
  dvaMasks          dd  3 dup(?)        ; masks for BI_BITFIELDS
  dvaOffSurface     dd  ?               ; surface offset
  dvaSelSurface     dw  ?               ; surface selector
  dvaVersion        dw  ?               ; DVA Version
  dvaFlags          dd  ?               ; Flags
  dvaSurface        dd  ?               ; driver use.
  dvaOpenSurface    dd  ?               ; OpenSurface callback
  dvaCloseSurface   dd  ?               ; CloseSurface callback
  dvaBeginAccess    dd  ?               ; BeginAccess callback
  dvaEndAccess      dd  ?               ; EndAccess callback
  dvaShowSurface    dd  ?               ; ShowSurface callback
DVASURFACEINFO  ends

;----------------------------------------------------------------------------
; Definitions for DVASURFACEINFO.dvaFlags
;----------------------------------------------------------------------------

DVAF_1632_ACCESS    equ     0001h   ; must access using 16:32 pointers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\dvadib.c ===
/****************************************************************************

    DVA surface provider for Chicago DIBENG

 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "dibeng.inc"
#include "lockbm.h"

#define RP_TYPE     0x5250  // 'RP'

// stuff in DVAVGA.C
extern HDC  hdcScreen;
extern BOOL FAR PASCAL _loadds vga_open_surface(LPVOID pv);
extern void FAR PASCAL _loadds vga_close_surface(LPVOID pv);

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK dib_open_surface(LPVOID pv)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK dib_close_surface(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK dib_begin_access(LPVOID pv, int x, int y, int AccessDX, int AccessDY)
{
    //
    //  on some SVGAs with 8514 like accelerators, a command Que may need to
    //  be flushed before touching video memory.
    //
    //  mini drivers should not need this "handholding" but the S3 driver
    //  does
    //
    if (hdcScreen)
        GetPixel(hdcScreen, x, y);

    _asm {
        push    ds
;       push    si
;       push    di

	lds	bx,pv

	xor	ax,ax
        test    [bx].deFlags,DISABLED
	jnz	exit

        mov     cx,x
        mov     dx,y
        mov     si,cx
        add     si,AccessDX
        mov     di,y
        add     di,AccessDY
	call	dword ptr [bx].deCursorExclude
	mov	ax,1
exit:
;       pop     di
;       pop     si
        pop     ds
    }
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL dib_end_access(LPVOID pv)
{
    _asm {
	push	ds
	lds	bx,pv
	call	dword ptr [bx].deCursorUnexclude
	pop	ds
    }
}

/****************************************************************************
 ***************************************************************************/

BOOL dib_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    DIBENGINE FAR *pde;
    LPBITMAPINFOHEADER lpbi;

    if (nSurface != 0)
        return FALSE;

    pde = (DIBENGINE FAR *)GetPDevice(hdc);

    if (pde == NULL ||
        pde->deType != RP_TYPE ||
        pde->dePlanes != 1 ||
        pde->deVersion != 0x0400)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    hmemcpy(lpbi, pde->deBitmapInfo, sizeof(BITMAPINFOHEADER));

    if (lpbi->biCompression != 0 &&
        lpbi->biCompression != BI_BITFIELDS)
	return FALSE;

    pdva->selSurface   = pde->deBitsSelector;
    pdva->offSurface   = pde->deBitsOffset;
    pdva->Flags        = 0;
    pdva->Version      = 0x0100;
    pdva->lpSurface    = (LPVOID)pde;
    (FARPROC)pdva->OpenSurface  = (FARPROC)vga_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vga_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)dib_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)dib_end_access;
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    if (!(pde->deFlags & CURSOREXCLUDE))
    {
        pdva->BeginAccess = NULL;
        pdva->EndAccess   = NULL;
    }

    if (pde->deDeltaScan > 0)
    {
        lpbi->biWidth  = (int)pde->deDeltaScan * 8 / (int)pde->deBitsPixel;
        lpbi->biHeight =-(int)pde->deHeight;
        lpbi->biSizeImage = pde->deDeltaScan * pde->deHeight;
    }
    else
    {
        lpbi->biWidth  = -(int)pde->deDeltaScan * 8 / (int)pde->deBitsPixel;
        lpbi->biHeight =  (int)pde->deHeight;
        lpbi->biSizeImage = -(int)pde->deDeltaScan * pde->deHeight;

	pdva->offSurface += (long)pde->deDeltaScan * (long)pde->deHeight-1;
    }

    //
    // mark the surface as 16:32 pointer access ONLY!
    //
    if (pde->deFlags & BANKEDVRAM)
	pdva->Flags |= DVAF_1632_ACCESS;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\dvavga.c ===
/****************************************************************************

    DVA surface provider for SVGA card, using dva.386

 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "lockbm.h"

extern UINT PASCAL __A000h;
#define A000h   (WORD)(&__A000h)

// stuff in VFlat.asm
//
extern LPVOID NEAR PASCAL VFlatInit(void);
extern void   NEAR PASCAL VFlatBegin(void);
extern void   NEAR PASCAL VFlatEnd(void);

#define GETAPI(mod, api) GetProcAddress(GetModuleHandle(mod),MAKEINTATOM(api))

static HCURSOR hcur;
static FARPROC CheckCursor;
       HDC     hdcScreen;
static int     open_count;

static BOOL (FAR PASCAL *XIsWinoldAppTask)(HTASK hTask);

#define IsWinoldAppTask XIsWinoldAppTask

/****************************************************************************
 ***************************************************************************/

BOOL FAR PASCAL _loadds vga_open_surface(LPVOID pv)
{
    if (open_count++ == 0)
    {
        (FARPROC)CheckCursor = GETAPI("DISPLAY", MAKEINTATOM(104));
        (FARPROC)XIsWinoldAppTask = GETAPI("KERNEL", MAKEINTATOM(158));

        hdcScreen = CreateDC("DISPLAY", NULL, NULL, NULL);
    }

    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL _loadds vga_close_surface(LPVOID pv)
{
    if (open_count && --open_count == 0)
    {
        DeleteDC(hdcScreen);
        hdcScreen = NULL;
    }
}

/****************************************************************************
 ***************************************************************************/

BOOL FAR PASCAL _loadds vga_begin_access(LPVOID pv, int x, int y, int dx, int dy)
{
    RECT rc;
    POINT pt;
    HWND  hwndA;

    //
    //  if windows is in the background dont draw to the screen.
    //
    hwndA = GetActiveWindow();
    if (IsWinoldAppTask(GetWindowTask(hwndA)) && IsIconic(hwndA))
        return FALSE;

    //
    //  on some SVGAs with 8514 like accelerators, a command Que may need to
    //  be flushed before touching video memory.
    //
    if (hdcScreen)
        GetPixel(hdcScreen, x, y);

//!!! we realy should hook the mouse callback.

    GetCursorPos(&pt);

    #define CUR 40

    if ((pt.x >= x-CUR && pt.x <= x+dx+CUR) &&
        (pt.y >= y-CUR && pt.y <= y+dy+CUR))
    {
        hcur = SetCursor(NULL);
    }
    else
    {
        hcur = NULL;

        rc.left = pt.x;
        rc.top = pt.y;
        rc.right = pt.x+1;
        rc.bottom = pt.y+1;

        ClipCursor(&rc);
    }

    if (CheckCursor)
        CheckCursor();

    VFlatBegin();
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL _loadds vga_end_access(LPVOID pv)
{
    VFlatEnd();

    if (hcur)
        SetCursor(hcur);
    else
        ClipCursor(NULL);
}

/****************************************************************************
 ***************************************************************************/

BOOL vga_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    LPBITMAPINFOHEADER lpbi;
    int BitDepth;
    LPVOID lpScreen=NULL;
    IBITMAP FAR *pbm;

    if (nSurface != 0)
        return FALSE;

    BitDepth = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);

    if (BitDepth < 8)       // forget VGA or mono.
        return FALSE;

    pbm = GetPDevice(hdc);

    if (pbm == NULL || pbm->bmType == 0)
        return FALSE;

    if (HIWORD(pbm->bmBits) != A000h)
        return FALSE;

    lpScreen = VFlatInit();

    if (lpScreen == NULL)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    lpbi->biSize           = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth          = pbm->bmWidthBytes*8/pbm->bmBitsPixel;
    lpbi->biHeight         = -(int)pbm->bmHeight;
    lpbi->biPlanes         = pbm->bmPlanes;
    lpbi->biBitCount       = pbm->bmBitsPixel;
    lpbi->biCompression    = 0;
    lpbi->biSizeImage      = (DWORD)pbm->bmWidthBytes * (DWORD)pbm->bmHeight;
    lpbi->biXPelsPerMeter  = pbm->bmWidthBytes;
    lpbi->biYPelsPerMeter  = 0;
    lpbi->biClrUsed        = 0;
    lpbi->biClrImportant   = 0;

    pdva->selSurface   = SELECTOROF(lpScreen);
    pdva->offSurface   = OFFSETOF(lpScreen);
    pdva->Version      = 0x0100;
    pdva->Flags        = DVAF_1632_ACCESS;
    pdva->lpSurface    = (LPVOID)(DWORD)pbm->bmHeight;
    (FARPROC)pdva->OpenSurface  = (FARPROC)vga_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vga_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)vga_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)vga_end_access;
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\dvathun.c ===
/****************************************************************************
 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "lockbm.h"

extern BOOL FAR PASCAL _loadds vga_open_surface(LPVOID pv);
extern void FAR PASCAL _loadds vga_close_surface(LPVOID pv);
extern BOOL FAR PASCAL _loadds vga_begin_access(LPVOID pv, int x, int y, int dx, int dy);
extern void FAR PASCAL _loadds vga_end_access(LPVOID pv);

/****************************************************************************
 ***************************************************************************/

BOOL thun_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    DWORD SizeImage;
    IBITMAP FAR *pbm;
    UINT sel;
    DWORD off;
    LPBITMAPINFOHEADER lpbi;

    if (nSurface != 0)
        return FALSE;

    pbm = GetPDevice(hdc);

    if (pbm == NULL || pbm->bmType == 0)
        return FALSE;

    if (pbm->bmType != 0xFFFF)
        return FALSE;

    sel = ((WORD FAR *)&pbm->bmBits)[1];
    off = ((WORD FAR *)&pbm->bmBits)[0];

    SizeImage = (DWORD)(UINT)pbm->bmWidthBytes * (DWORD)(UINT)pbm->bmHeight;

    if (GetSelectorLimit(sel) != 0x3FFFFF)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    lpbi->biSize            = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth           = pbm->bmWidthBytes/(pbm->bmBitsPixel/8);
    lpbi->biHeight          = -(int)pbm->bmHeight;
    lpbi->biPlanes          = pbm->bmPlanes;
    lpbi->biBitCount        = pbm->bmBitsPixel;
    lpbi->biCompression     = 0;
    lpbi->biSizeImage       = SizeImage;
    lpbi->biXPelsPerMeter   = pbm->bmWidthBytes;
    lpbi->biYPelsPerMeter   = 0;
    lpbi->biClrUsed         = 0;
    lpbi->biClrImportant    = 0;

    pdva->selSurface   = sel;
    pdva->offSurface   = off;
    pdva->Version      = 0x0100;
    pdva->Flags        = 0;
    pdva->lpSurface    = 0;
    (FARPROC)pdva->OpenSurface  = (FARPROC)vga_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vga_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)vga_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)vga_end_access;
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\dvavlb.c ===
/****************************************************************************

    DVA surface provider for a Viper VLB card.

    assumes a linear frame buffer

    assumes a hardware cursor

 ***************************************************************************/

#include <windows.h>
#include "dva.h"
#include "lockbm.h"

extern NEAR PASCAL DetectViper(void);

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK vlb_open_surface(LPVOID pv)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK vlb_close_surface(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK vlb_begin_access(LPVOID pv, int x, int y, int dx, int dy)
{
    //
    // VIPER has a HW cursor so we dont do anything
    // !!!we may need to check for the sysVM in background
    //
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK vlb_end_access(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL vlb_get_surface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    DWORD SizeImage;
    IBITMAP FAR *pbm;
    UINT sel;
    DWORD off;
    LPBITMAPINFOHEADER lpbi;

    if (nSurface != 0)
        return FALSE;

    pbm = GetPDevice(hdc);

    if (pbm == NULL || pbm->bmType == 0)
        return FALSE;

//  if (pbm->bmType != 0x2000)
//      return FALSE;

    if (!DetectViper())
        return FALSE;

    sel = ((WORD FAR *)&pbm->bmBits)[1];
    off = ((WORD FAR *)&pbm->bmBits)[0];

    SizeImage = (DWORD)(UINT)pbm->bmWidthBytes * (DWORD)(UINT)pbm->bmHeight;

    if (GetSelectorLimit(sel) != 0x1FFFFF)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    lpbi->biSize            = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth           = pbm->bmWidthBytes*8/pbm->bmBitsPixel;
    lpbi->biHeight          = -(int)pbm->bmHeight;
    lpbi->biPlanes          = pbm->bmPlanes;
    lpbi->biBitCount        = pbm->bmBitsPixel;
    lpbi->biCompression     = 0;
    lpbi->biSizeImage       = SizeImage;
    lpbi->biXPelsPerMeter   = pbm->bmWidthBytes;
    lpbi->biYPelsPerMeter   = 0;
    lpbi->biClrUsed         = 0;
    lpbi->biClrImportant    = 0;

    pdva->selSurface   = sel;
    pdva->offSurface   = off;
    pdva->Version      = 0x0100;
    pdva->Flags        = 0;
    pdva->lpSurface    = 0;
    (FARPROC)pdva->OpenSurface  = (FARPROC)vlb_open_surface;
    (FARPROC)pdva->CloseSurface = (FARPROC)vlb_close_surface;
    (FARPROC)pdva->BeginAccess  = (FARPROC)vlb_begin_access;
    (FARPROC)pdva->EndAccess    = (FARPROC)vlb_end_access;
    (FARPROC)pdva->ShowSurface  = (FARPROC)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\lockbm.h ===
#define BM_NULL         0
#define BM_TYPE         0x0F        // type mask
#define BM_8BIT         0x01        // all SVGA, and other 256 color
#define BM_16555        0x02        // some HiDAC cards
#define BM_24BGR        0x03        // just like a DIB
#define BM_32BGR        0x04        // 32 bit BGR
#define BM_VGA          0x05        // VGA style bitmap.
#define BM_16565        0x06        // most HiDAC cards
#define BM_24RGB        0x07        // 24 bit RGB
#define BM_32RGB        0x08        // 32 bit RGB
#define BM_1BIT         0x09        // mono bitmap
#define BM_4BIT         0x0A        // 4 bit packed pixel.

#define BM_CANLOCK      0x10        // can lock these bitmaps
#define BM_MAPFLAT      0x20        // can make bitmaps flat
#define BM_HUGE         0x40        // with FillBytes != 0 (for > 64k)
#define BM_BOTTOMTOTOP  0x80        // like a DIB

//
//  this is a physical BITMAP in memory, this is just like a  BITMAP
//  structure, but with extra fields staring at bmWidthPlanes
//
typedef struct {
    short  bmType;
    short  bmWidth;
    short  bmHeight;
    short  bmWidthBytes;
    BYTE   bmPlanes;
    BYTE   bmBitsPixel;
    LPVOID bmBits;
    long   bmWidthPlanes;
    long   bmlpPDevice;
    short  bmSegmentIndex;
    short  bmScanSegment;
    short  bmFillBytes;
    short  reserved1;
    short  reserved2;
} IBITMAP;

#define bmBitmapInfo bmWidthPlanes
#define bmOffset     bmlpPDevice
#define bmNextScan   reserved1

BOOL   FAR CanLockBitmaps(void);
UINT   FAR GetBitmapType(void);
LPVOID FAR LockBitmap(HBITMAP hbm);
LPVOID FAR GetBitmap(HBITMAP hbm, LPVOID p, int cb);
LPVOID FAR GetBitmapDIB(LPBITMAPINFOHEADER lpbi, LPVOID lpBits, LPVOID p, int cb);
LPVOID FAR GetDIBBitmap(HBITMAP hbm, LPBITMAPINFOHEADER lpbi);
LPVOID FAR GetPDevice(HDC hdc);
void   FAR TestSurfaceType(HDC hdc, int x, int y);
UINT   FAR GetSurfaceType(LPVOID lpBits);

BOOL   FAR MakeBitmapFlat(HBITMAP hbm);

//void   FAR BitmapXY(IBITMAP FAR *pbm, int x, int y);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\dva.c ===
#include <windows.h>

#define _INC_VFW
#define VFWAPI FAR PASCAL _loadds

#include "dva.h"
#include "lockbm.h"

/****************************************************************************
 ***************************************************************************/

extern BOOL vga_get_surface(HDC, int, DVASURFACEINFO FAR *);
extern BOOL ati_get_surface(HDC, int, DVASURFACEINFO FAR *);
extern BOOL dib_get_surface(HDC, int, DVASURFACEINFO FAR *);
extern BOOL thun_get_surface(HDC,int, DVASURFACEINFO FAR *);
extern BOOL vlb_get_surface(HDC, int, DVASURFACEINFO FAR *);

#define GetDS() SELECTOROF((LPVOID)&ScreenSel)
static short ScreenSel;

static BOOL InitSurface(DVASURFACEINFO FAR *pdva);
static BOOL TestSurface(DVASURFACEINFO FAR *pdva);
static void SetSelLimit(UINT sel, DWORD limit);

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL DVAInit()
{
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL DVATerm()
{
    //
    // free screen alias
    //
    if (ScreenSel)
    {
        SetSelLimit(ScreenSel, 0);
        FreeSelector(ScreenSel);
        ScreenSel = 0;
    }
}

/****************************************************************************
 ***************************************************************************/

BOOL FAR PASCAL _loadds DVAGetSurface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    int i;

#ifdef USESTUPIDESCAPE
    i = Escape(hdc, DVAGETSURFACE,sizeof(int),(LPCSTR)&nSurface,(LPVOID)pdva);
#else
    i = 0;
#endif
    
    //
    // should this be a function table? list?
    //
    if (i <= 0 &&
#ifdef BADDIBENGINESTUFF
        !dib_get_surface(hdc, nSurface, pdva) &&
#endif  
	!ati_get_surface(hdc, nSurface, pdva) &&
#ifdef DEBUG
        !vlb_get_surface(hdc, nSurface, pdva) &&
        !thun_get_surface(hdc, nSurface, pdva) &&
#endif
        !vga_get_surface(hdc, nSurface, pdva))

        return FALSE;

    return InitSurface(pdva);
}

#if 0

/****************************************************************************
 ***************************************************************************/

HDVA FAR PASCAL DVAOpenSurface(HDC hdc, int nSurface)
{
    PDVA pdva;

    pdva = (PDVA)GlobalAllocPtr(GHND|GMEM_SHARE, sizeof(DVASURFACEINFO));

    if (pdva == NULL)
        return NULL;

    if (!DVAGetSurface(hdc, nSurface, pdva) ||
        !pdva->OpenSurface(pdva->lpSurface))
    {
        GlobalFreePtr(pdva);
        return NULL;
    }

    return pdva;
}

/****************************************************************************
 ***************************************************************************/

void FAR PASCAL DVACloseSurface(HDVA pdva)
{
    if (pdva == NULL)
        return;

    pdva->CloseSurface(pdva->lpSurface);

    GlobalFreePtr(pdva);
}

#endif

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK default_open_surface(LPVOID pv)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK default_close_surface(LPVOID pv)
{
}

/****************************************************************************
 ***************************************************************************/

BOOL CALLBACK default_begin_access(LPVOID pv, int x, int y, int dx, int dy)
{
    return TRUE;
}

/****************************************************************************
 ***************************************************************************/

void CALLBACK default_end_access(LPVOID pv)
{
}


/****************************************************************************
 ***************************************************************************/

UINT CALLBACK default_show_surface(LPVOID pv, HWND hwnd, LPRECT src, LPRECT dst)
{
    return 1;
}

/****************************************************************************
 ***************************************************************************/

static BOOL InitSurface(DVASURFACEINFO FAR *pdva)
{
    LPBITMAPINFOHEADER lpbi;

    if (pdva->Version != 0x0100)
        return FALSE;

    lpbi = &pdva->BitmapInfo;

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
        return FALSE;

    if (lpbi->biPlanes != 1)
        return FALSE;

    //
    // make the pointer a 16:16 pointer
    //
    if (pdva->offSurface >= 0x10000 &&
        !(pdva->Flags & DVAF_1632_ACCESS))
    {
        if (ScreenSel == NULL)
            ScreenSel = AllocSelector(GetDS());

        if (pdva->selSurface != 0)
            pdva->offSurface += GetSelectorBase(pdva->selSurface);

        SetSelectorBase(ScreenSel,pdva->offSurface);
        SetSelLimit(ScreenSel,lpbi->biSizeImage-1);

        pdva->offSurface = 0;
        pdva->selSurface = ScreenSel;
    }

    //
    // fill in defaults.
    //
    if (pdva->OpenSurface == NULL)
        pdva->OpenSurface = default_open_surface;

    if (pdva->CloseSurface == NULL)
        pdva->CloseSurface = default_close_surface;

    if (pdva->ShowSurface == NULL)
        pdva->ShowSurface = default_show_surface;

    if (pdva->BeginAccess == NULL)
    {
        pdva->BeginAccess = default_begin_access;
        pdva->EndAccess   = default_end_access;
    }

    //
    // only test RGB surfaces.
    //
    if (lpbi->biCompression == 0 ||
        lpbi->biCompression == BI_BITFIELDS ||
        lpbi->biCompression == BI_1632)
    {
        if (!TestSurface(pdva))
            return FALSE;
    }

    //
    // set BI_1632 if needed
    //
    if (pdva->Flags & DVAF_1632_ACCESS)
    {
        lpbi->biCompression = BI_1632;
    }

    return TRUE;
}

/****************************************************************************
 ***************************************************************************/
#pragma optimize("", off)
static void SetSelLimit(UINT sel, DWORD limit)
{
    if (limit >= 1024*1024l)
        limit = ((limit+4096) & ~4095) - 1;

    _asm
    {
        mov     ax,0008h            ; DPMI set limit
        mov     bx,sel
        mov     dx,word ptr limit[0]
        mov     cx,word ptr limit[2]
        int     31h
    }
}
#pragma optimize("", on)

/****************************************************************************
 ***************************************************************************/

#define ASM66 _asm _emit 0x66 _asm
#define DB    _asm _emit

#pragma optimize("", off)
static BYTE ReadByte(PDVA pdva, LPVOID lpBits, DWORD dw)
{
    BYTE b=42;

    DVABeginAccess(pdva, 0, 0, 1024, 1024);

    _asm {
        ASM66   xor     bx,bx
                les     bx,lpBits
        ASM66   add     bx,word ptr dw
                mov     ax,es
        ASM66   lsl     ax,ax
        ASM66   cmp     bx,ax
                ja      exit
        DB 26h ;mov     al,es:[ebx]
        DB 67h
        DB 8Ah
        DB 03h
                mov b,al
exit:
    }

    DVAEndAccess(pdva);

    return b;
}
#pragma optimize("", on)

/////////////////////////////////////////////////////////////////////////////
//
//  SetPixel
//
//  some cards cant't seam to do SetPixel right it is amazing they work at all
//
/////////////////////////////////////////////////////////////////////////////

static void SetPixelX(HDC hdc, int x, int y, COLORREF rgb)
{
    RECT rc;

    rc.left = x;
    rc.top  = y;
    rc.right = x+1;
    rc.bottom = y+1;

    SetBkColor(hdc, rgb);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}

#define SetPixel SetPixelX

/****************************************************************************
 ***************************************************************************/

static BOOL TestSurface(DVASURFACEINFO FAR *pdva)
{
    HDC hdc;
    int x,y,h,w,wb;
    COLORREF rgb,rgb0,rgb1,rgb2,rgb3,rgb4;
    DWORD dw;
    BYTE  b0,b1;
    UINT  uType=0;
    LPBITMAPINFOHEADER lpbi;
    LPVOID lpBits;
    HCURSOR hcur;

    if (!pdva->OpenSurface(pdva->lpSurface))
        return FALSE;

    lpbi = DVAGetSurfaceFmt(pdva);
    lpBits = DVAGetSurfacePtr(pdva);

    h = abs((int)lpbi->biHeight);
    w = (int)lpbi->biWidth;
    wb = (w * ((UINT)lpbi->biBitCount/8) + 3) & ~3;
    dw = (DWORD)(UINT)(h-1) * (DWORD)(UINT)wb;

    if ((int)lpbi->biHeight < 0)
        y = 0;
    else
        y = h-1;

#ifdef XDEBUG
    x = (int)lpbi->biWidth - 5;
    ((LPBYTE)lpBits) += x * (UINT)lpbi->biBitCount/8;
#else
    x = 0;
#endif

    hcur = SetCursor(NULL);
    hdc = GetDC(NULL);

    rgb = GetPixel(hdc, x, h-1-y);
    SetPixel(hdc, x, h-1-y, RGB(0,0,0));       GetPixel(hdc, x, h-1-y); b0 = ReadByte(pdva, lpBits, dw);
    SetPixel(hdc, x, h-1-y, RGB(255,255,255)); GetPixel(hdc, x, h-1-y); b1 = ReadByte(pdva, lpBits, dw);
    SetPixel(hdc, x, h-1-y,rgb);

    if (b0 != 0x00 || b1 == 0x00)
        goto done;

    rgb0 = GetPixel(hdc, x+0, y);
    rgb1 = GetPixel(hdc, x+1, y);
    rgb2 = GetPixel(hdc, x+2, y);
    rgb3 = GetPixel(hdc, x+3, y);
    rgb4 = GetPixel(hdc, x+4, y);

    TestSurfaceType(hdc, x, y);

    DVABeginAccess(pdva, x, y, 5, 1);
    uType = GetSurfaceType(lpBits);
    DVAEndAccess(pdva);

    SetPixel(hdc, x+0, y,rgb0);
    SetPixel(hdc, x+1, y,rgb1);
    SetPixel(hdc, x+2, y,rgb2);
    SetPixel(hdc, x+3, y,rgb3);
    SetPixel(hdc, x+4, y,rgb4);

done:
    ReleaseDC(NULL, hdc);
    SetCursor(hcur);

    pdva->CloseSurface(pdva->lpSurface);

    switch (uType)
    {
        case BM_8BIT:
            break;

        case BM_16555:
            ((LPDWORD)(lpbi+1))[0] = 0x007C00;
            ((LPDWORD)(lpbi+1))[1] = 0x0003E0;
            ((LPDWORD)(lpbi+1))[2] = 0x00001F;
            break;

        case BM_24BGR:
        case BM_32BGR:
            ((LPDWORD)(lpbi+1))[0] = 0xFF0000;
            ((LPDWORD)(lpbi+1))[1] = 0x00FF00;
            ((LPDWORD)(lpbi+1))[2] = 0x0000FF;
            break;

        case BM_16565:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x00F800;
            ((LPDWORD)(lpbi+1))[1] = 0x0007E0;
            ((LPDWORD)(lpbi+1))[2] = 0x00001F;
            break;

        case BM_24RGB:
        case BM_32RGB:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x0000FF;
            ((LPDWORD)(lpbi+1))[1] = 0x00FF00;
            ((LPDWORD)(lpbi+1))[2] = 0xFF0000;
            break;
    }

    return uType != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\dibeng.inc ===
;/*
;----------------------------------------------------------------------------
; DIBENG.INC
; Copyright (c) 1992 Microsoft Corporation
;
; Dib Engine Interface Definitions
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; General Comments:
; The DIB Engine is non-palettized from GDI's perspective.  When an app
; selects a DIB into a memory DC, GDI will create a DIB Engine PDevice 
; (see definition below) and will stuff in a 'DI' in the deType field.
; Subsequent operations on this DC will result in calls to the DIB Engine
; with this PDevice.  
; Device drivers can also use the DIB Engine to handle most, if not all,
; of their rendering work.  A device driver exports the DIB Engine PDevice
; as it's own PDevice to GDI.  This PDevice contains a pointer to a 
; BitmapInfo header in the driver's data segment. Immediately following
; this is an optional color table for devices less than 16 bpp.
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
; E Q U A T E S
;----------------------------------------------------------------------------
BRUSHSIZE	equ	8		;height and width in pixels.
VER_DIBENG      equ     400h            ;version = 4.0
comment ~
*/
#define BRUSHSIZE       8
#define VER_DIBENG      0x400
/*
end comment ~
;----------------------------------------------------------------------------
; S T R U C T U R E S
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PDevice Structure for the DIB Engine.  deType will contain 'DI' when GDI
; calls the DIB Engine to perform graphics operations on the dib.  deType 
; will contain a 0 or a Selector if a mini-driver is calling the DIB Engine 
; to do graphics operations. 
;----------------------------------------------------------------------------
DIBENGINE	    struc						      ;*/ typedef struct {                        /*
  deType	    dw	?		; contains 'DI', 0 or ScreenSelector  ;*/ WORD         deType;                    /*
  deWidth	    dw	?		; Width of dib in pixels	      ;*/ WORD         deWidth;                   /*
  deHeight	    dw	?		; Height of dib in pixels	      ;*/ WORD         deHeight;                  /*
  deWidthBytes	    dw	?		; #bytes per scan line		      ;*/ WORD         deWidthBytes;              /*
  dePlanes	    db	?		; # of planes in bitmap 	      ;*/ BYTE         dePlanes;                  /*
  deBitsPixel	    db	?		; # of bits per pixel		      ;*/ BYTE         deBitsPixel;               /*
  deReserved1	    dd	?		; cannot be used.		      ;*/ DWORD        deReserved1;               /*
  deDeltaScan       dd  ?               ; + or -. Displacement to next scan.  ;*/ DWORD        deDeltaScan;               /*
  delpPDevice	    dd	?		; Pointer to associated PDevice       ;*/ LPBYTE       delpPDevice;               /*
  deBits	    df	?		; fword offset to bits of dib	      ;*/ DWORD        deBitsOffset;              /*
                                        ;                                     ;*/ WORD         deBitsSelector;            /*
  deFlags	    dw	?		; additional flags		      ;*/ WORD         deFlags;                   /*
  deVersion	    dw  ?		; lsb=minor, msb=major (0400h = 4.0)  ;*/ WORD         deVersion;                 /*
  deBitmapInfo	    dd	?		; pointer to the bitmapinfo header    ;*/ LPBITMAPINFO deBitmapInfo;              /*
  deCursorExclude   dd	?		; Cursor Exclude call back	      ;*/ void         (FAR *deCursorExclude)();  /*
  deCursorUnexclude dd	?		; Cursor Unexclude call back	      ;*/ void         (FAR *deCursorUnexclude)();/*
  deReserved2	    dd  ?		; Reserved.                           ;*/ DWORD        deReserved2;               /*
DIBENGINE	    ends		                                      ;*/ } DIBENGINE, FAR *LPDIBENGINE;          /*
;----------------------------------------------------------------------------
; Definitions for DIBEngine.deFlags
;----------------------------------------------------------------------------
MINIDRIVER   	equ     0000000000000001b
PALETTIZED   	equ     0000000000000010b				      
SELECTEDDIB  	equ     0000000000000100b				      
CURSOREXCLUDE	equ     0000000000001000b                                      
DISABLED        equ     0000000000010000b
VRAM		equ     1000000000000000b                                      
BANKEDVRAM	equ     0100000000000000b                                      
BANKEDSCAN	equ     0010000000000000b                                      
comment ~
*/
#define MINIDRIVER      0x0001	  
#define PALETTIZED      0x0002	  
#define SELECTEDDIB     0x0004	  
#define CURSOREXCLUDE   0x0008	  
#define DISABLED        0x0010	  
#define VRAM            0x8000	  
#define BANKEDVRAM      0x4000	  
#define BANKEDSCAN      0x2000
/*
end comment ~
;----------------------------------------------------------------------------
; Definitions for most significant byte of a physical color.
;----------------------------------------------------------------------------
MONO_BIT	equ	00000001b	;0=Black, 1=White                     
PHYS_BIT	equ	10000000b	;1=physical color, 0=logical color    
GREY_BIT        equ     01000000b       ;color is grey (r=g=b)
comment ~
*/
#define MONO_BIT        0x01	  
#define PHYS_BIT        0x80	  
#define GREY_BIT        0x40	  
/*
end comment ~
;----------------------------------------------------------------------------
; DIB Engine Color Table entry structure. This structure is used by device
; drivers that are using DIB Engine services for rendering.  This structure
; is identical to the RGBQuad structure except for some bit definitions
; in the 4th byte.
;----------------------------------------------------------------------------
DIBColorEntry	struc							      ;*/ typedef struct {		  /*
  dceBlue	    db	?                                                     ;*/ BYTE dceBlue;	                  /*
  dceGreen	    db	?                                                     ;*/ BYTE dceGreen;                  /*
  dceRed	    db	?                                                     ;*/ BYTE dceRed;	                  /*
  dceFlags          db  ?                                                     ;*/ BYTE dceFlags;                  /*
DIBColorEntry	ends                                                          ;*/ } DIBColorEntry;                /*
;----------------------------------------------------------------------------
; Definitions for DIBColorEntry.dceFlags
;----------------------------------------------------------------------------
NONSTATIC	equ	10000000b      ;Inhibits color matching to this entry.
MAPTOWHITE	equ	00000001b      ;0=Black, 1=White
comment ~
*/
#define NONSTATIC       0x80	  
#define MAPTOWHITE      0x01	  
/*
end comment ~
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; DIB Engine Physical Object Definitions
;----------------------------------------------------------------------------

DIB_Pen	struc                                                                 ;*/ typedef struct {                /*  
dpPenStyle	dw	?                                                     ;*/ WORD  dpPenStyle;               /*  
dpPenFlags	db	?		;currently none undefined.            ;*/ BYTE  dpPenFlags;               /*
dpPenBpp	db	?	                                              ;*/ BYTE  dpPenBpp;                 /*
dpPenMono	dd	?                                                     ;*/ DWORD dpPenMono;                /*
dpPenColor	dd	?                                                     ;*/ DWORD dpPenColor;               /*
DIB_Pen	ends                                                                  ;*/ } DIB_Pen;                      /*

DIB_Brush1	struc                                                         ;*/ typedef struct {                /*  
dp1BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp1BrushFlags;            /*
dp1BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp1BrushBpp;              /*
dp1BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp1BrushStyle;            /*
dp1FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp1FgColor;               /*
dp1Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp1Hatch;                 /*
dp1BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp1BgColor;               /*
dp1BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp1BrushMono [BRUSHSIZE*4];/*
dp1BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp1BrushMask [BRUSHSIZE*4];/*
dp1BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 1 bit/pixel ;*/ BYTE dp1BrushBits [BRUSHSIZE*4];/* 
DIB_Brush1	ends                                                          ;*/ } DIB_Brush1;                   /*  

DIB_Brush4	struc                                                         ;*/ typedef struct {                /*  
dp4BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp4BrushFlags;            /*
dp4BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp4BrushBpp;              /*
dp4BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp4BrushStyle;            /*
dp4FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp4FgColor;               /*
dp4Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp4Hatch;                 /*
dp4BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp4BgColor;               /*
dp4BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp4BrushMono [BRUSHSIZE*4];/*
dp4BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp4BrushMask [BRUSHSIZE*4];/*
dp4BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 4 bit/pixel ;*/ BYTE dp4BrushBits [BRUSHSIZE*4];/* 
DIB_Brush4	ends                                                          ;*/ } DIB_Brush4;                   /*  

DIB_Brush8	struc                                                         ;*/ typedef struct {                /*  
dp8BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp8BrushFlags;            /*
dp8BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp8BrushBpp;              /*
dp8BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp8BrushStyle;            /*
dp8FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp8FgColor;               /*
dp8Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp8Hatch;                 /*
dp8BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp8BgColor;               /*
dp8BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp8BrushMono [BRUSHSIZE*4];/*
dp8BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp8BrushMask [BRUSHSIZE*4];/*
dp8BrushBits	db	BRUSHSIZE*8 dup (?) ;8 rows,8 columns of 8 bit/pixel  ;*/ BYTE dp8BrushBits [BRUSHSIZE*8];/* 
DIB_Brush8	ends                                                          ;*/ } DIB_Brush8;                   /*  

DIB_Brush16	struc                                                         ;*/ typedef struct {                /*  
dp16BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp16BrushFlags;            /*
dp16BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp16BrushBpp;              /*
dp16BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp16BrushStyle;            /*
dp16FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp16FgColor;               /*
dp16Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp16Hatch;                 /*
dp16BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp16BgColor;               /*
dp16BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp16BrushMono [BRUSHSIZE*4];/*
dp16BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp16BrushMask [BRUSHSIZE*4];/*
dp16BrushBits	db	BRUSHSIZE*16 dup (?);8 rows,8 columns of 16 bit/pixel;*/ BYTE dp16BrushBits [BRUSHSIZE*16];/* 
DIB_Brush16	ends                                                          ;*/ } DIB_Brush16;                   /*  

DIB_Brush24	struc                                                         ;*/ typedef struct {                /*  
dp24BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp24BrushFlags;            /*
dp24BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp24BrushBpp;              /*
dp24BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp24BrushStyle;            /*
dp24FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp24FgColor;               /*
dp24Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp24Hatch;                 /*
dp24BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp24BgColor;               /*
dp24BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp24BrushMono [BRUSHSIZE*4];/*
dp24BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp24BrushMask [BRUSHSIZE*4];/*
dp24BrushBits	db	BRUSHSIZE*24 dup (?);8 rows,8 columns of 24 bit/pixel ;*/ BYTE dp24BrushBits [BRUSHSIZE*24];/* 
DIB_Brush24	ends                                                          ;*/ } DIB_Brush24;                   /*  

DIB_Brush32	struc                                                         ;*/ typedef struct {                /*  
dp32BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp32BrushFlags;            /*
dp32BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp32BrushBpp;              /*
dp32BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp32BrushStyle;            /*
dp32FgColor	dd	?		    ;Logical fg color                 ;*/ DWORD dp32FgColor;               /*
dp32Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp32Hatch;                 /*
dp32BgColor	dd	?		    ;Logical bg color                 ;*/ DWORD dp32BgColor;               /*
dp32BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp32BrushMono [BRUSHSIZE*4];/*
dp32BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp32BrushMask [BRUSHSIZE*4];/*
dp32BrushBits	db	BRUSHSIZE*32 dup (?);8 rows,8 columns of 32 bit/pixel ;*/ BYTE dp32BrushBits [BRUSHSIZE*32];/* 
DIB_Brush32	ends                                                          ;*/ } DIB_Brush32;                   /*  

;----------------------------------------------------------------------------
; Definitions for DIB_Brushxx.dpxxBrushFlags
;----------------------------------------------------------------------------                                      
COLORSOLID     equ      00000001b ;Color part is solid.                        
MONOSOLID      equ      00000010b ;Mono part is solid.                         
PATTERNMONO    equ      00000100b ;Pattern brush came from a mono bitmap.      
MONOVALID      equ      00001000b ;Mono part is valid.                         
MASKVALID      equ      00010000b ;Transparency Mask part is valid.
comment ~
*/
#define  COLORSOLID     0x01         
#define  MONOSOLID      0x02         
#define  PATTERNMONO    0x04         
#define  MONOVALID      0x08         
#define  MASKVALID      0x10
/*
end comment ~
;----------------------------------------------------------------------------
; M A C R O S
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; Cycle24 i
;
; This macro cycle a replicated 24 bit color in register eax, 'i' times.
; If 'i' is blank, the cycle is done one time, else it is done twice
;----------------------------------------------------------------------------
Cycle24 macro i

ifb <i>                                 ;assume eax = 'brgb'
        mov     al,ah                   ;eax = 'brgg'
        ror     eax,8                   ;eax = 'gbrg'
else
        rol     eax,16                  ;eax = 'gbbr'
        mov     ah,al                   ;eax = 'gbrr'
        ror     eax,8                   ;eax = 'rgbr'
endif
        endm
;----------------------------------------------------------------------------
; ColorToMono
; Entry: red, green, blue
; Exit:  blue = intensity.
;----------------------------------------------------------------------------
ColorToMono	macro	red, green, blue
	add	blue,red		;R+B
        rcr     blue,1                  ;(R+B)/2
	add	blue,green		;pitch in Green
        rcr     blue,1                  ;G/2 + (R+B)/4
endm	ColorToMono

;----------------------------------------------------------------------------
; ColorToMonoBit
; Entry: red, green, blue
; Exit:  blue = 0 if color maps to black
;        blue = 1 if color maps to white
;----------------------------------------------------------------------------
ColorToMonoBit	macro	red, green, blue
	ColorToMono red,green,blue    ; Call ColorToMono to derive intensity.
	cmp	blue,127
	setnc	blue
endm ColorToMonoBit

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\dva.h ===
/****************************************************************************

 DVA.H

 Copyright (c) 1993 Microsoft Corporation

 DVA 1.0 Interface Definitions

 ***************************************************************************/

#ifndef _INC_DVA
#define _INC_DVA

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dvaddi.h"     // interface to the display driver

/****************************************************************************
 ***************************************************************************/

typedef DVASURFACEINFO FAR *PDVA;
typedef PDVA HDVA;

/****************************************************************************
 ***************************************************************************/

//
// this code in biCompression means the frame buffer must be accesed via
// 48 bit pointers! using *ONLY* the given selector
//
// BI_1632 has bitmasks (just like BI_BITFIELDS) for biBitCount == 16,24,32
//
#ifndef BI_1632
#define BI_1632  0x32333631     // '1632'
#endif

#ifndef BI_BITFIELDS
#define BI_BITFIELDS 3
#endif

/****************************************************************************
 ***************************************************************************/

#if defined(_INC_VFW) || defined(_INC_DRAWDIB)
//
//  this API is in MSVIDEO.DLL
//
BOOL VFWAPI DVAGetSurface(HDC hdc, int nSurface, DVASURFACEINFO FAR *lpSurfaceInfo);

#else

//
//  this API uses the Escape to the display driver only
//
__inline BOOL DVAGetSurface(HDC hdc, int nSurface, DVASURFACEINFO FAR *pdva)
{
    int i;

    i = Escape(hdc, DVAGETSURFACE,sizeof(int),(LPCSTR)&nSurface,(LPVOID)pdva);

    return i > 0;
}

#endif

/****************************************************************************
 ***************************************************************************/

__inline PDVA DVAOpenSurface(HDC hdc, int nSurface)
{
    PDVA pdva;

    pdva = (PDVA)GlobalLock(GlobalAlloc(GHND|GMEM_SHARE, sizeof(DVASURFACEINFO)));

    if (pdva == NULL)
        return NULL;

    if (!DVAGetSurface(hdc, nSurface, pdva) ||
        !pdva->OpenSurface(pdva->lpSurface))
    {
        GlobalFree((HGLOBAL)SELECTOROF(pdva));
        return NULL;
    }

    return pdva;
}

/****************************************************************************
 ***************************************************************************/

__inline void DVACloseSurface(PDVA pdva)
{
    if (pdva == NULL)
        return;

    pdva->CloseSurface(pdva->lpSurface);

    GlobalFree((HGLOBAL)SELECTOROF(pdva));
}

/****************************************************************************
 ***************************************************************************/

__inline BOOL DVABeginAccess(PDVA pdva, int x, int y, int dx, int dy)
{
    return pdva->BeginAccess(pdva->lpSurface, x, y, dx, dy);
}

/****************************************************************************
 ***************************************************************************/

__inline void DVAEndAccess(PDVA pdva)
{
    pdva->EndAccess(pdva->lpSurface);
}

/****************************************************************************
 ***************************************************************************/

__inline LPBITMAPINFOHEADER DVAGetSurfaceFmt(PDVA pdva)
{
    if (pdva == NULL)
        return NULL;

    return &pdva->BitmapInfo;
}

/****************************************************************************
 ***************************************************************************/

__inline LPVOID DVAGetSurfacePtr(PDVA pdva)
{
    if (pdva == NULL)
        return NULL;

    return (LPVOID)MAKELONG(pdva->offSurface, pdva->selSurface);
}

#ifdef __cplusplus
    }
#endif

#endif // _INC_DVA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\vflatd\vflatd.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988
;
;   Title:      VflatD.INC -
;
;   Version:	1.00
;
;   Date:	10-Aug-1988
;
;   Author:     LDS
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   10-Aug-1988 LDS Original
;
;==============================================================================

WIN31 equ 1                                 ; support Windows 3.1

VflatD_Chicago_ID   equ     011Fh           ; OEM #8 Device #31
VflatD_Windows_ID   equ     (0440h + 29d)   ; MMSYS OEM# device 30

if WIN31
VflatD_Device_ID    equ     VflatD_Windows_ID
else
VflatD_Device_ID    equ     VflatD_Chicago_ID
endif

VflatD_Version      equ (0100h + 50)        ;    1.50


VflatD_Get_Version  equ 0
VflatD_Get_Sel      equ 1
VflatD_Reset        equ 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\aviffmt.h ===
/****************************************************************************/
/*                                                                          */
/*        AVIFFMT.H - Include file for working with AVI files               */
/*                                                                          */
/*        Note: You must include WINDOWS.H and MMSYSTEM.H before            */
/*        including this file.                                              */
/*                                                                          */
/*        Copyright (c) 1991-1992, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

/*
 *
 * An AVI file is the following RIFF form:
 *
 *	RIFF('AVI' 
 *	      LIST('hdrl'
 *		    avih(<MainAVIHeader>)
 *                  LIST ('strl'
 *                      strh(<Stream header>)
 *                      strf(<Stream format>)
 *                      ... additional header data
 *            LIST('movi'	 
 *      	  { LIST('rec' 
 *      		      SubChunk...
 *      		   )
 *      	      | SubChunk } ....	    
 *            )
 *            [ <AVIIndex> ]
 *      )
 *
 *      The first two characters of each chunk are the track number.
 *      SubChunk = {  xxdh(<AVI DIB header>)
 *                  | xxdb(<AVI DIB bits>)
 *                  | xxdc(<AVI compressed DIB bits>)
 *                  | xxpc(<AVI Palette Change>)
 *                  | xxwb(<AVI WAVE bytes>)
 *                  | xxws(<AVI Silence record>)
 *                  | xxmd(<MIDI data>)
 *                  | additional custom chunks }
 *
 */
/*
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * We need a better description of the AVI file header here.
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *
 * The grouping into LIST 'rec' chunks implies only that the contents of
 *   the chunk should be read into memory at the same time.  This
 *   grouping is only necessary for interleaved files.
 *       
 * For loading efficiency, the beginning of each LIST 'rec' chunk may
 * be aligned on a 2K boundary.  (Actually, the beginning of the LIST
 * chunk should be 12 bytes before a 2K boundary, so that the data chunks
 * inside the LIST chunk are aligned.)
 *
 * If the AVI file is being played from CD-ROM in, it is recommended that
 * the file be padded.
 *
 * Limitations for the Alpha release:
 *	If the AVI file has audio, each record LIST must contain exactly
 *	one audio chunk, which must be the first chunk.
 *	Each record must contain exactly one video chunk (possibly preceded
 *	by one or more palette change chunks).
 *	No wave format or DIB header chunks may occur outside of the header.
 */

#ifndef _INC_AVIFFMT
#define _INC_AVIFFMT

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

/* Macro to make a TWOCC out of two characters */
#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

typedef WORD TWOCC;

/* form types, list types, and chunk types */
#define formtypeAVI             mmioFOURCC('A', 'V', 'I', ' ')
#define listtypeAVIHEADER       mmioFOURCC('h', 'd', 'r', 'l')
#define ckidAVIMAINHDR          mmioFOURCC('a', 'v', 'i', 'h')
#define listtypeSTREAMHEADER    mmioFOURCC('s', 't', 'r', 'l')
#define ckidSTREAMHEADER        mmioFOURCC('s', 't', 'r', 'h')
#define ckidSTREAMFORMAT        mmioFOURCC('s', 't', 'r', 'f')
#define ckidSTREAMHANDLERDATA   mmioFOURCC('s', 't', 'r', 'd')

#define listtypeAVIMOVIE        mmioFOURCC('m', 'o', 'v', 'i')
#define listtypeAVIRECORD       mmioFOURCC('r', 'e', 'c', ' ')

#define ckidAVINEWINDEX         mmioFOURCC('i', 'd', 'x', '1')

/*
** Here are some stream types.  Currently, only audio and video
** are supported.
*/
#define streamtypeVIDEO         mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO         mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI          mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT          mmioFOURCC('t', 'x', 't', 's')

/*
** Here are some compression types.
*/
#define comptypeRLE0            mmioFOURCC('R','L','E','0')
#define comptypeRLE             mmioFOURCC('R','L','E',' ')
#define comptypeDIB             mmioFOURCC('D','I','B',' ')

#define cktypeDIBbits           aviTWOCC('d', 'b')
#define cktypeDIBcompressed     aviTWOCC('d', 'c')
#define cktypeDIBhalf           aviTWOCC('d', 'x')
#define cktypePALchange         aviTWOCC('p', 'c')
#define cktypeWAVEbytes         aviTWOCC('w', 'b')
#define cktypeWAVEsilence       aviTWOCC('w', 's')

#define cktypeMIDIdata          aviTWOCC('m', 'd')

#define cktypeDIBheader         aviTWOCC('d', 'h')
#define cktypeWAVEformat        aviTWOCC('w', 'f')

#define ckidAVIPADDING          mmioFOURCC('J', 'U', 'N', 'K')
#define ckidOLDPADDING          mmioFOURCC('p', 'a', 'd', 'd')


/*
** Useful macros
*/
#define ToHex(n)	((BYTE) (((n) > 9) ? ((n) - 10 + 'A') : ((n) + '0')))
#define FromHex(n)	(((n) >= 'A') ? ((n) + 10 - 'A') : ((n) - '0'))

/* Macro to get stream number out of a FOURCC ckid */
#define StreamFromFOURCC(fcc) ((WORD) ((FromHex(LOBYTE(LOWORD(fcc))) << 4) + \
                                             (FromHex(HIBYTE(LOWORD(fcc))))))

/* Macro to get TWOCC chunk type out of a FOURCC ckid */
#define TWOCCFromFOURCC(fcc)    HIWORD(fcc)

/* Macro to make a ckid for a chunk out of a TWOCC and a stream number
** from 0-255.
**
** Warning: This is a nasty macro, and MS C 6.0 compiles it incorrectly
** if optimizations are on.  Ack.
*/
#define MAKEAVICKID(tcc, stream) \
        MAKELONG((ToHex((stream) & 0x0f) << 8) | ToHex(((stream) & 0xf0) >> 4), tcc)



/*
** Main AVI File Header 
*/	     
		     
/* flags for use in <dwFlags> in AVIFileHdr */
#define AVIF_HASINDEX		0x00000010	// Index at end of file?
#define AVIF_MUSTUSEINDEX	0x00000020
#define AVIF_ISINTERLEAVED	0x00000100
#define AVIF_VARIABLESIZEREC	0x00000200
#define AVIF_NOPADDING		0x00000400
#define AVIF_WASCAPTUREFILE	0x00010000
#define AVIF_COPYRIGHTED	0x00020000

/* The AVI File Header LIST chunk should be padded to this size */
#define AVI_HEADERSIZE  2048                    // size of AVI header list

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types MainAVIHeader | The <t MainAVIHeader> structure contains 
 *	global information for the entire AVI file.  It is contained 
 *	within an 'avih' chunk within the LIST 'hdrl' chunk at the
 *	beginning of an AVI RIFF file.
 * 
 * @field DWORD | dwMicroSecPerFrame | Specifies the number of 
 *    microseconds between frames.
 *
 * @field DWORD | dwMaxBytesPerSec | Specifies the approximate 
 *    maximum data rate of file.
 *
 * @field DWORD | dwReserved1 | Reserved. (This field should be set to 0.)
 *
 * @field DWORD | dwFlags | Specifies any applicable flags. 
 *    The following flags are defined: 
 *
 *	@flag AVIF_HASINDEX | Indicates
 *		the AVI file has an 'idx1' chunk containing an index
 *		at the end of the file.  For good performance, all AVI 
 *		files should contain an index.
 *
 *	@flag AVIF_MUSTUSEINDEX | Indicates that the
 *		index, rather than the physical ordering of the chunks
 *		in the file, should be used to determine the order of
 *		presentation of the data.  For example, this could be
 *		used for creating a list frames for editing.
 *		
 *	@flag AVIF_ISINTERLEAVED | Indicates 
 *		the AVI file is interleaved.  
 *
 *	@flag AVIF_WASCAPTUREFILE | Indicates 
 *		the AVI file is a specially allocated file used for
 *		capturing real-time video.  Applications should warn the
 *		user before writing over a file with this flag set 
 *		because the user probably defragmented
 *		this file.
 *
 *	@flag AVIF_COPYRIGHTED | Indicates the
 *		AVI file contains copyrighted data and software.
 *    When this flag is used, 
 *    software should not permit the data to be duplicated. 
 *
 * @field DWORD | dwTotalFrames | Specifies the number of 
 *    frames of data in file.
 *
 * @field DWORD | dwInitialFrames | Specifies the initial frame 
 * for interleaved files. Non-interleaved files should specify 
 *	zero.
 *
 * @field DWORD | dwStreams | Specifies the number of streams in the file.
 *	   For example, a file with audio and video has 2 streams.
 *
 * @field DWORD | dwSuggestedBufferSize | Specifies the suggested 
 *    buffer size for reading the file.  Generally, this size 
 *    should be large enough to contain the largest chunk in 
 *    the file. If set to zero, or if it is too small, the playback
 *	   software will have to reallocate memory during playback 
 *	   which will reduce performance.
 *    
 *	   For an interleaved file, this buffer size should be large
 *	   enough to read an entire record and not just a chunk.
 *
 * @field DWORD | dwWidth | Specifies the width of the AVI file in pixels.
 *
 * @field DWORD | dwHeight | Specifies the height of the AVI file in pixels.
 *
 * @field DWORD | dwScale | This field is used with
 *	<e MainAVIHeader.dwRate> to specify the time scale that
 *	applies to the AVI file. In addition, each stream 
 * can have its own time scale.
 *
 *	Dividing <e MainAVIHeader.dwRate> by <e AVIStreamHeader.dwScale>
 *	gives the number of samples per second.
 *
 * @field DWORD | dwRate | See <e MainAVIHeader.dwScale>.
 *
 * @field DWORD | dwStart | Specifies the starting time of the AVI file.
 * The units are defined by <e MainAVIHeader.dwRate> and 
 * <e MainAVIHeader.dwScale>. This field is usually set to zero.
 *
 * @field DWORD | dwLength | Specifies the length of the AVI file. 
 * The units are defined by <e AVIStreamHeader.dwRate> and 
 * <e AVIStreamHeader.dwScale>. This length is returned by MCIAVI when 
 * using the frames time format.
 *
 ****************************************************************************/

typedef struct 
{
    DWORD		dwMicroSecPerFrame;	// frame display rate (or 0L)
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwPaddingGranularity;	// pad to multiples of this
                                                // size; normally 2K.
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwTotalFrames;		// # frames in file
    DWORD		dwInitialFrames;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;
    
    DWORD		dwWidth;
    DWORD		dwHeight;
    
    /* Do we want the stuff below for the whole movie, or just
    ** for the individual streams?
    */
    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwStart;  /* Is this always zero? */
    DWORD		dwLength; /* In units above... */
} MainAVIHeader;


/*
** Stream header
*/

/* !!! Do we need to distinguish between discrete and continuous streams? */

#define AVISF_DISABLED			0x00000001
#define AVISF_VIDEO_PALCHANGES		0x00010000
/* Do we need identity palette support? */

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types AVIStreamHeader | The <t AVIStreamHeader> structure contains 
 *	   header information for a single stream of an file. It is contained 
 *    within an 'strh' chunk within a LIST 'strl' chunk that is itself
 *	   contained within the LIST 'hdrl' chunk at the beginning of
 *    an AVI RIFF file.
 * 
 * @field FOURCC | fccType | Contains a four-character code which specifies
 *	   the type of data contained in the stream. The following values are 
 *	   currently defined:
 *
 *	@flag 'vids' | Indicates the stream contains video data.  The stream 
 *    format chunk contains a <t BITMAPINFO> structure which can include
 *		palette information.
 *
 *	@flag 'auds' | Indicates the stream contains video data.  The stream 
 *    format chunk contains a <t WAVEFORMATEX> or <t PCMWAVEFORMAT>
 *		structure.
 *
 *    New data types should be registered with the <MI>Multimedia Developer 
 *    Registration Kit<D>.
 *
 * @field FOURCC | fccHandler | Contains a four-character code that 
 *	   identifies a specific data handler.
 *
 * @field DWORD | dwFlags | Specifies any applicable flags. 
 *    The bits in the high-order word of these flags 
 *    are specific to the type of data contained in the stream.
 *    The following flags are currently defined:
 *
 *	@flag AVISF_DISABLED | Indicates 
 *		this stream should not be enabled by default.
 *
 *	@flag AVISF_VIDEO_PALCHANGES | Indicates 
 *		this video stream contains palette changes. This flag warns
 *		the playback software that it will need to animate the 
 *		palette.
 *
 * @field DWORD | dwReserved1 | Reserved. (Should be set to 0.)
 *
 * @field DWORD | dwInitialFrames | Reserved for interleaved files. 
 *	   (Set this to 0 for non-interleaved files.)
 *
 * @field DWORD | dwScale | This field is used together with
 *	<e AVIStreamHeader.dwRate> to specify the time scale that
 *	this stream will use.
 *
 *	Dividing <e AVIStreamHeader.dwRate> by <e AVIStreamHeader.dwScale>
 *	gives the number of samples per second.
 *
 *	For video streams, this rate should be the frame rate.
 *
 *	For audio streams, this rate should correspond to the time needed for
 *	<e WAVEFORMATEX.nBlockAlign> bytes of audio, which for PCM audio simply
 *	reduces to the sample rate.
 *
 * @field DWORD | dwRate | See <e AVIStreamHeader.dwScale>.
 *
 * @field DWORD | dwStart | Specifies the starting time of the AVI file.
 * The units are defined by the 
 *	<e MainAVIHeader.dwRate> and <e MainAVIHeader.dwScale> fields
 *	in the main file header. Normally, this is zero, but it can
 *	specify a delay time for a stream which does not start concurrently 
 *	with the file.
 *
 *	Note: The 1.0 release of the AVI tools does not support a non-zero
 *	starting time.
 *
 * @field DWORD | dwLength | Specifies the length of this stream. 
 * The units are defined by the 
 *	<e AVIStreamHeader.dwRate> and <e AVIStreamHeader.dwScale>
 *	fields of the stream's header. 
 *
 * @field DWORD | dwSuggestedBufferSize | Suggests how large a buffer
 *	should be used to read this stream.  Typically, this contains a
 *	value corresponding to the largest chunk present in the stream. 
 * Using the correct buffer size makes playback more efficient.
 * Use zero if you do not know the correct buffer size. 
 *
 * @field DWORD | dwQuality | Specifies an indicator of the quality 
 * of the data in the stream. Quality is 
 *	represented as a number between 0 and 10000.  For compressed data,
 *	this typically represent the value of the quality parameter
 *	passed to the compression software.
 *
 * @field DWORD | dwSampleSize | Specifies the size of a single sample 
 * of data. This is set to 
 *	zero if the samples can vary in size.  If this number is non-zero, then
 *	multiple samples of data can be grouped into a single chunk within
 *	the file.  If it is zero, each sample of data (such as a video
 *	frame) must be in a separate chunk.
 *
 *	For video streams, this number is typically zero, although it
 *	can be non-zero if all video frames are the same size.
 *
 *	For audio streams, this number should be the same as the
 *	<e WAVEFORMATEX.nBlockAlign> field of the <t WAVEFORMATEX> structure
 *	describing the audio.
 *
 ****************************************************************************/
typedef struct {
    FOURCC		fccType;
    FOURCC		fccHandler;
    DWORD		dwFlags;	/* Contains AVITF_* flags */
    WORD		wPriority;
    WORD		wLanguage;
    DWORD		dwInitialFrames;
    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwStart;
    DWORD		dwLength; /* In units above... */

    // new....
    DWORD		dwSuggestedBufferSize;
    DWORD		dwQuality;
    DWORD		dwSampleSize;
    RECT		rcFrame;    /* does each frame need this? */

    /* additional type-specific data goes in StreamInfo chunk */
    
    /* For video: position within rectangle... */
    /* For audio: volume?  stereo channel? */
} AVIStreamHeader;

typedef struct {
    RECT    rcFrame;
} AVIVideoStreamInfo;

typedef struct {
    WORD    wLeftVolume;    // !!! Range?
    WORD    wRightVolume;
    DWORD   dwLanguage;	    // !!! Is there a standard representation of this?
} AVIAudioStreamInfo;


#define AVIIF_LIST          0x00000001L // chunk is a 'LIST'
#define AVIIF_TWOCC         0x00000002L // ckid is a TWOCC?
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.
#define AVIIF_FIRSTPART     0x00000020L // this frame is the start of a partial frame.
#define AVIIF_LASTPART      0x00000040L // this frame is the end of a partial frame.
#define AVIIF_MIDPART       (AVIIF_LASTPART|AVIIF_FIRSTPART)
#define AVIIF_NOTIME	    0x00000100L // this frame doesn't take any time

#define AVIIF_COMPUSE       0x0FFF0000L // these bits are for compressor use

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types AVIINDEXENTRY | The AVI file index consists of an array
 *	of <t AVIINDEXENTRY> structures contained within an 'idx1'
 *	chunk at the end of an AVI file. This chunk follows the main LIST 'movi'
 *	chunk which contains the actual data.
 * 
 * @field DWORD | ckid | Specifies a four-character code corresponding 
 *    to the chunk ID of a data chunk in the file.
 *
 * @field DWORD | dwFlags | Specifies any applicable flags. 
 *    The flags in the low-order word are reserved for AVI, 
 *    while those in the high-order word can be used
 *    for stream- and compressor/decompressor-specific information.
 *    
 *	The following values are currently defined:
 *
 *	@flag AVIIF_LIST | Indicates the specified
 *		chunk is a 'LIST' chunk, and the <e AVIINDEXENTRY.ckid>
 *		field contains the list type of the chunk.
 *
 *	@flag AVIIF_KEYFRAME | Indicates this chunk
 *		is a key frame. Key frames do not require
 *		additional preceding chunks to be properly decoded.
 *
 *	@flag AVIIF_NOTIME | Indicates this chunk should have no effect
 *		on timing or calculating time values based on the number of chunks.
 *		For example, palette change chunks in a video stream
 *		should have this flag set, so that they are not counted
 *		as taking up a frame's worth of time.
 *
 * @field DWORD | dwChunkOffset | Specifies the position in the file of the 
 *    specified chunk. The position value includes the eight byte RIFF header.
 *
 * @field DWORD | dwChunkLength | Specifies the length of the 
 *    specified chunk. The length value does not include the eight
 *    byte RIFF header.
 *
 ****************************************************************************/
typedef struct
{
    DWORD		ckid;
    DWORD		dwFlags;
    DWORD		dwChunkOffset;		// Position of chunk
    DWORD		dwChunkLength;		// Length of chunk
} AVIINDEXENTRY;


/*
** Palette change chunk
**
** Used in video streams.
*/
typedef struct 
{
    BYTE		bFirstEntry;	/* first entry to change */
    BYTE		bNumEntries;	/* # entries to change (0 if 256) */
    WORD		wFlags;		/* Mostly to preserve alignment... */
    PALETTEENTRY	peNew[];	/* New color specifications */
} AVIPALCHANGE;

/*****************************************************************************
 * @doc EXTERNAL AVI_FFMT
 * 
 * @types AVIPALCHANGE | The <t AVIPALCHANGE> structure is used in 
 *	video streams containing palettized data to indicate the
 *	palette should change for subsequent video data.
 * 
 * @field BYTE | bFirstEntry | Specifies the first palette entry to change.
 *
 * @field BYTE | bNumEntries | Specifies the number of entries to change.
 * 
 * @field WORD | wFlags | Reserved. (This should be set to 0.)
 * 
 * @field PALETTEENTRY | peNew | Specifies an array of new palette entries.
 *
 ****************************************************************************/

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#endif /* INC_AVIFFMT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\lockbm.c ===
#include <windows.h>
#include <windowsx.h>
#include "lockbm.h"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#ifndef BI_BITFIELDS
    #define BI_BITFIELDS 3
#endif

#ifndef BI_BITMAP
    #define BI_BITMAP   0x4D544942      // 'BITM'
#endif

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//
//  GDI!GDIInit2()      GDI.403
//
//  this GDI function does the following:
//
//      GetSetBitmapHandle(hbm, 0)  - will return global handle of bitmap
//
//      GetSetBitmapHandle(hbm, h)  - will set global handle to <h>
//
//      GetSetBitmapHandle(hbm, -1) - will set global handle to NULL
//
static HANDLE (FAR PASCAL *GetSetBitmapHandle)(HBITMAP hbm, HANDLE h);

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
#define muldiv(a,b,c) (UINT)(((DWORD)(UINT)(a) * (DWORD)(UINT)(b)) / (UINT)(c))

//////////////////////////////////////////////////////////////////////////////
//
// CanLockBitmaps()
//
// determime if we can lock bitmaps on the current display device
//
//////////////////////////////////////////////////////////////////////////////
BOOL FAR CanLockBitmaps(void)
{
    UINT w;
    UINT rc;
    HDC  hdc;
    BOOL f;

    static BOOL fCanLockBitmaps = -1;

    if (fCanLockBitmaps == -1)
    {
        w = (UINT)GetVersion();

        w = ((UINT)LOBYTE(w) << 8) | HIBYTE(w);

        hdc = GetDC(NULL);
        rc = GetDeviceCaps(hdc, RASTERCAPS);
        ReleaseDC(NULL, hdc);

        (FARPROC)GetSetBitmapHandle =
            GetProcAddress(GetModuleHandle("GDI"),MAKEINTATOM(403));

        //
        // assume we dont need this on windows 4.0?
        //
        // what about the DIBENG? it does DEVBITS and in win 4.0?
        //
        // if the display handles device bitmaps, dont do this either
        //

        f = GetProfileInt("DrawDib", "Bitmaps", TRUE);

#ifdef DEBUG
        fCanLockBitmaps = f && GetSetBitmapHandle != NULL;
#else
        fCanLockBitmaps = f && /* (w < 0x0400) && */
                          !(rc & RC_DEVBITS) &&
                          GetSetBitmapHandle != NULL;
#endif
    }

    return fCanLockBitmaps;
}

//////////////////////////////////////////////////////////////////////////////
//
// LockBitmap
//
// return a pointer to the bitmap bits
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR LockBitmap(HBITMAP hbm)
{
    return GetBitmap(hbm, NULL, 0);
}

//////////////////////////////////////////////////////////////////////////////
//
// GetBitmapDIB
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetBitmapDIB(LPBITMAPINFOHEADER lpbi, LPVOID lpBits, LPVOID p, int cb)
{
    IBITMAP FAR *pbm;

    if (lpBits == NULL)
        lpBits = (LPBYTE)lpbi + (int)lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

    if (p == NULL || cb < sizeof(BITMAP))
        return lpBits;

    pbm = p;

    if (lpbi->biCompression == 0)
    {
        switch ((int)lpbi->biBitCount + (int)lpbi->biPlanes*256)
        {
            case 0x0101: pbm->bmType = BM_1BIT;  break;
            case 0x0104: pbm->bmType = BM_4BIT;  break;
            case 0x0108: pbm->bmType = BM_8BIT;  break;
            case 0x0110: pbm->bmType = BM_16555; break;
            case 0x0118: pbm->bmType = BM_24BGR; break;
            case 0x0120: pbm->bmType = BM_32BGR; break;
            case 0x0401: pbm->bmType = BM_VGA;   break;
            default: return NULL;
        }
    }
    else if (lpbi->biCompression == BI_BITFIELDS)
    {
        switch ((int)lpbi->biBitCount + (int)lpbi->biPlanes*256)
        {
            //!!! hack: realy should check the bit fields!
            case 0x0110: pbm->bmType = BM_16565; break;
            case 0x0118: pbm->bmType = BM_24RGB; break;
            case 0x0120: pbm->bmType = BM_32RGB; break;
            default: return NULL;
        }
    }
    else
        return NULL;

    pbm->bmWidth        = (int)lpbi->biWidth;
    pbm->bmHeight       = ((int)lpbi->biHeight > 0) ? (int)lpbi->biHeight : -(int)lpbi->biHeight;
    pbm->bmWidthBytes   = (((int)lpbi->biBitCount * (int)lpbi->biWidth + 31)&~31)/8;
    pbm->bmPlanes       = (BYTE)lpbi->biPlanes;
    pbm->bmBitsPixel    = (BYTE)lpbi->biBitCount;
    pbm->bmBits         = lpBits;

    if (cb > sizeof(BITMAP))
    {
        pbm->bmSegmentIndex = 0;
        pbm->bmScanSegment  = pbm->bmHeight;
        pbm->bmFillBytes    = 0;
        pbm->bmBitmapInfo   = (long)lpbi;

        if ((long)lpbi->biHeight < 0)
        {
            pbm->bmNextScan = -pbm->bmWidthBytes;
            pbm->bmOffset   = (long)pbm->bmWidthBytes * (pbm->bmHeight-1);
        }
        else
        {
            pbm->bmNextScan = pbm->bmWidthBytes;
            pbm->bmOffset   = 0;
        }
    }

    return lpBits;
}

#if 0
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void FAR BitmapXY(IBITMAP FAR *pbm, int x, int y)
{
    UINT t;

    if (pbm->bmFillBytes)
    {
        while (y-- > 0)
        {
            t = (UINT)(pbm->bmOffset & 0xFFFF0000);
            pbm->bmOffset += pbm->bmNextScan;
            if ((UINT)(pbm->bmOffset & 0xFFFF0000) != t)
                pbm->bmOffset += pbm->bmFillBytes;
        }
    }
    else
    {
        pbm->bmOffset += y * (long)pbm->bmNextScan;
    }

    pbm->bmOffset += x * pbm->bmBitsPixel / 8;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// GetDIBBitmap
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetDIBBitmap(HBITMAP hbm, LPBITMAPINFOHEADER lpbi)
{
    UINT wType;
    BITMAP bm;
    UINT ScansPerSeg;
    UINT FillBytes;

    if (hbm)
        GetObject(hbm, sizeof(bm), &bm);

    wType = GetBitmapType();

    if (wType == 0)
        return NULL;

    lpbi->biSize           = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth          = bm.bmWidth;
    lpbi->biHeight         = bm.bmHeight;
    lpbi->biPlanes         = bm.bmPlanes;
    lpbi->biBitCount       = bm.bmBitsPixel;
    lpbi->biCompression    = 0;
    lpbi->biSizeImage      = (DWORD)(bm.bmWidthBytes * bm.bmPlanes) * (DWORD)bm.bmHeight;
    lpbi->biXPelsPerMeter  = 0;
    lpbi->biYPelsPerMeter  = 0;
    lpbi->biClrUsed        = 0;
    lpbi->biClrImportant   = 0;

    switch(wType & BM_TYPE)
    {
        case BM_VGA:
            break;

        case BM_1BIT:
        case BM_4BIT:
        case BM_8BIT:
            break;

        case BM_16555:
            break;

        case BM_24BGR:
        case BM_32BGR:
            break;

        case BM_16565:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x00F800;
            ((LPDWORD)(lpbi+1))[1] = 0x0007E0;
            ((LPDWORD)(lpbi+1))[2] = 0x00001F;
            break;

        case BM_24RGB:
        case BM_32RGB:
            lpbi->biCompression = BI_BITFIELDS;
            ((LPDWORD)(lpbi+1))[0] = 0x0000FF;
            ((LPDWORD)(lpbi+1))[1] = 0x00FF00;
            ((LPDWORD)(lpbi+1))[2] = 0xFF0000;
            break;

        default:
            return NULL;
    }

    //
    //  make sure WidthBytes is right, dont forget bitmaps are WORD aligned
    //  and DIBs are DWORD aligned.
    //
    if (bm.bmWidthBytes != ((bm.bmWidth * bm.bmBitsPixel + 31) & ~31)/8)
    {
        if (lpbi->biCompression != 0)
            return NULL;

        lpbi->biCompression = BI_BITMAP;
        lpbi->biXPelsPerMeter  = bm.bmWidthBytes;
    }

    if ((wType & BM_HUGE) && (lpbi->biSizeImage > 64*1024l))
    {
        if (lpbi->biCompression == BI_BITFIELDS)
            return NULL;

        lpbi->biCompression = BI_BITMAP;

        ScansPerSeg = muldiv(64,1024,bm.bmWidthBytes * bm.bmPlanes);
        FillBytes   = (UINT)(64ul*1024 - bm.bmWidthBytes * bm.bmPlanes * ScansPerSeg);

        lpbi->biSizeImage     += FillBytes * (bm.bmHeight / ScansPerSeg);
        lpbi->biXPelsPerMeter  = bm.bmWidthBytes;
        lpbi->biYPelsPerMeter  = FillBytes;
    }

    if (!(wType & BM_BOTTOMTOTOP))
        lpbi->biHeight = -bm.bmHeight;

    return LockBitmap(hbm);
}

//////////////////////////////////////////////////////////////////////////////
//
// GetBitmap
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetBitmap(HBITMAP hbm, LPVOID p, int cb)
{
    HANDLE h;
    DWORD  dwSize;
    IBITMAP FAR *pbm;
    HDC hdc = NULL;
    HBITMAP hbmT;

    if (!CanLockBitmaps())
        return NULL;

    if (hbm == NULL)
        return NULL;

    h = GetSetBitmapHandle(hbm, 0);

    if (h == NULL)
        return NULL;

    pbm = (LPVOID)GlobalLock(h);

    if (IsBadReadPtr(pbm, sizeof(IBITMAP)))
        return NULL;

    //
    // see if it is realy a bitmap.
    //
    if (pbm->bmType != 0)
        return NULL;

    //
    // make sure the bmBits pointer is valid.
    //
    if (pbm->bmBits == NULL)
    {
        hdc = CreateCompatibleDC(NULL);
        hbmT = SelectObject(hdc, hbm);
    }

    dwSize = (DWORD)pbm->bmHeight * (DWORD)pbm->bmWidthBytes;

    if (IsBadHugeWritePtr((LPVOID)pbm->bmBits, dwSize))
    {
        if (hdc)
        {
            SelectObject(hdc, hbmT);
            DeleteDC(hdc);
        }

        return NULL;
    }

    if (p)
    {
        UINT u;

        hmemcpy(p, pbm, min(cb, sizeof(IBITMAP)));
        pbm = p;

        u = GetBitmapType();

        pbm->bmType = u & BM_TYPE;

        if (cb > sizeof(BITMAP))
        {
            pbm->bmBitmapInfo = NULL;
            pbm->bmNextScan = pbm->bmWidthBytes * pbm->bmPlanes;

            if (u & BM_BOTTOMTOTOP)
            {
                pbm->bmOffset = 0;
            }
            else
            {
                pbm->bmOffset   = (long)pbm->bmNextScan * (pbm->bmHeight-1);
                pbm->bmNextScan = -pbm->bmNextScan;
                pbm->bmFillBytes = -pbm->bmFillBytes;
            }

            //
            // see if this particular bitmap is HUGE
            //
            if (!(u & BM_HUGE) || (DWORD)pbm->bmHeight * pbm->bmWidthBytes < 64l*1024)
            {
                pbm->bmFillBytes = 0;
                pbm->bmScanSegment = pbm->bmHeight;
            }
            else
            {
                if (pbm->bmOffset)
                    pbm->bmOffset -= (long)((pbm->bmHeight-1) / pbm->bmScanSegment) * pbm->bmFillBytes;
            }
        }
    }

    if (hdc)
    {
        SelectObject(hdc, hbmT);
        DeleteDC(hdc);
    }

    return (LPVOID)pbm->bmBits;
}

/////////////////////////////////////////////////////////////////////////////
//
//  SetPixel
//
//  some cards cant't seam to do SetPixel right it is amazing they work at all
//
/////////////////////////////////////////////////////////////////////////////

static void SetPixelX(HDC hdc, int x, int y, COLORREF rgb)
{
    RECT rc;

    rc.left = x;
    rc.top  = y;
    rc.right = x+1;
    rc.bottom = y+1;

    SetBkColor(hdc, rgb);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}

#define SetPixel SetPixelX

///////////////////////////////////////////////////////////////////////////////
//
//  GetSurfaceType
//
///////////////////////////////////////////////////////////////////////////////

#define BCODE _based(_segname("_CODE"))

static BYTE  BCODE bits8[]   = {0x00,0xF9,0xFA,0xFC,0xFF};
static WORD  BCODE bits555[] = {0x0000,0x7C00,0x03E0,0x001F,0x7FFF};
static WORD  BCODE bits5551[]= {0x8000,0xFC00,0x83E0,0x801F,0xFFFF};
static WORD  BCODE bits565[] = {0x0000,0xF800,0x07E0,0x001F,0xFFFF};
static BYTE  BCODE bitsBGR[] = {0x00,0x00,0x00, 0x00,0x00,0xFF, 0x00,0xFF,0x00, 0xFF,0x00,0x00, 0xFF,0xFF,0xFF};
static BYTE  BCODE bitsRGB[] = {0x00,0x00,0x00, 0xFF,0x00,0x00, 0x00,0xFF,0x00, 0x00,0x00,0xFF, 0xFF,0xFF,0xFF};
static DWORD BCODE bitsRGBX[]= {0x000000, 0x0000FF, 0x00FF00, 0xFF0000, 0xFFFFFF};
static DWORD BCODE bitsBGRX[]= {0x000000, 0xFF0000, 0x00FF00, 0x0000FF, 0xFFFFFF};

void FAR TestSurfaceType(HDC hdc, int x, int y)
{
    PatBlt(hdc, x, y, 5, 1, BLACKNESS);

    SetPixel(hdc, x+0, y, RGB(000,000,000));
    SetPixel(hdc, x+1, y, RGB(255,000,000));
    SetPixel(hdc, x+2, y, RGB(000,255,000));
    SetPixel(hdc, x+3, y, RGB(000,000,255));
    SetPixel(hdc, x+4, y, RGB(255,255,255));

    GetPixel(hdc, x, y);
}

UINT FAR GetSurfaceType(LPVOID lpBits)
{
    #define TESTFMT(a,n) \
        if (_fmemcmp(lpBits, (LPVOID)a, sizeof(a)) == 0) return n;

    TESTFMT(bits8,    BM_8BIT);
    TESTFMT(bits555,  BM_16555);
    TESTFMT(bits5551, BM_16555);
    TESTFMT(bits565,  BM_16565);
    TESTFMT(bitsRGB,  BM_24RGB);
    TESTFMT(bitsBGR,  BM_24BGR);
    TESTFMT(bitsRGBX, BM_32RGB);
    TESTFMT(bitsBGRX, BM_32BGR);

    return 0;
}

///////////////////////////////////////////////////////////////////////////////
//
//  GetBitmapType
//
//  return the bitmap type that the display driver uses
//
///////////////////////////////////////////////////////////////////////////////

UINT FAR GetBitmapType()
{
    BITMAP bm;
    HBITMAP hbm;
    HBITMAP hbmT;
    HDC hdc;
    UINT u;
    BYTE bits[20*4*2];

    static UINT wBitmapType = 0xFFFF;

    if (wBitmapType != 0xFFFF)
        return wBitmapType;

    //
    // create a test bitmap (<64k)
    //
    hdc = GetDC(NULL);
    hbm = CreateCompatibleBitmap(hdc,20,2);
    ReleaseDC(NULL, hdc);

    hdc = CreateCompatibleDC(NULL);
    hbmT = SelectObject(hdc, hbm);

    GetObject(hbm, sizeof(bm), &bm);
    PatBlt(hdc, 0, 0, bm.bmWidth, bm.bmHeight, BLACKNESS);

    TestSurfaceType(hdc, 0, 0);
    GetBitmapBits(hbm, sizeof(bits), bits);
    u = GetSurfaceType(bits);

    if (u == 0) {
        u = GetSurfaceType(bits + bm.bmWidthBytes);

        if (u)
            u |= BM_BOTTOMTOTOP;
    }

#ifndef WIN32
    if (u) {
        BYTE _huge *pb;
        UINT dy,w;

        //
        // see if bitmap(s) are huge format
        //
        dy = (UINT)(0x10000l/bm.bmWidthBytes) + 1;
        hbm = CreateCompatibleBitmap(hdc,bm.bmWidth,dy);
        DeleteObject(SelectObject(hdc, hbm));
        PatBlt(hdc, 0, 0, bm.bmWidth, dy, BLACKNESS);

        pb = (BYTE _huge *)LockBitmap(hbm);

        if (pb == NULL || OFFSETOF(pb) != 0)
            ; // cant lock bitmaps
        else {
            u |= BM_CANLOCK;

            w = (dy-1) * bm.bmWidthBytes;

            pb[64l*1024] = 0;
            pb[w] = 0;

            if (u & BM_BOTTOMTOTOP)
                SetPixel(hdc, 0, 0, RGB(255,255,255));
            else
                SetPixel(hdc, 0, dy-1, RGB(255,255,255));

            if (pb[64l*1024] != 0 && pb[w] == 0)
                u |= BM_HUGE;
            else if (pb[64l*1024] == 0 && pb[w] != 0)
                ;
            else
                u = 0;
        }
    }
#endif

    SelectObject(hdc, hbmT);
    DeleteObject(hbm);
    DeleteDC(hdc);

    wBitmapType = u;
    return u;
}

//////////////////////////////////////////////////////////////////////////////
//
//  returns the PDevice of the given physical or memory DC
//
//  return the bitmap type that the display driver uses
//
///////////////////////////////////////////////////////////////////////////////

LPVOID FAR GetPDevice(HDC hdc)
{               
    HANDLE h;
    HBITMAP hbm;
    HBITMAP hbmT;
    HDC hdcT=NULL;
    IBITMAP FAR *pbm;
    LPVOID lpPDevice = NULL;

    // GDI.403
    static HANDLE (FAR PASCAL *GdiGetBitmapHandle)(HBITMAP hbm, HANDLE h);

    if (GdiGetBitmapHandle == NULL)
        (FARPROC)GdiGetBitmapHandle = GetProcAddress(GetModuleHandle("GDI"),MAKEINTATOM(403));

    if (GdiGetBitmapHandle == NULL)
        return NULL;

    hbm = CreateBitmap(1,1,1,1,NULL);

    //
    //  first try the passed DC if it is a bitmap/DC
    //
    hbmT = SelectBitmap(hdc, hbm);

    if (hbmT != NULL)
    {
        //
        // it is a memory DC.
        //
        h = GdiGetBitmapHandle(hbmT, 0);
    }
    else
    {
        //
        // it is a physical DC.
        //

        hdcT = CreateCompatibleDC(hdc);
        hbmT = SelectBitmap(hdcT, hbm);

        h = GdiGetBitmapHandle(hbm, 0);
    }

    if (h == NULL)
        goto exit;

    pbm = (IBITMAP FAR *)GlobalLock(h);

    if (IsBadReadPtr(pbm, sizeof(IBITMAP)))
        goto exit;

    if (pbm)
        pbm = (IBITMAP FAR *)pbm->bmlpPDevice;
    else
        pbm = NULL;

    if (IsBadReadPtr(pbm, 2))
        goto exit;

    lpPDevice = (LPVOID)pbm;

exit:
    if (hdcT)
    {
        SelectObject(hdcT, hbmT);
        DeleteObject(hdcT);
    }
    else
    {
        SelectObject(hdc, hbmT);
    }

    DeleteObject(hbm);

    return lpPDevice;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\dva\vflat.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  VFLAT.ASM
;
;   module for doing direct video access under windows.
;
;   we will talk to VflatD to get the linear address of the video buffer.
;
;   we MUST not use these API in the background, how do we do this?
;
;   we support the following modes: (same as SVGA256...)
;
;        VRAM II 640x480x8bpp
;        VRAM II 720x512x8bpp
;        VRAM II 800x600x8bpp
;        VRAM II 1024x768x8bpp
;
;        V7 VGA 640x480x8bpp
;        V7 VGA 720x512x8bpp
;        V7 VGA 800x600x8bpp
;        V7 VGA 1024x768x8bpp
;
;        WD VGA 640x480x8bpp
;        WD VGA 800x600x8bpp
;        WD VGA 1024x768x8bpp
;        WD VGA 640x480x16bpp
;        WD VGA 800x600x16bpp
;
;        Trident 640x480x8bpp
;        Trident 800x600x8bpp
;        Trident 1024x768x8bpp
;
;        Oak 640x480x8bpp
;        Oak 800x600x8bpp
;        Oak 1024x768x8bpp
;
;        ATI 640x480x8bpp
;        ATI 800x600x8bpp
;        ATI 1024x768x8bpp
;        ATI 640x480x24bpp
;
;        Compaq AVGA 640x480x8bpp
;
;        Compaq QVision 640x480x8bpp
;        Compaq QVision 800x600x8bpp
;        Compaq QVision 1024x768x8bpp
;
;        Compaq QVision 640x480x16bpp
;        Compaq QVision 800x600x16bpp
;        Compaq QVision 1024x768x16bpp
;
;        Tseng ET4000 640x480x8bpp
;        Tseng ET4000 800x600x8bpp
;        Tseng ET4000 1024x768x8bpp
;        Tseng ET4000 640x480x16bpp
;        Tseng ET4000 800x600x16bpp
;
;        Everex 640x480x8bpp
;        Everex 800x600x8bpp
;        Everex 1024x768x8bpp
;
;        Cirrus 542x 640x480x8bpp
;        Cirrus 542x 800x600x8bpp
;        Cirrus 542x 1024x768x8bpp
;
;        Cirrus 6420 640x480x8bpp
;        Cirrus 6420 800x600x8bpp
;        Cirrus 6420 1024x768x8bpp
;
; Created:  03-20-90
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1994 Microsoft Corporation
;
; Public Functions:
;
;       VFlatInit()
;
; Public Data:
;
; General Description:
;
; Restrictions:
;
;-----------------------------------------------------------------------;

?PLM = 1
?WIN = 0
.386
	.xlist
	include cmacros.inc
        include windows.inc
        WIN31=1
        include VflatD.inc
        .list

        externFP        GetDC
        externFP        ReleaseDC
        externFP        GetDeviceCaps
        externFP        OutputDebugString
        externFP        WriteProfileString

        externA         __C000h
        externA         __A000h

sBegin  Data

        ScreenMode  dw      0                   ; current mode (index)
        VflatD_Proc dd      0                   ; VflatD entry point

        bank_save           dw      0           ; saved bank...

sEnd    Data

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ifdef DEBUG
DPF     macro   text
        local   string, string_end
        jmp short string_end
string label byte
        db      "&text&",13,10,0
string_end label byte
        pusha
        push    es
        push    cs
        push    offset string
        call    OutputDebugString
        pop     es
        popa
        endm
else
DPF     macro text
        endm
endif

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin CodeSeg
        .386p
        assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ifdef DEBUG
szDebug     db "Debug", 0
szDrawDib   db "DrawDib", 0
szDetect    db "detect", 0
szDetectDVA db "DetectDVA: ", 0
szNone      db "None", 0
endif

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

ModeInfo STRUC

    ModeNext            dw      ?
    ModeDetect          dw      ?
    ModeNum             dw      ?
    ModeWidth           dw      ?
    ModeHeight          dw      ?
    ModeDepth           dw      ?
    ModeSetBank         dw      ?
    ModeGetBank         dw      ?
    ModeSetBank32       dw      ?
    ModeSetBank32Size   dw      ?
    ModeName            db      ?

ModeInfo ENDS

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

Mode macro y, n, w, h, b, x, name
        local   l1,l2
l1:
        dw      l2 - l1
        dw      Detect&y, n, w, h, b, SetBank&x, GetBank&x, SetBank32&x, SetBank32&x&Size

ifdef DEBUG
        db      name
        db      0
endif

l2:
        endm

ModeInfoTable label byte

        Mode VRAM, 67h, 640, 480, 8, VRAM, "VRAM II 640x480x8bpp"
        Mode VRAM, 68h, 720, 512, 8, VRAM, "VRAM II 720x512x8bpp"
        Mode VRAM, 69h, 800, 600, 8, VRAM, "VRAM II 800x600x8bpp"
        Mode VRAM, 6Ah, 1024,768, 8, VRAM, "VRAM II 1024x768x8bpp"

        Mode V7,   67h, 640, 480, 8, V7, "V7 VGA 640x480x8bpp"
        Mode V7,   68h, 720, 512, 8, V7, "V7 VGA 720x512x8bpp"
        Mode V7,   69h, 800, 600, 8, V7, "V7 VGA 800x600x8bpp"
        Mode V7,   6Ah, 1024,768, 8, V7, "V7 VGA 1024x768x8bpp"

        Mode WD,   5Fh, 640, 480, 8, WD, "WD VGA 640x480x8bpp"
        Mode WD,   5Ch, 800, 600, 8, WD, "WD VGA 800x600x8bpp"
        Mode WD,   60h, 1024,768, 8, WD, "WD VGA 1024x768x8bpp"
        Mode WD,   64h, 640, 480,16, WD, "WD VGA 640x480x16bpp"
        Mode WD,   65h, 800, 600,16, WD, "WD VGA 800x600x16bpp"

        Mode Trident, 5Dh, 640, 480, 8, Trident, "Trident 640x480x8bpp"
        Mode Trident, 5Eh, 800, 600, 8, Trident, "Trident 800x600x8bpp"
        Mode Trident, 62h, 1024,768, 8, Trident, "Trident 1024x768x8bpp"

        Mode Oak,  53h, 640, 480, 8, Oak, "Oak 640x480x8bpp"
        Mode Oak,  54h, 800, 600, 8, Oak, "Oak 800x600x8bpp"
        Mode Oak,  59h, 1024,768, 8, Oak, "Oak 1024x768x8bpp"

        Mode ATI,  12h, 640, 480, 8, ATI, "ATI 640x480x8bpp"
        Mode ATI,  12h, 800, 600, 8, ATI, "ATI 800x600x8bpp"
        Mode ATI,  12h, 1024,768, 8, ATI, "ATI 1024x768x8bpp"
        Mode ATI,  12h, 2048,1024,8, ATI, "ATI 2048x1024x8bpp"

        Mode ATI,  12h, 640, 480,16, ATI, "ATI 640x480x16bpp"
        Mode ATI,  12h, 800, 600,16, ATI, "ATI 800x600x16bpp"
        Mode ATI,  12h, 1024,768,16, ATI, "ATI 1024x768x16bpp"
        Mode ATI,  12h, 2048,1024,16,ATI, "ATI 2048x1024x16bpp"

        Mode ATI,  12h, 640, 480,24, ATI, "ATI 640x480x24bpp"
        Mode ATI,  12h, 800, 600,24, ATI, "ATI 800x600x24bpp"
        Mode ATI,  12h, 1024,768,24, ATI, "ATI 1024x768x24bpp"
        Mode ATI,  12h, 2048,1024,24,ATI, "ATI 2048x1024x24bpp"

        Mode ATI,  62h, 640, 480, 8, ATI, "ATI 640x480x8bpp"
        Mode ATI,  63h, 800, 600, 8, ATI, "ATI 800x600x8bpp"
        Mode ATI,  64h, 1024,768, 8, ATI, "ATI 1024x768x8bpp"
        Mode ATI,  75h, 640, 480,24, ATI, "ATI 640x480x24bpp"

        Mode Compaq,2Eh, 640, 480, 8, Compaq, "Compaq AVGA 640x480x8bpp"
        Mode Compaq,12h, 640, 480, 8, Compaq, "Compaq AVGA 640x480x8bpp"

        Mode Compaq,06h, 640, 480, 8, Compaq, "Compaq QVision 640x480x8bpp"
        Mode Compaq,06h, 800, 600, 8, Compaq, "Compaq QVision 800x600x8bpp"
        Mode Compaq,06h, 1024,768, 8, Compaq, "Compaq QVision 1024x768x8bpp"

        Mode Compaq,06h, 640, 480, 16, Compaq, "Compaq QVision 640x480x16bpp"
        Mode Compaq,06h, 800, 600, 16, Compaq, "Compaq QVision 800x600x16bpp"
        Mode Compaq,06h, 1024,768, 16, Compaq, "Compaq QVision 1024x768x16bpp"

        Mode Tseng, 2Eh, 640, 480, 8, Tseng, "Tseng ET4000 640x480x8bpp"
        Mode Tseng, 30h, 800, 600, 8, Tseng, "Tseng ET4000 800x600x8bpp"
        Mode Tseng, 38h, 1024,768, 8, Tseng, "Tseng ET4000 1024x768x8bpp"
        Mode Tseng, 2Eh, 640, 480,16, Tseng, "Tseng ET4000 640x480x16bpp"
        Mode Tseng, 30h, 800, 600,16, Tseng, "Tseng ET4000 800x600x16bpp"

        Mode Everex, 2Eh, 640, 480, 8, Tseng, "Everex 640x480x8bpp"
        Mode Everex, 30h, 800, 600, 8, Tseng, "Everex 800x600x8bpp"
        Mode Everex, 38h, 1024,768, 8, Tseng, "Everex 1024x768x8bpp"

; Until we get a detect routine for Cirrus, we won't include these.

        ;Mode C542x, 5Fh, 640, 480, 8, C542x, "C542x 640x480x8bpp"
        ;Mode C542x, 5Ch, 800, 600, 8, C542x, "C542x 800x600x8bpp"
        ;Mode C542x, 60h, 1024,768, 8, C542x, "C542x 1024x768x8bpp"

        ;Mode C6420, 2Eh, 640, 480, 8, C6420, "C6420 640x480x8bpp"
        ;Mode C6420, 30h, 800, 600, 8, C6420, "C6420 800x600x8bpp"
        ;Mode C6420, 38h, 1024,768, 8, C6420, "C6420 1024x768x8bpp"

ModeInfoTableEnd label byte

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;

szTseng:    db  "Tseng", 0
szOAK:      db  " OAK", 0
szTrident:  db  "TRIDENT", 0
szEverex:   db  "Everex", 0
szParadise: db  "PARADISE", 0
szWD:       db  "WESTERN DIGITAL", 0
szWeitek:   db  "WEITEK",0
szViper:    db  "VIPER VLB",0

;---------------------------Public-Routine------------------------------;
; VFlatInit
;
;       initialize for a banked display
;
; Returns:
;       C       if error
;       NC      if success
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   VFlatInit, <NEAR, PASCAL, PUBLIC>, <si,di,ds>
        localW  hdc
        localW  ScreenWidth
        localW  ScreenHeight
        localW  ScreenDepth
        localW  BiosMode
cBegin

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;   get a display DC and get resolution info
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
        cCall   GetDC, <0>
        mov     hdc,ax

        cCall   GetDeviceCaps, <hdc,HORZRES>
        mov     ScreenWidth,ax

        cCall   GetDeviceCaps, <hdc,VERTRES>
        mov     ScreenHeight,ax

        cCall   GetDeviceCaps, <hdc,BITSPIXEL>
        push    ax
        cCall   GetDeviceCaps, <hdc,PLANES>
        pop     dx
        mul     dx
        mov     ScreenDepth,ax

        cCall   ReleaseDC, <0, hdc>

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;   scan our mode table
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;

        mov     ax, 6F04h               ;Get V7 mode
        int     10h
        cmp     al,04h
        jne     short @f
	mov	ax,0F00h		;Call BIOS to get mode back.
	int	10h			;al = mode we are in.
@@:     xor     ah,ah
        mov     BiosMode,ax

        lea     bx,ModeInfoTable

mode_search:
        mov     ax,BiosMode
        cmp     cs:[bx].ModeNum,ax
        jne     short mode_search_next

        mov     ax,ScreenWidth
        cmp     cs:[bx].ModeWidth,ax
        jne     short mode_search_next

        mov     ax,ScreenHeight
        cmp     cs:[bx].ModeHeight,ax
        jne     short mode_search_next

        mov     ax,ScreenDepth
        cmp     cs:[bx].ModeDepth,ax
        jne     short mode_search_next

        push    bx
        call    cs:[bx].ModeDetect
        pop     bx
        or      ax,ax
        jnz     short mode_search_found
        errn$   mode_search_next

mode_search_next:
        add     bx,cs:[bx].ModeNext
        cmp     bx,offset ModeInfoTableEnd
        jl      mode_search
        jge     mode_search_fail

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_found:
        mov     ScreenMode,bx               ; save this for later.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;   this is a banked display, we need to talk to VflatD in order for
;   anything to work.
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
	xor	di,di
	mov	es,di
	mov	ax,1684h
        mov     bx,VflatD_Windows_ID
	int	2fh			    ;returns with es:di-->VFlatD Entry point
        mov     word ptr [VflatD_Proc][0],di
        mov     word ptr [VflatD_Proc][2],es
	mov	ax,es
        or      ax,di
        jne     short mode_search_vflat

	xor	di,di
	mov	es,di
	mov	ax,1684h
        mov     bx,VflatD_Chicago_ID
	int	2fh			    ;returns with es:di-->VFlatD Entry point
        mov     word ptr [VflatD_Proc][0],di
        mov     word ptr [VflatD_Proc][2],es
	mov	ax,es
        or      ax,di
        jz      short mode_search_fail

mode_search_vflat:
	xor	ax,ax
	mov	dx,VflatD_Get_Version
	call	[VflatD_Proc]
	cmp	ax,VflatD_Version
        jb      short mode_search_fail

        ;
        ;   estimate the required framebuffer memory
        ;
        mov     ax,ScreenDepth              ; bitdepth
        mul     ScreenWidth                 ; * width = bit width
        shr     ax,3                        ; / 8 = width bytes
        add     ax,1024-1                   ; round up to nearest K
        and     ax,not (1024-1)             ; now we have scan width
        mul     ScreenHeight                ; * number of scans = total bytes
        add     ax,0FFFFh                   ; round up to nearest MB
        adc     dx,0000Fh
        and     dx,0FFF0h
        shl     dx,4                        ; convert to 4K pages.
        mov     ax,dx

        mov     dx,VflatD_Get_Sel           ; get selector
;;;;;;;;mov     ax,512                      ; size in pages of video memory?
	mov	bx,ScreenMode
        mov     cx,cs:[bx].ModeSetBank32Size; size of bank code.
        mov     di,cs:[bx].ModeSetBank32    ; point es:di to bank code.
	push	cs
	pop	es
        call    [VflatD_Proc]               ; let VflatD init things.
        jc      short mode_search_fail
        or      ax,ax
        jz      short mode_search_fail

        errn$   mode_search_ok

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_ok:

ifdef DEBUG
        pusha
        mov     bx,ScreenMode
        lea     ax,[bx].ModeName
        lea     bx,szDrawDib
        lea     cx,szDetect

        cCall   WriteProfileString, <cs,bx, cs,cx, cs,ax>
        popa
endif
        mov     dx, ax
        xor     ax, ax
        jmp     short mode_search_exit

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_fail:
ifdef DEBUG
        pusha
        lea     ax,szDrawDib
        lea     bx,szDetect
        lea     cx,szNone
        cCall   WriteProfileString, <cs,ax, cs,bx, cs,cx>
        popa
endif
        xor     ax,ax
        mov     dx,ax
        mov     ScreenMode,ax
        mov     word ptr [VflatD_Proc][0],ax
        mov     word ptr [VflatD_Proc][2],ax
        errn$   mode_search_exit

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
mode_search_exit:

cEnd

;---------------------------Public-Routine------------------------------;
; VFlatBegin - start direct frame buffer access
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   VFlatBegin, <NEAR, PUBLIC>, <>
cBegin
        mov     bx, ScreenMode
        or      bx, bx
        jz      short BeginExit

%out is CLI/STI needed?
;;;;;;;;cli
        call    cs:[bx].ModeGetBank
        xchg    bank_save,ax
        mov     dx,ax
        call    cs:[bx].ModeSetBank
;;;;;;;;sti
BeginExit:
cEnd

;---------------------------Public-Routine------------------------------;
; VFlatEnd - end direct frame buffer access
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   VFlatEnd, <NEAR, PUBLIC>, <>
cBegin
        mov     bx, ScreenMode
        or      bx, bx
        jz      short EndExit

%out is CLI/STI needed?
;;;;;;;;cli
        call    cs:[bx].ModeGetBank
        xchg    bank_save,ax
        mov     dx,ax
        call    cs:[bx].ModeSetBank
;;;;;;;;sti
EndExit:
cEnd

;---------------------------Public-Routine------------------------------;
; ScanROM   - scan the video bios ROM looking for a string
;
; Entry:
;       cs:ax   - string to look for.
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

ScanROM proc near
        push    si
        mov     si,ax

        mov     ax,__C000h
        mov     es,ax

        xor     bx,bx               ; start at zero
        mov     cx,512              ; search first 512 bytes.

        mov     dx,si
scan_start:
        mov     si,dx
        mov     al,cs:[si]
scan_cmp:
        cmp     byte ptr es:[bx], al
        je      short scan_found
        inc     bx
        loop    scan_start
        xor     ax,ax
        pop     si
        ret

scan_next:
        inc     bx
        loop    scan_cmp
        xor     ax,ax
        pop     si
        ret

scan_found:
        inc     si
        mov     al,cs:[si]
        or      al,al
        jnz     scan_next
        inc     ax
        pop     si
        ret

ScanROM  endp

;----------------------------------------------------------------------------
; BANK SWITCH TEMPLATES
;  Each template is given to vflatd.386 which copies it inline in to the 
;  page fault handling code.
; NOTE: This code runs at ring 0 in a USE32 code segment, so be carefull!!!
; ALL REGISTERS MUST BE PRESERVED (except for dx)
;----------------------------------------------------------------------------

;****************************************************************************
; V7
;****************************************************************************

DetectV7 proc near

        mov     ax,6f00h                ;Test for Video 7
	xor	bx,bx
	cld
        int     10h
        xor     ax,ax
        cmp     bx,'V7'
        jne     short @f
        inc     ax
@@:     ret

DetectV7 endp

SetBank32V7 label byte
	push	ax
	push	bx

        mov     bl,al
        and     bl,1                    ; BL = extended page select

        mov     ah,al
        and     ah,2
        shl     ah,4                    ; AH = page select bit

        and     al,00ch
        mov     bh,al
        shr     al,2
        or      bh,al                   ; BH = 256K bank select

        db      66h,0bah,0cch,03h       ;mov dx, 3CCh
        in      al,dx                   ; Get Miscellaneous Output Register
        and     al,not 20h              ; Clear page select bit
        or      al,ah                   ; Set page select bit (maybe)
        mov     dl,0c2h                 ; Write Miscellaneous Output Register
        out     dx,al

        mov     dl,0c4h                 ; Sequencer
        mov     al,0f9h                 ; Extended page select register
        mov     ah,bl                   ; Extended page select value
        out     dx,eax			; out dx,ax

        mov     al,0f6h                 ; 256K bank select
        out     dx,al
        inc     dx                      ; Point to data
        in      al,dx
        and     al,0f0h                 ; Clear out bank select banks
        or      al,bh                   ; Set bank select banks (maybe)
        out     dx,al
	pop	bx
        pop     ax
SetBank32V7Size = $ - SetBank32V7

SetBankV7 proc near
        mov     bl,dl
        and     bl,1                    ; BL = extended page select

        mov     ah,dl
        and     ah,2
        shl     ah,4                    ; AH = page select bit

        and     dl,00ch
        mov     bh,dl
        shr     dl,2
        or      bh,dl                   ; BH = 256K bank select

        mov     dx,03cch
        in      al,dx                   ; Get Miscellaneous Output Register
        and     al,not 20h              ; Clear page select bit
        or      al,ah                   ; Set page select bit (maybe)
        mov     dl,0c2h                 ; Write Miscellaneous Output Register
        out     dx,al

        mov     dl,0c4h                 ; Sequencer
        mov     al,0f9h                 ; Extended page select register
        mov     ah,bl                   ; Extended page select value
        out     dx,ax

        mov     al,0f6h                 ; 256K bank select
        out     dx,al
        inc     dx                      ; Point to data
        in      al,dx
        and     al,0f0h                 ; Clear out bank select banks
        or      al,bh                   ; Set bank select banks (maybe)
        out     dx,al
	ret
SetBankV7 endp

GetBankV7      proc    near
	mov	dx,3cch
        in      al,dx
        and     al,20h                  ; page select bit
        shr     al,4
        mov     ah,al

	mov	dx,3C4h
	mov	al,0f9h
	out	dx,al
	inc	dx
        in      al,dx
        and     al,1
        or      ah,al

	dec	dx
	mov	al,0F6h
	out	dx,al
	inc	dx
        in      al,dx
        and     al,0ch
        or      al,ah
        xor     ah,ah
	ret
GetBankV7      endp

;****************************************************************************
; V7 II
;****************************************************************************

DetectVRAM proc near
if 0    ; ack!
        call    DetectV7
        or      ax,ax
        jz      short novram

	mov	dx,03C4H
	mov	al,08FH
	out	dx,al
	inc	dx
	in	al,dx
	mov	ah,al

	dec	dx
	mov	al,08EH
	out	dx,al
	inc	dx
	in	al,dx

        cmp     ax,07151H               ;VRAMII rev B id
        je      short isvram
        cmp     ax,07152H               ;VRAMII rev C and D id
        je      short isvram
;       cmp     ax,07760H               ;HT216 rev B and C
;       je      short isvram
;       cmp     ax,07763H               ;HT216 rev B, C, and D
;       je      short isvram
;       cmp     ax,07764H               ;HT216 rev E
;       je      short isvram
endif
novram:
        xor     ax,ax
        ret
isvram:
        mov     ax,1
        ret

DetectVRAM endp

SetBank32VRAM label byte
        push    ax                      ;push eax
        shl     dl,4
        mov     ah,dl
        db      66h,0bah,0c4h,03h       ; mov dx, 3C4h
	mov	al,0e8h
        out     dx,eax			; out dx,ax
        pop     ax                      ; pop eax
SetBank32VRAMSize = $ - SetBank32VRAM

SetBankVRAM proc near
        shl     dl,4
        mov     ah,dl
	mov	dx,03c4h
	mov	al,0e8h
        out     dx,ax
        ret
SetBankVRAM endp

GetBankVRAM proc near
        mov     dx,3c4h
        mov     al,0e8h
	out	dx,al
	inc	dx
        in      al,dx
        shr     al,4
        ret
GetBankVRAM endp

;****************************************************************************
; ATI
;****************************************************************************

public DetectATI
DetectATI proc near
        mov     ax,__C000h              ;ATI VGA detect (largely from ATI example code)
        mov     es,ax
        xor     ax,ax
	cmp	word ptr es:[40h],'13'	;ATI Signiture on the Video BIOS
        jne     short @f
        inc     ax
@@:     ret
DetectATI endp

SetBank32ATI label byte
	push	ax
	mov	ah,al
	shl	ah,1
	mov	al,0B2h
        db      66h,0bah,0ceh,01h       ;mov dx, 1CEh
	out	dx,eax
	pop	ax
SetBank32ATISize = $ - SetBank32ATI

SetBankATI proc near
	mov	ah,dl
	shl	ah,1
	mov	al,0b2h		;Page select register index
	mov	dx,1ceh		;
	out	dx,ax		;
	ret
SetBankATI endp

GetBankATI     proc    near
	mov	dx,1ceh
	mov	al,0b2h
	out	dx,al
	inc	dx
        in      al,dx
        shr     al,1
	ret
GetBankATI     endp

;****************************************************************************
; OAK
;****************************************************************************

DetectOAK   proc    near

        lea     ax,szOAK
        jmp     ScanROM

DetectOAK   endp

SetBank32Oak label byte
	push	ax
	mov	ah,al
	shl	al,4
	or	ah,al
        db      66h,0bah,0deh,03h       ;mov dx, 3DEh
	mov	al,11h
	out	dx,eax
	pop	ax
SetBank32OakSize = $ - SetBank32Oak

SetBankOAK proc near
	mov	al,dl
	mov	ah,al
	shl	al,4
	or	ah,al
	mov	dx,3deh
	mov	al,11h
	out	dx,ax
	ret
SetBankOAK endp

GetBankOAK     proc    near
	mov	dx,3deh
	mov	al,11h
	out	dx,al
	inc	dx
        in      al,dx
        and     al,0Fh
	ret
GetBankOAK        endp

;****************************************************************************
; Everex
;****************************************************************************

DetectEverex  proc    near

        lea     ax,szEverex
        jmp     ScanROM

DetectEverex    endp

;****************************************************************************
; Tseng
;****************************************************************************

DetectTseng  proc    near

        lea     ax,szTseng
        jmp     ScanROM

DetectTseng   endp

SetBank32Tseng label byte
	mov	dx, ax                  ;mov edx,eax
	shl	al, 4
	or	al, dl
        db      66h,0bah,0cdh,03h       ;mov dx, 3CDh
	out	dx, al                              
	shr	al, 4                   ;shr al,4
SetBank32TsengSize = $ - SetBank32Tseng

SetBankTseng proc near
        and     al,0fh
	mov	al,dl
	mov	ah,al
	shl	al,4
	or	al,ah
	mov	dx,3cdh
	out	dx,al
	ret
SetBankTseng endp

GetBankTseng proc near
	mov	dx,3cdh
        in      al,dx
	shr	al, 4                   ;shr al,4
	ret
GetBankTseng endp

;****************************************************************************
; WD
;****************************************************************************

DetectWD  proc    near

        lea     ax,szWD
        call    ScanROM
        or      ax,ax
        jz      short @f
        ret

@@:     lea     ax,szParadise
        jmp     ScanROM

DetectWD endp

SetBank32WD label byte
        push    ax
	mov	ah,al			;ah = bank number
        mov     al,9                    ;select the primary "bank adder" reg
        shl     ah,4
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax                  ;out dx,ax (write 3cf:09, desired bank)
        pop     ax
SetBank32WDSize = $ - SetBank32WD

SetBankWD proc near
        mov     al,9                    ;select the primary "bank adder" reg
        mov     ah,dl
        shl     ah,4
        mov     dx,3ceh
        out     dx,ax                   ;write 3cf:09, desired bank
        ret
SetBankWD endp

GetBankWD      proc near
	mov	dx,3ceh
        mov     al,9
	out	dx,al
	inc	dx
        in      al,dx
        shr     al,4
	ret
GetBankWD      endp

;****************************************************************************
; Weitek
;****************************************************************************

DetectWeitek  proc    near

        lea     ax,szWeitek
        jmp     ScanROM

DetectWeitek   endp

;****************************************************************************
; Trident
;****************************************************************************

DetectTrident proc    near

        lea     ax,szTrident
        jmp     ScanROM

DetectTrident endp

SetBank32Trident label byte
	push	ax
	mov	ah,al
	xor	ah,2
	mov	al,0EH
        db      66h,0bah,0c4h,03h       ;mov dx, 3C4h
	out	dx,eax			
;;      db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
;;	out	dx,eax			;for 8900c or better only.
	pop	ax
SetBank32TridentSize = $ - SetBank32Trident

SetBankTrident proc near
	mov	ah,dl
	xor	ah,2
	mov	al,0EH
	mov	dx,3c4h
	out	dx,ax
;;	mov	dx,3ceh
;;	out	dx,ax			;for 8900c or better only.
	ret
SetBankTrident endp

GetBankTrident proc near
	mov	dx,3c4h
	mov	al,0eh
	out	dx,al
	inc	dx
	in	al,dx
        xor     al,2
	ret
GetBankTrident endp

;****************************************************************************
; Compaq
;****************************************************************************

DetectCompaq proc near
        mov     ax,__C000h
        mov     es,ax
        xor     ax,ax
        cmp     word ptr es:[2],0E930h
        jne     short @f
        inc     ax
@@:     ret
DetectCompaq endp

SetBank32Compaq label byte
        push    ax
        mov     ah,al
        shl     ah,4
        mov     al,45h
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax
        inc     al
        add     ah,08h
        out     dx,eax
	pop	ax
SetBank32CompaqSize = $ - SetBank32Compaq

SetBankCompaq proc near
        mov     ah,dl
        shl     ah,4
        mov     dx,03CEh
        mov     al,45h
        out     dx,ax
        inc     al
        add     ah,08h
        out     dx,ax
	ret
SetBankCompaq endp

GetBankCompaq proc near
        mov     dx,03CEh
        mov     al,45h
	out	dx,al
	inc	dx
	in	al,dx
        shr     al,4
	ret
GetBankCompaq endp

;****************************************************************************
; Cirrus 6420
;****************************************************************************

DetectC6420 proc near
        %out *** need a Detect function for Cirrus 6420
        mov     ax,1        ;!!!
        ret
DetectC6420 endp

SetBank32C6420 label byte
        push    ax
        mov     ah,al
	shl	ah,4
        mov     al,0eh
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax                  ;
        pop     ax

SetBank32C6420Size = $ - SetBank32C6420

SetBankC6420    proc near
        mov     ah,dl
	shl	ah,4
        mov     al,0eh
        mov     dx, 3CEh
        out     dx,ax
        ret

SetBankC6420    endp

GetBankC6420    proc near
        mov     dx,03CEh
        mov     al,0Eh
	out	dx,al
	inc	dx
	in	al,dx
        shr     al,4
	ret

GetBankC6420    endp

;****************************************************************************
; Cirrus 542x
;****************************************************************************

DetectC542x proc near
        %out *** need a Detect function for Cirrus 542x
        mov     ax,1        ;!!!
        ret
DetectC542x endp

SetBank32C542x label byte
        push    ax
        mov     ah,al
	shl	ah,4
        mov     al,09h
        db      66h,0bah,0ceh,03h       ;mov dx, 3CEh
        out     dx,eax
        pop     ax

SetBank32C542xSize = $ - SetBank32C542x

SetBankC542x    proc near
        mov     ah,dl
	shl	ah,4
        mov     al,09h
        mov     dx,3CEh
        out     dx,ax
        ret

SetBankC542x    endp

GetBankC542x    proc near
        mov     dx,03CEh
        mov     al,09h
	out	dx,al
	inc	dx
	in	al,dx
        shr     al,4
	ret

GetBankC542x    endp

;****************************************************************************
; Viper Vesa Local bus
;****************************************************************************

public DetectViper
DetectViper proc near
        lea     ax,szViper
        jmp     ScanROM
DetectViper endp

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\drawdib.16\vflatd\vflatd.asm ===
PAGE 58,132
;******************************************************************************
TITLE VFLATD.ASM - Virtual Flat Device
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1987, 1988, 1989
;
;   Title:      VFLATD.ASM - Virtual flat video buffer Device
;
;           This virtual device simulates a flat video display buffer on
;           hardware that is designed to map video memory 64k at a time
;           at segment A000.  The video card is assumed to have 512K VRAM
;
;           It does this by alocating 512k of linear address space and
;           handling the pages faults in this memory
;
;           Our PageFault handler is last in the chain, it will only be called
;           by Win386 on pages it does not reconize (ie PT_RESERVED2 pages)
;           this keeps the PageFault overhead to a minimum.
;
;           Only 16 pages are marked present at a time these corespond to
;           the current 64k hunk of memory mapped by the video card at A0000.
;
;           When a PageFault occurs the 16 curently present pages are marked
;           not present and a new set of 16 are marked as present.  The
;           Video hardware is instructed to map in the 64k page that caused
;           the page fault.
;
;   PM API Services:
;
;       Get_Ver (DX = 0000)
;
;           returns
;               AX      version of VFLATD  (1.0)
;
;       Get_Video_Base (DX = 0001)
;
;           returns
;               AX      selector to the video buffer
;               EDX     Linear Address of video buffer
;
;       Reset (DX = 0002)
;           Assume the hardware 64k bank has been modifed and readjust
;           the PageTable mapping
;
;           returns
;               nothing
;
;   Version:    1.00
;
;   Date:       15-Sep-1989
;
;   Author:     LDS
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   15-Sep-1989 LDS Original
;
;==============================================================================
;
;   DESCRIPTION:
;
;
;******************************************************************************

	.386p

;******************************************************************************
;			      I N C L U D E S
;******************************************************************************

IFDEF WIN31
%OUT SUPPORT FOR Windows 3.1
WIN31COMPAT=1
ENDIF
        .XLIST
	INCLUDE VMM.Inc
;;      INCLUDE Debug.Inc
        INCLUDE VFLATD.Inc
        .LIST

;******************************************************************************
;		 V I R T U A L	 D E V I C E   D E C L A R A T I O N
;******************************************************************************

Declare_Virtual_Device VflatD,   \
        <VflatD_Version shr 8>,  \
        <VflatD_Version and 255>,\
        VFLATD_Control,          \
        VFLATD_Device_ID,        \
        UNDEFINED_INIT_ORDER,    \
        0,                       \
        VFLATD_PM_API_Handler

;******************************************************************************
;			    L O C A L	D A T A
;******************************************************************************

VxD_LOCKED_DATA_SEG

VFLATD_Video_Sel	    dw 0	; GDT Selector to virtual frame buffer

VFLATD_SlidingWindowBase    dd ?        ;base of 64k sliding window
VFLATD_GDTBase              df ?        ;base of GDT
VFLATD_VideoSelGDT	    dd ?	;ptr to video sel's GDT entry

VxD_LOCKED_DATA_ENDS

IFDEF WIN31
 VIDEO_BASE                 equ 0A0000h     ; Physical start of VRAM
 VIDEO_LIMIT                equ 0100000h-1  ; 1M VRAM
 VIDEO_NPAGES               equ ((VIDEO_LIMIT + 4095) / 4096)
ENDIF

MAXBANKSWITCHSIZE equ 100               ;maximum size of bank switch code

;******************************************************************************
;	       D E V I C E   C O N T R O L   P R O C E D U R E
;******************************************************************************

VxD_LOCKED_CODE_SEG

;******************************************************************************
;
;   VFLATD_Control
;
;   DESCRIPTION:
;       This is the VFLATD's control procedure.
;
;   ENTRY:
;	EAX = Control call ID
;
;   EXIT:
;	If carry clear then
;	    Successful
;	else
;	    Control call failed
;
;   USES:
;	EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;==============================================================================

BeginProc VFLATD_Control

        Control_Dispatch Device_Init, VFLATD_Device_Init

IFDEF DEBUG
        Control_Dispatch Debug_Query, VFLATD_Debug_Query
ENDIF
	clc					; Ignore other control calls
	ret

EndProc VFLATD_Control

;******************************************************************************
;  A P I   H A N D L E R S   F O R   P M    V M ' S
;******************************************************************************

VxD_DATA_SEG

VFLATD_API_Call_Table LABEL DWORD
        dd      OFFSET32 VFLATD_PM_API_Get_Ver
        dd      OFFSET32 VFLATD_PM_API_Get_Video_Base
        dd      OFFSET32 VFLATD_PM_API_Reset

VFLATD_Max_API_Function = ($ - VFLATD_API_Call_Table) / 4 - 1

VxD_DATA_ENDS

;******************************************************************************
;
;   VFLATD_Device_Init
;
;   DESCRIPTION:
;
;   ENTRY:
;
;   EXIT:
;       C for error
;
;   USES:
;	All registers and flags
;
;==============================================================================

BeginProc VFLATD_Device_Init

        clc
	ret

EndProc VFLATD_Device_Init

;******************************************************************************
;
;   VFLATD_PM_API_Handler
;
;   DESCRIPTION:
;
;   ENTRY:
;	EBX = Handle of VM that called API
;	EBP -> Client register structure
;
;   EXIT:
;	Client registers and flags may be altered
;
;   USES:
;	All registers and flags
;
;==============================================================================

BeginProc VFLATD_PM_API_Handler

	movzx	eax, [ebp.Client_DX]
        cmp     eax, VFLATD_Max_API_Function       ; Q: Is this a valid function?
        ja      SHORT VFLATD_PM_API_Failed
        CallRet VFLATD_API_Call_Table[eax*4]

VFLATD_PM_API_Failed:
	or	[ebp.Client_EFlags], CF_Mask
	ret

VFLATD_PM_API_Success:
	and	[ebp.Client_EFlags], NOT CF_Mask
	ret

EndProc VFLATD_PM_API_Handler

;******************************************************************************
;
;   VFLATD_PM_API_Get_Ver
;
;   DESCRIPTION:
;       Return the VFLATD version
;
;   ENTRY:
;	Client_DX = 0
;
;   EXIT:
;	Client_AX = 200h
;	Client carry flag clear
;
;   USES:
;	EAX, Flags, Client_AX, Client_Flags
;
;==============================================================================

BeginProc VFLATD_PM_API_Get_Ver

        mov     [ebp.Client_AX], VflatD_Version
        jmp     VFLATD_PM_API_Success

EndProc VFLATD_PM_API_Get_Ver

;******************************************************************************
;
;   VFLATD_PM_API_Get_Video_Base
;
;   DESCRIPTION:
;       Return a GDT selector to the flat video buffer
;
;   ENTRY:
;	Client_DX = 1
;	Client_AX = # of pages of video memory
;	Client_CX = size of bank switch code
;	Client_ES:DI -> bank switch code
;~~~~~ document guidlines for bank switch code
;
;   EXIT:
;       Client_AX  = Selector to flat video buffer
;       Client_EDX = Linear base of flat video buffer (not usable)
;	Client carry flag clear
;
;   USES:
;	EAX, Flags, Client_AX, Client_Flags
;
;==============================================================================

BeginProc VFLATD_PM_API_Get_Video_Base

        cmp     [ebp.Client_CX],MAXBANKSWITCHSIZE
        ja      VFLATD_PM_API_Failed             ;bank switch code too big

	cmp	[VFLATD_Video_sel], 0
	jne	already_initialized

IFNDEF WIN31
	movzx	eax, [ebp.Client_AX]
	add	eax, eax
	add	eax, 64/4
	push	eax
	VMMCall _MMReserve, <PR_SYSTEM, eax, PR_FIXED>
	pop	ecx
	inc	eax
	jz	VFLATD_PM_API_Failed
	add	eax, (64*1024-2)
ELSE

        ; allocate a hunk of linear address space to use as a virtual
        ; frame buffer  eax = handle, edx = linear addr
        ;

        VMMCall _MapPhysToLinear, <3*1024*1024*1024 - (2*1024*1024+64*1024),2*1024*1024+64*1024,0>
        or      eax, eax
        jz      VFLATD_PM_API_Failed
        add     eax,(64*1024-1)
ENDIF


; round up to 64Kb boundary

	and	eax, 0FFFF0000h
	mov	edx, eax

        ;   Save linear addr of video buffer
        ;
	mov	esi, edx

IFNDEF WIN31
	mov	[VFLATD_Video_Base], edx
	sub	ecx, 64/4
	shl	ecx, 12 		; # of bytes in allocated region
	dec	ecx
	lea	ecx, [edx+ecx]
	mov	[VFLATD_Video_Top], ecx

	shr	esi, 12 		; virt page # of start of region
	movzx	ecx, [ebp.Client_AX]
	add	esi, ecx
	VMMCall _MMCommitPhys, <esi, 16, 0A0h, PC_INCR+PC_USER+PC_WRITEABLE>
	or	eax, eax
	jz	VFLATD_PM_API_Failed

ELSE
        mov     [VFLATD_Video_Base],edx
        mov     eax,edx
        add     eax,2*VIDEO_LIMIT+1
        mov     [VFLATD_Video_Top],eax

        ; NOTE I dont handle the case where the frame buffer
        ; crosses multiple page tables, if it does, FAIL
        ;
        shr     edx,12
        and     edx,3FFh                ; edx = page number
        cmp     edx,0400h - VIDEO_NPAGES
        jg      VFLATD_PM_API_Failed

        ;   find the PTE that describes the base of video memory
        ;
        mov     eax,cr3                 ; eax --> Physical base of page dir
        VMMCall _MapPhysToLinear, <eax,4*1024,0>
        mov     edi,eax                 ; edi --> Linear base of page dir

        mov     eax,esi                 ; eax = linear video buffer base
        shr     eax,22                  ; eax = page dir number
        mov     edi,[edi + 4*eax]       ; edi = page dir entry (PDE)
        and     edi,not 0FFFh           ; edi = physical addr of PT

        mov     eax,esi                 ; eax = linear video buffer base
        shr     eax,12
        and     eax,3FFh                ; eax = page number
        lea     edi,[edi + 4*eax]       ; edi = physical addr of PTE

        VMMCall _MapPhysToLinear, <edi,VIDEO_NPAGES*4,0>

        ; now eax contains the Linear addr of our page table
        ;
        ; mark all pages as not present and set the page type to PT_RESERVED2
        ;
        mov     edi,eax
        mov     eax,PG_RESERVED2 OR P_WRITE OR P_USER
        mov     ecx,VIDEO_NPAGES 
        rep     stosd

; mark the next 64K present and map it to the 64k of video memory.

        m = 0
        n = 0

REPT 16
        mov     dword ptr [edi+m],((VIDEO_BASE+n) OR PG_RESERVED2 OR P_AVAIL)
        n = n + 1000h
        m = m + 4
ENDM
        add     edi,m

; mark the next (VIDEO_NPAGES - 16) pages as not present.

        mov     eax,PG_RESERVED2 OR P_WRITE OR P_USER
        mov     ecx,VIDEO_NPAGES - 16
        rep     stosd

ENDIF

        ; allocate a GDT selector to give to PM programs
        ;
	mov	eax, [VFLATD_Video_Base]
	movzx	ecx, [ebp.Client_AX]
	dec	ecx
	VMMCall _BuildDescriptorDWORDs, <eax,ecx,RW_Data_Type,D_GRAN_PAGE,0>
	VMMCall _Allocate_GDT_Selector, <edx,eax,0>
	mov	[VFLATD_Video_sel],ax
	or	eax, eax
	jz	VFLATD_PM_API_Failed

	mov	edx, [VFLATD_Video_Base]
	shr	edx, 16
	mov	[VFLATD_SlidingWindowBase], edx
	add	edx, (1024*1024 SHR 16)
	mov	[VFLATD_PresentWindowBase], edx

        sgdt    [VFLATD_GDTBase]
	mov	edx, dword ptr [VFLATD_GDTBase+2]
	and	eax, 0fff8h
	add	edx, eax		;-> base of sel's GDT entry
	add	edx, 4
	mov	[VFLATD_VideoSelGDT_B2], edx
	add	edx, 3
	mov	[VFLATD_VideoSelGDT_B3], edx

	pushfd
	cli
        sidt    [VFLATD_GDTBase]
        mov     eax, dword ptr [VFLATD_GDTBase+2]
        add     eax, 14*8
        mov     esi, OFFSET32 VFLATD_Direct_PageFault_Handler
        xchg    word ptr [eax], si      ; LSW
        ror     esi, 16
        xchg    word ptr [eax+6], si    ; MSW
	ror	esi, 16 		; esi = old handler offset
	sub	esi, OFFSET32 next_handler + 4
	mov	[next_handler], esi
	popfd

; make space for copying in the device specific bank switch code in the page
; fault handler and copy the code in.

        mov     esi, OFFSET32 VFLATD_EndOfDPH - 1
        movzx   edi, [ebp.Client_CX]
        add     edi, esi
        std
        mov     ecx, VFLATD_EndOfDPH - VFLATD_DPH_BankSwitchCode
        rep     movsb
        cld

	Client_Ptr_Flat esi, ES, DI
        mov     edi, OFFSET32 VFLATD_DPH_BankSwitchCode
        movzx   ecx, [ebp.Client_CX]
        rep     movsb

already_initialized:
        mov     ax, [VFLATD_Video_Sel]
        mov     [ebp.Client_AX], ax

        mov     eax, [VFLATD_Video_Base]
	mov	[ebp.Client_EDX], eax

        jmp     VFLATD_PM_API_Success

EndProc VFLATD_PM_API_Get_Video_Base

;******************************************************************************
;
;   VFLATD_PM_API_Reset
;
;   DESCRIPTION:
;       Called when Video card 64k page mapping has changed by someone other
;       than  VFLATD,  We mark not present any pages we think are currently
;       mapped to the hardware.
;
;   ENTRY:
;       Client_DX = 2
;
;   EXIT:
;	Client carry flag clear
;
;   USES:
;	EAX, Flags, Client_AX, Client_Flags
;
;==============================================================================

BeginProc VFLATD_PM_API_Reset

        ;   pretend we got a page fault on page zero so the bank gets
        ;   setup right.
        ;
        ;   we need to fake up a fault frame, and jump into the
        ;   fault handler.

;       int 3

        pushfd                                      ; iretd frame flags
        push    cs
        push    OFFSET32 VFLATD_PM_API_Success      ; iretd frame return
        push    0                                   ; fault type
        push    0                                   ; saved eax (cr2)
        mov     eax,[VFLATD_Video_Base]             ; faulting address (fake cr2)
        jmp     short VFLATD_Handle_Fault

EndProc VFLATD_PM_API_Reset

;******************************************************************************
;	  H A R D W A R E   I N T E R R U P T	P R O C E D U R E S
;******************************************************************************

;******************************************************************************
;
;   BeginProc VFLATD_Direct_PageFault_Handler
;
;   DESCRIPTION:
;
;   ENTRY:
;
;   EXIT:
;
;   USES:
;
;==============================================================================

BeginProc VFLATD_Direct_PageFault_Handler, NO_PROLOG, HIGH_FREQ

        push    eax
        mov     eax,cr2

        ;   Is the fault for us? or in other words does it fall in our
        ;   virtual video buffer.
        ;
        cmp     eax,12345678h
VFLATD_Video_Base equ dword ptr $-4

        jb      short VFLATD_Chain_Fault

        cmp     eax,12345678h
VFLATD_Video_Top equ dword ptr $-4

        jb      short VFLATD_Handle_Fault

VFLATD_Chain_Fault:     ;Chain the PageFault to the next guy in the chain
	pop	eax
;;	jmp	next_handler
        db      0E9h
next_handler	dd  ?

        ;   NOTE we jump here from VFLATD_PM_API_Reset

VFLATD_Handle_Fault:
        push    ds
        push    es
        push    edx

        ;   Calculate what 64k bank the fault occured in.
        ;
	shr	eax, 16
	sub	eax, ss:[VFLATD_SlidingWindowBase]  ; eax = bank #

;==============================================================================
; >>>>>>>>>>>>> BANK SWITCH CODE GETS INSERTED HERE <<<<<<<<<<<<<<<<<<
;==============================================================================
VFLATD_DPH_BankSwitchCode label byte

; we shift the code from here upto the label "VFLATD_EndOfDPH" down to
; accomodate device specific bank switch code.

;==============================================================================

	mov	edx, 12345678h
VFLATD_PresentWindowBase equ dword ptr $-4

	sub	edx, eax
	mov	ss:[VFLATD_SlidingWindowBase], edx
;
; modify the selector base
;
        mov     ss:[12345678h], dl
VFLATD_VideoSelGDT_B2 equ dword ptr $-4

        mov     ss:[12345678h], dh
VFLATD_VideoSelGDT_B3 equ dword ptr $-4

        pop     edx
        pop     es
        pop     ds
        pop     eax
	add	esp, 4
        iretd

EndProc VFLATD_Direct_PageFault_Handler

VFLATD_EndOfDPH label byte
        db      MAXBANKSWITCHSIZE dup (?) ;space for handler to grow when bank
                                          ; switching 

VxD_LOCKED_CODE_ENDS

;******************************************************************************
;		       D E B U G G I N G   C O D E
;******************************************************************************

;******************************************************************************
;
;   VFLATD_Debug_Query
;
;   DESCRIPTION:
;       This procedure is only assembled in the debug version of VFLATD.
;
;	Note that since this procedure can be called at any time by the
;	debugger it is not allowed to call any non-asynchronous services and
;	it must be in a LOCKED code segment.
;
;   ENTRY:
;	EAX = Debug_Query (equate)
;
;   EXIT:
;	None
;
;   USES:
;	EBX, ECX, EDX, ESI, Flags
;
;==============================================================================

IFDEF DEBUG

VxD_LOCKED_CODE_SEG

BeginProc VFLATD_Debug_Query

;       Trace_Out "******* VFLATD Debug_Query *******"

        mov     eax, VFLATD_Video_Base
;       Trace_Out "Video_Base:   #EAX"

        mov     ax, VFLATD_Video_Sel
;       Trace_Out "Video_Sel:    #AX"

VFLATD_DQ_Exit:
	ret

EndProc VFLATD_Debug_Query

VxD_LOCKED_CODE_ENDS

ENDIF

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\avifmt.h ===
/****************************************************************************/
/*                                                                          */
/*        AVIFMT.H - Include file for working with AVI files                */
/*                                                                          */
/*        Note: You must include WINDOWS.H and MMSYSTEM.H before            */
/*        including this file.                                              */
/*                                                                          */
/*        Copyright (c) 1991-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_AVIFMT
#define _INC_AVIFMT	100	/* version number * 100 + revision */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin_vfw32
#ifdef _MSC_VER
#pragma warning(disable:4200)
#endif

/* The following is a short description of the AVI file format.  Please
 * see the accompanying documentation for a full explanation.
 *
 * An AVI file is the following RIFF form:
 *
 *	RIFF('AVI'
 *	      LIST('hdrl'
 *		    avih(<MainAVIHeader>)
 *                  LIST ('strl'
 *                      strh(<Stream header>)
 *                      strf(<Stream format>)
 *                      ... additional header data
 *            LIST('movi'	
 *      	  { LIST('rec'
 *      		      SubChunk...
 *      		   )
 *      	      | SubChunk } ....	
 *            )
 *            [ <AVIIndex> ]
 *      )
 *
 *	The main file header specifies how many streams are present.  For
 *	each one, there must be a stream header chunk and a stream format
 *	chunk, enlosed in a 'strl' LIST chunk.  The 'strf' chunk contains
 *	type-specific format information; for a video stream, this should
 *	be a BITMAPINFO structure, including palette.  For an audio stream,
 *	this should be a WAVEFORMAT (or PCMWAVEFORMAT) structure.
 *
 *	The actual data is contained in subchunks within the 'movi' LIST
 *	chunk.  The first two characters of each data chunk are the
 *	stream number with which that data is associated.
 *
 *	Some defined chunk types:
 *           Video Streams:
 *                  ##db:	RGB DIB bits
 *                  ##dc:	RLE8 compressed DIB bits
 *                  ##pc:	Palette Change
 *
 *           Audio Streams:
 *                  ##wb:	waveform audio bytes
 *
 * The grouping into LIST 'rec' chunks implies only that the contents of
 *   the chunk should be read into memory at the same time.  This
 *   grouping is used for files specifically intended to be played from
 *   CD-ROM.
 *
 * The index chunk at the end of the file should contain one entry for
 *   each data chunk in the file.
 *
 * Limitations for the current software:
 *	Only one video stream and one audio stream are allowed.
 *	The streams must start at the beginning of the file.
 *
 *
 * To register codec types please obtain a copy of the Multimedia
 * Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 */


#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

/* Macro to make a TWOCC out of two characters */
#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

typedef WORD TWOCC;

/* form types, list types, and chunk types */
#define formtypeAVI             mmioFOURCC('A', 'V', 'I', ' ')
#define listtypeAVIHEADER       mmioFOURCC('h', 'd', 'r', 'l')
#define ckidAVIMAINHDR          mmioFOURCC('a', 'v', 'i', 'h')
#define listtypeSTREAMHEADER    mmioFOURCC('s', 't', 'r', 'l')
#define ckidSTREAMHEADER        mmioFOURCC('s', 't', 'r', 'h')
#define ckidSTREAMFORMAT        mmioFOURCC('s', 't', 'r', 'f')
#define ckidSTREAMHANDLERDATA   mmioFOURCC('s', 't', 'r', 'd')
#define ckidSTREAMNAME		mmioFOURCC('s', 't', 'r', 'n')

#define listtypeAVIMOVIE        mmioFOURCC('m', 'o', 'v', 'i')
#define listtypeAVIRECORD       mmioFOURCC('r', 'e', 'c', ' ')

#define ckidAVINEWINDEX         mmioFOURCC('i', 'd', 'x', '1')

/*
** Stream types for the <fccType> field of the stream header.
*/
#define streamtypeVIDEO         mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO         mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI		mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT          mmioFOURCC('t', 'x', 't', 's')

/* Basic chunk types */
#define cktypeDIBbits           aviTWOCC('d', 'b')
#define cktypeDIBcompressed     aviTWOCC('d', 'c')
#define cktypePALchange         aviTWOCC('p', 'c')
#define cktypeWAVEbytes         aviTWOCC('w', 'b')

/* Chunk id to use for extra chunks for padding. */
#define ckidAVIPADDING          mmioFOURCC('J', 'U', 'N', 'K')


/*
** Useful macros
**
** Warning: These are nasty macro, and MS C 6.0 compiles some of them
** incorrectly if optimizations are on.  Ack.
*/

/* Macro to get stream number out of a FOURCC ckid */
#define FromHex(n)	(((n) >= 'A') ? ((n) + 10 - 'A') : ((n) - '0'))
#define StreamFromFOURCC(fcc) ((WORD) ((FromHex(LOBYTE(LOWORD(fcc))) << 4) + \
                                             (FromHex(HIBYTE(LOWORD(fcc))))))

/* Macro to get TWOCC chunk type out of a FOURCC ckid */
#define TWOCCFromFOURCC(fcc)    HIWORD(fcc)

/* Macro to make a ckid for a chunk out of a TWOCC and a stream number
** from 0-255.
*/
#define ToHex(n)	((BYTE) (((n) > 9) ? ((n) - 10 + 'A') : ((n) + '0')))
#define MAKEAVICKID(tcc, stream) \
        MAKELONG((ToHex((stream) & 0x0f) << 8) | \
			    (ToHex(((stream) & 0xf0) >> 4)), tcc)


/*
** Main AVI File Header
*/	
		
/* flags for use in <dwFlags> in AVIFileHdr */
#define AVIF_HASINDEX		0x00000010	// Index at end of file?
#define AVIF_MUSTUSEINDEX	0x00000020
#define AVIF_ISINTERLEAVED	0x00000100
#define AVIF_WASCAPTUREFILE	0x00010000
#define AVIF_COPYRIGHTED	0x00020000

/* The AVI File Header LIST chunk should be padded to this size */
#define AVI_HEADERSIZE  2048                    // size of AVI header list

typedef struct
{
    DWORD		dwMicroSecPerFrame;	// frame display rate (or 0L)
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwPaddingGranularity;	// pad to multiples of this
                                                // size; normally 2K.
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwTotalFrames;		// # frames in file
    DWORD		dwInitialFrames;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwReserved[4];
} MainAVIHeader;


/*
** Stream header
*/

#define AVISF_DISABLED			0x00000001

#define AVISF_VIDEO_PALCHANGES		0x00010000

typedef struct {
    FOURCC		fccType;
    FOURCC		fccHandler;
    DWORD		dwFlags;	/* Contains AVITF_* flags */
    WORD		wPriority;
    WORD		wLanguage;
    DWORD		dwInitialFrames;
    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwStart;
    DWORD		dwLength; /* In units above... */
    DWORD		dwSuggestedBufferSize;
    DWORD		dwQuality;
    DWORD		dwSampleSize;
    RECT		rcFrame;
} AVIStreamHeader;

/* Flags for index */
#define AVIIF_LIST          0x00000001L // chunk is a 'LIST'
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.
#define AVIIF_FIRSTPART     0x00000020L // this frame is the start of a partial frame.
#define AVIIF_LASTPART      0x00000040L // this frame is the end of a partial frame.
#define AVIIF_MIDPART       (AVIIF_LASTPART|AVIIF_FIRSTPART)

#define AVIIF_NOTIME	    0x00000100L // this frame doesn't take any time
#define AVIIF_COMPUSE       0x0FFF0000L // these bits are for compressor use

typedef struct
{
    DWORD		ckid;
    DWORD		dwFlags;
    DWORD		dwChunkOffset;		// Position of chunk
    DWORD		dwChunkLength;		// Length of chunk
} AVIINDEXENTRY;


/*
** Palette change chunk
**
** Used in video streams.
*/
typedef struct
{
    BYTE		bFirstEntry;	/* first entry to change */
    BYTE		bNumEntries;	/* # entries to change (0 if 256) */
    WORD		wFlags;		/* Mostly to preserve alignment... */
    PALETTEENTRY	peNew[];	/* New color specifications */
} AVIPALCHANGE;

// end_vfw32

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif /* _INC_AVIFMT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\bidi.h ===
/*****************************************************************************\
*                                                                             *
*               Version 4.00                                                  *
*                                                                             *
*               Copyright (c) 1985-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
******************************************************************************/

#ifndef NOBIDI
#define  BIDI_SYSTEM_FONT        17
#define  BIDI_VAR_FONT           18
#define  BIDI_SYSTEM_FIXED_FONT  19

#define  WS_EX_BIDI_NOICON   0x00008000L
#define  WS_EX_BIDI_MENU     0x00004000L
#define  WS_EX_BIDI_SCROLL   0x00002000L
#define  WS_EX_BIDI_CAPTION  0x00001000L

#define  MB_RTL_READING          0x0400
#define  MB_HEBREW_BUTTONS       0x0800
#define  MB_BIDIDEFMASK          0x0300

#define OFN_BIDIDIALOG               0x80000000
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\aviver.h ===
/*
 *  aviver.h - internal header file to define the build version for AVI
 *
 */

/*
 *  All strings MUST have an explicit \0
 *
 *  MMSYSRELEASE should be changed every build
 *
 *  Version string should be changed each build
 *
 *  Remove build extension on final release
 */

#include "vernum.h"

#define MMSYSVERSION            rmj
#define MMSYSREVISION           rmm
#define MMSYSRELEASE            rup

#if defined(DEBUG_RETAIL)
#define MMSYSVERSIONSTR     "Debug Version 1.00\0"
#elif defined(DEBUG)
#define MMSYSVERSIONSTR     "Internal Debug Version 1.00\0"
#else
//#define MMSYSVERSIONSTR      "Final Beta\0"
#define MMSYSVERSIONSTR     "Version 1.00\0"
#endif

#define OFFICIAL
#define FINAL			// we are at RC now

/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED

#define MMVERSIONCOMPANYNAME    "Microsoft Corporation\0"
#define MMVERSIONPRODUCTNAME    "Microsoft Video For Windows\0"
#define MMVERSIONCOPYRIGHT      "Copyright \251 Microsoft Corp. 1991-1992\0"

/*
 *  Version flags
 */

#ifndef OFFICIAL
#define MMVER_PRIVATEBUILD      VS_FF_PRIVATEBUILD
#else
#define MMVER_PRIVATEBUILD      0
#endif

#ifndef FINAL
#define MMVER_PRERELEASE        VS_FF_PRERELEASE
#else
#define MMVER_PRERELEASE        0
#endif

#if defined(DEBUG_RETAIL)
#define MMVER_DEBUG             VS_FF_DEBUG
#elif defined(DEBUG)
#define MMVER_DEBUG             VS_FF_DEBUG
#else
#define MMVER_DEBUG             0
#endif

#define MMVERSIONFLAGS          (MMVER_PRIVATEBUILD|MMVER_PRERELEASE|MMVER_DEBUG)
#define MMVERSIONFILEFLAGSMASK  0x0000003FL


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\capdll.h ===
/* CAPDLL.h
 *
 * Capture DLL.
 *
 * (C) Copyright Microsoft Corporation 1991. All rights reserved.
 */

/* flat addressing  - Get a selector to the memory */
LPSTR FAR PASCAL CreatePhysicalSelector( DWORD dwBase, WORD wLimit );

/* Interrupt enable/disable */
WORD FAR PASCAL IRQEnable( void );
WORD FAR PASCAL IRQDisable( void );

/* check to see if card is there */
WORD FAR PASCAL videoInDetect( WORD wBase );

/* Targa card init/fini */
WORD FAR PASCAL TargaInit( WORD wBase, BYTE bIRQ, BYTE bAddress );
void FAR PASCAL TargaFini( void );

/* Assumes TargaInit has been called */
/* Return the value in the advanced reg */
WORD FAR PASCAL TargaAdvancedVal( void );

/* Set the border colour on the targa card */
void FAR PASCAL TargaBorder( WORD wColour );

/* Set the targa memory to the given colour */
void FAR PASCAL TargaFill( WORD wColour );

/* Set the Zoom bits of the MODE2 regester */
void FAR PASCAL TargaZoom( WORD wZoom );

#define ZOOM_1		0
#define ZOOM_2		1
#define ZOOM_4		2
#define ZOOM_8		3


/* Set the Display Mode bits of the MODE2 regester */
void FAR PASCAL TargaDispMode( WORD wDisp );

#define DISP_MEM_BORDER		0
#define DISP_LIVE_BORDER	1
#define DISP_MEM		2
#define DISP_LIVE		3


/* Set/Clear the Genlock bit of the MODE2 regester  */
void FAR PASCAL TargaGenlockBit( BOOL fSet );


/* Set/Clear the Capture bit of the MODE2 regester  */
void FAR PASCAL TargaCaptureBit( BOOL fSet );

/* Capture a frame from the targa card */
BOOL FAR PASCAL CaptureFrame( LPBITMAPINFO lpbi, LPBYTE lpBits );

/* Calculate the new translation table from the palette */
BOOL FAR PASCAL TransRecalcPal( HPALETTE hPal );
BOOL FAR PASCAL TransSet( LPBYTE );

/* Where is the input coming from? */
void FAR PASCAL CapRGB( void );
void FAR PASCAL CapSVideo( void );
void FAR PASCAL CapComp( void );

DWORD FAR PASCAL videoInError( void );



/* Memory list structure */
typedef struct _DIBNode {
    DWORD       dwBufferLength;         // length of data buffer
    DWORD       dwFlags;                // assorted flags (see defines)
    DWORD       reserved;               // reserved for driver
    struct _DIBNode FAR *	fpdnNext;
    struct _DIBNode FAR *	fpdnPrev;
    DWORD	ckid;
    DWORD	cksize;
    BYTE	abBits[0];
} DIBNode;

typedef DIBNode FAR * FPDIBNode;

#define VIDEOIN_PREPARED	1
#define VIDEOIN_DONE		2


/* Video routines for AVI capture */
WORD FAR PASCAL videoInOpen( DWORD dwTime );
WORD FAR PASCAL videoInClose( void );
WORD FAR PASCAL videoInAddBuffer( FPDIBNode fpdn );
WORD FAR PASCAL videoInUnprepareBuffer( FPDIBNode fpdn );
WORD FAR PASCAL videoInPrepareBuffer( FPDIBNode fpdn );
WORD FAR PASCAL videoInReset( void );
WORD FAR PASCAL videoInStart( void );
WORD FAR PASCAL videoInStop( void );
DWORD FAR PASCAL videoInGetPos( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\meddibs.h ===
/* 
 * MEDDIBS.H
 * 
 * This is the external definition of the video converter handlers.
 *
 * This file requires "windows.h", "mediaman.h"
 */

#ifndef _MEDDIBS_H_
#define _MEDDIBS_H_

#define medtypeDIBS	medFOURCC('D','I','B','S')	// logical type

#define medtypeIRLE	medFOURCC('I','R','L','E')	// 'rle' format
#define medtypeRLE0	medFOURCC('R','L','E','0')	// 'rle0' format
#define medtypeMERI	medFOURCC('M','E','R','I')	
#define medtypeFLI	medFOURCC('F','L','I',' ')	// Autodesk .fli
#define medtypeDIBSEQ	medFOURCC('D','S','E','Q')	// DIB sequence

#define medtypeAVID	medFOURCC('A','V','I',' ')	// AVI DIBS
#define medtypeAVI0	medFOURCC('A','V','I','0')	// Old AVI
#define medtypeAVIW	medFOURCC('A','V','I','W')	// AVI WAVE
#define medtypeAVIP	medFOURCC('A','V','I','P')	// AVI Palette
#define medtypeAVIM	medFOURCC('A','V','I','M')	// AVI MIDI
#define medtypeAVIMDIB	medFOURCC('M','D','B','A')	// AVI MDIB

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif




#define DIBSF_NONINTERLEAVED	0x0001

#define DIBSF_NOPADDING		0x0040
#define DIBSF_VARIABLESIZEREC	0x0080

#define DIBSC_RANDOMACCESS	0x00000001
#define DIBSC_USEABLERANDOM	0x00000002
#define	DIBSC_FASTACCESS	0x00000004

// The flag below is used if the handler supports quality, key frames, etc.
#define DIBSC_EXTENDEDINFO	0x00000008  

#define DIBSC_KNOWSLENGTH	0x00000010
#define DIBSC_RETURNSFULLFRAMES	0x00000020

#define DIBS_GETINFO		(MED_USER)
typedef struct {
    DWORD	dwFlags;
    DWORD	dwCapabilities;
    DWORD	dwWidth;
    DWORD	dwHeight;
    DWORD       dwBytesPerSec;              /* if not zero. */
    DWORD	dwMicroSecPerFrame;
    DWORD       dwStreams;

    DWORD       dwQuality;
    DWORD       dwFoo;

    DWORD       dwKeyFrameEvery;
    DWORD       dwAudioEvery;

} DIBSINFO;

/* quality flags */
#define ICQUALITY_LOW       0
#define ICQUALITY_HIGH      10000
#define ICQUALITY_DEFAULT   -1

typedef struct {
    DIBSINFO	di;
    DWORD	dwFrames;
    MEDTYPE	medtypePhys;
} DIBSCREATE;

#define DIBS_GETSTREAMTYPE	(MED_USER+1)

/* Define stream types here.... */
#define DIBS_STREAM_VIDEO		medFOURCC('v', 'i', 'd', 's')
#define DIBS_STREAM_AUDIO		medFOURCC('a', 'u', 'd', 's')
#define DIBS_STREAM_MIDI 		medFOURCC('m', 'i', 'd', 's')
#define DIBS_STREAM_TEXT 		medFOURCC('t', 'x', 't', 's')

#define DIBS_GETSTREAMFORMAT	(MED_USER+2)
#define DIBS_GETSTREAMHANDLER	(MED_USER+3)
#define DIBS_GETHANDLERDATA	(MED_USER+4)
#define DIBS_GETFRAMEDATA	(MED_USER+5)
#define DIBS_GETLENGTH		(MED_USER+6)
#define DIBS_GETKEYFRAMEINFO	(MED_USER+7)
#define DIBS_GETFILESIZE	(MED_USER+8)
#define DIBS_GETFRAMESIZE	(MED_USER+9)
#define DIBS_GETRAWDATA		(MED_USER+10)

#define DIBS_VID_KEYFRAME	0x01000000L
#define DIBS_VID_PERCENT(dwRet)	LOBYTE(HIWORD(dwRet))
#define DIBS_VID_HDIB(dwRet)	((HANDLE) LOWORD(dwRet))

#define MediaDibsSetError(ERR) medSetExtError(ERR, ghInst)


/* lParam1 = buffer, lParam2 = buffer length.  return = data size */
#define MED_GETEXTRACHUNKS	0x0080



/* Should the structure below even be public? */
typedef struct {
	DIBSINFO	di;
	DWORD		dwFrames;
	HMED		hMed;
	DWORD		dwFileLength;
	DWORD		dwFrame;
	MEDTYPE		medTypeCurrent;
	MEDID		medidOld;
	HANDLE		hColors;
	BITMAPINFOHEADER bih;
#if 0	
	MEDID		medidWAVE;
	MEDID		medidMIDI;
	FOURCC		fccVideoCompType;
	LPSTR		lpVCParms;
	DWORD		dwVCLen;
	FOURCC		fccAudioCompType;
	LPSTR		lpACParms;
	DWORD		dwACLen;
#endif	
	DWORD		dwPhysData;
} MediaDibs, FAR * FPMediaDibs;

#define DIBSF_NONINTERLEAVED	0x0001

#define DIBSF_VARIABLESIZEREC	0x0080
#define DIBSF_ALREADYCOMPRESSED	0x0100


#define OLDRLEF_MERGECOLORS	0x0010
#define OLDRLEF_SKIPSINGLE	0x0020
#define OLDRLEF_ADAPTIVE	0x0040


#define DIBSF_SPECIAL		0x1000
#define DIBSF_SPECIAL2		0x2000



/* ERROR MESSAGE DEFINITIONS, must be greater than 100 */

#define ERRCNV_BAD_HEADER		101
#define ERRCNV_MEMORY			102
#define ERRCNV_EOF			103
#define ERRCNV_NOVIDEO			104
#define ERRCNV_NOAUDIO			105
#define ERRCNV_NOT_FORM			120
#define ERRCNV_OPEN_INPUT		121
#define ERRCNV_OPEN_OUTPUT		122
#define ERRCNV_WRITING			129
#define ERRCNV_NOT_MERID		133
#define ERRCNV_NOTWRITE			143
#define ERRCNV_NOTREAD			144
#define ERRCNV_UNKNOWN			145
#define ERRCNV_SIZE			146
#define ERRCNV_IMAGE			147
#define ERRCNV_WAVEMEMORY		148
#define ERRCNV_BADMEDWAVEVERSION	160
#define ERRCNV_BADDSEQNAME		161
#define ERRCNV_DSEQTOOLONG		162
#define ERRCNV_CANTOPENCOMP             163
#define ERRCNV_DATARATETOOLOW           164
#define ERRCNV_CANTSTARTCOMP            165

#define ERRCNV_NOVIDEOSTREAM		170
#define ERRCNV_TWOVIDEOSTREAMS		171
#define ERRCNV_TWOAUDIOSTREAMS          172

#define ERRCNV_BADFORMAT                173
#define ERRCNV_MEDBITSNOTRUECOLOR	174
#define ERRCNV_ALPHAFORMAT		175
#define ERRCNV_NOPALETTE		176
#define ERRCNV_CHANGESEQNAME		177
#endif  /*  _MEDDIBS_H_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\mdkver.h ===
/*
 *  mdkver.h - internal header file to define the build version for post-1.0
 *	MDK.
 */

/* 
 *  All strings MUST have an explicit \0  
 *
 *  MMSYSRELEASE should be changed every build
 *
 *  Version string should be changed each build
 *
 *  Remove build extension on final release
 */

#include "vernum.h"

#define MMSYSVERSION            01
#define MMSYSREVISION           01
#define MMSYSRELEASE            rup

#if defined(DEBUG_RETAIL)
#define MMSYSVERSIONSTR     "MDK Debug Version 1.0c\0"
#elif defined(DEBUG)
#define MMSYSVERSIONSTR     "Internal Debug Version 1.0c\0"
#else 
#define MMSYSVERSIONSTR     "Version 1.0c\0"
#endif

#define OFFICIAL
#define FINAL

/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED

#define MMVERSIONCOMPANYNAME    "Microsoft Corporation\0"
#define MMVERSIONPRODUCTNAME    "Microsoft Windows\0"
#define MMVERSIONCOPYRIGHT      "Copyright \251 Microsoft Corp. 1991-1992\0"

/*
 *  Version flags 
 */

#ifndef OFFICIAL
#define MMVER_PRIVATEBUILD      VS_FF_PRIVATEBUILD
#else
#define MMVER_PRIVATEBUILD      0
#endif

#ifndef FINAL
#define MMVER_PRERELEASE        VS_FF_PRERELEASE
#else
#define MMVER_PRERELEASE        0
#endif

#if defined(DEBUG_RETAIL)
#define MMVER_DEBUG             VS_FF_DEBUG    
#elif defined(DEBUG)
#define MMVER_DEBUG             VS_FF_DEBUG    
#else
#define MMVER_DEBUG             0
#endif

#define MMVERSIONFLAGS          (MMVER_PRIVATEBUILD|MMVER_PRERELEASE|MMVER_DEBUG)
#define MMVERSIONFILEFLAGSMASK  0x0000003FL


VS_VERSION_INFO VERSIONINFO
FILEVERSION MMSYSVERSION,MMSYSREVISION, 0, MMSYSRELEASE
PRODUCTVERSION MMSYSVERSION,MMSYSREVISION, 0, MMSYSRELEASE
FILEFLAGSMASK MMVERSIONFILEFLAGSMASK
FILEFLAGS MMVERSIONFLAGS
FILEOS VOS_DOS_WINDOWS16
FILETYPE MMVERSIONTYPE
FILESUBTYPE MMVERSIONSUBTYPE
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
	BLOCK "040904E4"
	BEGIN
	    VALUE "CompanyName", MMVERSIONCOMPANYNAME
	    VALUE "FileDescription", MMVERSIONDESCRIPTION
            VALUE "FileVersion",  MMSYSVERSIONSTR
	    VALUE "InternalName", MMVERSIONNAME
	    VALUE "LegalCopyright", MMVERSIONCOPYRIGHT
            VALUE "OriginalFilename", MMVERSIONNAME
	    VALUE "ProductName", MMVERSIONPRODUCTNAME
	    VALUE "ProductVersion", MMSYSVERSIONSTR
	END

#ifdef INTL
        BLOCK "040904E4"
        BEGIN
            VALUE "CompanyName", MMVERSIONCOMPANYNAME
            VALUE "FileDescription", MMVERSIONDESCRIPTION
            VALUE "FileVersion", MMSYSVERSIONSTR      
            VALUE "InternalName", MMVERSIONNAME
            VALUE "LegalCopyright", MMVERSIONCOPYRIGHT
            VALUE "OriginalFilename", MMVERSIONNAME
            VALUE "ProductName", MMVERSIONPRODUCTNAME
            VALUE "ProductVersion", MMSYSVERSIONSTR
        END
#endif

    END

    BLOCK "VarFileInfo"
    BEGIN
        /* the following line should be extended for localized versions */
	VALUE "Translation", 0x409, 1252
    END

END

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\defdlg.h ===
#define DLGOPEN_CTL_MIN		20
#define DLGOPEN_CTL_MAX		30
#define DLGOPEN_EDIT		20
#define DLGOPEN_FILE_LISTBOX	21
#define DLGOPEN_DIR_LISTBOX	22
#define DLGOPEN_PATH		23
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\dispdib.h ===
/****************************************************************************/
/*                                                                          */
/*        DISPDIB.H - Include file for DisplayDib() function.               */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/


// DisplayDib() error return codes
#define DISPLAYDIB_NOERROR          0x0000  // success
#define DISPLAYDIB_NOTSUPPORTED     0x0001  // function not supported
#define DISPLAYDIB_INVALIDDIB       0x0002  // null or invalid DIB header
#define DISPLAYDIB_INVALIDFORMAT    0x0003  // invalid DIB format
#define DISPLAYDIB_INVALIDTASK      0x0004  // not called from current task
#define DISPLAYDIB_STOP             0x0005  // stop requested

// flags for <wFlags> parameter of DisplayDib()
#define DISPLAYDIB_NOPALETTE        0x0010  // don't set palette
#define DISPLAYDIB_NOCENTER         0x0020  // don't center image
#define DISPLAYDIB_NOWAIT           0x0040  // don't wait before returning
#define DISPLAYDIB_NOIMAGE          0x0080  // don't draw image
#define DISPLAYDIB_ZOOM2            0x0100  // stretch by 2
#define DISPLAYDIB_DONTLOCKTASK     0x0200  // don't lock current task
#define DISPLAYDIB_TEST             0x0400  // testing the command
#define DISPLAYDIB_NOFLIP           0x0800  // dont page flip
#define DISPLAYDIB_BEGIN            0x8000  // start of multiple calls
#define DISPLAYDIB_END              0x4000  // end of multiple calls

#define DISPLAYDIB_MODE             0x000F  // mask for display mode
#define DISPLAYDIB_MODE_DEFAULT     0x0000  // default display mode
#define DISPLAYDIB_MODE_320x200x8   0x0001  // 320-by-200
#define DISPLAYDIB_MODE_320x400x8   0x0002  // 320-by-400	/* ;Internal */
#define DISPLAYDIB_MODE_360x480x8   0x0003  // 360-by-480	/* ;Internal */
#define DISPLAYDIB_MODE_320x480x8   0x0004  // 320-by-480	/* ;Internal */
#define DISPLAYDIB_MODE_320x240x8   0x0005  // 320-by-240

#ifdef WIN32
// flags for the 32 bit version of DisplayDibEx
#define DISPLAYDIB_ANIMATE          0x00010000
#define DISPLAYDIB_HALFTONE         0x00020000
#endif


// function prototypes
UINT FAR PASCAL DisplayDib(LPBITMAPINFOHEADER lpbi, LPSTR lpBits, UINT wFlags);
UINT FAR PASCAL DisplayDibEx(LPBITMAPINFOHEADER lpbi, int x, int y, LPSTR lpBits, UINT wFlags);

#define DisplayDibBegin() DisplayDib(NULL, NULL, DISPLAYDIB_BEGIN)
#define DisplayDibEnd()   DisplayDib(NULL, NULL, DISPLAYDIB_END)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\medbits.h ===
/* (C) Copyright Microsoft Corporation 1991.  All Rights Reserved */
/* 
 * MEDBITS.H
 * 
 * Contains definition of the change structure for MBIT and HDIB
 * resources.  It should be used by all users of these resource types.
 * 
 * This file requires "windows.h" and "mediaman.h"
 */

#ifndef _MEDBITS_H_
#define _MEDBITS_H_

/*  Defintions that windows forgot  */
typedef RGBQUAD FAR	*LPRGBQUAD;
typedef RGBQUAD NEAR	*NPRGBQUAD;
typedef PALETTEENTRY NEAR *NPPALETTEENTRY;

/*
 *  MDIB HANDLER
 */

#define medtypeMDIB	medFOURCC('M', 'D', 'I', 'B')

/*  Associated physical handlers  */
#define medtypeRDIB	medFOURCC('R', 'D', 'I', 'B')
#define medtypePCX	medFOURCC('P', 'C', 'X', ' ')
#define medtypePICT	medFOURCC('P', 'I', 'C', 'T')
#define medtypeGIF	medFOURCC('G', 'I', 'F', ' ')
#define medtypeTGA	medFOURCC('T', 'G', 'A', ' ')
#define medtypeRLE	medFOURCC('R', 'L', 'E', ' ')
#define medtypeRRLE	medFOURCC('R', 'R', 'L', 'E')


/* 
 * Structure used for creation of MDIB resources.
 */
typedef struct _MDIBCreateStruct {
	DWORD		dwWidth;
	DWORD		dwHeight;
	WORD		wDepth;
	MEDID		medidPalette;
	WORD		wPalSize;
	BOOL		fRGBQuads;
	LPPALETTEENTRY	lpPalEntries;
} MDIBCreateStruct;
typedef MDIBCreateStruct FAR *FPMDIBCreateStruct;

#define mdibMAXPALETTESIZE	256

/*  MDIB messages  */
#define	MDIB_GETPALETTE		(MED_USER + 1)
#define MDIB_GETPALSIZE		(MED_USER + 2)
#define MDIB_GETPALMEDID	(MED_USER + 3)
#define MDIB_SETPALMEDID	(MED_USER + 4)
#define MDIB_SETSIZE		(MED_USER + 6)
#define MDIB_SETDEPTH		(MED_USER + 7)
#define MDIB_REMAP		(MED_USER + 8)

/*  Flags for MDIB_SETPALMEDID  */
#define MDIBSP_COPYPALRES	0x0001

// This flag was never implemented.  It never will be.  (davidmay 12/18/90)
// /*  Flags for accessing MDIB resources  */
// #define MDIBLOAD_NOYIELDING	0x0001

/*  MedUser-Notification messages for MDIB handler  */
#define MDIBCH_SIZE		(MED_USER + 2)
#define MDIBCH_DEPTH		(MED_USER + 3)
#define MDIBCH_REMAP		(MED_USER + 4)
#define MDIBCH_NEWPALMEDID	(MED_USER + 5)
#define MDIBCH_PALCHANGE	(MED_USER + 6)


/********************************************************/

/*
 *  MPAL HANDLER
 */

#define medtypeMPAL	medFOURCC('M','P','A','L')
#define medtypeDIBP	medFOURCC('D','I','B','P')
#define medtypeRDBP	medFOURCC('R','D','B','P')

typedef struct _MPALCreateStruct {
	HPALETTE	hPalette;
	WORD		wSize;
	BOOL		fRGBQuads;
	LPSTR		lpPalEntries;
} MPALCreateStruct;
typedef MPALCreateStruct FAR *FPMPALCreateStruct;
typedef MPALCreateStruct NEAR *NPMPALCreateStruct;
	

#define	MPAL_COPYPAL	(MED_USER + 1)	// return GDI copy of palette.
#define MPAL_GETPALETTE	(MED_USER + 2)	// get the current GDI palette object.
#define MPAL_SETPALETTE	(MED_USER + 3)	// set to new GDI palette. remaps
#define MPAL_GETPALSIZE	(MED_USER + 4)

#define MPAL_APPEND	(MED_USER + 5)
#define MPAL_DELETE	(MED_USER + 6)
#define MPAL_REPLACE	(MED_USER + 7)
#define MPAL_MOVE	(MED_USER + 8)

/*  Structures for MPAL_REPLACE and MPAL_DELETE  */
typedef struct {
	int		iEntryIndex;
	int		iNewIndex;
	WORD		wFlags;
} MPALEntry;
typedef MPALEntry FAR *FPMPALEntry;
typedef MPALEntry NEAR *NPMPALEntry;

#define MPALENT_CLOSEST		1
#define MPALENT_OLDINDEX	2
#define MPALENT_REPLACE		3

typedef struct {
	WORD		wNumEntries;
	MPALEntry	aDeletedEntries[1];
} MPALDeleteStruct;
typedef MPALDeleteStruct NEAR *NPMPALDeleteStruct;
typedef MPALDeleteStruct FAR *FPMPALDeleteStruct;

typedef struct {
	WORD		wNumEntries;
	WORD		wInsertPoint;
	WORD		wMovedEntries[1];
} MPALMoveStruct;
typedef MPALMoveStruct NEAR *NPMPALMoveStruct;
typedef MPALMoveStruct FAR *FPMPALMoveStruct;

typedef struct {
	WORD		wNumEntries;
	WORD		wInsertPoint;
	PALETTEENTRY	aInsertedColors[1];
} MPALReplaceStruct;
typedef MPALReplaceStruct NEAR *NPMPALReplaceStruct;
typedef MPALReplaceStruct FAR *FPMPALReplaceStruct;


/*  Change messages from/for the palette resource  */
#define MPALCH_CHANGE		(MED_USER + 1)

typedef struct {
	WORD		wNumNewEntries;
	WORD		wNumOldEntries;	// size of array
	HPALETTE	hPalette;
	WORD		wAction;
	WORD		wEntries[1];
} MPALRemapStruct;
typedef MPALRemapStruct NEAR *NPMPALRemapStruct;
typedef MPALRemapStruct FAR *FPMPALRemapStruct;

/*  Flags for hibyte of wEntries array in MPALChangeStruct  */
#define MPALR_FLAGMASK	0xff00
#define MPALR_ADD	0x8000
#define MPALR_DELETE	0x4000		// contains closest match index
#define MPALR_MOVE	0x2000		// contains new index
#define MPALR_EDIT	0x1000
#define MPALR_NEWOBJECT	0x0800

#endif  /*  _MEDBITS_H_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\ntavi.h ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1992. All rights reserved.

   Title:   ntavi.h - Definitions for the portable win16/32 version of AVI

   This file should be included by ALL AVI components that are built for NT.
   It provides AVI specific portable definitions that either do not belong
   in PORT1632.H or are not yet included in that file.

*****************************************************************************/


#include <port1632.h>

#if 0

Windows 3.1, from which most of the AVI code comes, uses #ifdef DEBUG
to control debug and retail build.  Windows NT on the other hand uses
DBG (as in #if DBG - note, not ifDEF) to control debug stuff.

For NT, we need the following paragraph in this single common header.

#endif

#ifdef WIN32
#undef DEBUG
#if DBG
    #define DEBUG
    #define STATICFN
    #define STATICDT
#else
    #define STATICFN static
    #define STATICDT static
#endif

#else    // !WIN32
    #define STATICFN static
    #define STATICDT static
#endif

/*
 * mciavi\ntavi.h provides definitions that are specific to mciavi.
 *
 * this file provides general definitions that are of use throughout
 * avi.
 */

#ifdef WIN32


/* --- Win32 version --------------------------------------------------- */

// To separate 32 bit drivers from their Win 16 equivalent we use a defined
// constant to let the code know in which INI file section to look

#define MCIAVI_SECTION (TEXT("MCIAVI"))       // To be changed to MCIAVI32 shortly

#ifdef I386
// __inline provides speed improvements for x86 platforms.  Unfortunately
// the MIPS compiler does not have inline support.  Alpha is unknown, so
// we do not assume and play it safe.
#define INLINE __inline
#else
#define INLINE
#endif

#define AVI_HTASK	DWORD
#define NPTSTR		LPTSTR

#if !defined(_ALPHA_) && !defined(_PPC_)
typedef RGBQUAD *	LPRGBQUAD;
#endif

//typedef HANDLE      HDRVR;

#define _FASTCALL

#define hmemcpy		memcpy

#undef EXPORT
#define EXPORT

#define _huge
#define huge

#else

/* --- Win16 version --------------------------------------------------- */


// To separate 32 bit drivers from their Win 16 equivalent we use a defined
// constant to let the code know in which INI file section to look
// The WIN16 version of MMDDK.H does not have these constants defined

#define DRIVERS_SECTION "Drivers"
#define MCI_SECTION "MCI"
#define MCIAVI_SECTION "MCIAVI"

#define	WIN16
#define WIN31

#define TEXT(a)		a
#define AVI_HTASK	HANDLE
#define NPTSTR		NPSTR
#define LPTSTR		LPSTR
#define TCHAR		char

#define _FASTCALL	_fastcall
#define INLINE		__inline     /* Always OK for Win 16 */
#define UNALIGNED

/*
 * define these so we can explicitly use Ansi versions for debugging etc
 */
#define GetProfileStringA		GetProfileString
#define GetPrivateProfileStringA	GetPrivateProfileString
#define GetProfileIntA			GetProfileInt
#define wvsprintfA			wvsprintf
#define wsprintfA			wsprintf
#define lstrcmpiA			lstrcmpi
#define lstrcpyA			lstrcpy
#define lstrcatA			lstrcat
#define lstrlenA			lstrlen
#define LoadStringA			LoadString	
#define OutputDebugStringA		OutputDebugString
#define MessageBoxA			MessageBox


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\medwave.h ===
/* 
 * MEDIAWAVE.H
 * 
 * There is the external definition of the WAVE
 * medai handlers.  DO NOT USE THIS STRUCTURE IN ANY WAY UNLESS YOU
 * ARE WRITING A MEDIA HANDLER!!!  This structure subject to change
 * without notice.
 *
 * This file requires "windows.h", "mediaman.h"
 */

#ifndef _MEDWAVE_H_
#define _MEDWAVE_H_

#define medtypeWAVE	medFOURCC('W','A','V','E')
#define medtypeAIFF	medFOURCC('A','I','F','F')
#define medtypePCM 	medFOURCC('P','C','M',' ')
#define medtypeCNVW	medFOURCC('C','N','V','W')
#define medtypeADPV	medFOURCC('A','D','P','V')
#define medtypeADPM	medFOURCC('A','D','P','M')

#define	CFNAME_WAVEEDIT		"WaveEditIntSound"


#define WAVE_GETSIZE	( MED_USER + 2 )
#define WAVE_CUT	( MED_USER + 3 )
#define WAVE_PASTE	( MED_USER + 4 )
#define WAVE_READ	( MED_USER + 5 )
#define WAVE_COPY	( MED_USER + 6 )
#define WAVE_GETDATA	( MED_USER + 9 )
#define WAVE_GETFMT	( MED_USER + 10 )
#define WAVE_GETFMTSIZE ( MED_USER + 11 )
#define WAVE_WRITE	( MED_USER + 12 )
#define WAVE_SETFMT	( MED_USER + 13 )
#define WAVE_REALIZE	( MED_USER + 14 )
#define WAVE_SETFMTNORESIZE	( MED_USER + 15 )


#define WAVE_PASTECHUNK	(MED_USER + 16)




/* HACK HACK a HWAVE is now defined in mmsystem.h */
/* Get around this by defining a different type. */
typedef DWORD MedWaveHWAVE;
#define HWAVE MedWaveHWAVE


typedef struct _WaveChange {
	int	nOperation;
	LONG	nPosition;
	LONG	nLength;
} WaveChangeStruct;

typedef WaveChangeStruct FAR * FPWaveChangeStruct;


typedef struct _WaveRead {
	LONG	nPosition;
	LONG	nLength;
	LPSTR	fpchBuffer;
} WaveReadStruct;

typedef WaveReadStruct FAR * FPWaveReadStruct;

typedef struct _WaveGetData {
	LONG	nChunkStart;
	LONG	nPosition;
	LONG	nLength;
	LPSTR	fpchBuffer;
} WaveGetDataStruct;

typedef WaveGetDataStruct FAR * FPWaveGetDataStruct;

typedef struct _WaveWrite {
	LONG	nLength;
	LPSTR	fpchBuffer;
} WaveWriteStruct;

typedef WaveWriteStruct FAR * FPWaveWriteStruct;


typedef struct _WavePasteChunk {
	LONG	nPosition;
	LONG	nLength;
	HMED	hMed;
} WavePasteChunkStruct;

typedef WavePasteChunkStruct FAR * FPWavePasteChunkStruct;




/* 
 * WARNING WARNING WARNING
 * 
 * Do not read below this line if you are not writing a wave physical
 * handler for use with the WAVE handlers.  The structure given
 * below is not for public consumption.
 * 
 */


#define HWaveSound( x )	HIWORD( x )
#define HWaveFmt( x )	LOWORD( x )



#define	WAVE_MED	1
#define	WAVE_TMEM	2
#define	WAVE_TMED	3
#define	WAVE_NONE	5

#define	WAVE_LINK	42

typedef WORD PWAVELINK;
typedef WORD PWAVELOC;

extern HPSTR	hpStorage;

typedef struct _WaveLocation {
    WORD	wType;			// the contents of the union
    WORD	wAccessCount;		// Access count
    LONG	nLength;		// Sample Length of the Block
    LONG	nStart;			// Offset in union u element
		// sample counts are in format stored in 
    union {
	    MEDID	medid;
	    struct _TmpMed NEAR *	pTmpMed;
	    struct _TmpMem NEAR *	pTmpMem;
        } u;
} WaveLocation;

typedef PWAVELOC	PWaveLocation;

#define MEDWAVE_ACCESS(p) (hpStorage + p * (DWORD) sizeof(WaveLocation))

#define PLOC(p)		((WaveLocation FAR *) MEDWAVE_ACCESS(p))

// typedef WaveLocation NEAR *PWaveLocation;


typedef struct _WaveLink {
	WORD			wType;
	PWAVELINK		pNext;
	PWAVELINK		pPrev;
	LONG			nStart;	// Starting sample # of the block
	LONG			nLength;// Sample Length of the Block
		// sample counts are in format wanted 
	PWAVELOC		pLoc;	// Where the data is
} WaveLink;

// typedef WaveLink NEAR *PWaveLink;
// typedef WaveLink FAR  *FPWaveLink;
typedef PWAVELINK	PWaveLink;

#define PLINK(p)	((WaveLink FAR *) MEDWAVE_ACCESS(p))
#define LINKLOC(p)	PLOC(PLINK(p)->pLoc)

typedef struct _MediaWave {
	MEDID			medidOld;
	MEDTYPE			medTypeCurrent;
	LONG			nSampleSize;
	WORD			cbSample;
	NPPCMWAVEFORMAT		pFmt;
	NPPCMWAVEFORMAT		pFmtWanted;
	HMED			hMed;
	PWAVELINK		pMedia;
} MediaWave;
typedef MediaWave FAR *FPMediaWave;



typedef struct _TmpMed {
    MEDID	medid;
    WORD	wAccessCount;
    LONG	nLength;
    MediaWave  Wave;
} TmpMed;

typedef TmpMed NEAR *PTmpMed;


typedef struct _TmpMem {
    HANDLE	hMem;
    WORD	wAccessCount;
    LONG	nLength;
    MediaWave  Wave;
} TmpMem;

typedef TmpMem NEAR *PTmpMem;





#define MediaWaveSetError(ERR) medSetExtError(ERR, ghInst)


/* ERROR MESSAGE DEFINITIONS, must be greater than 100 */

#define ERRCNV_READING			100
#define ERRCNV_SSND_OFFSET		101
#define ERRCNV_SSND_BLOCK		102
#define ERRCNV_SEEKING_FOR		103
#define ERRCNV_DATA_CREATE		104
#define ERRCNV_SSND_NOTFOUND		105
#define ERRCNV_COMM_ASCEND		109
#define ERRCNV_SEEK_START		110
#define ERRCNV_COMM_FIND		118
#define ERRCNV_NOT_AIFF			119
#define ERRCNV_OPEN_INPUT		121
#define ERRCNV_OPEN_OUTPUT		122
#define ERRCNV_NOT_RIFF			133
#define ERRCNV_NOT_WAVE			134
#define ERRCNV_BAD_FMT			135
#define ERRCNV_FMT_FIND			137
#define ERRCNV_DATA_FIND		138
#define ERRCNV_SSND_FIND		140
#define ERRCNV_ALLOC			141
#define ERRCNV_SAVE			142
#define ERRCNV_NOTWRITE			143
#define ERRCNV_NOTREAD			144



extern void	FAR PASCAL	MediaWaveFreeHWAVE( HWAVE hWave );



#endif  /*  _WAVE_H_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\mediaman.h ===
/* MEDIAMAN.H
 * 
 * Public header for the MMSys media element manager DLL
 * 
 * include after windows.h
 * 
 */

#ifndef _MEDMAN_H_
#define _MEDMAN_H_

/***************   MEDIAMAN TYPES  ****************/

typedef	DWORD	MEDID;
typedef	WORD	MEDGID;
typedef	DWORD	FOURCC;
typedef	FOURCC	MEDTYPE;

typedef	WORD	MEDMSG;
typedef	WORD	MEDUSER;

/***************  MEDINFO INSTANCE BLOCK  ****************/
/*
 *  Resource instance structure, passed around as MEDINFO.
 *  This structure definition may change, DO NOT DEPEND ON IT, but
 *  use access macros defined below instead!!
 */
typedef struct _MedInfoStruct {
	DWORD	wFlags;		// maybe duplicate fpEnt flags
	WORD	wAccessCount;
	WORD	wLockCount;
	DWORD	dwAccessRet;
	DWORD	dwLockRet;
	char	achInst[2];
} MedInfoStruct;
typedef MedInfoStruct FAR *MEDINFO;

/*  Instance data access macros  */
#define medInfoInstance(medinfo)	((LPSTR) &((medinfo)->achInst[0]))
#define medInfoAccessCount(medinfo)	((medinfo)->wAccessCount)
#define medInfoLockCount(medinfo)	((medinfo)->wLockCount)
#define medInfoLockRead(medinfo)	((medinfo)->wFlags & 0x0800)
#define medInfoLockWrite(medinfo)	((medinfo)->wFlags & 0x0400)

#define MedInfoInstance(medinfo)	medInfoInstance(medinfo)
#define MedInfoAccessCount(medinfo)	medInfoAccessCount(medinfo)
#define MedInfoLockCount(medinfo)	medInfoLockCount(medinfo)
#define MedInfoLockRead(medinfo)	medInfoLockRead(medinfo)
#define MedInfoLockWrite(medinfo)	medInfoLockWrite(medinfo)

		

/**********  RESOURCE HANDLER DECLARATION  *************/

typedef DWORD (FAR PASCAL MedHandler)
		(MEDID medid, MEDMSG medmsg, MEDINFO medinfo,
		 LONG lParam1, LONG lParam2);
typedef MedHandler FAR *FPMedHandler;

/*  Logical resource handler messages  */
#define	MED_INIT		0x0010
#define MED_UNLOAD		0x0011
#define MED_LOCK		0x0012
#define MED_UNLOCK		0x0013
#define MED_EXPEL		0x0014
#define MED_DESTROY		0x0015
#define MED_CREATE		0x0016
#define MED_TYPEINIT		0x0020
#define MED_TYPEUNLOAD		0x0021
#define MED_SETPHYSICAL		0x0022
#define MED_COPY		0x0023
#define MED_NEWNAME		0x0024

#define MED_PAINT		0x002A
#define MED_REALIZEPALETTE	0x002B
#define MED_GETPAINTCAPS	0x002C
#define MED_GETCLIPBOARDDATA	0x002D

/*  PaintCaps flags  */
#define	MMC_PALETTEINFO		0x0001
#define MMC_BOUNDRECT		0x0002
#define MMC_CLIPFORMAT		0x0003

/*  Paint message flags  */
#define MMP_NORMPAL		0x0000
#define MMP_NOPALETTE		0x0001
#define MMP_PALBACKGROUND	0x0002
#define MMP_SHRINKTOFIT		0x0010
#define MMP_DSTANDSRCRECTS	0x0020

/* Load/Save messages */
#define MED_GETLOADPARAM	0x0030
#define MED_PRELOAD		0x0031
#define MED_LOAD		0x0032
#define MED_POSTLOAD		0x0033
#define MED_FREELOADPARAM	0x0034
#define MED_GETSAVEPARAM	0x0035
#define MED_PRESAVE		0x0036
#define MED_SAVE		0x0037
#define MED_POSTSAVE		0x0038
#define MED_FREESAVEPARAM	0x0039

/*  Sent to resource users  */
#define	MED_CHANGE		0x0060

/* Messages sent to MedDiskInfoCallback */
#define MED_DISKCBBEGIN		0x0065
#define MED_DISKCBUPDATE	0x0066
#define MED_DISKCBEND		0x0067
#define MED_DISKCBNEWCONV	0x0068

/*  Minimum value available for type-defined messages  */
#define MED_USER		0x0200



/*****************  RESOURCE LOAD/SAVE  *******************/

typedef struct _MedDisk {
	WORD	wFlags;
	DWORD	dwMessageData;
	DWORD	dwRetVal;

	DWORD	dwInstance1;
	DWORD	dwInstance2;

	DWORD	dwParam1;
	DWORD	dwParam2;

	DWORD	dwCbInstance1;
	DWORD	dwCbInstance2;

	HWND	hwndParentWindow;
	MEDID	medid;

	DWORD	dwReserved1;
	DWORD	dwReserved2;
	DWORD	dwReserved3;
	DWORD	dwReserved4;
} MedDisk;
typedef MedDisk	FAR	*FPMedDisk;
typedef MedDisk	NEAR	*NPMedDisk;

/*  Flags for wFlags field  */
#define MEDF_DISKSAVE	0x0001		// save taking place
#define MEDF_DISKLOAD	0x0002		// load taking place
#define MEDF_DISKVERIFY	0x0004		// verify the file format on load

typedef HANDLE	HMEDIABATCH;

/* Macros to check status of load/save */
#define medIsDiskVerify(FPDISK)		\
	(((FPMedDisk) (FPDISK))->wFlags & MEDF_DISKVERIFY)
#define medIsDiskLoad(FPDISK)		\
	(((FPMedDisk) (FPDISK))->wFlags & MEDF_DISKLOAD)
#define medIsDiskSave(FPDISK)		\
	(((FPMedDisk) (FPDISK))->wFlags & MEDF_DISKSAVE)

/* Values returned by physical handlers to MED_LOAD & MED_SAVE messages */
#define MEDF_OK		1
#define MEDF_ABORT	2
#define MEDF_ERROR	3
#define MEDF_BADFORMAT	4
#define MEDF_NOTPROCESSED	0L

/* Callback type used for information on disk save/load status */
typedef WORD (FAR PASCAL MedDiskInfoCallback)
		(WORD wmsg, FPMedDisk fpDisk, LONG lParam,
		 WORD wPercentDone, LPSTR lpszTextStatus);
typedef MedDiskInfoCallback FAR *FPMedDiskInfoCallback;


/*  Functions used by info callbacks  */
void	FAR PASCAL	medDiskCancel(FPMedDisk fpDisk);
WORD	FAR PASCAL	medUpdateProgress(FPMedDisk fpDisk,
				WORD wPercentDone, LPSTR lpszTextStatus);


/*************  LOGICAL I/O ROUTINES  *****************/

typedef struct _MedReturn {
	MEDID	medid;
	DWORD	dwReturn;
} MedReturn;
typedef MedReturn FAR *FPMedReturn;
 
WORD FAR PASCAL medSave(MEDID medid, LONG lParam,
			BOOL fYield, FPMedDiskInfoCallback lpfnCb,
			LONG lParamCb);
WORD FAR PASCAL medSaveAs(MEDID medid, FPMedReturn medReturn,
			LPSTR lpszName, LONG lParam, BOOL fYield,
			FPMedDiskInfoCallback lpfnCb, LONG lParamCb);
WORD FAR PASCAL medAccess(MEDID medid, LONG lParam,
			FPMedReturn medReturn, BOOL fYield,
			FPMedDiskInfoCallback lpfnCb, LONG lParamCb);
void FAR PASCAL medRelease(MEDID medid, LONG lParam);
DWORD FAR PASCAL medLock(MEDID medid, WORD wFlags, LONG lParam);
void FAR PASCAL medUnlock(MEDID medid, WORD wFlags,
			DWORD dwChangeInfo, LONG lParam);
DWORD FAR PASCAL medSendMessage(MEDID medid, MEDMSG medmsg,
			LONG lParam1, LONG lParam2);
DWORD FAR PASCAL medSendPhysMessage(MEDID medid, MEDMSG medmsg,
			LONG lParam1, LONG lParam2);
BOOL FAR PASCAL medCreate(FPMedReturn medReturn,
			MEDTYPE medtype, LONG lParam);
BOOL FAR PASCAL medIsDirty(MEDID medid);
BOOL FAR PASCAL medSetDirty(MEDID medid, BOOL fDirty);
WORD FAR PASCAL medIsAccessed(MEDID medid);
BOOL FAR PASCAL medIsShared(MEDID medid);


MEDINFO FAR PASCAL medGetMedinfo(MEDID medid);
BOOL FAR PASCAL medReleaseResinfo(MEDID medid, MEDINFO medinfo);

DWORD FAR PASCAL medSendPhysTypeMsg(MEDID medid, MEDTYPE medTypePhysical,
			MEDMSG medmsg, LONG lParam1, LONG lParam2);

typedef struct _MedAccessStruct {
	MEDID			medid;
	LONG			lParamLoad;
	BOOL			fYield;
	HWND			hwndParent;
	FPMedDiskInfoCallback	lpfnCb;
	LONG			lParamCb;
	DWORD			dwReturn;
} MedAccessStruct;
typedef MedAccessStruct FAR *FPMedAccessStruct;

WORD FAR PASCAL medAccessIndirect(FPMedAccessStruct fpAccess, WORD wSize);

typedef struct _MedSaveStruct {
	MEDID			medid;
	LONG			lParamSave;
	BOOL			fYield;
	HWND			hwndParent;
	FPMedDiskInfoCallback	lpfnCb;
	LONG			lParamCb;
	LPSTR			lpszNewName;
	
	MEDID			medidReturn;
	DWORD			dwReturn;
} MedSaveStruct;
typedef MedSaveStruct FAR *FPMedSaveStruct;

WORD FAR PASCAL medSaveIndirect(FPMedSaveStruct fpSave, WORD wSize);
WORD FAR PASCAL medSaveAsIndirect(FPMedSaveStruct fpSave, WORD wSize);

		
/*
 *  BATCH CONVERSION
 */
WORD FAR PASCAL medAccessBatch(HMEDIABATCH hmedBatch, FPMedReturn medReturn,
			   BOOL fYield, WORD wFlags);
WORD FAR PASCAL medSaveBatch(HMEDIABATCH hmedBatch, BOOL fYield);
WORD FAR PASCAL medSaveAsBatch(HMEDIABATCH hmedBatch, MEDID medidExisting,
			   LPSTR lpszName, FPMedReturn medReturn,
			   BOOL fYield, WORD wResetFlags);

HMEDIABATCH FAR PASCAL medAllocBatchBuffer(MEDID medid, HWND hwnd,
			WORD wFlags, BOOL fLoad, DWORD dwMsgData,
			FPMedDiskInfoCallback lpfnCb, LONG lParamCb);
BOOL FAR PASCAL medResetBatchBuffer(HMEDIABATCH hmedbatch, MEDID medid,
			WORD wFlags);
BOOL FAR PASCAL medFreeBatchBuffer(HMEDIABATCH hmedbatch);

#define MEDBATCH_RESETUPDATECB	0x0001

/* Flags for medLock */
#define	MEDF_READ	0x0001
#define MEDF_WRITE	0x0002
/* Flags for medUnlock */
#define MEDF_CHANGED	0x0004
#define MEDF_NOCHANGE	0x0000


/****************  RESOURCE USER  ******************/

MEDUSER FAR PASCAL medRegisterUser(HWND hWnd, DWORD dwInst);
void FAR PASCAL medUnregisterUser(MEDUSER meduser);
void FAR PASCAL medSendUserMessage(MEDID medid, MEDMSG medmsg, LONG lParam);
BOOL FAR PASCAL medRegisterUsage(MEDID medid, MEDUSER meduser);
BOOL FAR PASCAL medUnregisterUsage(MEDID medid, MEDUSER meduser);


typedef struct _MedUserMsgInfo {
        MEDID           medid;
        LONG            lParam;
        MEDINFO         medinfo;
        DWORD           dwInst;
} MedUserMsgInfo;
typedef MedUserMsgInfo FAR *FPMedUserMsgInfo;

#ifndef MM_MEDNOTIFY
#define MM_MEDNOTIFY         0x3BA
#endif

// obsolete but still required by bitedit and paledit

typedef DWORD (FAR PASCAL MedUser)
 		(MEDID medid, MEDMSG medmsg, MEDINFO medinfo,
 		LONG lParam, DWORD dwInst);
typedef MedUser FAR *FPMedUser;
 
MEDUSER FAR PASCAL medRegisterCallback(FPMedUser lpfnUser, DWORD dwInst);


/****************  TYPE TABLE  *****************/

typedef struct _MedTypeInfo {
	BOOL		fValid;		// Is this entry valid?
	WORD		wFlags;		// type flags
	MEDTYPE		medtype;	// the type id
	FPMedHandler	lpfnHandler;	// handler function for this type
	WORD		wInstanceSize;	// the byte count of instance data
	WORD		wRefcount;	// reference count on this type
} MedTypeInfo;
typedef MedTypeInfo FAR *FPMedTypeInfo;

/*  Flags to medRegisterType  */
#define MEDTYPE_LOGICAL		0x0001
#define MEDTYPE_PHYSICAL	0x0002

/*  Type creation macros  */
#define medMEDTYPE( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

#define medFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

BOOL FAR PASCAL medRegisterType(MEDTYPE medtype, FPMedHandler lpfnHandler,
				WORD wFlags);
BOOL FAR PASCAL medUnregisterType(MEDTYPE medtype);
BOOL FAR PASCAL medGetTypeInfo(MEDTYPE medtype, FPMedTypeInfo fpInfo);
WORD FAR PASCAL medIterTypes(WORD wIndex, FPMedTypeInfo fpInfo);
FOURCC FAR PASCAL medStringToFourCC(LPSTR lpszString);
void FAR PASCAL medFourCCToString( FOURCC fcc, LPSTR lpszString);

MEDTYPE FAR PASCAL medGetLogicalType(MEDID medid);
MEDTYPE FAR PASCAL medGetPhysicalType(MEDID medid);
BOOL FAR PASCAL medSetPhysicalType(MEDID medid, MEDTYPE medtype);


/*************  MISC FUNCTIONS  *****************/

WORD FAR PASCAL medGetErrorText(DWORD wErrno, LPSTR lpszBuf, WORD wSize);
DWORD FAR PASCAL medGetError(void);
void FAR PASCAL medSetExtError(WORD wErrno, HANDLE hInst);
BOOL FAR PASCAL medClientInit(void);
BOOL FAR PASCAL medClientExit(void);
HANDLE FAR PASCAL medLoadHandlerDLL(LPSTR lpszDLLName);
BOOL FAR PASCAL medUnloadHandlerDLL(HANDLE hModule);


/*************  RESOURCE LOCATION  *****************/

MEDID FAR PASCAL medLocate(LPSTR lpszMedName, MEDTYPE medtype,
			WORD wFlags, LPSTR lpszMedPath);
MEDID FAR PASCAL medSubLocate(MEDID medidParent, MEDTYPE medtype,
			DWORD dwOffset, DWORD dwSize);
HANDLE FAR PASCAL medGetAliases(MEDID medid);
		
/* Flags for medLocate */
#define MEDF_LOCATE	0x0001
#define MEDF_MAKEFILE	0x0002
#define MEDF_MEMORYFILE	0x0004
#define MEDF_NONSHARED	0x0008

typedef struct _MedMemoryFileStruct {
	LPSTR	lpszBuf;
	DWORD	dwSize;
} MedMemoryFile;
typedef MedMemoryFile FAR *FPMedMemoryFile;

		     
typedef struct _MedFileInfo {
	WORD	wFlags;
	WORD	wFilesysType;
	MEDID	medidParent;
	DWORD	dwSize;
	DWORD	dwOffset;
	/*  Information on memory file system  */
	LPSTR	lpszMemory;
	DWORD	dwMemSize;
} MedFileInfo;
typedef MedFileInfo FAR *FPMedFileInfo;

#define	MEDFILE_SUBELEMENT	0x01
#define MEDFILE_NONSHARED	0x02

BOOL FAR PASCAL medGetFileInfo(MEDID medid, FPMedFileInfo fpInfo, WORD wSize);
WORD FAR PASCAL medGetFileName(MEDID medid, LPSTR lpszBuf, WORD wBufSize);

#define	MEDNAME_ERROR	0
#define MEDNAME_DYNAMIC	1
#define MEDNAME_MEMORY	2
#define MEDNAME_FILE	3


/***************************************
 *
 *	MEDIAMAN DLL ERROR MESSAGES
 *
 *	Should be less than 0x200.
 *
 ***************************************/
#define MMERR_NOERROR		0x0000
#define MMERR_TYPELISTMEM	0x0001
#define MMERR_BADHANDLER	0x0002
#define MMERR_TYPELISTDUPL	0x0003
#define MMERR_INVALIDTYPE	0x0004
#define MMERR_TYPEREFNOTZERO	0x0005
#define MMERR_WRONGHANDLERTYPE	0x0006

#define MMERR_GROUPTABLEMEMORY	0x0010
#define MMERR_GROUPSTRUCTMEMORY	0x0011
#define MMERR_GROUPSTRINGTABLE	0x0012
#define MMERR_GROUPENTRYTABLE	0x0013

#define MMERR_USERTABLEMEMORY	0x0014
#define RMERR_INVALIDMEDUSER	0x0015
#define MMERR_GLOBALUSERMEMORY	0x0016

#define MMERR_INVALIDSUBPARENT	0x0030
#define MMERR_NOFILEEXISTS	0x0031

#define MMERR_LOGONNAMESPACE	0x0040
#define MMERR_FILENAMESTEP	0x0041
#define MMERR_MEDNOTACCESSED	0x0042
#define MMERR_UNNAMEDELEMENT	0x0043
#define MMERR_DISKOPABORT	0x0044
#define	MMERR_NOTCORRECTFILE	0x0045
#define MMERR_COPYFAILED	0x0046
#define MMERR_DISKOPINPROGRESS	0x0047
#define MMERR_MEMORY		0x0048

#define MMERR_READOFWRITELOCKED		0x00E0
#define MMERR_WRITEOFWRITELOCKED	0x00E1

#define	MMERR_INVALIDDLLNAME	0x00F0
#define MMERR_COULDNOTLOADDLL	0x00F1
#define MMERR_BADLIBINIT	0x00F2
#define MMERR_INVALIDMODULE	0x00F3

#define MMERR_UNKNOWN		0x0100

#define MMERR_HMEDREAD		0x0101
#define MMERR_HMEDWRITE		0x0102
#define MMERR_HMEDGET		0x0103
#define MMERR_HMEDPUT		0x0104
#define MMERR_HMEDCLOSE		0x0105
#define MMERR_HMEDFIND		0x0106
#define MMERR_HMEDFINDANY	0x0107
#define MMERR_HMEDUNGET		0x0108
#define MMERR_HMEDALLOC		0x0109
#define MMERR_HMEDLOCK		0x010a
#define MMERR_GETFILEINFO	0x010b
#define MMERR_HMEDASCEND	0x010c
#define MMERR_STACKASCEND	0x010d
#define MMERR_HMEDDESCEND	0x010e
#define MMERR_DESCENDSPACE	0x010f
#define MMERR_DESCENDGET	0x0110
#define MMERR_STACKDESCEND	0x0111
#define MMERR_HMEDRESIZE	0x0112
#define MMERR_STACKRESIZE	0x0113
#define MMERR_HMEDCREATE	0x0114
#define MMERR_STACKCREATE	0x0115
#define MMERR_CREATESPACE	0x0116
#define MMERR_CREATEPUT		0x0117
#define MMERR_HMEDSIZE		0x0118
#define MMERR_HMEDLEVEL		0x0119
#define MMERR_HMEDCKID		0x011a
#define RMERR_MEDIDOPEN		0x011b
#define MMERR_WRITEONLY		0x011c
#define MMERR_READONLY		0x011d
#define MMERR_PREVERROR		0x011e
#define MMERR_EOF		0x011f
#define MMERR_BEGIN		0x0120
#define MMERR_IOERROR		0x0121
#define MMERR_UNGETROOM		0x0122
#define MMERR_GETFILENAME	0x0123
#define MMERR_FINDFIRST		0x0124
#define MMERR_OPEN		0x0125
#define MMERR_SEEKINIT		0x0126
#define MMERR_HMEDSEEK		0x0127
#define MMERR_READ		0x0128
#define MMERR_HMEDCFOPEN	0x0129
#define MMERR_MEDGCFCLOSE	0x0130
#define MMERR_WRITE		0x0131



#define MMERR_MAXERROR		0x0200





/***************************************
 *
 *	MEDIAMAN PHYSICAL IO DEFINITIONS
 *
 ***************************************/

typedef FOURCC CKID;
typedef FOURCC FORMTYPE;
typedef DWORD CKSIZE;

/* 
 * RIFF stack elements
 */

typedef int RIFFSTACKPLACE;
typedef void huge * HPVOID;


typedef struct riff_stack_element {
    CKID		nID;		/* TOS current chunk id */
    CKSIZE		cbSize;		/* TOS current chunk size */
    LONG		nOffset;	/* Stacked nOffset for prev chunk */
    LONG		nEnd;		/* Stacked nEnd for prev chunk */
    WORD		info;		/* Stacked info for prev chunk */
} RIFFSTACKELEM;

typedef RIFFSTACKELEM FAR * FPRIFFSTACKELEM;

/*
 * Storage System Handler routine type definition 
 */
typedef LONG (FAR PASCAL MIOHANDLER)       \
		(struct medElement far * hMed, WORD wFlags, \
			DWORD lParam1, DWORD lParam2 );
typedef MIOHANDLER FAR * FPMIOHANDLER;


#define MEDIO_DOS_STORAGE	0
#define MEDIO_MEM_STORAGE	1
#define MEDIO_CF_STORAGE	2

/*
 * Handle to Resource ( once opened ) 
 */
typedef struct medElement {
    LONG lData1;		/*  data 1 2 and 3 sections hold */
    LONG lData2;		/* info specific to the storage system */
    LONG lData3;		/* eg the dos file handle for dos files */
    MEDID medid;		/* medid opened */
    HANDLE hMem;		/* handle to the memory of the HMED */
    FPMIOHANDLER fpfnHandler;	/* storage system handler */
    LONG nInitOffset;		/* for sub-resources - offset of start */
    LONG nOffset;		/* for riff offset start of chunk to start */
				/* NOTE nOffset doesn't include nInitOffset */
    LONG nCurrent;		/* offset of end of current buffer */
    LONG nEnd;			/* offset of end of current chunk/file */
    LONG nLeft;			/* space in buff from eof(chunk) to buffend */
    LONG nGet;			/* number of chars left to read in buff */
    LONG nPut;			/* number of chars left to write in buff */
				/* NOTE nGet, nPut are mutually exclusive */
    LONG nSize;			/* size of information read into buffer */
    LONG nUnGet;		/* num of chars ungotten before buff start */
    WORD flags;			/* RIOF_ info 'temperary' like error */
    WORD info;			/* RIOI_ info 'permanent' eg. extendable*/
    LPSTR fpchPlace;		/* place to get/put next char in buffer */
    LPSTR fpchMax;		/* max position of Place - for seek, unget */
    LONG cbBuffer;		/* the full buffer size */
    RIFFSTACKPLACE nRiffTop;	/* current top of riff stack, -1 is nothing */
    FPRIFFSTACKELEM fpRiffStack;
				/* FP into the data to for Riff Stack */
				/* riff stack index top by nRiffTop */
    LPSTR fpchBuffer;		/* FP into the data for the Buffer */
    char data[1];		/* the actual buffer */
} MIOELEMENT;

typedef MIOELEMENT FAR * HMED;

/*
 * HMED flags 'temporary' info
 */
#define MIOF_OK		0	/* no info */
#define MIOF_EOF	1	/* have reached eof (or end of chunk) */
#define MIOF_READING	2	/* info has been read into buffer */
#define MIOF_WRITING	4	/* info has been written to buffer */
#define MIOF_UNGET	8	/* have ungotten before buff start */
#define MIOF_ERROR	16	/* have gotten some form of error */

#define MIOF_BUFF_EOF	64	/* EOF at buffer end */
#define MIOF_BUFF_ERROR	128	/* error at buffer end or 'fatal' error */
				/* fatal as in can not do any more IO */
				/* unlike the error you get for */
				/* trying to unget too many chars */
#define MIOF_AFTERCURR	256	/* the characters in the buffer are located */
				/* after the hMed->nCurrent */


/*
 * HMED info 'permanent' info
 */
#define MIOI_NOTHING		0	/* no info */
#define MIOI_RESIZED		32	/* This chunk has been resized */
					/* possibly fix the size on ascend */
#define MIOI_AUTOSIZED		64	/* This chunk has been created */
					/* fix the size on ascend */
#define MIOI_BYTESWAPPED	128	/* riff chunk sizes are byteswapped */
#define MIOI_EXTENDABLE		256	/* the resource is extendable */
					/* unlike riff chunks */


/*
 * Return values
 */
#define MED_EOF		(-1)		/* universal something wrong return */

/*
 * Resource mode to open resource as 
 */
#define MOP_READ	0
#define MOP_WRITE	1
#define MOP_READ_WRITE	2

#define MOP_PRELOAD	0x0008
#define MOP_CREATE	0x0010
#define MOP_ZEROBUFFER	0x0100


/* CLOSE return flags */
#define MCERR_OK		0x0000
#define MCERR_UNSPECIFIC	0x0001
#define MCERR_FLUSH		0x0002
#define MCERR_STORAGE		0x0004


/* 
 * seek flags
 */
#define MOPS_SET	1
#define MOPS_CUR	2
#define MOPS_END	4
#define MOPS_NONLOCAL	128
#define MOPS_EXTEND	64



/*
 * Resize Chunk Flags
 */
#define MOPRC_AUTOSIZE		1

/* 
 * FUNCTION API's
 */
/* normal IO */
HMED FAR PASCAL medOpen( MEDID id, WORD wMode, WORD wSize );
WORD FAR PASCAL medClose( HMED hMed );
LONG FAR PASCAL medRead( HMED hMed, HPVOID hpBuffer, LONG lBytes );
LONG FAR PASCAL medWrite( HMED hMed, HPVOID hpBuffer, LONG lBytes );
LONG FAR PASCAL medSeek( HMED hMed, LONG lOffset, WORD wOrigin );

/* RIFF */
BOOL FAR PASCAL medAscend( HMED hMed );
CKID FAR PASCAL medDescend( HMED hMed );
CKID FAR PASCAL medCreateChunk(HMED hMed, CKID ckid, DWORD dwCkSize);
BOOL FAR PASCAL medResizeChunk(HMED hMed, DWORD dwCkSize, WORD wFlags);
int FAR PASCAL medGetChunkLevel( HMED hMed );
CKID FAR PASCAL medGetChunkID( HMED hMed );
CKSIZE FAR PASCAL medGetChunkSize( HMED hMed );
BOOL FAR PASCAL medFindAnyChunk( HMED hMed, CKID FAR * ackid );
BOOL FAR PASCAL medFindChunk( HMED hMed, CKID id );

LONG FAR PASCAL medGetSwapWORD( HMED hMed );  

/* 
 * FUNCTIONs used in macros and such
 */
LONG FAR PASCAL medIOFillBuff( HMED hMed, int size );
LONG FAR PASCAL medIOFlushBuff( HMED hMed, DWORD dwElem, int size );
BOOL FAR PASCAL medFlush( HMED hMed );
LONG FAR PASCAL medUnGet( HMED hMed, DWORD dwElem, int size );

/*
 * MACRO API's autodocked in riomac.d
 */
/* RIFF stuff */

#define medFCC3( fcc )	( (BYTE)( (fcc & 0xFF000000) >> 24 ) )
#define medFCC2( fcc )	( (BYTE)( (fcc & 0x00FF0000) >> 16 ) )
#define medFCC1( fcc )	( (BYTE)( (fcc & 0x0000FF00) >> 8 ) )
#define medFCC0( fcc )	( (BYTE)(fcc & 0x000000FF) )


/* constant RIFF chunk id */
#define ckidRIFF	medFOURCC( 'R', 'I', 'F', 'F' )
			  

/* lets the user set and check if the file is byteswapped */
#define medGetByteSwapped( hMed )	( (hMed)->info & MIOI_BYTESWAPPED )

#define medSetByteSwapped( hMed, fVal )   ( (hMed)->info = ( fVal ?       \
			( (hMed)->info | MIOI_BYTESWAPPED ) :		\
			~((~((hMed)->info))|MIOI_BYTESWAPPED) ) )


#define medHMEDtoMEDID( hMed )	( (hMed)->medid )

						
						

/*
 * UnGet Get and Put of BYTE WORD and DWORD and ByteSwapped versions 
 * NOTE the ByteSwap function is in WINCOM and so WINCOM.H must be included
 *	before the RESIO.H
 */						
#define medUnGetBYTE( hMed, ch )   ( (int)(medUnGet( hMed,(DWORD)ch,1 ) ) )
#define medUnGetWORD( hMed, w )	   ( (LONG)(medUnGet( hMed,(DWORD)w,2 ) ) )
#define medUnGetDWORD( hMed, dw )  ( (LONG)(medUnGet( hMed,(DWORD)dw,4) ) )
#define medUnGetSwapWORD(hMed,w)   ( medUnGetWORD( hMed,		\
						ByteSwapWORD((WORD)w) ) )
#define medUnGetSwapDWORD(hMed,dw) ( medUnGetDWORD( hMed,		\
						ByteSwapDWORD((DWORD)dw) ) )

#define medUnGetOpSwapWORD( hMed, w )   ( medGetByteSwapped( hMed ) ?	\
			medUnGetSwapWORD( hMed, w ) :			\
			medUnGetWORD( hMed, w ) )

#define medUnGetOpSwapDWORD( hMed, dw )   ( medGetByteSwapped( hMed ) ?	\
			medUnGetSwapDWORD( hMed, dw ) :			\
			medUnGetDWORD( hMed, dw ) )

							
							

#define medGetBYTE( hMed )	( (--((hMed)->nGet) >= 0) ?	             \
		(int)(BYTE)*(((hMed)->fpchPlace)++) :			     \
		(int)(medIOFillBuff( hMed, 1 )) )
						
#define medPutBYTE( hMed, ch )	( (--((hMed)->nPut) >= 0) ?                 \
		(int)(BYTE)((*(((hMed)->fpchPlace)++)) = (BYTE)ch) :	  \
		(int)(medIOFlushBuff(hMed,(DWORD)ch,1)) )
				
				
/* note in the following macros we want to advance the fpchPlace */
/* by the size after we get the value of it.  To do this we typecast */
/* them to int ( or long ) and add the size ( += size ) and then */
/* subtract 4 so the value used is not incremented yet */
							
							
#define medGetWORD( hMed )	( (((hMed)->nGet -= 2) >= 0) ?		     \
	(long)*((WORD FAR *)((((LONG)((hMed)->fpchPlace))+=2)-2)) :	     \
	(long)(medIOFillBuff( hMed, 2 )) )
					
#define medPutWORD( hMed, w )	( (((hMed)->nPut -= 2) >= 0) ?                 \
	(long)((*((WORD FAR *)((((LONG)((hMed)->fpchPlace))+=2)-2)))=(WORD)w) :\
	(long)(medIOFlushBuff( hMed, (DWORD)w, 2 )) )

#define medPutSwapWORD( hMed, w )  ( medPutWORD(hMed,ByteSwapWORD((WORD)w)) )
		
#define medGetOpSwapWORD( hMed )   ( medGetByteSwapped( hMed ) ?	\
			medGetSwapWORD( hMed ) :			\
			medGetWORD( hMed ) )

#define medPutOpSwapWORD( hMed, w )   ( medGetByteSwapped( hMed ) ?	\
			medPutSwapWORD( hMed, w ) :			\
			medPutWORD( hMed, w ) )




#define medGetDWORD( hMed )	( (((hMed)->nGet -= 4) >= 0) ?		     \
	(long)*((DWORD FAR *)((((LONG)((hMed)->fpchPlace))+=4)-4)) :	     \
	(long)(medIOFillBuff( hMed, 4 )) )
					
#define medPutDWORD( hMed, dw )	( (((hMed)->nPut -= 4) >= 0) ?                \
    (long)((*((DWORD FAR *)((((LONG)((hMed)->fpchPlace))+=4)-4)))=(DWORD)dw): \
    (long)(medIOFlushBuff( hMed, (DWORD)dw, 4 )) )

#define medGetSwapDWORD(hMed)    (ByteSwapDWORD((DWORD)medGetDWORD(hMed)))
#define medPutSwapDWORD(hMed,dw) (medPutDWORD(hMed,ByteSwapDWORD((DWORD)dw)))

#define medGetOpSwapDWORD( hMed )   ( medGetByteSwapped( hMed ) ?	\
			medGetSwapDWORD( hMed ) :			\
			medGetDWORD( hMed ) )

#define medPutOpSwapDWORD( hMed, dw )   ( medGetByteSwapped( hMed ) ?	\
			medPutSwapDWORD( hMed, dw ) :			\
			medPutDWORD( hMed, dw ) )


/* for RIFF, read the FORMTYPE */
#define medReadFormHeader( hMed )		medGetDWORD( hMed )
#define medWriteFormHeader( hMed, formtype )	medPutDWORD( hMed, formtype )
#define medGetFOURCC( hMed )			medGetDWORD( hMed )
#define medPutFOURCC( hMed, fcc )		medPutDWORD( hMed, fcc )

/* ERROR and EOF checks */
#define medGetIOError( hMed )	( (hMed)->flags & MIOF_ERROR )
#define medGetIOEOF( hMed )	( (hMed)->flags & MIOF_EOF )

#endif /* _MEDMAN_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\vernum.h ===
#ifndef WIN32
#define rmj		1
#define rmm		1
#define rup		92
#define szVerName	""
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\oldavift.h ===
/* aviffmt.h
 *
 * This header file describes the AVI File Format.
 *
 * Initial version: David Maymudes 1/7/91, based heavily on EricLe's avi0.h
 * Last updated: David Maymudes 12/5/91.
 *
 * Prerequisites: <windows.h>, <mmsystem.h>
 *
 * An AVI file is the following RIFF form:
 *
 *	RIFF('AVI'
 *	      LIST('hdrl')
 *		    hdra(<AVIFileHdr>)
 *		    dibh(<BITMAPINFO>)
 *		    [ wavf(<WAVEFORMAT>) ]
 *		    [ vidc(<COMPRESSIONINFO>) ]
 *		    [ audc(<COMPRESSIONINFO>) ]
 *		    [ JUNK(<padding>) ]
 *            LIST('movi'	
 *      	  { LIST('rec'
 *      		      SubChunk...
 *      		   )
 *      	      | SubChunk } ....	
 *            )
 *            [ <AVIIndex> ]
 *      )
 *
 *      SubChunk = { dibh(<AVI DIB header>)
 *      		| dibb(<AVI DIB bits>)
 *      		| dibc(<AVI compressed DIB bits>)
 *      		| palc(<AVI Palette Change>)
 *      		| wavb(<AVI WAVE bytes>)
 *      		| wavs(<AVI Silence record>)
 *      		| midi(<MIDI data>)
 *			| additonal custom chunks }
 *
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * We need a better description of the AVI file header here.
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *
 *
 * The grouping into LIST 'rec' chunks implies only that the contents of
 *   the chunk should be read into memory at the same time.  This
 *   grouping is only necessary for interleaved files.
 *
 * For loading efficiency, the beginning of each LIST 'rec' chunk may
 * be aligned on a 2K boundary.  (Actually, the beginning of the LIST
 * chunk should be 12 bytes before a 2K boundary, so that the data chunks
 * inside the LIST chunk are aligned.)
 *
 * If the AVI file is being played from CD-ROM in, it is recommended that
 * the file be padded.
 *
 *
 * Limitations for the Alpha release:
 *	If the AVI file has audio, each record LIST must contain exactly
 *	one audio chunk, which must be the first chunk.
 *	Each record must contain exactly one video chunk (possibly preceded
 *	by one or more palette change chunks).
 *	No wave format or DIB header chunks may occur outside of the header.
 */

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

/* form types, list types, and chunk types */
#define formtypeAVI		mmioFOURCC('A', 'V', 'I', ' ')
#define listtypeAVIHEADER	mmioFOURCC('h', 'd', 'r', 'l')
#define listtypeAVIRECORD	mmioFOURCC('r', 'e', 'c', ' ')
#define listtypeAVIMOVIE	mmioFOURCC('m', 'o', 'v', 'i')

#define ckidAVIHDR		mmioFOURCC('h', 'd', 'r', 'a')

#define ckidAVIINDEX		mmioFOURCC('i', 'n', 'd', 'x')
#define ckidAVINEWINDEX		mmioFOURCC('i', 'd', 'x', '1')

#define ckidAVIAuthorInfo	mmioFOURCC('a', 'v', 'i', 'a')
#define ckidAVIVideoCompInfo	mmioFOURCC('v', 'i', 'd', 'c')
#define ckidAVIAudioCompInfo	mmioFOURCC('a', 'u', 'd', 'c')
#define ckidAVIAdditionalInfo	mmioFOURCC('i', 'n', 'f', 'o')

#define ckidDIBheader   	mmioFOURCC('d', 'i', 'b', 'h')
#define ckidPALchange 		mmioFOURCC('p', 'a', 'l', 'c')
#define ckidDIBbits		mmioFOURCC('d', 'i', 'b', 'b')
#define ckidDIBcompressed	mmioFOURCC('d', 'i', 'b', 'c')
#define ckidDIBhalfframe	mmioFOURCC('d', 'i', 'b', 'x')
#define ckidCCCbits		mmioFOURCC('C', 'C', 'C', 'b')
#define BI_CCC      0x20434343

#define ckidWAVEformat		mmioFOURCC('w', 'a', 'v', 'f')
#define ckidWAVEbytes 		mmioFOURCC('w', 'a', 'v', 'b')
#define ckidWAVEsilence 	mmioFOURCC('w', 'a', 'v', 's')

#define ckidMIDIdata		mmioFOURCC('m', 'i', 'd', 'i')

#define ckidAVIPADDING		mmioFOURCC('J', 'U', 'N', 'K')
#define ckidOLDPADDING		mmioFOURCC('p', 'a', 'd', 'd')

// #define comptypeCCC		mmioFOURCC('C','C','C',' ')
#define comptypeRLE0		mmioFOURCC('R','L','E','0')
#define comptypeRLE		mmioFOURCC('R','L','E',' ')
#define comptypeDIB		mmioFOURCC('D','I','B',' ')
#define comptypeNONE		mmioFOURCC('N','O','N','E')

#define comptypePCM		mmioFOURCC('P','C','M',' ')

#define OLDRLEF_MERGECOLORS	0x0010
#define OLDRLEF_SKIPSINGLE	0x0020
#define OLDRLEF_ADAPTIVE	0x0040


/* flags for use in <dwFlags> in AVIFileHdr */
#define AVIF_HASWAVE		0x00000001
#define AVIF_HASMIDI		0x00000002
#define AVIF_HASINDEX		0x00000010	// Index at end of file?
#define AVIF_ISINTERLEAVED	0x00000100
#define AVIF_VARIABLESIZEREC	0x00000200
#define AVIF_NOPADDING		0x00000400
#define AVIF_ONEPALETTE		0x00001000	// No palette changes?

/* The AVI File Header LIST chunk should be padded to this size */
#define AVI_HEADERSIZE	2048			// size of AVI header list


typedef struct _AVIFileHdr
{
    DWORD		dwMicroSecPerFrame;	// frame display rate (or 0L)
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwPaddingGranularity;	// pad to multiples of this
					        // size; normally 2K.
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwTotalFrames;		// # frames in file
    DWORD		dwInitialVideoFrames;
    DWORD		dwNumAudioChunks;
    DWORD		dwAudioOffsetFrames;	// how many frames is audio
						// ahead of video in file?
} AVIFileHdr;


typedef struct _AVIWAVEheader
{
    PCMWAVEFORMAT	waveformat;		// or some other format
} AVIWAVEheader;

#ifndef WIN32
/*
 * this section not used and causes warnings on NT (zero-length arrays
 * are disallowed).
 */

// Note: no time information here: wave audio always starts at time 0,
// and continues without stopping.
typedef struct _AVIWAVEbytes
{
    BYTE		abBits[0];		// bits of audio
} AVIWAVEbytes;

typedef struct _AVIWAVEsilence
{
    DWORD		dwSamples;		// # samples with no sound
} AVIWAVEsilence;

/* Possibly, we shouldn't have a whole BITMAPINFOHEADER here. */
typedef struct _AVIDIBheader
{
    BITMAPINFOHEADER	bih;			// DIB header to use
    RGBQUAD		argbq[0];		// optional colors
} AVIDIBheader;


typedef struct _AVIDIBbits
{
    BYTE		abBits[0];		// bits of video
} AVIDIBbits;

typedef struct _AVIPALchange
{
    BYTE		bFirstEntry;	/* first entry to change */
    BYTE		bNumEntries;	/* # entries to change (0 if 256) */
    WORD		wFlags;		/* Mostly to preserve alignment... */
    PALETTEENTRY	peNew[];	/* New color specifications */
} AVIPALchange;

typedef struct _MIDIdata
{
    BYTE		abData[0];		// Raw MIDI data
} MIDIdata;
#endif //WIN32

#define AVIIF_LIST	0x00000001L
#define AVIIF_KEYFRAME	0x00000010L
typedef struct _AVIIndexEntry
{
    DWORD		ckid;
    DWORD		dwFlags;
    DWORD		dwChunkOffset;		// Position of chunk
    DWORD		dwChunkLength;		// Length of chunk
} AVIIndexEntry;

#ifndef WIN32
typedef struct tagCOMPRESSIONINFO
{
    DWORD		fccCompType;	/* Which compressor to use */
    BYTE		abData[];	/* Compressor-dependent data */
} COMPRESSIONINFO;

/* OBSOLETE BELOW THIS LINE */
/* flags for use in <dwAuthorFlags> in AVIAuthorInfo */
#define AVIF_PADTOMAX	0x0001			// pad records to maximum size
#define AVIF_IDENTITY	0x0002			// translate to identity palette

#define	AVIF_MERGECOLORS	0x0010		// use <wInterFrameThreshold>
#define AVIF_SKIPSINGLE		0x0020
#define	AVIF_FILTERFRAMES	0x0100		// use <wIntraFrameThreshold>
typedef struct _AVIAuthorInfo
{
    DWORD		dwAuthorFlags;		// flags provided at author time
    WORD		wInterFrameThreshold;
    WORD		wIntraFrameThreshold;
} AVIAuthorInfo;

#endif //WIN32

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\ver.h ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

#ifdef LIB

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

#endif /* LIB */

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\targa.h ===
/* 
 * 
 * Targa Plus definitions 
 * 
 * (C) Copyright Microsoft Corporation 1991. All rights reserved.
 */

/* Port Base for regesters */
#define REGBASE	0x0220


/* Advanced Direct regesters */
/* WRITE space */
#define W_COLOR0	0x0000
#define W_COLOR1	0x0001
#define W_COLOR2	0x0002
#define W_COLOR3	0x0003

#define W_VIDCON	0x0400
#define W_INDIRECT	0x0401
#define W_HUESAT	0x0402

#define W_MASKL		0x0800
#define W_MASKH		0x0801

#define W_MODE1		0x0C00
#define W_MODE2		0x0C01
#define W_WBL		0x0C02
#define W_WBH		0x0C03

/* READ space */
#define R_VIDSTAT	0x0000
#define R_CTL		0x0002
#define R_MASKL		0x0003

#define R_READAD	0x0401
#define R_MODE1		0x0402

#define R_USCAN		0x0800
#define R_MASKH		0x0801
#define R_OSCAN		0x0802

#define R_ROWCNT	0x0C00
#define R_MODE2		0x0C01
#define R_RBL		0x0C02
#define R_RBH		0x0C03







/* Advanced Indirect Regesters */

#define ADVANCED	0x90
#define MEMORY		0xA1




/* ADVANCED bit masks */
#define ADVANCED_SET_INAE	0x08
#define ADVANCED_CLEAR_INAE	0xF7
#define ADVANCED_SET_INT	0xC0
#define ADVANCED_CLEAR_INT	0x0F


/* MODE1 bit masks */
#define MODE1_CLEAR_MOD		0x00
#define MODE1_SET_MOD		0x40
#define MODE1_MEM_CLEAR_MOD	0x01
#define MODE1_MEM_SET_MOD	0x41

/* MEMORY bit masks */
#define MEMORY_SET_SIZE8	0x80
#define MEMORY_CLEAR_SIZE8	0x7F

#define MEMORY_SET_LINEAR	0x60

#define MEMORY_BASE_CLEAR	0xE1
#define MEMORY_BASE_1000	0x02
#define MEMORY_BASE_2000	0x04
#define MEMORY_BASE_3000	0x06
#define MEMORY_BASE_4000	0x08
#define MEMORY_BASE_5000	0x0A
#define MEMORY_BASE_6000	0x0C
#define MEMORY_BASE_7000	0x0E
#define MEMORY_BASE_8000	0x10
#define MEMORY_BASE_9000	0x12
#define MEMORY_BASE_A000	0x14
#define MEMORY_BASE_B000	0x16
#define MEMORY_BASE_C000	0x18
#define MEMORY_BASE_D000	0x1A
#define MEMORY_BASE_E000	0x1C
#define MEMORY_BASE_F000	0x1E
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\waveff.h ===
/****************************************************************************
 *
 *   waveff.h  - Audio Compression Manager File Formats Public Header File
 *
 *   Copyright (c) 1991-1992 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef _INC_WAVEFF
#define _INC_WAVEFF      /* #defined if waveff.h has been included */

#ifndef WAVE_FORMAT_PCM

/* general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT;
typedef WAVEFORMAT       *PWAVEFORMAT;
typedef WAVEFORMAT NEAR *NPWAVEFORMAT;
typedef WAVEFORMAT FAR  *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1

/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT;
typedef PCMWAVEFORMAT       *PPCMWAVEFORMAT;
typedef PCMWAVEFORMAT NEAR *NPPCMWAVEFORMAT;
typedef PCMWAVEFORMAT FAR  *LPPCMWAVEFORMAT;


#endif /* WAVE_FORMAT_PCM */



/* general extended waveform format structure */
/* Use this for all NON PCM formats */
/* (information common to all formats) */
typedef struct waveformat_extended_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
    WORD    wBitsPerSample;    /* Number of bits per sample of mono data */
    WORD    cbSize;	       /* The count in bytes of the size */
				    /* SPECIFY TOTAL OR EXTRA */
} WAVEFORMATEX;
typedef WAVEFORMATEX       *PWAVEFORMATEX;
typedef WAVEFORMATEX NEAR *NPWAVEFORMATEX;
typedef WAVEFORMATEX FAR  *LPWAVEFORMATEX;

/* Define data for MS ADPCM */
#define WAVE_FORMAT_ADPCM     2

typedef struct adpcmcoef_tag {
	short	iCoef1;
	short	iCoef2;
} ADPCMCOEFSET;
typedef ADPCMCOEFSET       *PADPCMCOEFSET;
typedef ADPCMCOEFSET NEAR *NPADPCMCOEFSET;
typedef ADPCMCOEFSET FAR  *LPADPCMCOEFSET;

typedef struct adpcmwaveformat_tag {
	WAVEFORMATEX	wfx;
	WORD		wSamplesPerBlock;
	WORD		wNumCoef;
	ADPCMCOEFSET	aCoef[];
} ADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT       *PADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT NEAR *NPADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT FAR  *LPADPCMWAVEFORMAT;




#endif  /* _INC_WAVEFF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\wincom.h ===
/****************************************************************************
 *
 *	WINCOM.H
 *
 *	Exported definitions for MM/Windows common code library.
 *
 ****************************************************************************/

#ifndef _WINCOM_H_
#define _WINCOM_H_


/*************************************
 *
 *	OPEN FILE DIALOG BOX
 *
 *************************************/

int FAR PASCAL OpenFileDialog(HWND hwndParent, LPSTR lpszTitle,
				LPSTR lpszExtension, WORD wFlags,
				LPSTR lpszFileBuf, WORD wFileLen );

/*  Flags for OpenFileDialog  */
#define DLGOPEN_MUSTEXIST	0x0001
#define DLGOPEN_NOSHOWSPEC	0x0002
#define DLGOPEN_SAVE		0x0004
#define DLGOPEN_OPEN		0x0008
#define DLGOPEN_SHOWDEFAULT	0x0020
#define DLGOPEN_NOBEEPS		0x0040
#define DLGOPEN_SEARCHPATH	0x0080

/*  Return codes  */
#define DLG_CANCEL	0
#define DLG_MISSINGFILE	-1
#define DLG_OKFILE	1


/**************************************************
 *
 *  DEFAULT FILE OPEN DIALOG PROCEDURE STUFF
 *
 **************************************************/

BOOL FAR PASCAL DefDlgOpenProc(HWND hwnd, unsigned msg,
				WORD wParam, LONG lParam);

typedef struct _DlgOpenCreate {
	LPSTR	lpszTitle;	// NULL if use default dialog caption
	LPSTR	lpszExt;	// NULL defaults to *.*
	LPSTR	lpszBuf;	// final filename buffer
	WORD	wBufLen;	// length of this buffer
	WORD	wFlags;		// DLGOPEN_xxx flags
	DWORD	dwExtra;	// for use by the owner of the dialog
} DlgOpenCreate;
typedef DlgOpenCreate FAR *FPDlgOpenCreate;

#define SetDialogReturn(hwnd, val) SetWindowLong(hwnd, 0, val)

/*  These messages are sent to/from DefDlgOpenProc to make the
 *  Dialog box work.  They may be answered by the "owner" of the dialog
 *  box.
 */
#define DLGOPEN_OKTOCLOSE	(WM_USER + 1)	// ask whether ok to close box
#define DLGOPEN_CLOSEBOX	(WM_USER + 2)	// tell dlgOpen to close box
#define DLGOPEN_SETEXTEN	(WM_USER + 3)	// sets default extensions
// #define DLGOPEN_SETEDITTEXT	(WM_USER + 4)	// sets editbox contents
// #define DLGOPEN_REFRESH		(WM_USER + 5)	// refresh the box?
#define DLGOPEN_CHANGED		(WM_USER + 6)	// edit box has been changed
#define DLGOPEN_RESETDIR	(WM_USER + 7)	// directory change

BOOL FAR PASCAL IconDirBox(HWND hwnd, WORD wId, unsigned msg,
				WORD wParam, LONG lParam);
BOOL FAR PASCAL IconDirBoxFixup(HWND hwndDirbox);


/*
 *  HUGE READ/WRITE functions
 *
 */
typedef char huge * HPSTR;

// LONG FAR PASCAL _hread( int hFile, HPSTR hpBuffer, DWORD dwBytes ); 
// LONG FAR PASCAL _hwrite( int hFile, HPSTR hpBuffer, DWORD dwBytes ); 


/*
 *  FAR STRING FUNCTIONS 
 */
LPSTR FAR PASCAL lstrncpy(LPSTR dest, LPSTR source, WORD count);
LPSTR FAR PASCAL lstrncat(LPSTR dest, LPSTR source, WORD count);
int   FAR PASCAL lstrncmp(LPSTR d, LPSTR s, WORD n);

/*
 *  FAR MEMORY FUNCTIONS 
 */
void FAR * FAR PASCAL lmemcpy(LPSTR dest, LPSTR source, WORD count);
void FAR * FAR PASCAL hmemmove(HPSTR dest, HPSTR source, LONG count);
HANDLE FAR PASCAL CopyHandle(WORD wFlags, HANDLE h);

void FAR PASCAL fmemfill (LPSTR lpMem, DWORD count, BYTE bFill);

/*
 *  BYTE SWAPPING FUNCTIONS 
 */
WORD FAR PASCAL ByteSwapWORD( WORD w );
DWORD FAR PASCAL ByteSwapDWORD( DWORD dw );


/*
 * atol for far strings
 */
LONG FAR PASCAL StringToLong( LPSTR lpstr );


/*
 *  PATH PARSING FUNCTIONS
 */
BOOL FAR PASCAL AddExtension(LPSTR lpszPath, LPSTR lpszExt, WORD wBufLen);
WORD FAR PASCAL SplitPath(LPSTR path, LPSTR drive, LPSTR dir,
			LPSTR fname, LPSTR ext);
void FAR PASCAL MakePath(LPSTR lpPath, LPSTR lpDrive, LPSTR lpDir,
			LPSTR lpFname, LPSTR lpExt);
LPSTR FAR PASCAL QualifyPathname(LPSTR lpszFile);


/* return codes from SplitPath */
#define PATH_OK		0	/* path is fine */
#define PATH_TOOLONG	1	/* filename too long   */
#define PATH_ILLEGAL	2	/* filename is illegal */

		
/* Definitions stolen from <stdlib.h> */
#ifndef _MAX_PATH

#define _MAX_PATH      144      /* max. length of full pathname */
#define _MAX_DRIVE   3      /* max. length of drive component */
#define _MAX_DIR       130      /* max. length of path component */
#define _MAX_FNAME   9      /* max. length of file name component */
#define _MAX_EXT     5      /* max. length of extension component */

#endif

/*
 *  DOS FAR UTILITY FUNCTIONS
 */
typedef struct _FindFileStruct {
	char	chReserved[21];
	BYTE	bAttribute;
	WORD	wTime;
	WORD	wDate;
	DWORD	dwSize;
	char	chFilename[13];
} FindFileStruct;
typedef FindFileStruct	FAR *FPFindFileStruct;
typedef FindFileStruct	NEAR *NPFindFileStruct;

#define	DOS_READONLY	0x0001
#define	DOS_HIDDEN	0x0002
#define DOS_SYSTEM	0x0004
#define DOS_VOLUME	0x0008
#define DOS_DIRECTORY	0x0010
#define DOS_ARCHIVE	0x0020
#define DOS_FILES	(DOS_READONLY | DOS_SYSTEM)
#define DOS_ALL		(DOS_FILES | DOS_DIRECTORY | DOS_HIDDEN)

/*  Return codes from DosFindFirst and DosFindNext  */
#define	DOSFF_OK		0
#define DOSFF_FILENOTFOUND	2
#define DOSFF_PATHINVALID	3
#define DOSFF_NOMATCH		0x12

WORD FAR PASCAL DosFindFirst(FPFindFileStruct lpFindStruct,
				LPSTR lpszFileSpec, WORD wAttrib);
WORD FAR PASCAL DosFindNext(FPFindFileStruct lpFindStruct);

int FAR PASCAL DosChangeDir(LPSTR lpszPath);
WORD FAR PASCAL DosGetCurrentDrive();
BOOL FAR PASCAL DosSetCurrentDrive(WORD wDrive);
WORD FAR PASCAL DosGetCurrentDir(WORD wCurdrive, LPSTR lpszBuf);
BOOL FAR PASCAL DosGetCurrentPath(LPSTR lpszBuf, WORD wLen);
WORD FAR PASCAL DosDeleteFile(LPSTR lpszFile);
BOOL FAR PASCAL DosGetVolume(BYTE chDrive, LPSTR lpszBuf);

WORD FAR PASCAL DosQueryNet(WORD wIndex, LPSTR lpszLocal, LPSTR lspzRemote);
WORD FAR PASCAL mscdGetDrives(LPSTR lpszDriveBuf);

/*  Return codes from DosQueryNet()  */
#define NET_ERROR	(-1)
#define	NET_INVALID	(0x0100)
#define	NET_TYPEMASK	(0x00ff)
#define NET_PRINTER	(0x0003)
#define NET_DRIVE	(0x0004)



/*
 *  ERROR MESSAGE REPORTING BOX
 */
short FAR cdecl ErrorResBox(	HWND	hwnd,
				HANDLE	hInst,
				WORD	flags,
				WORD	idAppName,
				WORD	idErrorStr, ...);

/*
 *  PROGRESS BAR GRAPH CONTROL - class "ProgBar"
 */
#define BAR_SETRANGE	(WM_USER + 0)
#define BAR_SETPOS	(WM_USER + 2)
#define BAR_DELTAPOS	(WM_USER + 4)
#define CTLCOLOR_PROGBAR	(CTLCOLOR_MAX + 2)


/*
 *  STATUS TEXT CONTROL - class "MPStatusText".
 *
 *  See wincom project file status.c for more information on control.
 */
#define ST_GETSTATUSHEIGHT	(WM_USER + 0)
#define ST_SETRIGHTSIDE		(WM_USER + 1)
#define ST_GETRIGHTSIDE		(WM_USER + 2)
#define CTLCOLOR_STATUSTEXT	(CTLCOLOR_MAX + 1)


/*
 *  ARROW CONTROL - class "ComArrow".
 */
LONG FAR PASCAL ArrowEditChange( HWND hwndEdit, WORD wParam, 
			LONG lMin, LONG lMax );

/*
 *  CHOOSER CONTROL - class "CHOOSER".
 */
/* Chooser Window control messages */
#define CM_SETITEMRECTSIZE	(WM_USER + 1)
#define CM_CALCSIZE		(WM_USER + 2)
#define CM_ADDITEM		(WM_USER + 3)
#define CM_INSERTITEM		(WM_USER + 4)
#define CM_DELETEITEM		(WM_USER + 5)
#define CM_GETCOUNT		(WM_USER + 6)
#define CM_GETITEMDATA		(WM_USER + 7)
#define CM_GETCURSEL		(WM_USER + 8)
#define CM_SETCURSEL		(WM_USER + 9)
#define CM_FINDITEM		(WM_USER + 10)
#define CM_ERR			LB_ERR

/* Chooser Window notification messages */
#define CN_SELECTED		100
#define CN_DESELECTED		101


/*
 *  Mac-like small Non-client window message handler
 */
LONG FAR PASCAL ncMsgFilter(HWND hwnd,unsigned msg, WORD wParam, LONG lParam);

/*  Window styles used by ncMsgFilter  */
#define WF_SIZEFRAME	WS_THICKFRAME
#define WF_SYSMENU	WS_SYSMENU
#define WF_MINIMIZED	WS_MINIMIZE
#define WF_SIZEBOX	0x0002


/*  Obscure stuff to deal with DLL loading/unloading  */
typedef HANDLE	HLIBLIST;
typedef WORD	DYNALIBID;

typedef struct _DynaLib {
	HANDLE	hModule;
	WORD	wRefcount;
	char	achLibname[_MAX_PATH];
} DynaLib;
typedef DynaLib FAR *FPDynaLib;

HLIBLIST FAR PASCAL dllMakeList(WORD wSize, LPSTR lpszLoadPoint,
			LPSTR lpszFreePoint);
BOOL FAR PASCAL	dllUnloadLib(HLIBLIST hlist, DYNALIBID id, BOOL fDestroy);
BOOL FAR PASCAL	dllDestroyList(HLIBLIST hlist);
BOOL FAR PASCAL dllForceUnload(HLIBLIST hlist);
HANDLE FAR PASCAL dllLoadLib(HLIBLIST hlist, DYNALIBID libid);
BOOL FAR PASCAL	dllGetInfo(HLIBLIST hlist, DYNALIBID libid, FPDynaLib fpLib);
BOOL FAR PASCAL dllIsLoaded(HLIBLIST hlist, DYNALIBID libid);
DYNALIBID FAR PASCAL dllAddLib(HLIBLIST hlist, LPSTR lpszName);
DYNALIBID FAR PASCAL dllIterAll(HLIBLIST hlist, DYNALIBID idLast);
DYNALIBID FAR PASCAL dllFindHandle(HLIBLIST hlist, HANDLE hModHandle);
DYNALIBID FAR PASCAL dllFindName(HLIBLIST hlist, LPSTR lpszName);
DYNALIBID FAR PASCAL dllAddLoadedLib(HLIBLIST hlist,HANDLE hModule,BOOL fLoad);



/**********************************
 *
 *	FOR DOS FILE FUNCTIONS (SWITCH PSP)
 *
 **********************************/


/* flags for DosSeek */
#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

/* DOS attributes */
#define ATTR_READONLY   0x0001
#define ATTR_HIDDEN     0x0002
#define ATTR_SYSTEM     0x0004
#define ATTR_VOLUME     0x0008
#define ATTR_DIR        0x0010
#define ATTR_ARCHIVE    0x0020
#define ATTR_FILES      (ATTR_READONLY+ATTR_SYSTEM)
#define ATTR_ALL_FILES  (ATTR_READONLY+ATTR_SYSTEM+ATTR_HIDDEN)
#define ATTR_ALL        (ATTR_READONLY+ATTR_DIR+ATTR_HIDDEN+ATTR_SYSTEM)

typedef struct {
    char        Reserved[21];
    BYTE        Attr;
    WORD        Time;
    WORD        Date;
    DWORD       Length;
    char        szName[13];
}   FCB;

typedef FCB     * PFCB;
typedef FCB FAR * LPFCB;

/* functions from dos.asm */

extern int   FAR PASCAL DosError(void);

extern int   FAR PASCAL DosOpen(LPSTR szFile,WORD acc);
extern int   FAR PASCAL DosCreate(LPSTR szFile,WORD acc);
extern int   FAR PASCAL DosDup(int fh);
extern void  FAR PASCAL DosClose(int fh);

extern DWORD FAR PASCAL DosSeek(int fh,DWORD ulPos,WORD org);
extern DWORD FAR PASCAL DosRead(int fh,LPSTR pBuf,DWORD ulSize);
extern DWORD FAR PASCAL DosWrite(int fh,LPSTR pBuf,DWORD ulSize);

/* DOS ERROR CODES */

#define ERROR_OK            0x00
#define ERROR_FILENOTFOUND  0x02    /* File not found */
#define ERROR_PATHNOTFOUND  0x03    /* Path not found */
#define ERROR_NOFILEHANDLES 0x04    /* Too many open files */
#define ERROR_ACCESSDENIED  0x05    /* Access denied */
#define ERROR_INVALIDHANDLE 0x06    /* Handle invalid */
#define ERROR_FCBNUKED      0x07    /* Memory control blocks destroyed */
#define ERROR_NOMEMORY      0x08    /* Insufficient memory */
#define ERROR_FCBINVALID    0x09    /* Memory block address invalid */
#define ERROR_ENVINVALID    0x0A    /* Environment invalid */
#define ERROR_FORMATBAD     0x0B    /* Format invalid */
#define ERROR_ACCESSCODEBAD 0x0C    /* Access code invalid */
#define ERROR_DATAINVALID   0x0D    /* Data invalid */
#define ERROR_UNKNOWNUNIT   0x0E    /* Unknown unit */
#define ERROR_DISKINVALID   0x0F    /* Disk drive invalid */
#define ERROR_RMCHDIR       0x10    /* Attempted to remove current directory */
#define ERROR_NOSAMEDEV     0x11    /* Not same device */
#define ERROR_NOFILES       0x12    /* No more files */
#define ERROR_13            0x13    /* Write-protected disk */
#define ERROR_14            0x14    /* Unknown unit */
#define ERROR_15            0x15    /* Drive not ready */
#define ERROR_16            0x16    /* Unknown command */
#define ERROR_17            0x17    /* Data error (CRC) */
#define ERROR_18            0x18    /* Bad request-structure length */
#define ERROR_19            0x19    /* Seek error */
#define ERROR_1A            0x1A    /* Unknown media type */
#define ERROR_1B            0x1B    /* Sector not found */
#define ERROR_WRITE         0x1D    /* Write fault */
#define ERROR_1C            0x1C    /* Printer out of paper */
#define ERROR_READ          0x1E    /* Read fault */
#define ERROR_1F            0x1F    /* General failure */
#define ERROR_SHARE         0x20    /* Sharing violation */
#define ERROR_21            0x21    /* File-lock violation */
#define ERROR_22            0x22    /* Disk change invalid */
#define ERROR_23            0x23    /* FCB unavailable */
#define ERROR_24            0x24    /* Sharing buffer exceeded */
#define ERROR_32            0x32    /* Unsupported network request */
#define ERROR_33            0x33    /* Remote machine not listening */
#define ERROR_34            0x34    /* Duplicate name on network */
#define ERROR_35            0x35    /* Network name not found */
#define ERROR_36            0x36    /* Network busy */
#define ERROR_37            0x37    /* Device no longer exists on network */
#define ERROR_38            0x38    /* NetBIOS command limit exceeded */
#define ERROR_39            0x39    /* Error in network adapter hardware */
#define ERROR_3A            0x3A    /* Incorrect response from network */
#define ERROR_3B            0x3B    /* Unexpected network error */
#define ERROR_3C            0x3C    /* Remote adapter incompatible */
#define ERROR_3D            0x3D    /* Print queue full */
#define ERROR_3E            0x3E    /* Not enough room for print file */
#define ERROR_3F            0x3F    /* Print file was deleted */
#define ERROR_40            0x40    /* Network name deleted */
#define ERROR_41            0x41    /* Network access denied */
#define ERROR_42            0x42    /* Incorrect network device type */
#define ERROR_43            0x43    /* Network name not found */
#define ERROR_44            0x44    /* Network name limit exceeded */
#define ERROR_45            0x45    /* NetBIOS session limit exceeded */
#define ERROR_46            0x46    /* Temporary pause */
#define ERROR_47            0x47    /* Network request not accepted */
#define ERROR_48            0x48    /* Print or disk redirection paused */
#define ERROR_50            0x50    /* File already exists */
#define ERROR_51            0x51    /* Reserved */
#define ERROR_52            0x52    /* Cannot make directory */
#define ERROR_53            0x53    /* Fail on Int 24H (critical error) */
#define ERROR_54            0x54    /* Too many redirections */
#define ERROR_55            0x55    /* Duplicate redirection */
#define ERROR_56            0x56    /* Invalid password */
#define ERROR_57            0x57    /* Invalid parameter */
#define ERROR_58            0x58    /* Net write fault */

/*
 *  DIB and BITMAP UTILITIES
 */
HANDLE FAR PASCAL dibCreate(DWORD dwWidth, DWORD dwHeight, WORD wBitCount,
			    WORD wPalSize, WORD wGmemFlags, WORD wDibFlags);
#define DBC_PALINDEX	0x0001

#define dibWIDTHBYTES(i)	(((i) + 31) / 32 * 4)



/*
 *  WPF OUTPUT WINDOW
 */
#define WPF_CHARINPUT	0x00000001L

int	FAR cdecl wpfVprintf(HWND hwnd, LPSTR lpszFormat, LPSTR pargs);
int	FAR cdecl wpfPrintf(HWND hwnd, LPSTR lpszFormat, ...);
void	FAR PASCAL wpfOut(HWND hwnd, LPSTR lpsz);

HWND FAR PASCAL wpfCreateWindow(HWND hwndParent, HANDLE hInst,LPSTR lpszTitle,
				DWORD dwStyle, WORD x, WORD y,
				WORD dx, WORD dy, int iMaxLines, WORD wID);

/*  Control messages sent to WPF window  */
//#define WPF_SETNLINES	(WM_USER + 1)
#define WPF_GETNLINES	(WM_USER + 2)
#define WPF_SETTABSTOPS	(WM_USER + 4)
#define WPF_GETTABSTOPS	(WM_USER + 5)
#define WPF_GETNUMTABS	(WM_USER + 6)
#define WPF_SETOUTPUT	(WM_USER + 7)
#define WPF_GETOUTPUT	(WM_USER + 8)
#define WPF_CLEARWINDOW (WM_USER + 9)

/*  Flags for WPF_SET/GETOUTPUT  */
#define	WPFOUT_WINDOW		1
#define WPFOUT_COM1		2
#define WPFOUT_NEWFILE		3
#define WPFOUT_APPENDFILE	4
#define WPFOUT_DISABLED		5

/*  Messages sent to owner of window  */
#define WPF_NTEXT	(0xbff0)
#define WPF_NCHAR	(0xbff1)


/**********************************
 *
 *	DEBUGGING SUPPORT
 *
 **********************************/

BOOL	FAR PASCAL	wpfDbgSetLocation(WORD wLoc, LPSTR lpszFile);
int	FAR cdecl	wpfDbgOut(LPSTR lpszFormat, ...);
BOOL	FAR PASCAL	wpfSetDbgWindow(HWND hwnd, BOOL fDestroyOld);

#define	WinPrintf	wpfDbgOut

#ifdef DEBUG
	BOOL	__fEval;
	BOOL	__iDebugLevel;

	int FAR PASCAL __WinAssert(LPSTR lpszFile, int iLine);

	#define WinAssert(exp)		\
		((exp) ? 0 : __WinAssert((LPSTR) __FILE__, __LINE__))
	#define WinEval(exp) (__fEval=(exp), WinAssert(__fEval), __fEval)

	#define wpfGetDebugLevel(lpszModule)	\
		(__iDebugLevel = GetProfileInt("MMDebug", (lpszModule), 0))

        #define wpfSetDebugLevel(i)    \
                (__iDebugLevel = (i))

        #define wpfDebugLevel()    (__iDebugLevel)

	#define dprintf if (__iDebugLevel) wpfDbgOut
	#define dprintf1 if (__iDebugLevel >= 1) wpfDbgOut
	#define dprintf2 if (__iDebugLevel >= 2) wpfDbgOut
	#define dprintf3 if (__iDebugLevel >= 3) wpfDbgOut
	#define dprintf4 if (__iDebugLevel >= 4) wpfDbgOut
#else
	#define WinAssert(exp) 0
	#define WinEval(exp) (exp)

        #define wpfGetDebugLevel(lpszModule) 0
        #define wpfSetDebugLevel(i)          0
        #define wpfDebugLevel()              0

	#define dprintf if (0) ((int (*)(char *, ...)) 0)
	#define dprintf1 if (0) ((int (*)(char *, ...)) 0)
	#define dprintf2 if (0) ((int (*)(char *, ...)) 0)
	#define dprintf3 if (0) ((int (*)(char *, ...)) 0)
	#define dprintf4 if (0) ((int (*)(char *, ...)) 0)
#endif


/**  THIS MUST BE LAST LINE OF FILE  **/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\alias.h ===
/***********************************************************************
//
// ALIAS.H
//
//		Copyright (c) 1992 - Microsoft Corp.
//		All rights reserved.
//		Microsoft Confidential
//
// Global constants and data types used by the Jaguar file engine.
//
***********************************************************************/

//**********************************************************************
// Normal variable typedefs. These type defs are compatible with OS2
// typedefs.
//**********************************************************************

#ifndef	CHAR
	typedef		char					CHAR;
#endif

#ifndef	UCHAR
	typedef		unsigned char		UCHAR;
#endif

#ifndef	INT
	typedef		int					INT;
#endif

#ifndef	UINT
	typedef		unsigned int		UINT;
#endif

#ifndef	UL
	typedef		unsigned long		UL;
#endif

#if 0
#ifndef	FLOAT
	typedef		float 				FLOAT;
#endif
#endif

#ifndef	DOUBLE
	typedef		double				DOUBLE;
#endif

#ifndef	LONG
	typedef		long					LONG;
#endif

//**********************************************************************
//	ANY_TYPE
//
//	This is a union which can be used to cast any type to a basic
//	data type.
// 
//**********************************************************************

typedef union
{
   CHAR			Byte;
	UCHAR			uByte;
	INT			Word;
	UINT			uWord;
	LONG			Dword;
	UL				uDword;
} ANY_TYPE;

//**********************************************************************
// Standard global constants.
// Don't change the TRUE define because some functions depend on it being
// 1 instead of !FALSE.
//**********************************************************************

#ifndef		FALSE
   #define     FALSE          0
   #define     TRUE           1
#endif

#ifndef		EOL
   #define     EOL            '\0'
#endif

#ifndef	  OK
   #define		OK			      0
#endif

//**********************************************************************
// DeReference macro for unused function arguments
//**********************************************************************

#ifndef	DeReference		
	#ifdef	_lint
		#define	DeReference( x )	x = x
	#else
		#define	DeReference( x )	x = x
	#endif
#endif

//**********************************************************************
// MAX_PATH is the max path string length.
//**********************************************************************
#ifndef WIN32
#ifndef	MAX_PATH
	#define		MAX_PATH		256				// Really 64 but compatible with OS2
#else
	#if			MAX_PATH != 256				// Error check
		#error
	#endif
#endif
#endif
	
#ifndef	MAX_DIR_DEPTH
	#define	MAX_DIR_DEPTH		32				//	Directory levels supported by DOS
#else
	#if			MAX_DIR_DEPTH != 32			// Error check
		#error
	#endif
#endif

#ifndef	DIR_NAME_LEN
	#define		DIR_NAME_LEN	(8+3)			// Len of FCB type file name
#else
	#if			DIR_NAME_LEN != (8+3)		// Error check
		#error
	#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\assert.h ===
/***
*assert.h - define the assert macro
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines the assert(exp) macro.
*   [ANSI/System V]
*
****/

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#undef  assert

#ifdef NDEBUG

#define assert(exp) ((void)0)

#else 
#ifdef __cplusplus
extern "C" {
#endif 
void __cdecl _assert(void *, void *, unsigned);
#ifdef __cplusplus
}
#endif 

#define assert(exp) \
    ( (exp) ? (void) 0 : _assert(#exp, __FILE__, __LINE__) )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\appletp.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: appletp.h
//
//  This file contains the private (group B) functions of applet DLLs.
//
// History:
//  03-29-93 SatoNa     Created.
//
//---------------------------------------------------------------------------

typedef BOOL (STDAPICALLTYPE FAR * LPFNCREATESCRAPFROMCLIP)
                                            (HWND hwnd, LPCSTR pszDir);

#define STR_CREATESCRAP "appui.dll,Scrap_CreateFromClipboard"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc\wrkbench.h ===
/* (C) Copyright Microsoft Corporation 1991.  All rights reserved. */

/* 
 * WORKBENCH INCLUDE FILE
 * 
 * This is the public include for the workbench.  All workbench client
 * applications and handler DLLs will need to include this file.
 * 
 * The following must be included before this file:
 *	windows.h
 *	wincom.h
 *	mediaman.h
 * 
 */
#ifndef _WRKBENCH_H_
#define _WRKBENCH_H_

#ifndef EXPORT
#define EXPORT FAR PASCAL
#endif

/*******  VERSION FOR USE IN INFO STRUCTURES  *******/
#define WRK_VERSION	0x100

/*******  RANDOM FUNCTIONS  *******/
BOOL	EXPORT	wrkClientInit( void );
BOOL	EXPORT	wrkClientExit( void );
WORD	EXPORT	wrkGetVariable(WORD w);
BOOL	EXPORT	wrkSetVariable(WORD w, WORD wVariable);
BOOL	EXPORT	wrkLoadDll(LPSTR lpszDllName);

HWND	EXPORT	wrkCreateIntroWindow(HANDLE hInstApp, 
					WORD wString1Id,
					WORD wString2Id, 
					WORD wString3Id, 
					WORD wBitmapId);
				
BOOL	EXPORT	wrkDestroyIntroWindow(HWND hwndIntro);

VOID	EXPORT	wrkShowAboutDialog(HANDLE hInstApp,
					HWND hwndParent,
					WORD wCaptionId,
					WORD wString1Id,
					WORD wString2Id, 
					WORD wString3Id, 
					WORD wBitmapId);

#define WRKV_DEBUG		0
#define WRKV_CONFIRMCONVERT	2
#define WRKV_HINSTWORKBENCH	4


/*********  EXTENSION LIST  *********/

typedef DWORD	EXTENSION;
typedef	HANDLE	ExtensionList;

WORD		EXPORT	wrkGetExtSize(ExtensionList extList);
EXTENSION	EXPORT	wrkGetExtElement(ExtensionList extList,
					WORD wElement);
WORD		EXPORT	wrkGetExtString(ExtensionList extList,
					LPSTR lpszBuf, WORD wSize);
EXTENSION	EXPORT	wrkStringToExtension(LPSTR lpszString);
BOOL		EXPORT	wrkExtInList(ExtensionList extList,
					EXTENSION extension);

/*********  INSTALLED TOOL FUNCTIONS  *************/

#ifndef _WRKI_H_
typedef HANDLE InstalledTool;
#endif

InstalledTool EXPORT wrkRegisterLoader(HANDLE hModDll,
		MEDTYPE typeModule, MEDTYPE typeLogical,
		LPSTR lpszExtensions, LPSTR lpszTitle, WORD wFlags);
InstalledTool EXPORT wrkRegisterHandler(HANDLE hModDll, MEDTYPE typeLogical,
		LPSTR lpszTitle, WORD wFlags);
InstalledTool EXPORT wrkRegisterUtility(LPSTR lpszExeName,
		LPSTR lpszTitle, WORD wFlags);
InstalledTool EXPORT wrkRegisterEditor(LPSTR lpszExeName, MEDTYPE typeLogical,
		LPSTR lpszTitle, WORD wFlags);

InstalledTool EXPORT wrkIterTools(InstalledTool instTool, WORD wType);
InstalledTool EXPORT wrkVerifyHandler(MEDTYPE typeLogical, LPSTR lpszSuggest);
BOOL	EXPORT	wrkRealizeModule(InstalledTool tool);

/*  Defined tool/module types - for wrkIterTools  */
#define TOOL_LOADER	0x0001
#define TOOL_EDITOR	0x0002
#define TOOL_HANDLER	0x0004
#define TOOL_UTILITY	0x0008
#define TOOL_PROCTOOL	0x0010		// not implemented!
#define TOOL_ALLTYPES	0xffff

/* Flags for registerLoader */
#define LOADF_DOESLOAD	0x0001
#define LOADF_DOESSAVE	0x0002
#define LOADF_FILEBASED	0x0004
#define LOADF_CONVERTTOOL	0x0008
#define LOADF_MANAGERTOOL	0x0010


/*******  Installed tool Information functions  *******/
typedef struct _InstalledToolInfo {
	WORD		wVersion;
	WORD		wType;
	WORD		wFlags;
	WORD		wUsage;
	
	MEDTYPE		typeModule;
	MEDTYPE		typeLogical;
	ExtensionList	exten;
} InstalledToolInfo;
typedef InstalledToolInfo FAR *FPInstalledToolInfo;

BOOL EXPORT wrkGetToolInfo(InstalledTool tool, FPInstalledToolInfo fpInfo);
WORD EXPORT wrkGetToolType(InstalledTool tool);
BOOL EXPORT wrkGetToolTitle(InstalledTool tool, LPSTR lpszBuf, WORD wLen);
BOOL EXPORT wrkGetToolModname(InstalledTool tool, LPSTR lpszBuf, WORD wLen);
BOOL EXPORT wrkGetLogicalExtensions(MEDTYPE typeLogical, WORD wFlags,
				LPSTR lpszBuf, WORD wLen);


/*******  TOOL ARRAY FUNCTIONS  *******/
#ifndef _WRKI_H_
typedef WORD ToolArray;
#endif

ToolArray EXPORT wrkCreateToolArray(WORD wSize);
BOOL	EXPORT	wrkDestroyToolArray(ToolArray toolArr);
WORD	EXPORT	wrkAddToToolArray(ToolArray toolArr, 
			InstalledTool tool, BOOL fNoDup);
WORD	EXPORT	wrkGetToolArraySize(ToolArray toolArr);
InstalledTool EXPORT wrkGetToolArrayEntry(ToolArray toolArr, WORD wIndex);

WORD EXPORT wrkToolChooseDlg(HWND hwnd, ToolArray toolArr, WORD wInitial,
			LPSTR lpszTitle, LPSTR lpszFirst, WORD wFlags);
#define TCD_NOSELECTION	0xffff

/*******  INSTANCE FUNCTIONS  ********/

typedef HANDLE ToolInstance;

ToolInstance EXPORT wrkAddInstance(InstalledTool toolHandle, HWND hwnd,
		LPSTR lpszInstTitle, WORD wFlags);
BOOL EXPORT wrkRemoveInstance(ToolInstance toolInst);
LONG EXPORT wrkInstSendMessage(ToolInstance toolInst, unsigned msg,
		WORD wParam, LONG lParam);
BOOL EXPORT wrkInstPostMessage(ToolInstance toolInst, unsigned msg,
		WORD wParam, LONG lParam);
BOOL EXPORT wrkBroadcastMessage(BOOL fPost, unsigned msg,
		WORD wParam, LONG lParam);
ToolInstance EXPORT wrkGetNextInst(ToolInstance toolInst);

/*  Tool instance info functions  */
typedef struct _ToolInstanceInfo {
	WORD	wVersion;
	WORD	wAction;
	InstalledTool	toolClass;
	
	WORD	wInstFlags;
	HWND	hwndTool;
} ToolInstanceInfo;
typedef ToolInstanceInfo FAR *FPToolInstanceInfo;

/*  Action codes for wrkSetInstInfo structure  */
#define WRKINFO_INSTFLAGS	0x0002
#define WRKINFO_HWND		0x0008
#define WRKINFO_ALL		0x00FF

InstalledTool EXPORT wrkGetInstToolType(ToolInstance toolInst);
BOOL EXPORT wrkSetInstInfo(ToolInstance toolInst, FPToolInstanceInfo fpInfo);
BOOL EXPORT wrkGetInstInfo(ToolInstance toolInst, FPToolInstanceInfo fpInfo);
BOOL EXPORT wrkSetInstTitle(ToolInstance toolInst, LPSTR lpszInstTitle);
BOOL EXPORT wrkGetInstTitle(ToolInstance toolInst, LPSTR lpszBuf, WORD wLen);

/*  Flags for SetInstInfo & AddInstance  */
#define WRK_NOINSTNOTIFY	0x0001


/*********  RESOURCE ACCESS  **************/

WORD EXPORT wrkOpenFilename(LPSTR lpszFilename, FPMedReturn medReturn,
		MEDTYPE typeLogical, WORD wFlags, HWND hwnd, LPSTR lpszTitle);
WORD EXPORT wrkOpenDialog(FPMedReturn medReturn, MEDTYPE typeLogical,
		WORD wFlags, HWND hwnd, LPSTR lpszTitle);
WORD EXPORT wrkSaveDialog(MEDID medid, FPMedReturn medReturn,
		WORD wFlags, HWND hwnd, LPSTR lpszTitle);

BOOL EXPORT wrkShowResError(HWND hwnd, LPSTR lpszTitle);

/* Flags for FileLoading/Saving functions */		    
#define WRK_SHOWERROR		0x0001
#define WRK_SAVEASDIALOG	0x0002
#define WRK_NONSHARED		0x2000
#define WRK_SHAREDONLY		0x1000

/*********   TOOL INSTANCE STARTING  *********/
ToolInstance  EXPORT wrkRunTool(InstalledTool tool, LPSTR lpszArguments,
			WORD wCmdShow, HWND hwndParent, WORD wFlags);
#define WRK_NOGETINSTHANDLE	0x0080



/*
 *  Messages sent to client tools
 */
#define WRK_MINMESSAGE		0xB000
#define WRK_MAXMESSAGE		0xBFFF
/*  Notification messages  */
#define WRK_NEWINSTANCE		(WRK_MINMESSAGE + 3)
#define WRK_DELETEINSTANCE	(WRK_MINMESSAGE + 4)
#define WRK_CHANGEINSTANCE	(WRK_MINMESSAGE + 5)
#define WRK_NEWTOOL		(WRK_MINMESSAGE + 6)
#define WRK_DELETETOOL		(WRK_MINMESSAGE + 7)
/*  Control messages - instance related  */
#define WRK_CLOSEINST		(WRK_MINMESSAGE + 10)
#define WRK_ACTIVATEINST	(WRK_MINMESSAGE + 11)
#define WRK_DEACTIVATEINST	(WRK_MINMESSAGE + 12)
/*  Control messages - resource related  */
#define WRK_SETRESOURCE		(WRK_MINMESSAGE + 19)

/*  Flags for WRK_CHANGEINSTANCE message  */
#define	WRKINST_FLAGS	1L
#define WRKINST_TITLE	4L
#define WRKINST_HWND	8L


/*
 *  Workbench Error messages
 */
#define WRKERR_NOERROR		(MMERR_MAXERROR + 0)
#define WRKERR_NOPROFWRITE	(MMERR_MAXERROR + 1)
#define WRKERR_HANDLERNOTAVAIL	(MMERR_MAXERROR + 10)
#define WRKERR_COULDNOTLOADMOD	(MMERR_MAXERROR + 11)
#define WRKERR_USERCANCEL	(MMERR_MAXERROR + 12)
#define WRKERR_NOLOADERSAVAIL	(MMERR_MAXERROR + 13)
#define WRKERR_COULDNOTRUNTOOL	(MMERR_MAXERROR + 14)
#define WRKERR_NOSAVERSAVAIL	(MMERR_MAXERROR + 15)
#define WRKERR_UNNAMEDRES	(MMERR_MAXERROR + 16)
#define WRKERR_NOCONVERTTOOL	(MMERR_MAXERROR + 17)
#define WRKERR_ALREADYACCESSED	(MMERR_MAXERROR + 18)

/*  This endif must be the last line of the file  */
#endif /* _WRKBENCH_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\avicap.h ===
/****************************************************************************
 *
 *   avicap.h
 * 
 *   Main include file.
 *
 *   Microsoft Video for Windows Sample Capture Class
 *
 *   Copyright (c) 1992 - 1994 Microsoft Corporation.  All Rights Reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 ***************************************************************************/

#ifndef _INC_AVICAP
#define _INC_AVICAP

#ifndef VFWAPI
#ifdef WIN32
    #define VFWAPI  _stdcall
    #define VFWAPIV _stdcall
#else
    #define VFWAPI  FAR PASCAL
    #define VFWAPIV FAR CDECL
#endif
#endif
      
#ifdef __cplusplus
#define AVICapSM ::SendMessage  /* SendMessage in C++*/
#else
#define AVICapSM SendMessage    /* SendMessage in C */
#endif  /* __cplusplus */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifndef RC_INVOKED

// ------------------------------------------------------------------
//  Window Messages  WM_CAP... which can be sent to an AVICAP window
// ------------------------------------------------------------------

// Defines start of the message range
#define WM_CAP_START                    WM_USER

#define WM_CAP_GET_CAPSTREAMPTR         (WM_CAP_START+  1)

#define WM_CAP_SET_CALLBACK_ERROR       (WM_CAP_START+  2)
#define WM_CAP_SET_CALLBACK_STATUS      (WM_CAP_START+  3)
#define WM_CAP_SET_CALLBACK_YIELD       (WM_CAP_START+  4)
#define WM_CAP_SET_CALLBACK_FRAME       (WM_CAP_START+  5)
#define WM_CAP_SET_CALLBACK_VIDEOSTREAM (WM_CAP_START+  6)
#define WM_CAP_SET_CALLBACK_WAVESTREAM  (WM_CAP_START+  7)
#define WM_CAP_GET_USER_DATA            (WM_CAP_START+  8)
#define WM_CAP_SET_USER_DATA            (WM_CAP_START+  9)
    
#define WM_CAP_DRIVER_CONNECT           (WM_CAP_START+  10)
#define WM_CAP_DRIVER_DISCONNECT        (WM_CAP_START+  11)
#define WM_CAP_DRIVER_GET_NAME          (WM_CAP_START+  12) 
#define WM_CAP_DRIVER_GET_VERSION       (WM_CAP_START+  13) 
#define WM_CAP_DRIVER_GET_CAPS          (WM_CAP_START+  14) 

#define WM_CAP_FILE_SET_CAPTURE_FILE    (WM_CAP_START+  20)
#define WM_CAP_FILE_GET_CAPTURE_FILE    (WM_CAP_START+  21)
#define WM_CAP_FILE_ALLOCATE            (WM_CAP_START+  22)
#define WM_CAP_FILE_SAVEAS              (WM_CAP_START+  23)
#define WM_CAP_FILE_SET_INFOCHUNK       (WM_CAP_START+  24)
#define WM_CAP_FILE_SAVEDIB             (WM_CAP_START+  25)

#define WM_CAP_EDIT_COPY                (WM_CAP_START+  30)

#define WM_CAP_SET_AUDIOFORMAT          (WM_CAP_START+  35) 
#define WM_CAP_GET_AUDIOFORMAT          (WM_CAP_START+  36)

#define WM_CAP_DLG_VIDEOFORMAT          (WM_CAP_START+  41)
#define WM_CAP_DLG_VIDEOSOURCE          (WM_CAP_START+  42)
#define WM_CAP_DLG_VIDEODISPLAY         (WM_CAP_START+  43)
#define WM_CAP_GET_VIDEOFORMAT          (WM_CAP_START+  44)
#define WM_CAP_SET_VIDEOFORMAT          (WM_CAP_START+  45)
#define WM_CAP_DLG_VIDEOCOMPRESSION     (WM_CAP_START+  46)

#define WM_CAP_SET_PREVIEW              (WM_CAP_START+  50)
#define WM_CAP_SET_OVERLAY              (WM_CAP_START+  51)
#define WM_CAP_SET_PREVIEWRATE          (WM_CAP_START+  52)
#define WM_CAP_SET_SCALE                (WM_CAP_START+  53)
#define WM_CAP_GET_STATUS               (WM_CAP_START+  54)
#define WM_CAP_SET_SCROLL               (WM_CAP_START+  55)

#define WM_CAP_GRAB_FRAME               (WM_CAP_START+  60)
#define WM_CAP_GRAB_FRAME_NOSTOP        (WM_CAP_START+  61)

#define WM_CAP_SEQUENCE                 (WM_CAP_START+  62)
#define WM_CAP_SEQUENCE_NOFILE          (WM_CAP_START+  63)
#define WM_CAP_SET_SEQUENCE_SETUP       (WM_CAP_START+  64)
#define WM_CAP_GET_SEQUENCE_SETUP       (WM_CAP_START+  65)
#define WM_CAP_SET_MCI_DEVICE           (WM_CAP_START+  66)
#define WM_CAP_GET_MCI_DEVICE           (WM_CAP_START+  67)
#define WM_CAP_STOP                     (WM_CAP_START+  68)
#define WM_CAP_ABORT                    (WM_CAP_START+  69)

#define WM_CAP_SINGLE_FRAME_OPEN        (WM_CAP_START+  70) 
#define WM_CAP_SINGLE_FRAME_CLOSE       (WM_CAP_START+  71) 
#define WM_CAP_SINGLE_FRAME             (WM_CAP_START+  72) 

#define WM_CAP_PAL_OPEN                 (WM_CAP_START+  80) 
#define WM_CAP_PAL_SAVE                 (WM_CAP_START+  81) 
#define WM_CAP_PAL_PASTE                (WM_CAP_START+  82)
#define WM_CAP_PAL_AUTOCREATE           (WM_CAP_START+  83)
#define WM_CAP_PAL_MANUALCREATE         (WM_CAP_START+  84)

// Following added post VFW 1.1
#define WM_CAP_SET_CALLBACK_CAPCONTROL  (WM_CAP_START+  85)

// Defines end of the message range
#define WM_CAP_END                      WM_CAP_SET_CALLBACK_CAPCONTROL
                                        
// ------------------------------------------------------------------
//  Message crackers for above
// ------------------------------------------------------------------

#define capSetCallbackOnError(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_ERROR, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnStatus(hwnd, fpProc)       ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_STATUS, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnYield(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_YIELD, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnFrame(hwnd, fpProc)        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_FRAME, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnVideoStream(hwnd, fpProc)  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_VIDEOSTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnWaveStream(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_WAVESTREAM, 0, (LPARAM)(LPVOID)(fpProc)))
#define capSetCallbackOnCapControl(hwnd, fpProc)   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_CALLBACK_CAPCONTROL, 0, (LPARAM)(LPVOID)(fpProc)))

#define capSetUserData(hwnd, lUser)                ((BOOL)AVICapSM(hwnd, WM_CAP_SET_USER_DATA, 0, (LPARAM)lUser))
#define capGetUserData(hwnd)                       (AVICapSM(hwnd, WM_CAP_GET_USER_DATA, 0, 0))

#define capDriverConnect(hwnd, i)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_CONNECT, (WPARAM)(i), 0L))
#define capDriverDisconnect(hwnd)                  ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_DISCONNECT, (WPARAM)0, 0L))
#define capDriverGetName(hwnd, szName, wSize)      ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_NAME, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capDriverGetVersion(hwnd, szVer, wSize)    ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_VERSION, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szVer)))
#define capDriverGetCaps(hwnd, s, wSize)           ((BOOL)AVICapSM(hwnd, WM_CAP_DRIVER_GET_CAPS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPDRIVERCAPS)(s)))

#define capFileSetCaptureFile(hwnd, szName)        ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_CAPTURE_FILE, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capFileGetCaptureFile(hwnd, szName, wSize) ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_GET_CAPTURE_FILE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capFileAlloc(hwnd, dwSize)                 ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_ALLOCATE, 0, (LPARAM)(DWORD)(dwSize)))
#define capFileSaveAs(hwnd, szName)                ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEAS, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capFileSetInfoChunk(hwnd, lpInfoChunk)     ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SET_INFOCHUNK, (WPARAM)0, (LPARAM)(LPCAPINFOCHUNK)(lpInfoChunk)))
#define capFileSaveDIB(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_FILE_SAVEDIB, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))

#define capEditCopy(hwnd)                          ((BOOL)AVICapSM(hwnd, WM_CAP_EDIT_COPY, 0, 0L))

#define capSetAudioFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPWAVEFORMATEX)(s)))
#define capGetAudioFormatSize(hwnd)                ((DWORD)AVICapSM(hwnd, WM_CAP_GET_AUDIOFORMAT, (WPARAM)0, (LPARAM) NULL))

#define capDlgVideoFormat(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOFORMAT, 0, 0L))
#define capDlgVideoSource(hwnd)                    ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOSOURCE, 0, 0L))
#define capDlgVideoDisplay(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEODISPLAY, 0, 0L))
#define capDlgVideoCompression(hwnd)               ((BOOL)AVICapSM(hwnd, WM_CAP_DLG_VIDEOCOMPRESSION, 0, 0L))

#define capGetVideoFormat(hwnd, s, wSize)          ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))
#define capGetVideoFormatSize(hwnd)                ((DWORD)AVICapSM(hwnd, WM_CAP_GET_VIDEOFORMAT, 0, NULL))
#define capSetVideoFormat(hwnd, s, wSize)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_VIDEOFORMAT, (WPARAM)(wSize), (LPARAM)(LPVOID)(s)))

#define capPreview(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEW, (WPARAM)(BOOL)(f), 0L))
#define capPreviewRate(hwnd, wMS)                  ((BOOL)AVICapSM(hwnd, WM_CAP_SET_PREVIEWRATE, (WPARAM)(wMS), 0))
#define capOverlay(hwnd, f)                        ((BOOL)AVICapSM(hwnd, WM_CAP_SET_OVERLAY, (WPARAM)(BOOL)(f), 0L))
#define capPreviewScale(hwnd, f)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCALE, (WPARAM)(BOOL)f, 0L))
#define capGetStatus(hwnd, s, wSize)               ((BOOL)AVICapSM(hwnd, WM_CAP_GET_STATUS, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPSTATUS)(s)))
#define capSetScrollPos(hwnd, lpP)                 ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SCROLL, (WPARAM)0, (LPARAM)(LPPOINT)(lpP)))

#define capGrabFrame(hwnd)                         ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME, (WPARAM)0, (LPARAM)0L))
#define capGrabFrameNoStop(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_GRAB_FRAME_NOSTOP, (WPARAM)0, (LPARAM)0L))

#define capCaptureSequence(hwnd)                   ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSequenceNoFile(hwnd)             ((BOOL)AVICapSM(hwnd, WM_CAP_SEQUENCE_NOFILE, (WPARAM)0, (LPARAM)0L))
#define capCaptureStop(hwnd)                       ((BOOL)AVICapSM(hwnd, WM_CAP_STOP, (WPARAM)0, (LPARAM)0L))
#define capCaptureAbort(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_ABORT, (WPARAM)0, (LPARAM)0L))

#define capCaptureSingleFrameOpen(hwnd)            ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_OPEN, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrameClose(hwnd)           ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME_CLOSE, (WPARAM)0, (LPARAM)0L))
#define capCaptureSingleFrame(hwnd)                ((BOOL)AVICapSM(hwnd, WM_CAP_SINGLE_FRAME, (WPARAM)0, (LPARAM)0L))

#define capCaptureGetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_GET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))
#define capCaptureSetSetup(hwnd, s, wSize)         ((BOOL)AVICapSM(hwnd, WM_CAP_SET_SEQUENCE_SETUP, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPCAPTUREPARMS)(s)))

#define capSetMCIDeviceName(hwnd, szName)          ((BOOL)AVICapSM(hwnd, WM_CAP_SET_MCI_DEVICE, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capGetMCIDeviceName(hwnd, szName, wSize)   ((BOOL)AVICapSM(hwnd, WM_CAP_GET_MCI_DEVICE, (WPARAM)(wSize), (LPARAM)(LPVOID)(LPSTR)(szName)))

#define capPaletteOpen(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_OPEN, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capPaletteSave(hwnd, szName)               ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_SAVE, 0, (LPARAM)(LPVOID)(LPSTR)(szName)))
#define capPalettePaste(hwnd)                      ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_PASTE, (WPARAM) 0, (LPARAM)0L))
#define capPaletteAuto(hwnd, iFrames, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_AUTOCREATE, (WPARAM)(iFrames), (LPARAM)(DWORD)(iColors)))
#define capPaletteManual(hwnd, fGrab, iColors)     ((BOOL)AVICapSM(hwnd, WM_CAP_PAL_MANUALCREATE, (WPARAM)(fGrab), (LPARAM)(DWORD)(iColors)))

// ------------------------------------------------------------------
//  Structures 
// ------------------------------------------------------------------

typedef struct tagCapDriverCaps {
    WORD        wDeviceIndex;               // Driver index in system.ini
    BOOL        fHasOverlay;                // Can device overlay?
    BOOL        fHasDlgVideoSource;         // Has Video source dlg?
    BOOL        fHasDlgVideoFormat;         // Has Format dlg?
    BOOL        fHasDlgVideoDisplay;        // Has External out dlg?
    BOOL        fCaptureInitialized;        // Driver ready to capture?
    BOOL        fDriverSuppliesPalettes;    // Can driver make palettes?
    HVIDEO      hVideoIn;                   // Driver In channel
    HVIDEO      hVideoOut;                  // Driver Out channel
    HVIDEO      hVideoExtIn;                // Driver Ext In channel
    HVIDEO      hVideoExtOut;               // Driver Ext Out channel
} CAPDRIVERCAPS, *PCAPDRIVERCAPS, FAR *LPCAPDRIVERCAPS;

typedef struct tagCapStatus {
    UINT        uiImageWidth;               // Width of the image
    UINT        uiImageHeight;              // Height of the image
    BOOL        fLiveWindow;                // Now Previewing video?
    BOOL        fOverlayWindow;             // Now Overlaying video?
    BOOL        fScale;                     // Scale image to client?
    POINT       ptScroll;                   // Scroll position
    BOOL        fUsingDefaultPalette;       // Using default driver palette?
    BOOL        fAudioHardware;             // Audio hardware present?
    BOOL        fCapFileExists;             // Does capture file exist?
    DWORD       dwCurrentVideoFrame;        // # of video frames cap'td
    DWORD       dwCurrentVideoFramesDropped;// # of video frames dropped
    DWORD       dwCurrentWaveSamples;       // # of wave samples cap'td
    DWORD       dwCurrentTimeElapsedMS;     // Elapsed capture duration
    HPALETTE    hPalCurrent;                // Current palette in use
    BOOL        fCapturingNow;              // Capture in progress?
    DWORD       dwReturn;                   // Error value after any operation
    WORD        wNumVideoAllocated;         // Actual number of video buffers
    WORD        wNumAudioAllocated;         // Actual number of audio buffers
} CAPSTATUS, *PCAPSTATUS, FAR *LPCAPSTATUS;

                                            // Default values in parenthesis
typedef struct tagCaptureParms {
    DWORD       dwRequestMicroSecPerFrame;  // Requested capture rate
    BOOL        fMakeUserHitOKToCapture;    // Show "Hit OK to cap" dlg?
    WORD        wPercentDropForError;       // Give error msg if > (10%)
    BOOL        fYield;                     // Capture via background task?
    DWORD       dwIndexSize;                // Max index size in frames (32K)
    WORD        wChunkGranularity;          // Junk chunk granularity (2K)
    BOOL        fUsingDOSMemory;            // Use DOS buffers?
    WORD        wNumVideoRequested;         // # video buffers, If 0, autocalc
    BOOL        fCaptureAudio;              // Capture audio?
    WORD        wNumAudioRequested;         // # audio buffers, If 0, autocalc
    WORD        vKeyAbort;                  // Virtual key causing abort
    BOOL        fAbortLeftMouse;            // Abort on left mouse?
    BOOL        fAbortRightMouse;           // Abort on right mouse?
    BOOL        fLimitEnabled;              // Use wTimeLimit?
    WORD        wTimeLimit;                 // Seconds to capture
    BOOL        fMCIControl;                // Use MCI video source?
    BOOL        fStepMCIDevice;             // Step MCI device?
    DWORD       dwMCIStartTime;             // Time to start in MS
    DWORD       dwMCIStopTime;              // Time to stop in MS
    BOOL        fStepCaptureAt2x;           // Perform spatial averaging 2x
    WORD        wStepCaptureAverageFrames;  // Temporal average n Frames
    DWORD       dwAudioBufferSize;          // Size of audio bufs (0 = default)
    BOOL        fDisableWriteCache;         // Attempt to disable write cache
} CAPTUREPARMS, *PCAPTUREPARMS, FAR *LPCAPTUREPARMS;

typedef struct tagCapInfoChunk {
    FOURCC      fccInfoID;                  // Chunk ID, "ICOP" for copyright
    LPVOID      lpData;                     // pointer to data
    LONG        cbData;                     // size of lpData
} CAPINFOCHUNK, *PCAPINFOCHUNK, FAR *LPCAPINFOCHUNK;


// ------------------------------------------------------------------
//  Callback Definitions
// ------------------------------------------------------------------

typedef LRESULT (CALLBACK* CAPYIELDCALLBACK)  (HWND hWnd);
typedef LRESULT (CALLBACK* CAPSTATUSCALLBACK) (HWND hWnd, int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPERRORCALLBACK)  (HWND hWnd, int nID, LPCSTR lpsz);
typedef LRESULT (CALLBACK* CAPVIDEOCALLBACK)  (HWND hWnd, LPVIDEOHDR lpVHdr);
typedef LRESULT (CALLBACK* CAPWAVECALLBACK)   (HWND hWnd, LPWAVEHDR lpWHdr);
typedef LRESULT (CALLBACK* CAPCONTROLCALLBACK)(HWND hWnd, int nState);

// ------------------------------------------------------------------
//  CapControlCallback states
// ------------------------------------------------------------------
#define CONTROLCALLBACK_PREROLL         1 /* Waiting to start capture */
#define CONTROLCALLBACK_CAPTURING       2 /* Now capturing */

// ------------------------------------------------------------------
//  The only exported functions from AVICAP.DLL
// ------------------------------------------------------------------

HWND VFWAPI capCreateCaptureWindow (
        LPCSTR lpszWindowName, 
        DWORD dwStyle,
        int x, int y, int nWidth, int nHeight,
        HWND hwndParent, int nID);

BOOL VFWAPI capGetDriverDescription (WORD wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);

#endif  /* RC_INVOKED */

// ------------------------------------------------------------------
// New Information chunk IDs
// ------------------------------------------------------------------
#define infotypeDIGITIZATION_TIME  mmioFOURCC ('I','D','I','T')
#define infotypeSMPTE_TIME         mmioFOURCC ('I','S','M','P')

// ------------------------------------------------------------------
// String IDs from status and error callbacks
// ------------------------------------------------------------------

#define IDS_CAP_BEGIN               300  /* "Capture Start" */
#define IDS_CAP_END                 301  /* "Capture End" */

#define IDS_CAP_INFO                401  /* "%s" */
#define IDS_CAP_OUTOFMEM            402  /* "Out of memory" */
#define IDS_CAP_FILEEXISTS          403  /* "File '%s' exists -- overwrite it?" */
#define IDS_CAP_ERRORPALOPEN        404  /* "Error opening palette '%s'" */
#define IDS_CAP_ERRORPALSAVE        405  /* "Error saving palette '%s'" */
#define IDS_CAP_ERRORDIBSAVE        406  /* "Error saving frame '%s'" */
#define IDS_CAP_DEFAVIEXT           407  /* "avi" */
#define IDS_CAP_DEFPALEXT           408  /* "pal" */
#define IDS_CAP_CANTOPEN            409  /* "Cannot open '%s'" */
#define IDS_CAP_SEQ_MSGSTART        410  /* "Select OK to start capture\nof video sequence\nto %s." */
#define IDS_CAP_SEQ_MSGSTOP         411  /* "Hit ESCAPE or click to end capture" */
                
#define IDS_CAP_VIDEDITERR          412  /* "An error occurred while trying to run VidEdit." */
#define IDS_CAP_READONLYFILE        413  /* "The file '%s' is a read-only file." */
#define IDS_CAP_WRITEERROR          414  /* "Unable to write to file '%s'.\nDisk may be full." */
#define IDS_CAP_NODISKSPACE         415  /* "There is no space to create a capture file on the specified device." */
#define IDS_CAP_SETFILESIZE         416  /* "Set File Size" */
#define IDS_CAP_SAVEASPERCENT       417  /* "SaveAs: %2ld%%  Hit Escape to abort." */
                
#define IDS_CAP_DRIVER_ERROR        418  /* Driver specific error message */

#define IDS_CAP_WAVE_OPEN_ERROR     419  /* "Error: Cannot open the wave input device.\nCheck sample size, frequency, and channels." */
#define IDS_CAP_WAVE_ALLOC_ERROR    420  /* "Error: Out of memory for wave buffers." */
#define IDS_CAP_WAVE_PREPARE_ERROR  421  /* "Error: Cannot prepare wave buffers." */
#define IDS_CAP_WAVE_ADD_ERROR      422  /* "Error: Cannot add wave buffers." */
#define IDS_CAP_WAVE_SIZE_ERROR     423  /* "Error: Bad wave size." */
                
#define IDS_CAP_VIDEO_OPEN_ERROR    424  /* "Error: Cannot open the video input device." */
#define IDS_CAP_VIDEO_ALLOC_ERROR   425  /* "Error: Out of memory for video buffers." */
#define IDS_CAP_VIDEO_PREPARE_ERROR 426  /* "Error: Cannot prepare video buffers." */
#define IDS_CAP_VIDEO_ADD_ERROR     427  /* "Error: Cannot add video buffers." */
#define IDS_CAP_VIDEO_SIZE_ERROR    428  /* "Error: Bad video size." */
                
#define IDS_CAP_FILE_OPEN_ERROR     429  /* "Error: Cannot open capture file." */
#define IDS_CAP_FILE_WRITE_ERROR    430  /* "Error: Cannot write to capture file.  Disk may be full." */
#define IDS_CAP_RECORDING_ERROR     431  /* "Error: Cannot write to capture file.  Data rate too high or disk full." */
#define IDS_CAP_RECORDING_ERROR2    432  /* "Error while recording" */
#define IDS_CAP_AVI_INIT_ERROR      433  /* "Error: Unable to initialize for capture." */
#define IDS_CAP_NO_FRAME_CAP_ERROR  434  /* "Warning: No frames captured.\nConfirm that vertical sync interrupts\nare configured and enabled." */
#define IDS_CAP_NO_PALETTE_WARN     435  /* "Warning: Using default palette." */
#define IDS_CAP_MCI_CONTROL_ERROR   436  /* "Error: Unable to access MCI device." */
#define IDS_CAP_MCI_CANT_STEP_ERROR 437  /* "Error: Unable to step MCI device." */
#define IDS_CAP_NO_AUDIO_CAP_ERROR  438  /* "Error: No audio data captured.\nCheck audio card settings." */
#define IDS_CAP_AVI_DRAWDIB_ERROR   439  /* "Error: Unable to draw this data format." */
#define IDS_CAP_COMPRESSOR_ERROR    440  /* "Error: Unable to initialize compressor." */
#define IDS_CAP_AUDIO_DROP_ERROR    441  /* "Error: Audio data was lost during capture, reduce capture rate." */
                
/* status string IDs */
#define IDS_CAP_STAT_LIVE_MODE      500  /* "Live window" */
#define IDS_CAP_STAT_OVERLAY_MODE   501  /* "Overlay window" */
#define IDS_CAP_STAT_CAP_INIT       502  /* "Setting up for capture - Please wait" */
#define IDS_CAP_STAT_CAP_FINI       503  /* "Finished capture, now writing frame %ld" */
#define IDS_CAP_STAT_PALETTE_BUILD  504  /* "Building palette map" */
#define IDS_CAP_STAT_OPTPAL_BUILD   505  /* "Computing optimal palette" */
#define IDS_CAP_STAT_I_FRAMES       506  /* "%d frames" */
#define IDS_CAP_STAT_L_FRAMES       507  /* "%ld frames" */
#define IDS_CAP_STAT_CAP_L_FRAMES   508  /* "Captured %ld frames" */
#define IDS_CAP_STAT_CAP_AUDIO      509  /* "Capturing audio" */
#define IDS_CAP_STAT_VIDEOCURRENT   510  /* "Captured %ld frames (%ld dropped) %d.%03d sec." */
#define IDS_CAP_STAT_VIDEOAUDIO     511  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps).  %ld audio bytes (%d,%03d sps)" */
#define IDS_CAP_STAT_VIDEOONLY      512  /* "Captured %d.%03d sec.  %ld frames (%ld dropped) (%d.%03d fps)" */
#define IDS_CAP_STAT_FRAMESDROPPED  513  /* "Dropped %ld of %ld frames (%d.%02d%%) during capture." */
#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif /* INC_AVICAP */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\avifile.h ===
/****************************************************************************
 *
 *  AVIFILE.H
 *
 *  routines for reading Standard AVI files
 *
 *  Copyright (c) 1992 - 1994 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#if !defined( _AVIFILE_H_ )
#define _AVIFILE_H_

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin_vfw32

/*
 * Ansi - Unicode thunking.
 *
 * Unicode or Ansi-only apps can call the avifile APIs.
 * any Win32 app who wants to use
 * any of the AVI COM interfaces must be UNICODE - the AVISTREAMINFO and
 * AVIFILEINFO structures used in the Info methods of these interfaces are
 * the unicode variants, and no thunking to or from ansi takes place
 * except in the AVIFILE api entrypoints.
 *
 * For Ansi/Unicode thunking: for each entrypoint or structure that
 * uses chars or strings, two versions are declared in the Win32 version,
 * ApiNameW and ApiNameA. The default name ApiName is #defined to one or
 * other of these depending on whether UNICODE is defined (during
 * compilation of the app that is including this header). The source will
 * contain ApiName and ApiNameA (with ApiName being the Win16 implementation,
 * and also #defined to ApiNameW, and ApiNameA being the thunk entrypoint).
 *
 */

#ifndef mmioFOURCC
    #define mmioFOURCC( ch0, ch1, ch2, ch3 ) \
	( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
	( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef streamtypeVIDEO
#define streamtypeVIDEO		mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO		mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI		mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT		mmioFOURCC('t', 'x', 't', 's')
#endif

#ifndef AVIIF_KEYFRAME
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.
#endif

//
// Structures used by AVIStreamInfo & AVIFileInfo.
//
// These are related to, but not identical to, the header chunks
// in an AVI file.
//

/*
 *
 * --- AVISTREAMINFO ------------------------------------------------
 *
 * for Unicode/Ansi thunking we need to declare three versions of this!
 */
// end_vfw32
#ifdef WIN32
// begin_vfw32
typedef struct _AVISTREAMINFOW {
    DWORD		fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD		dwCaps;
    WORD		wPriority;
    WORD		wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD		dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    RECT                rcFrame;
    DWORD		dwEditCount;
    DWORD		dwFormatChangeCount;
    WCHAR		szName[64];
} AVISTREAMINFOW, FAR * LPAVISTREAMINFOW;

typedef struct _AVISTREAMINFOA {
    DWORD		fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD		dwCaps;
    WORD		wPriority;
    WORD		wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD		dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    RECT                rcFrame;
    DWORD		dwEditCount;
    DWORD		dwFormatChangeCount;
    char		szName[64];
} AVISTREAMINFOA, FAR * LPAVISTREAMINFOA;

#ifdef UNICODE
#define AVISTREAMINFO	AVISTREAMINFOW
#define LPAVISTREAMINFO	LPAVISTREAMINFOW
#else
#define AVISTREAMINFO	AVISTREAMINFOA
#define LPAVISTREAMINFO	LPAVISTREAMINFOA
#endif

// end_vfw32

#else //win16 variant

#define AVISTREAMINFOW	AVISTREAMINFO
typedef struct _AVISTREAMINFO {
    DWORD		fccType;
    DWORD               fccHandler;
    DWORD               dwFlags;        /* Contains AVITF_* flags */
    DWORD		dwCaps;
    WORD		wPriority;
    WORD		wLanguage;
    DWORD               dwScale;
    DWORD               dwRate; /* dwRate / dwScale == samples/second */
    DWORD               dwStart;
    DWORD               dwLength; /* In units above... */
    DWORD		dwInitialFrames;
    DWORD               dwSuggestedBufferSize;
    DWORD               dwQuality;
    DWORD               dwSampleSize;
    RECT                rcFrame;
    DWORD		dwEditCount;
    DWORD		dwFormatChangeCount;
    char		szName[64];
} AVISTREAMINFO, FAR * LPAVISTREAMINFO;

#endif

// begin_vfw32

#define AVISTREAMINFO_DISABLED			0x00000001
#define AVISTREAMINFO_FORMATCHANGES		0x00010000

/*
 * --- AVIFILEINFO ----------------------------------------------------
 *
 */

// end_vfw32

#ifdef WIN32

// begin_vfw32

typedef struct _AVIFILEINFOW {
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwCaps;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwLength;

    DWORD		dwEditCount;

    WCHAR		szFileType[64];		// descriptive string for file type?
} AVIFILEINFOW, FAR * LPAVIFILEINFOW;

typedef struct _AVIFILEINFOA {
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwCaps;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwLength;

    DWORD		dwEditCount;

    char		szFileType[64];		// descriptive string for file type?
} AVIFILEINFOA, FAR * LPAVIFILEINFOA;

#ifdef UNICODE
#define AVIFILEINFO	AVIFILEINFOW
#define LPAVIFILEINFO	LPAVIFILEINFOW
#else
#define AVIFILEINFO	AVIFILEINFOA
#define LPAVIFILEINFO	LPAVIFILEINFOA
#endif

// end_vfw32

#else  // win16 variant

#define AVIFILEINFOW	AVIFILEINFO
typedef struct _AVIFILEINFO {
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwCaps;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;

    DWORD		dwWidth;
    DWORD		dwHeight;

    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwLength;

    DWORD		dwEditCount;

    char		szFileType[64];		// descriptive string for file type?
} AVIFILEINFO, FAR * LPAVIFILEINFO;

#endif

// begin_vfw32

// Flags for dwFlags
#define AVIFILEINFO_HASINDEX		0x00000010
#define AVIFILEINFO_MUSTUSEINDEX	0x00000020
#define AVIFILEINFO_ISINTERLEAVED	0x00000100
#define AVIFILEINFO_WASCAPTUREFILE	0x00010000
#define AVIFILEINFO_COPYRIGHTED		0x00020000

// Flags for dwCaps
#define AVIFILECAPS_CANREAD		0x00000001
#define AVIFILECAPS_CANWRITE		0x00000002
#define AVIFILECAPS_ALLKEYFRAMES	0x00000010
#define AVIFILECAPS_NOCOMPRESSION	0x00000020

typedef BOOL (FAR PASCAL * AVISAVECALLBACK)(int);

/************************************************************************/
/* Declaration for the AVICOMPRESSOPTIONS structure.  Make sure it 	*/
/* matches the AutoDoc in avisave.c !!!                            	*/
/************************************************************************/

typedef struct {
    DWORD	fccType;		    /* stream type, for consistency */
    DWORD       fccHandler;                 /* compressor */
    DWORD       dwKeyFrameEvery;            /* keyframe rate */
    DWORD       dwQuality;                  /* compress quality 0-10,000 */
    DWORD       dwBytesPerSecond;           /* bytes per second */
    DWORD       dwFlags;                    /* flags... see below */
    LPVOID      lpFormat;                   /* save format */
    DWORD       cbFormat;
    LPVOID      lpParms;                    /* compressor options */
    DWORD       cbParms;
    DWORD       dwInterleaveEvery;          /* for non-video streams only */
} AVICOMPRESSOPTIONS, FAR *LPAVICOMPRESSOPTIONS;

//
// Defines for the dwFlags field of the AVICOMPRESSOPTIONS struct
// Each of these flags determines if the appropriate field in the structure
// (dwInterleaveEvery, dwBytesPerSecond, and dwKeyFrameEvery) is payed
// attention to.  See the autodoc in avisave.c for details.
//
#define AVICOMPRESSF_INTERLEAVE		0x00000001    // interleave
#define AVICOMPRESSF_DATARATE		0x00000002    // use a data rate
#define AVICOMPRESSF_KEYFRAMES		0x00000004    // use keyframes
#define AVICOMPRESSF_VALID		0x00000008    // has valid data?

// end_vfw32

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#include "aviiface.h"


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin2_vfw32

//
// functions
//

STDAPI_(void) AVIFileInit(void);   // Call this first!
STDAPI_(void) AVIFileExit(void);

STDAPI_(ULONG) AVIFileAddRef       (PAVIFILE pfile);
STDAPI_(ULONG) AVIFileRelease      (PAVIFILE pfile);

#ifdef WIN32
STDAPI AVIFileOpenA       (PAVIFILE FAR * ppfile, LPCSTR szFile,
			  UINT uMode, LPCLSID lpHandler);
STDAPI AVIFileOpenW       (PAVIFILE FAR * ppfile, LPCWSTR szFile,
			  UINT uMode, LPCLSID lpHandler);
#ifdef UNICODE
#define AVIFileOpen	  AVIFileOpenW	
#else
#define AVIFileOpen	  AVIFileOpenA	
#endif
#else // win16
STDAPI AVIFileOpen       (PAVIFILE FAR * ppfile, LPCSTR szFile,
			  UINT uMode, LPCLSID lpHandler);
#endif

#ifdef WIN32
STDAPI AVIFileInfoW (PAVIFILE pfile, LPAVIFILEINFOW pfi, LONG lSize);
STDAPI AVIFileInfoA (PAVIFILE pfile, LPAVIFILEINFOA pfi, LONG lSize);
#ifdef UNICODE
#define AVIFileInfo	AVIFileInfoW
#else
#define AVIFileInfo	AVIFileInfoA
#endif
#else //win16 version
STDAPI AVIFileInfo (PAVIFILE pfile, LPAVIFILEINFO pfi, LONG lSize);
#endif


STDAPI AVIFileGetStream     (PAVIFILE pfile, PAVISTREAM FAR * ppavi, DWORD fccType, LONG lParam);


STDAPI AVIFileCreateStream  (PAVIFILE pfile,
					 PAVISTREAM FAR *ppavi,
					 AVISTREAMINFOW FAR *psi);

STDAPI AVIFileWriteData	(PAVIFILE pfile,
					 DWORD ckid,
					 LPVOID lpData,
					 LONG cbData);
STDAPI AVIFileReadData	(PAVIFILE pfile,
					 DWORD ckid,
					 LPVOID lpData,
					 LONG FAR *lpcbData);
STDAPI AVIFileEndRecord	(PAVIFILE pfile);

STDAPI_(ULONG) AVIStreamAddRef       (PAVISTREAM pavi);
STDAPI_(ULONG) AVIStreamRelease      (PAVISTREAM pavi);

// end2_vfw32

#ifdef WIN32
// begin2_vfw32
STDAPI AVIStreamInfoW (PAVISTREAM pavi, LPAVISTREAMINFOW psi, LONG lSize);
STDAPI AVIStreamInfoA (PAVISTREAM pavi, LPAVISTREAMINFOA psi, LONG lSize);
#ifdef UNICODE
#define AVIStreamInfo	AVIStreamInfoW
#else
#define AVIStreamInfo	AVIStreamInfoA
#endif
// end2_vfw32
#else // win16
STDAPI AVIStreamInfo (PAVISTREAM pavi, LPAVISTREAMINFO psi, LONG lSize);
#endif

// begin2_vfw32

STDAPI_(LONG) AVIStreamFindSample(PAVISTREAM pavi, LONG lPos, LONG lFlags);
STDAPI AVIStreamReadFormat   (PAVISTREAM pavi, LONG lPos,LPVOID lpFormat,LONG FAR *lpcbFormat);
STDAPI AVIStreamSetFormat    (PAVISTREAM pavi, LONG lPos,LPVOID lpFormat,LONG cbFormat);
STDAPI AVIStreamReadData     (PAVISTREAM pavi, DWORD fcc, LPVOID lp, LONG FAR *lpcb);
STDAPI AVIStreamWriteData    (PAVISTREAM pavi, DWORD fcc, LPVOID lp, LONG cb);

STDAPI AVIStreamRead         (PAVISTREAM pavi,
			      LONG lStart,
			      LONG lSamples,
			      LPVOID lpBuffer,
			      LONG cbBuffer,
			      LONG FAR * plBytes,
			      LONG FAR * plSamples);
#define AVISTREAMREAD_CONVENIENT	(-1L)

STDAPI AVIStreamWrite        (PAVISTREAM pavi,
			      LONG lStart, LONG lSamples,
			      LPVOID lpBuffer, LONG cbBuffer, DWORD dwFlags,
			      LONG FAR *plSampWritten,
			      LONG FAR *plBytesWritten);

// Right now, these just use AVIStreamInfo() to get information, then
// return some of it.  Can they be more efficient?
STDAPI_(LONG) AVIStreamStart        (PAVISTREAM pavi);
STDAPI_(LONG) AVIStreamLength       (PAVISTREAM pavi);
STDAPI_(LONG) AVIStreamTimeToSample (PAVISTREAM pavi, LONG lTime);
STDAPI_(LONG) AVIStreamSampleToTime (PAVISTREAM pavi, LONG lSample);


STDAPI AVIStreamBeginStreaming(PAVISTREAM pavi, LONG lStart, LONG lEnd, LONG lRate);
STDAPI AVIStreamEndStreaming(PAVISTREAM pavi);

//
// helper functions for using IGetFrame
//
STDAPI_(PGETFRAME) AVIStreamGetFrameOpen(PAVISTREAM pavi,
					 LPBITMAPINFOHEADER lpbiWanted);
STDAPI_(LPVOID) AVIStreamGetFrame(PGETFRAME pg, LONG lPos);
STDAPI AVIStreamGetFrameClose(PGETFRAME pg);


// !!! We need some way to place an advise on a stream....
// STDAPI AVIStreamHasChanged   (PAVISTREAM pavi);



// Shortcut function
// end2_vfw32
#ifdef WIN32
// begin2_vfw32
STDAPI AVIStreamOpenFromFileA(PAVISTREAM FAR *ppavi, LPCSTR szFile,
			     DWORD fccType, LONG lParam,
			     UINT mode, CLSID FAR *pclsidHandler);
STDAPI AVIStreamOpenFromFileW(PAVISTREAM FAR *ppavi, LPCWSTR szFile,
			     DWORD fccType, LONG lParam,
			     UINT mode, CLSID FAR *pclsidHandler);
#ifdef UNICODE
#define AVIStreamOpenFromFile	AVIStreamOpenFromFileW
#else
#define AVIStreamOpenFromFile	AVIStreamOpenFromFileA
#endif
// end2_vfw32
#else // win16
STDAPI AVIStreamOpenFromFile(PAVISTREAM FAR *ppavi, LPCSTR szFile,
			     DWORD fccType, LONG lParam,
			     UINT mode, CLSID FAR *pclsidHandler);
#endif
// begin2_vfw32

// Use to create disembodied streams
STDAPI AVIStreamCreate(PAVISTREAM FAR *ppavi, LONG lParam1, LONG lParam2,
		       CLSID FAR *pclsidHandler);



// PHANDLER    AVIAPI AVIGetHandler         (PAVISTREAM pavi, PAVISTREAMHANDLER psh);
// PAVISTREAM  AVIAPI AVIGetStream          (PHANDLER p);

//
// flags for AVIStreamFindSample
//
#define FIND_DIR        0x0000000FL     // direction
#define FIND_NEXT       0x00000001L     // go forward
#define FIND_PREV       0x00000004L     // go backward

#define FIND_TYPE       0x000000F0L     // type mask
#define FIND_KEY        0x00000010L     // find key frame.
#define FIND_ANY        0x00000020L     // find any (non-empty) sample
#define FIND_FORMAT     0x00000040L     // find format change

#define FIND_RET        0x0000F000L     // return mask
#define FIND_POS        0x00000000L     // return logical position
#define FIND_LENGTH     0x00001000L     // return logical size
#define FIND_OFFSET     0x00002000L     // return physical position
#define FIND_SIZE       0x00003000L     // return physical size
#define FIND_INDEX      0x00004000L     // return physical index position


//
//  stuff to support backward compat.
//
#define AVIStreamFindKeyFrame AVIStreamFindSample
#define FindKeyFrame	FindSample

#define AVIStreamClose AVIStreamRelease
#define AVIFileClose   AVIFileRelease
#define AVIStreamInit  AVIFileInit
#define AVIStreamExit  AVIFileExit

#define SEARCH_NEAREST  FIND_PREV
#define SEARCH_BACKWARD FIND_PREV
#define SEARCH_FORWARD  FIND_NEXT
#define SEARCH_KEY      FIND_KEY
#define SEARCH_ANY      FIND_ANY

//
//  helper macros.
//
#define     AVIStreamSampleToSample(pavi1, pavi2, l) \
            AVIStreamTimeToSample(pavi1,AVIStreamSampleToTime(pavi2, l))

#define     AVIStreamNextSample(pavi, l) \
            AVIStreamFindSample(pavi,l+1,FIND_NEXT|FIND_ANY)

#define     AVIStreamPrevSample(pavi, l) \
            AVIStreamFindSample(pavi,l-1,FIND_PREV|FIND_ANY)

#define     AVIStreamNearestSample(pavi, l) \
            AVIStreamFindSample(pavi,l,FIND_PREV|FIND_ANY)

#define     AVIStreamNextKeyFrame(pavi,l) \
            AVIStreamFindSample(pavi,l+1,FIND_NEXT|FIND_KEY)

#define     AVIStreamPrevKeyFrame(pavi, l) \
            AVIStreamFindSample(pavi,l-1,FIND_PREV|FIND_KEY)

#define     AVIStreamNearestKeyFrame(pavi, l) \
            AVIStreamFindSample(pavi,l,FIND_PREV|FIND_KEY)

#define     AVIStreamIsKeyFrame(pavi, l) \
            (AVIStreamNearestKeyFrame(pavi,l) == l)

#define     AVIStreamPrevSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamPrevSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNextSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNextSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNearestSampleTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNearestSample(pavi,AVIStreamTimeToSample(pavi,t)))

#define     AVIStreamNextKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNextKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamPrevKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamPrevKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamNearestKeyFrameTime(pavi, t) \
            AVIStreamSampleToTime(pavi, AVIStreamNearestKeyFrame(pavi,AVIStreamTimeToSample(pavi, t)))

#define     AVIStreamStartTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamStart(pavi))

#define     AVIStreamLengthTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamLength(pavi))

#define     AVIStreamEnd(pavi) \
            (AVIStreamStart(pavi) + AVIStreamLength(pavi))

#define     AVIStreamEndTime(pavi) \
            AVIStreamSampleToTime(pavi, AVIStreamEnd(pavi))

#define     AVIStreamSampleSize(pavi, lPos, plSize) \
	    AVIStreamRead(pavi,lPos,1,NULL,0,plSize,NULL)

#define     AVIStreamFormatSize(pavi, lPos, plSize) \
            AVIStreamReadFormat(pavi,lPos,NULL,plSize)

#define     AVIStreamDataSize(pavi, fcc, plSize) \
            AVIStreamReadData(pavi,fcc,NULL,plSize)

/****************************************************************************
 *
 *  AVISave routines and structures
 *
 ***************************************************************************/

#ifndef comptypeDIB
#define comptypeDIB         mmioFOURCC('D', 'I', 'B', ' ')
#endif

STDAPI AVIMakeCompressedStream(
		PAVISTREAM FAR *	    ppsCompressed,
		PAVISTREAM		    ppsSource,
		AVICOMPRESSOPTIONS FAR *    lpOptions,
		CLSID FAR *pclsidHandler);

// end2_vfw32
#ifdef WIN32
// begin2_vfw32
EXTERN_C HRESULT CDECL AVISaveA (LPCSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM	    pfile,
		LPAVICOMPRESSOPTIONS lpOptions,
		...);

STDAPI AVISaveVA(LPCSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM FAR *    ppavi,
		LPAVICOMPRESSOPTIONS FAR *plpOptions);
EXTERN_C HRESULT CDECL AVISaveW (LPCWSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM	    pfile,
		LPAVICOMPRESSOPTIONS lpOptions,
		...);

STDAPI AVISaveVW(LPCWSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM FAR *    ppavi,
		LPAVICOMPRESSOPTIONS FAR *plpOptions);
#ifdef UNICODE
#define AVISave		AVISaveW
#define AVISaveV	AVISaveVW
#else
#define AVISave		AVISaveA
#define AVISaveV	AVISaveVA
#endif
// end2_vfw32
#else // Win16
EXTERN_C HRESULT CDECL AVISave (LPCTSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM	    pfile,
		LPAVICOMPRESSOPTIONS lpOptions,
		...);

STDAPI AVISaveV(LPCTSTR               szFile,
		CLSID FAR *pclsidHandler,
		AVISAVECALLBACK     lpfnCallback,
		int                 nStreams,
		PAVISTREAM FAR *    ppavi,
		LPAVICOMPRESSOPTIONS FAR *plpOptions);

#endif
// begin2_vfw32



STDAPI_(BOOL) AVISaveOptions(HWND hwnd,
			     UINT	uiFlags,
			     int	nStreams,
			     PAVISTREAM FAR *ppavi,
			     LPAVICOMPRESSOPTIONS FAR *plpOptions);

STDAPI AVISaveOptionsFree(int nStreams,
			     LPAVICOMPRESSOPTIONS FAR *plpOptions);

// FLAGS FOR uiFlags:
//
// Same as the flags for ICCompressorChoose (see compman.h)
// These determine what the compression options dialog for video streams
// will look like.

// end2_vfw32
#ifdef WIN32
// begin2_vfw32
STDAPI AVIBuildFilterW(LPWSTR lpszFilter, LONG cbFilter, BOOL fSaving);
STDAPI AVIBuildFilterA(LPSTR lpszFilter, LONG cbFilter, BOOL fSaving);
#ifdef UNICODE
#define AVIBuildFilter	AVIBuildFilterW
#else
#define AVIBuildFilter	AVIBuildFilterA
#endif
// end2_vfw32
#else //win16
STDAPI AVIBuildFilter(LPTSTR lpszFilter, LONG cbFilter, BOOL fSaving);
#endif

// begin2_vfw32
STDAPI AVIMakeFileFromStreams(PAVIFILE FAR *	ppfile,
			       int		nStreams,
			       PAVISTREAM FAR *	papStreams);

STDAPI AVIMakeStreamFromClipboard(UINT cfFormat, HANDLE hGlobal, PAVISTREAM FAR *ppstream);

/****************************************************************************
 *
 *  Clipboard routines
 *
 ***************************************************************************/

STDAPI AVIPutFileOnClipboard(PAVIFILE pf);

STDAPI AVIGetFromClipboard(PAVIFILE FAR * lppf);

STDAPI AVIClearClipboard(void);

/****************************************************************************
 *
 *  Editing routines
 *
 ***************************************************************************/
STDAPI CreateEditableStream(
		PAVISTREAM FAR *	    ppsEditable,
		PAVISTREAM		    psSource);

STDAPI EditStreamCut(PAVISTREAM pavi, LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult);

STDAPI EditStreamCopy(PAVISTREAM pavi, LONG FAR *plStart, LONG FAR *plLength, PAVISTREAM FAR * ppResult);

STDAPI EditStreamPaste(PAVISTREAM pavi, LONG FAR *plPos, LONG FAR *plLength, PAVISTREAM pstream, LONG lStart, LONG lEnd);

STDAPI EditStreamClone(PAVISTREAM pavi, PAVISTREAM FAR *ppResult);


// end2_vfw32
#ifdef WIN32
// begin2_vfw32
STDAPI EditStreamSetNameA(PAVISTREAM pavi, LPCSTR lpszName);
STDAPI EditStreamSetNameW(PAVISTREAM pavi, LPCWSTR lpszName);
STDAPI EditStreamSetInfoW(PAVISTREAM pavi, LPAVISTREAMINFOW lpInfo, LONG cbInfo);
STDAPI EditStreamSetInfoA(PAVISTREAM pavi, LPAVISTREAMINFOA lpInfo, LONG cbInfo);
#ifdef UNICODE
#define EditStreamSetInfo	EditStreamSetInfoW
#define EditStreamSetName	EditStreamSetNameW
#else
#define EditStreamSetInfo	EditStreamSetInfoA
#define EditStreamSetName	EditStreamSetNameA
#endif
// end2_vfw32
#else // win16
STDAPI EditStreamSetInfo(PAVISTREAM pavi, LPAVISTREAMINFO lpInfo, LONG cbInfo);
STDAPI EditStreamSetName(PAVISTREAM pavi, LPCTSTR lpszName);
#endif


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif

// begin2_vfw32

/*	-	-	-	-	-	-	-	-	*/

#ifndef AVIERR_OK
#define AVIERR_OK               0L

#define MAKE_AVIERR(error)	MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x4000 + error)

// !!! Questions to be answered:
// How can you get a string form of these errors?
// Which of these errors should be replaced by errors in SCODE.H?
#define AVIERR_UNSUPPORTED      MAKE_AVIERR(101)
#define AVIERR_BADFORMAT        MAKE_AVIERR(102)
#define AVIERR_MEMORY           MAKE_AVIERR(103)
#define AVIERR_INTERNAL         MAKE_AVIERR(104)
#define AVIERR_BADFLAGS         MAKE_AVIERR(105)
#define AVIERR_BADPARAM         MAKE_AVIERR(106)
#define AVIERR_BADSIZE          MAKE_AVIERR(107)
#define AVIERR_BADHANDLE        MAKE_AVIERR(108)
#define AVIERR_FILEREAD         MAKE_AVIERR(109)
#define AVIERR_FILEWRITE        MAKE_AVIERR(110)
#define AVIERR_FILEOPEN         MAKE_AVIERR(111)
#define AVIERR_COMPRESSOR       MAKE_AVIERR(112)
#define AVIERR_NOCOMPRESSOR     MAKE_AVIERR(113)
#define AVIERR_READONLY		MAKE_AVIERR(114)
#define AVIERR_NODATA		MAKE_AVIERR(115)
#define AVIERR_BUFFERTOOSMALL	MAKE_AVIERR(116)
#define AVIERR_CANTCOMPRESS	MAKE_AVIERR(117)
#define AVIERR_USERABORT        MAKE_AVIERR(198)
#define AVIERR_ERROR            MAKE_AVIERR(199)
#endif
// end2_vfw32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\avifmt.h ===
/****************************************************************************/
/*                                                                          */
/*        AVIFMT.H - Include file for working with AVI files                */
/*                                                                          */
/*        Note: You must include WINDOWS.H and MMSYSTEM.H before            */
/*        including this file.                                              */
/*                                                                          */
/*        Copyright (c) 1991-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_AVIFMT
#define _INC_AVIFMT	100	/* version number * 100 + revision */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef _MSC_VER
#pragma warning(disable:4200)
#endif
    
/* The following is a short description of the AVI file format.  Please
 * see the accompanying documentation for a full explanation.
 *
 * An AVI file is the following RIFF form:
 *
 *	RIFF('AVI' 
 *	      LIST('hdrl'
 *		    avih(<MainAVIHeader>)
 *                  LIST ('strl'
 *                      strh(<Stream header>)
 *                      strf(<Stream format>)
 *                      ... additional header data
 *            LIST('movi'	 
 *      	  { LIST('rec' 
 *      		      SubChunk...
 *      		   )
 *      	      | SubChunk } ....	    
 *            )
 *            [ <AVIIndex> ]
 *      )
 *
 *	The main file header specifies how many streams are present.  For
 *	each one, there must be a stream header chunk and a stream format
 *	chunk, enlosed in a 'strl' LIST chunk.  The 'strf' chunk contains
 *	type-specific format information; for a video stream, this should
 *	be a BITMAPINFO structure, including palette.  For an audio stream,
 *	this should be a WAVEFORMAT (or PCMWAVEFORMAT) structure.
 *
 *	The actual data is contained in subchunks within the 'movi' LIST 
 *	chunk.  The first two characters of each data chunk are the
 *	stream number with which that data is associated.
 *
 *	Some defined chunk types:
 *           Video Streams:
 *                  ##db:	RGB DIB bits
 *                  ##dc:	RLE8 compressed DIB bits
 *                  ##pc:	Palette Change
 *
 *           Audio Streams:
 *                  ##wb:	waveform audio bytes
 *
 * The grouping into LIST 'rec' chunks implies only that the contents of
 *   the chunk should be read into memory at the same time.  This
 *   grouping is used for files specifically intended to be played from 
 *   CD-ROM.
 *
 * The index chunk at the end of the file should contain one entry for 
 *   each data chunk in the file.
 *       
 * Limitations for the current software:
 *	Only one video stream and one audio stream are allowed.
 *	The streams must start at the beginning of the file.
 *
 * 
 * To register codec types please obtain a copy of the Multimedia
 * Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 */


#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

/* Macro to make a TWOCC out of two characters */
#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

typedef WORD TWOCC;

/* form types, list types, and chunk types */
#define formtypeAVI             mmioFOURCC('A', 'V', 'I', ' ')
#define listtypeAVIHEADER       mmioFOURCC('h', 'd', 'r', 'l')
#define ckidAVIMAINHDR          mmioFOURCC('a', 'v', 'i', 'h')
#define listtypeSTREAMHEADER    mmioFOURCC('s', 't', 'r', 'l')
#define ckidSTREAMHEADER        mmioFOURCC('s', 't', 'r', 'h')
#define ckidSTREAMFORMAT        mmioFOURCC('s', 't', 'r', 'f')
#define ckidSTREAMHANDLERDATA   mmioFOURCC('s', 't', 'r', 'd')
#define ckidSTREAMNAME		mmioFOURCC('s', 't', 'r', 'n')

#define listtypeAVIMOVIE        mmioFOURCC('m', 'o', 'v', 'i')
#define listtypeAVIRECORD       mmioFOURCC('r', 'e', 'c', ' ')

#define ckidAVINEWINDEX         mmioFOURCC('i', 'd', 'x', '1')

/*
** Stream types for the <fccType> field of the stream header.
*/
#define streamtypeVIDEO         mmioFOURCC('v', 'i', 'd', 's')
#define streamtypeAUDIO         mmioFOURCC('a', 'u', 'd', 's')
#define streamtypeMIDI		mmioFOURCC('m', 'i', 'd', 's')
#define streamtypeTEXT          mmioFOURCC('t', 'x', 't', 's')

/* Basic chunk types */
#define cktypeDIBbits           aviTWOCC('d', 'b')
#define cktypeDIBcompressed     aviTWOCC('d', 'c')
#define cktypePALchange         aviTWOCC('p', 'c')
#define cktypeWAVEbytes         aviTWOCC('w', 'b')

/* Chunk id to use for extra chunks for padding. */
#define ckidAVIPADDING          mmioFOURCC('J', 'U', 'N', 'K')


/*
** Useful macros
**
** Warning: These are nasty macro, and MS C 6.0 compiles some of them
** incorrectly if optimizations are on.  Ack.
*/

/* Macro to get stream number out of a FOURCC ckid */
#define FromHex(n)	(((n) >= 'A') ? ((n) + 10 - 'A') : ((n) - '0'))
#define StreamFromFOURCC(fcc) ((WORD) ((FromHex(LOBYTE(LOWORD(fcc))) << 4) + \
                                             (FromHex(HIBYTE(LOWORD(fcc))))))

/* Macro to get TWOCC chunk type out of a FOURCC ckid */
#define TWOCCFromFOURCC(fcc)    HIWORD(fcc)

/* Macro to make a ckid for a chunk out of a TWOCC and a stream number
** from 0-255.
*/
#define ToHex(n)	((BYTE) (((n) > 9) ? ((n) - 10 + 'A') : ((n) + '0')))
#define MAKEAVICKID(tcc, stream) \
        MAKELONG((ToHex((stream) & 0x0f) << 8) | \
			    (ToHex(((stream) & 0xf0) >> 4)), tcc)


/*
** Main AVI File Header 
*/	     
		     
/* flags for use in <dwFlags> in AVIFileHdr */
#define AVIF_HASINDEX		0x00000010	// Index at end of file?
#define AVIF_MUSTUSEINDEX	0x00000020
#define AVIF_ISINTERLEAVED	0x00000100
#define AVIF_WASCAPTUREFILE	0x00010000
#define AVIF_COPYRIGHTED	0x00020000

/* The AVI File Header LIST chunk should be padded to this size */
#define AVI_HEADERSIZE  2048                    // size of AVI header list

typedef struct
{
    DWORD		dwMicroSecPerFrame;	// frame display rate (or 0L)
    DWORD		dwMaxBytesPerSec;	// max. transfer rate
    DWORD		dwPaddingGranularity;	// pad to multiples of this
                                                // size; normally 2K.
    DWORD		dwFlags;		// the ever-present flags
    DWORD		dwTotalFrames;		// # frames in file
    DWORD		dwInitialFrames;
    DWORD		dwStreams;
    DWORD		dwSuggestedBufferSize;
    
    DWORD		dwWidth;
    DWORD		dwHeight;
    
    DWORD		dwReserved[4];
} MainAVIHeader;


/*
** Stream header
*/

#define AVISF_DISABLED			0x00000001

#define AVISF_VIDEO_PALCHANGES		0x00010000

typedef struct {
    FOURCC		fccType;
    FOURCC		fccHandler;
    DWORD		dwFlags;	/* Contains AVITF_* flags */
    WORD		wPriority;
    WORD		wLanguage;
    DWORD		dwInitialFrames;
    DWORD		dwScale;	
    DWORD		dwRate;	/* dwRate / dwScale == samples/second */
    DWORD		dwStart;
    DWORD		dwLength; /* In units above... */
    DWORD		dwSuggestedBufferSize;
    DWORD		dwQuality;
    DWORD		dwSampleSize;
    RECT		rcFrame;
} AVIStreamHeader;

/* Flags for index */
#define AVIIF_LIST          0x00000001L // chunk is a 'LIST'
#define AVIIF_KEYFRAME      0x00000010L // this frame is a key frame.

#define AVIIF_NOTIME	    0x00000100L // this frame doesn't take any time
#define AVIIF_COMPUSE       0x0FFF0000L // these bits are for compressor use

typedef struct
{
    DWORD		ckid;
    DWORD		dwFlags;
    DWORD		dwChunkOffset;		// Position of chunk
    DWORD		dwChunkLength;		// Length of chunk
} AVIINDEXENTRY;


/*
** Palette change chunk
**
** Used in video streams.
*/
typedef struct
{
    BYTE		bFirstEntry;	/* first entry to change */
    BYTE		bNumEntries;	/* # entries to change (0 if 256) */
    WORD		wFlags;		/* Mostly to preserve alignment... */
    PALETTEENTRY	peNew[];	/* New color specifications */
} AVIPALCHANGE;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif /* _INC_AVIFMT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\bmpublic.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       BMPUBLIC.H
*
*  VERSION:     2.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        20 Feb 1994
*
*  Public definitions of the battery meter tray applet.  Used for communication
*  between the control panel and the battery meter.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  20 Feb 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_BMPUBLIC
#define _INC_BMPUBLIC

#define BATTERYMETER_CLASSNAME          "BatteryMeter_Main"

//  Initialize the contents of the BatteryMeter window.
#define BMWM_INITDIALOG                 (WM_USER + 0)

//  Private tray icon notification message sent to the BatteryMeter window.
#define BMWM_NOTIFYICON                 (WM_USER + 1)

//  Private tray icon notification message sent to the BatteryMeter window.
#define BMWM_DESTROY                    (WM_USER + 2)

#endif // _INC_BMPUBLIC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\boot.inc ===
db	0EBH,03CH,090H,04DH,053H,057H,049H,04EH
	db	034H,02EH,030H,000H,002H,008H,001H,000H
	db	002H,000H,002H,003H,051H,0F8H,008H,000H
	db	011H,000H,004H,000H,001H,000H,000H,000H
	db	000H,000H,000H,000H,080H,000H,029H,000H
	db	000H,000H,000H,04EH,04FH,020H,04EH,041H
	db	04DH,045H,020H,020H,020H,020H,046H,041H
	db	054H,031H,032H,020H,020H,020H,0FAH,033H
	db	0C9H,08EH,0D1H,0BCH,0FCH,07BH,016H,007H
	db	0BDH,078H,000H,0C5H,076H,000H,01EH,056H
	db	016H,055H,0BFH,022H,005H,089H,07EH,000H
	db	089H,04EH,002H,0B1H,00BH,0FCH,0F3H,0A4H
	db	006H,01FH,0BDH,000H,07CH,0C6H,045H,0FEH
	db	00FH,08BH,046H,018H,088H,045H,0F9H,0FBH
	db	038H,066H,024H,07CH,004H,0CDH,013H,072H
	db	075H,08AH,046H,010H,098H,0F7H,066H,016H
	db	003H,046H,01CH,013H,056H,01EH,003H,046H
	db	00EH,013H,0D1H,050H,052H,089H,046H,0FCH
	db	089H,056H,0FEH,0B8H,020H,000H,08BH,076H
	db	011H,0F7H,0E6H,08BH,05EH,00BH,003H,0C3H
	db	048H,0F7H,0F3H,001H,046H,0FCH,011H,04EH
	db	0FEH,05AH,058H,0BBH,000H,007H,08BH,0FBH
	db	0B1H,001H,0E8H,091H,000H,072H,037H,0B1H
	db	00BH,056H,0BEH,0F1H,07DH,0F3H,0A6H,05EH
	db	074H,03EH,04EH,074H,00BH,003H,0F9H,083H
	db	0C7H,015H,03BH,0FBH,072H,0E9H,0EBH,0DBH
	db	0BEH,07BH,07DH,0ACH,098H,003H,0F0H,0ACH
	db	084H,0C0H,074H,017H,03CH,0FFH,074H,009H
	db	0B4H,00EH,0BBH,007H,000H,0CDH,010H,0EBH
	db	0EEH,0BEH,07EH,07DH,0EBH,0E5H,0BEH,07CH
	db	07DH,0EBH,0E0H,033H,0C0H,0CDH,016H,05EH
	db	01FH,08FH,004H,08FH,044H,002H,0CDH,019H
	db	0BEH,07DH,07DH,08BH,07DH,00FH,083H,0FFH
	db	002H,072H,0C8H,08BH,0C7H,048H,048H,08AH
	db	04EH,00DH,0F7H,0E1H,003H,046H,0FCH,013H
	db	056H,0FEH,0BBH,000H,007H,053H,0B1H,003H
	db	0E8H,023H,000H,05BH,072H,0C8H,081H,03FH
	db	04DH,05AH,075H,0A7H,081H,0BFH,000H,002H
	db	042H,04AH,075H,09FH,08BH,046H,0FCH,08BH
	db	056H,0FEH,0BBH,07BH,07DH,05EH,01FH,05EH
	db	01FH,0EAH,000H,002H,070H,000H,03BH,056H
	db	018H,0F5H,072H,02EH,050H,052H,051H,0F7H
	db	076H,018H,08AH,0CAH,041H,033H,0D2H,0F7H
	db	076H,01AH,08AH,0F2H,08AH,056H,024H,08AH
	db	0E8H,0D0H,0CCH,0D0H,0CCH,00AH,0CCH,0B8H
	db	001H,002H,0CDH,013H,059H,05AH,058H,072H
	db	009H,040H,075H,001H,042H,003H,05EH,00BH
	db	0E2H,0CCH,0C3H,003H,018H,001H,027H,00DH
	db	00AH,049H,06EH,076H,061H,06CH,069H,064H
	db	020H,073H,079H,073H,074H,065H,06DH,020H
	db	064H,069H,073H,06BH,0FFH,00DH,00AH,044H
	db	069H,073H,06BH,020H,049H,02FH,04FH,020H
	db	065H,072H,072H,06FH,072H,0FFH,00DH,00AH
	db	052H,065H,070H,06CH,061H,063H,065H,020H
	db	074H,068H,065H,020H,064H,069H,073H,06BH
	db	02CH,020H,061H,06EH,064H,020H,074H,068H
	db	065H,06EH,020H,070H,072H,065H,073H,073H
	db	020H,061H,06EH,079H,020H,06BH,065H,079H
	db	00DH,00AH,000H,049H,04FH,020H,020H,020H
	db	020H,020H,020H,053H,059H,053H,04DH,053H
	db	044H,04FH,053H,020H,020H,020H,053H,059H
	db	053H,000H,000H,000H,000H,000H,07BH,001H
	db	000H,057H,049H,04EH,042H,04FH,04FH,054H
	db	020H,053H,059H,053H,000H,000H,055H,0AAH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\aviiface.h ===
/****************************************************************************
 *
 *  AVIIFACE.H
 *
 *  Interface definitions for AVIFile
 *
 *  Copyright (c) 1992 - 1994 Microsoft Corporation.  All Rights Reserved.
 *
 *  You have a royalty-free right to use, modify, reproduce and
 *  distribute the Sample Files (and/or any modified version) in
 *  any way you find useful, provided that you agree that
 *  Microsoft has no warranty obligations or liability for any
 *  Sample Application Files which are modified.
 *
 ***************************************************************************/

#ifdef WIN32
#include <ole2.h>
#else
#include <compobj.h>
#endif

#ifndef RIID
#if defined(__cplusplus)
#define	RIID	IID FAR&
#define	RCLSID	CLSID FAR&
#else
#define	RIID	IID FAR*
#define	RCLSID	CLSID FAR*
#endif
#endif


/*	-	-	-	-	-	-	-	-	*/


/****** AVI Stream Interface *******************************************/

#undef  INTERFACE
#define INTERFACE   IAVIStream

DECLARE_INTERFACE_(IAVIStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIStream methods ***
    STDMETHOD(Create)      (THIS_ LPARAM lParam1, LPARAM lParam2) PURE ;
    STDMETHOD(Info)        (THIS_ AVISTREAMINFO FAR * psi, LONG lSize) PURE ;
    STDMETHOD_(LONG, FindSample)(THIS_ LONG lPos, LONG lFlags) PURE ;
    STDMETHOD(ReadFormat)  (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG FAR *lpcbFormat) PURE ;
    STDMETHOD(SetFormat)   (THIS_ LONG lPos,
			    LPVOID lpFormat, LONG cbFormat) PURE ;
    STDMETHOD(Read)        (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    LONG FAR * plBytes, LONG FAR * plSamples) PURE ;
    STDMETHOD(Write)       (THIS_ LONG lStart, LONG lSamples,
			    LPVOID lpBuffer, LONG cbBuffer,
			    DWORD dwFlags,
			    LONG FAR *plSampWritten,
			    LONG FAR *plBytesWritten) PURE ;
    STDMETHOD(Delete)      (THIS_ LONG lStart, LONG lSamples) PURE;
    STDMETHOD(ReadData)    (THIS_ DWORD fcc, LPVOID lp, LONG FAR *lpcb) PURE ;
    STDMETHOD(WriteData)   (THIS_ DWORD fcc, LPVOID lp, LONG cb) PURE ;
    STDMETHOD(Reserved1)            (THIS) PURE;
    STDMETHOD(Reserved2)            (THIS) PURE;
    STDMETHOD(Reserved3)            (THIS) PURE;
    STDMETHOD(Reserved4)            (THIS) PURE;
    STDMETHOD(Reserved5)            (THIS) PURE;
};

typedef       IAVIStream FAR* PAVISTREAM;


#undef  INTERFACE
#define INTERFACE   IAVIStreaming

DECLARE_INTERFACE_(IAVIStreaming, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIStreaming methods ***
    STDMETHOD(Begin) (THIS_
		      LONG  lStart,		    // start of what we expect
						    // to play
		      LONG  lEnd,		    // expected end, or -1
		      LONG  lRate) PURE;	    // Should this be a float?
    STDMETHOD(End)   (THIS) PURE;
};

typedef       IAVIStreaming FAR* PAVISTREAMING;


#undef  INTERFACE
#define INTERFACE   IAVIEditStream

DECLARE_INTERFACE_(IAVIEditStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIEditStream methods ***
    STDMETHOD(Cut) (THIS_ LONG FAR *plStart,
			  LONG FAR *plLength,
			  PAVISTREAM FAR * ppResult) PURE;
    STDMETHOD(Copy) (THIS_ LONG FAR *plStart,
			   LONG FAR *plLength,
			   PAVISTREAM FAR * ppResult) PURE;
    STDMETHOD(Paste) (THIS_ LONG FAR *plPos,
			    LONG FAR *plLength,
			    PAVISTREAM pstream,
			    LONG lStart,
			    LONG lEnd) PURE;
    STDMETHOD(Clone) (THIS_ PAVISTREAM FAR *ppResult) PURE;
    STDMETHOD(SetInfo) (THIS_ AVISTREAMINFO FAR * lpInfo,
			    LONG cbInfo) PURE;
};

typedef       IAVIEditStream FAR* PAVIEDITSTREAM;


/****** AVI File Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IAVIFile
#define PAVIFILE IAVIFile FAR*

DECLARE_INTERFACE_(IAVIFile, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAVIFile methods ***
#ifdef WIN32
    STDMETHOD(Open)		    (THIS_
                                     const TCHAR FAR * szFile,
                                     UINT mode) PURE;
#else
    STDMETHOD(Open)		    (THIS_
                                     const char FAR * szFile,
                                     UINT mode) PURE;
#endif
    STDMETHOD(Info)                 (THIS_
                                     AVIFILEINFO FAR * pfi,
                                     LONG lSize) PURE;
    STDMETHOD(GetStream)            (THIS_
                                     PAVISTREAM FAR * ppStream,
				     DWORD fccType,
                                     LONG lParam) PURE;
    STDMETHOD(CreateStream)         (THIS_
                                     PAVISTREAM FAR * ppStream,
                                     AVISTREAMINFO FAR * psi) PURE;
#ifdef WIN32
    STDMETHOD(Save)                 (THIS_
                                     const TCHAR FAR * szFile,
                                     AVICOMPRESSOPTIONS FAR *lpOptions,
                                     AVISAVECALLBACK lpfnCallback) PURE;
#else
    STDMETHOD(Save)                 (THIS_
                                     const char FAR * szFile,
                                     AVICOMPRESSOPTIONS FAR *lpOptions,
                                     AVISAVECALLBACK lpfnCallback) PURE;
#endif
    STDMETHOD(WriteData)            (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG cbData) PURE;
    STDMETHOD(ReadData)             (THIS_
                                     DWORD ckid,
                                     LPVOID lpData,
                                     LONG FAR *lpcbData) PURE;
    STDMETHOD(EndRecord)            (THIS) PURE;
    STDMETHOD(Reserved1)            (THIS) PURE;
    STDMETHOD(Reserved2)            (THIS) PURE;
    STDMETHOD(Reserved3)            (THIS) PURE;
    STDMETHOD(Reserved4)            (THIS) PURE;
    STDMETHOD(Reserved5)            (THIS) PURE;
};

#undef PAVIFILE
typedef       IAVIFile FAR* PAVIFILE;

/****** GetFrame Interface *******************************************/

#undef  INTERFACE
#define INTERFACE   IGetFrame
#define PGETFRAME   IGetFrame FAR*

DECLARE_INTERFACE_(IGetFrame, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IGetFrame methods ***

    STDMETHOD_(LPVOID,GetFrame) (THIS_ LONG lPos) PURE;
//  STDMETHOD_(LPVOID,GetFrameData) (THIS_ LONG lPos) PURE;

    STDMETHOD(Begin) (THIS_ LONG lStart, LONG lEnd, LONG lRate) PURE;
    STDMETHOD(End) (THIS) PURE;

    STDMETHOD(SetFormat) (THIS_ LPBITMAPINFOHEADER lpbi, LPVOID lpBits, int x, int y, int dx, int dy) PURE;

//  STDMETHOD(DrawFrameStart) (THIS) PURE;
//  STDMETHOD(DrawFrame) (THIS_ LONG lPos, HDC hdc, int x, int y, int dx, int dy) PURE;
//  STDMETHOD(DrawFrameEnd) (THIS) PURE;
};

#undef PGETFRAME
typedef IGetFrame FAR* PGETFRAME;

/****** GUIDs *******************************************/

#define DEFINE_AVIGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_AVIGUID(IID_IAVIFile,            0x00020020, 0, 0);
DEFINE_AVIGUID(IID_IAVIStream,          0x00020021, 0, 0);
DEFINE_AVIGUID(IID_IAVIStreaming,       0x00020022, 0, 0);
DEFINE_AVIGUID(IID_IGetFrame,           0x00020023, 0, 0);
DEFINE_AVIGUID(IID_IAVIEditStream,      0x00020024, 0, 0);
#ifndef UNICODE
DEFINE_AVIGUID(CLSID_AVISimpleUnMarshal,        0x00020009, 0, 0);
#endif

#define	AVIFILEHANDLER_CANREAD		0x0001
#define	AVIFILEHANDLER_CANWRITE		0x0002
#define	AVIFILEHANDLER_CANACCEPTNONRGB	0x0004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\bios.h ===
/***
*bios.h - declarations for bios interface functions and supporting definitions
*
*   Copyright (c) 1987-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file declares the constants, structures, and functions
*   used for accessing and using various BIOS interfaces.
*
****/

#ifndef _INC_BIOS

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _MT

/* manifest constants for BIOS serial communications (RS-232) support */

/* serial port services */

#define _COM_INIT   0   /* init serial port */
#define _COM_SEND   1   /* send character */
#define _COM_RECEIVE    2   /* receive character */
#define _COM_STATUS 3   /* get serial port status */

/* serial port initializers.  One and only one constant from each of the
 * following four groups - character size, stop bit, parity, and baud rate -
 * must be specified in the initialization byte.
 */

/* character size initializers */

#define _COM_CHR7   2   /* 7 bits characters */
#define _COM_CHR8   3   /* 8 bits characters */

/* stop bit values - on or off */

#define _COM_STOP1  0   /* 1 stop bit */
#define _COM_STOP2  4   /* 2 stop bits */

/*  parity initializers */

#define _COM_NOPARITY   0   /* no parity */
#define _COM_ODDPARITY  8   /* odd parity */
#define _COM_EVENPARITY 24  /* even parity */

/*  baud rate initializers */

#define _COM_110    0   /* 110 baud */
#define _COM_150    32  /* 150 baud */
#define _COM_300    64  /* 300 baud */
#define _COM_600    96  /* 600 baud */
#define _COM_1200   128 /* 1200 baud */
#define _COM_2400   160 /* 2400 baud */
#define _COM_4800   192 /* 4800 baud */
#define _COM_9600   224 /* 9600 baud */


/* manifest constants for BIOS disk support */

/* disk services */

#define _DISK_RESET 0   /* reset disk controller */
#define _DISK_STATUS    1   /* get disk status */
#define _DISK_READ  2   /* read disk sectors */
#define _DISK_WRITE 3   /* write disk sectors */
#define _DISK_VERIFY    4   /* verify disk sectors */
#define _DISK_FORMAT    5   /* format disk track */

/* struct used to send/receive information to/from the BIOS disk services */

#ifndef _DISKINFO_T_DEFINED
#pragma pack(2)

struct _diskinfo_t {
    unsigned drive;
    unsigned head;
    unsigned track;
    unsigned sector;
    unsigned nsectors;
    void __far *buffer;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define diskinfo_t _diskinfo_t
#endif 

#pragma pack()
#define _DISKINFO_T_DEFINED
#endif 


/* manifest constants for BIOS keyboard support */

/* keyboard services */

#define _KEYBRD_READ        0   /* read next character from keyboard */
#define _KEYBRD_READY       1   /* check for keystroke */
#define _KEYBRD_SHIFTSTATUS 2   /* get current shift key status */

/* services for enhanced keyboards */

#define _NKEYBRD_READ       0x10    /* read next character from keyboard */
#define _NKEYBRD_READY      0x11    /* check for keystroke */
#define _NKEYBRD_SHIFTSTATUS    0x12    /* get current shift key status */


/* manifest constants for BIOS printer support */

/* printer services */

#define _PRINTER_WRITE  0   /* write character to printer */
#define _PRINTER_INIT   1   /* intialize printer */
#define _PRINTER_STATUS 2   /* get printer status */


/* manifest constants for BIOS time of day support */

/* time of day services */

#define _TIME_GETCLOCK  0   /* get current clock count */
#define _TIME_SETCLOCK  1   /* set current clock count */


#ifndef _REGS_DEFINED

/* word registers */

struct _WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct _BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union _REGS {
    struct _WORDREGS x;
    struct _BYTEREGS h;
    };

/* segment registers */

struct _SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#endif 

#define _REGS_DEFINED
#endif 


/* function prototypes */

#ifndef _WINDOWS
unsigned __cdecl _bios_disk(unsigned, struct _diskinfo_t *);
#endif 
unsigned __cdecl _bios_equiplist(void);
#ifndef _WINDOWS
unsigned __cdecl _bios_keybrd(unsigned);
#endif 
unsigned __cdecl _bios_memsize(void);
#ifndef _WINDOWS
unsigned __cdecl _bios_printer(unsigned, unsigned, unsigned);
unsigned __cdecl _bios_serialcom(unsigned, unsigned, unsigned);
#endif 
unsigned __cdecl _bios_timeofday(unsigned, long *);
int __cdecl _int86(int, union _REGS *, union _REGS *);
int __cdecl _int86x(int, union _REGS *, union _REGS *, struct _SREGS *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl int86(int, union REGS *, union REGS *);
int __cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#endif 

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_BIOS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\cderr.h ===
/*****************************************************************************\
*                                                                             *
* cderr.h -     Common dialog error return codes                              *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CDERR
#define _INC_CDERR

#define CDERR_DIALOGFAILURE   0xFFFF

#define CDERR_GENERALCODES     0x0000
#define CDERR_STRUCTSIZE       0x0001
#define CDERR_INITIALIZATION   0x0002
#define CDERR_NOTEMPLATE       0x0003
#define CDERR_NOHINSTANCE      0x0004
#define CDERR_LOADSTRFAILURE   0x0005
#define CDERR_FINDRESFAILURE   0x0006
#define CDERR_LOADRESFAILURE   0x0007
#define CDERR_LOCKRESFAILURE   0x0008
#define CDERR_MEMALLOCFAILURE  0x0009
#define CDERR_MEMLOCKFAILURE   0x000A
#define CDERR_NOHOOK           0x000B
#define CDERR_REGISTERMSGFAIL  0x000C

#define PDERR_PRINTERCODES     0x1000
#define PDERR_SETUPFAILURE     0x1001
#define PDERR_PARSEFAILURE     0x1002
#define PDERR_RETDEFFAILURE    0x1003
#define PDERR_LOADDRVFAILURE   0x1004
#define PDERR_GETDEVMODEFAIL   0x1005
#define PDERR_INITFAILURE      0x1006
#define PDERR_NODEVICES        0x1007
#define PDERR_NODEFAULTPRN     0x1008
#define PDERR_DNDMMISMATCH     0x1009
#define PDERR_CREATEICFAILURE  0x100A
#define PDERR_PRINTERNOTFOUND  0x100B
#define PDERR_DEFAULTDIFFERENT 0x100C

#define CFERR_CHOOSEFONTCODES  0x2000
#define CFERR_NOFONTS          0x2001
#define CFERR_MAXLESSTHANMIN   0x2002

#define FNERR_FILENAMECODES    0x3000
#define FNERR_SUBCLASSFAILURE  0x3001
#define FNERR_INVALIDFILENAME  0x3002
#define FNERR_BUFFERTOOSMALL   0x3003

#define FRERR_FINDREPLACECODES 0x4000
#define FRERR_BUFFERLENGTHZERO 0x4001

#define CCERR_CHOOSECOLORCODES 0x5000

#endif  /* !_INC_CDERR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\cobjps.h ===
// cobjps.h - definitions for writing standard proxies and stubs

#if !defined( _COBJPS_H_ )
#define _COBJPS_H_


/****** IRpcChannel Interface ***********************************************/

interface IRpcChannel : IUnknown 
{
    STDMETHOD(GetStream)(REFIID iid, int iMethod, BOOL fSend,
                     BOOL fNoWait, DWORD size, IStream FAR* FAR* ppIStream) = 0;
    STDMETHOD(Call)(IStream FAR* pIStream) = 0;
    STDMETHOD(GetDestCtx)(DWORD FAR* lpdwDestCtx, LPVOID FAR* lplpvDestCtx) = 0;
    STDMETHOD(IsConnected)(void) = 0;
};


/****** IRpcProxy Interface *************************************************/

// IRpcProxy is an interface implemented by proxy objects.  A proxy object has
// exactly the same interfaces as the real object in addition to IRpcProxy.
//

interface IRpcProxy : IUnknown 
{
    STDMETHOD(Connect)(IRpcChannel FAR* pRpcChannel) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
};


/****** IRpcStub Interface **************************************************/

// IRpcStub is an interface implemented by stub objects.  
//

interface IRpcStub : IUnknown
{
    STDMETHOD(Connect)(IUnknown FAR* pUnk) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
    STDMETHOD(Invoke)(REFIID iid, int iMethod, IStream FAR* pIStream,
            DWORD dwDestCtx, LPVOID lpvDestCtx) = 0;
    STDMETHOD_(BOOL, IsIIDSupported)(REFIID iid) = 0;
    STDMETHOD_(ULONG, CountRefs)(void) = 0;
};


/****** IPSFactory Interface ************************************************/

// IPSFactory - creates proxies and stubs
//

interface IPSFactory : IUnknown
{
    STDMETHOD(CreateProxy)(IUnknown FAR* pUnkOuter, REFIID riid, 
        IRpcProxy FAR* FAR* ppProxy, void FAR* FAR* ppv) = 0;
    STDMETHOD(CreateStub)(REFIID riid, IUnknown FAR* pUnkServer,
        IRpcStub FAR* FAR* ppStub) = 0;
};

#endif // _COBJPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\cmacros.inc ===
IFNDEF MASM6
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1994
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
ELSE  ;MASM6
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1994
$
.xcref
??CM_Paste macro arg1:req, arg2:req
exitm <arg1&arg2>
endm
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
%out e r r o r ----- msg
.err e r r o r ----- msg
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.30 - Copyright (c) Microsoft Corp. 1984-1991>
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
outif memS,0,<Small Model>
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = ?PLM
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ??CM_Paste(?,x))
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ??CM_Paste(?,x))
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ??CM_Paste(?,x)
n=n or ??CM_Paste(?,x)
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP,parmH
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?pcc
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmH macro n
?pp <n>,<word>,4,2
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ??CM_Paste(?t_,x)
??CM_Paste(?t_,x)=s
ife ?pcc
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?pcc
n equ (t ptr [bp][+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc macro po
uconcat <n>,,<equ>,,<(t ptr [bp][+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp][-o-2])
.xcref ?t_&n
?t_&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp][-o])
.xcref ?t_&n
?t_&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ??CM_Paste(?,x) eq ??CM_Paste(?,r)
n equ (byte ptr [bp][-o])
??CM_Paste(?t_,n)=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <%??CM_Paste(seg_,x)>,<word ptr>,2,2,1
?aloc <%??CM_Paste(off_,x)>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ??CM_Paste(?t_,x)
??CM_Paste(?t_,x)=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp][-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ word ptr n[0]
seg_&n equ word ptr n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
ife ?ex2
extrn ??CM_Paste(_,x):&d
x equ ??CM_Paste(_,x)
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ??CM_Paste(?CC,x)
.cref
??CM_Paste(?CC,x)=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
ife ?lb2
if ?lblpu
public ??CM_Paste(_,x)
endif
??CM_Paste(_,x) label &d
x equ ??CM_Paste(_,x)
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t_&n
.cref
n macro
	push	s
	push	o
endm
?t_&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i macro
?ap <n>
endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t_&n
ife ?t_&n-1
	push	word ptr (n)
exitm
endif
ife ?t_&n-2
	push	n
exitm
endif
ife ?t_&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t_&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t_&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t_&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 macro arg
purge ?PLMParm0
endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
endm
.xcref ?utpe
?utpe macro
??error <unterminated procedure definition: "&n">
endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,(-2)[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
endm
.cref
endm
assumes macro s,ln
ifdef MS_STARTUP
ifidn <code>,<ln>
assume s&:_TEXT
exitm
elseifidn <CODE>,<ln>
assume s&:_TEXT
exitm
elseifidn <data>,<ln>
assume s&:dgroup
exitm
elseifidn <DATA>,<ln>
assume s&:dgroup
exitm
endif
endif
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
ifnb <grp>
grp group n
?cs3 <ln>,<grp>
ln&OFFSET equ <offset grp:>
ln&BASE equ <grp>
else
?cs3 <ln>,<n>
ln&OFFSET equ <offset>
ln&BASE equ <n>
endif
endm
addseg macro grp,seg
.xcref
.xcref grp&_add
.cref
grp&_add macro s
grp&_in <seg>,s
endm
.xcref
.xcref grp&_in
.cref
grp&_in macro sl,s
ifb <s>
grp group sl
else
grp&_add macro ns
grp&_in <sl,s>,ns
endm
endif
endm
endm
defgrp macro grp,ln
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin macro
?cs2 <ln>,<n>
n segment
.xcref
.xcref ?mf
.cref
?mf macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
endm
endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd macro arg
n ends
purge ?mf
purge sEnd
endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes macro s
assume s:&n
endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
ifnb <x>
.errnz (x),<x>
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
callcrt MACRO funcname
ifdef _QC2
call funcname
else
if sizeC
push cs
call near ptr (funcname)
else
call funcname
endif
endif
ENDM
.cref
ENDIF ;MASM6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\coguid.h ===
/* this file is the master definition of all GUIDs for the component object
   model and is included in compobj.h.  Some GUIDs for moinkers and storage 
   appear here as well.  All of these GUIDs are OLE GUIDs only in the sense 
   that part of the GUID range owned by OLE was used to define them.  
   
   NOTE: The second byte of all of these GUIDs is 0.
*/
   

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);

/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);

/* moniker related interfaces */
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);

/* concurrency releated interfaces */
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);

/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,        0x00000017L, 0, 0);

/* interface on server for getting info for std marshaler */
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);

/* NOTE: LSB 0x19 through 0xff are reserved for future use */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\commctrl.h ===
/*****************************************************************************\
*                                                                             *
* commctrl.h - - Interface for the Windows Common Controls		      *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1991-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

/*REVIEW: this stuff needs Windows style in many places; find all REVIEWs. */

#ifndef _INC_COMMCTRL
#define _INC_COMMCTRL

#ifdef WIN32
#define _huge
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Users of this header may define any number of these constants to avoid
 * the definitions of each functional group.
 *    NOTOOLBAR    Customizable bitmap-button toolbar control.
 *    NOUPDOWN     Up and Down arrow increment/decrement control.
 *    NOSTATUSBAR  Status bar and header bar controls.
 *    NOMENUHELP   APIs to help manage menus, especially with a status bar.
 *    NOTRACKBAR   Customizable column-width tracking control.
 *    NODRAGLIST   APIs to make a listbox source and sink drag&drop actions.
 *    NOPROGRESS   Progress gas gauge.
 *    NOHOTKEY     HotKey control
 */

/*/////////////////////////////////////////////////////////////////////////*/

/* InitCommonControls:
 * Any application requiring the use of any common control should call this
 * API upon application startup.  There is no required shutdown.
 */
void WINAPI InitCommonControls();

// Define Ownerdraw type for Header controls BUGBUG: should be in windows.h?
#define ODT_HEADER      100
#define ODT_TAB         101
#define ODT_LISTVIEW    102

//====== Ranges for control message IDs
// (making each control's messages unique makes validation and
// debugging easier).
//
#define LVM_FIRST       0x1000      // ListView messages
#define TV_FIRST        0x1100      // TreeView messages
#define HDM_FIRST       0x1200      // Header messages



//REVIEW: We need to add an "int cbHdr" field to NMHDR!

LRESULT WINAPI SendNotify(HWND hwndTo, HWND hwndFrom, int code, NMHDR FAR* pnmhdr);

/* LRESULT Cls_OnNotify(HWND hwnd, int idFrom, NMHDR FAR* pnmhdr); */
#define HANDLE_WM_NOTIFY(hwnd, wParam, lParam, fn) \
    (fn)((hwnd), (int)(wParam), (NMHDR FAR*)(lParam))
#define FORWARD_WM_NOTIFY(hwnd, idFrom, pnmhdr, fn) \
    (void)(fn)((hwnd), WM_NOTIFY, (WPARAM)(int)(id), (LPARAM)(NMHDR FAR*)(pnmhdr))

// Generic WM_NOTIFY notification codes


#define NM_OUTOFMEMORY          (NM_FIRST-1)
#define NM_CLICK                (NM_FIRST-2)
#define NM_DBLCLK               (NM_FIRST-3)
#define NM_RETURN               (NM_FIRST-4)
#define NM_RCLICK               (NM_FIRST-5)
#define NM_RDBLCLK              (NM_FIRST-6)
#define NM_SETFOCUS             (NM_FIRST-7)
#define NM_KILLFOCUS            (NM_FIRST-8)
#define NM_STARTWAIT            (NM_FIRST-9)
#define NM_ENDWAIT              (NM_FIRST-10)
#define NM_BTNCLK               (NM_FIRST-10)

// WM_NOTIFY codes (NMHDR.code values)
// these are not required to be in seperate ranges but that makes
// validation and debugging easier

#define NM_FIRST        (0U-  0U)	// generic to all controls
#define NM_LAST         (0U- 99U)

#define LVN_FIRST       (0U-100U)	// listview
#define LVN_LAST        (0U-199U)

#define HDN_FIRST       (0U-300U)	// header
#define HDN_LAST        (0U-399U)

#define TVN_FIRST       (0U-400U)	// treeview
#define TVN_LAST        (0U-499U)

#define TTN_FIRST	(0U-520U)	// tooltips
#define TTN_LAST	(0U-549U)

#define TCN_FIRST       (0U-550U)	// tab control
#define TCN_LAST        (0U-600U)

#define CDN_FIRST	(0U-601U)	// common dialog (new)
#define CDN_LAST	(0U-699U)

#define TBN_FIRST       (0U-700U)	// toolbar 
#define TBN_LAST        (0U-720U)


//====== IMAGE APIS ==================================================

#define CLR_NONE    0xFFFFFFFFL
#define CLR_DEFAULT 0xFF000000L
#define CLR_HILIGHT 0xFF000001L

struct _IMAGELIST;
typedef struct _IMAGELIST NEAR* HIMAGELIST;

    // fMask is TRUE to create a masked (two-bitmap) image list.
    // cInitial is initial size of bitmap, cGrow is size to increase by.
HIMAGELIST WINAPI ImageList_Create(int cx, int cy, BOOL fMask, int cInitial, int cGrow);
BOOL WINAPI ImageList_Destroy(HIMAGELIST himl);

    // loads one resource, figures out cy and cInitial from bmp,
    // and makes mask from a specified color (unless CLR_NONE given)
HIMAGELIST WINAPI ImageList_LoadImage(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
#define ImageList_LoadBitmap(hi, lpbmp, cx, cGrow, crMask) \
        ImageList_LoadImage(hi, lpbmp, cx, cGrow, crMask, IMAGE_BITMAP, 0) 

    // Number of images in list.
int WINAPI ImageList_GetImageCount(HIMAGELIST himl);

    // Add, Remove, replace images.  Add returns index of Added item, or -1 if error.
int  WINAPI ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);
int  WINAPI ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask);
BOOL WINAPI ImageList_Remove(HIMAGELIST himl, int i);
BOOL WINAPI ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask);

    // Add or replace given an icon handle.  hicon is not saved; can be destroyed
    // after call.  Add returns index of added item, else -1.
int  WINAPI ImageList_AddIcon(HIMAGELIST himl, HICON hicon);
int  WINAPI ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
HICON WINAPI ImageList_ExtractIcon(HINSTANCE hAppInst, HIMAGELIST himl, int i);
int   WINAPI ImageList_AddFromImageList(HIMAGELIST himlDest, HIMAGELIST himlSrc, int iSrc);

#define ILD_NORMAL      0x0000          // use current bkcolor
#define ILD_TRANSPARENT 0x0001          // force transparent icon style (override bk color)
#define ILD_MASK        0x0010          // draw the mask
#define ILD_BLEND       0x000E          // blend
#define ILD_BLEND25     0x0002          // blend 25%
#define ILD_BLEND50     0x0004          // blend 50%
#define ILD_BLEND75     0x0008          // blend 75%
#define ILD_OVERLAYMASK 0x0F00		// use these as indexes into special items
#define INDEXTOOVERLAYMASK(i) ((i) << 8)    //

#define ILD_SELECTED    ILD_BLEND50     // draw as selected
#define ILD_FOCUS       ILD_BLEND25     // draw as focused (selection)

    // Draw item i into hdcDst at x, y.  Flags define the drawing style.
BOOL WINAPI ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle);

    // Draw item i into hdcDst at x, y.  Flags define the drawing style.
BOOL WINAPI ImageList_Draw2(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, COLORREF rgb, UINT fStyle);

    // Get bounding rectangle of image in image bitmaps.
BOOL WINAPI ImageList_GetImageRect(HIMAGELIST himl, int i, RECT FAR* prcImage);

    // Set & get background color for speedy drawing.  Set to CLR_NONE for true
    // cursor-style AND/XOR transparency.
COLORREF WINAPI ImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk);
COLORREF WINAPI ImageList_GetBkColor(HIMAGELIST himl);

    // Set the image iImage as one of the special images for us in combine
    // drawing.  to draw with these specify the index of this
BOOL WINAPI ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay);

#ifdef WIN32
#ifdef _OBJBASE_H_
// Read and write an imagelist from/to an IStream.
HIMAGELIST WINAPI ImageList_Read(LPSTREAM pstm);
BOOL       WINAPI ImageList_Write(HIMAGELIST himl, LPSTREAM pstm);
#endif
#endif

typedef struct _IMAGEINFO
{
    HBITMAP hbmImage;
    HBITMAP hbmMask;
    int cPlanes;
    int cBitsPerPixel;
    RECT rcImage;
} IMAGEINFO;

    // Get information about an image for direct manipulation.  rcImage is
    // part of hbmImage and hbmMask that make up the image.  hbmMask is
    // NULL if not a masked imagelist.
BOOL WINAPI ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO FAR* pImageInfo);

    // Start tracking an image i, starting at x, y, offset by dx/dyHotspot.
BOOL WINAPI ImageList_StartDrag(HIMAGELIST himl, HWND hwndLock, int i, int x, int y, int dxHotspot, int dyHotspot);
    // End a dragging operation.
void WINAPI ImageList_EndDrag();
    // Called on mouse move to move dragging image.
BOOL WINAPI ImageList_DragMove(int x, int y);


    // Create new IMAGELIST that is the merge of two existing images.
HIMAGELIST WINAPI ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy);



//================ HEADER APIS =============================================
//
// Class name: SysHeader (WC_HEADER)
//
// The SysHeader control provides for column and row headers much like those
// found in MSMail and Excel.  Header items appear as text on a gray
// background. Items can behave as pushbuttons, in which case they have a
// raised face.
//
// SysHeaders support changing width or height of items using the mouse.
// These controls do not support a keyboard interface, so they do not accept
// the input focus.
//
// There are notifications that allow applications to determine when an item
// has been clicked or double clicked, width change has occured, drag tracking
// is occuring, etc.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef WIN32
#define WC_HEADER       "SysHeader32"
#else
#define WC_HEADER       "SysHeader"
#endif

// Header control styles
#define HDS_HORZ            0x00000000  // Horizontal header
#define HDS_BUTTONS         0x00000002  // Items act as buttons
#define HDS_HIDDEN 	    0x00000008 	// no header in details mode


// The HD_ITEM structure describes a header item.
// The first field contains a combination of HDI_* flags
// indicating which fields contain valid data.
//
typedef struct _HD_ITEM
{
    UINT    mask;
    int     cxy;            // width (HDS_HORZ) or height (HDS_VERT)
    LPSTR   pszText;
    HBITMAP hbm;            // Bitmap to use (implies HDF_BITMAP)
    int     cchTextMax;     // Valid only for GetItem: contains size of buffer
    int     fmt;            // HDF_* value
    LPARAM  lParam;
} HD_ITEM;

// HD_ITEM mask flags
#define HDI_WIDTH       0x0001
#define HDI_HEIGHT      HDI_WIDTH
#define HDI_TEXT        0x0002
#define HDI_FORMAT      0x0004
#define HDI_LPARAM      0x0008
#define HDI_BITMAP      0x0010

// HD_ITEM fmt field values
// First justification values
#define HDF_LEFT        0
#define HDF_RIGHT       1
#define HDF_CENTER      2
#define HDF_JUSTIFYMASK 0x0003

// Now other formating options
#define HDF_OWNERDRAW   0x8000
#define HDF_STRING      0x4000
#define HDF_BITMAP      0x2000

// Returns number of items in header.
//
// int Header_GetItemCount(HWND hwndHD);
//
#define HDM_GETITEMCOUNT    (HDM_FIRST + 0)
#define Header_GetItemCount(hwndHD) \
    (int)SendMessage((hwndHD), HDM_GETITEMCOUNT, 0, 0L)

// Insert header item at specified index.  Item is inserted at end if
// i is greater than or equal to the number of items in the header.
// Returns the index of the inserted item.
//
// int Header_InsertItem(HWND hwndHD, int i, const HD_ITEM FAR* pitem);
//
#define HDM_INSERTITEM      (HDM_FIRST + 1)
#define Header_InsertItem(hwndHD, i, phdi) \
    (int)SendMessage((hwndHD), HDM_INSERTITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM FAR*)(phdi))

// Delete a header item at the specified index.
//
// BOOL Header_DeleteItem(HWND hwndHD, int i);
//
#define HDM_DELETEITEM      (HDM_FIRST + 2)
#define Header_DeleteItem(hwndHD, i) \
    (BOOL)SendMessage((hwndHD), HDM_DELETEITEM, (WPARAM)(int)(i), 0L)

// Get header item at index i.  The mask field of the pointed-to
// HD_ITEM structure indicates which fields will be set by this
// function; other fields are not changed.
//
// The cchTextMax field of *pitem contains the maximum
// length of the returned string.
//
// BOOL Header_GetItem(HWND hwndHD, int i, HD_ITEM FAR* phdi);
//
#define HDM_GETITEM         (HDM_FIRST + 3)
#define Header_GetItem(hwndHD, i, phdi) \
    (BOOL)SendMessage((hwndHD), HDM_GETITEM, (WPARAM)(int)(i), (LPARAM)(HD_ITEM FAR*)(phdi))

// Set header item at index i.  The mask field of the pointed-to
// HD_ITEM structure indicates which header item attributes will
// be changed by this call; other fields of *pitem that do not
// correspond to pitem->mask are ignored.
//
// The cchTextMax of *pitem is ignored.
//
// BOOL Header_SetItem(HWND hwndHD, int i, const HD_ITEM FAR* phdi);
//
#define HDM_SETITEM         (HDM_FIRST + 4)
#define Header_SetItem(hwndHD, i, phdi) \
    (BOOL)SendMessage((hwndHD), HDM_SETITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM FAR*)(phdi))

// Calculate size and position of header within a rectangle.
// Results are returned in a WINDOWPOS structure you supply,
// and the layout rectangle is adjusted to exclude the leftover area.
//
typedef struct _HD_LAYOUT
{
    RECT FAR* prc;
    WINDOWPOS FAR* pwpos;
} HD_LAYOUT;

// BOOL Header_Layout(HWND hwndHD, HD_LAYOUT FAR* playout);
//
#define HDM_LAYOUT          (HDM_FIRST + 5)
#define Header_Layout(hwndHD, playout) \
    (BOOL)SendMessage((hwndHD), HDM_LAYOUT, 0, (LPARAM)(HD_LAYOUT FAR*)(playout))


#define HHT_NOWHERE         0x0001
#define HHT_ONHEADER        0x0002
#define HHT_ONDIVIDER       0x0004
#define HHT_ONDIVOPEN       0x0008
#define HHT_ABOVE           0x0100
#define HHT_BELOW           0x0200
#define HHT_TORIGHT         0x0400
#define HHT_TOLEFT          0x0800

typedef struct _HD_HITTESTINFO
{
    POINT pt;	    // in:	client coords
    UINT flags;	    // out:	HHT_ flags
    int iItem;	    // out:	item
} HD_HITTESTINFO;
#define HDM_HITTEST          (HDM_FIRST + 6)

// Header Notifications
//
// All header notifications are via the WM_NOTIFY message.
// lParam of WM_NOTIFY points to a HD_NOTIFY structure for
// all of the following notifications.

// *pitem contains item being changed.  pitem->mask indicates
// which fields are valid (others have indeterminate state)
//
#define HDN_ITEMCHANGING    (HDN_FIRST-0)
#define HDN_ITEMCHANGED     (HDN_FIRST-1)

// Item has been clicked or doubleclicked (HDS_BUTTONS only)
// iButton contains button id: 0=left, 1=right, 2=middle.
//
#define HDN_ITEMCLICK       (HDN_FIRST-2)
#define HDN_ITEMDBLCLICK    (HDN_FIRST-3)

// Divider area has been clicked or doubleclicked (HDS_DIVIDERTRACK only)
// iButton contains button id: 0=left, 1=right, 2=middle.
//
#define HDN_DIVIDERDBLCLICK (HDN_FIRST-5)

// Begin/end divider tracking (HDS_DIVIDERTRACK only)
// Return TRUE from HDN_BEGINTRACK notification to prevent tracking.
//
#define HDN_BEGINTRACK      (HDN_FIRST-6)
#define HDN_ENDTRACK        (HDN_FIRST-7)

// HDN_DRAG: cxy field contains new height/width, which may be < 0.
// Changing this value will affect the tracked height/width (allowing
// for gridding, pinning, etc).
//
// Return TRUE to cancel tracking.
//
#define HDN_TRACK           (HDN_FIRST-8)

typedef struct _HD_NOTIFY
{
    NMHDR   hdr;
    int     iItem;
    int     iButton;        // *CLICK notifications: 0=left, 1=right, 2=middle
    HD_ITEM FAR* pitem;     // May be NULL
} HD_NOTIFY;


#ifndef NOTOOLBAR

#ifdef WIN32
#define TOOLBARCLASSNAME "ToolbarWindow32"
#else
#define TOOLBARCLASSNAME "ToolbarWindow"
#endif

typedef struct _TBBUTTON {
    int iBitmap;	/* index into bitmap of this button's picture */
    int idCommand;	/* WM_COMMAND menu ID that this button sends */
    BYTE fsState;	/* button's state */
    BYTE fsStyle;	/* button's style */
    DWORD dwData;	/* app defined data */
    int iString;	/* index into string list */
} TBBUTTON, NEAR* PTBBUTTON, FAR* LPTBBUTTON;
typedef const TBBUTTON FAR* LPCTBBUTTON;

typedef struct _COLORMAP {
    COLORREF from;
    COLORREF to;
} COLORMAP, FAR* LPCOLORMAP;

HWND WINAPI CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps,
			HINSTANCE hBMInst, UINT wBMID, LPCTBBUTTON lpButtons,
			int iNumButtons, int dxButton, int dyButton,
			int dxBitmap, int dyBitmap, UINT uStructSize);

HBITMAP WINAPI CreateMappedBitmap(HINSTANCE hInstance, int idBitmap,
                                  UINT wFlags, LPCOLORMAP lpColorMap,
				  int iNumMaps);

#define CMB_MASKED	0x02	/* create image/mask pair in bitmap */

/*REVIEW: TBSTATE_* should be TBF_* (for Flags) */
#define TBSTATE_CHECKED		0x01	/* radio button is checked */
#define TBSTATE_PRESSED		0x02	/* button is being depressed (any style) */
#define TBSTATE_ENABLED		0x04	/* button is enabled */
#define TBSTATE_HIDDEN		0x08	/* button is hidden */
#define TBSTATE_INDETERMINATE	0x10	/* button is indeterminate */
#define TBSTATE_WRAP		0x20	/* there is a line break after this button */
                                        /*  (needs to be endabled, too) */
#define TBSTYLE_BUTTON		0x00	/* this entry is button */
#define TBSTYLE_SEP		0x01	/* this entry is a separator */
#define TBSTYLE_CHECK		0x02	/* this is a check button (it stays down) */
#define TBSTYLE_GROUP		0x04	/* this is a check button (it stays down) */
#define TBSTYLE_CHECKGROUP	(TBSTYLE_GROUP | TBSTYLE_CHECK)	/* this group is a member of a group radio group */

/* TOOLBAR window styles (not button, not trackbar) */
#define TBSTYLE_TOOLTIPS	0x0100    /* make/use a tooltips control */
#define TBSTYLE_WRAPABLE	0x0200    /* wrappable */

#define TB_ENABLEBUTTON		(WM_USER + 1)
#define TB_CHECKBUTTON		(WM_USER + 2)
#define TB_PRESSBUTTON		(WM_USER + 3)
#define TB_HIDEBUTTON		(WM_USER + 4)
#define TB_INDETERMINATE	(WM_USER + 5)
#define TB_ISBUTTONENABLED	(WM_USER + 9)
#define TB_ISBUTTONCHECKED	(WM_USER + 10)	
#define TB_ISBUTTONPRESSED	(WM_USER + 11)	
#define TB_ISBUTTONHIDDEN	(WM_USER + 12)	
#define TB_ISBUTTONINDETERMINATE    (WM_USER + 13)	
#define TB_SETSTATE             (WM_USER + 17)
#define TB_GETSTATE             (WM_USER + 18)
#define TB_ADDBITMAP		(WM_USER + 19)

#ifdef WIN32
typedef struct {
	HINSTANCE	hInst;	// module handle or NULL, or -1
	UINT		nID;	// if hInst == NULL, HBITMAP, else ID
} TBADDBITMAP, *LPTBADDBITMAP;

#define HINST_COMMCTRL		((HINSTANCE)-1)
#define IDB_STD_SMALL_COLOR	0
#define IDB_STD_LARGE_COLOR	1
#define IDB_VIEW_SMALL_COLOR	4	
#define IDB_VIEW_LARGE_COLOR	5
#endif

#define TB_ADDBUTTONS		(WM_USER + 20)
#define TB_INSERTBUTTON		(WM_USER + 21)
#define TB_DELETEBUTTON		(WM_USER + 22)
#define TB_GETBUTTON		(WM_USER + 23)
#define TB_BUTTONCOUNT		(WM_USER + 24)
#define TB_COMMANDTOINDEX	(WM_USER + 25)

#ifdef WIN32

typedef struct {
    HKEY hkr;
    LPCSTR pszSubKey;
    LPCSTR pszValueName;
} TBSAVEPARAMS;

// wParam: BOOL (TRUE -> save state, FALSE -> restore
// lParam: pointer to TBSAVERESTOREPARAMS

#endif

#define TB_SAVERESTORE		(WM_USER + 26)
#define TB_CUSTOMIZE            (WM_USER + 27)
#define TB_ADDSTRING		(WM_USER + 28)
#define TB_GETITEMRECT		(WM_USER + 29)
#define TB_BUTTONSTRUCTSIZE	(WM_USER + 30)
#define TB_SETBUTTONSIZE	(WM_USER + 31)
#define TB_SETBITMAPSIZE	(WM_USER + 32)
#define TB_AUTOSIZE		(WM_USER + 33)
#define TB_SETBUTTONTYPE	(WM_USER + 34)
#define TB_GETTOOLTIPS		(WM_USER + 35)
#define TB_SETTOOLTIPS		(WM_USER + 36)
#define TB_SETPARENT		(WM_USER + 37)
#define TB_SETROWS		(WM_USER + 39)
#define TB_GETROWS		(WM_USER + 40)
#define TB_SETCMDID		(WM_USER + 42)

#ifdef WIN32

#define TBBF_LARGE	0x0001

// returns TBBF_ flags
#define TB_GETBITMAPFLAGS	(WM_USER + 41)

#define TBN_GETBUTTONINFO	(TBN_FIRST-0)
#define TBN_BEGINDRAG		(TBN_FIRST-1)
#define TBN_ENDDRAG		(TBN_FIRST-2)
#define TBN_BEGINADJUST		(TBN_FIRST-3)
#define TBN_ENDADJUST		(TBN_FIRST-4)
#define TBN_RESET		(TBN_FIRST-5)
#define TBN_QUERYINSERT		(TBN_FIRST-6)
#define TBN_QUERYDELETE		(TBN_FIRST-7)
#define TBN_TOOLBARCHANGE	(TBN_FIRST-8)
#define TBN_CUSTHELP		(TBN_FIRST-9)

typedef struct {
    NMHDR   hdr;
    int     iItem;
    TBBUTTON tbButton;
    int	    cchText;
    LPSTR   pszText;
} TBNOTIFY, FAR *LPTBNOTIFY;

#endif

#endif /* NOTOOLBAR */


/*//////////////////////////////////////////////////////////////////////*/
#ifndef NOTOOLTIPS

#ifdef WIN32
#define TOOLTIPS_CLASS "tooltips_class32"
#else
#define TOOLTIPS_CLASS "tooltips_class"
#endif

typedef struct {
    UINT cbSize;
    UINT uFlags;

    HWND hwnd;
    UINT uId;
    RECT rect;

    HINSTANCE hinst;
    LPSTR lpszText;
} TOOLINFO, NEAR *PTOOLINFO, FAR *LPTOOLINFO;

#define TTS_ALWAYSTIP           0x01            // check over inactive windows as well
#define TTS_NOPREFIX            0x02

#define TTF_WIDISHWND   	0x01

#define TTM_ACTIVATE		(WM_USER + 1)   // wparam = BOOL (true or false  = activate or deactivate)
#define TTM_SETDELAYTIME	(WM_USER + 3)
#define TTM_ADDTOOL		(WM_USER + 4)
#define TTM_DELTOOL		(WM_USER + 5)
#define TTM_NEWTOOLRECT		(WM_USER + 6)
#define TTM_RELAYEVENT		(WM_USER + 7)

// lParam has TOOLINFO with hwnd and wid.  this gets filled in
#define TTM_GETTOOLINFO    	(WM_USER + 8)

// lParam has TOOLINFO
#define TTM_SETTOOLINFO    	(WM_USER + 9)

// returns true or false for found, not found.
// fills in LPHITTESTINFO->ti
#define TTM_HITTEST             (WM_USER +10)
#define TTM_GETTEXT             (WM_USER +11)
#define TTM_UPDATETIPTEXT       (WM_USER +12)
#define TTM_GETTOOLCOUNT        (WM_USER +13)
#define TTM_ENUMTOOLS           (WM_USER +14)

typedef struct _TT_HITTESTINFO {
    HWND hwnd;
    POINT pt;
    TOOLINFO ti;
} TTHITTESTINFO, FAR * LPHITTESTINFO;


// WM_NOTIFY message sent to parent window to get tooltip text
// if TTF_QUERYFORTIP is set on any tips
#define TTN_NEEDTEXT	(TTN_FIRST - 0)

// WM_NOTIFY structure sent if TTF_QUERYFORTIP is set
// the host can
// 1) fill in the szText,
// 2) point lpszText to their own text
// 3) put a resource id number in lpszText
//      and point hinst to the hinstance to load from
typedef struct {
    NMHDR hdr;
    LPSTR lpszText;
    char szText[80];
    HINSTANCE hinst;
} TOOLTIPTEXT, FAR *LPTOOLTIPTEXT;

#endif //NOTOOLTIPS


/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOSTATUSBAR

/*REVIEW: Here exists the only known documentation for status bars. */

// SBS_* styles need to not overlap with CCS_* values

// want a size gripper on a status bar.  this only applies if the
// DrawFrameControl function is available.
#define SBARS_SIZEGRIP		0x0100	

/* DrawStatusText:
 * This is used if the app wants to draw status in its client rect,
 * instead of just creating a window.  Note that this same function is
 * used internally in the status bar window's WM_PAINT message.
 * hDC is the DC to draw to.  The font that is selected into hDC will
 * be used.  The RECT lprc is the only portion of hDC that will be drawn
 * to: the outer edge of lprc will have the highlights (the area outside
 * of the highlights will not be drawn in the BUTTONFACE color: the app
 * must handle that).  The area inside the highlights will be erased
 * properly when drawing the text.
 */
void WINAPI DrawStatusText(HDC hDC, LPRECT lprc, LPCSTR szText, UINT uFlags);

HWND WINAPI CreateStatusWindow(LONG style, LPCSTR lpszText, HWND hwndParent, UINT wID);

#ifdef WIN32
#define STATUSCLASSNAME "msctls_statusbar32"
#else
#define STATUSCLASSNAME "msctls_statusbar"
#endif

#define SB_SETTEXT		(WM_USER+1)
#define SB_GETTEXT		(WM_USER+2)
#define SB_GETTEXTLENGTH	(WM_USER+3)
/* Just like WM_?ETTEXT*, with wParam specifying the pane that is referenced
 * (at most 255).
 * Note that you can use the WM_* versions to reference the 0th pane (this
 * is useful if you want to treat a "default" status bar like a static text
 * control).
 * For SETTEXT, wParam is the pane or'ed with SBT_* style bits (defined below).
 * If the text is "normal" (not OWNERDRAW), then a single pane may have left,
 * center, and right justified text by separating the parts with a single tab,
 * plus if lParam is NULL, then the pane has no text.  The pane will be
 * invalidated, but not draw until the next PAINT message.
 * For GETTEXT and GETTEXTLENGTH, the LOWORD of the return will be the length,
 * and the HIWORD will be the SBT_* style bits.
 */
#define SB_SETPARTS		(WM_USER+4)
/* wParam is the number of panes, and lParam points to an array of points
 * specifying the right hand side of each pane.  A right hand side of -1 means
 * it goes all the way to the right side of the control minus the X border
 */
#define SB_SETBORDERS		(WM_USER+5)
/* lParam points to an array of 3 integers: X border, Y border, between pane
 * border.  If any is less than 0, the default will be used for that one.
 */
#define SB_GETPARTS		(WM_USER+6)
/* lParam is a pointer to an array of integers that will get filled in with
 * the right hand side of each pane and wParam is the size (in integers)
 * of the lParam array (so we do not go off the end of it).
 * Returns the number of panes.
 */
#define SB_GETBORDERS		(WM_USER+7)
/* lParam is a pointer to an array of 3 integers that will get filled in with
 * the X border, the Y border, and the between pane border.
 */
#define SB_SETMINHEIGHT		(WM_USER+8)
/* wParam is the minimum height of the status bar "drawing" area.  This is
 * the area inside the highlights.  This is most useful if a pane is used
 * for an OWNERDRAW item, and is ignored if the SBS_NORESIZE flag is set.
 * Note that WM_SIZE (wParam=0, lParam=0L) must be sent to the control for
 * any size changes to take effect.
 */
#define SB_SIMPLE		(WM_USER+9)
/* wParam specifies whether to set (non-zero) or unset (zero) the "simple"
 * mode of the status bar.  In simple mode, only one pane is displayed, and
 * its text is set with LOWORD(wParam)==255 in the SETTEXT message.
 * OWNERDRAW is not allowed, but other styles are.
 * The pane gets invalidated, but not painted until the next PAINT message,
 * so you can set new text without flicker (I hope).
 * This can be used with the WM_INITMENU and WM_MENUSELECT messages to
 * implement help text when scrolling through a menu.
 */

#define SB_GETRECT              (WM_USER + 10)
// wParam is the nth part
// lparam is lprc
// returns true if found a rect for wParam


#define SBT_OWNERDRAW	0x1000
/* The lParam of the SB_SETTEXT message will be returned in the DRAWITEMSTRUCT
 * of the WM_DRAWITEM message.  Note that the fields CtlType, itemAction, and
 * itemState of the DRAWITEMSTRUCT are undefined for a status bar.
 * The return value for GETTEXT will be the itemData.
 */
#define SBT_NOBORDERS	0x0100
/* No borders will be drawn for the pane.
 */
#define SBT_POPOUT	0x0200
/* The text pops out instead of in
 */
#define HBT_SPRING	0x0400
/* this means that the item is "springy", meaning that it has a minimum
 * width, but will grow if there is extra room in the window.  Note that
 * multiple springs are allowed, and the extra room will be distributed
 * among them.
 */

#endif /* NOSTATUSBAR */

/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOMENUHELP

void WINAPI MenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, UINT FAR *lpwIDs);
BOOL WINAPI ShowHideMenuCtl(HWND hWnd, UINT uFlags, LPINT lpInfo);
void WINAPI GetEffectiveClientRect(HWND hWnd, LPRECT lprc, LPINT lpInfo);

/*REVIEW: is this internal? */
#define MINSYSCOMMAND	SC_SIZE

#endif /* NOMENUHELP */

											
/*/////////////////////////////////////////////////////////////////////////*/		
// slider control
											
#ifndef NOTRACKBAR
/*
    This control keeps its ranges in LONGs.  but for
    convienence and symetry with scrollbars
    WORD parameters are are used for some messages.
    if you need a range in LONGs don't use any messages
    that pack values into loword/hiword pairs

    The trackbar messages:
    message         wParam  lParam  return

    TBM_GETPOS      ------  ------  Current logical position of trackbar.
    TBM_GETRANGEMIN ------  ------  Current logical minimum position allowed.
    TBM_GETRANGEMAX ------  ------  Current logical maximum position allowed.
    TBM_SETTIC
    TBM_SETPOS
    TBM_SETRANGEMIN
    TBM_SETRANGEMAX
*/

#ifdef WIN32
#define TRACKBAR_CLASS          "msctls_trackbar32"
#else
#define TRACKBAR_CLASS          "msctls_trackbar"
#endif

/* Trackbar styles */

/* add ticks automatically on TBM_SETRANGE message */
#define TBS_AUTOTICKS           0x0001
#define TBS_VERT                0x0002  /* vertical trackbar */
#define TBS_HORZ                0x0000  /* default */
#define TBS_TOP			0x0004  /* Ticks on top */
#define TBS_BOTTOM		0x0000  /* Ticks on bottom  (default) */
#define TBS_LEFT		0x0004  /* Ticks on left */
#define TBS_RIGHT		0x0000  /* Ticks on right (default) */
#define TBS_BOTH		0x0008  /* Ticks on both side */
#define TBS_NOTICKS		0x0010
#define TBS_ENABLESELRANGE	0x0020


/* Trackbar messages */

/* returns current position (LONG) */
#define TBM_GETPOS              (WM_USER)

/* set the min of the range to LPARAM */
#define TBM_GETRANGEMIN         (WM_USER+1)

/* set the max of the range to LPARAM */
#define TBM_GETRANGEMAX         (WM_USER+2)

/* wParam is index of tick to get (ticks are in the range of min - max) */
#define TBM_GETTIC              (WM_USER+3)

/* wParam is index of tick to set */
#define TBM_SETTIC              (WM_USER+4)

/* set the position to the value of lParam (wParam is the redraw flag) */
#define TBM_SETPOS              (WM_USER+5)

/* LOWORD(lParam) = min, HIWORD(lParam) = max, wParam == fRepaint */
#define TBM_SETRANGE            (WM_USER+6)

/* lParam is range min (use this to keep LONG precision on range) */
#define TBM_SETRANGEMIN         (WM_USER+7)

/* lParam is range max (use this to keep LONG precision on range) */
#define TBM_SETRANGEMAX         (WM_USER+8)

/* remove the ticks */
#define TBM_CLEARTICS           (WM_USER+9)

/* select a range LOWORD(lParam) min, HIWORD(lParam) max */
#define TBM_SETSEL              (WM_USER+10)

/* set selection rang (LONG form) */
#define TBM_SETSELSTART         (WM_USER+11)
#define TBM_SETSELEND           (WM_USER+12)

// #define TBM_SETTICTOK           (WM_USER+13)

/* return a pointer to the list of tics (DWORDS) */
#define TBM_GETPTICS            (WM_USER+14)

/* get the pixel position of a given tick */
#define TBM_GETTICPOS           (WM_USER+15)
/* get the number of tics */
#define TBM_GETNUMTICS          (WM_USER+16)

/* get the selection range */
#define TBM_GETSELSTART         (WM_USER+17)
#define TBM_GETSELEND  	        (WM_USER+18)

/* clear the selection */
#define TBM_CLEARSEL  	        (WM_USER+19)

/* set tic frequency */
#define TBM_SETTICFREQ		(WM_USER+20)

/* Set/get the page size */
#define TBM_SETPAGESIZE         (WM_USER+21)  // lParam = lPageSize .  Returns old pagesize
#define TBM_GETPAGESIZE         (WM_USER+22)

/* Set/get the line size */
#define TBM_SETLINESIZE         (WM_USER+23)
#define TBM_GETLINESIZE         (WM_USER+24)

/* Get the thumb's and channel's rect size */
#define TBM_GETTHUMBRECT        (WM_USER+25) // lParam = lprc  .  for return value
#define TBM_GETCHANNELRECT      (WM_USER+26) // lParam = lprc  .  for return value



/*REVIEW: these match the SB_ (scroll bar messages); define them that way? */

#define TB_LINEUP		0
#define TB_LINEDOWN		1
#define TB_PAGEUP		2
#define TB_PAGEDOWN		3
#define TB_THUMBPOSITION	4
#define TB_THUMBTRACK		5
#define TB_TOP			6
#define TB_BOTTOM		7
#define TB_ENDTRACK             8
#endif

/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NODRAGLIST

typedef struct {
    UINT uNotification;
    HWND hWnd;
    POINT ptCursor;
} DRAGLISTINFO, FAR *LPDRAGLISTINFO;

#define DL_BEGINDRAG    (WM_USER+133)
#define DL_DRAGGING     (WM_USER+134)
#define DL_DROPPED      (WM_USER+135)
#define DL_CANCELDRAG   (WM_USER+136)

#define DL_CURSORSET	0
#define DL_STOPCURSOR	1
#define DL_COPYCURSOR	2
#define DL_MOVECURSOR	3

#define DRAGLISTMSGSTRING "commctrl_DragListMsg"

BOOL WINAPI MakeDragList(HWND hLB);
void WINAPI DrawInsert(HWND handParent, HWND hLB, int nItem);
int WINAPI LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll);

#endif /* NODRAGLIST */

/*/////////////////////////////////////////////////////////////////////////*/
// spinner control
#ifndef NOUPDOWN

/*
// OVERVIEW:
//
// The UpDown control is a simple pair of buttons which increment or
// decrement an integer value.  The operation is similar to a vertical
// scrollbar; except that the control only has line-up and line-down
// functionality, and changes the current position automatically.
//
// The control also can be linked with a companion control, usually an
// "edit" control, to simplify dialog-box management.  This companion is
// termed a "buddy" in this documentation.  Any sibling HWND may be
// assigned as the control's buddy, or the control may be allowed to
// choose one automatically.  Once chosen, the UpDown can size itself to
// match the buddy's right or left border, and/or automatically set the
// text of the buddy control to make the current position visible.
//
// ADDITIONAL NOTES:
//
// The "upper" and "lower" limits must not cover a range larger than 32,767
// positions.  It is acceptable to have the range inverted, i.e., to have
// (lower > upper).  The upper button always moves the current position
// towards the "upper" number, and the lower button always moves towards the
// "lower" number.  If the range is zero (lower == upper), or the control
// is disabled (EnableWindow(hCtrl, FALSE)), the control draws grayed
// arrows in both buttons.  The UDS_WRAP style makes the range cyclic; that
// is, the numbers will wrap once one end of the range is reached.
//
// The buddy window must have the same parent as the UpDown control.
//
// If either of the UDS_ALIGN* styles are used, the updown control will
// locate itself on the "inside" of the buddy by resizing the buddy
// accordingly.  so the original size of the buddy will now emcompass
// both a slightly smaller buddy and the updown control.
//
// If the buddy window resizes, and the UDS_ALIGN* styles are used, it
// is necessary to send the UDM_SETBUDDY message to re-anchor the UpDown
// control on the appropriate border of the buddy window.
//
// The UDS_AUTOBUDDY style uses GetWindow(hCtrl, GW_HWNDPREV) to pick
// the best buddy window.  In the case of a DIALOG resource, this will
// choose the previous control listed in the resource script.  If the
// windows will change in Z-order, sending UDM_SETBUDDY with a NULL handle
// will pick a new buddy; otherwise the original auto-buddy choice is
// maintained.
//
// The UDS_SETBUDDYINT style uses its own SetDlgItemInt-style
// functionality to set the caption text of the buddy.  All WIN.INI [Intl]
// values are honored by this routine.
//
// The UDS_ARROWKEYS style will subclass the buddy window, in order to steal
// the VK_UP and VK_DOWN arrow key messages.
//
// The UDS_HORZ sytle will draw the two buttons side by side with
// left and right arrows instead of up and down arrows.  It will also
// send the WM_HSCROLL message instead
//
*/

#ifdef WIN32
#define UPDOWN_CLASS "msctls_updown32"
#else
#define UPDOWN_CLASS "msctls_updown"
#endif

/* Structures */

typedef struct _UDACCEL {
    UINT nSec;
    UINT nInc;
} UDACCEL, FAR *LPUDACCEL;

#define UD_MAXVAL	0x7fff
#define UD_MINVAL	(-UD_MAXVAL)


/* STYLE BITS */

#define UDS_WRAP		0x0001
#define UDS_SETBUDDYINT		0x0002
#define UDS_ALIGNRIGHT		0x0004
#define UDS_ALIGNLEFT		0x0008
#define UDS_AUTOBUDDY		0x0010
#define UDS_ARROWKEYS		0x0020
#define UDS_HORZ                0x0040
#define UDS_NOTHOUSANDS		0x0080


/* MESSAGES */

#define UDM_SETRANGE		(WM_USER+101)
	/* wParam: not used, 0
	// lParam: short LOWORD, new upper; short HIWORD, new lower limit
	// return: not used
	*/

#define UDM_GETRANGE		(WM_USER+102)
	/* wParam: not used, 0
	// lParam: not used, 0
	// return: short LOWORD, upper; short HIWORD, lower limit
	*/

#define UDM_SETPOS		(WM_USER+103)
	/* wParam: not used, 0
	// lParam: short LOWORD, new pos; HIWORD not used, 0
	// return: short LOWORD, old pos; HIWORD not used
	*/

#define UDM_GETPOS		(WM_USER+104)
	/* wParam: not used, 0
	// lParam: not used, 0
	// return: short LOWORD, current pos; HIWORD not used
	*/

#define UDM_SETBUDDY		(WM_USER+105)
	/* wParam: HWND, new buddy
	// lParam: not used, 0
	// return: HWND LOWORD, old buddy; HIWORD not used
	*/

#define UDM_GETBUDDY		(WM_USER+106)
	/* wParam: not used, 0
	// lParam: not used, 0
	// return: HWND LOWORD, current buddy; HIWORD not used
	*/

#define UDM_SETACCEL		(WM_USER+107)
	/* wParam: UINT, number of acceleration steps
	// lParam: LPUDACCEL, pointer to array of UDACCEL elements
	//         Elements should be sorted in increasing nSec order.
	// return: BOOL LOWORD, nonzero if successful; HIWORD not used
	*/

#define UDM_GETACCEL		(WM_USER+108)
	/* wParam: UINT, number of elements in the UDACCEL array
	// lParam: LPUDACCEL, pointer to UDACCEL buffer to receive array
	// return: UINT LOWORD, number of elements returned in buffer
	*/

#define UDM_SETBASE		(WM_USER+109)
	/* wParam: UINT, new radix base (10 for decimal, 16 for hex, etc.)
	// lParam: not used, 0
	// return: not used
	*/
#define UDM_GETBASE		(WM_USER+110)
	/* wParam: not used, 0
	// lParam: not used, 0
	// return: UINT LOWORD, current radix base; HIWORD not used
	*/

/* NOTIFICATIONS */

// This code is used when we send a WM_COMMAND to specific a
// up/down control notification.
// It will be received Before the WM_VSCROLL notification.
#define UDM_DELTAPOS		1
//  wParam: UpDown Control ID
//  lParam: HIWORD -> Notification code (UDM_DELTAPOS)
//  lParam: LOWORD -> Position change delta as a signed 16 bit int.

/* WM_VSCROLL
// Note that unlike a scrollbar, the position is automatically changed by
// the control, and the LOWORD(lParam) is always the new position.  Only
// SB_THUMBTRACK and SB_THUMBPOSITION scroll codes are sent in the wParam.
*/

/* HELPER APIs */

HWND WINAPI CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy,
                                HWND hParent, int nID, HINSTANCE hInst,
                                HWND hBuddy,
				int nUpper, int nLower, int nPos);
	/* Does the CreateWindow call followed by setting the various
	// state information:
	//	hBuddy	The companion control (usually an "edit").
	//	nUpper	The range limit corresponding to the upper button.
	//	nLower	The range limit corresponding to the lower button.
	//	nPos	The initial position.
	// Returns the handle to the control or NULL on failure.
	*/

#endif /* NOUPDOWN */


/*/////////////////////////////////////////////////////////////////////////*/
// progress indicator
#ifndef NOPROGRESS

#ifdef WIN32
#define PROGRESS_CLASS "msctls_progress32"
#else
#define PROGRESS_CLASS "msctls_progress"
#endif

/*
// OVERVIEW:
//
// The progress bar control is a "gas gauge" that can be used to show the
// progress of a lengthy operation.
//
// The application sets the range and current position (similar to a
// scrollbar) and has the ability to advance the current position in
// a variety of ways.
//
// Text can be displayed in the progress bar as either a percentage
// of the entire range (using the PBS_SHOWPERCENT style) or as the
// value of the current position (using the PBS_SHOWPOS style).  If
// neither bit is set, no text is shown in the bar.
//
// When PBM_STEPIT is used to advance the current position, the gauge
// will wrap when it reaches the end and start again at the start.
// The position is clamped at either end in other cases.
//
*/

/*/////////////////////////////////////////////////////////////////////////*/

/* STYLE BITS */

#define PBS_SHOWPERCENT		0x01	// BUGBUG: not implemented yet
#define PBS_SHOWPOS		0x02	// BUGBUG: not implemented yet

/* MESSAGES */

#define PBM_SETRANGE         (WM_USER+1)
	/* wParam: not used, 0
	// lParam: int LOWORD, bottom of range; int HIWORD top of range
	// return: int LOWORD, previous bottom; int HIWORD old top
	*/
#define PBM_SETPOS           (WM_USER+2)
	/* wParam: int new position
	// lParam: not used, 0
	// return: int LOWORD, previous position; HIWORD not used
	*/
#define PBM_DELTAPOS         (WM_USER+3)
	/* wParam: int amount to advance current position
	// lParam: not used, 0
	// return: int LOWORD, previous position; HIWORD not used
	*/
#define PBM_SETSTEP          (WM_USER+4)
	/* wParam: int new step
	// lParam: not used, 0
	// return: int LOWORD, previous step; HIWORD not used
	*/
#define PBM_STEPIT	     (WM_USER+5)
        /* advance current position by current step
	// wParam: not used 0
	// lParam: not used, 0
	// return: int LOWORD, previous position; HIWORD not used
	*/
#endif /* NOPROGRESS */

#ifndef NOHOTKEY

/*
// OVERVIEW:						       k
//
// The hotkey control is designed as an edit control for hotkey
// entry.  the application supplies a set of control/alt/shift
// combinations that are considered invalid and a default combination
// to be used OR'd with an invalid combination.
//
// Hotkey values are returned as a pair of bytes, one for the
// virtual key code of the key and the other specifying the
// modifier combinations used with the key.
//
*/

// possible modifiers
#define HOTKEYF_SHIFT	0x01
#define HOTKEYF_CONTROL	0x02
#define HOTKEYF_ALT	0x04
#define HOTKEYF_EXT	0x08	// keyboard extended bit

// possible modifier combinations (for defining invalid combos)
#define HKCOMB_NONE	0x0001	// no modifiers
#define HKCOMB_S	0x0002	// only shift
#define HKCOMB_C	0x0004	// only control
#define HKCOMB_A	0x0008	// only alt
#define HKCOMB_SC	0x0010	// shift+control
#define HKCOMB_SA	0x0020	// shift+alt
#define HKCOMB_CA	0x0040	// control+alt
#define HKCOMB_SCA	0x0080	// shift+control+alt

// wHotkey: WORD lobyte, virtual key code
//	    WORD hibyte, modifers (combination of HOTKEYF_).
	
#define HKM_SETHOTKEY         (WM_USER+1)
	/* wParam: wHotkey;
	// lParam: not used, 0
	// return: not used
	*/

#define HKM_GETHOTKEY         (WM_USER+2)
	/* wParam: not used, 0
	// lParam: not used, 0
	// return: wHotkey;
	*/

#define HKM_SETRULES         (WM_USER+3)
	/* wParam: UINT, invalid modifier combinations (using HKCOMB_*)
	// lParam: UINT loword, default modifier combination (using HOTKEYF_*)
	//         hiword not used
	// return: not used
	*/

#ifdef WIN32
#define HOTKEY_CLASS "msctls_hotkey32"
#else
#define HOTKEY_CLASS "msctls_hotkey"
#endif
#endif /* NOHOTKEY */

/*/////////////////////////////////////////////////////////////////////////*/

/* Note that the following flags are checked every time the window gets a
 * WM_SIZE message, so the style of the window can be changed "on-the-fly".
 * If NORESIZE is set, then the app is responsible for all control placement
 * and sizing.  If NOPARENTALIGN is set, then the app is responsible for
 * placement.  If neither is set, the app just needs to send a WM_SIZE
 * message for the window to be positioned and sized correctly whenever the
 * parent window size changes.
 * Note that for STATUS bars, CCS_BOTTOM is the default, for HEADER bars,
 * CCS_NOMOVEY is the default, and for TOOL bars, CCS_TOP is the default.
 */
#define CCS_TOP			0x00000001L
/* This flag means the status bar should be "top" aligned.  If the
 * NOPARENTALIGN flag is set, then the control keeps the same top, left, and
 * width measurements, but the height is adjusted to the default, otherwise
 * the status bar is positioned at the top of the parent window such that
 * its client area is as wide as the parent window and its client origin is
 * the same as its parent.
 * Similarly, if this flag is not set, the control is bottom-aligned, either
 * with its original rect or its parent rect, depending on the NOPARENTALIGN
 * flag.
 */
#define CCS_NOMOVEY		0x00000002L
/* This flag means the control may be resized and moved horizontally (if the
 * CCS_NORESIZE flag is not set), but it will not move vertically when a
 * WM_SIZE message comes through.
 */
#define CCS_BOTTOM		0x00000003L
/* Same as CCS_TOP, only on the bottom.
 */
#define CCS_NORESIZE		0x00000004L
/* This flag means that the size given when creating or resizing is exact,
 * and the control should not resize itself to the default height or width
 */
#define CCS_NOPARENTALIGN	0x00000008L
/* This flag means that the control should not "snap" to the top or bottom
 * or the parent window, but should keep the same placement it was given
 */
#define CCS_NOHILITE		0x00000010L
/* Don't draw the one pixel highlight at the top of the control
 */
#define CCS_ADJUSTABLE		0x00000020L
/* This allows a toolbar (header bar?) to be configured by the user.
 */
#define CCS_NODIVIDER		0x00000040L
/* Don't draw the 2 pixel highlight at top of control (toolbar)
 */

/*/////////////////////////////////////////////////////////////////////////*/

//================ LISTVIEW APIS ===========================================
//
// Class name: SysListView (WC_LISTVIEW)
//
// The SysListView control provides for a group of items which are displayed
// as a name and/or an associated icon and associated sub-items, in one of
// several organizations, depending on current style settings:
//  * The Icon Format (LVS_ICON)
//      The control arranges standard-sized icons on an invisible grid
//      with their text caption below the icon. The user can drag icons to
//      rearrange them freely, even overlapping each other.
//  * The Small Icon Format (LVS_SMALLICON)
//      The control arranges half-sized icons on an invisible columnar grid
//      like a multi-column owner-draw listbox, with the caption of each
//      item to the icon's right.  The user can still rearrange items
//      freely to taste.  Converting from LVS_ICON to LVS_SMALLICON and back
//      will attempt to preserve approximate relative positions of
//      repositioned items.
//  * The List Format (LVS_LIST)
//      The control enforces a multi-column list of small-icon items with
//      each item's caption to the right.  No free rearranging is possible.
//  * The Report Format (LVS_REPORT)
//      The control enforces a single-column list of small-icon items with
//      each item's caption to the right, and further columns used for item-
//      specific sub-item text.  The columns are capped with a SysHeader
//      bar (unless specified) which allows the user to change the relative
//      widths of each sub-item column.
//
// The icons and small-icons presented may be assigned as indices into
// an ImageList of the appropriate size.  These ImageLists (either custom
// lists or copies of the system lists) are assigned to the control by the
// owner at initialization time or at any later time.
//
// Text and icon values may be "late-bound," or assigned by a callback
// routine as required by the control.  For example, if it would be slow to
// compute the correct icon or caption for an item, the item can be assigned
// special values which indicate that they should be computed only as the
// items become visible (say, for a long list of items being scrolled into
// view).
//
// Each item has a state, which can be (nearly) any combination of the
// following attributes, mostly managed automatically by the control:
//  * Selected (LVIS_SELECTED)
//      The item appears selected.  The appearance of selected items
//      depends on whether the control has the focus, and the selection
//      system colors.
//  * Focused (LVIS_FOCUSED)
//      One item at a time may be focused.  The item is surrounded with a
//      standard focus-rectangle.
//  * Marked (LVIS_CUT)
//      REVIEW: Call this "Checked"?
//  * Disabled (LVIS_DISABLED)
//      The item is drawn with the standard disabled style and coloring.
//  * Hidden (LVIS_HIDDEN)
//      The item is not visible nor does it respond to user interaction.
//  * Drop-Highlighted (LVIS_DROPHILITED)
//      The item appears marked when the user drags an object over it, if
//      it can accept the object as a drop-target.
//  * Link/Alias/Shortcut (LVIS_LINK)
//      The item's text has a standard link-indicator appended (Foo >>).
//
// There are notifications that allow applications to determine when an item
// has been clicked or double clicked, caption text changes have occured,
// drag tracking is occuring, widths of columns have changed, etc.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef WIN32
#define WC_LISTVIEW         "SysListView32"
#else
#define WC_LISTVIEW         "SysListView"
#endif

// ListView styles
//
// view type styles (we only have 16 bits to use here)
#define LVS_ICON            0x0000
#define LVS_REPORT          0x0001
#define LVS_SMALLICON       0x0002
#define LVS_LIST            0x0003
#define LVS_TYPEMASK        0x0003

// shared styles
#define LVS_SINGLESEL       0x0004
#define LVS_SHOWSELALWAYS   0x0008
#define LVS_SORTASCENDING   0x0010
#define LVS_SORTDESCENDING  0x0020
#define LVS_SHAREIMAGELISTS 0x0040

#define LVS_NOLABELWRAP     0x0080
#define LVS_AUTOARRANGE     0x0100
#define LVS_EDITLABELS      0x0200

#define LVS_NOITEMDATA      0x1000	
#define LVS_NOSCROLL        0x2000

/// the fields below are reserved for style specific settings.
#define LVS_TYPESTYLEMASK   0xfc00     // the mask for all these styles

// Large icon.
#define LVS_ALIGNTOP        0x0000	
#define LVS_ALIGNBOTTOM     0x0400
#define LVS_ALIGNLEFT       0x0800
#define LVS_ALIGNRIGHT      0x0c00
#define LVS_ALIGNMASK       0x0c00

// Report view.
#define LVS_OWNERDRAWFIXED  0x0400
#define LVS_NOCOLUMNHEADER  0x4000
#define LVS_NOSORTHEADER    0x8000

// COLORREF ListView_GetBkColor(HWND hwnd);
#define LVM_GETBKCOLOR      (LVM_FIRST + 0)
#define ListView_GetBkColor(hwnd)  \
    (COLORREF)SendMessage((hwnd), LVM_GETBKCOLOR, 0, 0L)

// BOOL ListView_SetBkColor(HWND hwnd, COLORREF clrBk);
#define LVM_SETBKCOLOR      (LVM_FIRST + 1)
#define ListView_SetBkColor(hwnd, clrBk) \
    (BOOL)SendMessage((hwnd), LVM_SETBKCOLOR, 0, (LPARAM)(COLORREF)(clrBk))

// HIMAGELIST ListView_GetImageList(HWND hwnd, int iImageList);
#define LVM_GETIMAGELIST    (LVM_FIRST + 2)
#define ListView_GetImageList(hwnd, iImageList) \
    (HIMAGELIST)SendMessage((hwnd), LVM_GETIMAGELIST, (WPARAM)(INT)(iImageList), 0L)

#define LVSIL_NORMAL	0
#define LVSIL_SMALL	1
#define LVSIL_STATE	2	

// HIMAGELIST ListView_SetImageList(HWND hwnd, HIMAGELIST himl, int iImageList);
#define LVM_SETIMAGELIST    (LVM_FIRST + 3)
#define ListView_SetImageList(hwnd, himl, iImageList) \
    (HIMAGELIST)(UINT)SendMessage((hwnd), LVM_SETIMAGELIST, (WPARAM)(iImageList), (LPARAM)(UINT)(HIMAGELIST)(himl))

// int ListView_GetItemCount(HWND hwnd);
#define LVM_GETITEMCOUNT    (LVM_FIRST + 4)
#define ListView_GetItemCount(hwnd) \
    (int)SendMessage((hwnd), LVM_GETITEMCOUNT, 0, 0L)

// ListView Item structure

#define LVIF_TEXT           0x0001  // LV_ITEM.mask flags (indicate valid fields in LV_ITEM)
#define LVIF_IMAGE          0x0002
#define LVIF_PARAM          0x0004
#define LVIF_STATE          0x0008

// State flags
#define LVIS_FOCUSED	    0x0001  // LV_ITEM.state flags
#define LVIS_SELECTED       0x0002
#define LVIS_CUT            0x0004  // LVIS_MARKED
#define LVIS_DROPHILITED    0x0008
#define LVIS_DISABLED       0x0010
#define LVIS_HIDDEN         0x0020
#define LVIS_LINK           0x0040

#define LVIS_OVERLAYMASK    0x0F00  // used as ImageList overlay image indexes
#define LVIS_STATEIMAGEMASK 0xF000 // client bits for state image drawing
#define LVIS_USERMASK       LVIS_STATEIMAGEMASK  // BUGBUG: remove me. 

#define INDEXTOSTATEIMAGEMASK(i) ((i) << 12)

typedef struct _LV_ITEM
{
    UINT mask;		// LVIF_ flags
    int iItem;
    int iSubItem;
    UINT state;		// LVIS_ flags
    UINT stateMask;	// LVIS_ flags (valid bits in state)
    LPSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
} LV_ITEM;

    // Values used to cause text/image GETDISPINFO callbacks
#define LPSTR_TEXTCALLBACK      ((LPSTR)-1L)
#define I_IMAGECALLBACK         (-1)

// BOOL ListView_GetItem(HWND hwnd, LV_ITEM FAR* pitem);
#define LVM_GETITEM         (LVM_FIRST + 5)
#define ListView_GetItem(hwnd, pitem) \
    (BOOL)SendMessage((hwnd), LVM_GETITEM, 0, (LPARAM)(LV_ITEM FAR*)(pitem))

// Sets items and subitems.
//
// BOOL ListView_SetItem(HWND hwnd, const LV_ITEM FAR* pitem);
#define LVM_SETITEM         (LVM_FIRST + 6)
#define ListView_SetItem(hwnd, pitem) \
    (BOOL)SendMessage((hwnd), LVM_SETITEM, 0, (LPARAM)(const LV_ITEM FAR*)(pitem))

// int ListView_InsertItem(HWND hwnd, const LV_ITEM FAR* pitem);
#define LVM_INSERTITEM         (LVM_FIRST + 7)
#define ListView_InsertItem(hwnd, pitem)   \
    (int)SendMessage((hwnd), LVM_INSERTITEM, 0, (LPARAM)(const LV_ITEM FAR*)(pitem))

// Deletes the specified item along with all its subitems.
//
// BOOL ListView_DeleteItem(HWND hwnd, int i);
#define LVM_DELETEITEM      (LVM_FIRST + 8)
#define ListView_DeleteItem(hwnd, i) \
    (BOOL)SendMessage((hwnd), LVM_DELETEITEM, (WPARAM)(int)(i), 0L)

// BOOL ListView_DeleteAllItems(HWND hwnd);
#define LVM_DELETEALLITEMS  (LVM_FIRST + 9)
#define ListView_DeleteAllItems(hwnd) \
    (BOOL)SendMessage((hwnd), LVM_DELETEALLITEMS, 0, 0L)

// UINT ListView_GetCallbackMask(HWND hwnd);
#define LVM_GETCALLBACKMASK (LVM_FIRST + 10)
#define ListView_GetCallbackMask(hwnd) \
    (BOOL)SendMessage((hwnd), LVM_GETCALLBACKMASK, 0, 0)

// BOOL ListView_SetCallbackMask(HWND hwnd, UINT mask);
#define LVM_SETCALLBACKMASK (LVM_FIRST + 11)
#define ListView_SetCallbackMask(hwnd, mask) \
    (BOOL)SendMessage((hwnd), LVM_SETCALLBACKMASK, (WPARAM)(UINT)(mask), 0)

// ListView_GetNextItem flags (can be used in combination)
#define LVNI_ALL		0x0000
#define LVNI_FOCUSED    	0x0001  // return only focused item
#define LVNI_SELECTED   	0x0002  // return only selected items
#define LVNI_CUT     	0x0004  // return only marked items
#define LVNI_DROPHILITED	0x0008 // return only drophilited items
#define LVNI_HIDDEN     	0x0010  // return only hidden items
#define LVNI_PREVIOUS   	0x0020  // Go backwards

#define LVNI_ABOVE      	0x0100  // return item geometrically above
#define LVNI_BELOW      	0x0200  // "" below
#define LVNI_TOLEFT     	0x0400  // "" to left
#define LVNI_TORIGHT    	0x0800  // "" to right (NOTE: these four are
                                	//              mutually exclusive, but
                                	//              can be used with other LVNI's)

// int ListView_GetNextItem(HWND hwnd, int i, UINT flags);
#define LVM_GETNEXTITEM     (LVM_FIRST + 12)
#define ListView_GetNextItem(hwnd, i, flags) \
    (int)SendMessage((hwnd), LVM_GETNEXTITEM, (WPARAM)(int)(i), MAKELPARAM((flags), 0))

// ListView_FindInfo definitions
#define LVFI_PARAM      0x0001
#define LVFI_STRING     0x0002
#define LVFI_SUBSTRING  0x0004
#define LVFI_PARTIAL    0x0008
#define LVFI_NOCASE     0x0010
#define LVFI_WRAP       0x0020

typedef struct _LV_FINDINFO
{
    UINT flags;
    LPCSTR psz;
    LPARAM lParam;
} LV_FINDINFO;

// int ListView_FindItem(HWND hwnd, int iStart, const LV_FINDINFO FAR* plvfi);
#define LVM_FINDITEM        (LVM_FIRST + 13)
#define ListView_FindItem(hwnd, iStart, plvfi) \
    (int)SendMessage((hwnd), LVM_FINDITEM, (WPARAM)(int)(iStart), (LPARAM)(const LV_FINDINFO FAR*)(plvfi))

#define LVIR_BOUNDS     0
#define LVIR_ICON       1
#define LVIR_LABEL      2

    // Rectangle bounding all or part of item, based on LVIR_* code.  Rect is returned in view coords
    // BOOL ListView_GetItemRect(HWND hwndLV, int i, RECT FAR* prc, int code);
#define LVM_GETITEMRECT     (LVM_FIRST + 14)
#define ListView_GetItemRect(hwnd, i, prc, code) \
    ((prc)->left = (code), (BOOL)SendMessage((hwnd), LVM_GETITEMRECT, (WPARAM)(int)(i), (LPARAM)(RECT FAR*)(prc)))

    // Move top-left corner of item to (x, y), specified in view rect relative coords
    // (icon and small view only)

// BOOL ListView_SetItemPosition(HWND hwndLV, int i, int x, int y);
#define LVM_SETITEMPOSITION (LVM_FIRST + 15)
#define ListView_SetItemPosition(hwndLV, i, x, y) \
    (BOOL)SendMessage((hwndLV), LVM_SETITEMPOSITION, (WPARAM)(int)(i), MAKELPARAM((x), (y)))

// BOOL ListView_GetItemPosition(HWND hwndLV, int i, POINT FAR* ppt);
#define LVM_GETITEMPOSITION (LVM_FIRST + 16)
#define ListView_GetItemPosition(hwndLV, i, ppt) \
    (BOOL)SendMessage((hwndLV), LVM_GETITEMPOSITION, (WPARAM)(int)(i), (LPARAM)(POINT FAR*)(ppt))

    // Get column width of string
    // int ListView_GetStringWidth(HWND hwndLV, LPCSTR psz);
#define LVM_GETSTRINGWIDTH  (LVM_FIRST + 17)
#define ListView_GetStringWidth(hwndLV, psz) \
    (int)SendMessage((hwndLV), LVM_GETSTRINGWIDTH, 0, (LPARAM)(LPCSTR)(psz))

    // Hit test item.  Returns item at (x,y), or -1 if not on an item.
    // Combination of LVHT_ values *pflags, indicating where the cursor
    // is relative to edges of ListView window (above, below, right, left)
    // or whether (x, y) is over icon, label, or inside window but not on item.
    // int ListView_HitTest(HWND hwndLV, LV_HITTESTINFO FAR* pinfo);

    // ItemHitTest flag values
#define LVHT_NOWHERE        0x0001
#define LVHT_ONITEMICON     0x0002
#define LVHT_ONITEMLABEL    0x0004
#define LVHT_ONITEMSTATEICON 0x0008
#define LVHT_ONITEM         (LVHT_ONITEMICON | LVHT_ONITEMLABEL | LVHT_ONITEMSTATEICON)

#define LVHT_ABOVE          0x0008
#define LVHT_BELOW          0x0010
#define LVHT_TORIGHT        0x0020
#define LVHT_TOLEFT         0x0040

typedef struct _LV_HITTESTINFO
{
    POINT pt;	    // in:	client coords
    UINT flags;	    // out:	LVHT_ flags
    int iItem;	    // out:	item
} LV_HITTESTINFO;

    // int ListView_HitTest(HWND hwndLV, LV_HITTESTINFO FAR* pinfo);
#define LVM_HITTEST     (LVM_FIRST + 18)
#define ListView_HitTest(hwndLV, pinfo) \
    (int)SendMessage((hwndLV), LVM_HITTEST, 0, (LPARAM)(LV_HITTESTINFO FAR*)(pinfo))

    // Return view rectangle, relative to window
    // BOOL ListView_GetViewRect(HWND hwndLV, RECT FAR* prcVis);
    // Scroll an item into view if not wholly or partially visible
    // BOOL ListView_EnsureVisible(HWND hwndLV, int i, BOOL fPartialOK);
#define LVM_ENSUREVISIBLE   (LVM_FIRST + 19)
#define ListView_EnsureVisible(hwndLV, i, fPartialOK) \
    (BOOL)SendMessage((hwndLV), LVM_ENSUREVISIBLE, (WPARAM)(int)(i), MAKELPARAM((fPartialOK), 0))

    // Scroll listview -- offsets origin of view rectangle by dx, dy
    // BOOL ListView_Scroll(HWND hwndLV, int dx, int dy);
#define LVM_SCROLL          (LVM_FIRST + 20)
#define ListView_Scroll(hwndLV, dx, dy) \
    (BOOL)SendMessage((hwndLV), LVM_SCROLL, 0, MAKELPARAM((dx), (dy)))

    // Force eventual redraw of range of items (redraw doesn't occur
    // until WM_PAINT processed -- call UpdateWindow() after to redraw right away)
    // BOOL ListView_RedrawItems(HWND hwndLV, int iFirst, int iLast);
#define LVM_REDRAWITEMS     (LVM_FIRST + 21)
#define ListView_RedrawItems(hwndLV, iFirst, iLast) \
    (BOOL)SendMessage((hwndLV), LVM_REDRAWITEMS, 0, MAKELPARAM((iFirst), (iLast)))

    // Arrange style
#define LVA_DEFAULT         0x0000
#define LVA_ALIGNLEFT       0x0001
#define LVA_ALIGNTOP        0x0002
#define LVA_ALIGNRIGHT      0x0003
#define LVA_ALIGNBOTTOM     0x0004
#define LVA_SNAPTOGRID      0x0005

#define LVA_SORTASCENDING   0x0100  // can be used in combo with above LVA_* values
#define LVA_SORTDESCENDING  0x0200  // ""

    // Arrange icons according to LVA_* code
    // BOOL ListView_Arrange(HWND hwndLV, UINT code);
#define LVM_ARRANGE         (LVM_FIRST + 22)
#define ListView_Arrange(hwndLV, code) \
    (BOOL)SendMessage((hwndLV), LVM_ARRANGE, (WPARAM)(UINT)(code), 0L)

    // Begin editing the label of a control.  Implicitly selects and focuses
    // item.  Send WM_CANCELMODE to cancel.
    // HWND ListView_EditLabel(HWND hwndLV, int i);
#define LVM_EDITLABEL       (LVM_FIRST + 23)
#define ListView_EditLabel(hwndLV, i) \
    (HWND)SendMessage((hwndLV), LVM_EDITLABEL, (WPARAM)(int)(i), 0L)

    // Return edit control being used for editing.  Subclass OK, but
    // don't destroy.  Will be destroyed when editing is finished.
    //HWND ListView_GetEditControl(HWND hwndLV);
#define LVM_GETEDITCONTROL  (LVM_FIRST + 24)
#define ListView_GetEditControl(hwndLV) \
    (HWND)SendMessage((hwndLV), LVM_GETEDITCONTROL, 0, 0L)

typedef struct _LV_COLUMN
{
    UINT mask;
    int fmt;
    int cx;
    LPSTR pszText;
    int cchTextMax;
    int iSubItem;       // subitem to display
} LV_COLUMN;

// LV_COLUMN mask values
#define LVCF_FMT        0x0001
#define LVCF_WIDTH      0x0002
#define LVCF_TEXT       0x0004
#define LVCF_SUBITEM    0x0008


// Column format codes
#define LVCFMT_LEFT     0
#define LVCFMT_RIGHT    1
#define LVCFMT_CENTER   2

// Set/Query column info
// BOOL ListView_GetColumn(HWND hwndLV, int iCol, LV_COLUMN FAR* pcol);
#define LVM_GETCOLUMN       (LVM_FIRST + 25)
#define ListView_GetColumn(hwnd, iCol, pcol) \
    (BOOL)SendMessage((hwnd), LVM_GETCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(LV_COLUMN FAR*)(pcol))

// BOOL ListView_SetColumn(HWND hwndLV, int iCol, LV_COLUMN FAR* pcol);
#define LVM_SETCOLUMN       (LVM_FIRST + 26)
#define ListView_SetColumn(hwnd, iCol, pcol) \
    (BOOL)SendMessage((hwnd), LVM_SETCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(const LV_COLUMN FAR*)(pcol))

// insert/delete report view column
// int ListView_InsertColumn(HWND hwndLV, int iCol, const LV_COLUMN FAR* pcol);
#define LVM_INSERTCOLUMN    (LVM_FIRST + 27)
#define ListView_InsertColumn(hwnd, iCol, pcol) \
    (int)SendMessage((hwnd), LVM_INSERTCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(const LV_COLUMN FAR*)(pcol))

// BOOL ListView_DeleteColumn(HWND hwndLV, int iCol);
#define LVM_DELETECOLUMN    (LVM_FIRST + 28)
#define ListView_DeleteColumn(hwnd, iCol) \
    (BOOL)SendMessage((hwnd), LVM_DELETECOLUMN, (WPARAM)(int)(iCol), 0)

#define LVM_GETCOLUMNWIDTH  (LVM_FIRST + 29)
#define ListView_GetColumnWidth(hwnd, iCol) \
    (int)SendMessage((hwnd), LVM_GETCOLUMNWIDTH, (WPARAM)(int)(iCol), 0)

#define     LVSCW_AUTOSIZE              -1
#define     LVSCW_AUTOSIZE_USEHEADER    -2
#define LVM_SETCOLUMNWIDTH  (LVM_FIRST + 30)
#define ListView_SetColumnWidth(hwnd, iCol, cx) \
    (BOOL)SendMessage((hwnd), LVM_SETCOLUMNWIDTH, (WPARAM)(int)(iCol), MAKELPARAM((cx), 0))

// HIMAGELIST ListView_CreateDragImage(HWND hwndLV, int iItem, LPPOINT lpptUpLeft);
#define LVM_CREATEDRAGIMAGE        (LVM_FIRST + 33)
#define ListView_CreateDragImage(hwnd, i, lpptUpLeft) \
    (HIMAGELIST)SendMessage((hwnd), LVM_CREATEDRAGIMAGE, (WPARAM)(int)(i), (LPARAM)(LPPOINT)(lpptUpLeft))

// BOOL ListView_GetViewRect(HWND hwndLV, RECT FAR* prc);
#define LVM_GETVIEWRECT     (LVM_FIRST + 34)
#define ListView_GetViewRect(hwnd, prc) \
    (BOOL)SendMessage((hwnd), LVM_GETVIEWRECT, 0, (LPARAM)(RECT FAR*)(prc))

// get/set text and textbk color for text drawing.  these override
// the standard window/windowtext settings.  they do NOT override
// when drawing selected text.
// COLORREF ListView_GetTextColor(HWND hwnd);
#define LVM_GETTEXTCOLOR      (LVM_FIRST + 35)
#define ListView_GetTextColor(hwnd)  \
    (COLORREF)SendMessage((hwnd), LVM_GETTEXTCOLOR, 0, 0L)

// BOOL ListView_SetTextColor(HWND hwnd, COLORREF clrText);
#define LVM_SETTEXTCOLOR      (LVM_FIRST + 36)
#define ListView_SetTextColor(hwnd, clrText) \
    (BOOL)SendMessage((hwnd), LVM_SETTEXTCOLOR, 0, (LPARAM)(COLORREF)(clrText))

// COLORREF ListView_GetTextBkColor(HWND hwnd);
#define LVM_GETTEXTBKCOLOR      (LVM_FIRST + 37)
#define ListView_GetTextBkColor(hwnd)  \
    (COLORREF)SendMessage((hwnd), LVM_GETTEXTBKCOLOR, 0, 0L)

// BOOL ListView_SetTextBkColor(HWND hwnd, COLORREF clrTextBk);
#define LVM_SETTEXTBKCOLOR      (LVM_FIRST + 38)
#define ListView_SetTextBkColor(hwnd, clrTextBk) \
    (BOOL)SendMessage((hwnd), LVM_SETTEXTBKCOLOR, 0, (LPARAM)(COLORREF)(clrTextBk))

// messages for getting the index of the first visible item
#define LVM_GETTOPINDEX         (LVM_FIRST + 39)
#define ListView_GetTopIndex(hwndLV, ppt) \
    (int)SendMessage((hwndLV), LVM_GETTOPINDEX, 0, 0)

// Message for getting the count of items per page
#define LVM_GETCOUNTPERPAGE     (LVM_FIRST + 40)
#define ListView_GetCountPerPage(hwndLV, ppt) \
    (int)SendMessage((hwndLV), LVM_GETCOUNTPERPAGE, 0, 0)

// Message for getting the listview origin, which is needed for SetItemPos...
#define LVM_GETORIGIN           (LVM_FIRST + 41)
#define ListView_GetOrigin(hwndLV, ppt) \
    (BOOL)SendMessage((hwndLV), LVM_GETORIGIN, (WPARAM)0, (LPARAM)(POINT FAR*)(ppt))

// Message for getting the count of items per page
#define LVM_UPDATE     (LVM_FIRST + 42)
#define ListView_Update(hwndLV, i) \
    (BOOL)SendMessage((hwndLV), LVM_UPDATE, (WPARAM)i, 0L)

// set and item's state.  this macro will return VOID.  but the
// message returns BOOL success.
#define LVM_SETITEMSTATE                (LVM_FIRST + 43)
#define ListView_SetItemState(hwndLV, i, data, mask) \
{ LV_ITEM lvi;\
  lvi.stateMask = mask;\
  lvi.state = data;\
  SendMessage((hwndLV), LVM_SETITEMSTATE, (WPARAM)i, (LPARAM)(LV_ITEM FAR *)&lvi);\
}

// get the item's state
#define LVM_GETITEMSTATE                (LVM_FIRST + 44)
#define ListView_GetItemState(hwndLV, i, mask) \
   (UINT)SendMessage((hwndLV), LVM_GETITEMSTATE, (WPARAM)i, (LPARAM)mask)

// get the item  text.
// if you want the int return value of how the buff size, you call it yourself.
#define LVM_GETITEMTEXT                 (LVM_FIRST + 45)
#define ListView_GetItemText(hwndLV, i, iSubItem_, pszText_, cchTextMax_) \
{ LV_ITEM lvi;\
  lvi.iSubItem = iSubItem_;\
  lvi.cchTextMax = cchTextMax_;\
  lvi.pszText = pszText_;\
  SendMessage((hwndLV), LVM_GETITEMTEXT, (WPARAM)i, (LPARAM)(LV_ITEM FAR *)&lvi);\
}

// get the item  text.
// if you want the int return value (BOOL) success do it yourself
#define LVM_SETITEMTEXT                 (LVM_FIRST + 46)
#define ListView_SetItemText(hwndLV, i, iSubItem_, pszText_) \
{ LV_ITEM lvi;\
  lvi.iSubItem = iSubItem_;\
  lvi.pszText = pszText_;\
  SendMessage((hwndLV), LVM_SETITEMTEXT, (WPARAM)i, (LPARAM)(LV_ITEM FAR *)&lvi);\
}

// tell the listview that you are going to add nItems lot of items
#define LVM_SETITEMCOUNT                 (LVM_FIRST + 47)
#define ListView_SetItemCount(hwndLV, cItems) \
  SendMessage((hwndLV), LVM_SETITEMCOUNT, (WPARAM)cItems, 0)

typedef int (CALLBACK *PFNLVCOMPARE)(LPARAM, LPARAM, LPARAM);

// tell the listview to resort the items
#define LVM_SORTITEMS                    (LVM_FIRST + 48)
#define ListView_SortItems(hwndLV, _pfnCompare, _lPrm) \
  (BOOL)SendMessage((hwndLV), LVM_SORTITEMS, (WPARAM)(LPARAM)_lPrm, \
  (LPARAM)(PFNLVCOMPARE)_pfnCompare)

// void ListView_SetItemPosition(HWND hwndLV, int i, int x, int y);
#define LVM_SETITEMPOSITION32 (LVM_FIRST + 49)
#define ListView_SetItemPosition32(hwndLV, i, x, y) \
{ POINT ptNewPos = {x,y}; \
    SendMessage((hwndLV), LVM_SETITEMPOSITION32, (WPARAM)(int)(i), (LPARAM)&ptNewPos); \
} 

// get the number of items selected
#define LVM_GETSELECTEDCOUNT  (LVM_FIRST + 50) 
#define ListView_GetSelectedCount(hwndLV) \
    (UINT)SendMessage((hwndLV), LVM_GETSELECTEDCOUNT, 0, 0L)

#define LVM_GETITEMSPACING (LVM_FIRST + 51)
#define ListView_GetItemSpacing(hwndLV, fSmall) \
        (DWORD)SendMessage((hwndLV), LVM_GETITEMSPACING, fSmall, 0L)

// ListView notification codes

// Structure used by all ListView control notifications.
// Not all fields supply useful info for all notifications:
// iItem will be -1 and others 0 if not used.
// Some return a BOOL, too.
//

typedef struct _NM_LISTVIEW
{
    NMHDR   hdr;
    int     iItem;
    int     iSubItem;
    UINT    uNewState;      // Combination of LVIS_* (if uChanged & LVIF_STATE)
    UINT    uOldState;      // Combination of LVIS_*
    UINT    uChanged;       // Combination of LVIF_* indicating what changed
    POINT   ptAction;       // Only valid for LVN_BEGINDRAG and LVN_BEGINRDRAG
    LPARAM  lParam;         // Only valid for LVN_DELETEITEM
} NM_LISTVIEW;

#define LVN_ITEMCHANGING        (LVN_FIRST-0)	// lParam -> NM_LISTVIEW: item changing.  Return FALSE to disallow
#define LVN_ITEMCHANGED         (LVN_FIRST-1)	// item changed.
#define LVN_INSERTITEM          (LVN_FIRST-2)
#define LVN_DELETEITEM          (LVN_FIRST-3)
#define LVN_DELETEALLITEMS      (LVN_FIRST-4)
#define LVN_BEGINLABELEDIT      (LVN_FIRST-5)	// lParam -> LV_DISPINFO: start of label editing
#define LVN_ENDLABELEDIT        (LVN_FIRST-6)	// lParam -> LV_DISPINFO: end of label editing
                                        	// (iItem == -1 if cancel)

//(LVN_FIRST-7) not used


#define LVN_COLUMNCLICK         (LVN_FIRST-8)   // column identified by iItem was clicked

#define LVN_BEGINDRAG           (LVN_FIRST-9)   // Start of drag operation requested
                                        	// (return FALSE if the app handles it)
#define LVN_ENDDRAG             (LVN_FIRST-10)  // End of dragging operation.
#define LVN_BEGINRDRAG          (LVN_FIRST-11)  // Start of button 2 dragging
#define LVN_ENDRDRAG            (LVN_FIRST-12)  // End of button 2 drag (not used yet)

#ifdef PW2
#define LVN_PEN                 (LVN_FIRST-20)  // pen notifications
#endif //PW2

// LVN_DISPINFO notification

#define LVN_GETDISPINFO         (LVN_FIRST-50)	// lParam -> LV_DISPINFO
#define LVN_SETDISPINFO         (LVN_FIRST-51)  // lParam -> LV_DISPINFO

typedef struct _LV_DISPINFO {
    NMHDR hdr;
    LV_ITEM item;
} LV_DISPINFO;

// LVN_KEYDOWN notification
#define LVN_KEYDOWN	(LVN_FIRST-55)

typedef struct _LV_KEYDOWN
{
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} LV_KEYDOWN;


// ====== TREEVIEW APIs =================================================
//
// Class name: SysTreeView (WC_TREEVIEW)
//
// The SysTreeView control provides for a group of items which are
// displayed in a hierarchical organization.  Each item may contain
// independent "sub-item" entries which are displayed below and indented
// from the parent item.
//
// Operation of this control is similar to the SysListView control above,
// except that sub-items are distinct entries, not supporting text elements
// belonging to the owning object (which is the case for the Report View
// mode of the SysListView).
//
// There are notifications that allow applications to determine when an item
// has been clicked or double clicked, caption text changes have occured,
// drag tracking is occuring, widths of columns have changed, node items
// are expanded, etc.
//
// NOTE: All "messages" below are documented as APIs; eventually these
// will be changed to window messages, and corresponding macros will be
// written that have the same signature as the APIs shown below.
//

#ifdef WIN32
#define WC_TREEVIEW     "SysTreeView32"
#else
#define WC_TREEVIEW     "SysTreeView"
#endif

// TreeView window styles
#define TVS_HASBUTTONS      0x0001	// draw "plus" & "minus" sign on nodes with children
#define TVS_HASLINES        0x0002	// draw lines between nodes
#define TVS_LINESATROOT     0x0004	
#define TVS_EDITLABELS      0x0008	// alow text edit in place
#define TVS_DISABLEDRAGDROP 0x0010      // disable draggine notification of nodes
#define TVS_SHOWSELALWAYS   0x0020

typedef struct _TREEITEM FAR* HTREEITEM;

#define TVIF_TEXT           0x0001  // TV_ITEM.mask flags
#define TVIF_IMAGE    	    0x0002
#define TVIF_PARAM          0x0004
#define TVIF_STATE          0x0008
#define TVIF_HANDLE         0x0010
#define TVIF_SELECTEDIMAGE  0x0020
#define TVIF_CHILDREN	    0x0040

// State flags
#define TVIS_FOCUSED	    0x0001  // TV_ITEM.state flags
#define TVIS_SELECTED       0x0002
#define TVIS_CUT            0x0004  // TVIS_MARKED
#define TVIS_DROPHILITED    0x0008
#define TVIS_DISABLED       0x0010
#define TVIS_EXPANDED       0x0020
#define TVIS_EXPANDEDONCE   0x0040

#define TVIS_OVERLAYMASK    0x0F00  // used as ImageList overlay image indexes
#define TVIS_STATEIMAGEMASK 0xF000
#define TVIS_USERMASK       0xF000

#define I_CHILDRENCALLBACK  (-1)    // cChildren value for children callback

typedef struct _TV_ITEM {
    UINT      mask;		// TVIF_ flags
    HTREEITEM hItem;		// The item to be changed
    UINT      state;		// TVIS_ flags
    UINT      stateMask;	// TVIS_ flags (valid bits in state)
    LPSTR     pszText;		// The text for this item
    int       cchTextMax;	// The length of the pszText buffer
    int       iImage;		// The index of the image for this item
    int       iSelectedImage;	// the index of the selected imagex
    int       cChildren;	// # of child nodes, I_CHILDRENCALLBACK for callback
    LPARAM    lParam;		// App defined data
} TV_ITEM, FAR *LPTV_ITEM;

#define TVI_ROOT  ((HTREEITEM)0xFFFF0000)
#define TVI_FIRST ((HTREEITEM)0xFFFF0001)
#define TVI_LAST  ((HTREEITEM)0xFFFF0002)
#define TVI_SORT  ((HTREEITEM)0xFFFF0003)

typedef struct _TV_INSERTSTRUCT {
    HTREEITEM hParent;		// a valid HTREEITEM or TVI_ value
    HTREEITEM hInsertAfter;	// a valid HTREEITEM or TVI_ value
    TV_ITEM item;
} TV_INSERTSTRUCT, FAR *LPTV_INSERTSTRUCT;

#define TVM_INSERTITEM      (TV_FIRST + 0)
#define TreeView_InsertItem(hwnd, lpis) \
    (HTREEITEM)SendMessage((hwnd), TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(lpis))

#define TVM_DELETEITEM      (TV_FIRST + 1)
#define TreeView_DeleteItem(hwnd, hitem) \
    (BOOL)SendMessage((hwnd), TVM_DELETEITEM, 0, (LPARAM)(HTREEITEM)(hitem))

#define TreeView_DeleteAllItems(hwnd) \
    (BOOL)SendMessage((hwnd), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT)

#define TVM_EXPAND	    (TV_FIRST + 2)
#define TreeView_Expand(hwnd, hitem, code) \
    (BOOL)SendMessage((hwnd), TVM_EXPAND, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))

// TreeView_Expand codes
#define TVE_COLLAPSE        0x0001
#define TVE_EXPAND          0x0002
#define TVE_TOGGLE          0x0003
#define TVE_COLLAPSERESET   0x8000	// remove all children when collapsing


#define TVM_GETITEMRECT     (TV_FIRST + 4)
#define TreeView_GetItemRect(hwnd, hitem, prc, code) \
    (*(HTREEITEM FAR *)prc = (hitem), (BOOL)SendMessage((hwnd), TVM_GETITEMRECT, (WPARAM)(code), (LPARAM)(RECT FAR*)(prc)))

#define TVM_GETCOUNT        (TV_FIRST + 5)
#define TreeView_GetCount(hwnd) \
    (UINT)SendMessage((hwnd), TVM_GETCOUNT, 0, 0)

#define TVM_GETINDENT       (TV_FIRST + 6)
#define TreeView_GetIndent(hwnd) \
    (UINT)SendMessage((hwnd), TVM_GETINDENT, 0, 0)

#define TVM_SETINDENT       (TV_FIRST + 7)
#define TreeView_SetIndent(hwnd, indent) \
    (BOOL)SendMessage((hwnd), TVM_SETINDENT, (WPARAM)indent, 0)

#define TVM_GETIMAGELIST    (TV_FIRST + 8)
#define TreeView_GetImageList(hwnd, iImage) \
    (HIMAGELIST)SendMessage((hwnd), TVM_GETIMAGELIST, iImage, 0)

#define TVSIL_NORMAL	0
#define TVSIL_STATE	2	// use TVIS_STATEIMAGEMASK as index into state imagelist

#define TVM_SETIMAGELIST    (TV_FIRST + 9)
#define TreeView_SetImageList(hwnd, himl, iImage) \
    (HIMAGELIST)SendMessage((hwnd), TVM_SETIMAGELIST, iImage, (LPARAM)(UINT)(HIMAGELIST)(himl))


#define TVM_GETNEXTITEM	    (TV_FIRST + 10)
#define TreeView_GetNextItem(hwnd, hitem, code) \
    (HTREEITEM)SendMessage((hwnd), TVM_GETNEXTITEM, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))

// TreeView_GetNextItem & TreeView_SelectItem codes
#define TVGN_ROOT		0x0000  // GetNextItem()
#define TVGN_NEXT		0x0001	// GetNextItem()
#define TVGN_PREVIOUS		0x0002	// GetNextItem()
#define TVGN_PARENT		0x0003	// GetNextItem()
#define TVGN_CHILD		0x0004	// GetNextItem()
#define TVGN_FIRSTVISIBLE	0x0005  // GetNextItem() & SelectItem()
#define TVGN_NEXTVISIBLE	0x0006	// GetNextItem()
#define TVGN_PREVIOUSVISIBLE	0x0007	// GetNextItem()
#define TVGN_DROPHILITE		0x0008	// GetNextItem() & SelectItem()
#define TVGN_CARET		0x0009	// GetNextItem() & SelectItem()

#define TreeView_GetChild(hwnd, hitem)		TreeView_GetNextItem(hwnd, hitem, TVGN_CHILD)
#define TreeView_GetNextSibling(hwnd, hitem)	TreeView_GetNextItem(hwnd, hitem, TVGN_NEXT)
#define TreeView_GetPrevSibling(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_PREVIOUS)
#define TreeView_GetParent(hwnd, hitem)		TreeView_GetNextItem(hwnd, hitem, TVGN_PARENT)
#define TreeView_GetFirstVisible(hwnd)		TreeView_GetNextItem(hwnd, NULL,  TVGN_FIRSTVISIBLE)
#define TreeView_GetNextVisible(hwnd, hitem)	TreeView_GetNextItem(hwnd, hitem, TVGN_NEXTVISIBLE)
#define TreeView_GetPrevVisible(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_PREVIOUSVISIBLE)
#define TreeView_GetSelection(hwnd)		TreeView_GetNextItem(hwnd, NULL,  TVGN_CARET)
#define TreeView_GetDropHilight(hwnd)		TreeView_GetNextItem(hwnd, NULL,  TVGN_DROPHILITE)
#define TreeView_GetRoot(hwnd)		    	TreeView_GetNextItem(hwnd, NULL,  TVGN_ROOT)

#define TVM_SELECTITEM      (TV_FIRST + 11)
#define TreeView_Select(hwnd, hitem, code) \
    (HTREEITEM)SendMessage((hwnd), TVM_SELECTITEM, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))

#define TreeView_SelectItem(hwnd, hitem)	    TreeView_Select(hwnd, hitem, TVGN_CARET)
#define TreeView_SelectDropTarget(hwnd, hitem)	    TreeView_Select(hwnd, hitem, TVGN_DROPHILITE)

#define TVM_GETITEM         (TV_FIRST + 12)
#define TreeView_GetItem(hwnd, pitem) \
    (BOOL)SendMessage((hwnd), TVM_GETITEM, 0, (LPARAM)(TV_ITEM FAR*)(pitem))

#define TVM_SETITEM         (TV_FIRST + 13)
#define TreeView_SetItem(hwnd, pitem) \
    (BOOL)SendMessage((hwnd), TVM_SETITEM, 0, (LPARAM)(const TV_ITEM FAR*)(pitem))

#define TVM_EDITLABEL       (TV_FIRST + 14)
#define TreeView_EditLabel(hwnd, hitem) \
    (HWND)SendMessage((hwnd), TVM_EDITLABEL, 0, (LPARAM)(HTREEITEM)(hitem))

#define TVM_GETEDITCONTROL  (TV_FIRST + 15)
#define TreeView_GetEditControl(hwnd) \
    (HWND)SendMessage((hwnd), TVM_GETEDITCONTROL, 0, 0)

#define TVM_GETVISIBLECOUNT (TV_FIRST + 16)
#define TreeView_GetVisibleCount(hwnd) \
    (UINT)SendMessage((hwnd), TVM_GETVISIBLECOUNT, 0, 0)

#define TVM_HITTEST         (TV_FIRST + 17)
#define TreeView_HitTest(hwnd, lpht) \
    (HTREEITEM)SendMessage((hwnd), TVM_HITTEST, 0, (LPARAM)(LPTV_HITTESTINFO)(lpht))

typedef struct _TV_HITTESTINFO {
    POINT       pt;		// in: client coords
    UINT	flags;		// out: TVHT_ flags
    HTREEITEM   hItem;		// out:
} TV_HITTESTINFO, FAR *LPTV_HITTESTINFO;

#define TVHT_NOWHERE        0x0001
#define TVHT_ONITEMICON     0x0002
#define TVHT_ONITEMLABEL    0x0004
#define TVHT_ONITEM         (TVHT_ONITEMICON | TVHT_ONITEMLABEL | TVHT_ONITEMSTATEICON)
#define TVHT_ONITEMINDENT   0x0008
#define TVHT_ONITEMBUTTON   0x0010
#define TVHT_ONITEMRIGHT    0x0020
#define TVHT_ONITEMSTATEICON 0x0040

#define TVHT_ABOVE          0x0100
#define TVHT_BELOW          0x0200
#define TVHT_TORIGHT        0x0400
#define TVHT_TOLEFT         0x0800

#define TVM_CREATEDRAGIMAGE  (TV_FIRST + 18)
#define TreeView_CreateDragImage(hwnd, hitem) \
    (HIMAGELIST)SendMessage((hwnd), TVM_CREATEDRAGIMAGE, 0, (LPARAM)(HTREEITEM)(hitem))

#define TVM_SORTCHILDREN     (TV_FIRST + 19)
#define TreeView_SortChildren(hwnd, hitem, recurse) \
    (BOOL)SendMessage((hwnd), TVM_SORTCHILDREN, (WPARAM)recurse, (LPARAM)(HTREEITEM)(hitem))

#define TVM_ENSUREVISIBLE    (TV_FIRST + 20)
#define TreeView_EnsureVisible(hwnd, hitem) \
    (BOOL)SendMessage((hwnd), TVM_ENSUREVISIBLE, 0, (LPARAM)(HTREEITEM)(hitem))

#define TVM_SORTCHILDRENCB   (TV_FIRST + 21)
#define TreeView_SortChildrenCB(hwnd, psort, recurse) \
    (BOOL)SendMessage((hwnd), TVM_SORTCHILDRENCB, (WPARAM)recurse, \
    (LPARAM)(LPTV_SORTCB)(psort))

typedef int (CALLBACK *PFNTVCOMPARE)(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
typedef struct _TV_SORTCB
{
	HTREEITEM	hParent;
	PFNTVCOMPARE	lpfnCompare;
	LPARAM		lParam;
} TV_SORTCB, FAR *LPTV_SORTCB;

// common notificaton structure for WM_NOTIFY sent to parent
// some fields are only valid on some notify messages

typedef struct _NM_TREEVIEW {
    NMHDR       hdr;
    UINT	action;         // notification specific action
    TV_ITEM  	itemOld;
    TV_ITEM  	itemNew;
    POINT       ptDrag;
} NM_TREEVIEW, FAR *LPNM_TREEVIEW;

#define TVN_SELCHANGING     (TVN_FIRST-1)
#define TVN_SELCHANGED      (TVN_FIRST-2)

// lParam -> NM_TREEVIEW
// NM_TREEVIEW.itemNew.hItem & NM_TREEVIEW.itemNew.lParam are valid
// NM_TREEVIEW.itemOld.hItem & NM_TREEVIEW.itemOld.lParam are valid
// NM_TREEVIEW.action is a TVE_ value indicating how the selcection changed

// TVN_SELCHANGING & TVN_SELCHANGED action values
#define TVC_UNKNOWN	    0x0000
#define TVC_BYMOUSE         0x0001
#define TVC_BYKEYBOARD      0x0002


#define TVN_GETDISPINFO     (TVN_FIRST-3)
#define TVN_SETDISPINFO     (TVN_FIRST-4)
// lParam -> TV_DISPINFO structure
// TV_DISPINFO.item.hItem & TV_DISPINFO.item.lParam are valid

typedef struct _TV_DISPINFO {
    NMHDR hdr;
    TV_ITEM item;
} TV_DISPINFO;

#define TVN_ITEMEXPANDING   (TVN_FIRST-5)
#define TVN_ITEMEXPANDED    (TVN_FIRST-6)
// lParam -> NM_TREEVIEW
// NM_TREEVIEW.itemNew.hItem & NM_TREEVIEW.itemNew.state & NM_TREEVIEW.itemNew.lParam are valid
// NM_TREEVIEW.action is TVE_ action and flags

#define TVN_BEGINDRAG       (TVN_FIRST-7)
#define TVN_BEGINRDRAG      (TVN_FIRST-8)
// lParam -> NM_TREEVIEW
// NM_TREEVIEW.itemNew.hItem & NM_TREEVIEW.itemNew.lParam are valid
// NM_TREEVIEW.ptDrag is start of drag in client coords

#define TVN_DELETEITEM      (TVN_FIRST-9)
// lParam -> NM_TREEVIEW
// NM_TREEVIEW.itemOld.hItem & NM_TREEVIEW.itemOld.lParam are valid

#define TVN_BEGINLABELEDIT  (TVN_FIRST-10)
#define TVN_ENDLABELEDIT    (TVN_FIRST-11)
// lParam -> NM_TREEVIEW
// TV_DISPINFO.item.hItem & TV_DISPINFO.item.state & TV_DISPINFO.item.lParam are valid

#define TVN_KEYDOWN         (TVN_FIRST-12)
// lParam -> TV_KEYDOWN

typedef struct _TV_KEYDOWN {
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} TV_KEYDOWN;


//============================================================================
//
// Class name: SysTabControl (WC_TABCONTROL)
//
#ifdef WIN32
#define WC_TABCONTROL         "SysTabControl32"
#else
#define WC_TABCONTROL         "SysTabControl"
#endif

// window styles to control tab control behavior

#define TCS_FORCEICONLEFT       0x0010  // 0nly for fixed width mode
#define TCS_FORCELABELLEFT      0x0020  // 0nly for fixed width mode
#define TCS_SHAREIMAGELISTS     0x0040
#define TCS_TABS		0x0000  // default
#define TCS_BUTTONS		0x0100
#define TCS_SINGLELINE		0x0000  // default
#define TCS_MULTILINE		0x0200
#define TCS_RIGHTJUSTIFY	0x0000  // default
#define TCS_FIXEDWIDTH		0x0400
#define TCS_RAGGEDRIGHT		0x0800
#define TCS_FOCUSONBUTTONDOWN   0x1000
#define TCS_OWNERDRAWFIXED      0x2000
#define TCS_TOOLTIPS            0x4000
#define TCS_FOCUSNEVER          0x8000

#define TCM_FIRST	    0x1300	    // Tab Control messages


// COLORREF TabCtrl_GetBkColor(HWND hwnd);
#define TCM_GETBKCOLOR      (TCM_FIRST + 0)
#define TabCtrl_GetBkColor(hwnd)  \
    (COLORREF)SendMessage((hwnd), TCM_GETBKCOLOR, 0, 0L)

// BOOL TabCtrl_SetBkColor(HWND hwnd, COLORREF clrBk);
#define TCM_SETBKCOLOR      (TCM_FIRST + 1)
#define TabCtrl_SetBkColor(hwnd, clrBk) \
    (BOOL)SendMessage((hwnd), TCM_SETBKCOLOR, 0, (LPARAM)(COLORREF)(clrBk))

// HIMAGELIST TabCtrl_GetImageList(HWND hwnd);
#define TCM_GETIMAGELIST    (TCM_FIRST + 2)
#define TabCtrl_GetImageList(hwnd) \
    (HIMAGELIST)SendMessage((hwnd), TCM_GETIMAGELIST, 0, 0L)

// this returns the old image list (null if no previous)
// BOOL TabCtrl_SetImageList(HWND hwnd, HIMAGELIST himl);
#define TCM_SETIMAGELIST    (TCM_FIRST + 3)
#define TabCtrl_SetImageList(hwnd, himl) \
    (HIMAGELIST)SendMessage((hwnd), TCM_SETIMAGELIST, 0, (LPARAM)(UINT)(HIMAGELIST)(himl))

// int TabCtrl_GetItemCount(HWND hwnd);
#define TCM_GETITEMCOUNT    (TCM_FIRST + 4)
#define TabCtrl_GetItemCount(hwnd) \
    (int)SendMessage((hwnd), TCM_GETITEMCOUNT, 0, 0L)


// TabView Item structure

#define TCIF_TEXT       0x0001  // TabView mask flags
#define TCIF_IMAGE      0x0002
#define TCIF_PARAM      0x0008


typedef struct _TC_ITEMHEADER
{
    UINT mask;		// TCIF_ bits
    UINT lpReserved1;
    UINT lpReserved2;
    LPSTR pszText;
    int cchTextMax;
    int iImage;
} TC_ITEMHEADER;

typedef struct _TC_ITEM
{
    // This block must be identical to TC_TEIMHEADER
    UINT mask;		// TCIF_ bits
    UINT lpReserved1;
    UINT lpReserved2;
    LPSTR pszText;
    int cchTextMax;
    int iImage;

    LPARAM lParam;
} TC_ITEM;

// BOOL TabCtrl_GetItem(HWND hwnd, int iItem, TC_ITEM FAR* pitem);
#define TCM_GETITEM         (TCM_FIRST + 5)
#define TabCtrl_GetItem(hwnd, iItem, pitem) \
    (BOOL)SendMessage((hwnd), TCM_GETITEM, (WPARAM)(int)iItem, (LPARAM)(TC_ITEM FAR*)(pitem))

// BOOL TabCtrl_SetItem(HWND hwnd, int iItem, TC_ITEM FAR* pitem);
#define TCM_SETITEM         (TCM_FIRST + 6)
#define TabCtrl_SetItem(hwnd, iItem, pitem) \
    (BOOL)SendMessage((hwnd), TCM_SETITEM, (WPARAM)(int)iItem, (LPARAM)(TC_ITEM FAR*)(pitem))

// int TabCtrl_InsertItem(HWND hwnd, int iItem, const TC_ITEM FAR* pitem);
#define TCM_INSERTITEM         (TCM_FIRST + 7)
#define TabCtrl_InsertItem(hwnd, iItem, pitem)   \
    (int)SendMessage((hwnd), TCM_INSERTITEM, (WPARAM)(int)iItem, (LPARAM)(const TC_ITEM FAR*)(pitem))

// Deletes the specified item along with all its subitems.
//
// BOOL TabCtrl_DeleteItem(HWND hwnd, int i);
#define TCM_DELETEITEM      (TCM_FIRST + 8)
#define TabCtrl_DeleteItem(hwnd, i) \
    (BOOL)SendMessage((hwnd), TCM_DELETEITEM, (WPARAM)(int)(i), 0L)

// BOOL TabCtrl_DeleteAllItems(HWND hwnd);
#define TCM_DELETEALLITEMS  (TCM_FIRST + 9)
#define TabCtrl_DeleteAllItems(hwnd) \
    (BOOL)SendMessage((hwnd), TCM_DELETEALLITEMS, 0, 0L)

    // Rectangle bounding all or part of item, based on code.  Rect is returned in view coords
    // BOOL TabCtrl_GetItemRect(HWND hwndTC, int i, RECT FAR* prc);
#define TCM_GETITEMRECT     (TCM_FIRST + 10)
#define TabCtrl_GetItemRect(hwnd, i, prc) \
    (BOOL)SendMessage((hwnd), TCM_GETITEMRECT, (WPARAM)(int)(i), (LPARAM)(RECT FAR*)(prc))

    // BOOL TabCtrl_GetCurSel(HWND hwndTC);
#define TCM_GETCURSEL     (TCM_FIRST + 11)
#define TabCtrl_GetCurSel(hwnd) \
    (int)SendMessage((hwnd), TCM_GETCURSEL, 0, 0)

#define TCM_SETCURSEL     (TCM_FIRST + 12)
#define TabCtrl_SetCurSel(hwnd, i) \
    (int)SendMessage((hwnd), TCM_SETCURSEL, (WPARAM)i, 0)

    // ItemHitTest flag values
#define TCHT_NOWHERE        0x0001
#define TCHT_ONITEMICON     0x0002
#define TCHT_ONITEMLABEL    0x0004
#define TCHT_ONITEM         (TCHT_ONITEMICON | TCHT_ONITEMLABEL)

typedef struct _TC_HITTESTINFO
{
    POINT pt;	    // in
    UINT flags;	    // out
} TC_HITTESTINFO, FAR * LPTC_HITTESTINFO;

 // int TabCtrl_HitTest(HWND hwndTC, TC_HITTESTINFO FAR* pinfo);
#define TCM_HITTEST     (TCM_FIRST + 13)
#define TabCtrl_HitTest(hwndTC, pinfo) \
    (int)SendMessage((hwndTC), TCM_HITTEST, 0, (LPARAM)(TC_HITTESTINFO FAR*)(pinfo))

// Set the size of extra byte (abExtra[]) for each item.
#define TCM_SETITEMEXTRA    (TCM_FIRST + 14)
#define TabCtrl_SetItemExtra(hwndTC, cb) \
    (BOOL)SendMessage((hwndTC), TCM_SETITEMEXTRA, (WPARAM)(cb), 0L)

// get/set text and textbk color for text drawing.  these override
// the standard window/windowtext settings.  they do NOT override
// when drawing selected text.
// COLORREF TabCtrl_GetTextColor(HWND hwnd);
#define TCM_GETTEXTCOLOR      (TCM_FIRST + 35)
#define TabCtrl_GetTextColor(hwnd)  \
    (COLORREF)SendMessage((hwnd), TCM_GETTEXTCOLOR, 0, 0L)

// BOOL TabCtrl_SetTextColor(HWND hwnd, COLORREF clrText);
#define TCM_SETTEXTCOLOR      (TCM_FIRST + 36)
#define TabCtrl_SetTextColor(hwnd, clrText) \
    (BOOL)SendMessage((hwnd), TCM_SETTEXTCOLOR, 0, (LPARAM)(COLORREF)(clrText))

// COLORREF TabCtrl_GetTextBkColor(HWND hwnd);
#define TCM_GETTEXTBKCOLOR      (TCM_FIRST + 37)
#define TabCtrl_GetTextColor(hwnd)  \
    (COLORREF)SendMessage((hwnd), TCM_GETTEXTCOLOR, 0, 0L)

// BOOL TabCtrl_SetTextBkColor(HWND hwnd, COLORREF clrTextBk);
#define TCM_SETTEXTBKCOLOR      (TCM_FIRST + 38)
#define TabCtrl_SetTextBkColor(hwnd, clrTextBk) \
    (BOOL)SendMessage((hwnd), TCM_SETTEXTBKCOLOR, 0, (LPARAM)(COLORREF)(clrTextBk))

#define TCM_ADJUSTRECT	(TCM_FIRST + 40)
#define TabCtrl_AdjustRect(hwnd, bLarger, prc) \
    (void)SendMessage(hwnd, TCM_ADJUSTRECT, (WPARAM)(BOOL)bLarger, (LPARAM)(RECT FAR *)prc)

#define TCM_SETITEMSIZE	(TCM_FIRST + 41)
#define TabCtrl_SetItemSize(hwnd, x, y) \
    (DWORD)SendMessage((hwnd), TCM_SETITEMSIZE, 0, MAKELPARAM(x,y))

#define TCM_REMOVEIMAGE         (TCM_FIRST + 42)
#define TabCtrl_RemoveImage(hwnd, i) \
        (void)SendMessage((hwnd), TCM_REMOVEIMAGE, i, 0L)

#define TCM_SETPADDING          (TCM_FIRST + 43)
#define TabCtrl_SetPadding(hwnd,  cx, cy) \
        (void)SendMessage((hwnd), TCM_SETPADDING, 0, MAKELPARAM(cx, cy))

#define TCM_GETROWCOUNT         (TCM_FIRST + 44)
#define TabCtrl_GetRowCount(hwnd) \
        (int)SendMessage((hwnd), TCM_GETROWCOUNT, 0, 0L)


/* all params are NULL
 * returns the hwnd for tooltips control  or NULL
 */
#define TCM_GETTOOLTIPS		(TCM_FIRST + 45)
#define TabCtrl_GetToolTips(hwnd) \
        (HWND)SendMessage((hwnd), TCM_GETTOOLTIPS, 0, 0L)

/* wParam: HWND of ToolTips control to use
 * lParam unused
 */
#define TCM_SETTOOLTIPS		(TCM_FIRST + 46)
#define TabCtrl_SetToolTips(hwnd, hwndTT) \
        (void)SendMessage((hwnd), TCM_SETTOOLTIPS, (WPARAM)hwndTT, 0L)

// this returns the item with the current focus.. which might not be 
// the currently selected item, if the user is in the process of selecting a new 
// item
    // BOOL TabCtrl_GetCurFocus(HWND hwndTC);
#define TCM_GETCURFOCUS     (TCM_FIRST + 47)
#define TabCtrl_GetCurFocus(hwnd) \
    (int)SendMessage((hwnd), TCM_GETCURFOCUS, 0, 0)

// TabView notification codes

#define TCN_KEYDOWN         (TCN_FIRST - 0)
typedef struct _TC_KEYDOWN
{
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} TC_KEYDOWN;

// selection has changed
#define TCN_SELCHANGE	    (TCN_FIRST - 1)

// selection changing away from current tab
// return:  FALSE to continue, or TRUE to not change
#define TCN_SELCHANGING     (TCN_FIRST - 2)

/*/////////////////////////////////////////////////////////////////////////*/
// Animate control
#ifndef NOANIMATE

/*
// OVERVIEW:
//
// The Animte control is a simple animation control, you can use it to
// have animaed controls in dialogs.
//
// what it animates are simple .AVI files from a resource.
// a simple AVI is a uncompressed or RLE compressed AVI file.
//
// the .AVI file must be placed in the resource with a type of "AVI"
//
// example:
//
//  myapp.rc:
//      MyAnimation AVI foobar.avi      // must be simple RLE avifile
//
//  myapp.c:
//      Animate_Open(hwndA, "MyAnimation"); // open the resource
//      Animate_Play(hwndA, 0, -1, -1);     // play from start to finish and repeat
*/

#ifdef WIN32
#define ANIMATE_CLASS "SysAnimate32"
#else
#define ANIMATE_CLASS "SysAnimate"
#endif

/* STYLE BITS */

#define ACS_CENTER          0x0001      // center animation in window
#define ACS_TRANSPARENT     0x0002      // make animation transparent.
#define ACS_AUTOPLAY        0x0004      // start playing on open

/* MESSAGES */

#define ACM_OPEN    (WM_USER+100)
	/* wParam: not used, 0
        // lParam: name of resource/file to open
        // return: bool
        */

#define ACM_PLAY            (WM_USER+101)
        /* wParam: repeat count        -1 = repeat forever.
        // lParam: LOWORD=frame start   0 = first frame.
        //         HIWORD=play end     -1 = last frame.
        // return: bool
        */

#define ACM_STOP            (WM_USER+102)
        /* wParam: not used
        // lParam: not used
        // return: bool
        */

/* notify codes, sent via WM_COMMAND */

#define ACN_START   1           // file has started playing
#define ACN_STOP    2           // file has stopped playing

/* HELPER MACROS */

#define Animate_Create(hwndP, id, dwStyle, hInstance)   \
            CreateWindow(ANIMATE_CLASS, NULL,           \
                dwStyle, 0, 0, 0, 0, hwndP, (HMENU)(id), hInstance, NULL)

#define Animate_Open(hwnd, szName)          (BOOL)SendMessage(hwnd, ACM_OPEN, 0, (LPARAM)(LPSTR)(szName))
#define Animate_Play(hwnd, from, to, rep)   (BOOL)SendMessage(hwnd, ACM_PLAY, (WPARAM)(UINT)(rep), (LPARAM)MAKELONG(from, to))
#define Animate_Stop(hwnd)                  (BOOL)SendMessage(hwnd, ACM_STOP, 0, 0)
#define Animate_Close(hwnd)                 Animate_Open(hwnd, NULL)
#define Animate_Seek(hwnd, frame)           Animate_Play(hwnd, frame, frame, 0)

#endif /* NOANIMATE */



// BUGBUG: move some place else

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif /* _INC_COMMCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\colordlg.h ===
/*****************************************************************************\
*                                                                             *
* colordlg.h -  Common dialog color dialog's control id numbers               *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COLORDLG
#define _INC_COLORDLG

#define DLG_COLOR          10

#define COLOR_HUESCROLL   700	       /* color dialog */
#define COLOR_SATSCROLL   701
#define COLOR_LUMSCROLL   702
#define COLOR_HUE         703
#define COLOR_SAT         704
#define COLOR_LUM         705
#define COLOR_RED         706
#define COLOR_GREEN       707
#define COLOR_BLUE        708
#define COLOR_CURRENT     709
#define COLOR_RAINBOW     710
#define COLOR_SAVE        711
#define COLOR_ADD         712
#define COLOR_SOLID       713
#define COLOR_TUNE        714
#define COLOR_SCHEMES     715
#define COLOR_ELEMENT     716
#define COLOR_SAMPLES     717
#define COLOR_PALETTE     718
#define COLOR_MIX         719
#define COLOR_BOX1        720
#define COLOR_CUSTOM1     721

#define COLOR_HUEACCEL    723
#define COLOR_SATACCEL    724
#define COLOR_LUMACCEL    725
#define COLOR_REDACCEL    726
#define COLOR_GREENACCEL  727
#define COLOR_BLUEACCEL   728

#define NUM_BASIC_COLORS   48
#define NUM_CUSTOM_COLORS  16

#endif  /* !_INC_COLORDLG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\compddk.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
 *
 *  Compddk.h - include file for implementing installable compressors
 *
 *  Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.
 *
 **********************************************************************
 *
 * To register FOURCC's for codec types please obtain a
 * copy of the Multimedia Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 *
*/

#ifndef _INC_COMPDDK
#define _INC_COMPDDK	50	/* version number */

#ifndef RC_INVOKED
#ifndef WIN32
#pragma pack(1)         /* Assume byte packing throughout */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin_vfw32

#define ICVERSION       0x0104

DECLARE_HANDLE(HIC);     /* Handle to a Installable Compressor */

//
// this code in biCompression means the DIB must be accesed via
// 48 bit pointers! using *ONLY* the selector given.
//
#define BI_1632  0x32333631     // '1632'

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#ifndef ICERR_OK
#define ICERR_OK                0L
#define ICERR_DONTDRAW          1L
#define ICERR_NEWPALETTE        2L
#define ICERR_GOTOKEYFRAME	3L
#define ICERR_STOPDRAWING 	4L

#define ICERR_UNSUPPORTED      -1L
#define ICERR_BADFORMAT        -2L
#define ICERR_MEMORY           -3L
#define ICERR_INTERNAL         -4L
#define ICERR_BADFLAGS         -5L
#define ICERR_BADPARAM         -6L
#define ICERR_BADSIZE          -7L
#define ICERR_BADHANDLE        -8L
#define ICERR_CANTUPDATE       -9L
#define ICERR_ABORT	       -10L
#define ICERR_ERROR            -100L
#define ICERR_BADBITDEPTH      -200L
#define ICERR_BADIMAGESIZE     -201L

#define ICERR_CUSTOM           -400L    // errors less than ICERR_CUSTOM...
#endif

/* Values for dwFlags of ICOpen() */
#ifndef ICMODE_COMPRESS
#define ICMODE_COMPRESS		1
#define ICMODE_DECOMPRESS	2
#define ICMODE_FASTDECOMPRESS   3
#define ICMODE_QUERY            4
#define ICMODE_FASTCOMPRESS     5
#define ICMODE_DRAW             8
#endif

/* Flags for AVI file index */
#define AVIIF_LIST	0x00000001L
#define AVIIF_TWOCC	0x00000002L
#define AVIIF_KEYFRAME	0x00000010L

/* quality flags */
#define ICQUALITY_LOW       0
#define ICQUALITY_HIGH      10000
#define ICQUALITY_DEFAULT   -1

/************************************************************************
************************************************************************/

#define ICM_USER          (DRV_USER+0x0000)

#define ICM_RESERVED      ICM_RESERVED_LOW
#define ICM_RESERVED_LOW  (DRV_USER+0x1000)
#define ICM_RESERVED_HIGH (DRV_USER+0x2000)

/************************************************************************

    messages.

************************************************************************/

#define ICM_GETSTATE                (ICM_RESERVED+0)    // Get compressor state
#define ICM_SETSTATE                (ICM_RESERVED+1)    // Set compressor state
#define ICM_GETINFO                 (ICM_RESERVED+2)    // Query info about the compressor

#define ICM_CONFIGURE               (ICM_RESERVED+10)   // show the configure dialog
#define ICM_ABOUT                   (ICM_RESERVED+11)   // show the about box

#define ICM_GETERRORTEXT            (ICM_RESERVED+12)   // get error text TBD

#define ICM_GETFORMATNAME	    (ICM_RESERVED+20)	// get a name for a format
#define ICM_ENUMFORMATS		    (ICM_RESERVED+21)	// cycle through formats

#define ICM_GETDEFAULTQUALITY       (ICM_RESERVED+30)   // get the default value for quality
#define ICM_GETQUALITY              (ICM_RESERVED+31)   // get the current value for quality
#define ICM_SETQUALITY              (ICM_RESERVED+32)   // set the default value for quality

#define ICM_SET			    (ICM_RESERVED+40)	// Tell the driver something
#define ICM_GET			    (ICM_RESERVED+41)	// Ask the driver something

// Constants for ICM_SET:
#define ICM_FRAMERATE       mmioFOURCC('F','r','m','R')
#define ICM_KEYFRAMERATE    mmioFOURCC('K','e','y','R')

/************************************************************************

    ICM specific messages.

************************************************************************/

#define ICM_COMPRESS_GET_FORMAT     (ICM_USER+4)    // get compress format or size
#define ICM_COMPRESS_GET_SIZE       (ICM_USER+5)    // get output size
#define ICM_COMPRESS_QUERY          (ICM_USER+6)    // query support for compress
#define ICM_COMPRESS_BEGIN          (ICM_USER+7)    // begin a series of compress calls.
#define ICM_COMPRESS                (ICM_USER+8)    // compress a frame
#define ICM_COMPRESS_END            (ICM_USER+9)    // end of a series of compress calls.

#define ICM_DECOMPRESS_GET_FORMAT   (ICM_USER+10)   // get decompress format or size
#define ICM_DECOMPRESS_QUERY        (ICM_USER+11)   // query support for dempress
#define ICM_DECOMPRESS_BEGIN        (ICM_USER+12)   // start a series of decompress calls
#define ICM_DECOMPRESS              (ICM_USER+13)   // decompress a frame
#define ICM_DECOMPRESS_END          (ICM_USER+14)   // end a series of decompress calls
#define ICM_DECOMPRESS_SET_PALETTE  (ICM_USER+29)   // fill in the DIB color table
#define ICM_DECOMPRESS_GET_PALETTE  (ICM_USER+30)   // fill in the DIB color table

#define ICM_DRAW_QUERY              (ICM_USER+31)   // query support for dempress
#define ICM_DRAW_BEGIN              (ICM_USER+15)   // start a series of draw calls
#define ICM_DRAW_GET_PALETTE        (ICM_USER+16)   // get the palette needed for drawing
#define ICM_DRAW_UPDATE             (ICM_USER+17)   // update screen with current frame
#define ICM_DRAW_START              (ICM_USER+18)   // start decompress clock
#define ICM_DRAW_STOP               (ICM_USER+19)   // stop decompress clock
#define ICM_DRAW_BITS/* not used */ (ICM_USER+20)   // decompress a frame to screen
#define ICM_DRAW_END                (ICM_USER+21)   // end a series of draw calls
#define ICM_DRAW_GETTIME            (ICM_USER+32)   // get value of decompress clock
#define ICM_DRAW                    (ICM_USER+33)   // generalized "render" message
#define ICM_DRAW_WINDOW             (ICM_USER+34)   // drawing window has moved or hidden
#define ICM_DRAW_SETTIME            (ICM_USER+35)   // set correct value for decompress clock
#define ICM_DRAW_REALIZE            (ICM_USER+36)   // realize palette for drawing
#define ICM_DRAW_FLUSH	            (ICM_USER+37)   // clear out buffered frames
#define ICM_DRAW_RENDERBUFFER       (ICM_USER+38)   // draw undrawn things in queue

#define ICM_DRAW_START_PLAY         (ICM_USER+39)   // start of a play
#define ICM_DRAW_STOP_PLAY          (ICM_USER+40)   // end of a play

#define ICM_DRAW_SUGGESTFORMAT      (ICM_USER+50)   // Like ICGetDisplayFormat
#define ICM_DRAW_CHANGEPALETTE      (ICM_USER+51)   // for animating palette

#define ICM_DRAW_IDLE               (ICM_USER+52)   // send each frame time

#define ICM_GETBUFFERSWANTED        (ICM_USER+41)   // ask about prebuffering

#define ICM_GETDEFAULTKEYFRAMERATE  (ICM_USER+42)   // get the default value for key frames


#define ICM_DECOMPRESSEX_BEGIN      (ICM_USER+60)   // start a series of decompress calls
#define ICM_DECOMPRESSEX_QUERY      (ICM_USER+61)   // start a series of decompress calls
#define ICM_DECOMPRESSEX            (ICM_USER+62)   // decompress a frame
#define ICM_DECOMPRESSEX_END        (ICM_USER+63)   // end a series of decompress calls

#define ICM_COMPRESS_FRAMES_INFO    (ICM_USER+70)   // tell about compress to come
#define ICM_COMPRESS_FRAMES         (ICM_USER+71)   // compress a bunch of frames
#define ICM_SET_STATUS_PROC	        (ICM_USER+72)   // set status callback

#define ICM_ENUM_FORMATS            (ICM_USER+80)   // enum all formats
#define ICM_GET_FORMAT_NAME         (ICM_USER+81)   // compress a bunch of frames

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwSize;         // sizeof(ICOPEN)
    DWORD               fccType;        // 'vidc'
    DWORD               fccHandler;     //
    DWORD               dwVersion;      // version of compman opening you
    DWORD               dwFlags;        // LOWORD is type specific
    LRESULT             dwError;        // error return.
} ICOPEN;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD   dwSize;                 // sizeof(ICINFO)
    DWORD   fccType;                // compressor type     'vidc' 'audc'
    DWORD   fccHandler;             // compressor sub-type 'rle ' 'jpeg' 'pcm '
    DWORD   dwFlags;                // flags LOWORD is type specific
    DWORD   dwVersion;              // version of the driver
    DWORD   dwVersionICM;           // version of the ICM used
// end_vfw32
#ifdef WIN32
// begin_vfw32
    //
    // under Win32, the driver always returns UNICODE strings.
    //
    WCHAR   szName[16];             // short name
    WCHAR   szDescription[128];     // long name
    WCHAR   szDriver[128];          // driver that contains compressor
// end_vfw32
#else
    char    szName[16];             // short name
    char    szDescription[128];     // long name
    char    szDriver[128];          // driver that contains compressor
#endif
// begin_vfw32
}   ICINFO;

/* Flags for the <dwFlags> field of the <ICINFO> structure. */
#define VIDCF_QUALITY        0x0001  // supports quality
#define VIDCF_CRUNCH         0x0002  // supports crunching to a frame size
#define VIDCF_TEMPORAL       0x0004  // supports inter-frame compress
#define VIDCF_COMPRESSFRAMES 0x0008  // wants the compress all frames message
#define VIDCF_DRAW           0x0010  // supports drawing
#define VIDCF_FASTTEMPORALC  0x0020  // does not need prev frame on compress
#define VIDCF_FASTTEMPORALD  0x0080  // does not need prev frame on decompress
//#define VIDCF_QUALITYTIME    0x0040  // supports temporal quality

//#define VIDCF_FASTTEMPORAL   (VIDCF_FASTTEMPORALC|VIDCF_FASTTEMPORALD)

/************************************************************************
************************************************************************/

#define ICCOMPRESS_KEYFRAME	0x00000001L

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPVOID              lpOutput;       // output data

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPVOID              lpInput;        // frame data to compress

    LPDWORD             lpckid;         // ckid for data in AVI file
    LPDWORD             lpdwFlags;      // flags in the AVI index.
    LONG                lFrameNum;      // frame number of seq.
    DWORD               dwFrameSize;    // reqested size in bytes. (if non zero)

    DWORD               dwQuality;      // quality

    // these are new fields
    LPBITMAPINFOHEADER  lpbiPrev;       // format of previous frame
    LPVOID              lpPrev;         // previous frame

} ICCOMPRESS;

/************************************************************************
************************************************************************/

#define ICCOMPRESSFRAMES_PADDING	0x00000001

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPARAM              lOutput;        // output identifier

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPARAM              lInput;         // input identifier

    LONG                lStartFrame;    // start frame
    LONG                lFrameCount;    // # of frames

    LONG                lQuality;       // quality
    LONG                lDataRate;      // data rate
    LONG                lKeyRate;       // key frame rate

    DWORD		dwRate;		// frame rate, as always
    DWORD		dwScale;

    DWORD		dwOverheadPerFrame;
    DWORD		dwReserved2;

    LONG (CALLBACK *GetData)(LPARAM lInput, LONG lFrame, LPVOID lpBits, LONG len);
    LONG (CALLBACK *PutData)(LPARAM lOutput, LONG lFrame, LPVOID lpBits, LONG len);
} ICCOMPRESSFRAMES;

typedef struct {
    DWORD		dwFlags;
    LPARAM		lParam;

    // messages for Status callback
    #define ICSTATUS_START	    0
    #define ICSTATUS_STATUS	    1	    // l == % done
    #define ICSTATUS_END	    2
    #define ICSTATUS_ERROR	    3	    // l == error string (LPSTR)
    #define ICSTATUS_YIELD	    4
    // return nonzero means abort operation in progress

    LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l);
} ICSETSTATUSPROC;

/************************************************************************
************************************************************************/

#define ICDECOMPRESS_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDECOMPRESS_UPDATE       0x40000000L   // don't draw just update screen
#define ICDECOMPRESS_PREROLL      0x20000000L   // this frame is before real start
#define ICDECOMPRESS_NULLFRAME    0x10000000L   // repeat last frame
#define ICDECOMPRESS_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)

    LPBITMAPINFOHEADER  lpbiInput;  // BITMAPINFO of compressed data
                                    // biSizeImage has the chunk size
    LPVOID              lpInput;    // compressed data

    LPBITMAPINFOHEADER  lpbiOutput; // DIB to decompress to
    LPVOID              lpOutput;
    DWORD		ckid;	    // ckid from AVI file
} ICDECOMPRESS;

typedef struct {
    //
    // same as ICM_DECOMPRESS
    //
    DWORD               dwFlags;

    LPBITMAPINFOHEADER  lpbiSrc;    // BITMAPINFO of compressed data
    LPVOID              lpSrc;      // compressed data

    LPBITMAPINFOHEADER  lpbiDst;    // DIB to decompress to
    LPVOID              lpDst;      // output data

    //
    // new for ICM_DECOMPRESSEX
    //
    int                 xDst;       // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    int                 xSrc;       // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

} ICDECOMPRESSEX;

/************************************************************************
************************************************************************/

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND
#define ICDRAW_ANIMATE	    0x00000008L	  // expect palette animation
#define ICDRAW_CONTINUE	    0x00000010L	  // draw is a continuation of previous draw
#define ICDRAW_MEMORYDC	    0x00000020L	  // DC is offscreen, by the way
#define ICDRAW_UPDATING	    0x00000040L	  // We're updating, as opposed to playing
#define ICDRAW_RENDER       0x00000080L   // used to render data not draw it
#define ICDRAW_BUFFER       0x00000100L   // please buffer this data offscreen, we will need to update it

typedef struct {
    DWORD               dwFlags;        // flags

    HPALETTE            hpal;           // palette to draw with
    HWND                hwnd;           // window to draw to
    HDC                 hdc;            // HDC to draw to

    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    LPBITMAPINFOHEADER  lpbi;           // format of frame to draw

    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

    DWORD               dwRate;         // frames/second = (dwRate/dwScale)
    DWORD               dwScale;

} ICDRAWBEGIN;

/************************************************************************
************************************************************************/

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen
#define ICDRAW_PREROLL	    0x20000000L	  // this frame is before real start
#define ICDRAW_NULLFRAME    0x10000000L	  // repeat last frame
#define ICDRAW_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;        // flags
    LPVOID		lpFormat;       // format of frame to decompress
    LPVOID              lpData;         // frame data to decompress
    DWORD               cbData;
    LONG                lTime;          // time in drawbegin units (see dwRate and dwScale)
} ICDRAW;

typedef struct {
    LPBITMAPINFOHEADER	lpbiIn;		// format to be drawn
    LPBITMAPINFOHEADER	lpbiSuggest;	// location for suggested format (or NULL to get size)
    int			dxSrc;		// source extent or 0
    int			dySrc;
    int			dxDst;		// dest extent or 0
    int			dyDst;
    HIC			hicDecompressor;// decompressor you can talk to
} ICDRAWSUGGEST;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)
    int                 iStart;     // first palette to change
    int                 iLen;       // count of entries to change.
    LPPALETTEENTRY      lppe;       // palette
} ICPALETTE;

// end_vfw32

#ifndef RC_INVOKED
#ifndef WIN32
#pragma pack()          /* Revert to default packing */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_COMPDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\compman.h ===
/*
*  Header file for comunication with AVI installable compressors/decompressors
*
*  Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.
*
* Win16:
*
* Installable compressors should be listed in SYSTEM.INI as
* follows:
*
* [Drivers]
*      VIDC.MSSQ = mssqcomp.drv
*      VIDC.XXXX = foodrv.drv
*
* Win32: (NT)
*
* Installable compressors should be listed in the registration database
* under the key
*   HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Drivers32
*      VIDC.MSSQ = mssqcomp.dll
*      VIDC.XXXX = foodrv.dll
*
*
* That is, an identifying FOURCC should be the key, and the value
* should be the driver filename
*
*/

#ifndef _INC_COMPMAN
#define _INC_COMPMAN

#ifndef RC_INVOKED
#ifndef VFWAPI
#ifdef WIN32
    #define VFWAPI  WINAPI
#ifdef WINAPIV
    #define VFWAPIV WINAPIV
#else
    #define VFWAPIV FAR CDECL
#endif
#else
    #define VFWAPI  FAR PASCAL
    #define VFWAPIV FAR CDECL
#endif
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/************************************************************************

    messages and structures.

************************************************************************/

#if !defined HTASK
    #define HTASK HANDLE
#endif
#include "compddk.h"            // include this file for the messages.

// begin_vfw32

/************************************************************************

    ICM function declarations
	
************************************************************************/

BOOL    VFWAPI ICInfo(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo);
BOOL    VFWAPI ICInstall(DWORD fccType, DWORD fccHandler, LPARAM lParam, LPSTR szDesc, UINT wFlags);
BOOL    VFWAPI ICRemove(DWORD fccType, DWORD fccHandler, UINT wFlags);
LRESULT VFWAPI ICGetInfo(HIC hic, ICINFO FAR *picinfo, DWORD cb);

HIC     VFWAPI ICOpen(DWORD fccType, DWORD fccHandler, UINT wMode);
HIC     VFWAPI ICOpenFunction(DWORD fccType, DWORD fccHandler, UINT wMode, FARPROC lpfnHandler);
LRESULT VFWAPI ICClose(HIC hic);

LRESULT VFWAPI  ICSendMessage(HIC hic, UINT msg, DWORD dw1, DWORD dw2);
#ifndef WIN32
//this function is unsupported on Win32 as it is non-portable.
LRESULT VFWAPIV ICMessage(HIC hic, UINT msg, UINT cb, ...);
#endif


/* Values for wFlags of ICInstall() */
#define ICINSTALL_FUNCTION      0x0001  // lParam is a DriverProc (function ptr)
#define ICINSTALL_DRIVER        0x0002  // lParam is a driver name (string)
#define ICINSTALL_HDRV          0x0004  // lParam is a HDRVR (driver handle)

/************************************************************************

    query macros

************************************************************************/
#define ICMF_CONFIGURE_QUERY     0x00000001
#define ICMF_ABOUT_QUERY         0x00000001

#define ICQueryAbout(hic) \
    (ICSendMessage(hic, ICM_ABOUT, (DWORD) -1, ICMF_ABOUT_QUERY) == ICERR_OK)

#define ICAbout(hic, hwnd) \
    ICSendMessage(hic, ICM_ABOUT, (DWORD)(UINT)(hwnd), 0)

#define ICQueryConfigure(hic) \
    (ICSendMessage(hic, ICM_CONFIGURE, (DWORD) -1, ICMF_CONFIGURE_QUERY) == ICERR_OK)

#define ICConfigure(hic, hwnd) \
    ICSendMessage(hic, ICM_CONFIGURE, (DWORD)(UINT)(hwnd), 0)

/************************************************************************

    get/set state macros
	
************************************************************************/

#define ICGetState(hic, pv, cb) \
    ICSendMessage(hic, ICM_GETSTATE, (DWORD)(LPVOID)(pv), (DWORD)(cb))

#define ICSetState(hic, pv, cb) \
    ICSendMessage(hic, ICM_SETSTATE, (DWORD)(LPVOID)(pv), (DWORD)(cb))

#define ICGetStateSize(hic) \
    ICGetState(hic, NULL, 0)

/************************************************************************

    get value macros

************************************************************************/
static DWORD dwICValue;

#define ICGetDefaultQuality(hic) \
    (ICSendMessage(hic, ICM_GETDEFAULTQUALITY, (DWORD)(LPVOID)&dwICValue, sizeof(DWORD)), dwICValue)

#define ICGetDefaultKeyFrameRate(hic) \
    (ICSendMessage(hic, ICM_GETDEFAULTKEYFRAMERATE, (DWORD)(LPVOID)&dwICValue, sizeof(DWORD)), dwICValue)

/************************************************************************

    draw window macro
	
************************************************************************/
#define ICDrawWindow(hic, prc) \
    ICSendMessage(hic, ICM_DRAW_WINDOW, (DWORD)(LPVOID)(prc), sizeof(RECT))

/************************************************************************

    compression functions

************************************************************************/
/*
 *  ICCompress()
 *
 *  compress a single frame
 *
 */
DWORD VFWAPIV ICCompress(
    HIC                 hic,
    DWORD               dwFlags,        // flags
    LPBITMAPINFOHEADER  lpbiOutput,     // output format
    LPVOID              lpData,         // output data
    LPBITMAPINFOHEADER  lpbiInput,      // format of frame to compress
    LPVOID              lpBits,         // frame data to compress
    LPDWORD             lpckid,         // ckid for data in AVI file
    LPDWORD             lpdwFlags,      // flags in the AVI index.
    LONG                lFrameNum,      // frame number of seq.
    DWORD               dwFrameSize,    // reqested size in bytes. (if non zero)
    DWORD               dwQuality,      // quality within one frame
    LPBITMAPINFOHEADER  lpbiPrev,       // format of previous frame
    LPVOID              lpPrev);        // previous frame

/*
 *  ICCompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICCompressBegin(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_BEGIN, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

/*
 *  ICCompressQuery()
 *
 *  determines if compression from a source format (lpbiInput) to a dest
 *  format (lpbiOuput) is supported.
 *
 */
#define ICCompressQuery(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_QUERY, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

/*
 *  ICCompressGetFormat()
 *
 *  get the output format, (format of compressed data)
 *  if lpbiOutput is NULL return the size in bytes needed for format.
 *
 */
#define ICCompressGetFormat(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_GET_FORMAT, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

#define ICCompressGetFormatSize(hic, lpbi) \
    ICCompressGetFormat(hic, lpbi, NULL)

/*
 *  ICCompressSize()
 *
 *  return the maximal size of a compressed frame
 *
 */
#define ICCompressGetSize(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_COMPRESS_GET_SIZE, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

#define ICCompressEnd(hic) \
    ICSendMessage(hic, ICM_COMPRESS_END, 0, 0)

/************************************************************************

    decompression functions

************************************************************************/

/*
 *  ICDecompress()
 *
 *  decompress a single frame
 *
 */
#define ICDECOMPRESS_HURRYUP    0x80000000L     // don't draw just buffer (hurry up!)

DWORD VFWAPIV ICDecompress(
    HIC                 hic,
    DWORD               dwFlags,    // flags (from AVI index...)
    LPBITMAPINFOHEADER  lpbiFormat, // BITMAPINFO of compressed data
                                    // biSizeImage has the chunk size
    LPVOID              lpData,     // data
    LPBITMAPINFOHEADER  lpbi,       // DIB to decompress to
    LPVOID              lpBits);

/*
 *  ICDecompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
#define ICDecompressBegin(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_BEGIN, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

/*
 *  ICDecompressQuery()
 *
 *  determines if compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
#define ICDecompressQuery(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_QUERY, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

/*
 *  ICDecompressGetFormat()
 *
 *  get the output format, (format of un-compressed data)
 *  if lpbiOutput is NULL return the size in bytes needed for format.
 *
 */
#define ICDecompressGetFormat(hic, lpbiInput, lpbiOutput) \
    ((LONG) ICSendMessage(hic, ICM_DECOMPRESS_GET_FORMAT, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput)))

#define ICDecompressGetFormatSize(hic, lpbi) \
    ICDecompressGetFormat(hic, lpbi, NULL)

/*
 *  ICDecompressGetPalette()
 *
 *  get the output palette
 *
 */
#define ICDecompressGetPalette(hic, lpbiInput, lpbiOutput) \
    ICSendMessage(hic, ICM_DECOMPRESS_GET_PALETTE, (DWORD)(LPVOID)(lpbiInput), (DWORD)(LPVOID)(lpbiOutput))

#define ICDecompressSetPalette(hic, lpbiPalette) \
    ICSendMessage(hic, ICM_DECOMPRESS_SET_PALETTE, (DWORD)(LPVOID)(lpbiPalette), 0)

#define ICDecompressEnd(hic) \
    ICSendMessage(hic, ICM_DECOMPRESS_END, 0, 0)

/************************************************************************

    decompression (ex) functions

************************************************************************/

// end_vfw32

#ifdef WIN32

// begin_vfw32

//
// on Win16 these functions are macros that call ICMessage. ICMessage will
// not work on NT. rather than add new entrypoints we have given
// them as static inline functions
//

/*
 *  ICDecompressEx()
 *
 *  decompress a single frame
 *
 */
static __inline LRESULT VFWAPI
ICDecompressEx(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,
            int ySrc,
            int dxSrc,
            int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,
            int yDst,
            int dxDst,
            int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX, (DWORD)&ic, sizeof(ic));
}


/*
 *  ICDecompressExBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
static __inline LRESULT VFWAPI
ICDecompressExBegin(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,
            int ySrc,
            int dxSrc,
            int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,
            int yDst,
            int dxDst,
            int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX_BEGIN, (DWORD)&ic, sizeof(ic));
}

/*
 *  ICDecompressExQuery()
 *
 */
static __inline LRESULT VFWAPI
ICDecompressExQuery(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,
            int ySrc,
            int dxSrc,
            int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,
            int yDst,
            int dxDst,
            int dyDst)
{
    ICDECOMPRESSEX ic;

    ic.dwFlags = dwFlags;
    ic.lpbiSrc = lpbiSrc;
    ic.lpSrc = lpSrc;
    ic.xSrc = xSrc;
    ic.ySrc = ySrc;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.lpbiDst = lpbiDst;
    ic.lpDst = lpDst;
    ic.xDst = xDst;
    ic.yDst = yDst;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DECOMPRESSEX_QUERY, (DWORD)&ic, sizeof(ic));
}

// end_vfw32

#else

// these macros need to be functions for WIN32 because ICMessage is
// essentially unsupportable on NT

/*
 *  ICDecompressEx()
 *
 *  decompress a single frame
 *
 */
#define ICDecompressEx(hic, dwFlags, lpbiSrc, lpSrc, xSrc, ySrc, dxSrc, dySrc, lpbiDst, lpDst, xDst, yDst, dxDst, dyDst) \
    ICMessage(hic, ICM_DECOMPRESSEX, sizeof(ICDECOMPRESSEX), \
        (DWORD)(dwFlags), \
        (LPBITMAPINFOHEADER)(lpbiSrc), (LPVOID)(lpSrc), \
        (LPBITMAPINFOHEADER)(lpbiDst), (LPVOID)(lpDst), \
        (int)(xDst), (int)(yDst), (int)(dxDst), (int)(dyDst), \
        (int)(xSrc), (int)(ySrc), (int)(dxSrc), (int)(dySrc))

/*
 *  ICDecompressBegin()
 *
 *  start compression from a source format (lpbiInput) to a dest
 *  format (lpbiOutput) is supported.
 *
 */
#define ICDecompressExBegin(hic, dwFlags, lpbiSrc, lpSrc, xSrc, ySrc, dxSrc, dySrc, lpbiDst, lpDst, xDst, yDst, dxDst, dyDst) \
    ICMessage(hic, ICM_DECOMPRESSEX_BEGIN, sizeof(ICDECOMPRESSEX), \
        (DWORD)(dwFlags), \
        (LPBITMAPINFOHEADER)(lpbiSrc), (LPVOID)(lpSrc), \
        (LPBITMAPINFOHEADER)(lpbiDst), (LPVOID)(lpDst), \
        (int)(xDst), (int)(yDst), (int)(dxDst), (int)(dyDst), \
        (int)(xSrc), (int)(ySrc), (int)(dxSrc), (int)(dySrc))

/*
 *  ICDecompressExQuery()
 *
 */
#define ICDecompressExQuery(hic, dwFlags, lpbiSrc, lpSrc, xSrc, ySrc, dxSrc, dySrc, lpbiDst, lpDst, xDst, yDst, dxDst, dyDst) \
    ICMessage(hic, ICM_DECOMPRESSEX_QUERY,  sizeof(ICDECOMPRESSEX), \
        (DWORD)(dwFlags), \
        (LPBITMAPINFOHEADER)(lpbiSrc), (LPVOID)(lpSrc), \
        (LPBITMAPINFOHEADER)(lpbiDst), (LPVOID)(lpDst), \
        (int)(xDst), (int)(yDst), (int)(dxDst), (int)(dyDst), \
        (int)(xSrc), (int)(ySrc), (int)(dxSrc), (int)(dySrc))
#endif

// begin_vfw32

#define ICDecompressExEnd(hic) \
    ICSendMessage(hic, ICM_DECOMPRESSEX_END, 0, 0)

/************************************************************************

    drawing functions

************************************************************************/

/*
 *  ICDrawBegin()
 *
 *  start decompressing data with format (lpbiInput) directly to the screen
 *
 *  return zero if the decompressor supports drawing.
 *
 */

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND

DWORD VFWAPIV ICDrawBegin(
        HIC                 hic,
        DWORD               dwFlags,        // flags
        HPALETTE            hpal,           // palette to draw with
        HWND                hwnd,           // window to draw to
        HDC                 hdc,            // HDC to draw to
        int                 xDst,           // destination rectangle
        int                 yDst,
        int                 dxDst,
        int                 dyDst,
        LPBITMAPINFOHEADER  lpbi,           // format of frame to draw
        int                 xSrc,           // source rectangle
        int                 ySrc,
        int                 dxSrc,
        int                 dySrc,
        DWORD               dwRate,         // frames/second = (dwRate/dwScale)
        DWORD               dwScale);

/*
 *  ICDraw()
 *
 *  decompress data directly to the screen
 *
 */

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen

DWORD VFWAPIV ICDraw(
        HIC                 hic,
        DWORD               dwFlags,        // flags
        LPVOID		    lpFormat,       // format of frame to decompress
        LPVOID              lpData,         // frame data to decompress
        DWORD               cbData,         // size of data
        LONG                lTime);         // time to draw this frame

// end_vfw32

#ifdef WIN32

// begin_vfw32

// ICMessage is not supported on Win32, so provide a static inline function
// to do the same job
static __inline LRESULT VFWAPI
ICDrawSuggestFormat(
            HIC hic,
            LPBITMAPINFOHEADER lpbiIn,
            LPBITMAPINFOHEADER lpbiOut,
            int dxSrc,
            int dySrc,
            int dxDst,
            int dyDst,
            HIC hicDecomp)
{
    ICDRAWSUGGEST ic;

    ic.lpbiIn = lpbiIn;
    ic.lpbiSuggest = lpbiOut;
    ic.dxSrc = dxSrc;
    ic.dySrc = dySrc;
    ic.dxDst = dxDst;
    ic.dyDst = dyDst;
    ic.hicDecompressor = hicDecomp;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_DRAW_SUGGESTFORMAT, (DWORD)&ic, sizeof(ic));
}

// end_vfw32

#else
#define ICDrawSuggestFormat(hic,lpbiIn,lpbiOut,dxSrc,dySrc,dxDst,dyDst,hicDecomp) \
        ICMessage(hic, ICM_DRAW_SUGGESTFORMAT, sizeof(ICDRAWSUGGEST),   \
            (LPBITMAPINFOHEADER)(lpbiIn),(LPBITMAPINFOHEADER)(lpbiOut), \
            (int)(dxSrc),(int)(dySrc),(int)(dxDst),(int)(dyDst), (HIC)(hicDecomp))
#endif

// begin_vfw32

/*
 *  ICDrawQuery()
 *
 *  determines if the compressor is willing to render the specified format.
 *
 */
#define ICDrawQuery(hic, lpbiInput) \
    ICSendMessage(hic, ICM_DRAW_QUERY, (DWORD)(LPVOID)(lpbiInput), 0L)

#define ICDrawChangePalette(hic, lpbiInput) \
    ICSendMessage(hic, ICM_DRAW_CHANGEPALETTE, (DWORD)(LPVOID)(lpbiInput), 0L)

#define ICGetBuffersWanted(hic, lpdwBuffers) \
    ICSendMessage(hic, ICM_GETBUFFERSWANTED, (DWORD)(LPVOID)(lpdwBuffers), 0)

#define ICDrawEnd(hic) \
    ICSendMessage(hic, ICM_DRAW_END, 0, 0)

#define ICDrawStart(hic) \
    ICSendMessage(hic, ICM_DRAW_START, 0, 0)

#define ICDrawStartPlay(hic, lFrom, lTo) \
    ICSendMessage(hic, ICM_DRAW_START_PLAY, (DWORD)(lFrom), (DWORD)(lTo))

#define ICDrawStop(hic) \
    ICSendMessage(hic, ICM_DRAW_STOP, 0, 0)

#define ICDrawStopPlay(hic) \
    ICSendMessage(hic, ICM_DRAW_STOP_PLAY, 0, 0)

#define ICDrawGetTime(hic, lplTime) \
    ICSendMessage(hic, ICM_DRAW_GETTIME, (DWORD)(LPVOID)(lplTime), 0)

#define ICDrawSetTime(hic, lTime) \
    ICSendMessage(hic, ICM_DRAW_SETTIME, (DWORD)lTime, 0)

#define ICDrawRealize(hic, hdc, fBackground) \
    ICSendMessage(hic, ICM_DRAW_REALIZE, (DWORD)(UINT)(HDC)(hdc), (DWORD)(BOOL)(fBackground))

#define ICDrawFlush(hic) \
    ICSendMessage(hic, ICM_DRAW_FLUSH, 0, 0)

#define ICDrawRenderBuffer(hic) \
    ICSendMessage(hic, ICM_DRAW_RENDERBUFFER, 0, 0)

/************************************************************************

    Status callback functions

************************************************************************/

/*
 *  ICSetStatusProc()
 *
 *  Set the status callback function
 *
 */

// end_vfw32

#ifdef WIN32

// begin_vfw32

// ICMessage is not supported on NT
static __inline LRESULT VFWAPI
ICSetStatusProc(
            HIC hic,
            DWORD dwFlags,
            LRESULT lParam,
            LONG (CALLBACK *fpfnStatus)(LPARAM, UINT, LONG) )
{
    ICSETSTATUSPROC ic;

    ic.dwFlags = dwFlags;
    ic.lParam = lParam;
    ic.Status = fpfnStatus;

    // note that ICM swaps round the length and pointer
    // length in lparam2, pointer in lparam1
    return ICSendMessage(hic, ICM_SET_STATUS_PROC, (DWORD)&ic, sizeof(ic));
}

// end_vfw32

#else

#define ICSetStatusProc(hic, dwFlags, lParam, fpfnStatus) \
    ICMessage(hic, ICM_SET_STATUS_PROC, sizeof(ICSETSTATUSPROC), \
        (DWORD)(dwFlags), \
	(LRESULT)(lParam), \
	(LONG ((CALLBACK *) ()))(fpfnStatus))
#endif

// begin_vfw32

/************************************************************************

helper routines for DrawDib and MCIAVI...

************************************************************************/

#define ICDecompressOpen(fccType, fccHandler, lpbiIn, lpbiOut) \
    ICLocate(fccType, fccHandler, lpbiIn, lpbiOut, ICMODE_DECOMPRESS)

#define ICDrawOpen(fccType, fccHandler, lpbiIn) \
    ICLocate(fccType, fccHandler, lpbiIn, NULL, ICMODE_DRAW)

HIC  VFWAPI ICLocate(DWORD fccType, DWORD fccHandler, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, WORD wFlags);
HIC  VFWAPI ICGetDisplayFormat(HIC hic, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, int BitDepth, int dx, int dy);

/************************************************************************
Higher level functions
************************************************************************/

HANDLE VFWAPI ICImageCompress(
        HIC                 hic,        // compressor to use
        UINT                uiFlags,    // flags (none yet)
        LPBITMAPINFO	    lpbiIn,     // format to compress from
        LPVOID              lpBits,     // data to compress
        LPBITMAPINFO        lpbiOut,    // compress to this (NULL ==> default)
        LONG                lQuality,   // quality to use
        LONG FAR *          plSize);     // compress to this size (0=whatever)

HANDLE VFWAPI ICImageDecompress(
        HIC                 hic,        // compressor to use
        UINT                uiFlags,    // flags (none yet)
        LPBITMAPINFO        lpbiIn,     // format to decompress from
        LPVOID              lpBits,     // data to decompress
        LPBITMAPINFO        lpbiOut);   // decompress to this (NULL ==> default)

//
// Structure used by ICSeqCompressFrame and ICCompressorChoose routines
// Make sure this matches the autodoc in icm.c!
//
typedef struct {
    LONG		cbSize;		// set to sizeof(COMPVARS) before
					// calling ICCompressorChoose
    DWORD		dwFlags;	// see below...
    HIC			hic;		// HIC of chosen compressor
    DWORD               fccType;	// basically ICTYPE_VIDEO
    DWORD               fccHandler;	// handler of chosen compressor or
					// "" or "DIB "
    LPBITMAPINFO	lpbiIn;		// input format
    LPBITMAPINFO	lpbiOut;	// output format - will compress to this
    LPVOID		lpBitsOut;
    LPVOID		lpBitsPrev;
    LONG		lFrame;
    LONG		lKey;		// key frames how often?
    LONG		lDataRate;	// desired data rate KB/Sec
    LONG		lQ;		// desired quality
    LONG		lKeyCount;
    LPVOID		lpState;	// state of compressor
    LONG		cbState;	// size of the state
} COMPVARS, FAR *PCOMPVARS;

// FLAGS for dwFlags element of COMPVARS structure:
// set this flag if you initialize COMPVARS before calling ICCompressorChoose
#define ICMF_COMPVARS_VALID	0x00000001	// COMPVARS contains valid data

//
//  allows user to choose compressor, quality etc...
//
BOOL VFWAPI ICCompressorChoose(
        HWND        hwnd,               // parent window for dialog
        UINT        uiFlags,            // flags
        LPVOID      pvIn,               // input format (optional)
        LPVOID      lpData,             // input data (optional)
        PCOMPVARS   pc,                 // data about the compressor/dlg
        LPSTR       lpszTitle);         // dialog title (optional)

// defines for uiFlags
#define ICMF_CHOOSE_KEYFRAME	0x0001	// show KeyFrame Every box
#define ICMF_CHOOSE_DATARATE	0x0002	// show DataRate box
#define ICMF_CHOOSE_PREVIEW	0x0004	// allow expanded preview dialog
#define ICMF_CHOOSE_ALLCOMPRESSORS	0x0008	// don't only show those that
						// can handle the input format
						// or input data

BOOL VFWAPI ICSeqCompressFrameStart(PCOMPVARS pc, LPBITMAPINFO lpbiIn);
void VFWAPI ICSeqCompressFrameEnd(PCOMPVARS pc);

LPVOID VFWAPI ICSeqCompressFrame(
    PCOMPVARS               pc,         // set by ICCompressorChoose
    UINT                    uiFlags,    // flags
    LPVOID                  lpBits,     // input DIB bits
    BOOL FAR 		    *pfKey,	// did it end up being a key frame?
    LONG FAR		    *plSize);	// size to compress to/of returned image

void VFWAPI ICCompressorFree(PCOMPVARS pc);

// end_vfw32

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif /* _INC_COMPMAN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\compobj.h ===
// compobj.h - component object model definitions

#if !defined( _COMPOBJ_H_ )
#define _COMPOBJ_H_


/****** Linkage Definitions *************************************************/

/*
 *      These are macros for declaring methods/functions.  They exist so that
 *      control over the use of keywords (CDECL, PASCAL, __export,
 *      extern "C") resides in one place, and because this is the least
 *      intrusive way of writing function declarations that do not have
 *      to be modified in order to port to the Mac.
 *
 *      The macros without the trailing underscore are for functions/methods
 *      which a return value of type HRESULT; this is by far the most common
 *      case in OLE. The macros with a trailing underscore take a return
 *      type as a parameter.
 *
 * WARNING: STDAPI is hard coded into the LPFNGETCLASSOBJECT typedef below.
 */

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef _MAC
#define STDMETHODCALLTYPE
#define STDAPICALLTYPE          pascal

#define STDAPI                  EXTERN_C STDAPICALLTYPE HRESULT
#define STDAPI_(type)           EXTERN_C STDAPICALLTYPE type

#else   //  !_MAC

#ifdef WIN32
#define STDMETHODCALLTYPE       __export __cdecl
#define STDAPICALLTYPE          __export __stdcall

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#else
#define STDMETHODCALLTYPE       __export FAR CDECL
#define STDAPICALLTYPE          __export FAR PASCAL

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#endif

#endif //!_MAC

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE


/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __TURBOC__
#define interface               struct huge
#else
#define interface               struct FAR
#endif
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface

#else
#define interface               struct

#ifdef _MAC

#define STDMETHOD(method)       long    method##pad;\
                                HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) long    method##pad;\
                                type (STDMETHODCALLTYPE * method)

#else // _MAC

#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)

#endif // !_MAC

#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif


/****** Additional basic types **********************************************/


#ifndef FARSTRUCT
#ifdef __cplusplus
#define FARSTRUCT   FAR
#else
#define FARSTRUCT   
#endif  // __cplusplus
#endif  // FARSTRUCT


#ifndef WINAPI          /* If not included with 3.1 headers... */

#ifdef WIN32
#define FAR
#define PASCAL          __stdcall
#define CDECL
#else
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#endif

#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif

typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int UINT;

typedef long LONG;
typedef unsigned long DWORD;


typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

typedef unsigned int HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name

DECLARE_HANDLE(HMODULE);
DECLARE_HANDLE(HINSTANCE);
DECLARE_HANDLE(HLOCAL);
DECLARE_HANDLE(HGLOBAL);
DECLARE_HANDLE(HDC);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HWND);
DECLARE_HANDLE(HMENU);
DECLARE_HANDLE(HACCEL);
DECLARE_HANDLE(HTASK);

#ifndef NULL
#define NULL 0
#endif


typedef void FAR *      LPVOID;
typedef WORD FAR *      LPWORD;
typedef DWORD FAR *     LPDWORD;
typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;
typedef void FAR*       LPLOGPALETTE;
typedef void FAR*       LPMSG;
//typedef struct tagMSG FAR *LPMSG;

typedef HANDLE FAR *LPHANDLE;
typedef struct tagRECT FAR *LPRECT;

typedef struct FARSTRUCT tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;


#endif  /* WINAPI */


typedef short SHORT;
typedef unsigned short USHORT;
typedef DWORD ULONG;


#ifndef HUGEP
#ifdef WIN32
#define HUGEP
#else
#define HUGEP __huge
#endif // WIN32
#endif // HUGEP

typedef WORD WCHAR;

#ifndef WIN32
typedef struct FARSTRUCT _LARGE_INTEGER {
    DWORD LowPart;
    LONG  HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
#endif
#define LISet32(li, v) ((li).HighPart = ((LONG)(v)) < 0 ? -1 : 0, (li).LowPart = (v))

#ifndef WIN32
typedef struct FARSTRUCT _ULARGE_INTEGER {
    DWORD LowPart;
    DWORD HighPart;
} ULARGE_INTEGER, *PULARGE_INTEGER;
#endif
#define ULISet32(li, v) ((li).HighPart = 0, (li).LowPart = (v))

#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif

#ifdef WIN32
#define HTASK DWORD
#endif

#include "scode.h"



// *********************** Compobj errors **********************************

#define CO_E_NOTINITIALIZED         (CO_E_FIRST + 0x0)
// CoInitialize has not been called and must be

#define CO_E_ALREADYINITIALIZED     (CO_E_FIRST + 0x1)
// CoInitialize has already been called and cannot be called again (temporary)

#define CO_E_CANTDETERMINECLASS     (CO_E_FIRST + 0x2)
// can't determine clsid (e.g., extension not in reg.dat)

#define CO_E_CLASSSTRING            (CO_E_FIRST + 0x3)
// the string form of the clsid is invalid (including ole1 classes)

#define CO_E_IIDSTRING              (CO_E_FIRST + 0x4)
// the string form of the iid is invalid

#define CO_E_APPNOTFOUND            (CO_E_FIRST + 0x5)
// application not found

#define CO_E_APPSINGLEUSE           (CO_E_FIRST + 0x6)
// application cannot be run more than once

#define CO_E_ERRORINAPP             (CO_E_FIRST + 0x7)
// some error in the app program file

#define CO_E_DLLNOTFOUND            (CO_E_FIRST + 0x8)
// dll not found

#define CO_E_ERRORINDLL             (CO_E_FIRST + 0x9)
// some error in the dll file

#define CO_E_WRONGOSFORAPP          (CO_E_FIRST + 0xa)
// app written for other version of OS or other OS altogether

#define CO_E_OBJNOTREG              (CO_E_FIRST + 0xb)
// object is not registered

#define CO_E_OBJISREG               (CO_E_FIRST + 0xc)
// object is already registered

#define CO_E_OBJNOTCONNECTED        (CO_E_FIRST + 0xd)
// handler is not connected to server

#define CO_E_APPDIDNTREG            (CO_E_FIRST + 0xe)
// app was launched, but didn't registered a class factory


// ********************* ClassObject errors ********************************

#define CLASS_E_NOAGGREGATION       (CLASSFACTORY_E_FIRST + 0x0)
// class does not support aggregation (or class object is remote)


// *********************** Reg.dat errors **********************************

#define REGDB_E_READREGDB           (REGDB_E_FIRST + 0x0)
// some error reading the registration database

#define REGDB_E_WRITEREGDB          (REGDB_E_FIRST + 0x1)
// some error reading the registration database

#define REGDB_E_KEYMISSING          (REGDB_E_FIRST + 0x2)
// some error reading the registration database

#define REGDB_E_INVALIDVALUE        (REGDB_E_FIRST + 0x3)
// some error reading the registration database

#define REGDB_E_CLASSNOTREG         (REGDB_E_FIRST + 0x4)
// some error reading the registration database

#define REGDB_E_IIDNOTREG           (REGDB_E_FIRST + 0x5)
// some error reading the registration database


// *************************** RPC errors **********************************

#define RPC_E_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x000)

// call was rejected by callee, either by MF::HandleIncomingCall or
#define RPC_E_CALL_REJECTED             (RPC_E_FIRST + 0x1)         

// call was canceld by call - returned by MessagePending
// this code only occurs if MessagePending return cancel
#define RPC_E_CALL_CANCELED             (RPC_E_FIRST + 0x2)         

// the caller is dispatching an intertask SendMessage call and 
// can NOT call out via PostMessage
#define RPC_E_CANTPOST_INSENDCALL       (RPC_E_FIRST + 0x3)             

// the caller is dispatching an asynchronus call can NOT 
// make an outgoing call on behalf of this call
#define RPC_E_CANTCALLOUT_INASYNCCALL   (RPC_E_FIRST + 0x4)         

// the caller is not in a state where an outgoing call can be made
// this is the case if the caller has an outstandig call and
// another incoming call was excepted by HIC; now the caller is
// not allowed to call out again
#define RPC_E_CANTCALLOUT_INEXTERNALCALL (RPC_E_FIRST + 0x5)                

// the connection terminated or is in a bogus state
// and can not be used any more. Other connections
// are still valid.
#define RPC_E_CONNECTION_TERMINATED     (RPC_E_FIRST + 0x6)         

// the callee (server [not server application]) is not available 
// and disappeared; all connections are invalid
#define RPC_E_SERVER_DIED               (RPC_E_FIRST + 0x7)         

// the caller (client ) disappeared while the callee (server) was 
// processing a call 
#define RPC_E_CLIENT_DIED               (RPC_E_FIRST + 0x8)         

// the date paket with the marshalled parameter data is
// incorrect 
#define RPC_E_INVALID_DATAPACKET        (RPC_E_FIRST + 0x9)         

// the call was not transmitted properly; the message queue 
// was full and was not emptied after yielding
#define RPC_E_CANTTRANSMIT_CALL         (RPC_E_FIRST + 0xa)         

// the client (caller) can not marshall the parameter data 
// or unmarshall the return data - low memory etc.
#define RPC_E_CLIENT_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xb)         
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xc)         

// the server (caller) can not unmarshall the parameter data
// or marshall the return data - low memory
#define RPC_E_SERVER_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xd)         
#define RPC_E_SERVER_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xe)         

// received data are invalid; can be server or 
// client data
#define RPC_E_INVALID_DATA              (RPC_E_FIRST + 0xf)         

// a particular parameter is invalid and can not be un/marshalled
#define RPC_E_INVALID_PARAMETER         (RPC_E_FIRST + 0x10)

// a internal error occured 
#define RPC_E_UNEXPECTED                (RPC_E_FIRST + 0xFFFF)


/****** Globally Unique Ids *************************************************/
 
#ifdef __cplusplus

struct FAR GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];

    BOOL operator==(const GUID& iidOther) const

#ifdef WIN32
        { return !memcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#else        
        { return !_fmemcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#endif
    BOOL operator!=(const GUID& iidOther) const
        { return !((*this) == iidOther); }
};

#else
typedef struct GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];
} GUID;
#endif

typedef                GUID FAR* LPGUID;


// macros to define byte pattern for a GUID.  
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
// Each dll/exe must initialize the GUIDs once.  This is done in one of
// two ways.  If you are not using precompiled headers for the file(s) which
// initializes the GUIDs, define INITGUID before including compobj.h.  This
// is how OLE builds the initialized versions of the GUIDs which are included
// in ole2.lib.  The GUIDs in ole2.lib are all defined in the same text 
// segment GUID_TEXT.
//
// The alternative (which some versions of the compiler don't handle properly;
// they wind up with the initialized GUIDs in a data, not a text segment),
// is to use a precompiled version of compobj.h and then include initguid.h 
// after compobj.h followed by one or more of the guid defintion files.


#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL FAR name

#ifdef INITGUID
#include "initguid.h"
#endif

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


// Interface ID are just a kind of GUID
typedef GUID IID;
typedef                IID FAR* LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)


// Class ID are just a kind of GUID
typedef GUID CLSID;
typedef              CLSID FAR* LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


#if defined(__cplusplus)
#define REFGUID             const GUID FAR&
#define REFIID              const IID FAR&
#define REFCLSID            const CLSID FAR&
#else
#define REFGUID             const GUID FAR* const
#define REFIID              const IID FAR* const
#define REFCLSID            const CLSID FAR* const
#endif


#ifndef INITGUID
#include "coguid.h"
#endif


/****** Other value types ***************************************************/

// memory context values; passed to CoGetMalloc
typedef enum tagMEMCTX
{
    MEMCTX_TASK = 1,            // task (private) memory
    MEMCTX_SHARED = 2,          // shared memory (between processes)
#ifdef _MAC
    MEMCTX_MACSYSTEM = 3,       // on the mac, the system heap
#endif 

    // these are mostly for internal use...
    MEMCTX_UNKNOWN = -1,        // unknown context (when asked about it)
    MEMCTX_SAME = -2,           // same context (as some other pointer)
} MEMCTX;



// class context: used to determine what scope and kind of class object to use
// NOTE: this is a bitwise enum
typedef enum tagCLSCTX
{
    CLSCTX_INPROC_SERVER = 1,   // server dll (runs in same process as caller)
    CLSCTX_INPROC_HANDLER = 2,  // handler dll (runs in same process as caller)
    CLSCTX_LOCAL_SERVER = 4     // server exe (runs on same machine; diff proc)
} CLSCTX;

#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)

#define CLSCTX_INPROC           (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER)


// class registration flags; passed to CoRegisterClassObject
typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,       // class object only generates one instance
    REGCLS_MULTIPLEUSE = 1      // same class object genereates multiple inst.
} REGCLS;


// interface marshaling definitions
#define MARSHALINTERFACE_MIN 40 // minimum number of bytes for interface marshl

// marshaling flags; passed to CoMarshalInterface
typedef enum tagMSHLFLAGS
{
    MSHLFLAGS_NORMAL = 0,       // normal marshaling via proxy/stub
    MSHLFLAGS_TABLESTRONG = 1,  // keep object alive; must explicitly release
    MSHLFLAGS_TABLEWEAK = 2     // doesn't hold object alive; still must release
} MSHLFLAGS;

// marshal context: determines the destination context of the marshal operation
typedef enum tagMSHCTX
{
    MSHCTX_LOCAL = 0,           // unmarshal context is local (eg.shared memory)
    MSHCTX_NOSHAREDMEM = 1,     // unmarshal context has no shared memory access
} MSHCTX;


// call type used by IMessageFilter::HandleIncommingMessage
typedef enum tagCALLTYPE
{
    CALLTYPE_TOPLEVEL = 1,      // toplevel call - no outgoing call 
    CALLTYPE_NESTED   = 2,      // callback on behalf of previous outgoing call - should always handle
    CALLTYPE_ASYNC    = 3,      // aysnchronous call - can NOT be rejected
    CALLTYPE_TOPLEVEL_CALLPENDING = 4,  // new toplevel call with new LID
    CALLTYPE_ASYNC_CALLPENDING    = 5   // async call - can NOT be rejected
} CALLTYPE;

// status of server call - returned by IMessageFilter::HandleIncommingCall
// and passed to  IMessageFilter::RetryRejectedCall
typedef enum tagSERVERCALL
{
    SERVERCALL_ISHANDLED    = 0,
    SERVERCALL_REJECTED     = 1,
    SERVERCALL_RETRYLATER   = 2         
} SERVERCALL;


// Pending type indicates the level of nesting
typedef enum tagPENDINGTYPE
{   
    PENDINGTYPE_TOPLEVEL = 1,       // toplevel call
    PENDINGTYPE_NESTED   = 2,       // nested call
} PENDINGTYPE;

// return values of MessagePending
typedef enum tagPENDINGMSG
{   
    PENDINGMSG_CANCELCALL  = 0, // cancel the outgoing call
    PENDINGMSG_WAITNOPROCESS  = 1, // wait for the return and don't dispatch the message
    PENDINGMSG_WAITDEFPROCESS = 2  // wait and dispatch the message 
    
} PENDINGMSG;


/****** IUnknown Interface **************************************************/


#undef  INTERFACE
#define INTERFACE   IUnknown

DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
};
typedef        IUnknown FAR* LPUNKNOWN;


/****** Class Factory Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IClassFactory

DECLARE_INTERFACE_(IClassFactory, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_ LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject) PURE;
    STDMETHOD(LockServer) (THIS_ BOOL fLock) PURE;

};
typedef       IClassFactory FAR* LPCLASSFACTORY;


/****** Memory Allocation Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IMalloc

DECLARE_INTERFACE_(IMalloc, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMalloc methods ***
    STDMETHOD_(void FAR*, Alloc) (THIS_ ULONG cb) PURE;
    STDMETHOD_(void FAR*, Realloc) (THIS_ void FAR* pv, ULONG cb) PURE;
    STDMETHOD_(void, Free) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(ULONG, GetSize) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(int, DidAlloc) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(void, HeapMinimize) (THIS) PURE;
};
typedef       IMalloc FAR* LPMALLOC;


/****** IMarshal Interface ************************************************/

// forward declaration for IStream; must include storage.h later to use
#ifdef __cplusplus
interface IStream;
#else
typedef interface IStream IStream;
#endif
typedef         IStream FAR* LPSTREAM;


#undef  INTERFACE
#define INTERFACE   IMarshal

DECLARE_INTERFACE_(IMarshal, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMarshal methods ***
    STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPCLSID pCid) PURE;
    STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPDWORD pSize) PURE;
    STDMETHOD(MarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags) PURE;
    STDMETHOD(UnmarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID FAR* ppv) PURE;
    STDMETHOD(ReleaseMarshalData)(THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved) PURE;
};
typedef         IMarshal FAR* LPMARSHAL;


#undef  INTERFACE
#define INTERFACE   IStdMarshalInfo

DECLARE_INTERFACE_(IStdMarshalInfo, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStdMarshalInfo methods ***
    STDMETHOD(GetClassForHandler)(THIS_ DWORD dwDestContext, 
                        LPVOID pvDestContext, LPCLSID pClsid) PURE;
};
typedef         IStdMarshalInfo FAR* LPSTDMARSHALINFO;


/****** Message Filter Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IMessageFilter

DECLARE_INTERFACE_(IMessageFilter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMessageFilter methods ***
    STDMETHOD_(DWORD, HandleInComingCall) (THIS_ DWORD dwCallType,
                                HTASK htaskCaller, DWORD dwTickCount,
                                DWORD dwReserved ) PURE;
    STDMETHOD_(DWORD, RetryRejectedCall) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount,
                                DWORD dwRejectType ) PURE;
    STDMETHOD_(DWORD, MessagePending) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount, 
                                DWORD dwPendingType  ) PURE; 
};
typedef       IMessageFilter FAR* LPMESSAGEFILTER;


/****** Enumerator Interfaces *********************************************/

/*
 *  Since we don't use parametrized types, we put in explicit declarations
 *  of the enumerators we need.
 */


#undef  INTERFACE
#define INTERFACE   IEnumString

DECLARE_INTERFACE_(IEnumString, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumString methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, 
                       LPSTR FAR* rgelt, 
                       ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumString FAR* FAR* ppenm) PURE;
};
typedef      IEnumString FAR* LPENUMSTRING;


#undef  INTERFACE
#define INTERFACE   IEnumUnknown

DECLARE_INTERFACE_(IEnumUnknown, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumUnknown methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPUNKNOWN FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumUnknown FAR* FAR* ppenm) PURE;
};
typedef         IEnumUnknown FAR* LPENUMUNKNOWN;


/****** STD Object API Prototypes *****************************************/

STDAPI_(DWORD) CoBuildVersion( VOID );

/* init/uninit */

STDAPI  CoInitialize(LPMALLOC pMalloc);
STDAPI_(void)  CoUninitialize(void);
STDAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
STDAPI_(DWORD) CoGetCurrentProcess(void);


/* register/revoke/get class objects */

STDAPI  CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                    REFIID riid, LPVOID FAR* ppv);
STDAPI  CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);
STDAPI  CoRevokeClassObject(DWORD dwRegister);


/* marshaling interface pointers */

STDAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
STDAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv);
STDAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);
STDAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult);
STDAPI CoReleaseMarshalData(LPSTREAM pStm);
STDAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);
STDAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);
STDAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk, 
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
                    LPMARSHAL FAR* ppMarshal);


/* dll loading helpers; keeps track of ref counts and unloads all on exit */

STDAPI_(HINSTANCE) CoLoadLibrary(LPSTR lpszLibName, BOOL bAutoFree);
STDAPI_(void) CoFreeLibrary(HINSTANCE hInst);
STDAPI_(void) CoFreeAllLibraries(void);
STDAPI_(void) CoFreeUnusedLibraries(void);


/* helper for creating instances */

STDAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);


/* other helpers */

STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2);
STDAPI StringFromCLSID(REFCLSID rclsid, LPSTR FAR* lplpsz);
STDAPI CLSIDFromString(LPSTR lpsz, LPCLSID pclsid);
STDAPI StringFromIID(REFIID rclsid, LPSTR FAR* lplpsz);
STDAPI IIDFromString(LPSTR lpsz, LPIID lpiid);
STDAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid);
STDAPI ProgIDFromCLSID (REFCLSID clsid, LPSTR FAR* lplpszProgID);
STDAPI CLSIDFromProgID (LPCSTR lpszProgID, LPCLSID lpclsid);


STDAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
STDAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime);
STDAPI  CoFileTimeNow( FILETIME FAR* lpFileTime );


STDAPI CoRegisterMessageFilter( LPMESSAGEFILTER lpMessageFilter,
                                LPMESSAGEFILTER FAR* lplpMessageFilter );


/* TreatAs APIS */

STDAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);


/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
 * to match these; the typedefs are located here to ensure all are changed at 
 * the same time.
 */

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#endif


STDAPI  DllCanUnloadNow(void);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNCANUNLOADNOW)(void);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNCANUNLOADNOW)(void);
#endif


/****** Debugging Helpers *************************************************/

#ifdef _DEBUG
// writes to the debug port and displays a message box
STDAPI FnAssert(LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine);
#endif  //  _DEBUG

#endif // _COMPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\comdev.h ===
/*****************************************************************************\
*                                                                             *
* comdev.h -
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1994, Microsoft Corp.	All rights reserved.		      *
*                                                                             *
\*****************************************************************************/


/*************************************************************************
**
** Miscelaneous definitions.
*/
typedef unsigned short ushort;
typedef unsigned char uchar;

#define NULL    0
#define FALSE   0
#define TRUE    1

#define LPTx    0x80        /* Mask to indicate cid is for LPT device   */  /*081985*/
#define LPTxMask 0x7F       /* Mask to get      cid    for LPT device   */  /*081985*/

#define PIOMAX  3           /* Max number of LPTx devices in high level */  /*081985*/
#define CDEVMAX 10          /* Max number of COMx devices in high level */
#define DEVMAX  13          /* Max number of devices in high level      */  /*081985*/

/*************************************************************************
**
** Extended Functions
**
** SETXOFF      - Causes transmit to behave as if an X-OFF character had
**                been received. Valid only if transmit X-ON/X-OFF specified
**                in the dcb.
** SETXON       - Causes transmit to behave as if an X-ON character had
**                been received. Valid only if transmit X-ON/X-OFF specified
**                in the dcb.
*************************************************************************/
#define SETXOFF         1               /* Set X-Off for output control */
#define SETXON          2               /* Set X-ON for output control  */
#define SETRTS          3               /* Set RTS high                 */
#define CLRRTS          4               /* Set RTS low                  */
#define SETDTR          5               /* Set DTR high                 */
#define CLRDTR          6               /* Set DTR low                  */
#define RESETDEV        7               /* Reset device if possible     */  /*081985*/


/*=========================================================================
;
;       qdb
;       Queue definition block. Passed to setqueue, defines the location and
;       size of the transmit and receive circular queue's used for interrupt
;       transmit and recieve processing.
;
;=========================================================================*/

typedef struct tagQDB
	{
	char _far *QueueRxAddr;								//Pointer to RX Queue, Offset
	unsigned	QueueRxSize;								//Size of RX Queue in bytes
	char _far *QueueTxAddr;								//Pointer to TX Queue, Offset
	unsigned	QueueTxSize;								//Size of TX Queue in bytes
	} QDB;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\commdlg.h ===
/*****************************************************************************\
*                                                                             *
* commdlg.h -   Common dialog functions, types, and definitions               *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* NOTE: windows.h must be #included first				      *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//---------------------------------------------------------------------------
typedef struct tagOFN
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HINSTANCE hInstance;
    LPCSTR  lpstrFilter;
    LPSTR   lpstrCustomFilter;
    DWORD   nMaxCustFilter;
    DWORD   nFilterIndex;
    LPSTR   lpstrFile;
    DWORD   nMaxFile;
    LPSTR   lpstrFileTitle;
    DWORD   nMaxFileTitle;
    LPCSTR  lpstrInitialDir;
    LPCSTR  lpstrTitle;
    DWORD   Flags;
    UINT    nFileOffset;
    UINT    nFileExtension;
    LPCSTR  lpstrDefExt;
    LPARAM  lCustData;
    UINT    (CALLBACK *lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
}   OPENFILENAME;
typedef OPENFILENAME FAR* LPOPENFILENAME;

BOOL    WINAPI GetOpenFileName(OPENFILENAME FAR*);
BOOL    WINAPI GetSaveFileName(OPENFILENAME FAR*);
int     WINAPI GetFileTitle(LPCSTR, LPSTR, UINT);

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000
#define OFN_NONETWORKBUTTON          0x00020000
#define OFN_NOLONGNAMES              0x00040000		// force no long names for 4.x modules
#if (WINVER >= 0x400)
#define OFN_EXPLORER                 0x00080000
#define OFN_NODEREFERENCELINKS       0x00100000
#define OFN_LONGNAMES		     0x00200000		// force long names for 3.x modules
#endif  /* WINVER >= 0x400 */

/* Return values for the registered message sent to the hook function
 * when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
 * filename to be accepted, OFN_SHARENOWARN rejects the name but puts
 * up no warning (returned when the app has already put up a warning
 * message), and OFN_SHAREWARN puts up the default warning message
 * for sharing violations.
 *
 * Note:  Undefined return values map to OFN_SHAREWARN, but are
 *        reserved for future use.
 */

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

//---------------------------------------------------------------------------
typedef struct tagCHOOSECOLOR
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HINSTANCE hInstance;
    COLORREF rgbResult;
    COLORREF FAR* lpCustColors;
    DWORD   Flags;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
} CHOOSECOLOR;
typedef CHOOSECOLOR FAR *LPCHOOSECOLOR;

BOOL    WINAPI ChooseColor(CHOOSECOLOR FAR*);

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040
//// reserved                    0x?0000000

//---------------------------------------------------------------------------
typedef struct tagFINDREPLACE
{
    DWORD    lStructSize;            /* size of this struct 0x20 */
    HWND     hwndOwner;              /* handle to owner's window */
    HINSTANCE hInstance;             /* instance handle of.EXE that
                                      * contains cust. dlg. template
                                      */
    DWORD    Flags;                  /* one or more of the FR_?? */
    LPSTR    lpstrFindWhat;          /* ptr. to search string    */
    LPSTR    lpstrReplaceWith;       /* ptr. to replace string   */
    UINT     wFindWhatLen;           /* size of find buffer      */
    UINT     wReplaceWithLen;        /* size of replace buffer   */
    LPARAM   lCustData;              /* data passed to hook fn.  */
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
                                     /* ptr. to hook fn. or NULL */
    LPCSTR   lpTemplateName;         /* custom template name     */
} FINDREPLACE;
typedef FINDREPLACE FAR *LPFINDREPLACE;

#define FR_DOWN                         0x00000001
#define FR_WHOLEWORD                    0x00000002
#define FR_MATCHCASE                    0x00000004
#define FR_FINDNEXT                     0x00000008
#define FR_REPLACE                      0x00000010
#define FR_REPLACEALL                   0x00000020
#define FR_DIALOGTERM                   0x00000040
#define FR_SHOWHELP                     0x00000080
#define FR_ENABLEHOOK                   0x00000100
#define FR_ENABLETEMPLATE               0x00000200
#define FR_NOUPDOWN                     0x00000400
#define FR_NOMATCHCASE                  0x00000800
#define FR_NOWHOLEWORD                  0x00001000
#define FR_ENABLETEMPLATEHANDLE         0x00002000
#define FR_HIDEUPDOWN                   0x00004000
#define FR_HIDEMATCHCASE                0x00008000
#define FR_HIDEWHOLEWORD                0x00010000
/// 0x?0000000 is reserved for internal use


HWND    WINAPI FindText(FINDREPLACE FAR*);
HWND    WINAPI ReplaceText(FINDREPLACE FAR*);

//---------------------------------------------------------------------------
typedef struct tagCHOOSEFONT
{
    DWORD           lStructSize;        /* */
    HWND            hwndOwner;          /* caller's window handle   */
    HDC             hDC;                /* printer DC/IC or NULL    */
    LOGFONT FAR*    lpLogFont;          /* ptr. to a LOGFONT struct */
    int             iPointSize;         /* 10 * size in points of selected font */
    DWORD           Flags;              /* enum. type flags         */
    COLORREF        rgbColors;          /* returned text color      */
    LPARAM          lCustData;          /* data passed to hook fn.  */
    UINT (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
                                        /* ptr. to hook function    */
    LPCSTR          lpTemplateName;     /* custom template name     */
    HINSTANCE       hInstance;          /* instance handle of.EXE that
                                         * contains cust. dlg. template
                                         */
    LPSTR           lpszStyle;          /* return the style field here
                                         * must be LF_FACESIZE or bigger */
    UINT            nFontType;          /* same value reported to the EnumFonts
                                         * call back with the extra FONTTYPE_
                                         * bits added */
    int             nSizeMin;           /* minimum pt size allowed & */
    int             nSizeMax;           /* max pt size allowed if    */
                                        /* CF_LIMITSIZE is used      */
} CHOOSEFONT;
typedef CHOOSEFONT FAR *LPCHOOSEFONT;

BOOL WINAPI ChooseFont(CHOOSEFONT FAR*);

#define CF_SCREENFONTS               0x00000001
#define CF_PRINTERFONTS              0x00000002
#define CF_BOTH                      (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP                  0x00000004L
#define CF_ENABLEHOOK                0x00000008L
#define CF_ENABLETEMPLATE            0x00000010L
#define CF_ENABLETEMPLATEHANDLE      0x00000020L
#define CF_INITTOLOGFONTSTRUCT       0x00000040L
#define CF_USESTYLE                  0x00000080L
#define CF_EFFECTS                   0x00000100L
#define CF_APPLY                     0x00000200L
#define CF_ANSIONLY                  0x00000400L
#define CF_NOVECTORFONTS             0x00000800L
#define CF_NOOEMFONTS                CF_NOVECTORFONTS
#define CF_NOSIMULATIONS             0x00001000L
#define CF_LIMITSIZE                 0x00002000L
#define CF_FIXEDPITCHONLY            0x00004000L
#define CF_WYSIWYG                   0x00008000L /* must also have CF_SCREENFONTS & CF_PRINTERFONTS */
#define CF_FORCEFONTEXIST            0x00010000L
#define CF_SCALABLEONLY              0x00020000L
#define CF_TTONLY                    0x00040000L
#define CF_NOFACESEL                 0x00080000L
#define CF_NOSTYLESEL                0x00100000L
#define CF_NOSIZESEL                 0x00200000L
/////  reserved for internal use     0x?0000000L

/* these are extra nFontType bits that are added to what is returned to the
 * EnumFonts callback routine */

#define SIMULATED_FONTTYPE      0x8000
#define PRINTER_FONTTYPE        0x4000
#define SCREEN_FONTTYPE         0x2000
#define BOLD_FONTTYPE           0x0100
#define ITALIC_FONTTYPE         0x0200
#define REGULAR_FONTTYPE        0x0400

#define WM_CHOOSEFONT_GETLOGFONT        (WM_USER + 1)


/* strings used to obtain unique window message for communication
 * between dialog and caller
 */
#define LBSELCHSTRING  "commdlg_LBSelChangedNotify"
#define SHAREVISTRING  "commdlg_ShareViolation"
#define FILEOKSTRING   "commdlg_FileNameOK"
#define COLOROKSTRING  "commdlg_ColorOK"
#define SETRGBSTRING   "commdlg_SetRGBColor"
#define FINDMSGSTRING  "commdlg_FindReplace"
#define HELPMSGSTRING  "commdlg_help"

/* HIWORD values for lParam of commdlg_LBSelChangeNotify message */
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

//---------------------------------------------------------------------------
typedef struct tagPD
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HGLOBAL hDevMode;
    HGLOBAL hDevNames;
    HDC     hDC;
    DWORD   Flags;
    UINT    nFromPage;
    UINT    nToPage;
    UINT    nMinPage;
    UINT    nMaxPage;
    UINT    nCopies;
    HINSTANCE hInstance;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnPrintHook)(HWND, UINT, WPARAM, LPARAM);
    UINT    (CALLBACK* lpfnSetupHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpPrintTemplateName;
    LPCSTR  lpSetupTemplateName;
    HGLOBAL hPrintTemplate;
    HGLOBAL hSetupTemplate;
} PRINTDLG;
typedef PRINTDLG  FAR* LPPRINTDLG;

BOOL    WINAPI PrintDlg(PRINTDLG FAR*);

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000
#define PD_NONETWORKBUTTON           0x00200000
////  reserved                       0x?0000000

typedef struct tagDEVNAMES
{
    UINT wDriverOffset;
    UINT wDeviceOffset;
    UINT wOutputOffset;
    UINT wDefault;
} DEVNAMES;
typedef DEVNAMES FAR* LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD   WINAPI CommDlgExtendedError(void);

//---------------------------------------------------------------------------
#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   the MS C V2.03 compatible console and port I/O routines.
*
****/

#ifndef _INC_CONIO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

/* function prototypes */

#ifndef _WINDOWS
char * __cdecl _cgets(char *);
int __cdecl _cprintf(const char *, ...);
int __cdecl _cputs(const char *);
int __cdecl _cscanf(const char *, ...);
int __cdecl _getch(void);
int __cdecl _getche(void);
#endif 
int __cdecl _inp(unsigned);
unsigned __cdecl _inpw(unsigned);
#ifndef _WINDOWS
int __cdecl _kbhit(void);
#endif 
int __cdecl _outp(unsigned, int);
unsigned __cdecl _outpw(unsigned, unsigned);
#ifndef _WINDOWS
int __cdecl _putch(int);
int __cdecl _ungetch(int);
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#ifndef _WINDOWS
char * __cdecl cgets(char *);
int __cdecl cprintf(const char *, ...);
int __cdecl cputs(const char *);
int __cdecl cscanf(const char *, ...);
int __cdecl getch(void);
int __cdecl getche(void);
#endif 
int __cdecl inp(unsigned);
unsigned __cdecl inpw(unsigned);
#ifndef _WINDOWS
int __cdecl kbhit(void);
#endif 
int __cdecl outp(unsigned, int);
unsigned __cdecl outpw(unsigned, unsigned);
#ifndef _WINDOWS
int __cdecl putch(int);
int __cdecl ungetch(int);
#endif 
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_CONIO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\cpl.h ===
/*****************************************************************************\
*                                                                             *
* cpl.h -       Control panel extension DLL definitions                       *
*                                                                             *
* Version 3.10								      *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved	      *
*                                                                             *
******************************************************************************
*  General rules for being installed in the Control Panel:
*
*      1) The DLL must export a function named CPlApplet which will handle
*         the messages discussed below.
*      2) If the applet needs to save information in CONTROL.INI minimize
*         clutter by using the application name [MMCPL.appletname].
*      2) If the applet is refrenced in CONTROL.INI under [MMCPL] use
*         the following form:
*              ...
*              [MMCPL]
*              uniqueName=c:\mydir\myapplet.dll
*              ...
*
*
*  The order applet DLL's are loaded by CONTROL.EXE is:
*
*      1) MAIN.CPL is loaded from the windows system directory.
*
*      2) Installable drivers that are loaded and export the
*         CplApplet() routine.
*
*      3) DLL's specified in the [MMCPL] section of CONTROL.INI.
*
*      4) DLL's named *.CPL from windows system directory.
*
*/
#ifndef _INC_CPL
#define _INC_CPL

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * CONTROL.EXE will answer this message and launch an applet
 *
 * WM_CPL_LAUNCH
 *
 *      wParam      - window handle of calling app
 *      lParam      - LPSTR of name of applet to launch
 *
 * WM_CPL_LAUNCHED
 *
 *      wParam      - TRUE/FALSE if applet was launched
 *      lParam      - NULL
 *
 * CONTROL.EXE will post this message to the caller when the applet returns
 * (ie., when wParam is a valid window handle)
 *
 */
#define WM_CPL_LAUNCH   (WM_USER+1000)
#define WM_CPL_LAUNCHED (WM_USER+1001)

/* A function prototype for CPlApplet() */

typedef LRESULT (CALLBACK *APPLET_PROC)(HWND hwndCpl, UINT msg, LPARAM lParam1, LPARAM lParam2);

/* The data structure CPlApplet() must fill in. */

typedef struct tagCPLINFO
{
    int     idIcon;     /* icon resource id, provided by CPlApplet() */
    int     idName;     /* name string res. id, provided by CPlApplet() */
    int     idInfo;     /* info string res. id, provided by CPlApplet() */
    LONG    lData;      /* user defined data */
} CPLINFO, *PCPLINFO, FAR *LPCPLINFO;

typedef struct tagNEWCPLINFO
{
    DWORD       dwSize;         /* similar to the commdlg */
    DWORD	dwFlags;
    DWORD       dwHelpContext;  /* help context to use */
    LONG        lData;          /* user defined data */
    HICON       hIcon;          /* icon to use, this is owned by CONTROL.EXE (may be deleted) */
    char        szName[32];     /* short name */
    char        szInfo[64];     /* long name (status line) */
    char        szHelpFile[128];/* path to help file to use */
} NEWCPLINFO, *PNEWCPLINFO, FAR *LPNEWCPLINFO;


/* The messages CPlApplet() must handle: */

#define CPL_INIT        1
/*  This message is sent to indicate CPlApplet() was found. */
/*  lParam1 and lParam2 are not defined. */
/*  Return TRUE or FALSE indicating whether the control panel should proceed. */


#define CPL_GETCOUNT    2
/*  This message is sent to determine the number of applets to be displayed. */
/*  lParam1 and lParam2 are not defined. */
/*  Return the number of applets you wish to display in the control */
/*  panel window. */


#define CPL_INQUIRE     3
/*  This message is sent for information about each applet. */
/*  lParam1 is the applet number to register, a value from 0 to */
/*  (CPL_GETCOUNT - 1).  lParam2 is a far ptr to a CPLINFO structure. */
/*  Fill in CPL_INFO's idIcon, idName, idInfo and lData fields with */
/*  the resource id for an icon to display, name and description string ids, */
/*  and a long data item associated with applet #lParam1. */


#define CPL_SELECT      4
/*  This message is sent when the applet's icon has been clicked upon. */
/*  lParam1 is the applet number which was selected.  lParam2 is the */
/*  applet's lData value. */


#define CPL_DBLCLK      5
/*  This message is sent when the applet's icon has been double-clicked */
/*  upon.  lParam1 is the applet number which was selected.  lParam2 is the */
/*  applet's lData value. */
/*  This message should initiate the applet's dialog box. */


#define CPL_STOP        6
/*  This message is sent for each applet when the control panel is exiting. */
/*  lParam1 is the applet number.  lParam2 is the applet's lData  value. */
/*  Do applet specific cleaning up here. */


#define CPL_EXIT        7
/*  This message is sent just before the control panel calls FreeLibrary. */
/*  lParam1 and lParam2 are not defined. */
/*  Do non-applet specific cleaning up here. */


#define CPL_NEWINQUIRE	8
/* this is the same as CPL_INQUIRE execpt lParam2 is a pointer to a */
/* NEWCPLINFO structure.  this will be sent before the CPL_INQUIRE */
/* and if it is responed to (return != 0) CPL_INQUIRE will not be sent */


#define CPL_STARTWPARMS 9
/* this message parallels CPL_DBLCLK in that the applet should initiate 
** its dialog box.  where it differs is that this invocation is coming
** out of RUNDLL, and there may be some extra directions for execution.
** lParam1: the applet number.
** lParam2: an LPSTR to any extra directions that might exist.
** returns: TRUE if the message was handled; FALSE if not.
*/



#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_CPL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines macros for character classification/conversion.
*   [ANSI/System V]
*
****/

#ifndef _INC_CTYPE

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

extern unsigned char __near __cdecl _ctype[];

/* set bit masks for the possible character types */

#define _UPPER      0x1 /* upper case letter */
#define _LOWER      0x2 /* lower case letter */
#define _DIGIT      0x4 /* digit[0-9] */
#define _SPACE      0x8 /* tab, carriage return, newline, */
                /* vertical tab or form feed */
#define _PUNCT      0x10    /* punctuation character */
#define _CONTROL    0x20    /* control character */
#define _BLANK      0x40    /* space char */
#define _HEX        0x80    /* hexadecimal digit */

/* character classification function prototypes */

#ifndef _CTYPE_DEFINED
int __cdecl isalpha(int);
int __cdecl isupper(int);
int __cdecl islower(int);
int __cdecl isdigit(int);
int __cdecl isxdigit(int);
int __cdecl isspace(int);
int __cdecl ispunct(int);
int __cdecl isalnum(int);
int __cdecl isprint(int);
int __cdecl isgraph(int);
int __cdecl iscntrl(int);
int __cdecl toupper(int);
int __cdecl tolower(int);
int __cdecl _tolower(int);
int __cdecl _toupper(int);
int __cdecl __isascii(int);
int __cdecl __toascii(int);
int __cdecl __iscsymf(int);
int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif 

#ifdef _INTL
int __cdecl __isleadbyte(int);
#endif 

/* the character classification macro definitions */

#define isalpha(_c) ( (_ctype+1)[_c] & (_UPPER|_LOWER) )
#define isupper(_c) ( (_ctype+1)[_c] & _UPPER )
#define islower(_c) ( (_ctype+1)[_c] & _LOWER )
#define isdigit(_c) ( (_ctype+1)[_c] & _DIGIT )
#define isxdigit(_c)    ( (_ctype+1)[_c] & _HEX )
#define isspace(_c) ( (_ctype+1)[_c] & _SPACE )
#define ispunct(_c) ( (_ctype+1)[_c] & _PUNCT )
#define isalnum(_c) ( (_ctype+1)[_c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(_c) ( (_ctype+1)[_c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(_c) ( (_ctype+1)[_c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(_c) ( (_ctype+1)[_c] & _CONTROL )
#ifndef __STDC__
#define toupper(_c) ( (islower(_c)) ? _toupper(_c) : (_c) )
#define tolower(_c) ( (isupper(_c)) ? _tolower(_c) : (_c) )
#endif 
#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )
#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef isleadbyte
#ifdef _INTL
#define isleadbyte(_c)  __isleadbyte(_c)
#else 
#define isleadbyte(_c)  (0)
#endif 
#endif 

/* extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#ifndef _CTYPE_DEFINED
int __cdecl isascii(int);
int __cdecl toascii(int);
int __cdecl iscsymf(int);
int __cdecl iscsym(int);
#else 
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif 
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_CTYPE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\ddeml.h ===
/*****************************************************************************\
*                                                                             *
*  ddeml.h -    DDEML API header file                                         *
*                                                                             *
*  Version 1.0								      *
*                                                                             *
*  Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/
#ifndef _INC_DDEML
#define _INC_DDEML

#ifndef RC_INVOKED
#pragma pack(1)
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {                /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef _INC_WINDOWS    /* If not included with 3.1 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifndef DECLARE_HANDLE32
#ifdef STRICT
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ _far* name
#else   /* STRICT */
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */
#endif  /* !DECLARE_HANDLE32 */

#define EXPENTRY    WINAPI

/******** public types ********/

DECLARE_HANDLE32(HCONVLIST);
DECLARE_HANDLE32(HCONV);
DECLARE_HANDLE32(HSZ);
DECLARE_HANDLE32(HDDEDATA);

/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR
{
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR;
typedef HSZPAIR FAR *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT
{
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */
    UINT        wFlags;         /* none currently defined. */
    UINT        wCountryID;     /* country code for topic/item strings used. */
    int         iCodePage;      /* codepage used for topic/item strings. */
    DWORD       dwLangID;       /* language ID for topic/item strings. */
    DWORD       dwSecurity;     /* Private security code. */
} CONVCONTEXT;
typedef CONVCONTEXT FAR *PCONVCONTEXT;

/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO
{
    DWORD   cb;            /* sizeof(CONVINFO)  */
    DWORD   hUser;         /* user specified field  */
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */
    HSZ     hszServiceReq; /* AppName requested for connection  */
    HSZ     hszTopic;      /* Topic name for conversation  */
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */
    UINT    wFmt;          /* transaction format or NULL if quiescent  */
    UINT    wType;         /* XTYP_ for current transaction  */
    UINT    wStatus;       /* ST_ constant for current conversation  */
    UINT    wConvst;       /* XST_ constant for current transaction  */
    UINT    wLastError;    /* last transaction error.  */
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */
    CONVCONTEXT ConvCtxt;  /* conversation context */
    HWND    hwnd;          /* window handle for this conversation */
    HWND    hwndPartner;   /* partner window handle for this conversation */
} CONVINFO;
typedef CONVINFO FAR *PCONVINFO;

/***** conversation states (usState) *****/

#define     XST_NULL              0  /* quiescent states */
#define     XST_INCOMPLETE        1
#define     XST_CONNECTED         2
#define     XST_INIT1             3  /* mid-initiation states */
#define     XST_INIT2             4
#define     XST_REQSENT           5  /* active conversation states */
#define     XST_DATARCVD          6
#define     XST_POKESENT          7
#define     XST_POKEACKRCVD       8
#define     XST_EXECSENT          9
#define     XST_EXECACKRCVD      10
#define     XST_ADVSENT          11
#define     XST_UNADVSENT        12
#define     XST_ADVACKRCVD       13
#define     XST_UNADVACKRCVD     14
#define     XST_ADVDATASENT      15
#define     XST_ADVDATAACKRCVD   16

/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */
#define     CADV_LATEACK         0xFFFF

/***** conversation status bits (fsStatus) *****/

#define     ST_CONNECTED        0x0001
#define     ST_ADVISE           0x0002
#define     ST_ISLOCAL          0x0004
#define     ST_BLOCKED          0x0008
#define     ST_CLIENT           0x0010
#define     ST_TERMINATED       0x0020
#define     ST_INLIST           0x0040
#define     ST_BLOCKNEXT        0x0080
#define     ST_ISSELF           0x0100

/* DDE constants for wStatus field */

#define DDE_FACK	  	0x8000
#define DDE_FBUSY	  	0x4000
#define DDE_FDEFERUPD		0x4000
#define DDE_FACKREQ	        0x8000
#define DDE_FRELEASE  		0x2000
#define DDE_FREQUESTED		0x1000
#define DDE_FACKRESERVED	0x3ff0
#define DDE_FADVRESERVED	0x3fff
#define DDE_FDATRESERVED	0x4fff
#define DDE_FPOKRESERVED	0xdfff
#define DDE_FAPPSTATUS		0x00ff
#define DDE_FNOTPROCESSED   0x0000

/***** message filter hook types *****/

#define     MSGF_DDEMGR             0x8001

/***** codepage constants ****/

#define CP_WINANSI      1004    /* default codepage for windows & old DDE convs. */

/***** transaction types *****/

#define     XTYPF_NOBLOCK            0x0002  /* CBR_BLOCK will not work */
#define     XTYPF_NODATA             0x0004  /* DDE_FDEFERUPD */
#define     XTYPF_ACKREQ             0x0008  /* DDE_FACKREQ */

#define     XCLASS_MASK              0xFC00
#define     XCLASS_BOOL              0x1000
#define     XCLASS_DATA              0x2000
#define     XCLASS_FLAGS             0x4000
#define     XCLASS_NOTIFICATION      0x8000

#define     XTYP_ERROR              (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK )
#define     XTYP_ADVDATA            (0x0010 | XCLASS_FLAGS         )
#define     XTYP_ADVREQ             (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK )
#define     XTYP_ADVSTART           (0x0030 | XCLASS_BOOL          )
#define     XTYP_ADVSTOP            (0x0040 | XCLASS_NOTIFICATION)
#define     XTYP_EXECUTE            (0x0050 | XCLASS_FLAGS         )
#define     XTYP_CONNECT            (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)
#define     XTYP_CONNECT_CONFIRM    (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_XACT_COMPLETE      (0x0080 | XCLASS_NOTIFICATION  )
#define     XTYP_POKE               (0x0090 | XCLASS_FLAGS         )
#define     XTYP_REGISTER           (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_REQUEST            (0x00B0 | XCLASS_DATA          )
#define     XTYP_DISCONNECT         (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_UNREGISTER         (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_WILDCONNECT        (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)

#define     XTYP_MASK                0x00F0
#define     XTYP_SHIFT               4  /* shift to turn XTYP_ into an index */

/***** Timeout constants *****/

#define     TIMEOUT_ASYNC           -1L

/***** Transaction ID constants *****/

#define     QID_SYNC                -1L

/****** public strings used in DDE ******/

#define SZDDESYS_TOPIC          "System"
#define SZDDESYS_ITEM_TOPICS    "Topics"
#define SZDDESYS_ITEM_SYSITEMS  "SysItems"
#define SZDDESYS_ITEM_RTNMSG    "ReturnMessage"
#define SZDDESYS_ITEM_STATUS    "Status"
#define SZDDESYS_ITEM_FORMATS   "Formats"
#define SZDDESYS_ITEM_HELP      "Help"
#define SZDDE_ITEM_ITEMLIST     "TopicItemList"


/****** API entry points ******/

typedef HDDEDATA CALLBACK FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);
typedef FNCALLBACK *PFNCALLBACK;

#define     CBR_BLOCK                0xffffffffL

/* DLL registration functions */

UINT    WINAPI DdeInitialize(DWORD FAR* pidInst, PFNCALLBACK pfnCallback,
                DWORD afCmd, DWORD ulRes);

/*
 * Callback filter flags for use with standard apps.
 */

#define     CBF_FAIL_SELFCONNECTIONS     0x00001000
#define     CBF_FAIL_CONNECTIONS         0x00002000
#define     CBF_FAIL_ADVISES             0x00004000
#define     CBF_FAIL_EXECUTES            0x00008000
#define     CBF_FAIL_POKES               0x00010000
#define     CBF_FAIL_REQUESTS            0x00020000
#define     CBF_FAIL_ALLSVRXACTIONS      0x0003f000

#define     CBF_SKIP_CONNECT_CONFIRMS    0x00040000
#define     CBF_SKIP_REGISTRATIONS       0x00080000
#define     CBF_SKIP_UNREGISTRATIONS     0x00100000
#define     CBF_SKIP_DISCONNECTS         0x00200000
#define     CBF_SKIP_ALLNOTIFICATIONS    0x003c0000

/*
 * Application command flags
 */
#define     APPCMD_CLIENTONLY            0x00000010L
#define     APPCMD_FILTERINITS           0x00000020L
#define     APPCMD_MASK                  0x00000FF0L

/*
 * Application classification flags
 */
#define     APPCLASS_STANDARD            0x00000000L
#define     APPCLASS_MASK                0x0000000FL


BOOL    WINAPI DdeUninitialize(DWORD idInst);

/* conversation enumeration functions */

HCONVLIST WINAPI DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
            HCONVLIST hConvList, CONVCONTEXT FAR* pCC);
HCONV   WINAPI DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev);
BOOL    WINAPI DdeDisconnectList(HCONVLIST hConvList);

/* conversation control functions */

HCONV   WINAPI DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
            CONVCONTEXT FAR* pCC);
BOOL    WINAPI DdeDisconnect(HCONV hConv);
HCONV   WINAPI DdeReconnect(HCONV hConv);

UINT    WINAPI DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, CONVINFO FAR* pConvInfo);
BOOL    WINAPI DdeSetUserHandle(HCONV hConv, DWORD id, DWORD hUser);

BOOL    WINAPI DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction);


/* app server interface functions */

BOOL    WINAPI DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem);
BOOL    WINAPI DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd);

#define EC_ENABLEALL            0
#define EC_ENABLEONE            ST_BLOCKNEXT
#define EC_DISABLE              ST_BLOCKED
#define EC_QUERYWAITING         2

HDDEDATA WINAPI DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd);

#define DNS_REGISTER        0x0001
#define DNS_UNREGISTER      0x0002
#define DNS_FILTERON        0x0004
#define DNS_FILTEROFF       0x0008

/* app client interface functions */

HDDEDATA WINAPI DdeClientTransaction(void FAR* pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType,
        DWORD dwTimeout, DWORD FAR* pdwResult);

/* data transfer functions */

HDDEDATA WINAPI DdeCreateDataHandle(DWORD idInst, void FAR* pSrc, DWORD cb,
            DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd);
HDDEDATA WINAPI DdeAddData(HDDEDATA hData, void FAR* pSrc, DWORD cb, DWORD cbOff);
DWORD   WINAPI DdeGetData(HDDEDATA hData, void FAR* pDst, DWORD cbMax, DWORD cbOff);
BYTE FAR* WINAPI DdeAccessData(HDDEDATA hData, DWORD FAR* pcbDataSize);
BOOL    WINAPI DdeUnaccessData(HDDEDATA hData);
BOOL    WINAPI DdeFreeDataHandle(HDDEDATA hData);

#define     HDATA_APPOWNED          0x0001



UINT WINAPI DdeGetLastError(DWORD idInst);

#define     DMLERR_NO_ERROR                    0       /* must be 0 */

#define     DMLERR_FIRST                       0x4000

#define     DMLERR_ADVACKTIMEOUT               0x4000
#define     DMLERR_BUSY                        0x4001
#define     DMLERR_DATAACKTIMEOUT              0x4002
#define     DMLERR_DLL_NOT_INITIALIZED         0x4003
#define     DMLERR_DLL_USAGE                   0x4004
#define     DMLERR_EXECACKTIMEOUT              0x4005
#define     DMLERR_INVALIDPARAMETER            0x4006
#define     DMLERR_LOW_MEMORY                  0x4007
#define     DMLERR_MEMORY_ERROR                0x4008
#define     DMLERR_NOTPROCESSED                0x4009
#define     DMLERR_NO_CONV_ESTABLISHED         0x400a
#define     DMLERR_POKEACKTIMEOUT              0x400b
#define     DMLERR_POSTMSG_FAILED              0x400c
#define     DMLERR_REENTRANCY                  0x400d
#define     DMLERR_SERVER_DIED                 0x400e
#define     DMLERR_SYS_ERROR                   0x400f
#define     DMLERR_UNADVACKTIMEOUT             0x4010
#define     DMLERR_UNFOUND_QUEUE_ID            0x4011

#define     DMLERR_LAST                        0x4011

HSZ     WINAPI DdeCreateStringHandle(DWORD idInst, LPCSTR psz, int iCodePage);
DWORD   WINAPI DdeQueryString(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
BOOL    WINAPI DdeFreeStringHandle(DWORD idInst, HSZ hsz);
BOOL    WINAPI DdeKeepStringHandle(DWORD idInst, HSZ hsz);
int     WINAPI DdeCmpStringHandles(HSZ hsz1, HSZ hsz2);


#ifndef NODDEMLSPY
/* */
/* DDEML public debugging header file info */
/* */

typedef struct tagMONMSGSTRUCT
{
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
} MONMSGSTRUCT;

typedef struct tagMONCBSTRUCT
{
    UINT   cb;
    WORD   wReserved;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    DWORD  dwData1;
    DWORD  dwData2;
} MONCBSTRUCT;

typedef struct tagMONHSZSTRUCT
{
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    WORD   wReserved;
    char   str[1];
} MONHSZSTRUCT;

#define MH_CREATE   1
#define MH_KEEP     2
#define MH_DELETE   3
#define MH_CLEANUP  4


typedef struct tagMONERRSTRUCT
{
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT;

typedef struct tagMONLINKSTRUCT
{
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT
{
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;
    HCONV   hConvServer;
} MONCONVSTRUCT;

#define     MAX_MONITORS            4
#define     APPCLASS_MONITOR        0x00000001L
#define     XTYP_MONITOR            (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)

/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */
#define     MF_HSZ_INFO                  0x01000000
#define     MF_SENDMSGS                  0x02000000
#define     MF_POSTMSGS                  0x04000000
#define     MF_CALLBACKS                 0x08000000
#define     MF_ERRORS                    0x10000000
#define     MF_LINKS                     0x20000000
#define     MF_CONV                      0x40000000

#define     MF_MASK                      0xFF000000
#endif /* NODDEMLSPY */

#ifdef __cplusplus
}
#endif

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif /* _INC_DDEML */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\custcntl.h ===
/*****************************************************************************\
*                                                                             *
* custcntl.h -  Custom Control Library header file                            *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CUSTCNTL
#define _INC_CUSTCNTL

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*
 * Every custom control DLL must have three functions present,
 * and they must be exported by the following ordinals.
 */
#define CCINFOORD       2       /* information function ordinal */
#define CCSTYLEORD      3       /* styles function ordinal */
#define CCFLAGSORD      4       /* translate flags function ordinal */

/* general size definitions */
#define CTLTYPES        12      /* max number of control types */
#define CTLDESCR        22      /* max size of description */
#define CTLCLASS        20      /* max size of class name */
#define CTLTITLE        94      /* max size of control text */

/*
 * CONTROL STYLE DATA STRUCTURE
 *
 * This data structure is used by the class style dialog function
 * to set and/or reset various control attributes.
 *
 */
typedef struct tagCTLSTYLE
{
    UINT    wX;                 /* x origin of control */
    UINT    wY;                 /* y origin of control */
    UINT    wCx;                /* width of control */
    UINT    wCy;                /* height of control */
    UINT    wId;                /* control child id */
    DWORD   dwStyle;            /* control style */
    char    szClass[CTLCLASS];  /* name of control class */
    char    szTitle[CTLTITLE];  /* control text */
} CTLSTYLE;
typedef CTLSTYLE *      PCTLSTYLE;
typedef CTLSTYLE FAR*   LPCTLSTYLE;

/*
 * CONTROL DATA STRUCTURE
 *
 * This data structure is returned by the control options function
 * when inquiring about the capabilities of a particular control.
 * Each control may contain various types (with predefined style
 * bits) under one general class.
 *
 * The width and height fields are used to provide the host
 * application with a suggested size.  The values in these fields
 * are in rc coordinates.
 *
 */
typedef struct tagCTLTYPE
{
    UINT    wType;              /* type style */
    UINT    wWidth;             /* suggested width */
    UINT    wHeight;            /* suggested height */
    DWORD   dwStyle;            /* default style */
    char    szDescr[CTLDESCR];  /* description */
} CTLTYPE;

typedef struct tagCTLINFO
{
    UINT    wVersion;           /* control version */
    UINT    wCtlTypes;          /* control types */
    char    szClass[CTLCLASS];  /* control class name */
    char    szTitle[CTLTITLE];  /* control title */
    char    szReserved[10];     /* reserved for future use */
    CTLTYPE Type[CTLTYPES];     /* control type list */
} CTLINFO;
typedef CTLINFO *       PCTLINFO;
typedef CTLINFO FAR*    LPCTLINFO;

/* These two function prototypes are used by the dialog editor */
#ifdef STRICT
typedef DWORD   (CALLBACK* LPFNSTRTOID)(LPCSTR);
#else
typedef DWORD   (CALLBACK* LPFNSTRTOID)(LPSTR);
#endif
typedef UINT    (CALLBACK* LPFNIDTOSTR)(UINT, LPSTR, UINT);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_CUSTCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\dbcs.h ===
/*****************************************************************************\
*                                                                             *
* dbcs.h - DBCS functions prototypes for DOS apps.			      *
*									      *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

extern int IsDBCSLeadByte(unsigned char uch);
extern unsigned char far *AnsiNext(unsigned char far *puch);
extern unsigned char far *AnsiPrev(unsigned char far *psz, unsigned char far *puch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\dde.h ===
/*****************************************************************************\
*                                                                             *
* dde.h -       Dynamic Data Exchange structures and definitions              *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_DDE
#define _INC_DDE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* DDE window messages */

#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	    (WM_DDE_FIRST+4)
#define WM_DDE_DATA	    (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	    (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	    (WM_DDE_FIRST+8)

/****************************************************************************\
*       DDEACK structure
*
*       Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
*       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
*       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
*
\****************************************************************************/

typedef struct tagDDEACK
{
    WORD    bAppReturnCode:8,
            reserved:6,
            fBusy:1,
            fAck:1;
} DDEACK;

/****************************************************************************\
*       DDEADVISE structure
*
*       WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
*
\****************************************************************************/

typedef struct tagDDEADVISE
{
    WORD    reserved:14,
            fDeferUpd:1,
            fAckReq:1;
    short   cfFormat;
} DDEADVISE;

/****************************************************************************\
*       DDEDATA structure
*
*       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
*       The actual size of this structure depends on the size of
*       the Value array.
*
\****************************************************************************/

typedef struct tagDDEDATA
{
    WORD    unused:12,
            fResponse:1,
            fRelease:1,
            reserved:1,
            fAckReq:1;
    short   cfFormat;
    BYTE     Value[1];
} DDEDATA;


/****************************************************************************\
*       DDEPOKE structure
*
*       WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
*       The actual size of this structure depends on the size of
*       the Value array.
*
\****************************************************************************/

typedef struct tagDDEPOKE
{
    WORD    unused:13,  /* Earlier versions of DDE.H incorrectly */
                        /* 12 unused bits.                       */
            fRelease:1,
            fReserved:2;
    short   cfFormat;
    BYTE    Value[1];   /* This member was named rgb[1] in previous */
                        /* versions of DDE.H                        */

} DDEPOKE;

/****************************************************************************\
* The following typedef's were used in previous versions of the Windows SDK.
* They are still valid.  The above typedef's define exactly the same structures
* as those below.  The above typedef names are recommended, however, as they
* are more meaningful.
*
* Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
* not correctly define the bit positions.
\****************************************************************************/

typedef struct tagDDELN
{
    WORD    unused:13,
            fRelease:1,
            fDeferUpd:1,
            fAckReq:1;
    short   cfFormat;
} DDELN;

typedef struct tagDDEUP
{
    WORD    unused:12,
            fAck:1,
            fRelease:1,
            fReserved:1,
            fAckReq:1;
    short   cfFormat;
    BYTE    rgb[1];
} DDEUP;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_DDE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\devinfo.h ===
/* *********************************************************************
 * DevInfo.h	Header file for DOS ConfigMgr Internal structure
 * 
 * Microsoft Corporation 
 * Copyright 1993
 * 
 * Author:	Nagarajan Subramaniyan 
 * Created:	9/1/93
 *
 * Modification history:
 *
 * **********************************************************************
*/

#ifndef _INC_DEVINFO
#define _INC_DEVINFO

/* XLATOFF */
#ifndef FAR
#ifdef	IS_32
#define	FAR
#else
#define	FAR	far
#endif
#endif
/* XLATON */

#define MAX_DEVID_LENGTH	10
			// device id string length 
			// EISA/PNP/PCI ids are only (max)8 bytes in length
#define MAX_SERNO_LENGTH	MAX_DEVID_LENGTH

#define CONFIG_DEVICE_NAME	"CONFIG$"

#define BUSTYPE_UNKNOWN 0
#define	BUSTYPE_ISA	1
		// ISA PNP bus is also treated as ISA 
#define BUSTYPE_EISA	2
#define BUSTYPE_PCI	4
#define BUSTYPE_PCMCIA	8
#define BUSTYPE_PNPISA	0x10
#define BUSTYPE_MCA	0x20
#define BUSTYPE_BIOS	0x40

struct Device_ID_s {
	DWORD	dwBusID;
			// 0 	undefined
			// 1 	ISA
			// 2	EISA
			// 4	PCI
			// 8	PCMCIA
			// 0x10	PNP
			// 0x20 MCA
	DWORD	dwDevId;
			// physical device ID ; -1 is undefined
	DWORD	dwSerialNum;	// 0 undefined
	DWORD	dwLogicalID;
		// Log device ID for PNP ISA
		// Class code for PCI, -1 undefined
	DWORD	dwFlags;
		// Bit 0:	Device has been inited
		// Bit 1:	Device is enabled
		// Bit 2: 	Device Config has been locked
	
};

/* values for DevId->dwFlags field */

#define DEV_INITED		0x1
			// device has been initialized
#define DEV_ENABLED		0x2
			// device has been enabled
#define DEV_CONFIG_LOCKED	0x4
			// device config was locked

#define DEV_STATIC_FLAGS	(DEV_INITED | DEV_ENABLED | DEV_CONFIG_LOCKED )
		// for static, motherboard devices, all 3 bits have to be set


#define SERNO_UNKNOWN	0x0
			// unknown serial no

#define UNKNOWN_VALUE	0xFFFFFFFF
		// unknown devid, log id etc..


typedef struct Device_ID_s	DEVICE_ID;
typedef DEVICE_ID 	*PDEVICE_ID;
typedef struct Device_ID_s FAR *LPDEVICE_ID;


/* XLATOFF */
union	Bus_Access	{
/* XLATON */

	struct	PCIAccess_s 	{
		BYTE	bBusNumber;	// Bus no 0-255
		BYTE	bDevFuncNumber;	// Device # in bits 7:3 and
					// Function # in bits 2:0
		WORD	wPCIReserved;	// 
	} sPCIAccess;
	struct EISAAccess_s	{
		BYTE	bSlotNumber;	// EISA board slot number
		BYTE	bFunctionNumber;
		WORD	wEisaReserved;
	} sEISAAccess;
	struct PnPAccess_s	{
		BYTE	bCSN;	// card slot number
		BYTE	bLogicalDevNumber;	// Logical Device #
		WORD	wReadDataPort;		// Read data port
	} sPnPAccess;
	struct PCMCIAAccess_s	{
		BYTE	bAdapterNumber;     // Card adapter number
		BYTE	bSocketNumber;	    // Card socket #
		WORD	wPCMCIAReserved;    // Reserved
	} sPCMCIAAccess;
	struct BIOSAccess_s	{
		BYTE	bBIOSNode;	    // Node number
	} sBIOSAccess;
/* XLATOFF */
};

typedef union Bus_Access	UBUS_ACCESS;
typedef union Bus_Access	*PUBUS_ACCESS;
typedef union Bus_Access FAR	*LPUBUS_ACCESS;


/* XLATON */

/* ASM 
; Following is supposed to be the max size of the above UNION
; This is done since H2INC doesn't know how to handle Unions

UBUS_ACCESS_SIZE	equ	size PnPAccess_s
;
; Structure definition for Config_Info_s
;
Config_Info_s	STRUC
	sDeviceId	db	size Device_ID_s dup (?)	
	uBusAccess	db	UBUS_ACCESS_SIZE	dup (?)
	sConfig_Data	db	size Config_Buff_s	dup (?)
Config_Info_s	ENDS

; End assembly
*/

/* XLATOFF */

struct Config_Info_s	{
	DEVICE_ID 		sDeviceId;	// DEVICE ID Info
	UBUS_ACCESS		uBusAccess;	// Bus specific data
	CMCONFIG		sConfig_Data;	// configuration data
						// 	defined in configmg.h
};
typedef struct Config_Info_s CONFIGINFO;
typedef struct Config_Info_s *PCONFIGINFO;
typedef struct Config_Info_s FAR *LPCONFIGINFO;

/* XLATON */

struct	Dev_Info_s	{

	struct Dev_Info_s FAR *lpNxtDevInfo;	// ptr to next dev info record
	struct Config_Info_s	sConfigInfo;	// config data info
						// variable length
};

typedef struct Dev_Info_s DEVINFO;
typedef struct Dev_Info_s *PDEVINFO;
typedef struct Dev_Info_s FAR *LPDEVINFO;


#define MAX_STATE_DATA_SIZE	300
#define DEVHDR_SIGNATURE	0x4d435744	// "DWCM" = Dos/Windows Config Manager

struct Dev_Header_s	{
	DWORD	DH_Signature;	// for verification == DEVHDR_SIGNATURE
	DWORD	DH_DevCount;	// no of devices we know of (and have data)
	DWORD	DH_TotalSize;	// size in bytes (incl. this header	)
	DWORD	DH_LinearAddr;	// Linear address if XMS.
	char	DH_StateData[MAX_STATE_DATA_SIZE];
				// Hardware state data
	struct Config_Info_s	DH_DevInfo;	// array of Config Info records
					// start here
};

typedef struct Dev_Header_s DEVHEADER;
typedef struct Dev_Header_s *PDEVHEADER;
typedef struct Dev_Header_s FAR *LPDEVHEADER;
	
/* Structures and definitions for the IOCTL_READ call to CONFIG$ */

struct ConfigDataPtr_s {
	DWORD	lpConfigPtr;
	BYTE	bConfigFlags;
};

typedef struct ConfigDataPtr_s CONFIGDATAPTR;
typedef struct ConfigDataPtr_s *PCONFIGDATAPTR;
typedef struct ConfigDataPtr_s FAR *LPCONFIGDATAPTR;

/* Definitions for bConfigFlags */

#define DC_API_ENABLED	1
#define DC_DATA_IN_XMS	2		
			// default: data in conv mem
/* if Data in conv mem, lpConfigPtr is actually a far ptr to the data 
 * if Data is in xms, LOWORD(lpConfigPtr) = 0 and HIWORD(lpConfigPtr) is the
 * XMS handle. 
*/


#define MAX_CONFIG 9
#define MAX_PROFILE_LEN 80
#define ULDOCK_ZERO 0xFFFFFFF0

typedef WORD CONFIG;
typedef WORD *PCONFIG;
typedef WORD FAR *LPCONFIG;

struct Map_s	{
	DWORD	MP_dwDock;
	DWORD	MP_dwSerialNo;
	WORD	MP_wChecksum;
	CONFIG	MP_cfg;
};

typedef struct Map_s MAP;
typedef struct Map_s *PMAP;
typedef struct Map_s FAR *LPMAP;

struct Map_DB_s	{
	WORD	MD_imapMax;
	struct	Map_s MD_rgmap[MAX_CONFIG];
};

typedef struct Map_DB_s MAPDB;
typedef struct Map_DB_s *PMAPDB;
typedef struct Map_DB_s FAR *LPMAPDB;

struct Config_Data_s	{
	// this data put into CONFIG$ device
	DWORD	CD_dwDock;
	DWORD	CD_dwSerialNo;
	WORD	CD_wChecksum;
	CONFIG	CD_cfg;
	char	CD_szFriendlyName[MAX_PROFILE_LEN];
	// this data not put into CONFIG$ device
	struct Map_DB_s	CD_mapdb;
};

typedef struct Config_Data_s CONFIGDATA;
typedef struct Config_Data_s *PCONFIGDATA;
typedef struct Config_Data_s FAR *LPCONFIGDATA;

#endif /* _INC_DEVINFO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\digitalv.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
 *
 *  FILE:   DIGITALV.H
 *      
 *  DESCRIPTION:
 *      Include file for the MCI Digital Video Command Set
 *
 *  HISTORY:
 *      Aug 19, 1992    -Version 1.0 Release
 *
 **************************************************************************/

#ifndef _INC_DIGITALV
#define _INC_DIGITALV  100

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MCI_TEST                            0x00000020L

/* Message values */

#define MCI_CAPTURE                         0x0870 
#define MCI_MONITOR                         0x0871 
#define MCI_RESERVE                         0x0872 
#define MCI_SETAUDIO                        0x0873 
#define MCI_SIGNAL                          0x0875 
#define MCI_SETVIDEO                        0x0876 
#define MCI_QUALITY                         0x0877
#define MCI_LIST                            0x0878
#define MCI_UNDO                            0x0879
#define MCI_CONFIGURE                       0x087a
#define MCI_RESTORE                         0x087b

/* Return and string constant values */

#define MCI_ON   1
#define MCI_OFF  0

#define MCI_DGV_FILE_MODE_SAVING            0x0001
#define MCI_DGV_FILE_MODE_LOADING           0x0002
#define MCI_DGV_FILE_MODE_EDITING           0x0003
#define MCI_DGV_FILE_MODE_IDLE              0x0004

/* These identifiers are used only by device drivers */

#define MCI_ON_S                            0x00008000L
#define MCI_OFF_S                           0x00008001L
#define MCI_DGV_FILE_S                      0x00008002L
#define MCI_DGV_INPUT_S                     0x00008003L

#define MCI_DGV_FILE_MODE_SAVING_S          0x00008004L
#define MCI_DGV_FILE_MODE_LOADING_S         0x00008005L
#define MCI_DGV_FILE_MODE_EDITING_S         0x00008006L
#define MCI_DGV_FILE_MODE_IDLE_S            0x00008007L

#define MCI_DGV_SETVIDEO_SRC_NTSC_S         0x00008010L
#define MCI_DGV_SETVIDEO_SRC_RGB_S          0x00008011L
#define MCI_DGV_SETVIDEO_SRC_SVIDEO_S       0x00008012L
#define MCI_DGV_SETVIDEO_SRC_PAL_S          0x00008013L
#define MCI_DGV_SETVIDEO_SRC_SECAM_S        0x00008014L
#define MCI_DGV_SETVIDEO_SRC_GENERIC_S      0x00008015L

#define MCI_DGV_SETAUDIO_SRC_LEFT_S         0x00008020L
#define MCI_DGV_SETAUDIO_SRC_RIGHT_S        0x00008021L
#define MCI_DGV_SETAUDIO_SRC_AVERAGE_S      0x00008022L
#define MCI_DGV_SETAUDIO_SRC_STEREO_S       0x00008023L

/* Window message for signal notification */

#ifndef MM_MCISIGNAL
#define MM_MCISIGNAL                        0x3CB
#endif
				    
/* error values */

#define MCIERR_DGV_DEVICE_LIMIT             (MCIERR_CUSTOM_DRIVER_BASE+0)
#define MCIERR_DGV_IOERR                    (MCIERR_CUSTOM_DRIVER_BASE+1) 
#define MCIERR_DGV_WORKSPACE_EMPTY          (MCIERR_CUSTOM_DRIVER_BASE+2) 
#define MCIERR_DGV_DISK_FULL                (MCIERR_CUSTOM_DRIVER_BASE+3) 
#define MCIERR_DGV_DEVICE_MEMORY_FULL       (MCIERR_CUSTOM_DRIVER_BASE+4)
#define MCIERR_DGV_BAD_CLIPBOARD_RANGE      (MCIERR_CUSTOM_DRIVER_BASE+5)
 
/* defines for monitor methods */

#define MCI_DGV_METHOD_PRE                  0x0000a000L
#define MCI_DGV_METHOD_POST                 0x0000a001L
#define MCI_DGV_METHOD_DIRECT               0x0000a002L

/* defines for known file formats */

#define MCI_DGV_FF_AVSS                     0x00004000L
#define MCI_DGV_FF_AVI                      0x00004001L
#define MCI_DGV_FF_DIB                      0x00004002L
#define MCI_DGV_FF_RDIB                     0x00004003L
#define MCI_DGV_FF_JPEG                     0x00004004L
#define MCI_DGV_FF_RJPEG                    0x00004005L
#define MCI_DGV_FF_JFIF                     0x00004006L
#define MCI_DGV_FF_MPEG                     0x00004007L

/* values for dwItem field of MCI_CAPABILITY_PARMS structure */

#define MCI_DGV_GETDEVCAPS_CAN_LOCK         0x00004000L
#define MCI_DGV_GETDEVCAPS_CAN_STRETCH      0x00004001L 
#define MCI_DGV_GETDEVCAPS_CAN_FREEZE       0x00004002L
#define MCI_DGV_GETDEVCAPS_MAX_WINDOWS      0x00004003L 
#define MCI_DGV_GETDEVCAPS_CAN_REVERSE      0x00004004L 
#define MCI_DGV_GETDEVCAPS_HAS_STILL        0x00004005L
#define MCI_DGV_GETDEVCAPS_PALETTES         0x00004006L
#define MCI_DGV_GETDEVCAPS_CAN_STR_IN       0x00004008L 
#define MCI_DGV_GETDEVCAPS_CAN_TEST         0x00004009L
#define MCI_DGV_GETDEVCAPS_MAXIMUM_RATE     0x0000400aL
#define MCI_DGV_GETDEVCAPS_MINIMUM_RATE     0x0000400bL

/* flags for dwFlags parameter of MCI_CAPTURE command message */

#define MCI_DGV_CAPTURE_AS                  0x00010000L
#define MCI_DGV_CAPTURE_AT                  0x00020000L

/* flags for dwFlags parameter of MCI_COPY command message */

#define MCI_DGV_COPY_AT                     0x00010000L
#define MCI_DGV_COPY_AUDIO_STREAM           0x00020000L
#define MCI_DGV_COPY_VIDEO_STREAM           0x00040000L

/* flags for dwFlags parameter of MCI_CUE command message */

#define MCI_DGV_CUE_INPUT                   0x00010000L 
#define MCI_DGV_CUE_OUTPUT                  0x00020000L
#define MCI_DGV_CUE_NOSHOW                  0x00040000L 

/* flags for dwFlags parameter of MCI_CUT command message */

#define MCI_DGV_CUT_AT                      0x00010000L
#define MCI_DGV_CUT_AUDIO_STREAM            0x00020000L
#define MCI_DGV_CUT_VIDEO_STREAM            0x00040000L

/* flags for dwFlags parameter of MCI_DELETE command message */

#define MCI_DGV_DELETE_AT                   0x00010000L
#define MCI_DGV_DELETE_AUDIO_STREAM         0x00020000L
#define MCI_DGV_DELETE_VIDEO_STREAM         0x00040000L

/* flags for dwFlags parameter of MCI_FREEZE command message */

#define MCI_DGV_FREEZE_AT                   0x00010000L
#define MCI_DGV_FREEZE_OUTSIDE              0x00020000L

/* flags for dwFlags parameter of MCI_INFO command message */

#define MCI_DGV_INFO_TEXT                   0x00010000L 
#define MCI_DGV_INFO_ITEM                   0X00020000L

/* values for dwItem field of MCI_DGV_INFO_PARMS structure */

#define MCI_INFO_VERSION                    0x00000400L

#define MCI_DGV_INFO_USAGE                  0x00004000L
#define MCI_DGV_INFO_AUDIO_QUALITY          0x00004001L
#define MCI_DGV_INFO_STILL_QUALITY          0x00004002L
#define MCI_DGV_INFO_VIDEO_QUALITY          0x00004003L
#define MCI_DGV_INFO_AUDIO_ALG              0x00004004L
#define MCI_DGV_INFO_STILL_ALG              0x00004005L
#define MCI_DGV_INFO_VIDEO_ALG              0x00004006L

/* flags for dwFlags parameter of MCI_LIST command message */

#define MCI_DGV_LIST_ITEM                   0x00010000L
#define MCI_DGV_LIST_COUNT                  0x00020000L
#define MCI_DGV_LIST_NUMBER                 0x00040000L
#define MCI_DGV_LIST_ALG                    0x00080000L

/* values for dwItem field of MCI_DGV_LIST_PARMS structure */

#define MCI_DGV_LIST_AUDIO_ALG              0x00004000L
#define MCI_DGV_LIST_AUDIO_QUALITY          0x00004001L
#define MCI_DGV_LIST_AUDIO_STREAM           0x00004002L
#define MCI_DGV_LIST_STILL_ALG              0x00004003L
#define MCI_DGV_LIST_STILL_QUALITY          0x00004004L
#define MCI_DGV_LIST_VIDEO_ALG              0x00004005L
#define MCI_DGV_LIST_VIDEO_QUALITY          0x00004006L
#define MCI_DGV_LIST_VIDEO_STREAM           0x00004007L
#define MCI_DGV_LIST_VIDEO_SOURCE           0x00004008L


/* flags for dwFlags parameter of MCI_MONITOR command message */

#define MCI_DGV_MONITOR_METHOD              0x00010000L
#define MCI_DGV_MONITOR_SOURCE              0x00020000L

/* values for dwSource parameter of the MCI_DGV_MONITOR_PARMS struture */

#define MCI_DGV_MONITOR_INPUT               0x00004000L
#define MCI_DGV_MONITOR_FILE                0x00004001L

/* flags for dwFlags parameter of MCI_OPEN command message */

#define MCI_DGV_OPEN_WS                     0x00010000L 
#define MCI_DGV_OPEN_PARENT                 0x00020000L
#define MCI_DGV_OPEN_NOSTATIC               0x00040000L

/* flags for dwFlags parameter of MCI_PASTE command message */

#define MCI_DGV_PASTE_AT                    0x00010000L
#define MCI_DGV_PASTE_AUDIO_STREAM          0x00020000L
#define MCI_DGV_PASTE_VIDEO_STREAM          0x00040000L
#define MCI_DGV_PASTE_INSERT                0x00080000L
#define MCI_DGV_PASTE_OVERWRITE             0x00100000L

/* flags for dwFlags parameter of MCI_PLAY command message */

#define MCI_DGV_PLAY_REPEAT                 0x00010000L                
#define MCI_DGV_PLAY_REVERSE                0x00020000L 
 
/* flags for dwFlags parameter of MCI_PUT command message */

#define MCI_DGV_RECT                        0x00010000L 
#define MCI_DGV_PUT_SOURCE                  0x00020000L 
#define MCI_DGV_PUT_DESTINATION             0x00040000L 
#define MCI_DGV_PUT_FRAME                   0x00080000L
#define MCI_DGV_PUT_VIDEO                   0x00100000L
#define MCI_DGV_PUT_WINDOW                  0x00200000L
#define MCI_DGV_PUT_CLIENT                  0x00400000L

/* flags for dwFlags parameter of MCI_QUALITY command message */

#define MCI_QUALITY_ITEM                    0x00010000L
#define MCI_QUALITY_NAME                    0x00020000L
#define MCI_QUALITY_ALG                     0x00040000L
#define MCI_QUALITY_DIALOG                  0x00080000L
#define MCI_QUALITY_HANDLE                  0x00100000L

/* values for dwItem field of MCI_QUALITY_PARMS structure */

#define MCI_QUALITY_ITEM_AUDIO              0x00004000L
#define MCI_QUALITY_ITEM_STILL              0x00004001L
#define MCI_QUALITY_ITEM_VIDEO              0x00004002L

/* flags for dwFlags parameter of MCI_REALIZE command message */

#define MCI_DGV_REALIZE_NORM                0x00010000L
#define MCI_DGV_REALIZE_BKGD                0x00020000L

/* flags for dwFlags parameter of MCI_RECORD command message */

#define MCI_DGV_RECORD_HOLD                 0x00020000L
#define MCI_DGV_RECORD_AUDIO_STREAM         0x00040000L
#define MCI_DGV_RECORD_VIDEO_STREAM         0x00080000L

/* flags for dwFlags parameters of MCI_RESERVE command message */

#define MCI_DGV_RESERVE_IN                  0x00010000L
#define MCI_DGV_RESERVE_SIZE                0x00020000L

/* flags for dwFlags parameter of MCI_RESTORE command message */

#define MCI_DGV_RESTORE_FROM                0x00010000L
#define MCI_DGV_RESTORE_AT                  0x00020000L

/* flags for dwFlags parameters of MCI_SAVE command message */

#define MCI_DGV_SAVE_ABORT                  0x00020000L
#define MCI_DGV_SAVE_KEEPRESERVE            0x00040000L

/* flags for dwFlags parameters of MCI_SET command message */

#define MCI_DGV_SET_SEEK_EXACTLY            0x00010000L
#define MCI_DGV_SET_SPEED                   0x00020000L
#define MCI_DGV_SET_STILL                   0x00040000L
#define MCI_DGV_SET_FILEFORMAT              0x00080000L

/* flags for the dwFlags parameter of MCI_SETAUDIO command message */

#define MCI_DGV_SETAUDIO_OVER               0x00010000L
#define MCI_DGV_SETAUDIO_CLOCKTIME          0x00020000L
#define MCI_DGV_SETAUDIO_ALG                0x00040000L
#define MCI_DGV_SETAUDIO_QUALITY            0x00080000L
#define MCI_DGV_SETAUDIO_RECORD             0x00100000L
#define MCI_DGV_SETAUDIO_LEFT               0x00200000L
#define MCI_DGV_SETAUDIO_RIGHT              0x00400000L
#define MCI_DGV_SETAUDIO_ITEM               0x00800000L
#define MCI_DGV_SETAUDIO_VALUE              0x01000000L
#define MCI_DGV_SETAUDIO_INPUT              0x02000000L
#define MCI_DGV_SETAUDIO_OUTPUT             0x04000000L

/* values for the dwItem parameter of MCI_DGV_SETAUDIO_PARMS */

#define MCI_DGV_SETAUDIO_TREBLE             0x00004000L
#define MCI_DGV_SETAUDIO_BASS               0x00004001L
#define MCI_DGV_SETAUDIO_VOLUME             0x00004002L
#define MCI_DGV_SETAUDIO_STREAM             0x00004003L
#define MCI_DGV_SETAUDIO_SOURCE             0x00004004L
#define MCI_DGV_SETAUDIO_SAMPLESPERSEC      0x00004005L
#define MCI_DGV_SETAUDIO_AVGBYTESPERSEC     0x00004006L
#define MCI_DGV_SETAUDIO_BLOCKALIGN         0x00004007L
#define MCI_DGV_SETAUDIO_BITSPERSAMPLE      0x00004008L

/* values for the dwValue parameter of MCI_DGV_SETAUDIO_PARMS
   used with MCI_DGV_SETAUDIO_SOURCE */

#define MCI_DGV_SETAUDIO_SOURCE_STEREO      0x00000000L
#define MCI_DGV_SETAUDIO_SOURCE_LEFT        0x00000001L
#define MCI_DGV_SETAUDIO_SOURCE_RIGHT       0x00000002L
#define MCI_DGV_SETAUDIO_SOURCE_AVERAGE     0x00004000L

/* flags for the dwFlags parameter of MCI_SETVIDEO command */

#define MCI_DGV_SETVIDEO_QUALITY            0x00010000L
#define MCI_DGV_SETVIDEO_ALG                0x00020000L
#define MCI_DGV_SETVIDEO_CLOCKTIME          0x00040000L
#define MCI_DGV_SETVIDEO_SRC_NUMBER         0x00080000L
#define MCI_DGV_SETVIDEO_ITEM               0x00100000L
#define MCI_DGV_SETVIDEO_OVER               0x00200000L
#define MCI_DGV_SETVIDEO_RECORD             0x00400000L
#define MCI_DGV_SETVIDEO_STILL              0x00800000L
#define MCI_DGV_SETVIDEO_VALUE              0x01000000L
#define MCI_DGV_SETVIDEO_INPUT              0x02000000L
#define MCI_DGV_SETVIDEO_OUTPUT             0x04000000L

/* values for the dwTo field of MCI_SETVIDEO_PARMS
   used with MCI_DGV_SETVIDEO_SOURCE */

#define MCI_DGV_SETVIDEO_SRC_NTSC           0x00004000L
#define MCI_DGV_SETVIDEO_SRC_RGB            0x00004001L
#define MCI_DGV_SETVIDEO_SRC_SVIDEO         0x00004002L
#define MCI_DGV_SETVIDEO_SRC_PAL            0x00004003L
#define MCI_DGV_SETVIDEO_SRC_SECAM          0x00004004L
#define MCI_DGV_SETVIDEO_SRC_GENERIC        0x00004005L

/* values for the dwItem field of MCI_SETVIDEO_PARMS */

#define MCI_DGV_SETVIDEO_BRIGHTNESS         0x00004000L
#define MCI_DGV_SETVIDEO_COLOR              0x00004001L
#define MCI_DGV_SETVIDEO_CONTRAST           0x00004002L
#define MCI_DGV_SETVIDEO_TINT               0x00004003L
#define MCI_DGV_SETVIDEO_SHARPNESS          0x00004004L
#define MCI_DGV_SETVIDEO_GAMMA              0x00004005L
#define MCI_DGV_SETVIDEO_STREAM             0x00004006L
#define MCI_DGV_SETVIDEO_PALHANDLE          0x00004007L
#define MCI_DGV_SETVIDEO_FRAME_RATE         0x00004008L
#define MCI_DGV_SETVIDEO_SOURCE             0x00004009L
#define MCI_DGV_SETVIDEO_KEY_INDEX          0x0000400aL
#define MCI_DGV_SETVIDEO_KEY_COLOR          0x0000400bL
#define MCI_DGV_SETVIDEO_BITSPERPEL         0x0000400cL

/* flags for the dwFlags parameter of MCI_SIGNAL */

#define MCI_DGV_SIGNAL_AT                   0x00010000L
#define MCI_DGV_SIGNAL_EVERY                0x00020000L
#define MCI_DGV_SIGNAL_USERVAL              0x00040000L
#define MCI_DGV_SIGNAL_CANCEL               0x00080000L
#define MCI_DGV_SIGNAL_POSITION             0x00100000L

/* The following is the function digitalvideo drivers must use 
 * to signal when a frame marked by the SIGNAL command has been rendered:
 *
 *  SEND_DGVSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos )
 *
 * The following is a description of the parameters:
 *
 *  dwFlags    - the dwFlags parameter passed when the signal was set
 *  dwCallback - the dwCallback value from the MCI_DGV_SIGNAL_PARMS struct
 *               used to set the signal
 *  hDriver    - the handle assigned to the driver by MMSYSTEM when the 
 *               device was opened
 *  wDeviceID  - the device ID
 *  dwUser     - the dwUserParm value from the MCI_DGV_SIGNAL_PARMS struct
 *               used to set the signal
 *  dwPos      - the position at which the signal was sent, in the current
 *               time format.
 *
 * The window indicated by the handle in the dwCallback field is notified 
 * by means of a Windows message with the following form:
 *
 * msg    = MM_MCISIGNAL
 * wParam = wDeviceID of the sending driver 
 * lParam = the uservalue specified or the position the signal was sent
 *          at; the latter if the MCI_DGV_SIGNAL_POSITION flag was set 
 *          in the dwFlags parameter when the signal was created.
 */

#define SEND_DGVSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos ) \
  DriverCallback( (dwCallback), DCB_WINDOW, (HANDLE)(wDeviceID), MM_MCISIGNAL,\
  hDriver, ((dwFlags) & MCI_DGV_SIGNAL_POSITION) ? (dwPos):(dwUser),\
  ((dwFlags) & MCI_DGV_SIGNAL_POSITION) ? (dwUser):(dwPos))

/* flags for the dwFlags parameter of MCI_STATUS command */
                                            
#define MCI_DGV_STATUS_NOMINAL              0x00020000L
#define MCI_DGV_STATUS_REFERENCE            0x00040000L
#define MCI_DGV_STATUS_LEFT                 0x00080000L
#define MCI_DGV_STATUS_RIGHT                0x00100000L
#define MCI_DGV_STATUS_DISKSPACE            0x00200000L
#define MCI_DGV_STATUS_INPUT                0x00400000L
#define MCI_DGV_STATUS_OUTPUT               0x00800000L
#define MCI_DGV_STATUS_RECORD               0x01000000L

/* values for dwItem field of MCI_STATUS_PARMS structure */

#define MCI_DGV_STATUS_AUDIO_INPUT          0x00004000L
#define MCI_DGV_STATUS_HWND                 0x00004001L
#define MCI_DGV_STATUS_SPEED                0x00004003L
#define MCI_DGV_STATUS_HPAL                 0x00004004L
#define MCI_DGV_STATUS_BRIGHTNESS           0x00004005L
#define MCI_DGV_STATUS_COLOR                0x00004006L
#define MCI_DGV_STATUS_CONTRAST             0x00004007L
#define MCI_DGV_STATUS_FILEFORMAT           0x00004008L
#define MCI_DGV_STATUS_AUDIO_SOURCE         0x00004009L
#define MCI_DGV_STATUS_GAMMA                0x0000400aL
#define MCI_DGV_STATUS_MONITOR              0x0000400bL
#define MCI_DGV_STATUS_MONITOR_METHOD       0x0000400cL
#define MCI_DGV_STATUS_FRAME_RATE           0x0000400eL
#define MCI_DGV_STATUS_BASS                 0x0000400fL
#define MCI_DGV_STATUS_SIZE                 0x00004010L
#define MCI_DGV_STATUS_SEEK_EXACTLY         0x00004011L
#define MCI_DGV_STATUS_SHARPNESS            0x00004012L
#define MCI_DGV_STATUS_SMPTE                0x00004013L
#define MCI_DGV_STATUS_AUDIO                0x00004014L
#define MCI_DGV_STATUS_TINT                 0x00004015L
#define MCI_DGV_STATUS_TREBLE               0x00004016L
#define MCI_DGV_STATUS_UNSAVED              0x00004017L
#define MCI_DGV_STATUS_VIDEO                0x00004018L
#define MCI_DGV_STATUS_VOLUME               0x00004019L
#define MCI_DGV_STATUS_AUDIO_RECORD         0x0000401aL
#define MCI_DGV_STATUS_VIDEO_SOURCE         0x0000401bL
#define MCI_DGV_STATUS_VIDEO_RECORD         0x0000401cL
#define MCI_DGV_STATUS_STILL_FILEFORMAT     0x0000401dL
#define MCI_DGV_STATUS_VIDEO_SRC_NUM        0x0000401eL
#define MCI_DGV_STATUS_FILE_MODE            0x0000401fL
#define MCI_DGV_STATUS_FILE_COMPLETION      0x00004020L
#define MCI_DGV_STATUS_WINDOW_VISIBLE       0x00004021L
#define MCI_DGV_STATUS_WINDOW_MINIMIZED     0x00004022L
#define MCI_DGV_STATUS_WINDOW_MAXIMIZED     0x00004023L
#define MCI_DGV_STATUS_KEY_INDEX            0x00004024L
#define MCI_DGV_STATUS_KEY_COLOR            0x00004025L
#define MCI_DGV_STATUS_PAUSE_MODE           0x00004026L
#define MCI_DGV_STATUS_SAMPLESPERSEC        0x00004027L
#define MCI_DGV_STATUS_AVGBYTESPERSEC       0x00004028L
#define MCI_DGV_STATUS_BLOCKALIGN           0x00004029L
#define MCI_DGV_STATUS_BITSPERSAMPLE        0x0000402aL
#define MCI_DGV_STATUS_BITSPERPEL           0x0000402bL
#define MCI_DGV_STATUS_FORWARD              0x0000402cL
#define MCI_DGV_STATUS_AUDIO_STREAM         0x0000402dL
#define MCI_DGV_STATUS_VIDEO_STREAM         0x0000402eL

/* flags for dwFlags parameter of MCI_STEP command message */

#define MCI_DGV_STEP_REVERSE                0x00010000L 
#define MCI_DGV_STEP_FRAMES                 0x00020000L 

/* flags for dwFlags parameter of MCI_STOP command message */

#define MCI_DGV_STOP_HOLD                   0x00010000L

/* flags for dwFlags parameter of MCI_UPDATE command message */

#define MCI_DGV_UPDATE_HDC                  0x00020000L
#define MCI_DGV_UPDATE_PAINT                0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */

#define MCI_DGV_WHERE_SOURCE                0x00020000L
#define MCI_DGV_WHERE_DESTINATION           0x00040000L
#define MCI_DGV_WHERE_FRAME                 0x00080000L
#define MCI_DGV_WHERE_VIDEO                 0x00100000L
#define MCI_DGV_WHERE_WINDOW                0x00200000L
#define MCI_DGV_WHERE_MAX                   0x00400000L

/* flags for dwFlags parameter of MCI_WINDOW command message */

#define MCI_DGV_WINDOW_HWND                 0x00010000L 
#define MCI_DGV_WINDOW_STATE                0x00040000L 
#define MCI_DGV_WINDOW_TEXT                 0x00080000L 

/* flags for hWnd parameter of MCI_DGV_WINDOW_PARMS parameter block */

#define MCI_DGV_WINDOW_DEFAULT              0x00000000L

/* parameter block for MCI_WHERE, MCI_PUT, MCI_FREEZE, MCI_UNFREEZE cmds */

typedef struct {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif  
} MCI_DGV_RECT_PARMS;
typedef MCI_DGV_RECT_PARMS FAR * LPMCI_DGV_RECT_PARMS;

/* parameter block for MCI_CAPTURE command message */

typedef struct {
    DWORD   dwCallback;
#ifdef WIN32
    LPTSTR  lpstrFileName;
#else
    LPSTR   lpstrFileName;
#endif
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif  
} MCI_DGV_CAPTURE_PARMS;
typedef MCI_DGV_CAPTURE_PARMS FAR * LPMCI_DGV_CAPTURE_PARMS;

/* parameter block for MCI_CLOSE command message */

typedef MCI_GENERIC_PARMS MCI_CLOSE_PARMS;
typedef MCI_CLOSE_PARMS FAR * LPMCI_CLOSE_PARMS;

/* parameter block for MCI_COPY command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwFrom;    
    DWORD   dwTo;  
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif  
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_COPY_PARMS;
typedef MCI_DGV_COPY_PARMS FAR * LPMCI_DGV_COPY_PARMS;

/* parameter block for MCI_CUE command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwTo;    
} MCI_DGV_CUE_PARMS;
typedef MCI_DGV_CUE_PARMS FAR * LPMCI_DGV_CUE_PARMS;

/* parameter block for MCI_CUT command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;  
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif  
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_CUT_PARMS;
typedef MCI_DGV_CUT_PARMS FAR * LPMCI_DGV_CUT_PARMS;

/* parameter block for MCI_DELETE command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif  
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_DELETE_PARMS;
typedef MCI_DGV_DELETE_PARMS FAR * LPMCI_DGV_DELETE_PARMS;

/* parameter block for MCI_FREEZE command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_FREEZE_PARMS;
typedef MCI_DGV_FREEZE_PARMS FAR * LPMCI_DGV_FREEZE_PARMS;

/* parameter block for MCI_INFO command message */

typedef struct  {
    DWORD   dwCallback;
#ifdef WIN32
    LPTSTR  lpstrReturn;
#else
    LPSTR   lpstrReturn;
#endif
    DWORD   dwRetSize;
    DWORD   dwItem;
} MCI_DGV_INFO_PARMS;
typedef MCI_INFO_PARMS FAR * LPMCI_INFO_PARMS;
typedef MCI_DGV_INFO_PARMS FAR * LPMCI_DGV_INFO_PARMS;

/* parameter block for MCI_LIST command message */

typedef struct {
    DWORD   dwCallback;
#ifdef WIN32
    LPTSTR  lpstrReturn;
#else
    LPSTR   lpstrReturn;
#endif
    DWORD   dwLength;
    DWORD   dwNumber;
    DWORD   dwItem;
#ifdef WIN32
    LPTSTR  lpstrAlgorithm;
#else
    LPSTR   lpstrAlgorithm;
#endif
} MCI_DGV_LIST_PARMS;
typedef MCI_DGV_LIST_PARMS FAR * LPMCI_DGV_LIST_PARMS;

/* parameter block for MCI_LOAD command message */

typedef MCI_LOAD_PARMS MCI_DGV_LOAD_PARMS;   
typedef MCI_DGV_LOAD_PARMS FAR * LPMCI_DGV_LOAD_PARMS;

/* parameter block for MCI_MONITOR command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwSource;
    DWORD   dwMethod;
} MCI_DGV_MONITOR_PARMS;
typedef MCI_DGV_MONITOR_PARMS FAR * LPMCI_DGV_MONITOR_PARMS;

/* parameter block for MCI_OPEN command message */

typedef struct {
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
#ifdef WIN32
    LPTSTR  lpstrDeviceType;
    LPTSTR  lpstrElementName;
    LPTSTR  lpstrAlias;
#else
    LPSTR   lpstrDeviceType;
    LPSTR   lpstrElementName;
    LPSTR   lpstrAlias;
#endif
    DWORD   dwStyle;
    HWND    hWndParent;
#ifndef WIN32
    WORD    wReserved1;
#endif
} MCI_DGV_OPEN_PARMS;
typedef MCI_DGV_OPEN_PARMS FAR * LPMCI_DGV_OPEN_PARMS;

/* parameter block for MCI_PAUSE command message */

typedef MCI_GENERIC_PARMS MCI_DGV_PAUSE_PARMS;
typedef MCI_DGV_PAUSE_PARMS FAR * LPMCI_DGV_PAUSE_PARMS;

/* parameter block for MCI_PASTE command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwTo;  
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif  
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_PASTE_PARMS;
typedef MCI_DGV_PASTE_PARMS FAR * LPMCI_DGV_PASTE_PARMS;

/* parameter block for MCI_PLAY command message */

typedef MCI_PLAY_PARMS MCI_DGV_PLAY_PARMS;
typedef MCI_DGV_PLAY_PARMS FAR * LPMCI_DGV_PLAY_PARMS;

/* parameter block for MCI_PUT command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_PUT_PARMS;
typedef MCI_DGV_PUT_PARMS FAR * LPMCI_DGV_PUT_PARMS;

/* parameter block for MCI_QUALITY command message */

typedef struct {
    DWORD       dwCallback;
    DWORD       dwItem;
#ifdef WIN32
    LPTSTR      lpstrName;
#else
    LPSTR       lpstrName;
#endif
    DWORD       lpstrAlgorithm;
    DWORD       dwHandle;
} MCI_DGV_QUALITY_PARMS;
typedef MCI_DGV_QUALITY_PARMS FAR * LPMCI_DGV_QUALITY_PARMS;

/* parameter block for MCI_REALIZE command message */

typedef MCI_GENERIC_PARMS MCI_REALIZE_PARMS;
typedef MCI_REALIZE_PARMS FAR * LPMCI_REALIZE_PARMS;

/* parameter block for MCI_RECORD command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif  
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_RECORD_PARMS;
typedef MCI_DGV_RECORD_PARMS FAR * LPMCI_DGV_RECORD_PARMS;

/* parameter block for MCI_RESERVE command message */

typedef struct {
    DWORD   dwCallback;
#ifdef WIN32
    LPTSTR  lpstrPath;
#else
    LPSTR   lpstrPath;
#endif
    DWORD   dwSize;
} MCI_DGV_RESERVE_PARMS;
typedef MCI_DGV_RESERVE_PARMS FAR * LPMCI_DGV_RESERVE_PARMS;

/* parameter block for MCI_RESTORE command message */

typedef struct {
    DWORD   dwCallback;
#ifdef WIN32
    LPTSTR  lpstrFileName;
#else
    LPSTR   lpstrFileName;
#endif
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif  
} MCI_DGV_RESTORE_PARMS;
typedef MCI_DGV_RESTORE_PARMS FAR * LPMCI_DGV_RESTORE_PARMS;

/* parameter block for MCI_RESUME command message */

typedef MCI_GENERIC_PARMS MCI_DGV_RESUME_PARMS;
typedef MCI_DGV_RESUME_PARMS FAR * LPMCI_DGV_RESUME_PARMS;

/* parameter block for MCI_SAVE command message */

typedef struct {
    DWORD   dwCallback;
#ifdef WIN32
    LPTSTR  lpstrFileName;
#else
    LPSTR   lpstrFileName;
#endif
    RECT    rc;
} MCI_DGV_SAVE_PARMS;
typedef MCI_DGV_SAVE_PARMS FAR * LPMCI_DGV_SAVE_PARMS;

/* parameter block for MCI_SET command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwFileFormat;
    DWORD   dwSpeed;
} MCI_DGV_SET_PARMS;
typedef MCI_DGV_SET_PARMS FAR * LPMCI_DGV_SET_PARMS;

/* parameter block for MCI_SETAUDIO command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
#ifdef WIN32
    LPTSTR  lpstrAlgorithm;
    LPTSTR  lpstrQuality;
#else
    LPSTR   lpstrAlgorithm;
    LPSTR   lpstrQuality;
#endif
} MCI_DGV_SETAUDIO_PARMS;
typedef MCI_DGV_SETAUDIO_PARMS FAR * LPMCI_DGV_SETAUDIO_PARMS;

/* parameter block for MCI_SIGNAL command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwPosition;
    DWORD   dwPeriod;
    DWORD   dwUserParm;
} MCI_DGV_SIGNAL_PARMS;
typedef MCI_DGV_SIGNAL_PARMS FAR * LPMCI_DGV_SIGNAL_PARMS;

/* parameter block for MCI_SETVIDEO command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
#ifdef WIN32
    LPTSTR  lpstrAlgorithm;
    LPTSTR  lpstrQuality;
#else
    LPSTR   lpstrAlgorithm;
    LPSTR   lpstrQuality;
#endif
    DWORD   dwSourceNumber;
} MCI_DGV_SETVIDEO_PARMS;
typedef MCI_DGV_SETVIDEO_PARMS FAR * LPMCI_DGV_SETVIDEO_PARMS;

/* parameter block for MCI_STATUS command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
#ifdef WIN32
    LPTSTR  lpstrDrive;
#else
    LPSTR   lpstrDrive;
#endif
    DWORD   dwReference;
} MCI_DGV_STATUS_PARMS;
typedef MCI_DGV_STATUS_PARMS FAR * LPMCI_DGV_STATUS_PARMS;

/* parameter block for MCI_STEP command message */

typedef struct {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_DGV_STEP_PARMS;
typedef MCI_DGV_STEP_PARMS FAR *LPMCI_DGV_STEP_PARMS;

/* parameter block for MCI_STOP command message */

typedef MCI_GENERIC_PARMS MCI_DGV_STOP_PARMS;
typedef MCI_DGV_STOP_PARMS FAR * LPMCI_DGV_STOP_PARMS;

/* parameter block for MCI_UNFREEZE command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_UNFREEZE_PARMS;
typedef MCI_DGV_UNFREEZE_PARMS FAR * LPMCI_DGV_UNFREEZE_PARMS;

/* parameter block for MCI_UPDATE command message */

typedef struct {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif  
    HDC     hDC;
    WORD    wReserved0;
} MCI_DGV_UPDATE_PARMS;
typedef MCI_DGV_UPDATE_PARMS FAR * LPMCI_DGV_UPDATE_PARMS;

/* parameter block for MCI_WHERE command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_WHERE_PARMS;
typedef MCI_DGV_WHERE_PARMS FAR * LPMCI_DGV_WHERE_PARMS;

/* parameter block for MCI_WINDOW command message */

typedef struct {
    DWORD   dwCallback;
    HWND    hWnd;
#ifdef WIN32
    UINT    nCmdShow;
    LPTSTR  lpstrText;
#else
    WORD    wReserved1;
    UINT    nCmdShow;
    WORD    wReserved2;
    LPSTR   lpstrText;
#endif
} MCI_DGV_WINDOW_PARMS;
typedef MCI_DGV_WINDOW_PARMS FAR * LPMCI_DGV_WINDOW_PARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* !_INC_DIGITALV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\dispatch.h ===
/*** 
*dispatch.h - Application Programmability definitions.
*
*  Copyright (C) 1992-1993, Microsoft Corporation.  All Rights Reserved.
*
*Purpose:
*  This file defines the Ole Automation interfaces and APIs.
*
*Implementation Notes:
*  This file requires ole2.h
*
*****************************************************************************/

#ifndef _DISPATCH_H_
#define _DISPATCH_H_


#include "variant.h"


#ifdef _MAC

DEFINE_OLEGUID(IID_IDispatch,		0x00, 0x04, 0x02, 0, 0, 0, 0, 0); 
DEFINE_OLEGUID(IID_IEnumVARIANT,	0x04, 0x04, 0x02, 0, 0, 0, 0, 0);
DEFINE_OLEGUID(IID_ITypeInfo,		0x01, 0x04, 0x02, 0, 0, 0, 0, 0);
DEFINE_OLEGUID(IID_ITypeLib,		0x02, 0x04, 0x02, 0, 0, 0, 0, 0);
DEFINE_OLEGUID(IID_ITypeComp,		0x03, 0x04, 0x02, 0, 0, 0, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeInfo,	0x05, 0x04, 0x02, 0, 0, 0, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeLib,	0x06, 0x04, 0x02, 0, 0, 0, 0, 0);

#else

DEFINE_OLEGUID(IID_IDispatch,		0x00020400L, 0, 0);
DEFINE_OLEGUID(IID_IEnumVARIANT,	0x00020404L, 0, 0);
DEFINE_OLEGUID(IID_ITypeInfo,		0x00020401L, 0, 0);
DEFINE_OLEGUID(IID_ITypeLib,		0x00020402L, 0, 0);
DEFINE_OLEGUID(IID_ITypeComp,		0x00020403L, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeInfo,	0x00020405L, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeLib,	0x00020406L, 0, 0);

#endif


/* forward declarations */
#ifdef __cplusplus
interface IDispatch;
interface IEnumVARIANT;
interface ITypeInfo;
interface ITypeLib;
interface ITypeComp;
interface ICreateTypeInfo;
interface ICreateTypeLib;
#else
typedef interface IDispatch IDispatch;
typedef interface IEnumVARIANT IEnumVARIANT;
typedef interface ITypeInfo ITypeInfo;
typedef interface ITypeLib ITypeLib;
typedef interface ITypeComp ITypeComp;
typedef interface ICreateTypeInfo ICreateTypeInfo;
typedef interface ICreateTypeLib ICreateTypeLib;
#endif


/* IDispatch related error codes */

#define DISP_ERROR(X) MAKE_SCODE(SEVERITY_ERROR, FACILITY_DISPATCH, X)

#define DISP_E_UNKNOWNINTERFACE		DISP_ERROR(1)
#define DISP_E_MEMBERNOTFOUND		DISP_ERROR(3)
#define DISP_E_PARAMNOTFOUND		DISP_ERROR(4)
#define DISP_E_TYPEMISMATCH		DISP_ERROR(5)
#define DISP_E_UNKNOWNNAME		DISP_ERROR(6)
#define DISP_E_NONAMEDARGS		DISP_ERROR(7)
#define DISP_E_BADVARTYPE		DISP_ERROR(8)
#define DISP_E_EXCEPTION		DISP_ERROR(9)
#define DISP_E_OVERFLOW			DISP_ERROR(10)
#define DISP_E_BADINDEX			DISP_ERROR(11)
#define DISP_E_UNKNOWNLCID		DISP_ERROR(12)
#define DISP_E_ARRAYISLOCKED		DISP_ERROR(13)
#define DISP_E_BADPARAMCOUNT		DISP_ERROR(14)
#define DISP_E_PARAMNOTOPTIONAL		DISP_ERROR(15)
#define DISP_E_BADCALLEE		DISP_ERROR(16)
#define DISP_E_NOTACOLLECTION		DISP_ERROR(17)


#define TYPE_ERROR(X) MAKE_SCODE(SEVERITY_ERROR, FACILITY_DISPATCH, X)

#define TYPE_E_IOERROR			TYPE_ERROR(   57)
#define TYPE_E_COMPILEERROR		TYPE_ERROR(   90)
#define TYPE_E_CANTCREATETMPFILE	TYPE_ERROR(  322)
#define TYPE_E_ILLEGALINDEX		TYPE_ERROR(  341)
#define TYPE_E_IDNOTFOUND		TYPE_ERROR( 1000)
#define TYPE_E_BUFFERTOOSMALL		TYPE_ERROR(32790)
#define TYPE_E_READONLY 		TYPE_ERROR(32791)
#define TYPE_E_INVDATAREAD		TYPE_ERROR(32792)
#define TYPE_E_UNSUPFORMAT		TYPE_ERROR(32793)
#define TYPE_E_ALREADYCONTAINSNAME	TYPE_ERROR(32794)
#define TYPE_E_NOMATCHINGARITY		TYPE_ERROR(32795)
#define TYPE_E_REGISTRYACCESS		TYPE_ERROR(32796)
#define TYPE_E_LIBNOTREGISTERED 	TYPE_ERROR(32797)
#define TYPE_E_DUPLICATEDEFINITION	TYPE_ERROR(32798)
#define TYPE_E_USAGE			TYPE_ERROR(32799)
#define TYPE_E_DESTNOTKNOWN		TYPE_ERROR(32800)
#define TYPE_E_UNDEFINEDTYPE		TYPE_ERROR(32807)
#define TYPE_E_QUALIFIEDNAMEDISALLOWED	TYPE_ERROR(32808)
#define TYPE_E_INVALIDSTATE		TYPE_ERROR(32809)
#define TYPE_E_WRONGTYPEKIND		TYPE_ERROR(32810)
#define TYPE_E_ELEMENTNOTFOUND		TYPE_ERROR(32811)
#define TYPE_E_AMBIGUOUSNAME		TYPE_ERROR(32812)
#define TYPE_E_INVOKEFUNCTIONMISMATCH	TYPE_ERROR(32813)
#define TYPE_E_DLLFUNCTIONNOTFOUND	TYPE_ERROR(32814)
#define TYPE_E_BADMODULEKIND		TYPE_ERROR(35005)
#define TYPE_E_WRONGPLATFORM		TYPE_ERROR(35006)
#define TYPE_E_ALREADYBEINGLAIDOUT	TYPE_ERROR(35007)
#define TYPE_E_CANTLOADLIBRARY		TYPE_ERROR(40010)


/* if not already picked up from olenls.h */
#ifndef _LCID_DEFINED
typedef DWORD LCID;
# define _LCID_DEFINED
#endif


/*---------------------------------------------------------------------*/
/*                            BSTR API                                 */
/*---------------------------------------------------------------------*/


STDAPI_(BSTR) SysAllocString(char FAR*);
STDAPI_(BOOL) SysReAllocString(BSTR FAR*, char FAR*);
STDAPI_(BSTR) SysAllocStringLen(char FAR*, UINT);
STDAPI_(BOOL) SysReAllocStringLen(BSTR FAR*, char FAR*, UINT);
STDAPI_(void) SysFreeString(BSTR);
STDAPI_(UINT) SysStringLen(BSTR);


/*---------------------------------------------------------------------*/
/*                            Time API                                 */
/*---------------------------------------------------------------------*/

STDAPI_(BOOL)
DosDateTimeToVariantTime(
    WORD wDosDate,
    WORD wDosTime,
    double FAR* pvtime);

STDAPI_(BOOL)
VariantTimeToDosDateTime(
    double vtime,
    WORD FAR* pwDosDate,
    WORD FAR* pwDosTime);


/*---------------------------------------------------------------------*/
/*                          SafeArray API                              */
/*---------------------------------------------------------------------*/

STDAPI_(SAFEARRAY FAR*)
SafeArrayCreate(
    VARTYPE vt,
    UINT cDims,
    SAFEARRAYBOUND FAR* rgsabound);

STDAPI SafeArrayDestroy(SAFEARRAY FAR* psa);

STDAPI_(UINT) SafeArrayGetDim(SAFEARRAY FAR* psa);

STDAPI_(UINT) SafeArrayGetElemsize(SAFEARRAY FAR* psa);

STDAPI
SafeArrayGetUBound(
    SAFEARRAY FAR* psa,
    UINT nDim,
    LONG FAR* plUbound);

STDAPI
SafeArrayGetLBound(
    SAFEARRAY FAR* psa,
    UINT nDim,
    LONG FAR* plLbound);

STDAPI SafeArrayLock(SAFEARRAY FAR* psa);

STDAPI SafeArrayUnlock(SAFEARRAY FAR* psa);

STDAPI SafeArrayAccessData(SAFEARRAY FAR* psa, void FAR* HUGEP* ppvData);

STDAPI SafeArrayUnaccessData(SAFEARRAY FAR* psa);

STDAPI
SafeArrayGetElement(
    SAFEARRAY FAR* psa,
    LONG FAR* rgIndices,
    void FAR* pv);

STDAPI
SafeArrayPutElement(
    SAFEARRAY FAR* psa,
    LONG FAR* rgIndices,
    void FAR* pv);

/* return a copy of the given SafeArray
 */
STDAPI
SafeArrayCopy(
    SAFEARRAY FAR* psa,
    SAFEARRAY FAR* FAR* ppsaOut);


/*---------------------------------------------------------------------*/
/*                           VARIANT API                               */
/*---------------------------------------------------------------------*/

STDAPI_(void)
VariantInit(
    VARIANTARG FAR* pvarg);

STDAPI
    VariantClear(VARIANTARG FAR* pvarg);

STDAPI
VariantCopy(
    VARIANTARG FAR* pvargDest,
    VARIANTARG FAR* pvargSrc);

STDAPI
VariantCopyInd(
    VARIANT FAR* pvarDest,
    VARIANTARG FAR* pvargSrc);

STDAPI
VariantChangeType(
    VARIANTARG FAR* pvargDest,
    VARIANTARG FAR* pvarSrc,
    WORD wFlags,
    VARTYPE vt);

#define VARIANT_NOVALUEPROP 1


/*---------------------------------------------------------------------*/
/*                             ITypeLib                                */
/*---------------------------------------------------------------------*/

typedef struct FARSTRUCT tagTLIBATTR {
    LCID lcid;			/* locale of the TypeLibrary */
    WORD wMajorVerNum;		/* major version number	*/
    WORD wMinorVerNum;		/* minor version number	*/
    GUID guid;			/* globally unique library id */
} TLIBATTR, FAR* LPTLIBATTR;


#undef  INTERFACE
#define INTERFACE ITypeLib

DECLARE_INTERFACE_(ITypeLib, IUnknown)
{
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* ITypeLib methods */
    STDMETHOD_(UINT,GetTypeInfoCount)(THIS) PURE;

    STDMETHOD(GetTypeInfo)(THIS_
      UINT index, ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetTypeInfoOfGuid)(THIS_
      REFGUID guid, ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetLibAttr)(THIS_
      TLIBATTR FAR* FAR* pptlibattr) PURE;

    STDMETHOD(GetTypeComp)(THIS_
      ITypeComp FAR* FAR* pptcomp) PURE;

    STDMETHOD(GetDocumentation)(THIS_
      int index,
      BSTR FAR* pbstrName,
      BSTR FAR* pbstrDocString,
      DWORD FAR* pdwHelpContext,
      BSTR FAR* pbstrHelpFile) PURE;

    STDMETHOD(IsName)(THIS_
      LPSTR szNameBuf, WORD wHashVal, BOOL FAR* pfName) PURE;

    STDMETHOD_(void, ReleaseTLibAttr)(THIS_ TLIBATTR FAR* ptlibattr) PURE;

    STDMETHOD(Load)(THIS_
      IStorage FAR* pstg, LPSTR szFileName) PURE;
};

typedef ITypeLib FAR* LPTYPELIB;


/*---------------------------------------------------------------------*/
/*                            ITypeInfo                                */
/*---------------------------------------------------------------------*/


typedef LONG DISPID;
typedef DISPID MEMBERID;

#define MEMBERID_NIL DISPID_UNKNOWN
#define ID_DEFAULTINST	-2

typedef DWORD HREFTYPE;

typedef enum tagTYPEKIND {
    TKIND_ENUM = 0,
    TKIND_RECORD,
    TKIND_MODULE,
    TKIND_INTERFACE,
    TKIND_DISPATCH,
    TKIND_COCLASS,
    TKIND_ALIAS,
    TKIND_UNION,
    TKIND_ENCUNION,
    TKIND_Class,
    TKIND_MAX			/* end of enum marker */
} TYPEKIND;


typedef struct FARSTRUCT tagTYPEDESC {
    VARTYPE vt;
    union {
      /* VT_PTR - the pointed-at type */
      struct FARSTRUCT tagTYPEDESC FAR* lptdesc;

      /* VT_CARRAY */
      struct FARSTRUCT tagARRAYDESC FAR* lpadesc;

      /* VT_USERDEFINED - this is used to get a TypeInfo for the UDT */
      HREFTYPE hreftype;
    }
#ifdef NONAMELESSUNION
    u
#endif
    ;
} TYPEDESC;


typedef struct FARSTRUCT tagARRAYDESC {
    TYPEDESC tdescElem;		/* element type */
    USHORT cDims;		/* dimension count */
    SAFEARRAYBOUND rgbounds[1];	/* variable length array of bounds */
} ARRAYDESC;


typedef struct FARSTRUCT tagIDLDESC {
    WORD wIDLFlags;		/* IN, OUT, etc */
    BSTR bstrIDLInfo;
} IDLDESC, FAR* LPIDLDESC;

#define IDLFLAG_NONE	0
#define IDLFLAG_FIN	0x1
#define IDLFLAG_FOUT	0x2

typedef struct FARSTRUCT tagELEMDESC {
    TYPEDESC tdesc;		/* the type of the element */
    IDLDESC idldesc;		/* info for remoting the element */ 
} ELEMDESC, FAR* LPELEMDESC;


typedef struct FARSTRUCT tagTYPEATTR {
    TYPEKIND typekind;		/* the kind of type this typeinfo describes */
    WORD wMajorVerNum;		/* major version number */
    WORD wMinorVerNum;		/* minor version number */
    LCID lcid;			/* locale of member names and doc strings */
    WORD cFuncs;		/* number of functions */
    WORD cVars;			/* number of variables / data members */
    WORD cImplTypes;		/* number of implemented interfaces */
    TYPEDESC tdescAlias;	/* if typekind == TKIND_ALIAS this field
				   specifies the type for which this type
				   is an alias */
    GUID guid;			/* the GUID of the TypeInfo */
    WORD wTypeFlags;
    DWORD dwReserved;
    WORD cbAlignment;		/* specifies the alignment requirements for
				   an instance of this type,
				     0 = align on 64k boundary
				     1 = byte align
				     2 = word align
				     4 = dword align... */
    WORD cbSizeInstance;	/* the size of an instance of this type */
    WORD cbSizeVft;		/* the size of this types virtual func table */
    IDLDESC idldescType;        /* IDL attributes of the described type */
    MEMBERID memidConstructor;	/* ID of constructor, MEMBERID_NIL if none */
    MEMBERID memidDestructor;	/* ID of destructor, MEMBERID_NIL if none */
} TYPEATTR, FAR* LPTYPEATTR;


typedef struct FARSTRUCT tagDISPPARAMS{
    VARIANTARG FAR* rgvarg;
    DISPID FAR* rgdispidNamedArgs;
    UINT cArgs;
    UINT cNamedArgs;
} DISPPARAMS;


typedef struct FARSTRUCT tagEXCEPINFO {
    WORD wCode;             /* An error code describing the error. */
    WORD wReserved;

    BSTR bstrSource;	    /* A textual, human readable name of the
			       source of the exception. It is up to the
			       IDispatch implementor to fill this in.
			       Typically this will be an application name. */

    BSTR bstrDescription;   /* A textual, human readable description of the
			       error. If no description is available, NULL
			       should be used. */

    BSTR bstrHelpFile;      /* Fully qualified drive, path, and file name
			       of a help file with more information about
			       the error.  If no help is available, NULL
			       should be used. */

    DWORD dwHelpContext;    /* help context of topic within the help file. */

    void FAR* pvReserved;

    HRESULT (STDAPICALLTYPE FAR* pfnDeferredFillIn)(struct tagEXCEPINFO FAR*);
			    /* Use of this field allows an application
			       to defer filling in the bstrDescription,
			       bstrHelpFile, and dwHelpContext fields
			       until they are needed.  This field might
			       be used, for example, if loading the
			       string for the error is a time-consuming
			       operation. If deferred fill-in is not
			       desired, this field should be set to NULL. */
    DWORD dwReserved;
} EXCEPINFO, FAR* LPEXCEPINFO;


typedef enum tagCALLCONV {
    CC_CDECL = 1,
    CC_MSCPASCAL,
    CC_PASCAL = CC_MSCPASCAL,
    CC_MACPASCAL,
    CC_STDCALL,
    CC_THISCALL,
    CC_MAX			/* end of enum marker */
} CALLCONV;


typedef enum tagFUNCKIND {
    FUNC_VIRTUAL,
    FUNC_PUREVIRTUAL,
    FUNC_NONVIRTUAL,
    FUNC_STATIC,
    FUNC_DISPATCH
} FUNCKIND;


/* Flags for IDispatch::Invoke */
#define DISPATCH_METHOD		0x1
#define DISPATCH_PROPERTYGET	0x2
#define DISPATCH_PROPERTYPUT	0x4
#define DISPATCH_PROPERTYPUTREF	0x8


typedef enum tagINVOKEKIND {
    INVOKE_FUNC = DISPATCH_METHOD,
    INVOKE_PROPERTYGET = DISPATCH_PROPERTYGET,
    INVOKE_PROPERTYPUT = DISPATCH_PROPERTYPUT,
    INVOKE_PROPERTYPUTREF = DISPATCH_PROPERTYPUTREF
} INVOKEKIND;


typedef struct FARSTRUCT tagFUNCDESC {
    MEMBERID memid;
    FUNCKIND funckind;
    INVOKEKIND invkind;
    CALLCONV callconv;
    SHORT cParams;
    SHORT cParamsOpt;
    SHORT oVft;
    WORD wFuncFlags;
    ELEMDESC elemdescFunc;
    ELEMDESC FAR* lprgelemdescParam;  /* array of parameter types */
    SHORT cScodes;
    SCODE FAR* lprgscode;
} FUNCDESC, FAR* LPFUNCDESC;


typedef enum tagVARKIND {
    VAR_PERINSTANCE,
    VAR_STATIC,
    VAR_CONST,
    VAR_DISPATCH
} VARKIND;


typedef struct FARSTRUCT tagVARDESC {
    MEMBERID memid;
    WORD wVarFlags;
    VARKIND varkind;
    ELEMDESC elemdescVar;
    union {
      ULONG oInst;		/* VAR_PERINSTANCE - the offset of this
				   variable within the instance */
      VARIANT FAR* lpvarValue;  /* VAR_CONST - the value of the constant */
    }
#ifdef NONAMELESSUNION
    u
#endif
    ;
} VARDESC, FAR* LPVARDESC;


typedef enum tagTYPEFLAGS {
    TYPEFLAG_FAPPOBJECT = 1,
    TYPEFLAG_FCANCREATE = 2
} TYPEFLAGS;


typedef enum tagFUNCFLAGS {
    FUNCFLAG_FRESTRICTED = 1
} FUNCFLAGS;


typedef enum tagVARFLAGS {
    VARFLAG_FREADONLY = 1
} VARFLAGS;


#undef  INTERFACE
#define INTERFACE ITypeInfo

DECLARE_INTERFACE_(ITypeInfo, IUnknown)
{
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* ITypeInfo methods */
    STDMETHOD(GetTypeAttr)(THIS_ TYPEATTR FAR* FAR* pptypeattr) PURE;

    STDMETHOD(GetTypeComp)(THIS_ ITypeComp FAR* FAR* pptcomp) PURE;

    STDMETHOD(GetFuncDesc)(THIS_
      UINT index, FUNCDESC FAR* FAR* ppfuncdesc) PURE;

    STDMETHOD(GetVarDesc)(THIS_
      UINT index, VARDESC FAR* FAR* ppvardesc) PURE;

    STDMETHOD(GetNames)(THIS_
      MEMBERID memid,
      BSTR FAR* rgbstrNames,
      UINT cMaxNames,
      UINT FAR* pcNames) PURE;

    STDMETHOD(GetRefTypeOfImplType)(THIS_
      UINT index, HREFTYPE FAR* phreftype) PURE;

    STDMETHOD(GetIDsOfNames)(THIS_
      char FAR* FAR* rgszNames, UINT cNames, MEMBERID FAR* rgmemid) PURE;

    STDMETHOD(Invoke)(THIS_
      void FAR* pvInstance,
      MEMBERID memid,
      WORD wFlags,
      DISPPARAMS FAR *pdispparams,
      VARIANT FAR *pvarResult,
      EXCEPINFO FAR *pexcepinfo,
      UINT FAR *puArgErr) PURE;

    STDMETHOD(GetDocumentation)(THIS_
      MEMBERID memid,
      BSTR FAR* pbstrName,
      BSTR FAR* pbstrDocString,
      DWORD FAR* pdwHelpContext,
      BSTR FAR* pbstrHelpFile) PURE;

    STDMETHOD(GetDllEntry)(THIS_
      MEMBERID memid,
      BSTR FAR* pbstrDllName,
      BSTR FAR* pbstrName,
      WORD FAR* pwOrdinal) PURE;

    STDMETHOD(GetRefTypeInfo)(THIS_
      HREFTYPE hreftype, ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(AddressOfMember)(THIS_
      MEMBERID memid, INVOKEKIND invkind, void FAR* FAR* ppv) PURE;

    STDMETHOD(CreateInstance)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;

    STDMETHOD(GetMops)(THIS_ MEMBERID memid, BSTR FAR* pbstrMops) PURE;

    STDMETHOD(GetContainingTypeLib)(THIS_
      ITypeLib FAR* FAR* pptlib, UINT FAR* pindex) PURE;

    STDMETHOD_(void, ReleaseTypeAttr)(THIS_ TYPEATTR FAR* ptypeattr) PURE;
    STDMETHOD_(void, ReleaseFuncDesc)(THIS_ FUNCDESC FAR* pfuncdesc) PURE;
    STDMETHOD_(void, ReleaseVarDesc)(THIS_ VARDESC FAR* pvardesc) PURE;
};

typedef ITypeInfo FAR* LPTYPEINFO;


/*---------------------------------------------------------------------*/
/*                            ITypeComp                                */
/*---------------------------------------------------------------------*/


typedef enum tagDESCKIND {
    DESCKIND_NONE = 0,
    DESCKIND_FUNCDESC,
    DESCKIND_VARDESC,
    DESCKIND_TYPECOMP,
    DESCKIND_MAX		/* end of enum marker */
} DESCKIND;


typedef union tagBINDPTR {
    FUNCDESC FAR* lpfuncdesc;
    VARDESC FAR* lpvardesc;
    ITypeComp FAR* lptcomp;
} BINDPTR, FAR* LPBINDPTR;


#undef  INTERFACE
#define INTERFACE ITypeComp

DECLARE_INTERFACE_(ITypeComp, IUnknown)
{
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* ITypeComp methods */
    STDMETHOD(Bind)(THIS_
      LPSTR szName,
      WORD wHashVal,
      WORD wflags,
      ITypeInfo FAR* FAR* pptinfo,
      DESCKIND FAR* pdesckind,
      BINDPTR FAR* pbindptr) PURE;

    STDMETHOD(BindType)(THIS_
      LPSTR szName,
      WORD wHashVal,
      ITypeInfo FAR* FAR* pptinfo,
      ITypeComp FAR* FAR* pptcomp) PURE;
};

typedef ITypeComp FAR* LPTYPECOMP;


/*---------------------------------------------------------------------*/
/*                         ICreateTypeLib                              */
/*---------------------------------------------------------------------*/


#undef  INTERFACE
#define INTERFACE ICreateTypeLib

DECLARE_INTERFACE_(ICreateTypeLib, IUnknown)
{
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* ICreateTypeLib methods */
    STDMETHOD(CreateTypeInfo)(THIS_
      LPSTR szName,
      TYPEKIND tkind,
      ICreateTypeInfo FAR* FAR* lplpictinfo) PURE;

    STDMETHOD(SetName)(THIS_ LPSTR szName) PURE;

    STDMETHOD(SetVersion)(THIS_
      WORD wMajorVerNum, WORD wMinorVerNum) PURE;

    STDMETHOD(SetGuid) (THIS_ REFGUID guid) PURE;

    STDMETHOD(SetDocString)(THIS_ LPSTR szDoc) PURE;

    STDMETHOD(SetHelpFileName)(THIS_ LPSTR szHelpFileName) PURE;

    STDMETHOD(SetHelpContext)(THIS_ DWORD dwHelpContext) PURE;

    STDMETHOD(SetLcid)(THIS_ LCID lcid) PURE;

    STDMETHOD(SaveAllChanges)(THIS_ IStorage FAR* pstg) PURE;
};

typedef ICreateTypeLib FAR* LPCREATETYPELIB;


/*---------------------------------------------------------------------*/
/*                         ICreateTypeInfo                             */
/*---------------------------------------------------------------------*/

#undef  INTERFACE
#define INTERFACE ICreateTypeInfo

DECLARE_INTERFACE_(ICreateTypeInfo, IUnknown)
{
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* ICreateTypeInfo methods */
    STDMETHOD(SetGuid)(THIS_ REFGUID guid) PURE;

    STDMETHOD(SetTypeFlags)(THIS_ UINT uTypeFlags) PURE;

    STDMETHOD(SetDocString)(THIS_ LPSTR pstrDoc) PURE;

    STDMETHOD(SetHelpContext)(THIS_ DWORD dwHelpContext) PURE;

    STDMETHOD(SetVersion)(THIS_
      WORD wMajorVerNum, WORD wMinorVerNum) PURE;

    STDMETHOD(AddRefTypeInfo)(THIS_
      ITypeInfo FAR* ptinfo, HREFTYPE FAR* phreftype) PURE;

    STDMETHOD(AddFuncDesc)(THIS_
      UINT index, FUNCDESC FAR* pfuncdesc) PURE;

    STDMETHOD(AddImplType)(THIS_
      UINT index, HREFTYPE hreftype) PURE;

    STDMETHOD(AddVarDesc)(THIS_
      UINT index, VARDESC FAR* pvardesc) PURE;

    STDMETHOD(SetFuncAndParamNames)(THIS_
      UINT index, LPSTR FAR* rgszNames, UINT cNames) PURE;

    STDMETHOD(SetVarName)(THIS_
      UINT index, LPSTR szName) PURE;

    STDMETHOD(SetTypeDescAlias)(THIS_
      TYPEDESC FAR* ptdescAlias) PURE;

    STDMETHOD(DefineFuncAsDllEntry)(THIS_
      UINT index, LPSTR szDllName, LPSTR szProcName) PURE;

    STDMETHOD(SetFuncDocString)(THIS_
      UINT index, LPSTR szDocString) PURE;

    STDMETHOD(SetVarDocString)(THIS_
      UINT index, LPSTR szDocString) PURE;

    STDMETHOD(SetFuncHelpContext)(THIS_
      UINT index, DWORD dwHelpContext) PURE;

    STDMETHOD(SetVarHelpContext)(THIS_
      UINT index, DWORD dwHelpContext) PURE;

    STDMETHOD(SetMops)(THIS_
      UINT index, BSTR bstrMops) PURE;

    STDMETHOD(SetTypeIdldesc)(THIS_
      IDLDESC FAR* pidldesc) PURE;

    STDMETHOD(LayOut)(THIS) PURE;
};

typedef ICreateTypeInfo FAR* LPCREATETYPEINFO;

/*---------------------------------------------------------------------*/
/*                         TypeInfo APIs                               */
/*---------------------------------------------------------------------*/


/* compute a 16bit hash value for the given name
 */
STDAPI_(WORD)
WHashValOfName(LPSTR szName);

/* load the typelib from the file with the given filename
 */
STDAPI
LoadTypeLib(LPSTR szFile, ITypeLib FAR* FAR* pptlib);

/* load registered typelib
 */
STDAPI
LoadRegTypeLib(
    REFGUID rguid,
    WORD wVerMajor,
    WORD wVerMinor,
    LCID lcid,
    ITypeLib FAR* FAR* pptlib);

/* add typelib to registry
 */
STDAPI
RegisterTypeLib(ITypeLib FAR* ptlib, LPSTR szFullPath, LPSTR szHelpDir);

/* remove typelib from registry
 */
STDAPI
DeregisterTypeLib(REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid);

typedef enum tagSYSKIND {
    SYS_WIN16,
    SYS_WIN32,
    SYS_MAC
} SYSKIND;

STDAPI
CreateTypeLib(SYSKIND syskind, ICreateTypeLib FAR* FAR* ppctlib);


/*---------------------------------------------------------------------*/
/*                          IEnumVARIANT                               */
/*---------------------------------------------------------------------*/

#undef  INTERFACE
#define INTERFACE IEnumVARIANT

DECLARE_INTERFACE_(IEnumVARIANT, IUnknown)
{
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IEnumVARIANT methods */
    STDMETHOD(Next)(
      THIS_ ULONG celt, VARIANT FAR* rgvar, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone)(THIS_ IEnumVARIANT FAR* FAR* ppenum) PURE;
};

typedef IEnumVARIANT FAR* LPENUMVARIANT;


/*---------------------------------------------------------------------*/
/*                             IDispatch                               */
/*---------------------------------------------------------------------*/


#undef  INTERFACE
#define INTERFACE IDispatch

DECLARE_INTERFACE_(IDispatch, IUnknown)
{
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      char FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
};

typedef IDispatch FAR* LPDISPATCH;


/* DISPID reserved for the standard "value" property */
#define DISPID_VALUE	0

/* DISPID reserved to indicate an "unknown" name */
#define DISPID_UNKNOWN	-1

/* The following DISPID is reserved to indicate the param
 * that is the right-hand-side (or "put" value) of a PropertyPut
 */
#define DISPID_PROPERTYPUT -3

/* DISPID reserved for the standard "NewEnum" method */
#define DISPID_NEWENUM	-4

/* DISPID reserved for the standard "Evaluate" method */
#define DISPID_EVALUATE	-5


/*---------------------------------------------------------------------*/
/*                   IDispatch implementation support                  */
/*---------------------------------------------------------------------*/

typedef struct FARSTRUCT tagPARAMDATA {
    char FAR* szName;		/* parameter name */
    VARTYPE vt;			/* parameter type */
} PARAMDATA, FAR* LPPARAMDATA;

typedef struct FARSTRUCT tagMETHODDATA {
    char FAR* szName;		/* method name */
    PARAMDATA FAR* ppdata;	/* pointer to an array of PARAMDATAs */
    DISPID dispid;		/* method ID */
    UINT iMeth;			/* method index */
    CALLCONV cc;		/* calling convention */
    UINT cArgs;			/* count of arguments */
    WORD wFlags;		/* same wFlags as on IDispatch::Invoke() */
    VARTYPE vtReturn;
} METHODDATA, FAR* LPMETHODDATA;

typedef struct FARSTRUCT tagINTERFACEDATA {
    METHODDATA FAR* pmethdata;	/* pointer to an array of METHODDATAs */
    UINT cMembers;		/* count of members */
} INTERFACEDATA, FAR* LPINTERFACEDATA;



/* Locate the parameter indicated by the given position, and
 * return it coerced to the given target VARTYPE (vtTarg).
 */
STDAPI
DispGetParam(
    DISPPARAMS FAR* pdispparams,
    UINT position,
    VARTYPE vtTarg,
    VARIANT FAR* pvarResult,
    UINT FAR* puArgErr);

/* Automatic TypeInfo driven implementation of IDispatch::GetIDsOfNames()
 */ 
STDAPI
DispGetIDsOfNames(
    ITypeInfo FAR* ptinfo,
    char FAR* FAR* rgszNames,
    UINT cNames,
    DISPID FAR* rgdispid);

/* Automatic TypeInfo driven implementation of IDispatch::Invoke()
 */
STDAPI
DispInvoke(
    void FAR* _this,
    ITypeInfo FAR* ptinfo,
    DISPID dispidMember,
    WORD wFlags,
    DISPPARAMS FAR* pparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr);

/* Construct a TypeInfo from an interface data description
 */
STDAPI
CreateDispTypeInfo(
    INTERFACEDATA FAR* pidata,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo);

/* Create an instance of the standard TypeInfo driven IDispatch
 * implementation.
 */
STDAPI
CreateStdDispatch(
    IUnknown FAR* punkOuter,
    void FAR* pvThis,
    ITypeInfo FAR* ptinfo,
    IUnknown FAR* FAR* ppunkStdDisp);


/*---------------------------------------------------------------------*/
/*                    Active Object Registration API                   */
/*---------------------------------------------------------------------*/


STDAPI
RegisterActiveObject(
   IUnknown FAR* punk,
   REFCLSID rclsid,
   void FAR* pvReserved,
   DWORD FAR* pdwRegister);

STDAPI
RevokeActiveObject(
    DWORD dwRegister,
    void FAR* pvReserved);

STDAPI
GetActiveObject(
    REFCLSID rclsid,
    void FAR* pvReserved,
    IUnknown FAR* FAR* ppunk);


#endif /* _DISPATCH_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the library
*   functions related to directory handling and creation.
*
****/

#ifndef _INC_DIRECT

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

/* function prototypes */

int __cdecl _chdir(const char *);
int __cdecl _chdrive(int);
char * __cdecl _getcwd(char *, int);
char * __cdecl _getdcwd(int, char *, int);
int __cdecl _getdrive(void);
int __cdecl _mkdir(const char *);
int __cdecl _rmdir(const char *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl chdir(const char *);
char * __cdecl getcwd(char *, int);
int __cdecl mkdir(const char *);
int __cdecl rmdir(const char *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_DIRECT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\dlgs.h ===
/*****************************************************************************\
*                                                                             *
* dlgs.h -      Common dialog's dialog element ID numbers                     *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_DLGS
#define _INC_DLGS

#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define pshNetwork  psh14
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544
#define RUNDLGORD        1545

#endif  /* !_INC_DLGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\dispdib.h ===
/****************************************************************************/
/*                                                                          */
/*        DISPDIB.H - Include file for DisplayDib() function.               */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/


// DisplayDib() error return codes
#define DISPLAYDIB_NOERROR          0x0000  // success
#define DISPLAYDIB_NOTSUPPORTED     0x0001  // function not supported
#define DISPLAYDIB_INVALIDDIB       0x0002  // null or invalid DIB header
#define DISPLAYDIB_INVALIDFORMAT    0x0003  // invalid DIB format
#define DISPLAYDIB_INVALIDTASK      0x0004  // not called from current task
#define DISPLAYDIB_STOP             0x0005  // stop requested

// flags for <wFlags> parameter of DisplayDib()
#define DISPLAYDIB_NOPALETTE        0x0010  // don't set palette
#define DISPLAYDIB_NOCENTER         0x0020  // don't center image
#define DISPLAYDIB_NOWAIT           0x0040  // don't wait before returning
#define DISPLAYDIB_NOIMAGE          0x0080  // don't draw image
#define DISPLAYDIB_ZOOM2            0x0100  // stretch by 2
#define DISPLAYDIB_DONTLOCKTASK     0x0200  // don't lock current task
#define DISPLAYDIB_TEST             0x0400  // testing the command
#define DISPLAYDIB_NOFLIP           0x0800  // dont page flip
#define DISPLAYDIB_BEGIN            0x8000  // start of multiple calls
#define DISPLAYDIB_END              0x4000  // end of multiple calls

#define DISPLAYDIB_MODE             0x000F  // mask for display mode
#define DISPLAYDIB_MODE_DEFAULT     0x0000  // default display mode
#define DISPLAYDIB_MODE_320x200x8   0x0001  // 320-by-200
#define DISPLAYDIB_MODE_320x240x8   0x0005  // 320-by-240

#ifdef WIN32
// flags for the 32 bit version of DisplayDibEx
#define DISPLAYDIB_ANIMATE          0x00010000
#define DISPLAYDIB_HALFTONE         0x00020000
#endif


// function prototypes
UINT FAR PASCAL DisplayDib(LPBITMAPINFOHEADER lpbi, LPSTR lpBits, WORD wFlags);
UINT FAR PASCAL DisplayDibEx(LPBITMAPINFOHEADER lpbi, int x, int y, LPSTR lpBits, WORD wFlags);

#define DisplayDibBegin() DisplayDib(NULL, NULL, DISPLAYDIB_BEGIN)
#define DisplayDibEnd()   DisplayDib(NULL, NULL, DISPLAYDIB_END)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Defines the structs and unions used for the direct DOS interface
*   routines; includes macros to access the segment and offset
*   values of far pointers, so that they may be used by the routines; and
*   provides function prototypes for direct DOS interface functions.
*
****/

#ifndef _INC_DOS

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __interrupt _interrupt
#define __near      _near
#endif 

#ifndef _REGS_DEFINED

/* word registers */

struct _WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct _BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union _REGS {
    struct _WORDREGS x;
    struct _BYTEREGS h;
    };

/* segment registers */

struct _SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#endif 

#define _REGS_DEFINED
#endif 


/* dosexterror structure */

#ifndef _DOSERROR_DEFINED
#pragma pack(2)

struct _DOSERROR {
    int exterror;
    char errclass;
    char action;
    char locus;
    };

#if ((!defined (__STDC__)) && (!defined (__cplusplus)))
/* Non-ANSI name for compatibility */
struct DOSERROR {
    int exterror;
    char class;
    char action;
    char locus;
    };
#endif 

#pragma pack()
#define _DOSERROR_DEFINED
#endif 


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED
#pragma pack(2)

struct _find_t {
    char reserved[21];
    char attrib;
    unsigned wr_time;
    unsigned wr_date;
    long size;
    char name[13];
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define find_t _find_t
#endif 

#pragma pack()
#define _FIND_T_DEFINED
#endif 


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED
#pragma pack(2)

struct _dosdate_t {
    unsigned char day;      /* 1-31 */
    unsigned char month;        /* 1-12 */
    unsigned int year;      /* 1980-2099 */
    unsigned char dayofweek;    /* 0-6, 0=Sunday */
    };

struct _dostime_t {
    unsigned char hour; /* 0-23 */
    unsigned char minute;   /* 0-59 */
    unsigned char second;   /* 0-59 */
    unsigned char hsecond;  /* 0-99 */
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define dosdate_t _dosdate_t
#define dostime_t _dostime_t
#endif 

#pragma pack()
#define _DATETIME_T_DEFINED
#endif 


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
    unsigned total_clusters;
    unsigned avail_clusters;
    unsigned sectors_per_cluster;
    unsigned bytes_per_sector;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t _diskfree_t
#endif 

#define _DISKFREE_T_DEFINED
#endif 


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE     0   /* Ignore the error */
#define _HARDERR_RETRY      1   /* Retry the operation */
#define _HARDERR_ABORT      2   /* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL       3   /* Fail the system call in progress */
                    /* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL   0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY   0x01    /* Read only file */
#define _A_HIDDEN   0x02    /* Hidden file */
#define _A_SYSTEM   0x04    /* System file */
#define _A_VOLID    0x08    /* Volume ID file */
#define _A_SUBDIR   0x10    /* Subdirectory */
#define _A_ARCH     0x20    /* Archive file */

/* macros to break C "far" pointers into their segment and offset components
 */

#define _FP_SEG(fp) (*((unsigned __far *)&(fp)+1))
#define _FP_OFF(fp) (*((unsigned __far *)&(fp)))

/* macro to construct a far pointer from segment and offset values
 */

#define _MK_FP(seg, offset) (void __far *)(((unsigned long)seg << 16) \
    + (unsigned long)(unsigned)offset)

/* external variable declarations */

extern unsigned int __near __cdecl _osversion;


/* function prototypes */

#ifndef _MT
int __cdecl _bdos(int, unsigned int, unsigned int);
#ifndef _WINDOWS
void __cdecl _chain_intr(void (__cdecl __interrupt __far *)());
#endif 
void __cdecl _disable(void);
#ifndef _WINDOWS
unsigned __cdecl _dos_allocmem(unsigned, unsigned *);
#endif 
unsigned __cdecl _dos_close(int);
unsigned __cdecl _dos_commit(int);
unsigned __cdecl _dos_creat(const char *, unsigned, int *);
unsigned __cdecl _dos_creatnew(const char *, unsigned, int *);
unsigned __cdecl _dos_findfirst(const char *, unsigned, struct _find_t *);
unsigned __cdecl _dos_findnext(struct _find_t *);
#ifndef _WINDOWS
unsigned __cdecl _dos_freemem(unsigned);
#endif 
void __cdecl _dos_getdate(struct _dosdate_t *);
void __cdecl _dos_getdrive(unsigned *);
unsigned __cdecl _dos_getdiskfree(unsigned, struct _diskfree_t *);
unsigned __cdecl _dos_getfileattr(const char *, unsigned *);
unsigned __cdecl _dos_getftime(int, unsigned *, unsigned *);
void __cdecl _dos_gettime(struct _dostime_t *);
void (__cdecl __interrupt __far * __cdecl _dos_getvect(unsigned))();
#ifndef _WINDOWS
void __cdecl _dos_keep(unsigned, unsigned);
#endif 
unsigned __cdecl _dos_lock(int, int, unsigned long, unsigned long);
unsigned __cdecl _dos_open(const char *, unsigned, int *);
unsigned __cdecl _dos_read(int, void __far *, unsigned, unsigned *);
unsigned long __cdecl _dos_seek(int, unsigned long, int);
#ifndef _WINDOWS
unsigned __cdecl _dos_setblock(unsigned, unsigned, unsigned *);
#endif 
unsigned __cdecl _dos_setdate(struct _dosdate_t *);
void __cdecl _dos_setdrive(unsigned, unsigned *);
unsigned __cdecl _dos_setfileattr(const char *, unsigned);
unsigned __cdecl _dos_setftime(int, unsigned, unsigned);
unsigned __cdecl _dos_settime(struct _dostime_t *);
#ifndef _WINDOWS
void __cdecl _dos_setvect(unsigned, void (__cdecl __interrupt __far *)());
#endif 
unsigned __cdecl _dos_write(int, const void __far *, unsigned, unsigned *);
int __cdecl _dosexterr(struct _DOSERROR *);
void __cdecl _enable(void);
#ifndef _WINDOWS
void __cdecl _harderr(void (__far __cdecl *)(unsigned, unsigned,
    unsigned __far *));
void __cdecl _hardresume(int);
void __cdecl _hardretn(int);
#endif 
int __cdecl _intdos(union _REGS *, union _REGS *);
int __cdecl _intdosx(union _REGS *, union _REGS *, struct _SREGS *);
int __cdecl _int86(int, union _REGS *, union _REGS *);
int __cdecl _int86x(int, union _REGS *, union _REGS *, struct _SREGS *);
#endif 

void __cdecl _segread(struct _SREGS *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define FP_SEG     _FP_SEG
#define FP_OFF     _FP_OFF
#define MK_FP      _MK_FP

#ifndef _MT
int __cdecl bdos(int, unsigned int, unsigned int);
int __cdecl intdos(union REGS *, union REGS *);
int __cdecl intdosx(union REGS *, union REGS *, struct SREGS *);
int __cdecl int86(int, union REGS *, union REGS *);
int __cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#ifndef __cplusplus
int __cdecl dosexterr(struct DOSERROR *);
#endif 
#endif 
void __cdecl segread(struct SREGS *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_DOS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\doserr.h ===
//***************************************************************************
//
// DOSERR.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1993
//  All rights reserved
//
// DOS int 21h error codes.
//
//**************************************************************************/

#ifndef DOSERR_INC

#define NO_ERROR                        0

#define ERROR_INVALID_FUNCTION          1
#define ERROR_FILE_NOT_FOUND            2
#define ERROR_PATH_NOT_FOUND            3
#define ERROR_TOO_MANY_OPEN_FILES       4
#define ERROR_ACCESS_DENIED             5
#define ERROR_INVALID_HANDLE            6
#define ERROR_ARENA_TRASHED             7
#define ERROR_NOT_ENOUGH_MEMORY         8
#define ERROR_INVALID_BLOCK             9
#define ERROR_BAD_ENVIRONMENT           10
#define ERROR_BAD_FORMAT                11
#define ERROR_INVALID_ACCESS            12
#define ERROR_INVALID_DATA              13
/* 14 is reserved                        */
#define ERROR_INVALID_DRIVE             15
#define ERROR_CURRENT_DIRECTORY         16
#define ERROR_NOT_SAME_DEVICE           17
#define ERROR_NO_MORE_FILES             18
#define ERROR_WRITE_PROTECT             19
#define ERROR_BAD_UNIT                  20
#define ERROR_NOT_READY                 21
#define ERROR_BAD_COMMAND               22
#define ERROR_CRC                       23
#define ERROR_BAD_LENGTH                24
#define ERROR_SEEK                      25
#define ERROR_NOT_DOS_DISK              26
#define ERROR_SECTOR_NOT_FOUND          27
#define ERROR_OUT_OF_PAPER              28
#define ERROR_WRITE_FAULT               29
#define ERROR_READ_FAULT                30
#define ERROR_GEN_FAILURE               31
#define ERROR_SHARING_VIOLATION         32
#define ERROR_LOCK_VIOLATION            33
#define ERROR_WRONG_DISK                34
#define ERROR_FCB_UNAVAILABLE           35
#define ERROR_SHARING_BUFFER_EXCEEDED   36
#define ERROR_NOT_SUPPORTED             50
#define ERROR_REM_NOT_LIST              51 /* Remote computer not listening   */
#define ERROR_DUP_NAME                  52 /* Duplicate name on network       */
#define ERROR_BAD_NETPATH               53 /* Network path not found          */
#define ERROR_NETWORK_BUSY              54 /* Network busy                    */
#define ERROR_DEV_NOT_EXIST             55 /* Network device no longer exists */
#define ERROR_TOO_MANY_CMDS             56 /* Net BIOS command limit exceeded */
#define ERROR_ADAP_HDW_ERR              57 /* Network adapter hardware error  */
#define ERROR_BAD_NET_RESP              58 /* Incorrect response from network */
#define ERROR_UNEXP_NET_ERR             59 /* Unexpected network error        */
#define ERROR_BAD_REM_ADAP              60 /* Incompatible remote adapter     */
#define ERROR_PRINTQ_FULL               61 /* Print queue full                */
#define ERROR_NO_SPOOL_SPACE            62 /* Not enough space for print file */
#define ERROR_PRINT_CANCELLED           63 /* Print file was cancelled        */
#define ERROR_NETNAME_DELETED           64 /* Network name was deleted        */
#define ERROR_NETWORK_ACCESS_DENIED     65 /* Access denied                   */
#define ERROR_BAD_DEV_TYPE              66 /* Network device type incorrect   */
#define ERROR_BAD_NET_NAME              67 /* Network name not found          */
#define ERROR_TOO_MANY_NAMES            68 /* Network name limit exceeded     */
#define ERROR_TOO_MANY_SESS             69 /* Net BIOS session limit exceeded */
#define ERROR_SHARING_PAUSED            70 /* Sharing temporarily paused      */
#define ERROR_REQ_NOT_ACCEP             71 /* Network request not accepted    */
#define ERROR_REDIR_PAUSED              72 /* Print|disk redirection is paused*/
#define ERROR_FILE_EXISTS               80
#define ERROR_DUP_FCB                   81
#define ERROR_CANNOT_MAKE               82
#define ERROR_FAIL_I24                  83
#define ERROR_OUT_OF_STRUCTURES         84
#define ERROR_ALREADY_ASSIGNED          85
#define ERROR_INVALID_PASSWORD          86
#define ERROR_INVALID_PARAMETER         87
#define ERROR_NET_WRITE_FAULT           88
#define ERROR_SYS_COMP_NOT_LOADED       90


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\dosdll.h ===
//*********************************************************************
//
//	DOSDLL.H
//
//		Copyright (c) 1992 - Microsoft Corp.
//		All rights reserved.
//		Microsoft Confidential
//
//	This header file contains the typedefs and #defines needed when
//	calling into and calling back from a DOS type DLL.
//
// PROGRAMMER CAVEAT:
//		Remember that all pointers in the DLL must be far because
//		the C runtime libraries which use near pointers always assume
//		that DS == SS which is not the case with a DLL.
//*********************************************************************

#define			CMD_YIELD		0		// Standard callback cmd to call Yield()
#define			SIGNAL_ABORT	1		// Signal to abort DLL process

//*********************************************************************
//	Windows memory allocation functions used in the implementation
// of GetMemory() and FreeMemory().
//*********************************************************************

#ifndef	GMEM_FIXED
	#define	GMEM_FIXED		0

	unsigned		_far _pascal GlobalAlloc( unsigned Flags, unsigned long Bytes );
	unsigned		_far _pascal GlobalFree( unsigned );
	void *		_far _pascal GlobalLock( unsigned );
	unsigned		_far _pascal GlobalUnlock( unsigned );
	unsigned long _far _pascal GlobalHandle( unsigned );

#endif

//#define	DllYield()	((void)(*CallBackAddr)( NULL, CMD_YIELD, 0, 0, 0, 0 ))

//*********************************************************************
// TO_DLL		- Declaration for a DLL entry function.
// TO_DLL_PTR	- Declaration for a pointer to a DLL entry function.
//*********************************************************************

// #define	TO_DLL unsigned long _far _cdecl
typedef	unsigned	long _far _cdecl TO_DLL( unsigned, unsigned, ... );

typedef	unsigned long (_far _cdecl *TO_DLL_PTR)();

//*********************************************************************
// FROM_DLL		- Declaration for a callback dispatcher function.
// FROM_DLL_PTR- Declaration for a pointer to a callback dispatcher funct.
//	FROM_DLL_ARGS- Argument prototype for callback dispatcher function.
//*********************************************************************

#define	FROM_DLL	unsigned long _loadds _far _pascal
#define  FROM_DLL_ARGS	CB_FUNC_PTR,unsigned,unsigned,unsigned long,unsigned, unsigned
typedef	unsigned long (_loadds _far _pascal *FROM_DLL_PTR)();

//*********************************************************************
//	CB_FUNC		- Declaration for a callback function.
// CB_FUNC_PTR	- Declaration for a pointer to a callback function.
//	CB_FUNC_ARGS- Argument prototype for callback function.
//*********************************************************************

#define	CB_FUNC	unsigned long _far
#define	CB_FUNC_ARGS	unsigned,unsigned,unsigned long
typedef	unsigned long (_far *CB_FUNC_PTR)();

//*********************************************************************

#define	PTR_TYPE					FPTR_TYPE
#define	SZPTR_TYPE				FSZPTR_TYPE
#define	CODE_PTR_TYPE			DWORD_TYPE

//*********************************************************************

#define	WORD_TYPE				00
#define	DWORD_TYPE				01U
#define	NPTR_TYPE				02U
#define	FPTR_TYPE				03U
#define	NSZPTR_TYPE				04U
#define	FSZPTR_TYPE				05U
#define	VARI_TYPE				07U

#define	TRANS_NONE				00
#define	TRANS_SRC				(01U << 14)
#define	TRANS_DEST				(02U << 14)
#define	TRANS_BOTH				(03U << 14)

#define	LEN_SHIFT				12

//*********************************************************************
//	DllCall()	- Entry function for call DLL.
//	CallBack()	- Function in control program which dispatches callbacks
//*********************************************************************

// TO_DLL DllCall( unsigned Cmd, unsigned ArgCount, unsigned Descriptor, ... );

// FROM_DLL CallBack( unsigned long (_far *Func)(CB_FUNC_ARGS),
//						 unsigned Cmd, unsigned uParam, unsigned long lParam,
//						 unsigned Descriptor, unsigned Size );

//*********************************************************************
//	The following #defines are used to simulate a function call from the
//	control program to the DLL. There is only one entry point into the
//	DLL so a function number is used to specify the function being called.
//	A complete and detailed description of how the transport descriptors
//	should be specified is in ENTRY.ASM.
//
// PROGRAMMER CAVEAT:
//		Remember that these are #defines and not function prototypes
//		so all references to types must be done as casts....
// 	Also remember that any pointer to data must be FAR because
//		DS is always set to the DLL  own heap on entry and SS != DS.
//*********************************************************************

#define	DLL_SIGNAL				0				// DllSignal()
#define	DLL_SET_CALLBACK		1				// SetCallBackAddr()
#define	DLL_COPY					2				// DllCopyMain()
#define	DLL_DELETE				3				// DllDeleteMain()
#define	DLL_DIR					4				// DllDirMain()

#define	DLL_GET_DISK_FREE		5				// DllGetDiskFree()
#define	DLL_LOAD_MSGS			6				// DllLoadMsgs()
#define	DLL_LOAD_STRING		7				// DllLoadString()

#define	DLL_EXT_OPEN_FILE		8				// DllDosExtOpen()
#define	DLL_OPEN_FILE			9				// DllDosOpen()
#define	DLL_READ_FILE			10				// DllDosRead()
#define	DLL_WRITE_FILE			11				// DllDosWrite()
#define	DLL_CLOSE_FILE			12				// DllDosClose()
#define	DLL_SEEK_FILE			13				// DllDosSeek()

#define	DLL_GET_MEDIA_ID		14				// DllDosGetMediaId()

#define	DLL_GET_CWD_ID			15				// DllGetCwd()
#define	DLL_SET_CWD_ID			16				// DllSetCwd()
#define	DLL_GET_DRV_ID			17				// DllGetDrive()
#define	DLL_SET_DRV_ID			18				// DllSetDrive()

#define	DLL_MKDIR				19				// DllMakeDir()
#define	DLL_RMDIR				20				// DllRemoveDir()
#define	DLL_MKDIR_TREE			21				// DllCreateDirTree()

#define	DLL_RENAME				22				// DllRenameFiles()
#define	DLL_MOVE					23				// DllRenameFiles()

#define	DLL_FIND					24				// DllFindFiles()
#define	DLL_TOUCH				25				// DllTouchFiles()
#define	DLL_ATTRIB				26				// DllAttribFiles()
#define	DLL_SET_CNTRY_INF		27				// DllSetCntryInfo()
#define	DLL_RELEASE				28				// DllReleaseInstance()

//*********************************************************************
//	DLL function which is called by the user of the DLL to set a global
//	callback address where all callback will be routed thru. The
//	callback function must follow the criteria exampled in CB_ENTRY.ASM.
//	This function will initialize the SignalValue and the DOS version
//	number.
//
//	void DllSetCallBackAddr( long (far cdecl *FuncPtr)() )
//
//	ARGUMENTS:
//		FunctPtr		- Pointer to callback entry function (TO_DLL_PTR)
//	RETURNS:
//		int			- OK
//
//*********************************************************************

#define DllSetCallBackAddr( CallBackAddr )\
				((void)(*DllEntry)( DLL_SET_CALLBACK, 1,\
				DWORD_TYPE + TRANS_NONE,\
				CallBackAddr ))

//*********************************************************************
//	DLL function to set a signal value which will cause the currently
//	executing function to abort and return an error code. If the
//	SignalValue is < 0 it will be returned returned unchanged as the
//	error code. If the value > 0 it will be considered a user abort
//	and ERR_USER_ABORT will be returned.
//
//	void DllSignal( int Signal )
//
//	ARGUMENTS:
//		Signal		- Signal value.
//	RETURNS:
//		void
//
//*********************************************************************

#define DllSignal( x )\
				((void)(*DllEntry)( DLL_SIGNAL, 1,\
				WORD_TYPE + TRANS_NONE,\
				(int)x ))

//*********************************************************************
//	Main entry point for the copy/move engine. Accepts a command line and
//	copies the files meeting the specified criteria.
//
//	int DllCopyFiles( char *szCmdLine, char *szEnvStr, CPY_CALLBACK CpyCallBack )
//	int DllMoveFiles( char *szCmdLine, char *szEnvStr, CPY_CALLBACK CpyCallBack )
//
//	ARGUMENTS:
//		szCmdLine	- Ptr to command line string, less command name
//		szEnvStr		- Ptr to optional enviroment cmd string or NULL
//		CpyCallBack	- Ptr to copy callback function.
//	RETURNS:
//		int			- OK if all files copies successfull else error code
//						  which is < 0 if a parse error and > 0 if a DOS
//						  or C runtime error.
//	
//	szCmdLine is ptr to commandline string.
//
//		"srcfiles [dest] [SrchCriteria] [/E][/M][/N][/P][/R][/S][/U][/V][/W]
//
//  	source       Specifies the file or files to be copied.
//  	             and may be substituted with /F:filename
//  	             to use filespecs from a text file.
//
//  	destination  Specifies the directory and/or filename
//  	             for the new file(s).
//
//  	SrchCriteria Any extended search criteria supported by
//  	             by the findfile engine.
//
//		/C   Confirm on overwrite of existing file.
//
//		/D   Prompt for next disk when current on is full
//
//  	/E   Copies any subdirectories, even if empty.
//
//  	/M   Turns the source files archive attribute bit off after
//  	     copying the file.
//
//  	/N   Adds new files to destination directory. "CAN" be used
//  	     with /S or /U switches.
//
//		/O   Replace existing files regardless of date not compable
//         with /N or /U.
//
//  	/P   Prompts for confirmation before copying each file.
//
//  	/R   Overwrites read-only files as well as reqular files.
//
//  	/S   Copies files from specified directory and it's
//  	     subdirectories.
//
//  	/U   Replaces (updates) only files that are older than
//  	     source files (May be used with /A)
//
//  	/V   Verifies that new files are written correctly.
//
//  	/W   Prompts you to press a key before copying. (Not implemented)
//
//  	/X   Emulate XCOPY's ablity to read as many files as possible
//  	     before writing them to the destination.
//
//	CpyCallBack is a ptr to a callback function which supports these
//	these callback functions.
//
//	int far CPY_CALLBACK)( int Func, unsigned long ulArg0, void far *pArg1,
//								  void far *pArg2, void far *pArg3 );
//
//		CB_CPY_FLGS		0x0001		// Passing back parsed copy flags
//		CB_CPY_ENVERR	0x0002		// Passing back non-fatal error
//		CB_CPY_SWITCH	0x0003		//	Passing back unrecongized switch
//		CB_CPY_ERR_STR	0x0004		// Passing back error error string
//		CB_CPY_FOUND	0x0005		// File was found and ready to copy
//		CB_CPY_FWRITE	0x0006		// Destination is about to be written
//		CB_CPY_QISDIR	0x0007		// Query user if dest is file or dir
//
//	Option bits which may be passed by by CB_CPY_FLGS are:
//
//		CPY_CONFIRM			0x0001 /C Confirm before overwrite existing file
//		CPY_EMPTY			0x0002 /E Copy empty subdirectories
//		CPY_MODIFY			0x0004 /M Set the archive bit on source
//		CPY_NEW				0x0008 /N Copy if file !exist on destination
//		CPY_EXISTING		0x0010 /O Copy over existing files only.
//		CPY_PROMPT			0x0020 /P Prompt before copying file
//		CPY_RDONLY			0x0040 /R Overwrite readonly files
//		CPY_UPDATE			0x0080 /U Copy only files new than destin
//		CPY_VERIFY			0x0100 /V Turn DOS verify to ON
//		CPY_WAIT				0x0200 /W Prompt before first file
//		CPY_XCOPY			0x0400 /X Use buffered copy.
//    CPY_FULL          0x1000 /D Prompt for next disk when current is full
//		CPY_HELP				0x0800 /? Display help
//
//*********************************************************************

#define DllCopyFiles( szCmdLine, szEnv, CB_CpyCallBack )\
				((int)(*DllEntry)( DLL_COPY, 3,\
				FSZPTR_TYPE + TRANS_SRC,\
				FSZPTR_TYPE + TRANS_SRC,\
				DWORD_TYPE + TRANS_NONE,\
				(char far *)szCmdLine,\
				(char far *)szEnv,\
				(int (far pascal *)())CB_CpyCallBack ))

//*********************************************************************

#define DllMoveFiles( szCmdLine, szEnv, CB_CpyCallBack )\
				((int)(*DllEntry)( DLL_MOVE, 3,\
				FSZPTR_TYPE + TRANS_SRC,\
				FSZPTR_TYPE + TRANS_SRC,\
				DWORD_TYPE + TRANS_NONE,\
				(char far *)szCmdLine,\
				(char far *)szEnv,\
				(int (far pascal *)())CB_CpyCallBack ))

//*********************************************************************
//	Main entry point for the file delete engine. Accepts a command line
//	and deletes the files meeting the specified criteria.
//
//	int DllDelFiles( char *szCmdLine, char *szEnvStr, DEL_CALLBACK DelCallBack )
//
//	ARGUMENTS:
//		szCmdLine	- Ptr to command line string, less command name
//		szEnvStr		- Ptr to optional enviroment cmd string or NULL
//		DelCallBack	- Ptr to delete callback function.
//	RETURNS:
//		int			- OK if all files deleted successfull else error code
//						  which is < 0 if a parse error and > 0 if a DOS
//						  or C runtime error.
//	
//	szCmdLine is ptr to commandline string.
//
//		"srcfiles [SrchCriteria] [/E] [/P] [/R] [/S] [/U]"
//
//  	source       Specifies the file or files to be deleted
//  	             and may be substituted with /F:filename
//  	             to use filespecs from a text file.
//
//  	SrchCriteria Any extended search criteria supported by
//  	             by the findfile engine.
//
//		/E   Delete empty subdirectories
//  	/P   Prompts for confirmation before copying each file
//		/R   Delete readonly files which match search criteria
//		/S   Delete files in specified path and all its subdirectories
//		/U   Alias for /A*/R/E
//
//
//	DelCallBack is a ptr to a callback function which supports these
//	these callback functions.
//
//	int far DEL_CALLBACK)( int Func, unsigned long ulArg0, void far *pArg1,
//								  void far *pArg2 )
//
//		CB_DEL_FLGS			0x0001 	// Passing back parsed delete flags
//		CB_DEL_ENVERR		0x0002	// Passing back non-fatal error
//		CB_DEL_SWITCH		0x0003	//	Passing back unrecongized switch
//		CB_DEL_ERR_STR		0x0004 	// Passing back error error string
//		CB_DEL_FOUND		0x0005 	// File was found and ready to delete
//		CB_DEL_QDELALL		0x0006	// Query user if should delete *.*
//		CB_DEL_QDELALL		0x0006	// Query user if should delete *.*
//
//*********************************************************************

#define DllDeleteFiles( szCmdLine, szEnv, CB_DelCallBack )\
				((int)(*DllEntry)( DLL_DELETE, 3,\
				FSZPTR_TYPE + TRANS_SRC,\
				FSZPTR_TYPE + TRANS_SRC,\
				DWORD_TYPE + TRANS_NONE,\
				(char far *)szCmdLine,\
				(char far *)szEnv,\
 				(int (far pascal *)())CB_DelCallBack ))

//*********************************************************************
//	Main entry point for the file dir engine. Accepts a command line
//	and does an application callback the files meeting the specified
//	criteria.
//
//	int DllDirFiles( char *szCmdLine, char *szEnvStr, DIR_CALLBACK DirCallBack )
//
//	ARGUMENTS:
//		szCmdLine	- Ptr to command line string, less command name
//		szEnvStr		- Ptr to optional enviroment cmd string or NULL
//		DirCallBack	- Ptr to dir callback function.
//	RETURNS:
//		int			- OK if all files directoried successfull else error code
//						  which is < 0 if a parse error and > 0 if a DOS
//						  or C runtime error.
//
//	szCmdLine is ptr to commandline string.
//
//		"srcfiles [SrchCriteria] [/B] [/L] [/O] [/P] [/S] [/V] [/W] [/?]
//
//  	source       Specifies the file or files to be directoried
//  	             and may be substituted with /F:filename
//  	             to use filespecs from a text file.
//
//  	SrchCriteria Any extended search criteria supported by
//  	             by the findfile engine.
//
//		Switches:								#defined value in DirFlgs
//
//		/B Display a bare listing			DIR_BARE			0x0001
//		/L	Display in lower case			DIR_LCASE		0x0002
//		/O Display in sorted order			DIR_ORDERED		0x0004
//		/P Paged output						DIR_PAGED		0x0008
//		/S Recurse subdirectories			DIR_SUBDIRS		0X0010
//		/V Display verbose information	DIR_VERBOSE		0x0020
//		/W Display wide listing				DIR_WIDE			0x0040
//		/? Display help						DIR_HELP			0x0080
//
//
//	DelCallBack is a ptr to a callback function which supports these
//	these callback functions.
//
//	int far DIR_CALLBACK)( int Func, unsigned long ulArg0, void far *pArg1,
//								  void far *pArg2 )
//
//		CB_DIR_FLGS			0x0001 	// Passing back parsed dir flags
//		CB_DIR_ENVERR		0x0002	// Passing back non-fatal error
//		CB_DIR_SWITCH		0x0003	// Passing a non-search switch
//		CB_DIR_ERR_STR		0x0004 	// Passing back an error string
//		CB_DIR_FOUND		0x0005 	// File was found and ready to delete
//		CB_DIR_ENTER		0x0006	// A search is starting on a new directory
//		CB_DIR_LEAVE		0x0007	// No more files on current directory
//		CB_DIR_NEWSEARCH  0x0008	// Starting a new srch with diff. filespec
//		CB_DIR_ENDPATH		0x0009	// End of current search path
//		CB_QUERY_ACCESS	0x000a	// Query if access date is required.
//
//*********************************************************************

#define DllDirFiles( szCmdLine, szEnv, CB_DirCallBack )\
				((int)(*DllEntry)( DLL_DIR, 3,\
				FSZPTR_TYPE + TRANS_SRC,\
				FSZPTR_TYPE + TRANS_SRC,\
				DWORD_TYPE + TRANS_NONE,\
				(char far *)szCmdLine,\
				(char far *)szEnv,\
				(int (pascal far *)())CB_DirCallBack))

//**********************************************************************
// Returns disk free information for the specified drive.
//
//	int DllGetDiskFree( int cDrvLetter, struct _diskfree_t *DrvInfo )
//
//	ARGUMENTS:
//		DrvLetter	- Drive letter to get disk free information about
//		pDrvInfo		- Ptr to a drive information structure to fill in
//	RETURNS:
//		int			- OK if no errors else errno from C runtime
//
//**********************************************************************

#define DllGetDiskFree( DriveLetter, DiskFreeStruc )\
		      ((int)(*DllEntry)( DLL_GET_DISK_FREE, 2,\
		      WORD_TYPE + TRANS_NONE,\
		      PTR_TYPE + TRANS_DEST,\
		      sizeof( struct diskfree_t ),\
		      DriveLetter,\
		      (struct diskfree_t _far *)DiskFreeStruc ))

//*********************************************************************
//	Main entry point for the file rename engine. Accepts a command line
//	and renames the files meeting the specified criteria.
//
//	int DllRenameFiles( char *szCmdLine, char *szEnvStr, REN_CALLBACK RenCallBack )
//
//	ARGUMENTS:
//		szCmdLine	- Ptr to command line string, less command name
//		szEnvStr		- Ptr to optional enviroment cmd string or NULL
//		DelCallBack	- Ptr to rename callback function.
//	RETURNS:
//		int			- OK if all files renamed successfull else error code
//						  which is < 0 if a parse error and > 0 if a DOS
//						  or C runtime error.
//	
//	szCmdLine is ptr to commandline string.
//
//		"srcfiles [SrchCriteria] [/P] [/S]"
//
//  	source       Specifies the file or files to be renamed
//  	             and may be substituted with /F:filename
//  	             to use filespecs from a text file.
//
//  	SrchCriteria Any extended search criteria supported by
//  	             by the findfile engine.
//
//  	/P   Prompts for confirmation before copying each file
//		/S   Rename files in specified path and all its subdirectories
//
//
//	DelCallBack is a ptr to a callback function which supports these
//	these callback functions.
//
//	int far REN_CALLBACK)( int Func, unsigned long ulArg0, void far *pArg1,
//								  void far *pArg2 )
//
//		CB_REN_FLGS			0x0001 	// Passing back parsed rename flags
//		CB_REN_ENVERR		0x0002	// Passing back non-fatal error
//		CB_REN_SWITCH		0x0003	//	Passing back unrecongized switch
//		CB_REN_ERR_STR		0x0004 	// Passing back error error string
//		CB_REN_FOUND		0x0005 	// File was found and ready to rename
//
//*********************************************************************

#define DllRenameFiles( szCmdLine, szEnv, CB_DelCallBack )\
				((int)(*DllEntry)( DLL_RENAME, 3,\
				FSZPTR_TYPE + TRANS_SRC,\
				FSZPTR_TYPE + TRANS_SRC,\
				DWORD_TYPE + TRANS_NONE,\
				(char far *)szCmdLine,\
				(char far *)szEnv,\
 				(int (far pascal *)())CB_DelCallBack ))

//*********************************************************************
//	Loads a group of messages from the resource file in the specified
//	file into memory for latter retrieval by LoadStr(). In addition to
//	the requested messages the function will also load all error messages
//	in the ranges of 0-0xff and 0xff00 - 0xffff (-256 thru +255) on
//	the first call to the function. The resource table is built in
//	StrTable and then sorted, and then StrBuf is allocated and the
//	resource strings are read into the buffer.
//
//	NOTE:
//		Currently this function may only be called once.
//
//	int LoadMsgs( char *szFile, unsigned uStart, unsigned uEnd )
//
//	ARGUMENTS:
//		szFile		- Ptr to .EXE file containing the messages to load
//		uStart		- Starting message number to load into memory
//		uEnd			- Ending message number to be loaded into memory.
//	RETURNS:
//		int			- OK if all messages (including normal preloaded messages)
//						  are successfully loaded, else an error code.
//	
//*********************************************************************

#define DllLoadMsgs( szFile, uStart, uEnd )\
				((int)(*DllEntry)( DLL_LOAD_MSGS, 3,\
				FSZPTR_TYPE + TRANS_SRC,\
				WORD_TYPE + TRANS_NONE,\
				WORD_TYPE + TRANS_NONE,\
				(char far *)szFile,\
				(unsigned)uStart,\
				(unsigned)uEnd ))

//*********************************************************************
//	Windows emulatation function for accessing a string resource. Copies
//	the specified string resource into a caller supplied buffer and
//	appends a terminating zero to it. Because string groups are aligned
//	standard boundaries there is normally a lot of trailing zeros which
//	we strip off after reading in a group of strings.
//
//	NOTE:
//		Currently this functions requires that the string resource was
//		previously loaded into memory by LoadMsgs() which should be called
//		once at the begining of the program to preload all required
//		messages.
//	
//	int DllLoadString( unsigned hInst, unsigned idResource, char far *szBuf,
//							 int iBufLen )
//
//	ARGUMENTS:
//		hInst			- Instance of the calling program (should be zero)
//		idResource	- The string ID as specified in the .RC file
//		szBuf			- Buffer to copy the string to
//		iBufLen		- Max characters to copy into the specified buffer
//	RETURNS:
//		int			- The number of bytes copied. This number will be
//						  0 if the specified resource cannot be located in
//						  StrTable[].
//
//*********************************************************************

#define DllLoadString( hInst, idResource, szBuf, iBufLen )\
				((int)(*DllEntry)( DLL_LOAD_STRING, 4,\
				WORD_TYPE + TRANS_NONE,\
				WORD_TYPE + TRANS_NONE,\
				FSZPTR_TYPE + TRANS_SRC,\
				WORD_TYPE + TRANS_NONE,\
				(unsigned)hInst,\
				(unsigned)idResource,\
				(char far *)szBuf,\
				(int)iBufLen ))
				

//*********************************************************************
//	Extended file open function used DOS function 6ch to open a file
//	and return a file handle.
//	
//	unsigned DllDosExtOpen(  char *szFile, unsigned uMode, unsigned uAttribs,
//									 unsigned uCreat, unsigned *uFhandle )
//	
//	ARGUMENTS:
//		szFile	- Ptr to buffer containing a fully qualified filespec string
//		uMode		- Open mode for file access and sharing. (BX)
//		uAttribs	- Attributes for file if being created. (CX)
//		uCreate	- Create action flags. (DX)
//		uFhandle- Ptr to unsigned file handle
//	RETURNS:
//		unsigned - OK if no errors and open file handle stored in *uFhandle
//					  ELSE DOS error code and errno set to C runtime erro code
//	
//*********************************************************************

#define DllDosExtOpen( szFile, uMode, uAttribs, uCreate, pHandle )\
				((int)(*DllEntry)( DLL_EXT_OPEN_FILE, 5,\
		      FSZPTR_TYPE + TRANS_SRC,\
				WORD_TYPE + TRANS_NONE,\
				WORD_TYPE + TRANS_NONE,\
				WORD_TYPE + TRANS_NONE,\
		      FPTR_TYPE + TRANS_DEST,\
		      sizeof( int ),\
		      (char far *)szFile,\
				(unsigned)uMode,\
				(unsigned)uAttribs,\
				(unsigned)uCreate,\
		      (int far *)pHandle ))

//*********************************************************************
//	See C_RUNTIME _dos_open() for complete description.
//*********************************************************************

// unsigned DosOpenFile( char far *szFileSpec, unsigned uMode, int *pHandle );
#define DllDosOpen( szFile, uMode, pHandle )\
		      ((int)(*DllEntry)( DLL_OPEN_FILE, 3,\
		      FSZPTR_TYPE + TRANS_SRC,\
				WORD_TYPE + TRANS_NONE,\
		      FPTR_TYPE + TRANS_DEST,\
		      sizeof( int ),\
		      (char far *)szFile,\
				(unsigned)uMode,\
		      (int far *)pHandle ))

//*********************************************************************
//	See C_RUNTIME _dos_read() for complete description.
//*********************************************************************

// unsigned DosReadFile( int fHandle, char far *Buf, unsigned Bytes,
//		      unsigned *puRead );
#define DllDosRead( fHandle, pBuf, Bytes, pRead )\
		      ((int)(*DllEntry)( DLL_READ_FILE, 4,\
				WORD_TYPE + TRANS_NONE,\
		      FPTR_TYPE + TRANS_DEST,\
		      Bytes,\
				WORD_TYPE + TRANS_NONE,\
		      FPTR_TYPE + TRANS_DEST,\
		      sizeof( int ),\
		      (int)fHandle,\
				(void far *)pBuf,\
				(unsigned)Bytes,\
				(unsigned far *)pRead ))

//*********************************************************************
//	See C_RUNTIME _dos_write() for complete description.
//*********************************************************************

// unsigned DosWriteFile( int fHandle, char far *Buf, unsigned Bytes,
//		      unsigned *puWrite );
#define DllDosWrite( fHandle, pBuf, Bytes, pWritten )\
		      ((int)(*DllEntry)( DLL_WRITE_FILE, 4,\
				WORD_TYPE + TRANS_NONE,\
		      FPTR_TYPE + TRANS_SRC,\
		      Bytes,\
				WORD_TYPE + TRANS_NONE,\
		      FPTR_TYPE + TRANS_DEST,\
		      sizeof( int ),\
		      (int)fHandle,\
				(void far *)pBuf,\
				(unsigned)Bytes,\
				(unsigned far *)pWritten ))

//*********************************************************************
//	See C_RUNTIME _dos_close() for complete description.
//*********************************************************************

// unsigned DosCloseFile( int fHandle );
#define	DllDosClose( fHandle )\
		      ((int)(*DllEntry)( DLL_CLOSE_FILE, 1,\
				WORD_TYPE + TRANS_NONE,\
				(int)fHandle ))


//*********************************************************************
//	Seeks to a new position in an open file using DOS function 0x42.
//	
//	unsigned _dos_seek( int fHandle, long lOffset, int iOrgin, long *plCurPos );
//	
//	ARGUMENTS:
//		fHandle	- Open DOS file handle
//		lOffset	- Offset to seek to in the file
//		iOrigin	- Origin to seek from can be:
//					  SEEK_SET From begining of file
//					  SEEK_CUR From current position if the file
//					  SEEK_END From the end of the file
//		plCurPos - Ptr to dword value where absolute position in the file will
//					  be stored after the seek
//	RETURNS:
//		unsigned - OK if no errors and open file handle stored in *uFhandle
//					  ELSE DOS error code and errno set to C runtime erro code
//	
//*********************************************************************

// DllDosSeek( int fHandle, long 0L, int SEEK_SET, long *lPos )
#define	DllDosSeek( fHandle, lPos, Type, lpNewPos )\
		      ((int)(*DllEntry)( DLL_SEEK_FILE, 4,\
				WORD_TYPE + TRANS_NONE,\
				DWORD_TYPE + TRANS_NONE,\
				WORD_TYPE + TRANS_NONE,\
		      FPTR_TYPE + TRANS_DEST,\
				sizeof( long ),\
				(int)fHandle,\
				(long)lPos,\
				(int)Type,\
				(long far *)lpNewPos ))
			
//**********************************************************************
// Fills in a media ID information structure passed by the caller.
//
//	NOTE: The _dos_getmedia_id call may return a volume id which does
//			not match that found with a _dos_findfirst() so we do the
//			_dos_findfirst() to be compatible with DOS 5.0 DIR cmd.
//
//	int GetMediaId( int cDrvLetter, struct MEDIA_ID_INF *pMediaInf )
//
//	ARGUMENTS:
//		cDrvLetter	- Drive letter to get media information about
//		pMediaInf	- Ptr to a media information structure to fill in
//	RETURNS:
//		int			- OK if no errors else errno from C runtime
//
//**********************************************************************

// DllGetMediaId( char DrvLetter, struct MEDIA_ID_INF *pMediaInf )
#define	DllGetMediaId( DrvLetter, pMediaInf )\
		      ((int)(*DllEntry)( DLL_GET_MEDIA_ID, 2,\
				WORD_TYPE + TRANS_NONE,\
		      FPTR_TYPE + TRANS_DEST,\
				sizeof( struct MEDIA_ID_INF ),\
				(char)DrvLetter,\
				(struct MEDIA_ID_INF far *)pMediaInf ))

//**********************************************************************
//	Fills in a user supplied buffer with the current directory path string
//	for a specified drive. The path does not contain the drive letter or
//	root directory specifier, ie: "dos\user\bin". To get the current
//	directory on the current drive call the function with drive
//	specified as 0.
//
//	int DllGetdCwd( int iDrive, char *szBuf )
//
//	ARGUMENTS:
//		iDrive	- Drive specifier (0=default,1=A:,2=B:,3=C:,...)
//		szBuf		- Ptr to buffer to accept path string which should be 256
//					  bytes in length.
//	RETURNS:
//		int		- OK if specified drive C runtime error code
//
//**********************************************************************

#define	DllGetdCwd( iDrive, szBuf )\
		      ((int)(*DllEntry)( DLL_GET_CWD_ID, 2,\
				WORD_TYPE + TRANS_NONE,\
		      FSZPTR_TYPE + TRANS_DEST,\
				(int)iDrive,\
				(char far *)szBuf ))


//**********************************************************************
//	Sets the working directory to that specified by a path string passed
//	by the caller. The path string may include a drive specifier and the
//	path may be relative to the current directory on the drive affected.
//
//	int DllSetCwd( char *szBuf )
//
//	ARGUMENTS:
//		szBuf	- Ptr to string which specifies the directory to change to.
//	RETURNS:
//		int		- OK if specified drive C runtime error code
//
//**********************************************************************

#define	DllSetCwd( szBuf )\
		      ((int)(*DllEntry)( DLL_SET_CWD_ID, 1,\
		      FSZPTR_TYPE + TRANS_SRC,\
				(char far *)szBuf ))

//**********************************************************************
//	Gets the current drive using DOS function 0x19. The value obtained is
//	the based 1 drive (A:=1, B:=2, C:=3, ...)
//
//	void DllGetDrive( unsigned *pDrive )
//
//	ARGUMENTS:
//		pDrive	- Pointer to unsigned value where the drive number will
//					  be stored.
//	RETURNS:
//		void
//
//**********************************************************************

#define	DllGetDrive( pDrive )\
		      ((void)(*DllEntry)( DLL_GET_DRV_ID, 1,\
		      FPTR_TYPE + TRANS_DEST,\
				sizeof( unsigned ),\
				(unsigned far *)pDrive ))

//**********************************************************************
//	Sets the current drive using DOS function 0x0e. The drive is specified
//	using base 1 so that A:=1, B:=2, C:=3, etc.
//
//	void DllSetDrive( unsigned uDrive, unsigned *pNumDrvs )
//
//	ARGUMENTS:
//		uDrive	- Drive number to set as current drive.
//		pNumDrvs	- Pointer to unsigned value where the total number of drives
//				     in the system will be store. (This is the value of
//					  lastdrive= in the config.sys).
//	RETURNS:
//		void		- No return value is passed. Use DllGetDrive() to determine
//					  if the call was successful.
//
//**********************************************************************

#define	DllSetDrive( uDrive, pNumDrvs )\
		      ((void)(*DllEntry)( DLL_SET_DRV_ID, 2,\
				WORD_TYPE + TRANS_NONE,\
		      FPTR_TYPE + TRANS_DEST,\
				sizeof( unsigned ),\
				(unsigned)(uDrive),\
				(unsigned far *)pNumDrvs ))

//**********************************************************************
//	Creates a new directory with the specified name. The string specifying
//	the name may be a fully qualified path or relative to the current
//	drive and directory.
//
//	int DllMakeDir( char *szDir )
//
//	ARGUMENTS:
//		szDir		- Ptr to path directory name string
//	RETURNS:
//		int		- OK in successfull else C runtime error code of
//					  EACCESS if directory already exists or conflicting
//					  file name, or ENOENT if the path is invalid
//
//**********************************************************************

#define	DllMakeDir( szDir )\
		      ((int)(*DllEntry)( DLL_MKDIR, 1,\
		      FSZPTR_TYPE + TRANS_SRC,\
				(char far *)szDir ))


//**********************************************************************
//	Deletes the directory with the specified name. The string specifying
//	the name may be a fully qualified path or relative to the current
//	drive and directory.
//
//	int DllRemoveDir( char *szDir )
//
//	ARGUMENTS:
//		szDir		- Ptr to directory name string
//	RETURNS:
//		int		- OK in successfull else C runtime error code of
//					  EACCESS if name given is not a directory or the
//					  directory is not empty or is the current or
//					  root directory, or ENOENT if the path is invalid.
//
//**********************************************************************

#define	DllRemoveDir( szDir )\
		      ((int)(*DllEntry)( DLL_RMDIR, 1,\
		      FSZPTR_TYPE + TRANS_SRC,\
				(char far *)szDir ))


//**********************************************************************
//	Creates a complete directory path from a caller supplied path string.
//	Any or all of the directories in the specified path may already
//	exist when the function is called. The path string may be drive or
//	UNC based and may include a trailing backslash.
//
//	int DllCreateDirTree( char *szPath )
//
//	ARGUMENTS:
//		szPath		- Fully qualified path string.
//	RETURNS:
//		int			- OK if successful else EACCES or ENOENT
//
//**********************************************************************

#define	DllCreateDirTree( szDir )\
		      ((int)(*DllEntry)( DLL_MKDIR_TREE, 1,\
		      FSZPTR_TYPE + TRANS_SRC,\
				(char far *)szDir ))



//**********************************************************************
//	Main entry point for the find/grep engine. Accepts a command line and
//	emulates the DOS FIND command.
//
//
//	int FindFiles( char *szCmdLine, FIND_CALLBACK FindCallBack )
//
//	szCmdLine is ptr to commandline string.
//
//		"srcfiles [SrchCriteria] [/V] [/C] [/N] [/I]
//
//  	source       Specifies the file or files to be finds
//  	             and may be substituted with /F:filename
//  	             to use filespecs from a text file.
//
//  	SrchCriteria Any extended search criteria supported by
//  	             by the findfile engine.
//
//		/V   Displays all lines NOT containing the specified string.
//		/C   Displays only the count of lines containing the string.
//		/N   Displays line numbers with the displayed lines.
//		/I   Ignores the case of characters when searching for the string.
//
//	FindCallBack is a ptr to a callback function which supports these
//	these callback functions.
//
//	long (far pascal *FIND_CALLBACK)( int Func, unsigned uArg0,
// 								 	 		 void far *pArg1, void far *pArg2,
//										 	 	 void far *pArg3 );
//
//		CB_FIND_FLGS		0x0001	// Passing back parsed FIND flags
//		CB_FIND_ENVERR		0x0002	// Passing back non-fatal error
//		CB_FIND_SWITCH		0x0003	//	Passing back unrecongized switch
//		CB_FIND_ERR_STR	0x0004	// Passing back error error string
//		CB_FIND_FOUND		0x0005	// File matching search criteria found
//		CB_FIND_MATCH		0x0006	// Passing back matching line from file
//		CB_FIND_COUNT		0x0007	// Passing back count of matching lines
//
//***********************************************************************

#define DllFindFiles( szCmdLine, szEnv, CB_FindCallBack )\
				((int)(*DllEntry)( DLL_FIND, 3,\
				FSZPTR_TYPE + TRANS_SRC,\
				FSZPTR_TYPE + TRANS_SRC,\
				DWORD_TYPE + TRANS_NONE,\
				(char far *)szCmdLine,\
				(char far *)szEnv,\
				(int (pascal far *)())CB_FindCallBack))


//**********************************************************************
//	File touch engine entry function. Allows setting the time/date
//	stamp on files.
//
//	int TouchFiles( char *szCmdLine, TOUCH_CALLBACK TouchCallBack )
//
//	szCmdLine is ptr to commandline string.
//
//		"srcfiles [SrchCriteria] [/TDM:mm-dd-yy[:hh:mm:ss]]
//                             [/TTA:hh:mm:ss]
//                             [/TDA:mm-dd-yy]
//
//  	source       Specifies the file or files to be touches
//  	             and may be substituted with /F:filename
//  	             to use filespecs from a text file.
//
//  	SrchCriteria Any extended search criteria supported by
//  	             by the findfile engine.
//
//    /TDM: Set last write date and optional time to specified value.
//    /TTM: Set last write time to specified value.
//    /TDA: Set last access date and optional time to specified value.
//    /TTA:	Set last access time to specified value.
//
//	TouchCallBack is a ptr to a callback function which supports these
//	these callback functions.
//
//	long (far pascal *TOUCH_CALLBACK)( int Func, unsigned uArg0,
//                                    void far *pArg1, void far *pArg2,
//                                    void far *pArg3 );
//
//    CB_TOUCH_FLGS     0x0001   // Passing back parsed TOUCH flags
//    CB_TOUCH_ENVERR   0x0002   // Passing back non-fatal error
//    CB_TOUCH_SWITCH   0x0003   //	Passing back unrecongized switch
//    CB_TOUCH_ERR_STR	0x0004   // Passing back error error string
//    CB_TOUCH_FOUND    0x0005   // File matching search criteria found
//
//***********************************************************************


#define DllTouchFiles( szCmdLine, szEnv, CB_TouchCallBack )\
				((int)(*DllEntry)( DLL_TOUCH, 3,\
				FSZPTR_TYPE + TRANS_SRC,\
				FSZPTR_TYPE + TRANS_SRC,\
				DWORD_TYPE + TRANS_NONE,\
				(char far *)szCmdLine,\
				(char far *)szEnv,\
				(int (pascal far *)())CB_TouchCallBack))


//**********************************************************************
//	File Attrib engine entry function. Allows setting access attributes
// on files
//
// int AttribFiles( char *szCmdLine, char *szEnvStr,
//                  ATTRIB_CALLBACK CB_AttrMain )
//
//	szCmdLine is ptr to commandline string.
//
//		"srcfiles [SrchCriteria] [{+|-}A] [{+|-}H] [{+|-}R] [{+|-}S]
//
//  	source       Specifies the file or files to be attribs
//  	             and may be substituted with /F:filename
//  	             to use filespecs from a text file.
//
//  	SrchCriteria Any extended search criteria supported by
//  	             by the findfile engine.
//
//    +   Sets an attribute.
//    -   Clears an attribute.
//    R   Read-only file attribute.
//    A   Archive file attribute.
//    S   System file attribute.
//    H   Hidden file attribute.
//    /S  Processes files in all directories in the specified path.
//		
//
//	AttribCallBack is a ptr to a callback function which supports these
//	these callback functions.
//
//	long (far pascal *ATTRIB_CALLBACK)( int Func, unsigned uArg0,
//                                    void far *pArg1, void far *pArg2,
//                                    void far *pArg3 );
//
//    CB_ATTRIB_FLGS     0x0001   // Passing back parsed ATTRIB flags
//    CB_ATTRIB_ENVERR   0x0002   // Passing back non-fatal error
//    CB_ATTRIB_SWITCH   0x0003   // Passing back unrecongized switch
//    CB_ATTRIB_ERR_STR	 0x0004   // Passing back error error string
//    CB_ATTRIB_FOUND    0x0005   // File matching search criteria found
//
//***********************************************************************

#define DllAttribFiles( szCmdLine, szEnv, CB_AttribCallBack )\
				((int)(*DllEntry)( DLL_ATTRIB, 3,\
				FSZPTR_TYPE + TRANS_SRC,\
				FSZPTR_TYPE + TRANS_SRC,\
				DWORD_TYPE + TRANS_NONE,\
				(char far *)szCmdLine,\
				(char far *)szEnv,\
				(int (pascal far *)())CB_AttribCallBack))

//**********************************************************************
//	Sets up the country specific information for the .DLL. The country
//	information is passed in a a buffer containg:
//
//	Offset
//	0			Case map	table 
//	256		Collate table
//	512		File name char table
//	768		Extended country information structure
//	808		END
//
//	int DllSetCntryInfo( char far *pBuf )
//
//	ARGUMENTS:
//		pBuf		- Ptr to buffer described above
//	RETURNS:
//		void
//
//**********************************************************************

#define	DllSetCntryInfo( pBuf )\
		      ((void)(*DllEntry)( DLL_SET_CNTRY_INF, 1,\
		      FPTR_TYPE + TRANS_SRC,\
				(unsigned)(808),\
				(char far *)pBuf ))


//**********************************************************************
//	Frees the instance data for the current instance of the DLL. Should
//	be the last call a Windows App makes to the DLL.
//
//	int ReleaseDataSeg( void )
//
//	ARGUMENTS:
//		NONE
//	RETURNS:
//		int		- OK if successful else ERR_MEM_CORRUPT
//
//**********************************************************************

#define	DllReleaseInstance( )\
		      ((int)(*DllEntry)( DLL_RELEASE, 0 ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\drivinit.h ===
/************************************************************************
*                                                                       *
*   drivinit.h -- obsolete                                              *
*                                                                       *
*   Copyright (c) 1985-1994, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/
/* OBSOLETE: Use print.h instead */
#include <print.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\dpmi.inc ===
COMMENT #
//***************************************************************************
//
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1993
//  All rights reserved
//
// Include file for using DPMI functionality in Windows.
//
//***************************************************************************
END COMMENT #


DPMI                    EQU     031h            ; DPMI interrupt vector
ALLOC_LDT_DESC          EQU     0000h
SEG_TO_DESC             EQU 	0002h
SET_SEG_BASE_ADDR       EQU 	0007h
SET_SEG_LIMIT           EQU 	0008h
ALLOC_DOS_MEM_BLOCK     EQU 	0100h
FREE_DOS_MEM_BLOCK      EQU 	0101h
SET_REALMODE_INTVEC     EQU 	0201h
GET_REALMODE_INTVEC     EQU 	0200h
SIMULATE_RELMODE_INT    EQU 	0300h
CALL_REALMODE_PROC      EQU     0301h

; ***************************************************************************

EXTERNDEF C     IsWindows:WORD
EXTERNDEF C    	IntVector:WORD
EXTERNDEF C    	DosMem:DWORD

; ***************************************************************************
;
; Macro for simulating a real mode interrupt from protect mode using DPMI.
; Before invoking the macro the registers should be setup for the desired
; real mode interrupt call. All register pointer must be to real mode
; memory obtained via DPMI.
;
; ***************************************************************************

DpmiInt MACRO Vector:REQ
    LOCAL   IsDos                           ; Local label
    LOCAL   EndMacro                        ; Local labe

    cmp     IsWindows, 0                    ; See if a Windows app
    je      IsDos                           ; If not not Windows use DOS int

    mov     IntVector, Vector               ; Set vector to simulate
    call    GenericDpmi                     ; Call generic DPMI function
    jmp     SHORT EndMacro

IsDos:
    int     Vector                          ; Do DOS interrupt

EndMacro:

ENDM

; ***************************************************************************
;
; Real Mode call structure for Simulating Real Mode Interrupts using DPMI
;
; ***************************************************************************

RealModeCallStruc   Struc

    RegEDI      dd  	?
    RegESI      dd  	?
    RegEBP      dd  	?
    Regres      dd  	?
    RegEBX      dd  	?
    RegEDX      dd  	?
    RegECX      dd  	?
    RegEAX      dd  	?
    RegFlg      dw  	?
    RegES       dw  	?
    RegDS       dw  	?
    RegFS       dw  	?
    RegGS       dw  	?
    RegIP       dw  	?
    RegCS       dw  	?
    RegSP       dw  	?
    RegSS       dw  	?

RealModeCallStruc	Ends


; ***************************************************************************
;
; Real Mode call structure for Simulating Real Mode Interrupts using DPMI
;
; ***************************************************************************

@proto_100      TYPEDEF     PROTO C
GenericDpmi 	PROTO       @proto_100

@proto_101              TYPEDEF     PROTO C
DpmiDskRdWr     PROTO       @proto_101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\dskmaint.h ===
//----------------------------------------------------------------------
//
// .h file for the DSKMAINT DLL
//
//----------------------------------------------------------------------

//
// Prototype for the engine call back function
//
typedef LRESULT (CALLBACK* DSKUTILCBPROC)(UINT,LPARAM,LPARAM,LPARAM,LPARAM,LPARAM,LPARAM);

//
// Drive parameter structures
//
typedef struct tagUNKNOWNFSSTRUCT {
	WORD	Error;		/* If available, error code */
} UNKNOWNFSSTRUCT;

typedef struct tagINVALIDFSSTRUCT {
	WORD	Error;		/* If available, error code */
} INVALIDFSSTRUCT;

typedef struct tagFATFSSTRUCT {
	BYTE	MediaDesc;		/* Media Descriptor byte */
	BYTE	FATNum; 		/* Number of FATs */
	WORD	FSSubType;		/* allocation sub type */
	DWORD	BytPerSec;		/* Bytes per sector */
	DWORD	SecPerClus;		/* Sectors per cluster */
	DWORD	TotSec; 		/* Total number of sectors on drive */
	DWORD	TotSizeK;		/* (TotSec * BytPerSec) / 1024 */
	DWORD	TotSizeM;		/* (TotSec * BytPerSec) / 1024^2 */
	DWORD	FATSector;		/* Sector number of first sector of first FAT and */
					/*    number of RESERVED/BOOT sectors */
	DWORD	FATSize;		/* Size of one FAT in sectors */
	DWORD	DirEntSizeMin;		/* Minimum size in bytes of a directory entry */
	DWORD	DirEntSizeMax;		/* Maximum size in bytes of a directory entry */
	DWORD	RootDirSecCnt;		/* number of sectors in root directory */
	DWORD	RootDirSector;		/* Sector number of first root directory sector */
	DWORD	RootDirEntCntMin;	/* Min number of entries in root directory */
	DWORD	RootDirEntCntMax;	/* Max number of entries in root directory */
	DWORD	TotDataClus;		/* total number of data clusters on drive */
	DWORD	DataSizeK;		/* (TotDataClus*SecPerClus*BytePerSec) / 1024 */
	DWORD	DataSizeM;		/* (TotDataClus*SecPerClus*BytePerSec)/1024^2 */
	DWORD	MaxClusNum;		/* Maximum valid cluster number for drive */
	DWORD	FSStrucSzBytes; 	/* Buffer size req for ReadFileSysStruc API */
	DWORD	EOFClusVal;		/* Clusters which contain values >= this */
					/*     value are EndOfFile clusters */
	DWORD	BadClusVal;		/* "Lost" clusters which contain values == this */
					/*     value are BAD clusters */
	DWORD	FrstDataSector; 	/* Sector number of first sector of first data cluster */
	DWORD	FrstDataCluster;	/* Cluster # who's first sector  is FrstDataSector */
} FATFSSTRUCT;

//
// FSSubType
//
#define FSS_FAT12	1
#define FSS_FAT16	2

typedef struct tagDRVPARMSTRUCT {
	UINT	FileSysType;
	UINT	Drive;
	union	{
		    UNKNOWNFSSTRUCT unkFS;
		    INVALIDFSSTRUCT invFS;
		    FATFSSTRUCT     FatFS;
		} drvprm;
	BYTE	resrvd[80];
} DRVPARMSTRUCT;
typedef DRVPARMSTRUCT*	    PDRVPARMSTRUCT;
typedef DRVPARMSTRUCT NEAR* NPDRVPARMSTRUCT;
typedef DRVPARMSTRUCT FAR*  LPDRVPARMSTRUCT;

//
// File system types
//
#define FS_INVALID	    6000
#define FS_UNKNOWN	    1
#define FS_ERROR	    2
#define FS_FAT		    3
#define FS_DDFAT	    4
#define FS_LFNFAT	    5
#define FS_DDLFNFAT	    6
#define FS_SIZEERR	    8000

//
// Modifyer flags for GetEngineDriveInfo returns
//
#define FS_CANRDWRTSEC	    0x0001
#define FS_CANRDWRTFSS	    0x0002
#define FS_CANFORMAT	    0x0004
#define FS_ISFIXABLE	    0x0008
#define FS_ISOPTIMIZABLE    0x0010

BOOL WINAPI DMaint_GetEngineDriveInfo(LPDWORD lpEngInfArray);

UINT WINAPI DMaint_GetFileSysParameters(UINT Drive, LPDRVPARMSTRUCT lpParmBuf, UINT nSize);

DWORD WINAPI DMaint_ReadSector(LPDRVPARMSTRUCT lpParmBuf, LPVOID lpSectorBuf, DWORD sSector, DWORD nSectors);

DWORD WINAPI DMaint_WriteSector(LPDRVPARMSTRUCT lpParmBuf, LPVOID lpSectorBuf, DWORD sSector, DWORD nSectors);

DWORD WINAPI DMaint_ReadFileSysStruc(LPDRVPARMSTRUCT lpParmBuf, LPVOID lpFSBuf, DWORD nSize);

DWORD WINAPI DMaint_WriteFileSysStruc(LPDRVPARMSTRUCT lpParmBuf, LPVOID lpFSBuf, DWORD FSFlags);

//
// Structures and defines for DMaint_GetFormatOptions DMaint_FormatDrive
//			      DMaint_UnFormatDrive
//
#define MAXNUMFMTS	16
#define MAXFMTNAMELEN	60
#define MAXFNAMELEN	256	    // INCLUDES trailing NUL
#define DRVMAXPATHLEN	(260 + 3)   // INCLUDES trailing NUL, + 3 for "X:\"

typedef struct tagFMTINFOSTRUCT {
	BYTE		TotalPcntCmplt;
	BYTE		CurrOpRegion;
	UINT		Drive;
	WORD		FSFmtID;
	WORD		DefFSFmtID;
	WORD		PhysFmtID;
	WORD		DefPhysFmtID;
	DWORD		Options;
	WORD		FSFmtCnt;
	WORD		PhysFmtCnt;
	BYTE		VolLabel[MAXFNAMELEN];
	LPARAM		lParam1;
	LPARAM		lParam2;
	BYTE		reserved[40];
	WORD		FSFmtIDList[MAXNUMFMTS];
	BYTE		FSFmtNmList[MAXNUMFMTS][MAXFMTNAMELEN];
	WORD		PhysFmtIDList[MAXNUMFMTS];
	BYTE		PhysFmtNmList[MAXNUMFMTS][MAXFMTNAMELEN];
} FMTINFOSTRUCT;
typedef FMTINFOSTRUCT*	    PFMTINFOSTRUCT;
typedef FMTINFOSTRUCT NEAR* NPFMTINFOSTRUCT;
typedef FMTINFOSTRUCT FAR*  LPFMTINFOSTRUCT;

typedef struct tagFATFMTREPORT {
	DWORD	TotDiskSzByte;
	DWORD	TotDiskSzK;
	DWORD	TotDiskSzM;
	DWORD	BadSzByte;
	DWORD	BadSzK;
	DWORD	BadSzM;
	DWORD	SysSzByte;
	DWORD	UsedSzByte;
	DWORD	UsedSzK;
	DWORD	UsedSzM;
	DWORD	AvailSzByte;
	DWORD	AvailSzK;
	DWORD	AvailSzM;
	DWORD	BytesPerClus;
	DWORD	TotDataClus;
	DWORD	SerialNumber;
} FATFMTREPORT;
typedef FATFMTREPORT*	    PFATFMTREPORT;
typedef FATFMTREPORT NEAR* NPFATFMTREPORT;
typedef FATFMTREPORT FAR*  LPFATFMTREPORT;

//
// Error values and bits
//
#define NOERROR 		0	// This MUST be 0!
#define OPCANCEL		1
#define ERR_NOTSUPPORTED	2
#define ERR_NOTFULLSUPP 	3
    #define NOFORMAT		    0x0001
    #define NOUNFORMAT		    0x0002
    #define MKSYSONLY		    0x0004
    #define FSONLY		    0x0008
#define ERR_ISSYSDRIVE		4
    #define ISWINDRV		    0x0001
    #define ISPAGINGDRV 	    0x0002
#define ERR_NONFATAL		5
#define ERR_FATAL		6
    //	    RETRY		    0x0001
    //	    RECOV		    0x0002
    #define ERRTOS		    0x0004
    #define ERRNOOS		    0x0008
    #define ERRVOLLABEL 	    0x0010
    #define ERRFBOOT		    0x0020
    #define ERRROOTD		    0x0040
    #define ERROSAREA		    0x0080
    #define ERRDATA		    0x0100
    #define ERRMBR		    0x0200
    #define ERRFAT		    0x0400
    #define ERRCVFHD		    0x0800

#define ERR_OSNOTFOUND		7
#define ERR_OSERR		8
#define ERR_INSUFMEM		9
#define ERR_LOCKVIOLATION	10
#define ERR_LOCKREQUIRED	11
#define ERR_FSACTIVE		12
#define ERR_BADOPTIONS		13
#define ERR_BADSTART		14
#define ERR_BADEND		15
#define ERR_BADXADDR		16
#define ERR_NOTWRITABLE 	17
#define ERR_SZERR		18
#define ERR_FSERR		19
    #define	FATCLUSINVALID	    0x0001
    #define	FATSECTORSBADS	    0x0002
#define ERR_BADFORMAT		20
    #define	FATCLUSOVERFLOW     0x0004
    #define	FATSECTORSBADH	    0x0008
#define ERR_FSCORRECTED 	21
#define ERR_FSUNCORRECTED	22
#define ERR_EXCLVIOLATION	23
//	FATERRMXPLEN		29

//
// sub-operation codes
//
#define FOP_INIT		1
#define FOP_LOWFMT		2
#define FOP_VERIFY		3
#define FOP_FSFMT		4
#define FOP_TSYS		5
#define FOP_GETLABEL		6
#define FOP_SEARCH		7
#define FOP_RESTORE		8
#define FOP_SHTDOWN		9
#define FOP_FAT 		10
#define FOP_DIR 		11
#define FOP_FILDIR		12
#define FOP_LOSTCLUS		13
#define FSOP_INIT		14
#define FSOP_SETUNMOV		15
#define FSOP_SYSTEM		16
#define FSOP_DATA		17
#define FOP_DDHEAD		18
#define FOP_DDSTRUC		19
#define FOP_DDFAT		20
#define FOP_DDSIG		21
#define FOP_DDBOOT		22

//
// WriteFileSysStruc options
//
#define FATNOPACKINPLACE	0x00010000L
#define FATSTOPONERR		0x00020000L

//
// Format options
//
#define FD_LOWLEV		0x00000001L
#define FD_LOWLEVONLY		0x00000002L
#define FD_VERIFY		0x00000004L
#define FD_FSONLY		0x00000008L
#define FD_UNFORMAT		0x00000010L
#define FD_NOUNFORMAT		0x00000020L
#define FD_PHYSONLY		0x00000040L
#define FD_BOOT 		0x00000080L
#define FD_BOOTONLY		0x00000100L
#define FD_VOLLABEL		0x00000200L
#define FD_NOVOLLABEL		0x00000400L
#define FD_ISVOLLABEL		0x00000800L
#define FD_GETCONFIRM		0x00001000L
#define FD_ISREM		0x00002000L

#define FDFAT_SETCLUS		0x80000000L
#define FDFAT_SETROOTSZ 	0x40000000L

//
// Defines for call back messages
//
#define DU_INITENGINE		0x0401
#define DU_ENGINESTART		0x0402
#define DU_ERRORDETECTED	0x0403
#define DU_ERRORCORRECTED	0x0404
#define DU_OPUPDATE		0x0405
#define DU_READ 		0x0406
#define DU_WRITE		0x0407
#define DU_OPCOMPLETE		0x0408
#define DU_YIELD		0x0409
#define DU_ENGINERESTART	0x040A

#define DU_EXTENSION_FIRST	0x2000
#define DU_EXTENSION_LAST	0x2FFF

// Following errors are also Bits, rest are just values
// ERRFAT		   0x0400
// ERRTOS		   0x0004
// ERRNOOS		   0x0008
// ERRVOLLABEL		   0x0010
// ERRFBOOT		   0x0020
// ERRROOTD		   0x0040
// ERROSAREA		   0x0080
// ERRDATA		   0x0100
// ERRMBR		   0x0200
// ERRCVFHD		   0x0800
#define ERRNOUFOR	   3
//	ERRTOS		   4
#define ERRBADUFOR	   5
#define ERRDSKWRT	   6
#define ERRINVFMT	   7
//	ERRNOOS 	   8
#define ERRNOQUICK	   9
#define READERROR	   10
#define WRITEERROR	   11
#define FATERRMISMAT	   12
#define FATERRLSTCLUS	   13
#define FATERRXLNK	   14
    #define	ERRXLNKDIR	0x0001
    #define	ERRCANTDEL	0x8000
#define FATERRFILE	   15
    #define	ERRINVLFN	0x0001
    #define	ERRINVNM	0x0002
    #define	ERRSIZE 	0x0004
    #define	ERRDTTM1	0x0008
    #define	ERRDTTM2	0x0010
    #define	ERRDTTM3	0x0020
    #define	ERRLFNSTR	0x0040
    #define	ERRDEVNM	0x0080
    #define	ERRLFNLEN	0x0100
    //		ERRCANTDEL	0x8000
//	ERRVOLLABEL	   16
#define FATERRDIR	   17
    #define	DBUFAPP 	0x0001
    #define	ERRBAD		0x0002
    #define	ERRDOTS 	0x0004
    #define	ERRPNOTD	0x0008
    #define	ERRLFNSRT	0x0010
    #define	ERRZRLEN	0x0020
    #define	ERRLFNLST	0x0040
    #define	ERRLOSTFILE	0x0080
    #define	ERRDUPNM	0x0100
    //		ERRCANTDEL	0x8000
#define FATERRBOOT	   18
    #define	ERRSIG1 	0x0004
    #define	ERRSIG2 	0x0008
    #define	ERROEMVER	0x0010
    #define	ERRBPB		0x0020
    #define	ERRINVPRT	0x0040
    #define	ERRINCPRT	0x0080
    //		ERRMBR		0x0100
#define FULLCORR	   19
#define NOCORR		   20
#define PCORROK 	   21
#define PCORRBAD	   22
    #define	APPFIX		0x0001
    #define	CANTMARK	APPFIX
    #define	DISKERR 	0x0002
    #define	NOMEM		0x0004
    #define	FILCRT		0x0008
    #define	FILCOLL 	0x0010
    #define	CLUSALLO	0x0020
    #define	UNEXP		0x0040
    #define	DIRCRT		0x0080
    #define	CANTFIX 	0x0100
#define FATERRRESVAL	   23
#define FATERRCIRCC	   24
    //		ERRCANTDEL	0x8000
#define FATERRINVCLUS	   25
    #define	ERRINVC 	0x0001
    #define	ERRINVFC	0x0002
    //		ERRCANTDEL	0x8000
#define FATERRCDLIMIT	   26
    #define	ERRDLNML	0x0001
    #define	ERRDSNML	0x0002
    //		ERRCANTDEL	0x8000
#define FATERRVOLLAB	   27
    #define	ISFRST		0x0001
#define MEMORYERROR	   28
    //		RETRY		0x0001
    //		RECOV		0x0002
    #define	GLBMEM		0x0004
    #define	LOCMEM		0x0008
#define FATERRMXPLEN	   29
    //		ERRINVLFN	0x0001
    //		ERRCANTDEL	0x8000
#define ERRISBAD	   30
#define ERRISNTBAD	   31
//	ERRFBOOT	   32
    //		RETRY		0x0001
    //		RECOV		0x0002
    //		GLBMEM		0x0004
    //		LOCMEM		0x0008
    //		ERRFBOOT	0x0020
    //		ERRROOTD	0x0040
    //		ERRDATA 	0x0100
    //		ERRFAT		0x0400
    #define	RDFAIL		0x4000
    #define	WRTFAIL 	0x8000
#define ERRNOFILE	   33
#define ERRLOCKV	   34
    //		RETRY		0x0001
#define DDERRSIZE1	   35
#define DDERRFRAG	   36
#define DDERRALIGN	   37
#define DDERRSIG	   38
    //		RETRY		0x0001
    //		RECOV		0x0002
    //		ERRSIG1 	0x0004
    //		ERRSIG2 	0x0008
#define DDERRBOOT	   39
#define DDERRSIZE2	   40
#define DDERRCVFNM	   41
    //		RETRY		0x0001
    //		RECOV		0x0002
    #define	CHNGTONEW	0x0004
#define DDERRMDBPB	   42
#define DDERRMDFAT	   43
    //		RETRY		0x0001
    //		RECOV		0x0002
    #define	GTMXCLUS	0x0004
    #define	INVCHEAP	0x0008
#define DDERRLSTSQZ	   44
#define DDERRXLSQZ	   45
    //		RETRY		0x0001
    //		RECOV		0x0002
    #define DUPFILE		0x0004
    #define LOSTSQZ		0x0008
    //		ERRCANTDEL	0x8000
#define DDERRUNSUP	   46
    #define	ISBETA		0x0001
    #define	ISSUPER 	0x0002
//	ERRROOTD	   64
//	ERROSAREA	   128
//	ERRDATA 	   256
//	ERRMBR		   512
//			   1024
//	ERRCVFHD	   2048


#define RETRY		0x0001
#define RECOV		0x0002
#define BADCHRS 	0x0004
#define BADSEC		0x0008
#define DISKFULL	0x0010
#define OSFILESPACE	0x0020
#define WRTPROT 	0x0040
#define NOTRDY		0x0080
// The following must not conflict with RETRY and RECOV only
#define MBR		0x0010
#define FAT1		0x0020
#define FAT2		0x0040
#define FATN		0x0080
#define FATMIX		0x0100
#define ROOTD		0x0200
#define DIR		0x0400
#define DATA		0x0800

#define ERETCAN2	0
#define ERETAFIX	0
#define ERETIGN2	0
#define ERETIGN 	1
#define ERETRETRY	2
#define ERETCAN 	3
#define ERETWFAT	4
#define ERETAPPFIX	5
#define ERETFREE	6
#define ERETMKFILS	7
#define ERETDELALL	8
#define ERETMKCPY	9
#define ERETSVONED	10
#define ERETTNCALL	11
#define ERETSVONET	12
#define ERETWRTFIX	13
#define ERETDELDIR	14
#define ERETMVDIR	15
#define ERETMVFIL	ERETMVDIR
#define ERETRDDIR	16
#define ERETMRKBAD	17

// Bit defines specific to DU_ENGINERESTART for DMaint_FixDrive
#define OTHERWRT	0x0001
#define LOSTDIR 	0x0002
#define XLNKSQZ 	0x0004
//	LOSTSQZ 	0x0008

DWORD WINAPI DMaint_GetFormatOptions(UINT Drive, LPFMTINFOSTRUCT lpFmtInfoBuf, UINT nSize);

DWORD WINAPI DMaint_FormatDrive(LPFMTINFOSTRUCT lpFmtInfoBuf, DWORD Options, DSKUTILCBPROC lpfnCallBack, LPARAM lRefData);

DWORD WINAPI DMaint_UnFormatDrive(LPFMTINFOSTRUCT lpFmtInfoBuf, DWORD Options, DSKUTILCBPROC lpfnCallBack, LPARAM lRefData);

//
// Structures and defines for DMaint_GetFixOptions and DMaint_FixDrive
//
typedef struct tagFIXFATDISP {
	BYTE		TotalPcntCmplt;
	BYTE		CurrOpRegion;
	WORD		Flags;
	WORD		BitArrSz;
	DWORD		SysAreaCnt;
	LPDRVPARMSTRUCT lpParmBuf;
	DWORD		Options;
	LPDWORD 	lpVisitBitArray;
	LPDWORD 	lpDirBitArray;
	LPDWORD 	lpAllocedBitArray;
	LPDWORD 	lpBadBitArray;
	LPDWORD 	lpLostBitArray;
	LPDWORD 	lpUnMovBitArray;
	DWORD		SerialNumber;
	BYTE		VolLabel[MAXFNAMELEN];
	WORD		VolLabelDate;
	WORD		VolLabelTime;
	BYTE		reserved[40];
} FIXFATDISP;
typedef FIXFATDISP*	  PFIXFATDISP;
typedef FIXFATDISP NEAR* NPFIXFATDISP;
typedef FIXFATDISP FAR*  LPFIXFATDISP;

typedef struct tagFATFIXREPORT {
	DWORD	TotDiskSzByte;
	DWORD	TotDiskSzK;
	DWORD	TotDiskSzM;
	DWORD	BadDataClusCnt;
	DWORD	BadSzDataByte;
	DWORD	BadSzDataK;
	DWORD	BadSzDataM;
	DWORD	TotBadSecCntSys;
	DWORD	BadSecCntResvd;
	DWORD	BadSecCntFAT;
	DWORD	BadSecCntRootDir;
	DWORD	HidFileCnt;
	DWORD	HidSzByte;
	DWORD	HidSzK;
	DWORD	HidSzM;
	DWORD	DirFileCnt;
	DWORD	DirSzByte;
	DWORD	DirSzK;
	DWORD	DirSzM;
	DWORD	UserFileCnt;
	DWORD	UserSzByte;
	DWORD	UserSzK;
	DWORD	UserSzM;
	DWORD	AvailSzByte;
	DWORD	AvailSzK;
	DWORD	AvailSzM;
	DWORD	BytesPerClus;
	DWORD	TotDataClus;
	DWORD	AvailDataClus;
	DWORD	BadClusRelocFailCnt;
	DWORD	BadClusUnMovFailCnt;
	DWORD	BadDataClusNew;
	DWORD	BadDataClusConf;
	DWORD	BadDataClusRecl;
	WORD	Flags;
} FATFIXREPORT;
typedef FATFIXREPORT*	    PFATFIXREPORT;
typedef FATFIXREPORT NEAR* NPFATFIXREPORT;
typedef FATFIXREPORT FAR*  LPFATFIXREPORT;

// Defines for Flags
#define REPLACEDISK	0x0001
#define REFORMAT	0x0002
#define HOSTFILE	0x0004
#define SWAPFILE	0x0008
#define OSFILE		0x0010
#define SPCLFILE	0x0020

typedef struct tagFATLOSTCLUSERR {
	DWORD	LostClusCnt;
	DWORD	LostClusChainCnt;
	DWORD	RootDirFreeEntCnt;
	WORD	FileFirstDigits;
	WORD	FileLastDigits;
	LPSTR	LostClusSaveDir;
	WORD	DirRecvCnt;
	WORD	LstAsFilesInDirs;
} FATLOSTCLUSERR;
typedef FATLOSTCLUSERR*       PFATLOSTCLUSERR;
typedef FATLOSTCLUSERR NEAR* NPFATLOSTCLUSERR;
typedef FATLOSTCLUSERR FAR*  LPFATLOSTCLUSERR;

typedef struct tagXLNKFILE {
	DWORD	FileFirstCluster;
	DWORD	LastSecNumNotXLnked;
	LPSTR	FileName;
	DWORD	reserved;
	BYTE	FileAttributes;
	BYTE	Flags;
} XLNKFILE;
typedef XLNKFILE*	PXLNKFILE;
typedef XLNKFILE NEAR* NPXLNKFILE;
typedef XLNKFILE FAR*  LPXLNKFILE;

//
// Flags bits
//
#define XFF_ISSWAP	0x01
#define XFF_ISCVF	0x02
#define XFF_ISSYSDIR	0x04
#define XFF_ISSYSFILE	0x08

typedef struct tagFATXLNKERR {
	DWORD	    XLnkCluster;
	DWORD	    XLnkFrstSectorNum;
	DWORD	    XLnkClusCnt;
	WORD	    XLnkFileCnt;
	XLNKFILE    XLnkList[];
} FATXLNKERR;
typedef FATXLNKERR*	  PFATXLNKERR;
typedef FATXLNKERR NEAR* NPFATXLNKERR;
typedef FATXLNKERR FAR*  LPFATXLNKERR;

//
// Following is provided because sizeof(FATXLNKERR) is illegal. This
// define is the size in bytes of FATXLNKERR up to XLnkList (the size
// without the dynamic part).
//
#define BASEFATXLNKERRSZ  (4+4+4+2)

typedef struct tagDDXLNKERR {
	LPDWORD     DDXLnkClusterList;
	DWORD	    DDXLnkClusCnt;
	WORD	    DDXLnkFileCnt;
	LPXLNKFILE  DDXLnkList;
} DDXLNKERR;
typedef DDXLNKERR*	 PDDXLNKERR;
typedef DDXLNKERR NEAR* NPDDXLNKERR;
typedef DDXLNKERR FAR*	LPDDXLNKERR;


typedef struct tagFATFILEERR {
	LPSTR	lpDirName;
	LPSTR	lpLFNFileName;
	LPSTR	lpShortFileName;
	DWORD	ClusterFileSize;
	DWORD	FileFirstCluster;
	DWORD	DirFirstCluster;
	DWORD	DirSectorIndex;
	DWORD	DirEntryIndex;
	DWORD	DirEntCnt;
	LPVOID	lpFileDirEnts;
	LPARAM	lParam1;
	LPARAM	lParam2;
	LPARAM	lParam3;
	DWORD	ExtAtt;
	BYTE	FileAttribute;
} FATFILEERR;
typedef FATFILEERR*	  PFATFILEERR;
typedef FATFILEERR NEAR* NPFATFILEERR;
typedef FATFILEERR FAR*  LPFATFILEERR;

typedef struct tagFATDIRERR {
	LPSTR	lpDirName;
	DWORD	DirFirstCluster;
	DWORD	DirFirstSectorNum;
	DWORD	DirReadBufSizeBytes;
	LPVOID	lpDirReadBuf;
	LPARAM	lParam1;
	LPARAM	lParam2;
	LPARAM	lParam3;
} FATDIRERR;
typedef FATDIRERR*	 PFATDIRERR;
typedef FATDIRERR NEAR* NPFATDIRERR;
typedef FATDIRERR FAR*	LPFATDIRERR;

typedef struct tagFATBOOTERR {
	DWORD	BootSectorNum;
	DWORD	BootBufSizeSectors;
	LPVOID	lpBootBuf;
	LPARAM	lParam1;
	LPARAM	lParam2;
	LPARAM	lParam3;
} FATBOOTERR;
typedef FATBOOTERR*	  PFATBOOTERR;
typedef FATBOOTERR NEAR* NPFATBOOTERR;
typedef FATBOOTERR FAR*  LPFATBOOTERR;

//
// Max number of conflicting files for LFNSORT error
//
#define MAXLFNSORT 8
//
// Max number of LFN directory entry extensions
//
#define MAXLFNEXT  10

typedef struct tagLFNSORT {
	DWORD	FileCnt;
	DWORD	Flags;
	LPSTR	lpShortNames[MAXLFNSORT];
	LPSTR	lpLFNResolve[MAXLFNEXT][MAXLFNSORT];
	LPSTR	lpLFNExtName0[MAXLFNSORT];
	LPSTR	lpLFNExtName1[MAXLFNSORT];
	LPSTR	lpLFNExtName2[MAXLFNSORT];
	LPSTR	lpLFNExtName3[MAXLFNSORT];
	LPSTR	lpLFNExtName4[MAXLFNSORT];
	LPSTR	lpLFNExtName5[MAXLFNSORT];
	LPSTR	lpLFNExtName6[MAXLFNSORT];
	LPSTR	lpLFNExtName7[MAXLFNSORT];
	LPSTR	lpLFNExtName8[MAXLFNSORT];
	LPSTR	lpLFNExtName9[MAXLFNSORT];
} LFNSORT;
typedef LFNSORT*       PLFNSORT;
typedef LFNSORT NEAR* NPLFNSORT;
typedef LFNSORT FAR*  LPLFNSORT;

//
// DMaint_GetFixOptions flags
//
#define FSINVALID	0x00000001L
#define FSDISALLOWED	0x00000002L
#define FSISACTIVE	0x00000004L
#define FSALWAYSACTIVE	0x00000008L
#define FSSFTEXCLUSIVE	0x00000010L
#define FSHRDEXCLUSIVE	0x00000020L
#define FSEXCLUSIVEREQ	0x00000040L

//
// DMaint_FixDrive options
//
#define FDO_AUTOFIX	  0x00000001L
#define FDO_NOFIX	  0x00000002L
#define FDO_LOWPRIORITY   0x00000004L
#define FDO_HRDEXCLUSIVE  0x00000008L
#define FDO_SFTEXCLUSIVE  0x00000010L
#define FDO_EXCLBLOCK	  0x00000020L
#define FDO_ALREADYLOCKED 0x00000040L
#define FDOS_WRTTST	  0x00000080L
#define FDOS_NOSRFANAL	  0x00000100L

#define FDOFAT_LSTMKFILE  0x00010000L
#define FDOFAT_NOXLNKLIST 0x00020000L
#define FDOFAT_XLNKDEL	  0x00040000L
#define FDOFAT_XLNKCPY	  0x00080000L
#define FDOFAT_NOCHKDT	  0x00100000L
#define FDOFAT_NOCHKNM	  0x00200000L
#define FDOFAT_CHKNMMAP   0x00400000L
#define FDOFAT_INVDIRIGN  0x00800000L
#define FDOFAT_INVDIRDEL  0x01000000L
#define FDOFAT_CHKDUPNM   0x02000000L
#define FDOSFAT_NMHISSYS  0x04000000L
#define FDOSFAT_NOSYSTST  0x08000000L
#define FDOSFAT_NODATATST 0x10000000L
#define FDOFAT_MKOLDFS	  0x20000000L

DWORD WINAPI DMaint_GetFixOptions(LPDRVPARMSTRUCT lpParmBuf);

DWORD WINAPI DMaint_FixDrive(LPDRVPARMSTRUCT lpParmBuf, DWORD Options, DSKUTILCBPROC lpfnCallBack, LPARAM lRefData);

//
// Structures and defines for DMaint_GetOptimizeOptions and DMaint_OptimizeDrive
//
DWORD WINAPI DMaint_GetOptimizeOptions(LPDRVPARMSTRUCT lpParmBuf);

DWORD WINAPI DMaint_OptimizeDrive(LPDRVPARMSTRUCT lpParmBuf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\drawdib.h ===
/**************************************************************************

    DRAWDIB.H   - routines for drawing DIBs to the screen.

    Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.

    this code handles stretching and dithering with custom code.

    the following DIB formats are supported:

        8bpp
        16bpp
        24bpp

    drawing to:

        16 color DC         (will dither 8bpp down)
        256 (palletized) DC (will dither 16 and 24bpp down)
        Full-color DC       (will just draw it!)

**************************************************************************/

#ifndef _INC_DRAWDIB
#define _INC_DRAWDIB

#ifdef __cplusplus
extern "C" {
#endif

#ifndef RC_INVOKED
#ifndef VFWAPI
    #define VFWAPI  WINAPI
#ifdef WINAPIV
    #define VFWAPIV WINAPIV
#else
    #define VFWAPIV FAR CDECL
#endif
#endif
#endif

// begin_vfw32

typedef HANDLE HDRAWDIB; /* hdd */

/*********************************************************************

  DrawDib Flags

**********************************************************************/
#define DDF_UPDATE          0x0002          /* re-draw the last DIB */
#define DDF_SAME_HDC        0x0004          /* HDC same as last call (all setup) */
#define DDF_SAME_DRAW       0x0008          /* draw params are the same */
#define DDF_DONTDRAW        0x0010          /* dont draw frame, just decompress */
#define DDF_ANIMATE         0x0020          /* allow palette animation */
#define DDF_BUFFER          0x0040          /* always buffer image */
#define DDF_JUSTDRAWIT      0x0080          /* just draw it with GDI */
#define DDF_FULLSCREEN      0x0100          /* use DisplayDib */
#define DDF_BACKGROUNDPAL   0x0200	    /* Realize palette in background */
#define DDF_NOTKEYFRAME     0x0400          /* this is a partial frame update, hint */
#define DDF_HURRYUP         0x0800          /* hurry up please! */
#define DDF_HALFTONE        0x1000          /* always halftone */

#define DDF_PREROLL         DDF_DONTDRAW    /* Builing up a non-keyframe */
#define DDF_SAME_DIB        DDF_SAME_DRAW
#define DDF_SAME_SIZE       DDF_SAME_DRAW

/*********************************************************************

    DrawDib functions
	
*********************************************************************/
/*
**  DrawDibOpen()
**
*/
extern HDRAWDIB VFWAPI DrawDibOpen(void);

/*
**  DrawDibClose()
**
*/
extern BOOL VFWAPI DrawDibClose(HDRAWDIB hdd);

/*
** DrawDibGetBuffer()
**
*/
extern LPVOID VFWAPI DrawDibGetBuffer(HDRAWDIB hdd, LPBITMAPINFOHEADER lpbi, DWORD dwSize, DWORD dwFlags);

/*
**  DrawDibGetPalette()
**
**  get the palette used for drawing DIBs
**
*/
extern HPALETTE VFWAPI DrawDibGetPalette(HDRAWDIB hdd);


/*
**  DrawDibSetPalette()
**
**  get the palette used for drawing DIBs
**
*/
extern BOOL VFWAPI DrawDibSetPalette(HDRAWDIB hdd, HPALETTE hpal);

/*
**  DrawDibChangePalette()
*/
extern BOOL VFWAPI DrawDibChangePalette(HDRAWDIB hdd, int iStart, int iLen, LPPALETTEENTRY lppe);

/*
**  DrawDibRealize()
**
**  realize the palette in a HDD
**
*/
extern UINT VFWAPI DrawDibRealize(HDRAWDIB hdd, HDC hdc, BOOL fBackground);

/*
**  DrawDibStart()
**
**  start of streaming playback
**
*/
extern BOOL VFWAPI DrawDibStart(HDRAWDIB hdd, DWORD rate);

/*
**  DrawDibStop()
**
**  start of streaming playback
**
*/
extern BOOL VFWAPI DrawDibStop(HDRAWDIB hdd);

/*
**  DrawDibBegin()
**
**  prepare to draw
**
*/
extern BOOL VFWAPI DrawDibBegin(HDRAWDIB hdd,
                                    HDC      hdc,
                                    int      dxDst,
                                    int      dyDst,
                                    LPBITMAPINFOHEADER lpbi,
                                    int      dxSrc,
                                    int      dySrc,
                                    UINT     wFlags);
/*
**  DrawDibDraw()
**
**  actualy draw a DIB to the screen.
**
*/
extern BOOL VFWAPI DrawDibDraw(HDRAWDIB hdd,
                                   HDC      hdc,
                                   int      xDst,
                                   int      yDst,
                                   int      dxDst,
                                   int      dyDst,
                                   LPBITMAPINFOHEADER lpbi,
                                   LPVOID   lpBits,
                                   int      xSrc,
                                   int      ySrc,
                                   int      dxSrc,
                                   int      dySrc,
                                   UINT     wFlags);

/*
**  DrawDibUpdate()
**
**  redraw the last image (may only be valid with DDF_BUFFER)
*/
#define DrawDibUpdate(hdd, hdc, x, y) \
        DrawDibDraw(hdd, hdc, x, y, 0, 0, NULL, NULL, 0, 0, 0, 0, DDF_UPDATE)

/*
**  DrawDibEnd()
*/
extern BOOL VFWAPI DrawDibEnd(HDRAWDIB hdd);

/*
**  DrawDibTime()  [for debugging purposes only]
*/
typedef struct {
    LONG    timeCount;
    LONG    timeDraw;
    LONG    timeDecompress;
    LONG    timeDither;
    LONG    timeStretch;
    LONG    timeBlt;
    LONG    timeSetDIBits;
}   DRAWDIBTIME, FAR *LPDRAWDIBTIME;

BOOL VFWAPI DrawDibTime(HDRAWDIB hdd, LPDRAWDIBTIME lpddtime);

/* display profiling */
#define PD_CAN_DRAW_DIB         0x0001      /* if you can draw at all */
#define PD_CAN_STRETCHDIB       0x0002      /* basicly RC_STRETCHDIB */
#define PD_STRETCHDIB_1_1_OK    0x0004      /* is it fast? */
#define PD_STRETCHDIB_1_2_OK    0x0008      /* ... */
#define PD_STRETCHDIB_1_N_OK    0x0010      /* ... */

DWORD VFWAPI DrawDibProfileDisplay(LPBITMAPINFOHEADER lpbi);

// end_vfw32

#ifdef __cplusplus
}
#endif

#endif // _INC_DRAWDIB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\dvobj.h ===
/*****************************************************************************\
*                                                                             *
* dvobj.h -	Data/view value types, interface and APIs		      *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#if !defined( _DVOBJ_H_ )
#define _DVOBJ_H_

/****** DV value types ******************************************************/

//      forward type declarations
#if defined(__cplusplus)
interface IStorage;
interface IStream;
interface IAdviseSink;
interface IMoniker;
#else 
typedef interface IStorage IStorage;
typedef interface IStream IStream;
typedef interface IAdviseSink IAdviseSink;
typedef interface IMoniker IMoniker;
#endif

typedef            IStorage FAR* LPSTORAGE;
typedef             IStream FAR* LPSTREAM;
typedef         IAdviseSink FAR* LPADVISESINK;
typedef             IMoniker FAR* LPMONIKER;


#if !defined(_MAC)
typedef WORD CLIPFORMAT;
#else
typedef unsigned long CLIPFORMAT;            // ResType
#endif
typedef  CLIPFORMAT FAR* LPCLIPFORMAT;


// Data/View aspect; specifies the desired aspect of the object when 
// drawing or getting data.
typedef enum tagDVASPECT
{
    DVASPECT_CONTENT = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON = 4,
    DVASPECT_DOCPRINT = 8
} DVASPECT;


// Data/View target device; determines the device for drawing or gettting data
typedef struct FARSTRUCT tagDVTARGETDEVICE
{
    DWORD tdSize;
    WORD tdDriverNameOffset;
    WORD tdDeviceNameOffset;
    WORD tdPortNameOffset;
    WORD tdExtDevmodeOffset;
    BYTE tdData[1];
} DVTARGETDEVICE;


// Format, etc.; completely specifices the kind of data desired, including tymed
typedef struct FARSTRUCT tagFORMATETC
{
    CLIPFORMAT          cfFormat;
    DVTARGETDEVICE FAR* ptd;
    DWORD               dwAspect;
    LONG                lindex;
    DWORD               tymed;
} FORMATETC, FAR* LPFORMATETC;


// TYpes of storage MEDiums; determines how data is stored or passed around
typedef enum tagTYMED
{
    TYMED_HGLOBAL = 1,
    TYMED_FILE = 2,
    TYMED_ISTREAM = 4,
    TYMED_ISTORAGE = 8,
    TYMED_GDI = 16,
    TYMED_MFPICT = 32,
    TYMED_NULL = 0
} TYMED;


// DATA format DIRection
typedef enum tagDATADIR
{
    DATADIR_GET = 1,
    DATADIR_SET = 2,
} DATADIR;


// SToraGe MEDIUM; a block of data on a particular medium 
typedef struct FARSTRUCT tagSTGMEDIUM
{
    DWORD   tymed;
    union
    {
        HANDLE  hGlobal;
        LPSTR   lpszFileName;
        IStream FAR* pstm;
        IStorage FAR* pstg;
    }
#ifdef NONAMELESSUNION
    u       // add a tag when name less unions not supported
#endif
    ;
    IUnknown FAR* pUnkForRelease;
} STGMEDIUM, FAR* LPSTGMEDIUM;


// Advise Flags
typedef enum tagADVF
{
    ADVF_NODATA = 1,
    ADVF_PRIMEFIRST = 2,
    ADVF_ONLYONCE = 4,
    ADVF_DATAONSTOP = 64,
    ADVFCACHE_NOHANDLER = 8,
    ADVFCACHE_FORCEBUILTIN = 16,
    ADVFCACHE_ONSAVE = 32
} ADVF;


// Stats for data; used by several enumerations and by at least one 
// implementation of IDataAdviseHolder; if a field is not used, it
// will be NULL.
typedef struct FARSTRUCT tagSTATDATA
{                                   // field used by:
    FORMATETC formatetc;            // EnumAdvise, EnumData (cache), EnumFormats
    DWORD advf;                     // EnumAdvise, EnumData (cache)
    IAdviseSink FAR* pAdvSink;      // EnumAdvise
    DWORD dwConnection;             // EnumAdvise
} STATDATA;
    
typedef  STATDATA FAR* LPSTATDATA;



/****** DV Interfaces ***************************************************/


#undef  INTERFACE
#define INTERFACE   IEnumFORMATETC

DECLARE_INTERFACE_(IEnumFORMATETC, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumFORMATETC methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, FORMATETC FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumFORMATETC FAR* FAR* ppenum) PURE;
};
typedef        IEnumFORMATETC FAR* LPENUMFORMATETC;


#undef  INTERFACE
#define INTERFACE   IEnumSTATDATA

DECLARE_INTERFACE_(IEnumSTATDATA, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IEnumSTATDATA methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATDATA FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATDATA FAR* FAR* ppenum) PURE;
};
typedef        IEnumSTATDATA FAR* LPENUMSTATDATA;



#undef  INTERFACE
#define INTERFACE   IDataObject

#define DATA_E_FORMATETC        DV_E_FORMATETC
#define DATA_S_SAMEFORMATETC    (DATA_S_FIRST + 0)

DECLARE_INTERFACE_(IDataObject, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IDataObject methods ***
    STDMETHOD(GetData) (THIS_ LPFORMATETC pformatetcIn,
                            LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(GetDataHere) (THIS_ LPFORMATETC pformatetc,
                            LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(QueryGetData) (THIS_ LPFORMATETC pformatetc ) PURE;
    STDMETHOD(GetCanonicalFormatEtc) (THIS_ LPFORMATETC pformatetc,
                            LPFORMATETC pformatetcOut) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;
    STDMETHOD(EnumFormatEtc) (THIS_ DWORD dwDirection,
                            LPENUMFORMATETC FAR* ppenumFormatEtc) PURE;

    STDMETHOD(DAdvise) (THIS_ FORMATETC FAR* pFormatetc, DWORD advf, 
                    LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(DUnadvise) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumDAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
};                 
typedef      IDataObject FAR* LPDATAOBJECT;



#undef  INTERFACE
#define INTERFACE   IViewObject

#define VIEW_E_DRAW             (VIEW_E_FIRST)
#define E_DRAW                  VIEW_E_DRAW

#define VIEW_S_ALREADY_FROZEN   (VIEW_S_FIRST)

DECLARE_INTERFACE_(IViewObject, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IViewObject methods ***
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    HDC hdcDraw, 
                    const LPRECTL lprcBounds, 
                    const LPRECTL lprcWBounds,
                    BOOL (CALLBACK * pfnContinue) (DWORD), 
                    DWORD dwContinue) PURE;

    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    LPLOGPALETTE FAR* ppColorSet) PURE;

    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex, 
                    void FAR* pvAspect,
                    DWORD FAR* pdwFreeze) PURE;
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf, 
                    LPADVISESINK pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf, 
                    LPADVISESINK FAR* ppAdvSink) PURE;
};
typedef      IViewObject FAR* LPVIEWOBJECT;


#undef  INTERFACE
#define INTERFACE   IAdviseSink

DECLARE_INTERFACE_(IAdviseSink, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc, 
                            STGMEDIUM FAR* pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;
};
typedef      IAdviseSink FAR* LPADVISESINK;



#undef  INTERFACE
#define INTERFACE   IAdviseSink2

DECLARE_INTERFACE_(IAdviseSink2, IAdviseSink)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc, 
                            STGMEDIUM FAR* pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;

    // *** IAdviseSink2 methods ***
    STDMETHOD_(void,OnLinkSrcChange)(THIS_ LPMONIKER pmk) PURE;
};
typedef      IAdviseSink2 FAR* LPADVISESINK2;



#undef  INTERFACE
#define INTERFACE   IDataAdviseHolder

DECLARE_INTERFACE_(IDataAdviseHolder, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDataAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPDATAOBJECT pDataObject, FORMATETC FAR* pFetc, 
            DWORD advf, LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnDataChange)(THIS_ LPDATAOBJECT pDataObject, DWORD dwReserved, DWORD advf) PURE;
};
typedef      IDataAdviseHolder FAR* LPDATAADVISEHOLDER;



#undef  INTERFACE
#define INTERFACE   IOleCache

#define CACHE_E_NOCACHE_UPDATED         (CACHE_E_FIRST)

#define CACHE_S_FORMATETC_NOTSUPPORTED  (CACHE_S_FIRST)
#define CACHE_S_SAMECACHE               (CACHE_S_FIRST+1)
#define CACHE_S_SOMECACHES_NOTUPDATED   (CACHE_S_FIRST+2)


DECLARE_INTERFACE_(IOleCache, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleCache methods ***
    STDMETHOD(Cache) (THIS_ LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwConnection) PURE;
    STDMETHOD(Uncache) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumCache) (THIS_ LPENUMSTATDATA FAR* ppenumStatData) PURE;
    STDMETHOD(InitCache) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;
};
typedef         IOleCache FAR* LPOLECACHE;


/****** DV APIs ***********************************************************/


STDAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder);


#endif // _DVOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\dwconfig.inc ===
; ***************************************************************************
;
;   Microsoft Confidential
;   Copyright (C) Microsoft Corporation 1993
;   All Rights Reserved.
;
; ***************************************************************************
;
; MODIFICATION HISTORY
;
; Created:	8/30/93	NSM	
; 
; 11/15/93	NSM	Modified and moved so that this can be used both
;			in BIOS and DwConfigmg VxD
;
; ***************************************************************************



INCLUDE	DEVINFO.INC

OLD_CONFIGMGR_VXDID	equ	34h	; should match with vmm.h

CM_VERSION_NO	equ	0101h		; CONFIGMGR Version no
 

;
;
; CONFIG API function codes
;
CM_GetVersion	EQU	0
CM_GetConfig	EQU	1
CM_LockConfig	EQU	2
CM_UnlockConfig	EQU	3

;
; Various error codes returned by CONFIGMGR API
;
CM_DEVICE_NOT_FOUND		equ	1

CM_CONFIG_ERROR			equ	1	
CM_IO_PORT_UNAVAILABLE		equ	2  
CM_IRQ_UNAVAILABLE		equ	4  
CM_DMA_CH_UNAVAILABLE		equ	8	
CM_MEM_WINDOW_UNAVAILABLE	equ	10h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\fcext.h ===
#ifndef _SHLOBJ_H_
#include "..\inc\shlobj.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines constants for the file control options used
*   by the open() function.
*   [System V]
*
****/

#ifndef _INC_FCNTL

#define _O_RDONLY   0x0000  /* open for reading only */
#define _O_WRONLY   0x0001  /* open for writing only */
#define _O_RDWR     0x0002  /* open for reading and writing */
#define _O_APPEND   0x0008  /* writes done at eof */

#define _O_CREAT    0x0100  /* create and open file */
#define _O_TRUNC    0x0200  /* open and truncate */
#define _O_EXCL     0x0400  /* open only if file doesn't already exist */

/* _O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT     0x4000  /* file mode is text (translated) */
#define _O_BINARY   0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define O_RDONLY    _O_RDONLY
#define O_WRONLY    _O_WRONLY
#define O_RDWR      _O_RDWR
#define O_APPEND    _O_APPEND
#define O_CREAT     _O_CREAT
#define O_TRUNC     _O_TRUNC
#define O_EXCL      _O_EXCL
#define O_TEXT      _O_TEXT
#define O_BINARY    _O_BINARY
#define O_NOINHERIT _O_NOINHERIT
#endif 

#define _INC_FCNTL
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\float.h ===
/***
*float.h - constants for floating point values
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains defines for a number of implementation dependent
*   values which are commonly used by sophisticated numerical (floating
*   point) programs.
*   [ANSI]
*
****/

#ifndef _INC_FLOAT

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#define DBL_DIG     15          /* # of decimal digits of precision */
#define DBL_EPSILON 2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53          /* # of bits in mantissa */
#define DBL_MAX     1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308         /* max decimal exponent */
#define DBL_MAX_EXP 1024            /* max binary exponent */
#define DBL_MIN     2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)          /* min decimal exponent */
#define DBL_MIN_EXP (-1021)         /* min binary exponent */
#define _DBL_RADIX  2           /* exponent radix */
#define _DBL_ROUNDS 1           /* addition rounding: near */

#define FLT_DIG     6           /* # of decimal digits of precision */
#define FLT_EPSILON 1.192092896e-07F    /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD   0
#define FLT_MANT_DIG    24          /* # of bits in mantissa */
#define FLT_MAX     3.402823466e+38F    /* max value */
#define FLT_MAX_10_EXP  38          /* max decimal exponent */
#define FLT_MAX_EXP 128         /* max binary exponent */
#define FLT_MIN     1.175494351e-38F    /* min positive value */
#define FLT_MIN_10_EXP  (-37)           /* min decimal exponent */
#define FLT_MIN_EXP (-125)          /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX   2           /* exponent radix */
#define FLT_ROUNDS  1           /* addition rounding: near */

#define LDBL_DIG    18          /* # of decimal digits of precision */
#define LDBL_EPSILON    1.084202172485504434e-019L /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   64          /* # of bits in mantissa */
#define LDBL_MAX    1.189731495357231765e+4932L /* max value */
#define LDBL_MAX_10_EXP 4932            /* max decimal exponent */
#define LDBL_MAX_EXP    16384           /* max binary exponent */
#define LDBL_MIN    3.3621031431120935063e-4932L /* min positive value */
#define LDBL_MIN_10_EXP (-4931)         /* min decimal exponent */
#define LDBL_MIN_EXP    (-16381)        /* min binary exponent */
#define _LDBL_RADIX 2           /* exponent radix */
#define _LDBL_ROUNDS    1           /* addition rounding: near */


/*
 *  8087/80287 math control information
 */


/* User Control Word Mask and bit definitions.
 * These definitions match the 8087/80287
 */

#define _MCW_EM     0x003f      /* interrupt Exception Masks */
#define _EM_INVALID 0x0001      /*   invalid */
#define _EM_DENORMAL    0x0002      /*   denormal */
#define _EM_ZERODIVIDE  0x0004      /*   zero divide */
#define _EM_OVERFLOW    0x0008      /*   overflow */
#define _EM_UNDERFLOW   0x0010      /*   underflow */
#define _EM_INEXACT 0x0020      /*   inexact (precision) */

#define _MCW_IC     0x1000      /* Infinity Control */
#define _IC_AFFINE  0x1000      /*   affine */
#define _IC_PROJECTIVE  0x0000      /*   projective */

#define _MCW_RC     0x0c00      /* Rounding Control */
#define _RC_CHOP    0x0c00      /*   chop */
#define _RC_UP      0x0800      /*   up */
#define _RC_DOWN    0x0400      /*   down */
#define _RC_NEAR    0x0000      /*   near */

#define _MCW_PC     0x0300      /* Precision Control */
#define _PC_24      0x0000      /*    24 bits */
#define _PC_53      0x0200      /*    53 bits */
#define _PC_64      0x0300      /*    64 bits */


/* initial Control Word value */

#define _CW_DEFAULT ( _IC_AFFINE + _RC_NEAR + _PC_64 + _EM_DENORMAL + _EM_UNDERFLOW + _EM_INEXACT )


/* user Status Word bit definitions */

#define _SW_INVALID 0x0001  /* invalid */
#define _SW_DENORMAL    0x0002  /* denormal */
#define _SW_ZERODIVIDE  0x0004  /* zero divide */
#define _SW_OVERFLOW    0x0008  /* overflow */
#define _SW_UNDERFLOW   0x0010  /* underflow */
#define _SW_INEXACT 0x0020  /* inexact (precision) */


/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED      0x0040  /* unemulated instruction */
#define _SW_SQRTNEG     0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW   0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW  0x0400  /* FP stack underflow */


/*  Floating point error signals and return codes */

#define _FPE_INVALID        0x81
#define _FPE_DENORMAL       0x82
#define _FPE_ZERODIVIDE     0x83
#define _FPE_OVERFLOW       0x84
#define _FPE_UNDERFLOW      0x85
#define _FPE_INEXACT        0x86

#define _FPE_UNEMULATED     0x87
#define _FPE_SQRTNEG        0x88
#define _FPE_STACKOVERFLOW  0x8a
#define _FPE_STACKUNDERFLOW 0x8b

#define _FPE_EXPLICITGEN    0x8c    /* raise( SIGFPE ); */


/* function prototypes */

unsigned int __cdecl _clear87(void);
unsigned int __cdecl _control87(unsigned int, unsigned int);
void __cdecl _fpreset(void);
unsigned int __cdecl _status87(void);


#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define DBL_RADIX       _DBL_RADIX
#define DBL_ROUNDS      _DBL_ROUNDS

#define LDBL_RADIX      _LDBL_RADIX
#define LDBL_ROUNDS     _LDBL_ROUNDS

#define MCW_EM          _MCW_EM
#define EM_INVALID      _EM_INVALID
#define EM_DENORMAL     _EM_DENORMAL
#define EM_ZERODIVIDE       _EM_ZERODIVIDE
#define EM_OVERFLOW     _EM_OVERFLOW
#define EM_UNDERFLOW        _EM_UNDERFLOW
#define EM_INEXACT      _EM_INEXACT

#define MCW_IC          _MCW_IC
#define IC_AFFINE       _IC_AFFINE
#define IC_PROJECTIVE       _IC_PROJECTIVE

#define MCW_RC          _MCW_RC
#define RC_CHOP         _RC_CHOP
#define RC_UP           _RC_UP
#define RC_DOWN         _RC_DOWN
#define RC_NEAR         _RC_NEAR

#define MCW_PC          _MCW_PC
#define PC_24           _PC_24
#define PC_53           _PC_53
#define PC_64           _PC_64

#define CW_DEFAULT      _CW_DEFAULT

#define SW_INVALID      _SW_INVALID
#define SW_DENORMAL     _SW_DENORMAL
#define SW_ZERODIVIDE       _SW_ZERODIVIDE
#define SW_OVERFLOW     _SW_OVERFLOW
#define SW_UNDERFLOW        _SW_UNDERFLOW
#define SW_INEXACT      _SW_INEXACT

#define SW_UNEMULATED       _SW_UNEMULATED
#define SW_SQRTNEG      _SW_SQRTNEG
#define SW_STACKOVERFLOW    _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW   _SW_STACKUNDERFLOW

#define FPE_INVALID     _FPE_INVALID
#define FPE_DENORMAL        _FPE_DENORMAL
#define FPE_ZERODIVIDE      _FPE_ZERODIVIDE
#define FPE_OVERFLOW        _FPE_OVERFLOW
#define FPE_UNDERFLOW       _FPE_UNDERFLOW
#define FPE_INEXACT     _FPE_INEXACT

#define FPE_UNEMULATED      _FPE_UNEMULATED
#define FPE_SQRTNEG     _FPE_SQRTNEG
#define FPE_STACKOVERFLOW   _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW  _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN     _FPE_EXPLICITGEN

#endif 


#ifdef __cplusplus
}
#endif 

#define _INC_FLOAT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\fce.h ===
//***************************************************************************
//
// Typedefs and Function proto for Forced Configuration Edit (FCE)
// support.
// These function are in FCE.C, which is part of SETUPX.DLL
//
//***************************************************************************

#define NOT_VXD
#include <configmg.h>

#define ULONG_AT(x)     (*(LPULONG)(x))

typedef	WORD			FCERET;
typedef	LPVOID			LPREGLOGCONF;
typedef	ULONG		_far	*LPULONG;

#define	FCE_OK			0x00000000
#define	FCE_OK_IS_ALLOC		0x00000001
#define	FCE_OK_IS_NOT_ALLOC	0x00000002
#define	FCE_OK_IS_IN_CONFLICT	0x00000003
#define	FCE_ERROR		0x00000004
#define	FCE_NO_MORE		0x00000005

#define REGSTR_VAL_FORCEDCONFIG "ForcedConfig"		//

typedef union _RESOURCE_POINTER {
    LPBYTE              pRaw;
    LPDWORD             pDword;
    MEM_RESOURCE FAR    *pMem;
    IO_RESOURCE FAR     *pIo;
    DMA_RESOURCE FAR    *pDma;
    IRQ_RESOURCE FAR    *pIrq;
}   RESOURCE_POINTER;

typedef struct _ASSIGN_RESOURCES_DATA {
    LPDEVICE_INFO lpdi;
    UINT EnabledBits;
    UINT AutomaticBits;
}   ASSIGN_RESOURCES_DATA, FAR* LPASSIGN_RESOURCES_DATA;

FCERET WINAPI
FCEInit(DWORD dwFlags);

#define FCE_FLAGS_USECONFIGMG       0x00000001

FCERET WINAPI
FCEGetResDes(LPREGLOGCONF pLogConf, WORD wResNumber, PRESOURCEID PResType);

FCERET WINAPI
FCEGetFirstValue(DEVNODE dnDevNode, LPREGLOGCONF pLogConf, WORD wResNumber, LPULONG pulValue, LPULONG pulLen);

FCERET WINAPI
FCEGetOtherValue(DEVNODE dnDevNode, LPREGLOGCONF pLogConf, WORD wResNumber, BOOL bNext, LPULONG pulValue, LPULONG pulLen);

FCERET WINAPI
FCEGetValidateValue(DEVNODE dnDevNode, LPREGLOGCONF pLogConf, WORD wResNumber, ULONG ulValue, ULONG ulLen, LPULONG pulValue, LPULONG pulLen);

FCERET WINAPI
FCEWriteThisForcedConfigNow(LPREGLOGCONF pLogConf, HKEY hkey);

FCERET WINAPI
FCEAddResDes(LPREGLOGCONF pLogConf, LPBYTE lpResDes, ULONG ulResDesSize, RESOURCEID ResType);

FCERET WINAPI
FCEDeleteResDes(LPREGLOGCONF pLogConf, WORD wResNumber, LPULONG pulNewSize);

FCERET WINAPI
FCEGetAllocValue(LPREGLOGCONF pLogConf, WORD wResNumber, LPULONG pulValue, LPULONG pulLen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\find.h ===
/**********************************************************************
//	FIND.H
//
//		Copyright (c) 1992 - Microsoft Corp.
//		All rights reserved.
//		Microsoft Confidential
//
//	Include file with #defines and prototypes for qgrep functions used
//	by the Jaguar search engine.
**********************************************************************/

#include	<setjmp.h>

//*********************************************************************
//	Constant definitions.
//*********************************************************************

#if 0
typedef long (far pascal *FIND_CALLBACK)( int Func, unsigned uArg0,\
									 	 				void far *pArg1, void far *pArg2,\
										 	 			void far *pArg3 );

#define	FLG_FIND_NOMATCH	0x0001		// Display non-matching lines
#define	FLG_FIND_COUNT		0x0002		// Display on count of matching lines
#define	FLG_FIND_LINENO	0x0004		// Display line numbers on output
#endif

#define	FIND_FILE			0x0100		// Only searching for a file (EXCLUSIVE)
#define	FIND_NOT				0x0200		// Searching for /NOT strings


#define BUFLEN		256						// Temporary buffer length
#define PATMAX		512						// Maximum parsed pattern length

#define	MAXSTRLEN	128					// Maximum search string length
#define	TRTABLEN		256					// Translation table length
													// Total bytes in StringList array
#define	STRING_LST_LEN		((TRTABLEN + 1) * sizeof(char *))

// #ifndef NOASM
//		#define match	exprmatch
// #endif

//*********************************************************************
//	Pattern token types.
//*********************************************************************

#define T_END		0							// End of expression
#define T_STRING	1							// String to match
#define T_SINGLE	2							// Single character to match
#define T_CLASS	3 							// Class to match
#define T_ANY		4							// Match any character
#define T_STAR		5							// *-expr

//*********************************************************************
//*********************************************************************

typedef struct stringnode
{
	struct stringnode *s_alt;				// List of alternates
	struct stringnode *s_suf;				// List of suffixes
	int s_must; 								// Length of portion that must match
}
STRINGNODE; 									// String node
													// Text field access macro

#define s_text(x) ( ((char *)(x)) + (sizeof( STRINGNODE ) + ((x)->s_must & 1)) )

//*********************************************************************
//	Type definitions.
//*********************************************************************

typedef struct exprnode
{
	struct exprnode	*ex_next;			// Next node in list
	struct exprnode	*ex_dummy;			// Needed by freenode()
	char					*ex_pattern; 		// Pointer to pattern to match
}
EXPR; 											// Expression node

//*********************************************************************
//	QGREP function prototypes
//*********************************************************************

extern void (*addstr)( char *s, int n );
extern char	*(*find)	( char *buffer, char *bufend );
extern void	(*flush1)( void );
extern int	(*grep)	( char *startbuf, char *endbuf, char *name, int *first );
extern void	(*write1)( char *buffer, int buflen );

int			InitGrepInfo( char *pStrLst, char *pNotList, unsigned uOpts );
int			FreeGrepBufs( void );
int			InitGrepBufs( void );
int			FileFindGrep( int fHandle, unsigned fFlags,
								  long (far pascal *AppCb)( int Func,
																	 unsigned uArg0,
																	 void far *pArg1,
																	 unsigned long ulArg2 ) );
void			addexpr		( char *e, int n );
void 			addstring	( char *s, int n );
int			addstrings	( char *buffer, char *bufend, char *seplist, int *first );
void			addtoken		( char *e, int n );
char			*alloc		( unsigned size );
void			bitset		( unsigned char *bitvec, int first, int last, int bitval );
int			enumlist		( struct stringnode *node, int cchprev );
int			enumstrings	( void );
int			exprmatch	( char *s, char *p );
char			*exprparse	( char *p, int *NewBufLen );
char			*findall		( char *buffer, char *bufend );
char			*findlist	( char *buffer, char *bufend );
char			*findone		( char *buffer, char *bufend );
void			freenode		( struct stringnode *x );
char			*get1stcharset( char *e, unsigned char *bitvec );
int			isexpr		( char *s, int n );
int			istoken		( char *s, int n );
void			maketd1		( unsigned char *pch, int cch, int cchstart );
int			match			( char *s, char *p );
void			matchstrings( char *s1, char *s2, int len, int *nmatched,
								  int *leg );
STRINGNODE	*newnode		( char *s, int n );
static int	newstring	( unsigned char *s, int n );
char			*NextEol		( char *pchChar, char *EndBuf );
int			preveol		( char *s );

STRINGNODE	*reallocnode(  register STRINGNODE *node, char *s, int n );
char			*simpleprefix( char *s, char **pp );
int			strncspn		( char *s, char *t, int n );
int			strnspn		( char *s, char *t, int n );
char			*strnupr		( char *pch, int cch );
void			SwapSrchTables( void );
int			cmpicase		( char * buf1, char * buf2, unsigned int count );

char			*findexpr	( char *buffer, char *bufend );

//*********************************************************************
//	Bit flag definitions
//*********************************************************************

#define	SHOWNAME		0x001					// Print filename
#define	NAMEONLY		0x002					// Print filename only
#define	LINENOS		0x004					// Print line numbers
#define	BEGLINE		0x008					// Match at beginning of line
#define	ENDLINE		0x010					// Match at end of line
#define	DEBUG			0x020					// Print debugging output
#define	TIMER			0x040					// Time execution
#define	SEEKOFF		0x080					// Print seek offsets
#define	ALLLINES		0x100					// Print all lines before/after match
#define	COLNOS		0x200					// Show column numbers (if LINENOS)
#define	CNTMATCH		0x400					// Show count of matching lines
#define	NEWDISP		0x800

#ifndef TRUE
	#define	TRUE 1
#endif

#ifndef	FALSE
	#define FALSE 0
#endif

//*********************************************************************
//	Miscellaneous constants.
//*********************************************************************

#define	EOS				('\r')			// End of string character

//*********************************************************************
//	Data shared among source files.
//*********************************************************************

extern char	*Target;								// Buffer for srch string being added
extern int	CaseSen;								// Case-sensitivity flag
extern int	Flags;								// Flags
extern int	StrCount;							// String count
extern jmp_buf	ErrorJmp;						// Storage location for setjmp()

	// All of the data below is located in DATA.ASM to allow	swapping
	// blocks of search data with a single memmove() call.

#define	SWAP_LEN		((sizeof( int ) * 8) + (sizeof( char * ) * 4))
#define	INIT_LEN		(sizeof( int ) * 8)

	// Storage for "string" search trees.
extern int			DummyFirst;
extern int			TblEntriesUsed;			// Number of transtab entries used
extern int			ExprEntriesUsed;			// Number of expression strings used
extern int			StrCount;					// String count
extern int			TargetLen; 					// Length of last string added
extern int			MaxChar;						// Max char value in srch string
extern int			MinChar;						// Min char value in srch string
extern int			ShortStrLen;				// Min string length added to list
extern char				**ExprStrList;			// Array of ptrs to srch expressions
extern STRINGNODE		**StringList;			// Array of ptrs to srch strings
extern unsigned char	*td1;						// Ptr to TD1 shift table
extern unsigned char	*TransTable;			// Allocated in grepmain()

extern int			nDummyFirst;
extern int			nTblEntriesUsed;			// Number of transtab entries used
extern int			nExprEntriesUsed;			// Number of expression strings used
extern int			nStrCount;					// String count
extern int			nTargetLen; 				// Length of last string added
extern unsigned	nMaxChar;					// Max char value in search string
extern unsigned 	nMinChar;					// Min char value in srch string
extern int			nShortStrLen;				// Min string length added to list
extern char				**nExprStrList;		// Array of ptrs to srch expressions
extern STRINGNODE		**nStringList;			// Array of ptrs to srch strings
extern unsigned char	*ntd1;					// Ptr to TD1 shift table
extern unsigned char	*nTransTable;			// Allocated in grepmain()


extern unsigned InitialSearchData;			// First word in area containing
														// initial search values.

extern char			*ReadBuf;					// Ptr to buffer for file reads
extern char			*Target;						// Tmp buf for string being added

extern unsigned char	*achcol;					// Ptr to collate table

//*********************************************************************
//	Added for purposes of integrating the message subsysstem
//*********************************************************************

struct sublistx
{
	unsigned char	size;	       			// sublist size			      
	unsigned char	reserved;      		// reserved for future growth	      
	unsigned far	*value;	      		// pointer to replaceable parm	      
	unsigned char	id;	       			// type of replaceable parm	      
	unsigned char	Flags;	      		// how parm is to be displayed	      
	unsigned char	max_width;     		// max width of replaceable field      
	unsigned char	min_width;     		// min width of replaceable field      
	unsigned char	pad_char;      		// pad character for replaceable field 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\imm.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the system-wide error numbers (set by
*   system calls).  Conforms to the XENIX standard.  Extended
*   for compatibility with Uniforum standard.
*   [ANSI/System V]
*
****/

#ifndef _INC_ERRNO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/* declare reference to errno */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
#define errno   (*_errno())
#else 
extern int __near __cdecl volatile errno;
#endif 

/* Error Codes */

#define EZERO       0
#define EPERM       1
#define ENOENT      2
#define ESRCH       3
#define EINTR       4
#define EIO     5
#define ENXIO       6
#define E2BIG       7
#define ENOEXEC     8
#define EBADF       9
#define ECHILD      10
#define EAGAIN      11
#define ENOMEM      12
#define EACCES      13
#define EFAULT      14
#define ENOTBLK     15
#define EBUSY       16
#define EEXIST      17
#define EXDEV       18
#define ENODEV      19
#define ENOTDIR     20
#define EISDIR      21
#define EINVAL      22
#define ENFILE      23
#define EMFILE      24
#define ENOTTY      25
#define ETXTBSY     26
#define EFBIG       27
#define ENOSPC      28
#define ESPIPE      29
#define EROFS       30
#define EMLINK      31
#define EPIPE       32
#define EDOM        33
#define ERANGE      34
#define EUCLEAN     35
#define EDEADLOCK   36

#ifdef __cplusplus
}
#endif 

#define _INC_ERRNO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\err.h ===
/***********************************************************************
//
// ERR.H
//
//		Copyright (c) 1992 - Microsoft Corp.
//		All rights reserved.
//		Microsoft Confidential
//
// Error values for file engine functions.
//
// johnhe - 03-13-92
***********************************************************************/

//**********************************************************************
//	Parsing errors
//**********************************************************************

#define	ERR_UNKNOWN					-1		// Unknown error
#define	ERR_UNKNOWN_SWITCH		-2		// Unknown criteria switch was specified
#define	ERR_NO_END_SEARCHSTR		-3		// No end search string delimiter
#define	ERR_DATE_FORMAT			-4		// Invalid date format
#define	ERR_TIME_FORMAT			-5		// Invalid time format
#define	ERR_DATE_COMBO				-6		// Invalid date combination
#define	ERR_SIZE_FORMAT			-7		// Invalid size format
#define	ERR_SIZE_COMBO				-8		// Invalid size combination
#define	ERR_ATTR_FORMAT			-9		// Invalid attribute format
#define	ERR_ATTR_COMBO				-10	// Invalid attribute combination
#define	ERR_MULT_SRCHSTR			-11	// Multiple search strings specified
#define	ERR_STRLST_LEN				-12	// Search string length is too long
#define	ERR_SRCH_EXPRESSION		-13	// Invalid search expression

#define	ERR_DUP_DESTINATION		-14	// Duplicate destination file specs
#define	ERR_SWITCH_COMBO			-15	// Invalid switch combination
#define	ERR_NO_SOURCE				-16	// No source filespec given
#define	ERR_NOT_ON_NAME			-17	// /NOT was applied to single filename

#define	ERR_FILESPEC_LEN			-18	// More than 1K of filespec strings
#define	ERR_NOT_FILE_LEN			-19	// More than 1K of !filespec strings

#define	ERR_INVALID_SRC_PATH		-20	// Invalid source path (not found)

#define	ERR_SOURCE_ISDEVICE		-21	// Source filespec is reserved device
#define	ERR_DEST_ISDEVICE			-22	// Dest. filespec is reserved device
#define	ERR_NO_DESTINATION		-23	// No destination was specified
#define	ERR_INVALID_PARAMETR		-24	// Extra parameter on cmd line

//**********************************************************************
//	System errors
//**********************************************************************

#define	ERR_NOMEMORY				-25	// Insuffient memory error
#define	ERR_MEM_CORRUPT			-26	// Error returned on MemFree()
#define	ERR_USER_ABORT				-27	// User aborted (CTRL+C)
#define	ERR_NOT_SUPPORTED			-28	// Unsupported callback request
#define	ERR_COLLATE_TABLE			-29	// Error on DOS call get collate table

//**********************************************************************
//	File or disk errors
//**********************************************************************

#define	ERR_BAD_FILESPEC			-50	// Bad file specification
#define	ERR_DIR_CREATE				-51	// Error creating a subdirectory entry
#define	ERR_FILE_READ				-52	// Error reading a file
#define	ERR_INVALID_DRIVE			-53	// Invalid drive specification
#define	ERR_INVALID_DESTINATION	-54	// Invalid destination filespec

//**********************************************************************
//	Copy errors
//**********************************************************************

#define	ERR_CPY_OVER_SELF			-75	// File cannot be copied over itself
#define	ERR_CLEAR_ARCHIVE			-76	// Error clearing file's archive bit
#define	ERR_RDONLY_DESTINATION	-77	// Destination file is readonly
#define	ERR_CYLINDRIC_COPY		-79	// Destination path is child of source

//**********************************************************************
//	Errors accessing a specified list file
//**********************************************************************

#define	ERR_FILELIST				-80	// Unknown error accessing the file list
#define	ERR_BAD_LISTFILE			-81	// File list was not found
#define	ERR_FILELIST_ACCESS		-82	// Sharing error accessing file list

//**********************************************************************
//	Resource load errors
//**********************************************************************

#define	ERR_READING_MSG			-100	// Error reading string resource
#define	ERR_MSG_LOADED				-101	// Strings have already been loaded

//**********************************************************************
//	Misc error values
//**********************************************************************

#define	ERR_DO_HELP					ERR_NO_SOURCE	// Display help
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the filebuf and fstream classes.
*   [AT&T C++]
*
****/

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#include <iostream.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef int filedesc;

class filebuf : public streambuf {
public:
static  const int   openprot;   // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int   sh_compat;  // compatibility share mode
static  const int   sh_none;    // exclusive mode no sharing
static  const int   sh_read;    // allow read sharing
static  const int   sh_write;   // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int   binary;
static  const int   text;

            filebuf();
            filebuf(filedesc);
            filebuf(filedesc, char _HFAR_ *, int);
            ~filebuf();

    filebuf*    attach(filedesc);
    filedesc    fd() const { return (x_fd==-1) ? EOF : x_fd; }
    int     is_open() const { return (x_fd!=-1); }
    filebuf*    open(const char _HFAR_ *, int, int = filebuf::openprot);
    filebuf*    close();
    int     setmode(int = filebuf::text);

virtual int     overflow(int=EOF);
virtual int     underflow();

virtual streambuf*  setbuf(char _HFAR_ *, int);
virtual streampos   seekoff(streamoff, ios::seek_dir, int);
// virtual  streampos   seekpos(streampos, int);
virtual int     sync();

private:
    filedesc    x_fd;
    int     x_fOpened;
};

class ifstream : public istream {
public:
    ifstream();
    ifstream(const char _HFAR_ *, int =ios::in, int = filebuf::openprot);
    ifstream(filedesc);
    ifstream(filedesc, char _HFAR_ *, int);
    ~ifstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int =ios::in, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class ofstream : public ostream {
public:
    ofstream();
    ofstream(const char _HFAR_ *, int =ios::out, int = filebuf::openprot);
    ofstream(filedesc);
    ofstream(filedesc, char _HFAR_ *, int);
    ~ofstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int =ios::out, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class fstream : public iostream {
public:
    fstream();
    fstream(const char _HFAR_ *, int, int = filebuf::openprot);
    fstream(filedesc);
    fstream(filedesc, char _HFAR_ *, int);
    ~fstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\initguid.h ===
// initguid.h - include after compobj.h to enable GUID initialization.  This 
//              must be done once per exe/dll.
//
// After this file, include one or more of the GUID definition files.
//
// NOTE: ole2.lib contains references to all GUIDs defined by OLE.

#ifndef DEFINE_GUID
#pragma error "initguid: must include compobj.h first."
#endif

#undef DEFINE_GUID

#ifdef _MAC
#define __based(a)
#endif

#ifdef WIN32
#define __based(a)
#endif

#ifdef __TURBOC__
#define __based(a)
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\int31.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	INT31.INC - Equates and Structures for Int 31h Interface
;
;   Version:	3.00
;
;   Date:	22-May-1989
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   22-May-1989 RAL Original
;
;==============================================================================



Int31_Sel_Mgt		EQU	00h
    SelMgt_Alloc_Sel	EQU	00h
    SelMgt_Free_Sel	EQU	01h
    SelMgt_Seg_To_Sel	EQU	02h
    SelMgt_Get_LDT_Base EQU	03h
    SelMgt_Lock_Sel	EQU	04h
    SelMgt_Unlock_Sel	EQU	05h
    SelMgt_Get_Base	EQU	06h
    SelMgt_Set_Base	EQU	07h
    SelMgt_Set_Limit	EQU	08h
    SelMgt_Set_Acc_Bits EQU	09h
    SelMgt_Alias_Sel	EQU	0Ah
    SelMgt_Get_Desc	EQU	0Bh
    SelMgt_Set_Desc	EQU	0Ch
    SelMgt_Get_Spec_Sel EQU	0Dh

Int31_DOS_Mem_Mgt	EQU	01h
    DOSMem_Allocate	EQU	00h
    DOSMem_Free 	EQU	01h
    DOSMem_Resize	EQU	02h

Int31_Int_Serv		EQU	02h
    Int_Get_Real_Vec	EQU	00h
    Int_Set_Real_Vec	EQU	01h
    Int_Get_Excep_Vec	EQU	02h
    Int_Set_Excep_Vec	EQU	03h
    Int_Get_PMode_Vec	EQU	04h
    Int_Set_PMode_Vec	EQU	05h

Int31_Trans_Serv	EQU	03h
    Trans_Sim_Int	EQU	00h
    Trans_Far_Call	EQU	01h
    Trans_Call_Int_Proc EQU	02h
    Trans_Call_Back	EQU	03h
    Trans_Free_CB	EQU	04h
    Trans_Get_Save_Addr EQU	05h
    Trans_Get_Sw_Addr	EQU	06h

Int31_Get_Version	EQU	04h

Int31_Mem_Mgt		EQU	05h
    MemMgt_Get_Info	EQU	00h
    MemMgt_Allocate	EQU	01h
    MemMgt_Free 	EQU	02h
    MemMgt_Resize	EQU	03h

Int31_Page_Lock 	EQU	06h
    Lock_Region 	EQU	00h
    Unlock_Region	EQU	01h
    Mark_Pageable	EQU	02h
    Mark_Not_Pageable	EQU	03h
    Get_Page_Size	EQU	04h

Int31_Demand_Page_Tune	EQU	07h
    Page_Candidate	EQU	00h
    Page_Discard	EQU	01h
    DPMI_Candidate	EQU	02h
    DPMI_Discard	EQU	03h

Int31_Map_Phys_Addr	EQU	08h

Int31_Virt_Int_State	EQU	09h
    Get_Clear_Int_State EQU	00h
    Get_Set_Int_State	EQU	01h
    Get_Int_State	EQU	02h

Int31_MCP_Control	EQU	0Eh
    Get_Status		EQU	00h
    Set_Emulation	EQU	01h


Real_Mode_Call_Struc	STRUC
RealMode_EDI	dd	?
RealMode_ESI	dd	?
RealMode_EBP	dd	?
		dd	?
RealMode_EBX	dd	?
RealMode_EDX	dd	?
RealMode_ECX	dd	?
RealMode_EAX	dd	?
RealMode_Flags	dw	?
RealMode_ES	dw	?
RealMode_DS	dw	?
RealMode_FS	dw	?
RealMode_GS	dw	?
RealMode_IP	dw	?
RealMode_CS	dw	?
RealMode_SP	dw	?
RealMode_SS	dw	?
Real_Mode_Call_Struc	ENDS


Real_Mode_Word_Regs	STRUC
RealMode_DI	dw	?
		dw	?
RealMode_SI	dw	?
		dw	?
RealMode_BP	dw	?
		dw	?
		dd	?
RealMode_BX	dw	?
		dw	?
RealMode_DX	dw	?
		dw	?
RealMode_CX	dw	?
		dw	?
RealMode_AX	dw	?
Real_Mode_Word_Regs	ENDS


Real_Mode_Byte_Regs	STRUC
		dd	4 dup (?)
RealMode_BL	db	?
RealMode_BH	db	?
		dw	?
RealMode_DL	db	?
RealMode_DH	db	?
		dw	?
RealMode_CL	db	?
RealMode_CH	db	?
		dw	?
RealMode_AL	db	?
RealMode_AH	db	?
Real_Mode_Byte_Regs	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\instver.h ===
/**************************************************************************
 *
 * InstVer.h - SDK Version-checking installer include file
 *
 * Copyright (C) Microsoft, 1991-1994
 * February 25, 1991
 *
 **************************************************************************/

/** Error returns from DLL/.EXE */
#define ERR_BADSRCDIR	       -1    /* invalid library (source) pathname */
#define ERR_BADWINDIR	       -2    /* invalid windows directory */
#define ERR_BADARGS	       -3    /* incorrect arguments (DOS .EXE only) */
#define ERR_CREATINGFILE       -4    /* error creating destination file */
#define ERR_CANNOTREADSRC      -5    /* error opening/reading source file  */
#define ERR_OUTOFSPACE	       -6    /* out of disk space copying file */
#define ERR_BADDATFILE	       -7    /* invalid DAT file */
#define ERR_CANTOPENDATFILE    -8    /* can't open DAT file for reading */
#define ERR_NOMEM	       -9    /* out of memory for local buffers */
#define ERR_READINGDATFILE     -10   /* error in reading DAT file*/
#define ERR_RENAME	       -11   /* error renaming destination file */


/* library installer function */

BOOL FAR PASCAL InstallVersionFiles (LPSTR lpszLibPath,
				     LPSTR lpszWindowsPath,
				     LPSTR lpszDatFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\graph.h ===
/***
*graph.h - declare constants, functions, and macros for graphics library
*
*   Copyright (c) 1987 - 1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file declares the graphics library functions and the
*   structures and manifest constants that are used with them.
*
***************************************************************************/

#ifndef	_WINDOWS
/* Force graphics.lib to be linked in if graph.h used */
#pragma comment(lib,"graphics.lib")
#endif

#ifdef __cplusplus
extern "C" {			/* allow use with C++ */
#endif

#if (_MSC_VER <= 600)
#define	__cdecl	_cdecl
#define	__far	_far
#define	__huge	_huge
#endif

/* force word packing to avoid possible -Zp override */
#pragma pack(2)


/* user-visible declarations for Quick-C Graphics Library */

#ifndef _VIDEOCONFIG_DEFINED
/* structure for _getvideoconfig() as visible to user */
struct _videoconfig {
	short numxpixels;	/* number of pixels on X axis */
	short numypixels;	/* number of pixels on Y axis */
	short numtextcols;	/* number of text columns available */
	short numtextrows;	/* number of text rows available */
	short numcolors;	/* number of actual colors */
	short bitsperpixel;	/* number of bits per pixel */
	short numvideopages;	/* number of available video pages */
	short mode;		/* current video mode */
	short adapter;		/* active display adapter */
	short monitor;		/* active display monitor */
	short memory;		/* adapter video memory in K bytes */
};
#define _VIDEOCONFIG_DEFINED
#endif

#ifndef _XYCOORD_DEFINED
/* return value of _setvieworg(), etc. */
struct _xycoord {
	short xcoord;
	short ycoord;
};
#define _XYCOORD_DEFINED
#endif

/* structure for text position */
#ifndef _RCCOORD_DEFINED
struct _rccoord {
	short row;
	short col;
};
#define _RCCOORD_DEFINED
#endif

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define videoconfig	_videoconfig
#define xycoord		_xycoord
#define rccoord		_rccoord
#endif


/* ERROR HANDLING */
short __far __cdecl _grstatus(void);

/* Error Status Information returned by _grstatus() */

/* successful */
#define	_GROK                        0

/* errors */
#define _GRERROR                    (-1)
#define	_GRMODENOTSUPPORTED	    (-2)
#define	_GRNOTINPROPERMODE          (-3)
#define _GRINVALIDPARAMETER         (-4)
#define	_GRFONTFILENOTFOUND         (-5)
#define	_GRINVALIDFONTFILE          (-6)
#define _GRCORRUPTEDFONTFILE        (-7)
#define _GRINSUFFICIENTMEMORY       (-8)
#define _GRINVALIDIMAGEBUFFER       (-9)

/* warnings */
#define _GRNOOUTPUT                  1
#define _GRCLIPPED                   2
#define _GRPARAMETERALTERED          3
#define _GRTEXTNOTSUPPORTED          4


/* SETUP AND CONFIGURATION */

short __far __cdecl _setvideomode(short);
short __far __cdecl _setvideomoderows(short,short); /* return rows; 0 if error */

/* arguments to _setvideomode() */
#define _MAXRESMODE	(-3)	/* graphics mode with highest resolution */
#define _MAXCOLORMODE	(-2)	/* graphics mode with most colors */
#define _DEFAULTMODE	(-1)	/* restore screen to original mode */
#define _TEXTBW40	0	/* 40-column text, 16 grey */
#define _TEXTC40	1	/* 40-column text, 16/8 color */
#define _TEXTBW80	2	/* 80-column text, 16 grey */
#define _TEXTC80	3	/* 80-column text, 16/8 color */
#define _MRES4COLOR	4	/* 320 x 200, 4 color */
#define _MRESNOCOLOR	5	/* 320 x 200, 4 grey */
#define _HRESBW		6	/* 640 x 200, BW */
#define _TEXTMONO	7	/* 80-column text, BW */
#define _HERCMONO	8	/* 720 x 348, BW for HGC */
#define _MRES16COLOR	13	/* 320 x 200, 16 color */
#define _HRES16COLOR	14	/* 640 x 200, 16 color */
#define _ERESNOCOLOR	15	/* 640 x 350, BW */
#define _ERESCOLOR	16	/* 640 x 350, 4 or 16 color */
#define _VRES2COLOR	17	/* 640 x 480, BW */
#define _VRES16COLOR	18	/* 640 x 480, 16 color */
#define _MRES256COLOR	19	/* 320 x 200, 256 color */
#define _ORESCOLOR	64	/* 640 x 400, 1 of 16 colors (Olivetti only) */

/* the following 8 modes require VESA SuperVGA BIOS extensions */
#define	_ORES256COLOR	0x0100	/* 640 x 400, 256 color */
#define	_VRES256COLOR	0x0101	/* 640 x 480, 256 color */

/* WARNING: DO NOT attempt to set the following modes without ensuring that
   your monitor can safely handle that resolution.  Otherwise, you may risk
   damaging your display monitor!  Consult your owner's manual for details.
   Note: _MAXRESMODE and _MAXCOLORMODE never select SRES, XRES, or ZRES modes */

/* requires NEC MultiSync 3D or equivalent, or better */
#define	_SRES16COLOR	0x0102	/* 800 x 600, 16 color */
#define	_SRES256COLOR	0x0103	/* 800 x 600, 256 color */

/* requires NEC MultiSync 4D or equivalent, or better */
#define	_XRES16COLOR	0x0104	/* 1024 x 768, 16 color */
#define	_XRES256COLOR	0x0105	/* 1024 x 768, 256 color */

/* requires NEC MultiSync 5D or equivalent, or better */
#define	_ZRES16COLOR	0x0106	/* 1280 x 1024, 16 color */
#define	_ZRES256COLOR	0x0107	/* 1280 x 1024, 256 color */


short __far __cdecl _setactivepage(short);
short __far __cdecl _setvisualpage(short);
short __far __cdecl _getactivepage(void);
short __far __cdecl _getvisualpage(void);

/* _videoconfig adapter values */
/* these manifest constants can be used to determine the type of the active  */
/* adapter, using either simple comparisons or the bitwise-AND operator (&)  */
#define _MDPA		0x0001	/* Monochrome Display Adapter	      (MDPA) */
#define _CGA		0x0002	/* Color Graphics Adapter	      (CGA)  */
#define _EGA		0x0004	/* Enhanced Graphics Adapter	      (EGA)  */
#define _VGA		0x0008	/* Video Graphics Array		      (VGA)  */
#define _MCGA		0x0010	/* MultiColor Graphics Array	      (MCGA) */
#define _HGC		0x0020	/* Hercules Graphics Card	      (HGC)  */
#define _OCGA		0x0042	/* Olivetti Color Graphics Adapter    (OCGA) */
#define _OEGA		0x0044	/* Olivetti Enhanced Graphics Adapter (OEGA) */
#define _OVGA		0x0048	/* Olivetti Video Graphics Array      (OVGA) */
#define _SVGA		0x0088	/* Super VGA with VESA BIOS support   (SVGA) */

/* _videoconfig monitor values */
/* these manifest constants can be used to determine the type of monitor in */
/* use, using either simple comparisons or the bitwise-AND operator (&) */
#define _MONO		0x0001	/* Monochrome */
#define _COLOR		0x0002	/* Color (or Enhanced emulating color) */
#define _ENHCOLOR	0x0004	/* Enhanced Color */
#define _ANALOGMONO	0x0008	/* Analog Monochrome only */
#define _ANALOGCOLOR	0x0010	/* Analog Color only */
#define _ANALOG		0x0018	/* Analog Monochrome and Color modes */

struct _videoconfig __far * __far __cdecl _getvideoconfig(struct _videoconfig __far *);


/* COORDINATE SYSTEMS */

struct _xycoord __far __cdecl _setvieworg(short, short);
#define _setlogorg _setvieworg		/* obsolescent */

struct _xycoord __far __cdecl _getviewcoord(short, short);
#define _getlogcoord _getviewcoord	/* obsolescent */

struct _xycoord __far __cdecl _getphyscoord(short, short);

void __far __cdecl _setcliprgn(short, short, short, short);
void __far __cdecl _setviewport(short, short, short, short);


/* OUTPUT ROUTINES */

/* control parameters for _ellipse, _rectangle, _pie and _polygon */
#define _GBORDER	2	/* draw outline only */
#define _GFILLINTERIOR	3	/* fill using current fill mask */

/* parameters for _clearscreen */
#define _GCLEARSCREEN	0
#define _GVIEWPORT	1
#define _GWINDOW	2

void __far __cdecl _clearscreen(short);

struct _xycoord __far __cdecl _moveto(short, short);
struct _xycoord __far __cdecl _getcurrentposition(void);

short __far __cdecl _lineto(short, short);
short __far __cdecl _rectangle(short, short, short, short, short);
short __far __cdecl _polygon(short, const struct _xycoord __far *, short);
short __far __cdecl _arc(short, short, short, short, short, short, short, short);
short __far __cdecl _ellipse(short, short, short, short, short);
short __far __cdecl _pie(short, short, short, short, short, short, short, short, short);

short __far __cdecl _getarcinfo(struct _xycoord __far *, struct _xycoord __far *, struct _xycoord __far *);

short __far __cdecl _setpixel(short, short);
short __far __cdecl _getpixel(short, short);
short __far __cdecl _floodfill(short, short, short);


/* PEN COLOR, LINE STYLE, WRITE MODE, FILL PATTERN */

short __far __cdecl _setcolor(short);
short __far __cdecl _getcolor(void);

void __far __cdecl _setlinestyle(unsigned short);
unsigned short __far __cdecl _getlinestyle(void);

short __far __cdecl _setwritemode(short);
short __far __cdecl _getwritemode(void);

void __far __cdecl _setfillmask(const unsigned char __far *);
unsigned char __far * __far __cdecl _getfillmask(unsigned char __far *);


/* COLOR SELECTION */

long __far __cdecl _setbkcolor(long);
long __far __cdecl _getbkcolor(void);

long __far __cdecl _remappalette(short, long);
short __far __cdecl _remapallpalette(const long __far *);
short __far __cdecl _selectpalette(short);


/* TEXT */
/* parameters for _displaycursor */
#define _GCURSOROFF	0
#define _GCURSORON	1

/* parameters for _wrapon */
#define _GWRAPOFF	0
#define _GWRAPON	1


/* direction parameters for _scrolltextwindow */
#define _GSCROLLUP	1
#define _GSCROLLDOWN	(-1)

/* request maximum number of rows in _settextrows and _setvideomoderows */
#define _MAXTEXTROWS	(-1)

short __far __cdecl _settextrows(short); /* returns # rows set; 0 if error */
void __far __cdecl _settextwindow(short, short, short, short);
void __far __cdecl _gettextwindow(short __far *, short __far *, short __far *, short __far *);
void __far __cdecl _scrolltextwindow(short);
void __far __cdecl _outmem(const char __far *, short);
void __far __cdecl _outtext(const char __far *);
short __far __cdecl _inchar(void);
short __far __cdecl _wrapon(short);

short __far __cdecl _displaycursor(short);
short __far __cdecl _settextcursor(short);
short __far __cdecl _gettextcursor(void);

struct _rccoord __far __cdecl _settextposition(short, short);
struct _rccoord __far __cdecl _gettextposition(void);

short __far __cdecl _settextcolor(short);
short __far __cdecl _gettextcolor(void);


/* SCREEN IMAGES */

void __far __cdecl _getimage(short, short, short, short, char __huge *);
void __far __cdecl _putimage(short, short, char __huge *, short);
long __far __cdecl _imagesize(short, short, short, short);

/* "action verbs" for _putimage() and _setwritemode() */
#define _GPSET		3
#define _GPRESET	2
#define _GAND		1
#define _GOR		0
#define _GXOR		4


/* Color values are used with _setbkcolor in graphics modes and also by
   _remappalette and _remapallpalette.  Also known as palette colors.
   Not to be confused with color indices (aka. color attributes).  */

/* universal color values (all color modes): */
#define _BLACK		0x000000L
#define _BLUE		0x2a0000L
#define _GREEN		0x002a00L
#define _CYAN		0x2a2a00L
#define _RED		0x00002aL
#define _MAGENTA	0x2a002aL
#define _BROWN		0x00152aL
#define _WHITE		0x2a2a2aL
#define _GRAY		0x151515L
#define _LIGHTBLUE	0x3F1515L
#define _LIGHTGREEN	0x153f15L
#define _LIGHTCYAN	0x3f3f15L
#define _LIGHTRED	0x15153fL
#define _LIGHTMAGENTA	0x3f153fL
#define _YELLOW		0x153f3fL
#define _BRIGHTWHITE	0x3f3f3fL

/* the following is obsolescent and defined only for backward compatibility */
#define _LIGHTYELLOW	_YELLOW

/* mono mode F (_ERESNOCOLOR) color values: */
#define _MODEFOFF	0L
#define _MODEFOFFTOON	1L
#define _MODEFOFFTOHI	2L
#define _MODEFONTOOFF	3L
#define _MODEFON	4L
#define _MODEFONTOHI	5L
#define _MODEFHITOOFF	6L
#define _MODEFHITOON	7L
#define _MODEFHI	8L

/* mono mode 7 (_TEXTMONO) color values: */
#define _MODE7OFF	0L
#define _MODE7ON	1L
#define _MODE7HI	2L


/* Warning:  these '_xy' entrypoints are undocumented.
   They may or may not be supported in future versions. */
struct _xycoord __far __cdecl _moveto_xy(struct _xycoord);
short __far __cdecl _lineto_xy(struct _xycoord);
short __far __cdecl _rectangle_xy(short,struct _xycoord,struct _xycoord);
short __far __cdecl _arc_xy(struct _xycoord, struct _xycoord, struct _xycoord, struct _xycoord);
short __far __cdecl _ellipse_xy(short, struct _xycoord, struct _xycoord);
short __far __cdecl _pie_xy(short, struct _xycoord, struct _xycoord, struct _xycoord, struct _xycoord);
short __far __cdecl _getpixel_xy(struct _xycoord);
short __far __cdecl _setpixel_xy(struct _xycoord);
short __far __cdecl _floodfill_xy(struct _xycoord, short);
void __far __cdecl _getimage_xy(struct _xycoord,struct _xycoord, char __huge *);
long __far __cdecl _imagesize_xy(struct _xycoord,struct _xycoord);
void __far __cdecl _putimage_xy(struct _xycoord, char __huge *, short);


/* WINDOW COORDINATE SYSTEM */

#ifndef _WXYCOORD_DEFINED
/* structure for window coordinate pair */
struct _wxycoord {
	double wx;	/* window x coordinate */
	double wy;	/* window y coordinate */
	};
#define _WXYCOORD_DEFINED
#endif


/* define real coordinate window - returns non-zero if successful */
short __far __cdecl _setwindow(short,double,double,double,double);

/* convert from view to window coordinates */
struct _wxycoord __far __cdecl _getwindowcoord(short,short);
struct _wxycoord __far __cdecl _getwindowcoord_xy(struct _xycoord);

/* convert from window to view coordinates */
struct _xycoord __far __cdecl _getviewcoord_w(double,double);
struct _xycoord __far __cdecl _getviewcoord_wxy(const struct _wxycoord __far *);

/*	return the window coordinates of the current graphics output
	position as an _wxycoord structure. no error return. */
struct _wxycoord __far __cdecl _getcurrentposition_w(void);


/* window coordinate entry points for graphics output routines */

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _arc_w(double, double, double, double, double, double, double, double);
short __far __cdecl _arc_wxy(const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _ellipse_w(short, double, double, double, double);
short __far __cdecl _ellipse_wxy(short, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _floodfill_w(double, double, short);

/*	returns pixel value at given point; -1 if unsuccessful. */
short __far __cdecl _getpixel_w(double, double);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _lineto_w(double, double);

/*	returns the view coordinates of the previous output
	position as a _wxycoord structure. no error return */
struct _wxycoord __far __cdecl _moveto_w(double, double);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _pie_w(short, double, double, double, double, double, double, double, double);
short __far __cdecl _pie_wxy(short, const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _rectangle_w(short, double, double, double, double);
short __far __cdecl _rectangle_wxy(short, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _polygon_w(short, const double __far *, short);
short __far __cdecl _polygon_wxy(short, const struct _wxycoord __far *, short);

/*	returns previous color; -1 if unsuccessful */
short __far __cdecl _setpixel_w(double, double);


/* window coordinate image routines */

/*	no return value */
void __far __cdecl _getimage_w(double, double, double, double, char __huge *);
void __far __cdecl _getimage_wxy(const struct _wxycoord __far *, const struct _wxycoord __far *, char __huge *);

/*	returns the image's storage size in bytes */
long __far __cdecl _imagesize_w(double, double, double, double);
long __far __cdecl _imagesize_wxy(const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	no return value */
void __far __cdecl _putimage_w(double, double ,char __huge * ,short);


/* FONTS */

#ifndef _FONTINFO_DEFINED
/* structure for _getfontinfo() */
struct _fontinfo {
	int	type;		/* b0 set = vector,clear = bit map	*/
	int	ascent;		/* pix dist from top to baseline	*/
	int	pixwidth;	/* character width in pixels, 0=prop	*/
	int	pixheight;	/* character height in pixels		*/
	int	avgwidth;	/* average character width in pixels	*/
	char	filename[81];	/* file name including path		*/
	char	facename[32];	/* font name				*/
};
#define _FONTINFO_DEFINED
#endif


/* font function prototypes */
short	__far __cdecl	_registerfonts( const char __far *);
void	__far __cdecl	_unregisterfonts( void );
short	__far __cdecl	_setfont( const char __far * );
short	__far __cdecl	_getfontinfo( struct _fontinfo __far * );
void	__far __cdecl	_outgtext( const char __far * );
short	__far __cdecl	_getgtextextent( const char __far * );
struct _xycoord __far __cdecl _setgtextvector( short, short );
struct _xycoord __far __cdecl _getgtextvector(void);


#ifdef _WINDOWS
/* QuickWin graphics extension prototypes */
int __far __cdecl _wgclose( int );
int __far __cdecl _wggetactive( void );
int __far __cdecl _wgopen( char __far * );
int __far __cdecl _wgsetactive( int );
#endif


/* restore default packing */
#pragma pack()

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\idf.h ===
//************************************************************************
//**
//**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//**  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//**  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//**  A PARTICULAR PURPOSE.
//**
//**  Copyright (C) 1993, 1994 Microsoft Corporation. All Rights Reserved.
//**
//**  IDF.h
//**
//**  DESCRIPTION:
//**     This file contains the format of the .IDF files.
//**
//**  HISTORY:
//**     04/29/93       created.
//**     07/04/93       added UNICODE for displayable strings.
//**     09/04/93       added keymaps.
//**     09/05/93       added ID's for channel types.
//**
//************************************************************************

/*
@doc  EXTERNAL SDK

@types   IDFHEADER |
   This is the format of the "hdr " chunk in a Microsoft IDF file.
   This will be the first subchunk of a "MMAP" list chunk.  This will 
   provide information on the IDF itself; what version, who created it,
   and a unique ASCII ID for the instrument.

@field   DWORD | cbStruct |
   This is the inclusive size of the header structure.

@field   DWORD | dwVersion |
   This is the version of the IDF file.
   under.

@field   DWORD | dwCreator |
   This is the creator ID for the IDF.

@field   DWORD | cbInstID |
   This is the size of the unique instrument identifier including the NULL.

@field   BYTE | abInstID[] |
   This is the actual ASCII bytes of the unique instrument id. This _IS_ 
   NULL terminated.  There is no UNICODE version of this since this will
   only be used internally and not displayed to the user.

@othertype  IDFHEADER * | PIDFHEADER |
   A memory model dependant pointer to the structure.

@othertype  IDFHEADER FAR* | LPIDFHEADER |
   A far pointer to the structure.
*/

typedef struct tag_IDFHEADER
{
   DWORD cbStruct;

   DWORD dwVersion;
   DWORD dwCreator;

   DWORD cbInstID;
   BYTE  abInstID[1];
} IDFHEADER, *PIDFHEADER, FAR *LPIDFHEADER;


/*
@doc  EXTERNAL SDK

@types   IDFINSTINFO |
   This is the format of the "inst" chunk in a Microsoft IDF file.
   This chunk will contain information on the instrument, e.g. who
   manufactured it, the name of the instrument, it's manufacturer and
   product id's and a revision number.

@field   DWORD | cbStruct |
   This is the inclusive size of the instrument information structure.

@field   DWORD | dwManufactID |
   Manufacturer's ID.

@field   DWORD | dwProductID |
   Product's ID.

@field   DWORD | dwRevision |
   Revision of the product.

@field   DWORD | cbManufactASCII |
   Length of the ASCII version of the manufacturuers name.

@field   DWORD | cbManufactUNICODE |
   Length of the UNICODE version of the manufacturuers name.

@field   DWORD | cbProductASCII |
   Length of the ASCII version of the product name.

@field   DWORD | cbProductUNICODE |
   Length of the UNICODE version of the product name.

@field   BYTE | abData[] |
   Contains the ASCII and UNICODE strings for the manufacturer and product
   names.  NOTE that all strings are separated by a NULL and the NULL IS
   counted in the string lengths.

@othertype  IDFINSTINFO * | PIDFINSTINFO |
   A memory model dependant pointer to the structure.

@othertype  IDFINSTINFO FAR * | LPIDFINSTINFO |
   A far pointer to the structure.

@comm The idea is that the cbManufactXXXXX and cbProductXXXXX will be the
      offsets into the bData array of bytes and it will contain a complete
      string that you can strcpy out.  That is why the NULL is included in
      the byte count and in the actual data.
*/

typedef struct tag_IDFINSTINFO
{
   DWORD cbStruct;

   DWORD dwManufactID;
   DWORD dwProductID;
   DWORD dwRevision;

   DWORD cbManufactASCII;
   DWORD cbManufactUNICODE;
   DWORD cbProductASCII;
   DWORD cbProductUNICODE;

   BYTE  abData[1];
} IDFINSTINFO, FAR *LPIDFINSTINFO;

/*
@doc  EXTERNAL SDK

@types   IDFINSTCAPS |
   This is the format of the "caps" chunk in a Microsoft IDF file.
   This chunk will contain information on the MIDI capabilities of
   the device. e.g. basic channel of the instrument, number of channels
   that the instrument has available. the polyphony of the instrument, 
   whether or not it supports General MIDI, etc....

@field   DWORD | cbStruct |
   This is the size of the capabilities structure.

@field   DWORD | fdwFlags |
   Flags specifiying additional capabilities of an instrument.

@flag IDFINSTCAPS_F_GENERAL_MIDI |
   Instrument supports General MIDI.

@flag IDFINSTCAPS_F_SYSTEMEXCLUSIVE |
   Instrument supports system exclusive messages

@field   DWORD | dwBasicChannel |
   The basic channel for the instrument.

@field   DWORD | cNumChannels |
   Number of channels that the instrument supports to.

@field   DWORD | cInstrumentPolyphony |
   The total polyphony for the instrument.

@field   DWORD | cChannelPolyphony |
   The polyphony per channel.

@othertype  IDFINSTCAPS * | PIDFINSTCAPS |
   A memory model dependant pointer to the structure.

@othertype  IDFINSTCAPS FAR * | LPIDFINSTCAPS |
   A far pointer to the structure.
*/

typedef struct tag_IDFINSTCAPS
{
   DWORD cbStruct;
   DWORD fdwFlags;
   DWORD dwBasicChannel;
   DWORD cNumChannels;
   DWORD cInstrumentPolyphony;
   DWORD cChannelPolyphony;
} IDFINSTCAPS, *PIDFINSTCAPS, FAR *LPIDFINSTCAPS;

#define  IDFINSTCAPS_F_GENERAL_MIDI       0x00000001
#define  IDFINSTCAPS_F_SYSTEMEXCLUSIVE    0x00000002

/*
@doc  EXTERNAL SDK

@types   IDFCHANNELHDR |
   This is the format of the "chnl" chunk in a Microsoft IDF file.
   This contains a description on what "type" a channel is, i.e. 
   is it a General MIDI channel, a drum channel, etc... Directly 
   following this header is the actual data on each channel.

@field   DWORD | cbStruct |
   This is the size of the channel header structure.

@field   DWORD | fdwFlags |
   Flags describing the channel type information.

@flag IDFCHANNELHDR_F_GENERAL_MIDI |
   If this flag is set then any channels that are not defined in the 
   IDF are General MIDI channel types.  If this flag is _NOT_ set then
   any channels that are not defined in the IDF are undefined and should 
   NOT be used in mapping.

@field   DWORD | cNumChannels |
   This is the number of channels that follows the header.

@othertype  IDFCHANNELHDR * | PIDFCHANNELHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFCHANNELHDR FAR * | LPIDFCHANNELHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFCHANNELHDR
{
   DWORD cbStruct;

   DWORD cNumChannels;
   DWORD fdwFlags;
} IDFCHANNELHDR, *PIDFCHANNELHDR, FAR *LPIDFCHANNELHDR;

#define  IDFCHANNELHDR_F_GENERAL_MIDI     0x00000001


/*
@doc  EXTERNAL SDK

@types    IDFCHANNELINFO |
   This is the format of the actual channel information for Microsoft
   authored IDF files. This is the Microsoft supported format for
   channel information.

@field   DWORD | dwChannel |
   This is the channel number that the structure defines.

@field   DWORD | fdwChannel |
   Defines the possible types this channel can be.

   @flag    IDFCHANNELINFO_F_GENERAL_CHANNEL |
       Indicates that this channel may be a general channel.

   @flag    IDFCHANNELINFO_F_DRUM_CHANNEL |
       Indicates that this channel may be a drum channel.

@field   DWORD | cbGeneralInitData |
    Specifies the length of the data which should be sent to initialize
    the channel to a general channel. This data will be sent whenever the
    channel is allocated as a general channel. If no initialization data
    is desired, this field should be set to zero. If more than one channel
    type is specified in the <f fdwChannel> field, initialization data
    must be specified and this field may not be zero.

@field   DWORD | cbDrumInitData |
    Specifies the length of the data which should be sent to initialize
    the channel to a drum channel. This data will be sent whenever the
    channel is allocated as a drum channel. If no initialization data
    is desired, this field should be set to zero. If more than one channel
    type is specified in the <f fdwChannel> field, initialization data
    must be specified and this field may not be zero.


@field    BYTE | abData[] |
    This field contains the actual initialization data to set the channel
    to general or drum. <f abData> contains first the initialization
    sequence to set the channel to a general channel, followed by
    the sequence to initialize the channel to a drum channel.
    <f cbGeneralInitData> and <f cbDrumInitData> should indicate the lengths
    of these sequences, byte aligned. However, the actual sequence should
    be padded so that it is actually DWORD aligned (i.e. even multiple
    of four bytes). <f cbStruct> should reflect the padded length of
    the sequences.
        
@othertype  IDFCHANNELINFO * | PIDFCHANNELINFO |
   A memory model dependant pointer to the structure.

@othertype  IDFCHANNELINFO FAR * | LPIDFCHANNELINFO |
   A far pointer to the structure.
*/

typedef struct tag_IDFCHANNELINFO
{
   DWORD cbStruct;

   DWORD dwChannel;
   DWORD fdwChannel;

   DWORD cbGeneralInitData;
   DWORD cbDrumInitData;

   BYTE  abData[];

} IDFCHANNELINFO, *PIDFCHANNELINFO, FAR *LPIDFCHANNELINFO;


//
// Currently defined channel types.
//
#define  IDFCHANNELINFO_F_GENERAL_CHANNEL      0x00000001
#define  IDFCHANNELINFO_F_DRUM_CHANNEL         0x00000002


/*
@doc  EXTERNAL SDK

@types   IDFPATCHMAPHDR |
   This is the format of the "map " chunk in a Microsoft IDF file.
   This chunk contains information on the patch map used for the 
   instrument. Directly following this header is the actual mapping 
   information for each patch.

@field   DWORD | cbStruct |
   This is the size of the patch map header structure.

@field   BYTE | abPatchMap[128] |
   This array contains the actual patch map. The incoming patch is
   used to index the array; the array contents are the new patch value
   and must be in the range 0x00-0x7F. Patch maps will only apply to
   channels of type general. If the instrument needs a patch change
   on a drum channel, it should be included in the initialization data
   in the IDFCHANNELINFO.

@othertype  IDFPATCHMAPHDR * | PIDFPATCHMAPHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFPATCHMAPHDR FAR * | LPIDFPATCHMAPHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFPATCHMAPHDR
{
   DWORD cbStruct;
   BYTE  abPatchMap[128];
           
} IDFPATCHMAPHDR, *PIDFPATCHMAPHDR, FAR *LPIDFPATCHMAPHDR;

/*
@doc  EXTERNAL SDK

@types   IDFKEYMAPHDR |
   This is the format of the "key " chunk in a Microsoft IDF file.
   This chunk contains information on the all of the key maps used 
   for a given instrument. The information that is in this structure
   pertains to all of the key maps for the instrument.  It contains
   the total number of key maps for the instrument and whether or not
   the key maps are General MIDI.

@field   DWORD | cbStruct |
   This is the size of the key map header structure.

@field   DWORD | cNumKeyMaps |
   This is the number of key maps that follow the header.

@field   DWORD | cbKeyMap |
   This is the size of each key map that follows the header.   

@othertype  IDFPATCHMAPHDR * | PIDFPATCHMAPHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFPATCHMAPHDR FAR * | LPIDFPATCHMAPHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFKEYMAPHDR
{
   DWORD cbStruct;
   DWORD cNumKeyMaps;
   DWORD cbKeyMap;
} IDFKEYMAPHDR, *PIDFKEYMAPHDR, FAR *LPIDFKEYMAPHDR;

/*
@doc  EXTERNAL SDK

@types   IDFKEYMAP |
   This is a keymap that follows the key map header. 

@field   DWORD | cbStruct |
   This is the size of the key map header structure.

@field   DWORD | fdwKeyMapType |
   This field specifies the channel type this key map is valid for.

@flag IDFKEYMAP_F_GENERAL_CHANNEL      0x00000001
@flag IDFKEYMAP_F_DRUM_CHANNEL         0x00000002

@field   BYTE | abKeyMap[128] |
    This field contains the actual key map. The incoming key number from
    a note on or note off message is used to index this array; the array
    contents are the new key value. If the high bit it set in the new
    key value, then the note on or note off will be ignore; otherwise,
    it will be transmitted with the new key value.
    
@othertype  IDFKEYMAP * | PIDFKEYMAP |
   A memory model dependant pointer to the structure.

@othertype  IDFKEYMAP FAR * | LPIDFKEYMAP |
   A far pointer to the structure.
*/

typedef struct tag_IDFKEYMAP
{
   DWORD cbStruct;
   DWORD fdwKeyMap;
   BYTE  abKeyMap[128];
} IDFKEYMAP, *PIDFKEYMAP, FAR *LPIDFKEYMAP;



#define IDFKEYMAP_F_GENERAL_CHANNEL      0x00000001L
#define IDFKEYMAP_F_DRUM_CHANNEL         0x00000002L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\ime31.h ===
/**********************************************************************/
/*      IME31.H - 3.1 Input Method related definitions                */
/*                                                                    */
/*      Copyright (c) 1993-1994  Microsoft Corporation                */
/**********************************************************************/

#ifndef _INC_IME31
#define _INC_IME31      // defined if IME31.H has been included

typedef struct _tagDATETIME {
    WORD        year;
    WORD        month;
    WORD        day;
    WORD        hour;
    WORD        min;
    WORD        sec;
} DATETIME;


// compatible IMEPro - this is the same as 3.1 in 3 countries
typedef struct _tagCIMEPRO {
    HWND        hWnd;
    DATETIME    InstDate;
    UINT        wVersion;
    BYTE        szDescription[50];
    BYTE        szName[80];
    BYTE        szOptions[30];
#ifdef TAIWAN
    BYTE        szUsrFontName[80];
    BOOL        fEnable;
#endif
} CIMEPRO;

typedef CIMEPRO      *PCIMEPRO;
typedef CIMEPRO NEAR *NPCIMEPRO;
typedef CIMEPRO FAR  *LPCIMEPRO;


// new IMEPro - this is the same in 3 countries
typedef struct _tagNIMEPRO {
    HWND        hWnd;
    DATETIME    InstDate;
    UINT        wVersion;
    BYTE        szDescription[50];
    BYTE        szName[80];
    BYTE        szOptions[30];
} NIMEPRO;

typedef NIMEPRO      *PNIMEPRO;
typedef NIMEPRO NEAR *NPNIMEPRO;
typedef NIMEPRO FAR  *LPNIMEPRO;


// wParam for WINNLSSendString
#define WSST_STRING     0
#define WSST_STRINGEX   1


#ifdef _INC_IMMSTRUC
BOOL WINAPI WINNLSInquire(LPIMELINK, LPTHREADLINK, LPPTHREADLINK);
#endif

BOOL WINAPI IMPGetIME(HWND, LPCIMEPRO);
BOOL WINAPI IMPQueryIME(LPCIMEPRO);
BOOL WINAPI IMPAddIME(LPNIMEPRO);
BOOL WINAPI IMPDeleteIME(LPNIMEPRO);
BOOL WINAPI IMPSetIME(HWND, LPNIMEPRO);
BOOL WINAPI IMPModifyIME(LPSTR, LPCIMEPRO);
WORD WINAPI IMPGetDefaultIME(LPNIMEPRO);
WORD WINAPI IMPSetDefaultIME(LPNIMEPRO);
BOOL WINAPI WINNLSSetIMEHandle(LPSTR, HWND);
BOOL WINAPI WINNLSSetIMEStatus(HWND, BOOL);

BOOL WINAPI WINNLSEnableIME(HWND, BOOL);
UINT WINAPI WINNLSGetKeyState(void);
BOOL WINAPI WINNLSSetKeyState(UINT);
BOOL WINAPI WINNLSGetEnableStatus(HWND);
BOOL WINAPI WINNLSSetKeyboardHook(BOOL);
BOOL WINAPI WINNLSSendControl(WORD, WORD);

BOOL WINAPI WINNLSSendString(HWND, WORD, LPVOID);
BOOL WINAPI WINNLSPostAppMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI WINNLSSendAppMessage(HWND, UINT, WPARAM, LPARAM);

#if defined(JAPAN)
BOOL WINAPI WINNLSSetIMEHotkey(HWND, UINT);
UINT WINAPI WINNLSGetIMEHotkey(HWND);
#endif

// 4.0 APIs
int  WINAPI WINNLSTranslateMessage(int, LPDWORD, HIMC);
UINT WINAPI WINNLSGet31ModeFrom40CMode(DWORD);
DWORD WINAPI WINNLSGet40CModeFrom31Mode(UINT);
#ifdef _INC_IMMSTRUC
BOOL WINAPI IMPInstallIME(LPIMELINK);
BOOL WINAPI IMPUpdateIMESettings(LPIMELINK, int);
BOOL WINAPI IMPDeleteIMESettings(LPIMELINK, int);
#endif

#if defined(CHINA) || defined(JAPAN) || defined(TAIWAN)
// dispatch IME support functions
BOOL WINAPI WINNLSSetDispatchDDIs(HINSTANCE);
BOOL WINAPI WINNLSClearDispatchDDIs(HINSTANCE);
BOOL WINAPI IMPDispatchGetIME(HINSTANCE, LPCIMEPRO);
#endif

#if defined(CHINA) || defined(TAIWAN)
// Chinese Windows WINNLS functions
BOOL WINAPI IMPSetFirstIME(HWND, LPNIMEPRO);
BOOL WINAPI IMPGetFirstIME(HWND, LPCIMEPRO);
BOOL WINAPI WINNLSDefIMEProc(HWND, HDC, WPARAM, WPARAM,  LPARAM, LPARAM);
LRESULT WINAPI ControlIMEMessage(HWND, LPCIMEPRO, WPARAM, WPARAM, LPARAM);
BOOL WINAPI IMPRetrieveIME(LPCIMEPRO, WPARAM);

// Chinese Windows 3.0 WINNLS APIs, these APIs just return fail in 4.0
BOOL WINAPI IMPEnableIME(HWND, LPCIMEPRO, BOOL);
BOOL WINAPI IMPSetUsrFont(HWND, LPCIMEPRO);
BOOL WINAPI WINNLSQueryIMEInfo(HWND, HWND, LPVOID);
BOOL WINAPI InquireIME(void);
#endif


typedef struct tagIMESTRUCT {
    UINT        fnc;            // function code
    WPARAM      wParam;         // word parameter
    UINT        wCount;         // word counter
    UINT        dchSource;      // offset to Source from top of memory object
    UINT        dchDest;        // offset to Desrination from top of memory object
    LPARAM      lParam1;
    LPARAM      lParam2;
    LPARAM      lParam3;
} IMESTRUCT;

typedef IMESTRUCT      *PIMESTRUCT;
typedef IMESTRUCT NEAR *NPIMESTRUCT;
typedef IMESTRUCT FAR  *LPIMESTRUCT;


typedef struct tagOLDUNDETERMINESTRUCT {
    UINT        uSize;
    UINT        uDefIMESize;
    UINT        uLength;
    UINT        uDeltaStart;
    UINT        uCursorPos;
    BYTE        cbColor[16];
//  -- below members will have variable length. --
//  BYTE        cbAttrib[];
//  BYTE        cbText[];
//  BYTE        cbIMEDef[];
} OLDUNDETERMINESTRUCT;

typedef OLDUNDETERMINESTRUCT      *POLDUNDETERMINESTRUCT;
typedef OLDUNDETERMINESTRUCT NEAR *NPOLDUNDETERMINESTRUCT;
typedef OLDUNDETERMINESTRUCT FAR  *LPOLDUNDETERMINESTRUCT;


typedef struct tagUNDETERMINESTRUCT {
    DWORD    dwSize;
    UINT     uDefIMESize;
    UINT     uDefIMEPos;
    UINT     uUndetTextLen;
    UINT     uUndetTextPos;
    UINT     uUndetAttrPos;
    UINT     uCursorPos;
    UINT     uDeltaStart;
    UINT     uDetermineTextLen;
    UINT     uDetermineTextPos;
    UINT     uDetermineDelimPos;
    UINT     uYomiTextLen;
    UINT     uYomiTextPos;
    UINT     uYomiDelimPos;
} UNDETERMINESTRUCT;

typedef UNDETERMINESTRUCT      *PUNDETERMINESTRUCT;
typedef UNDETERMINESTRUCT NEAR *NPUNDETERMINESTRUCT;
typedef UNDETERMINESTRUCT FAR *LPUNDETERMINESTRUCT;


typedef struct tagSTRINGEXSTRUCT {
    DWORD    dwSize;
    UINT     uDeterminePos;
    UINT     uDetermineDelimPos;
    UINT     uYomiPos;
    UINT     uYomiDelimPos;
} STRINGEXSTRUCT;

typedef STRINGEXSTRUCT     *PSTRINGEXSTRUCT;
typedef STRINGEXSTRUCT NEAR *NPSTRINGEXSTRUCT;
typedef STRINGEXSTRUCT FAR *LPSTRINGEXSTRUCT;

#ifdef KOREA
#define CP_HWND                 0
#define CP_OPEN                 1
#define CP_DIRECT               2
#define CP_LEVEL                3

#define lpSource(lpks) (LPSTR)((LPSTR)lpks+lpks->dchSource)
#define lpDest(lpks)   (LPSTR)((LPSTR)lpks+lpks->dchDest)
#endif   // KOREA

#ifdef JAPAN
// virtual key of Japan
#define VK_DBE_ALPHANUMERIC             0x0f0
#define VK_DBE_KATAKANA                 0x0f1
#define VK_DBE_HIRAGANA                 0x0f2
#define VK_DBE_SBCSCHAR                 0x0f3
#define VK_DBE_DBCSCHAR                 0x0f4
#define VK_DBE_ROMAN                    0x0f5
#define VK_DBE_NOROMAN                  0x0f6
#define VK_DBE_ENTERIMECONFIGMODE       0x0f8
#define VK_DBE_FLUSHSTRING              0x0f9
#define VK_DBE_CODEINPUT                0x0fa
#define VK_DBE_NOCODEINPUT              0x0fb
#define VK_DBE_DETERMINESTRING          0x0fc
#define VK_DBE_ENTERDLGCONVERSIONMODE   0x0fd
#endif  // JAPAN

#ifdef KOREA
// virtual key of Korea
#define VK_FINAL        0x18
#define VK_CONVERT      0x1C
#define VK_NONCONVERT   0x1D
#define VK_ACCEPT       0x1E
#define VK_MODECHANGE   0x1F
#endif

// IME subfunctions
#define IME_GETIMECAPS                  0x03
#define IME_SETOPEN                     0x04
#define IME_GETOPEN                     0x05
#define IME_ENABLEDOSIME                0x06
#define IME_GETVERSION                  0x07
#define IME_SETCONVERSIONWINDOW         0x08
#define IME_SETCONVERSIONMODE           0x10
#define IME_GETCONVERSIONMODE           0x11
#define IME_SETCONVERSIONFONT           0x12
#define IME_SENDVKEY                    0x13
#define IME_DESTROYIME                  0x14
#define IME_PRIVATE                     0x15
#define IME_WINDOWUPDATE                0x16
#define IME_SELECT                      0x17
#define IME_ENTERWORDREGISTERMODE       0x18
#define IME_SETCONVERSIONFONTEX         0x19
#define IME_DBCSNAME                    0x1A
#define IME_MAXKEY                      0x1B
#define IME_CODECONVERT                 0x20
#define IME_SETUSRFONT                  0x20
#define IME_CONVERTLIST                 0x21
#define IME_QUERYUSRFONT                0x21
#define IME_INPUTKEYTOSEQUENCE          0x22
#define IME_SEQUENCETOINTERNAL          0x23
#define IME_QUERYIMEINFO                0x24
#define IME_DIALOG                      0x25
#define IME_AUTOMATA                    0x30
#define IME_HANJAMODE                   0x31
#define IME_GETLEVEL                    0x40
#define IME_SETLEVEL                    0x41
#define IME_GETMNTABLE                  0x42
#define IME_SETUNDETERMINESTRING        0x50
#define IME_SETCAPTURE                  0x51

#define IME_PRIVATEFIRST                0x0100
#define IME_PRIVATELAST                 0x04FF

// 3.0 IME subfunctions
#define IME_QUERY               IME_GETIMECAPS
#define IME_ENABLE              IME_ENABLEDOSIME
#define IME_GET_MODE            IME_GETCONVERSIONMODE
#define IME_SETFONT             IME_SETCONVERSIONFONT
#define IME_SENDKEY             IME_SENDVKEY
#define IME_DESTROY             IME_DESTROYIME
#define IME_WORDREGISTER        IME_ENTERWORDREGISTERMODE

#ifdef KOREA
#define IME_MOVEIMEWINDOW       IME_SETCONVERSIONWINDOW
#define IME_SET_MODE            0x12
#else
#define IME_MOVECONVERTWINDOW   IME_SETCONVERSIONWINDOW
#define IME_SET_MODE            IME_SETCONVERSIONMODE
#endif

#if defined(JAPAN) || defined(KOREA)
#define MCW_DEFAULT     0x00
#define MCW_RECT        0x01
#define MCW_WINDOW      0x02
#define MCW_SCREEN      0x04
#define MCW_VERTICAL    0x08
#define MCW_HIDDEN      0x10
#define MCW_CMD         0x16
#endif

#ifdef KOREA
// IME_CODECONVERT subfunctions
#define IME_BANJAtoJUNJA        0x13
#define IME_JUNJAtoBANJA        0x14
#define IME_JOHABtoKS           0x15
#define IME_KStoJOHAB           0x16

// IME_AUTOMATA subfunctions
#define IMEA_INIT               0x01
#define IMEA_NEXT               0x02
#define IMEA_PREV               0x03

// IME_HANJAMODE subfunctions
#define IME_REQUEST_CONVERT     0x01
#define IME_ENABLE_CONVERT      0x02

// IME_MOVEIMEWINDOW subfunctions
#define INTERIM_WINDOW          0x00
#define MODE_WINDOW             0x01
#define HANJA_WINDOW            0x02
#endif  // KOREA

#if defined(CHINA) || defined(TAIWAN)
#define SK_KEY_MAX              46

#define IMEPROC_SWITCH          0x0001

// the IMEPROC_SK is from 0x0010 ~ 0x001F
#define IMEPROC_SK              0x0010
#define IMEPROC_SK0             0x0010
#define IMEPROC_SK1             0x0011
#define IMEPROC_SK2             0x0012

#define PROC_INFO               0x0001
#define PROC_SHOW               0x0002
#define PROC_HIDE               0x0004

#define BY_IME_HWND             0x0000
#define BY_IME_NAME             0x0001
#define BY_IME_DESCRIPTION      0x0002
#define BY_IME_DEFAULT          0x000F

// Those bits are used by ControlIMEMessage()
// 0x0030 - the two bits are for post/send messages control
// CTRL_NONE - don't send and post
#define CTRL_MSG_MASK           0x0030
#define CTRL_SEND               0x0000
#define CTRL_POST               0x0010
#define CTRL_NONE               0x0030

#define CTRL_USER_ALLOC         0x0040

// CTRL_MODIFY_??? - modify imepro of specified IME
// CTRL_MODIFY is all modify bits, but now only one bit
#define CTRL_MODIFY_USR_DIC     0x0080
#define CTRL_MODIFY             CTRL_MODIFY_USR_DIC
#endif  // CHINA || TAIWAN

// conversion mode
#define IME_MODE_ALPHANUMERIC   0x0001
#define IME_MODE_KATAKANA       0x0002
#define IME_MODE_HIRAGANA       0x0004
#define IME_MODE_HANJACONVERT   0x0004
#define IME_MODE_DBCSCHAR       0x0010
#define IME_MODE_ROMAN          0x0020
#define IME_MODE_NOROMAN        0x0040
#define IME_MODE_CODEINPUT      0x0080
#define IME_MODE_NOCODEINPUT    0x0100
#define IME_MODE_LHS            0x0200
#define IME_MODE_NOLHS          0x0400
#define IME_MODE_SK             0x0800
#define IME_MODE_NOSK           0x1000
#define IME_MODE_XSPACE         0x2000
#define IME_MODE_NOXSPACE       0x4000

#ifdef KOREA
#define IME_MODE_SBCSCHAR       0x0002
#else
#define IME_MODE_SBCSCHAR       0x0008
#endif


// error code
#define IME_RS_ERROR            0x01    // general error
#define IME_RS_NOIME            0x02    // IME is not installed
#define IME_RS_TOOLONG          0x05    // given string is too long
#define IME_RS_ILLEGAL          0x06    // illegal charactor(s) is string
#define IME_RS_NOTFOUND         0x07    // no (more) candidate
#define IME_RS_NOROOM           0x0a    // no disk/memory space
#define IME_RS_DISKERROR        0x0e    // disk I/O error
#define IME_RS_CAPTURED         0x10    // IME is captured (PENWIN)
#define IME_RS_INVALID          0x11    // invalid sub-function was specified
#define IME_RS_NEST             0x12    // called nested
#define IME_RS_SYSTEMMODAL      0x13    // called when system mode


#define WM_IME_REPORT           0x0280
#define WM_IMEKEYDOWN           0x0290
#define WM_IMEKEYUP             0x0291

// wParam of report message WM_IME_REPORT
#define IR_STRINGSTART          0x0100
#define IR_STRINGEND            0x0101
#define IR_OPENCONVERT          0x0120
#define IR_CHANGECONVERT        0x0121
#define IR_CLOSECONVERT         0x0122
#define IR_FULLCONVERT          0x0123
#define IR_IMESELECT            0x0130
#define IR_STRING               0x0140
#define IR_DBCSCHAR             0x0160
#define IR_UNDETERMINE          0x0170
#define IR_STRINGEX             0x0180

// return value for IME_VERSION
#define IMEVER_31               0x0a03

WORD WINAPI SendIMEMessage(HWND, LPARAM);
LRESULT WINAPI SendIMEMessageEx(HWND, LPARAM);

#if defined(CHINA) || defined(TAIWAN)
LRESULT WINAPI ControlIMEMessage(HWND, LPCIMEPRO, WPARAM, WPARAM, LPARAM);
#endif

#endif // _INC_IME31
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\internat.h ===
/***********************************************************************
// INTERNAT.H
//
//      Copyright (c) 1992, 1993 - Microsoft Corp.
//		All rights reserved.
//		Microsoft Confidential
//
//	Include file for international specific options.
//
// Johnhe 03-10-92
// TABS = 3
***********************************************************************/

#ifndef INTERNAT_INC
#define INTERNAT_INC 1           // INTERNAT.H signature


#ifdef DBCS
	#define	SkipDBCSLeadByte( x )   {if IsDBCLeadByte( szPtr ) szPtr++;}
#else
	#define	SkipDBCSLeadByte( x )
#endif

//**********************************************************************
// BUGBUG - need to move to resource file
//**********************************************************************

#define		AM_PM_STRINGS		{ "A", "AM", "P", "PM", NULL }
#define		PM_CHAR				'P'
#define		AM_CHAR				'A'
#define     AMPM_TRAIL_CHAR 	'M'

#define		DATE_DELIMITER_STR "-/."	// Date seperators ('-' is replaced)

//**********************************************************************
// Command line delimiters
//**********************************************************************

#define CHAR_COMMA          ','
#define CHAR_EOL            '\0'
#define CHAR_PLUS           '+'
#define CHAR_MINUS          '-'
#define CHAR_SIMICOLON      ';'
#define CHAR_SRCHSTR        '"'
#define CHAR_SWITCH         '/'
#define CHAR_QUOTE          '"'
#define CHAR_SPC            ' '
#define CHAR_TAB            '\t'

#define DOUBLE_SLASH        0x2f2f  	// Double slash chars "//"
#define UNC_WORD            0x5c5c      // UNC specifier ("\\\\")

#define CUR_DIR_STR         "."
#define PARENT_DIR_STR      ".."


#define PATH_CHAR_STR       "\\"
#define PATH_CHAR           '\\'
#define	DRIVE_DELIMITER		':'

#define WILD_NAME_CHAR      '*'     	//  All remaining wildcarc
#define WILD_CHAR           '?'     	// Single wildcard character
#define MULTI_WILDCARDS     1       	// Allow multiple wildcards filenames

#define FILE_EXT_CHAR       '.'     	// File extension seperator
#define CHAR_NOT_ATTRIB     '-'     	// Invert attribute switch

//***********************************************************************
//***********************************************************************

#define GET_EXTINFO         1           // Fill in extended info structure
#define GET_CASEMAP         2           // Get ptr to case map table
#define GET_FNCASEMAP       4           // Get ptr to filename case map table
#define GET_FNAME_CHARS     5           // Get ptr to filename character table
#define GET_COLLATE         6           // Get ptr to collate table
#define GET_DBYTE_SET       7           // Get ptr to double-byte char set

#define	DEFAULT_CODEPAGE	0xffff
#define DEFAULT_COUNTRY 	0xffff

#define USA_CNTRY_ID        1       	// Default country ID
#define USA_CODE_PAGE       437     	// Default country code page
		
#define ASCII_LEN           256         	// # of ASCII characters
#define NON_EXT_LEN         (ASCII_LEN / 2)	// # of non-ext ASCII chars
#define EXT_ASCII_LEN       (ASCII_LEN / 2)	// # of ext ASCII chars
#define COLLATE_TABLE_LEN   ASCII_LEN

//***********************************************************************
//	CntryTable_s is a structure which is filled in by DOS function 65xxh
//***********************************************************************

#ifndef	CntryTable_s
typedef struct CntryTable_s
{
    char                IdByte;
    unsigned char far	*fpAddr;
} CNTRY_TABLE;

#endif

//**********************************************************************
//	COUNTRY_INFO is the structure of the data returned by DOS function
//	0x38.
//**********************************************************************

#ifndef	COUNTRY_DEFINED
struct COUNTRY_INFO
{
    char        ccSetCountryInfo;   // SetCountryInfo
    unsigned    ccCountryInfoLen;   // length of country info
    unsigned    ccDosCountry;       // active country code id
    unsigned    ccDosCodePage;      // active code page id

    unsigned    ccDFormat;          // date format
    char        ccCurSymbol[ 5 ];   // 5 byte of (currency symbol+0)
    char        cc1000Sep[ 2 ];     // 2 byte of (1000 sep. + 0)
    char        ccDecSep[ 2 ];      // 2 byte of (Decimal sep. + 0)
    char        ccDateSep[ 2 ];     // 2 byte of (date sep. + 0)
    char        ccTimeSep[ 2 ];     // 2 byte of (time sep. + 0)
    char        ccCFormat;          // currency format flags
    char        ccCSigDigits;       // # of digits in currency
    char        ccTFormat;          // time format
    char far    *ccMono_Ptr;        // monocase routine entry point
    char        ccListSep[ 2 ];     // data list separator
    unsigned    ccReserved_area[ 5 ];   // reserved
};
#define	COUNTRY_DEFINED	1
#endif

//**********************************************************************
//	Global country specific tables.
//**********************************************************************

extern unsigned char near	CollateTable[ ASCII_LEN ];
extern unsigned char near	CaseMap[ ASCII_LEN ];
extern unsigned char near	FnameCharTable[ ASCII_LEN ];
extern unsigned char near	DBCSLeadByteTable[ ASCII_LEN ];
extern struct COUNTRY_INFO near Cntry;     // DOS country info structure

//**********************************************************************
//	Function prototypes.
//**********************************************************************

extern void     GetCountryInfo  ( struct COUNTRY_INFO *Cntry );
extern int      GetExtCountryInfo( unsigned InfoType, unsigned CodePage,
                                   unsigned CountryCode,
                                   struct COUNTRY_INFO *pTable );
extern void		InitCountryInfo	( void );

#ifdef DBCS
int             IsDBCSLeadByte  ( unsigned char c );
int             CheckDBCSTailByte( unsigned char *str, unsigned char *point );
unsigned char   *DBCSstrupr 	( unsigned char *str );
unsigned char	*DBCSstrchr( unsigned char *str, unsigned char c );
#endif


//***************************************************************************
//
//  End of INTERNAT.H
//
//***************************************************************************

#endif  // INTERNAT_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the iostream classes' paramterized manipulators.
*   [AT&T C++]
*
****/

#ifndef _INC_IOMANIP
#define _INC_IOMANIP
#include <iostream.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

// CONSIDER: use macro to define these
// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public: \
    SMANIP(T)(ios& (*f)(ios&,T), T t) { _fp = f; _tp = t; } \
    friend istream& operator>>(istream& s, SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
    friend ostream& operator<<(ostream& s, SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:    \
    ios& (* _fp)(ios&,T); \
    T _tp; \
};  \
class SAPP(T) { \
public: \
    SAPP(T)( ios& (*f)(ios&,T)) { _fp = f; }    \
    SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); }  \
private:    \
    ios& (* _fp)(ios&,T); \
};  \
class IMANIP(T) { \
public: \
    IMANIP(T)(istream& (*f)(istream&,T), T t) { _fp = f; _tp = t; } \
    friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:    \
    istream& (* _fp)(istream&,T); \
    T _tp;  \
};  \
class IAPP(T) { \
public: \
    IAPP(T)( istream& (*f)(istream&,T)) { _fp = f; }    \
    IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); }  \
private:    \
    istream& (* _fp)(istream&,T); \
};  \
class OMANIP(T) { \
public: \
    OMANIP(T)(ostream& (*f)(ostream&,T), T t) { _fp = f; _tp = t; } \
    friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:    \
    ostream& (* _fp)(ostream&,T); \
    T _tp; \
};  \
class OAPP(T) { \
public: \
    OAPP(T)(ostream& (*f)(ostream&,T)) { _fp = f; } \
    OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:    \
    ostream& (* _fp)(ostream&,T); \
};  \
\
class IOMANIP(T) { \
public: \
    IOMANIP(T)(iostream& (*f)(iostream&,T), T t) { _fp = f; _tp = t; } \
    friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
    friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:    \
    iostream& (* _fp)(iostream&,T); \
    T _tp; \
};  \
class IOAPP(T) {    \
public: \
    IOAPP(T)( iostream& (*f)(iostream&,T)) { _fp = f; } \
    IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); }    \
private:    \
    iostream& (* _fp)(iostream&,T); \
}; \


IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long) resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)  setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long) setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)  setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)  setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\limits.h ===
/***
*limits.h - implementation dependent values
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains defines for a number of implementation dependent values
*   which are commonly used in C programs.
*   [ANSI]
*
****/

#ifndef _INC_LIMITS

#define CHAR_BIT      8     /* number of bits in a char */
#define SCHAR_MIN   (-127)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */
#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else 
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#ifndef __cplusplus
unsigned int _charmax;          /* unsigned CHAR_MAX value */
#else 
extern "C" unsigned int _charmax;   /* unsigned CHAR_MAX value */
static unsigned int *_char_max = &_charmax;
#endif 
#endif 
#define MB_LEN_MAX    2     /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32767)    /* minimum (signed) short value */
#define SHRT_MAX      32767     /* maximum (signed) short value */
#define USHRT_MAX     0xffff    /* maximum unsigned short value */
#define INT_MIN     (-32767)    /* minimum (signed) int value */
#define INT_MAX       32767     /* maximum (signed) int value */
#define UINT_MAX      0xffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647)   /* minimum (signed) long value */
#define LONG_MAX      2147483647    /* maximum (signed) long value */
#define ULONG_MAX     0xffffffff    /* maximum unsigned long value */

#define _INC_LIMITS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*   Copyright (c) 1988-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   used by the localization routines.
*   [ANSI]
*
****/

#ifndef _INC_LOCALE

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* Locale categories */

#define LC_ALL      0
#define LC_COLLATE  1
#define LC_CTYPE    2
#define LC_MONETARY 3
#define LC_NUMERIC  4
#define LC_TIME     5

#define LC_MIN      LC_ALL
#define LC_MAX      LC_TIME


/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    };
#define _LCONV_DEFINED
#endif 

/* function prototypes */

char * __cdecl setlocale(int, const char *);
struct lconv * __cdecl localeconv(void);

#ifdef __cplusplus
}
#endif 

#define _INC_LOCALE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the iostream classes.
*   [AT&T C++]
*
****/

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

typedef long streamoff, streampos;

#include <ios.h>        // Define ios.

#include <streamb.h>        // Define streambuf.

#include <istream.h>        // Define istream.

#include <ostream.h>        // Define ostream.

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

class iostream : public istream, public ostream {
public:
    iostream(streambuf*);
    virtual ~iostream();
protected:
// consider: make private??
    iostream();
    iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
    iostream(ios&);
    iostream(istream&);
    iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class Iostream_init {
public:
    Iostream_init();
    Iostream_init(ios &, int =0);   // treat as private
    ~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit; // initializes cin/cout/cerr/clog

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the low-level
*   file handling and I/O functions.
*
****/

#ifndef _INC_IO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifdef _WINDOWS
#ifndef _WINDLL
#ifndef _WINFO_DEFINED
/* interface version number */
#define _QWINVER    0

/* max number of windows */
#define _WFILE      20

/* values for windows screen buffer size */
#define _WINBUFINF  0
#define _WINBUFDEF  -1

/* size/move settings */
#define _WINSIZEMIN 1
#define _WINSIZEMAX 2
#define _WINSIZERESTORE 3
#define _WINSIZECHAR    4

/* size/move query types */
#define _WINMAXREQ  100
#define _WINCURRREQ 101

/* values for closing window */
#define _WINPERSIST 1
#define _WINNOPERSIST   0

/* pseudo file handle for frame window */
#define _WINFRAMEHAND   -1

/* menu items */
#define _WINSTATBAR 1
#define _WINTILE    2
#define _WINCASCADE 3
#define _WINARRANGE 4

/* quickwin exit options */
#define _WINEXITPROMPT      1
#define _WINEXITNOPERSIST   2
#define _WINEXITPERSIST     3

/* open structure */
#pragma pack(2)
struct _wopeninfo {
    unsigned int _version;
    const char __far * _title;
    long _wbufsize;
    };
#pragma pack()

/* size/move structure */
struct _wsizeinfo {
    unsigned int _version;
    unsigned int _type;
    unsigned int _x;
    unsigned int _y;
    unsigned int _h;
    unsigned int _w;
    };

#define _WINFO_DEFINED
#endif 
#endif 
#endif 

/* function prototypes */

int __cdecl _access(const char *, int);
int __cdecl _chmod(const char *, int);
int __cdecl _chsize(int, long);
int __cdecl _close(int);
int __cdecl _commit(int);
int __cdecl _creat(const char *, int);
int __cdecl _dup(int);
int __cdecl _dup2(int, int);
int __cdecl _eof(int);
long __cdecl _filelength(int);
int __cdecl _isatty(int);
int __cdecl _locking(int, int, long);
long __cdecl _lseek(int, long, int);
char * __cdecl _mktemp(char *);
int __cdecl _open(const char *, int, ...);
int __cdecl _read(int, void *, unsigned int);
int __cdecl remove(const char *);
int __cdecl rename(const char *, const char *);
int __cdecl _setmode(int, int);
int __cdecl _sopen(const char *, int, int, ...);
long __cdecl _tell(int);
int __cdecl _umask(int);
int __cdecl _unlink(const char *);
int __cdecl _write(int, const void *, unsigned int);
#ifdef _WINDOWS
#ifndef _WINDLL
int __cdecl _wabout(char *);
int __cdecl _wclose(int, int);
int __cdecl _wgetexit(void);
int __cdecl _wgetfocus(void);
long __cdecl _wgetscreenbuf(int);
int __cdecl _wgetsize(int, int, struct _wsizeinfo *);
int __cdecl _wmenuclick(int);
int __cdecl _wopen(struct _wopeninfo *, struct _wsizeinfo *, int);
int __cdecl _wsetexit(int);
int __cdecl _wsetfocus(int);
int __cdecl _wsetscreenbuf(int, long);
int __cdecl _wsetsize(int, struct _wsizeinfo *);
void __cdecl _wyield(void);
#endif 
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl access(const char *, int);
int __cdecl chmod(const char *, int);
int __cdecl chsize(int, long);
int __cdecl close(int);
int __cdecl creat(const char *, int);
int __cdecl dup(int);
int __cdecl dup2(int, int);
int __cdecl eof(int);
long __cdecl filelength(int);
int __cdecl isatty(int);
int __cdecl locking(int, int, long);
long __cdecl lseek(int, long, int);
char * __cdecl mktemp(char *);
int __cdecl open(const char *, int, ...);
int __cdecl read(int, void *, unsigned int);
int __cdecl setmode(int, int);
int __cdecl sopen(const char *, int, int, ...);
long __cdecl tell(int);
int __cdecl umask(int);
int __cdecl unlink(const char *);
int __cdecl write(int, const void *, unsigned int);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_IO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\lzdos.h ===
/* OBSOLETE: Replaced by #define LIB/#include <lzexpand.h> */
#ifndef LIB
#define LIB
#endif
#include <lzexpand.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the istream class.
*   [AT&T C++]
*
****/

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#include <ios.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef long streamoff, streampos;

class istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { }

    inline istream& operator>>(istream& (*_f)(istream&));
    inline istream& operator>>(ios& (*_f)(ios&));
    istream& operator>>(char _HFAR_ *);
    inline istream& operator>>(unsigned char _HFAR_ *);
    inline istream& operator>>(signed char _HFAR_ *);
    istream& operator>>(char _HFAR_ &);
    inline istream& operator>>(unsigned char _HFAR_ &);
    inline istream& operator>>(signed char _HFAR_ &);
    istream& operator>>(short _HFAR_ &);
    istream& operator>>(unsigned short _HFAR_ &);
    istream& operator>>(int _HFAR_ &);
    istream& operator>>(unsigned int _HFAR_ &);
    istream& operator>>(long _HFAR_ &);
    istream& operator>>(unsigned long _HFAR_ &);
    istream& operator>>(float _HFAR_ &);
    istream& operator>>(double _HFAR_ &);
    istream& operator>>(long double _HFAR_ &);
    istream& operator>>(streambuf*);

    int get();
    istream& get(char _HFAR_ *,int,char ='\n');
    inline istream& get(unsigned char _HFAR_ *,int,char ='\n');
    inline istream& get(signed char _HFAR_ *,int,char ='\n');
    istream& get(char _HFAR_ &);
    inline istream& get(unsigned char _HFAR_ &);
    inline istream& get(signed char _HFAR_ &);
    istream& get(streambuf&,char ='\n');
    inline istream& getline(char _HFAR_ *,int,char ='\n');
    inline istream& getline(unsigned char _HFAR_ *,int,char ='\n');
    inline istream& getline(signed char _HFAR_ *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char _HFAR_ *,int);
    inline istream& read(unsigned char _HFAR_ *,int);
    inline istream& read(signed char _HFAR_ *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();    // consider: protect and friend with manipulator ws
protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    int do_ipfx(int);

private:
    istream(ios&);
    int getint(char _HFAR_ *);
    int getdouble(char _HFAR_ *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (*_f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (*_f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char _HFAR_ * _s) { return operator>>((char _HFAR_ *)_s); }
    inline istream& istream::operator>>(signed char _HFAR_ * _s) { return operator>>((char _HFAR_ *)_s); }

    inline istream& istream::operator>>(unsigned char _HFAR_ & _c) { return operator>>((char _HFAR_ &) _c); }
    inline istream& istream::operator>>(signed char _HFAR_ & _c) { return operator>>((char _HFAR_ &) _c); }

    inline istream& istream::get(unsigned char _HFAR_ * b, int lim ,char delim) { return get((char _HFAR_ *)b, lim, delim); }
    inline istream& istream::get(signed char _HFAR_ * b, int lim, char delim) { return get((char _HFAR_ *)b, lim, delim); }

    inline istream& istream::get(unsigned char _HFAR_ & _c) { return get((char _HFAR_ &)_c); }
    inline istream& istream::get(signed char _HFAR_ & _c) { return get((char _HFAR_ &)_c); }

    inline istream& istream::getline(char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get(_b, _lim, _delim); }
    inline istream& istream::getline(unsigned char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get((char _HFAR_ *)_b, _lim, _delim); }
    inline istream& istream::getline(signed char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get((char _HFAR_ *)_b, _lim, _delim); }

    inline istream& istream::ignore(int _n,int delim) { _fGline++; return get((char _HFAR_ *)0, _n+1, (char)delim); }

    inline istream& istream::read(unsigned char _HFAR_ * _ptr, int _n) { return read((char _HFAR_ *) _ptr, _n); }
    inline istream& istream::read(signed char _HFAR_ * _ptr, int _n) { return read((char _HFAR_ *) _ptr, _n); }

class istream_withassign : public istream {
    public:
        istream_withassign();
        istream_withassign(streambuf*);
        ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

#ifndef _WINDLL
extern istream_withassign cin;
#endif 

inline istream& ws(istream& _ins) { _ins.eatwhite(); return _ins; }

ios&        dec(ios&);
ios&        hex(ios&);
ios&        oct(ios&);

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the ios class.
*   [AT&T C++]
*
****/

#ifndef _INC_IOS
#define _INC_IOS


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

#ifndef NULL
#define NULL    0
#endif 

#ifndef EOF
#define EOF (-1)
#endif 

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

class streambuf;
class ostream;

class ios {

public:
    enum io_state {  goodbit = 0x00,
             eofbit  = 0x01,
             failbit = 0x02,
             badbit  = 0x04 };

    enum open_mode { in        = 0x01,
             out       = 0x02,
             ate       = 0x04,
             app       = 0x08,
             trunc     = 0x10,
             nocreate  = 0x20,
             noreplace = 0x40,
             binary    = 0x80 };    // CONSIDER: not in latest spec.

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
        left       = 0x0002,
        right      = 0x0004,
        internal   = 0x0008,
        dec        = 0x0010,
        oct        = 0x0020,
        hex        = 0x0040,
        showbase   = 0x0080,
        showpoint  = 0x0100,
        uppercase  = 0x0200,
        showpos    = 0x0400,
        scientific = 0x0800,
        fixed      = 0x1000,
        unitbuf    = 0x2000,
        stdio      = 0x4000
                 };

    static const long basefield;    // dec | oct | hex
    static const long adjustfield;  // left | right | internal
    static const long floatfield;   // scientific | fixed

    ios(streambuf*);            // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long _HFAR_ & iword(int) const;
    inline void _HFAR_ * _HFAR_ & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

protected:
    ios();
    ios(const ios&);            // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;           // not used
    int     ospecial;           // not used
    int     isfx_special;       // not used
    int     osfx_special;       // not used
    int     x_delbuf;           // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    int     x_width;
    char    x_fill;

    static void (*stdioflush)();    // not used
public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static long _HFAR_ * x_statebuf;  // used by xalloc()
    static int x_curindex;
// consider: make interal static to ios::sync_with_stdio()
    static int sunk_with_stdio;     // make sure sync_with done only once
};

inline ios& dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline ios& hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline ios& oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); return _lO; }
inline long ios::setf(long _l){ long _lO; _lO = x_flags; x_flags |= _l; return _lO; }
inline long ios::unsetf(long _l){ long _lO; _lO = x_flags; x_flags &= (~_l); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ state = _i; }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long _HFAR_ & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void _HFAR_ * _HFAR_ & ios::pword(int _i) const { return (void _HFAR_ * _HFAR_ &)x_statebuf[_i]; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\mdequ.inc ===
;	mdequ.inc -- MagicDrv general equate file
;/*
; *			 Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1992
; *			 All Rights Reserved.
; */

;	History:
;
;	    20-Jul-1992 chuckst 	initial version
;

;CODE_CSUM_SNAP equ 0ffffh	; defined: save image of code on csum err

;	Now that CSUM is the default, the build won't work without
;	POPUP being true.  However, I'm leaving the POPUP conditionals
;	in to help identify that code, just in case we ever want to
;	remove it and let CSUM faults simply hang.

POPUP	=	0ffffh

	ifdef DEBUG
POPUP	=	0ffffh		; POPUPs mandatory for DEBUG build
	endif


; Define the following variable to generate the standalone
; version of DBLSPACE.BIN, which loads as a device driver under
; MS-DOS 5.0 or greater.
;
;STANDALONE	 equ	 0ffffh

switch_n	equ	0001h
switch_f	equ	0002h

fatal_error_0	equ	0	; re-entered at strat
fatal_error_1	equ	1	; irpt without 1 strat
fatal_error_2	equ	2	; 2 irpts per strat
fatal_error_3	equ	3	; get_sqztor, number too low
fatal_error_4	equ	4	; put_sqztor, number too low
fatal_error_5	equ	5	; get_sqztor, number too high
fatal_error_6	equ	6	; put_sqztor, number too high
fatal_error_7	equ	7	; DOS system I/O too high
fatal_error_8	equ	8	; DOS system I/O too low
fatal_error_9	equ	9	; HEAP I/O too high
fatal_error_10	equ	10	; HEAP I/O too low
fatal_error_11	equ	11	; BITFAT I/O too high
fatal_error_12	equ	12	; BITFAT I/O too low
fatal_error_13	equ	13	; MDFAT I/O too high
fatal_error_14	equ	14	; MDFAT I/O too low
fatal_error_15	equ	15	; Bad signature check on CVF fragment list
fatal_error_16	equ	16	; Invalid int2f subfn (for forcing popup)
fatal_error_17	equ	17	; free to free sqztor
fatal_error_18	equ	18	; unfree to used sqztor
fatal_error_19	equ	19	; bitfat memory corrupt
fatal_error_20	equ	20	; mdfat memory corrupt
fatal_error_21	equ	21	; file fragment list corrupt
fatal_error_22	equ	22	; code block corrupt
fatal_error_23	equ	23	; write to invalid BitFAT page (0f0h)
fatal_error_24	equ	24	; DBLSPACE.BIN stack overrun

CSUM_CODE	equ	1
CSUM_FFLIST	equ	2
CSUM_BFAT_USE	equ	4
CSUM_BFAT_WRITE equ	8
CSUM_BFAT	equ	CSUM_BFAT_USE+CSUM_BFAT_WRITE
CSUM_MDFAT_USE	equ	16
CSUM_MDFAT_WRITE equ	32
CSUM_MDFAT	equ	CSUM_MDFAT_USE+CSUM_MDFAT_WRITE
CSUM_STACK_CHK  equ     64      ; Set => check for stack overrun
CSUM_ALL        equ     CSUM_CODE+CSUM_FFLIST+CSUM_BFAT+CSUM_MDFAT+CSUM_STACK_CHK


CSUM_XOR	equ	4fd0h	; this value is XOR'd with all internal
;				; data structure words before the checksum
;				; is performed.  This is because of the
;				; fact that 0ffffh is minus 0 in one's
;				; complement, and thus the checksum would
;				; not detect 0s changing to 0ffffhs, and
;				; vice versa.  By doing this XOR, we map
;				; the two 'identical' values to 4fd0h and
;				; 0b02fh, which are much less likely to
;				; occur.  Only a trashing bug which did
;				; a properly aligned NOT function on one
;				; of these two words would not be detected.
CODE_CSUM_INTERVAL equ 10	; checksum code one out of this many
;				; times driver is entered.

;;
;; Equates
;;

multMagicdrv	equ	4a11h	; Int2f multiplex number

DRVMAP_CPR_BIT	equ	80h	; bit indicating mounted CVF in drv_map array

cr		=	13
lf		=	10
tab		=	9
ctrlz		=	1ah

CVF_SEQ_SWAP	equ	0	; Sequence number which implies SWAP
CVF_SEQ_MAX	equ	255	; Maximum allowable sequence number

MAX_ACTIVATES	equ	24	; 26 drive letters, less two floppies

BIG_CLUSTER	equ	8192		;Size of BIG cluster (8K)
SMALL_CLUSTER	equ	4096		;Size of SMALL cluster (4K)

BPTR	equ	BYTE PTR

MAX_FULL		equ	32  ;;64;Minimum of free sectors b4 we declare this disk as full
MAX_WARN		equ	256	;Minimum free sectors to generate an 'almost full' warning

;; temp_buf_list values
ORIGINAL_DATA		equ	1	;This sector has an original data
NEW_DATA		equ	2	;This sector contains new data

MAX_DEMO_HIWORD_SIZE	equ	48	;Maximum high word for demo file
MAX_SECTOR_SIZE 	equ	2048	;Maximum host sector size (2K)

IO_PART_SPACE		equ	2048	;Page size for sqztor table
PART_CLUSTER_SIZE_POW2	equ	9	;How many clusters per one page (DWORD per cluster)

BIT_FAT_SPACE		equ	2048	;Page size of sec_list table (free space)
SECTORS_PER_BIT_FAT_POW2 equ	14	;In power 2 if sectors
SECTORS_PER_BIT_FAT	equ	16384	;Number of bits (sectors) in one page

DBL_SIGN		equ	0	;Where the 'DBL' signature can be located
VOL_STAMP		equ	6	;Where unique vol stamp is found
RETRACT_SIGNATURE	equ	1	; signature is last full sector, ie:
;					;  end of file (rounded down to sector)
;					;  minus 1

RH			equ	ds:[bx] ;Addressability to Request Header structure

MAX_DISK_UNITS		equ	15	;Maximumm of extended disk we can handle

cMINFILEFRAGMENTS	equ	50	;Minimum file fragment heap size
cDEFFILEFRAGMENTS	equ	700	;Default  "      "	 "   "
cMAXFILEFRAGMENTS	equ	10000	;Maximum  "      "	 "   "

; cluster_to_Sqztor equates. See globals definition
NO_FLAGS_MASK		equ	001FH	;Just the entry, without flags
RESERVED1_MASK		equ	0020H	;Reserved bit just after 21-bit sector#
PHYSICAL_SIZE_MASK	equ	03C0H	;Only the physical size bits
PHYSICAL_SIZE_OFFSET	equ	6	;THe physical size bits offset
PLAINTEXT_MASK		equ	3C00H	;Only the plaintext size bits
PLAINTEXT_OFFSET	equ	10	;Plaintext size bits offset
UNCODED_CLUSTER_MASK	equ	4000H	;Uncompress cluster bit
USED_CLUSTER_MASK	equ	8000H	;Used cluster bit

PARA_SIZE_POW2		equ	4	;Number of bytes in one 8088 paragraph
STACK_SIZE		equ	768	;Size of our stack

; Device driver equates
READ_DISK_CMD		equ	4
WRITE_DISK_CMD		equ	8
WRITE_VERIFY_CMD	equ	9

STAT_WRITP		equ	8000H		;Write protect violation
STAT_DFULL		equ	8027h		;Disk full error
STAT_NRDY		equ	8002H		;Device not ready
STAT_NOCOM		equ	8003H		;Unkown command
STAT_CRC		equ	8004H		;CRC error
STAT_SNF		equ	8008H		;sector not found error
STAT_SEEK		equ	8006H		;Seek error
STAT_WRITE		equ	800AH		;Write FAULT
STAT_READ		equ	800BH		;Read fault
STAT_GEN		equ	800CH		;General failore

DOS	   EQU	21H		;DOS request INT
DOS_PCHR   EQU	02H		;print character function

;Constants for compression/Decompression alg.
MAX_BITS	equ	12		;Maximum bits (2048 entries)
TABLESIZE	equ	2048		;Hash table size

SPECIAL_EOS	equ	4415		;End of Sector code


;Generic IOCTL return codes
NO_ERROR	    equ 0		;No error
LETTER_BOUNDRY_ERROR equ 1		;Letter out of bounds
UNIT_USED_ERROR     equ 2		;Unit already used
NO_FREE_SLOT_ERROR  equ 3		;No reserved slot available
STAMP_ERROR	    equ 4		;Stamp error on extended disk


;Cluster signature
;Compressed clusters has the signature:
; 44 53 00 00	-  Cluster compressed real time
; 44 53 00 01	-  Cluster SuperCompressed offline
; 44 53 00 02	-  Cluster XCompressed real time
;
; NOTE: If you load these signature as words, they look like:
;
;   low  word = 5344h
;   high word = 0000h or 0100h

; XCMP defines a different REAL_TIME_COMPRESSED signature so a XCMP and
; non XCMP driver can be used on the same CVF and not get confused trying
; to UpdateCompress a XCMP block (XCMP does not support UpdateCompress).

SIG_SIZE		equ	4	; 4 byte signature
STANDARD_COMPRESSED	equ  0000h	; High word of stamp
SUPER_COMPRESSED	equ  0100h	; High word of stamp
X_COMPRESSED		equ  0200h	; High word of stamp
REAL_TIME_COMPRESSED	equ  X_COMPRESSED ; Stamp used for real-time compress

;;
;; We always keep at least 64k of extra sqztors around so a
;; file overwrite won't expand to more sqztors that are available.
;; Of course this is a raw heuristic since these should also
;; be contingous.  For more info, see dospatch.asm and
;; low_dlb.asm referenece to FUDGESTOR
FUDGESTOR	equ	128


; eXperimental compression code uses a lookup table to find past
; occurances of individual characters.	The table is currently
; 256 rows (1 for each possible byte value) X N (tracks N occurances
; of each character).


cltROWS EQU	256		; lookup table 256 rows x
cltCOLS EQU	8		;   N columns


	ifdef	POPUP

PUP_FILE_SIZE	equ	20*1024
MAX_PUP_FRAGLIST equ	6*(1+PUP_FILE_SIZE/1024) ; support >=1K clusters
PUP_QUEUE_SIZE	equ	4096

	endif

; mcsNONE indicates there is no saved Media Check status.  This value
; must not be equated to a valid media check result (-1, 0, 1).

mcsNONE 	equ	80h


; cAM_HOOKS is the number of block device drivers that can be hooked
; by the automount code.  Each hook adds approx 30 bytes, so keeping
; this value low is significant.  A MS-DOS 6 system that does not
; load additional block device driver in config.sys uses 1 hook (A:,
; B:, C:, ... are all serviced by one device driver).

cAM_HOOKS	equ	5

para_adjust	equ	-16		; we'll add this to certain vars
;					;  in the automount device headers
;					;  and related variables when we
;					;  access them with low_stub_seg+1,
;					;  to work around a Norton SpeeDrv bug.


STACK_GUARD_VALUE equ	1234h		; unlikely value to use when checking
					;   for stack overrun
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\mdstring.inc ===
;	mdstring.inc -- MagicDrv strings definitions
;/*
; *			 Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1992
; *			 All Rights Reserved.
; */

;	History:
;
;	    20-Jul-1992 chuckst 	initial version
;	    10-Aug-1992 bens		Changed strings
;	    03-Sep-1992 chuckst 	changed to DBLSPACE
;           26-Jul-1993 bens            Added DoubleGuard


IFDEF  OLD_NAMES
    dev_name_7	    equ     "DUBLDSK"	    ; last 7 chars of device name field
ELSE ; !OLD_NAMES
if 0
    ;;;WHY IS THIS CODE REMOVED? Because although it works fine for
    ;;;control panel, it also works fine for windows setup, which won't
    ;;;write the autoexec.bat and config.sys out on squish drives.
    ;;;Oh well.

    ;;;BUG BUGBUG warning we use the byte sequence S,Q,U,I,S,H,+ to
    ;;;make windows 31 control panel consider us ineligible for
    ;;;a permanent swap file
    dev_name_7	    equ     "SQUISH+"	    ; last 7 chars of device name field
endif
    dev_name_7	    equ     "DBLSPAC"
ENDIF ; OLD_NAMES

magic_ini_file_name equ '\dblspace.ini'

IFDEF  OLD_NAMES
    CVF_NAME_BASE   equ     '\dubldisk'
ELSE ; !OLD_NAMES
    CVF_NAME_BASE   equ     '\DBLSPACE'
ENDIF ; OLD_NAMES

KWD_ACT 	equ	'ACTIVATEDRIVE'
KWD_FIRST	equ	'FIRSTDRIVE'
KWD_LAST	equ	'LASTDRIVE'
KWD_MAXREM	equ	'MAXREMOVABLEDRIVES'
KWD_MAXFILE	equ	'MAXFILEFRAGMENTS'
KWD_ENABLE	equ	'ENABLE386'
KWD_ROMSERVER	equ	'ROMSERVER'
KWD_CHECKSUM    equ     'CHECKSUM'      ; NOTE: Undocumented!
KWD_DBLGUARD    equ     'DOUBLEGUARD'
KWD_SWITCHES	equ	'SWITCHES'
KWD_AUTOMOUNT	equ	'AUTOMOUNT'

NSWITCH_CHAR	=	'N'
FSWITCH_CHAR	=	'F'

OEM_LOWORD	equ	'2L'
OEM_MIDWORD	equ	'6.'
OEM_HIBYTE	equ	' '

IFDEF  OLD_NAMES
    MD_SIG_LOWORD   equ     'BD'
    MD_SIG_HIBYTE   equ     'L'

    MD_STAMP	    equ     "DD"
    OK_STAMP	    equ     'OK'
ELSE ; !OLD_NAMES
    MD_SIG_LOWORD   equ     044F8h  ; Low CVF signature is F8,'D','R'
    MD_SIG_HIBYTE   equ     'R'

    MD_STAMP	    equ     "SD"
    OK_STAMP	    equ     'OK'
ENDIF ; OLD_NAMES

; MD_EXT_STAMP is used in IOCTL & Int 2Fh calls to DblSpace driver -- it
; should not change even if MD_STAMP does.  MD_EXT_STAMP is the value
; external software expects to see and use.

MD_EXT_STAMP	equ	"DM"

; MD_MOUNT_CMD identifies activate records for use with the activate
; Int 2Fh API.	MS-DOS 6 DBLSPACE.BIN used a MD_MOUNT_CMD value of 'M'.
; The MS-DOS 6.2 activate record is not compatible with MS-DOS 6 so
; the comand value has been changed to cleanly fail mount/activate
; attempts with the MS-DOS 6 structure.

MD_MOUNT_CMD	equ	'A'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\mciavi.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
**	Copyright (C) Microsoft Corporation 1991-1994. All rights reserved.
**
**	Title: mciavi.h - Multimedia Systems Media Control Interface
**	AVI driver external header file
**
**	Version:	1.00	
**
**	Date:		16-JUL-1992
**
**	Depends on MMSYSTEM.H and WINDOWS.h
*/

/************************************************************************/


/*
** These three flags apply to the 'play' command:
**	play <alias> window		Play in normal window
**	play <alias> fullscreen		Play in 320x240 full-screen mode
**	play <alias> fullscreen by 2	Play fullscreen, zoomed by 2
*/
#define MCI_MCIAVI_PLAY_WINDOW		0x01000000L
#define	MCI_MCIAVI_PLAY_FULLSCREEN	0x02000000L
#define MCI_MCIAVI_PLAY_FULLBY2		0x04000000L
/*
** Debugging constants for AVI diagnostics
*/
/* 
** Returns number of frames not drawn during last play.  If this number
** is more than a small fraction of the number of frames that should have
** been displayed, things aren't looking good.
*/
#define MCI_AVI_STATUS_FRAMES_SKIPPED		0x8001L
/*
** Returns a number representing how well the last AVI play worked.
** A result of 1000 indicates that the AVI sequence took the amount
** of time to play that it should have; a result of 2000, for instance,
** would indicate that a 5-second AVI sequence took 10 seconds to play,
** implying that the audio and video were badly broken up.
*/
#define MCI_AVI_STATUS_LAST_PLAY_SPEED		0x8002L
/*
** Returns the number of times that the audio definitely broke up.
** (We count one for every time we're about to write some audio data
** to the driver, and we notice that it's already played all of the
** data we have.
*/
#define MCI_AVI_STATUS_AUDIO_BREAKS		0x8003L


#define MCI_AVI_SETVIDEO_DRAW_PROCEDURE		0x8000L

#define MCI_AVI_SETVIDEO_PALETTE_COLOR		0x8100L


/*
** This constant specifies that the "halftone" palette should be
** used, rather than the default palette.
*/
#define MCI_AVI_SETVIDEO_PALETTE_HALFTONE       0x0000FFFFL

/*
**	Custom error return values
*/
#define MCIERR_AVI_OLDAVIFORMAT		(MCIERR_CUSTOM_DRIVER_BASE + 100)
#define MCIERR_AVI_NOTINTERLEAVED	(MCIERR_CUSTOM_DRIVER_BASE + 101)
#define MCIERR_AVI_NODISPDIB		(MCIERR_CUSTOM_DRIVER_BASE + 102)
#define MCIERR_AVI_CANTPLAYFULLSCREEN	(MCIERR_CUSTOM_DRIVER_BASE + 103)
#define MCIERR_AVI_TOOBIGFORVGA		(MCIERR_CUSTOM_DRIVER_BASE + 104)
#define MCIERR_AVI_NOCOMPRESSOR         (MCIERR_CUSTOM_DRIVER_BASE + 105)
#define MCIERR_AVI_DISPLAYERROR         (MCIERR_CUSTOM_DRIVER_BASE + 106)
#define MCIERR_AVI_AUDIOERROR		(MCIERR_CUSTOM_DRIVER_BASE + 107)
#define MCIERR_AVI_BADPALETTE		(MCIERR_CUSTOM_DRIVER_BASE + 108)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\math.h ===
/***
*math.h - definitions and declarations for math library
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains constant definitions and external subroutine
*   declarations for the math subroutine library.
*   [ANSI/System V]
*
****/

#ifndef _INC_MATH

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

/* definition of _exception struct - this struct is passed to the _matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
#pragma pack(2)

struct _exception {
    int type;       /* exception type - see below */
    char *name;   /* name of function where error occured */
    double arg1;        /* first argument to function */
    double arg2;        /* second argument (if any) to function */
    double retval;      /* value to be returned by function */
    } ;

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define exception _exception
#endif 

#pragma pack()
#define _EXCEPTION_DEFINED
#endif 


/* definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED

struct _complex {
    double x,y; /* real and imaginary parts */
    } ;

#ifndef __cplusplus
#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct complex {
    double x,y; /* real and imaginary parts */
    } ;
#endif 
#endif 

#define _COMPLEX_DEFINED
#endif 


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* definitions of _HUGE (XENIX) and HUGE_VAL (ANSI) error return values used
 * by several floating point math routines
 */

extern double __near __cdecl _HUGE;
#define HUGE_VAL _HUGE


/* function prototypes */

#ifdef _MT
int __cdecl  abs(int);
double  __pascal acos(double);
double  __pascal asin(double);
double  __pascal atan(double);
double  __pascal atan2(double, double);
double  __pascal atof(const char *);
double  __pascal _cabs(struct _complex);
double  __pascal ceil(double);
double  __pascal cos(double);
double  __pascal cosh(double);
int __cdecl  _dieeetomsbin(double *, double *);
int __cdecl  _dmsbintoieee(double *, double *);
double  __pascal exp(double);
double  __pascal fabs(double);
int __cdecl  _fieeetomsbin(float *, float *);
double  __pascal floor(double);
double  __pascal fmod(double, double);
int __cdecl  _fmsbintoieee(float *, float *);
double  __pascal frexp(double, int *);
double  __pascal _hypot(double, double);
double  __pascal _j0(double);
double  __pascal _j1(double);
double  __pascal _jn(int, double);
long    __cdecl  labs(long);
double  __pascal ldexp(double, int);
double  __pascal log(double);
double  __pascal log10(double);
int __cdecl  _matherr(struct _exception *);
double  __pascal modf(double, double *);
double  __pascal pow(double, double);
double  __pascal sin(double);
double  __pascal sinh(double);
double  __pascal sqrt(double);
double  __pascal tan(double);
double  __pascal tanh(double);
double  __pascal _y0(double);
double  __pascal _y1(double);
double  __pascal _yn(int, double);

#else 
int __cdecl abs(int);
double  __cdecl acos(double);
double  __cdecl asin(double);
double  __cdecl atan(double);
double  __cdecl atan2(double, double);
double  __cdecl atof(const char *);
double  __cdecl _cabs(struct _complex);
double  __cdecl ceil(double);
double  __cdecl cos(double);
double  __cdecl cosh(double);
int __cdecl _dieeetomsbin(double *, double *);
int __cdecl _dmsbintoieee(double *, double *);
double  __cdecl exp(double);
double  __cdecl fabs(double);
int __cdecl _fieeetomsbin(float *, float *);
double  __cdecl floor(double);
double  __cdecl fmod(double, double);
int __cdecl _fmsbintoieee(float *, float *);
double  __cdecl frexp(double, int *);
double  __cdecl _hypot(double, double);
double  __cdecl _j0(double);
double  __cdecl _j1(double);
double  __cdecl _jn(int, double);
long    __cdecl labs(long);
double  __cdecl ldexp(double, int);
double  __cdecl log(double);
double  __cdecl log10(double);
int __cdecl _matherr(struct _exception *);
double  __cdecl modf(double, double *);
double  __cdecl pow(double, double);
double  __cdecl sin(double);
double  __cdecl sinh(double);
double  __cdecl sqrt(double);
double  __cdecl tan(double);
double  __cdecl tanh(double);
double  __cdecl _y0(double);
double  __cdecl _y1(double);
double  __cdecl _yn(int, double);
#endif 


/* definition of _exceptionl struct - this struct is passed to the _matherrl
 * routine when a floating point exception is detected in a long double routine
 */

#ifndef _LD_EXCEPTION_DEFINED
#pragma pack(2)
struct _exceptionl {
    int type;       /* exception type - see below */
    char *name;   /* name of function where error occured */
    long double arg1;   /* first argument to function */
    long double arg2;   /* second argument (if any) to function */
    long double retval; /* value to be returned by function */
    } ;
#pragma pack()
#define _LD_EXCEPTION_DEFINED
#endif 


/* definition of a _complexl struct to be used by those who use _cabsl and
 * want type checking on their argument
 */

#ifndef _LD_COMPLEX_DEFINED
#pragma pack(2)
struct _complexl {
    long double x,y;    /* real and imaginary parts */
    } ;
#pragma pack()
#define _LD_COMPLEX_DEFINED
#endif 

extern long double __near __cdecl _LHUGE;
#define _LHUGE_VAL _LHUGE


long double  __cdecl acosl(long double);
long double  __cdecl asinl(long double);
long double  __cdecl atanl(long double);
long double  __cdecl atan2l(long double, long double);
long double  __cdecl _atold(const char *);
long double  __cdecl _cabsl(struct _complexl);
long double  __cdecl ceill(long double);
long double  __cdecl cosl(long double);
long double  __cdecl coshl(long double);
long double  __cdecl expl(long double);
long double  __cdecl fabsl(long double);
long double  __cdecl floorl(long double);
long double  __cdecl fmodl(long double, long double);
long double  __cdecl frexpl(long double, int *);
long double  __cdecl _hypotl(long double, long double);
long double  __cdecl _j0l(long double);
long double  __cdecl _j1l(long double);
long double  __cdecl _jnl(int, long double);
long double  __cdecl ldexpl(long double, int);
long double  __cdecl logl(long double);
long double  __cdecl log10l(long double);
int      __cdecl _matherrl(struct _exceptionl *);
long double  __cdecl modfl(long double, long double *);
long double  __cdecl powl(long double, long double);
long double  __cdecl sinl(long double);
long double  __cdecl sinhl(long double);
long double  __cdecl sqrtl(long double);
long double  __cdecl tanl(long double);
long double  __cdecl tanhl(long double);
long double  __cdecl _y0l(long double);
long double  __cdecl _y1l(long double);
long double  __cdecl _ynl(int, long double);


#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr _matherr

extern double __near __cdecl HUGE;

#ifdef _MT
#ifndef __cplusplus
double  __pascal cabs(struct complex);
#endif 
double  __pascal hypot(double, double);
double  __pascal j0(double);
double  __pascal j1(double);
double  __pascal jn(int, double);
double  __pascal y0(double);
double  __pascal y1(double);
double  __pascal yn(int, double);
#else 
#ifndef __cplusplus
double  __cdecl cabs(struct complex);
#endif 
double  __cdecl hypot(double, double);
double  __cdecl j0(double);
double  __cdecl j1(double);
double  __cdecl jn(int, double);
double  __cdecl y0(double);
double  __cdecl y1(double);
double  __cdecl yn(int, double);
#endif 

int __cdecl dieeetomsbin(double *, double *);
int __cdecl dmsbintoieee(double *, double *);
int __cdecl fieeetomsbin(float *, float *);
int __cdecl fmsbintoieee(float *, float *);

long double  __cdecl cabsl(struct _complexl);
long double  __cdecl hypotl(long double, long double);

#endif 


#ifdef __cplusplus
}
#endif 

#define _INC_MATH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\lzexpand.h ===
/*****************************************************************************\
*                                                                             *
* lzexpand.h    Public interfaces for LZEXPAND.DLL.                           *
*                                                                             *
* Version 3.10								      *
*                                                                             *
* NOTE: windows.h must be included first if LIB is NOT #defined 	      *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with LZEXP?.LIB (default is for LZEXPAND.DLL)
*                 NOTE: Not compatible with windows.h if LIB is #defined
*
\*****************************************************************************/

#ifndef _INC_LZEXPAND
#define _INC_LZEXPAND

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#define LZAPI       _pascal

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#endif  /* WINAPI */

#else   /* LIB */

#define LZAPI       _far _pascal

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/****** Error return codes ***************************************************/

#define LZERROR_BADINHANDLE   (-1)  /* invalid input handle */
#define LZERROR_BADOUTHANDLE  (-2)  /* invalid output handle */
#define LZERROR_READ          (-3)  /* corrupt compressed file format */
#define LZERROR_WRITE         (-4)  /* out of space for output file */
#define LZERROR_GLOBALLOC     (-5)  /* insufficient memory for LZFile struct */
#define LZERROR_GLOBLOCK      (-6)  /* bad global handle */
#define LZERROR_BADVALUE      (-7)  /* input parameter out of range */
#define LZERROR_UNKNOWNALG    (-8)  /* compression algorithm not recognized */

/****** Public functions *****************************************************/

int     LZAPI LZStart(void);
void    LZAPI LZDone(void);
LONG    LZAPI CopyLZFile(HFILE, HFILE);
LONG    LZAPI LZCopy(HFILE, HFILE);
HFILE   LZAPI LZInit(HFILE);
int     LZAPI GetExpandedName(LPCSTR, LPSTR);
HFILE   LZAPI LZOpenFile(LPCSTR, OFSTRUCT FAR*, UINT);
LONG    LZAPI LZSeek(HFILE, LONG, int);
int     LZAPI LZRead(HFILE, void FAR*, int);
void    LZAPI LZClose(HFILE);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif  /* _INC_LZEXPAND */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains the function declarations for memory allocation functions;
*   also defines manifest constants and types used by the heap routines.
*   [System V]
*
****/

#ifndef _INC_MALLOC

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __based     _based
#define __cdecl     _cdecl
#define __far       _far
#define __huge      _huge
#define __near      _near
#define __segment   _segment
#endif 

/* constants for based heap routines */

#define _NULLSEG    ((__segment)0)
#define _NULLOFF    ((void __based(void) *)0xffff)

/* constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY  (-1)
#define _HEAPOK     (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND    (-5)
#define _HEAPBADPTR (-6)
#define _FREEENTRY  0
#define _USEDENTRY  1

/* maximum heap request that can ever be honored */

#ifdef _WINDOWS
#define _HEAP_MAXREQ    0xFFE6
#else 
#define _HEAP_MAXREQ    0xFFE8
#endif 

/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
    int __far * _pentry;
    size_t _size;
    int _useflag;
    } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif 


/* external variable declarations */

extern unsigned int __near __cdecl _amblksiz;


/* based heap function prototypes */

void __based(void) * __cdecl _bcalloc(__segment, size_t, size_t);
void __based(void) * __cdecl _bexpand(__segment,
    void __based(void) *, size_t);
void __cdecl _bfree(__segment, void __based(void) *);
int __cdecl _bfreeseg(__segment);
int __cdecl _bheapadd(__segment, void __based(void) *, size_t);
int __cdecl _bheapchk(__segment);
int __cdecl _bheapmin(__segment);
__segment __cdecl _bheapseg(size_t);
int __cdecl _bheapset(__segment, unsigned int);
int __cdecl _bheapwalk(__segment, _HEAPINFO *);
void __based(void) * __cdecl _bmalloc(__segment, size_t);
size_t __cdecl _bmsize(__segment, void __based(void) *);
void __based(void) * __cdecl _brealloc(__segment,
    void __based(void) *, size_t);


/* function prototypes */

void * __cdecl _alloca(size_t);
void * __cdecl calloc(size_t, size_t);
void * __cdecl _expand(void *, size_t);
void __far * __cdecl _fcalloc(size_t, size_t);
void __far * __cdecl _fexpand(void __far *, size_t);
void __cdecl _ffree(void __far *);
int __cdecl _fheapchk(void);
int __cdecl _fheapmin(void);
int __cdecl _fheapset(unsigned int);
int __cdecl _fheapwalk(_HEAPINFO *);
void __far * __cdecl _fmalloc(size_t);
size_t __cdecl _fmsize(void __far *);
void __far * __cdecl _frealloc(void __far *, size_t);
unsigned int __cdecl _freect(size_t);
void __cdecl free(void *);
void __huge * __cdecl _halloc(long, size_t);
void __cdecl _hfree(void __huge *);
#ifndef _WINDOWS
int __cdecl _heapadd(void __far *, size_t);
int __cdecl _heapchk(void);
#endif 
int __cdecl _heapmin(void);
#ifndef _WINDOWS
int __cdecl _heapset(unsigned int);
int __cdecl _heapwalk(_HEAPINFO *);
#endif 
void * __cdecl malloc(size_t);
size_t __cdecl _memavl(void);
size_t __cdecl _memmax(void);
size_t __cdecl _msize(void *);
void __near * __cdecl _ncalloc(size_t, size_t);
void __near * __cdecl _nexpand(void __near *, size_t);
void __cdecl _nfree(void __near *);
#ifndef _WINDOWS
int __cdecl _nheapchk(void);
#endif 
int __cdecl _nheapmin(void);
#ifndef _WINDOWS
int __cdecl _nheapset(unsigned int);
int __cdecl _nheapwalk(_HEAPINFO *);
#endif 
void __near * __cdecl _nmalloc(size_t);
size_t __cdecl _nmsize(void __near *);
void __near * __cdecl _nrealloc(void __near *, size_t);
void * __cdecl realloc(void *, size_t);
size_t __cdecl _stackavail(void);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl alloca(size_t);
void __huge * __cdecl halloc(long, size_t);
void __cdecl hfree(void __huge *);
size_t __cdecl stackavail(void);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_MALLOC
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\mciwnd.h ===
/*----------------------------------------------------------------------------*\
 *
 *  MCIWnd
 *
 *    MCIWnd window class header file.
 *
 *    the MCIWnd window class is a window class for controling MCI devices
 *    MCI devices include, wave files, midi files, AVI Video, cd audio,
 *    vcr, video disc, and others..
 *
 *    to learn more about MCI and mci command sets see the
 *    "Microsoft Multimedia Programmers's guide" in the Win31 SDK
 *
 *    the easiest use of the MCIWnd class is like so:
 *
 *          hwnd = MCIWndCreate(hwndParent, hInstance, 0, "chimes.wav");
 *          ...
 *          MCIWndPlay(hwnd);
 *          MCIWndStop(hwnd);
 *          MCIWndPause(hwnd);
 *          ....
 *          MCIWndDestroy(hwnd);
 *
 *    this will create a window with a play/pause, stop and a playbar
 *    and start the wave file playing.
 *
 *    mciwnd.h defines macros for all the most common MCI commands, but
 *    any string command can be used if needed.
 *
 *    Note: unlike the mciSendString() API, no alias or file name needs
 *    to be specifed, since the device to use is implied by the window handle.
 *
 *          MCIWndSendString(hwnd, "setaudio stream to 2");
 *
 *    (C) Copyright Microsoft Corp. 1991-1994.  All rights reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files.
 *
 *    If you did not get this from Microsoft Sources, then it may not be the
 *    most current version.  This sample code in particular will be updated
 *    and include more documentation.
 *
 *    Sources are:
 *       CompuServe: WINSDK forum, MDK section.
 *       Anonymous FTP from ftp.uu.net vendor\microsoft\multimedia
 *
 * WIN32:
 *
 *    MCIWnd supports both ansi and unicode interfaces. For any message that
 *    takes or returns a text string, two versions of the message are defined,
 *    appended with A or W for Ansi or Wide Char. The message or api itself
 *    is defined to be one or other of these depending on whether you have
 *    UNICODE defined in your application.
 *    Thus for the api MCIWndCreate, there are in fact two apis,
 *    MCIWndCreateA and MCIWndCreateW. If you call MCIWndCreate, this will be
 *    re-routed to MCIWndCreateA unless UNICODE is defined when building your
 *    application. In any one application, you can mix calls to the
 *    Ansi and Unicode entrypoints.
 *
 *    If you use SendMessage instead of the macros below such as MCIWndOpen(),
 *    you will see that the messages have changed for WIN32, to support Ansi
 *    and Unicode entrypoints. In particular, MCI_OPEN has been replaced by
 *    MCWNDM_OPENA, or MCIWNDM_OPENW (MCIWNDM_OPEN is defined to be one or
 *    other of these).
 *
 *    Also, note that the WIN32 implementation of MCIWnd uses UNICODE
 *    so all apis and messages supporting ANSI strings do so by mapping them
 *    UNICODE strings and then calling the corresponding UNICODE entrypoint.
 *
 *----------------------------------------------------------------------------*/

#ifndef INC_MCIWND
#define INC_MCIWND

#ifdef __cplusplus
// MFC Redefines SendMessage, so make sure we get the global one....
#define MCIWndSM ::SendMessage  /* SendMessage in C++*/
#else
#define MCIWndSM SendMessage    /* SendMessage in C */
#endif  /* __cplusplus */

#ifdef __cplusplus
extern "C" {
#endif

#define MCIWND_WINDOW_CLASS TEXT("MCIWndClass")

#ifdef WIN32
HWND FAR _cdecl _loadds MCIWndCreateA(HWND hwndParent, HINSTANCE hInstance,
		      DWORD dwStyle,LPCSTR szFile);
HWND FAR _cdecl _loadds MCIWndCreateW(HWND hwndParent, HINSTANCE hInstance,
		      DWORD dwStyle,LPCWSTR szFile);
#ifdef UNICODE
#define MCIWndCreate    MCIWndCreateW
#else
#define MCIWndCreate    MCIWndCreateA
#endif
#else
HWND FAR _cdecl _loadds MCIWndCreate(HWND hwndParent, HINSTANCE hInstance,
                      DWORD dwStyle,LPCSTR szFile);
#endif

BOOL FAR _cdecl _loadds MCIWndRegisterClass();

// Flags for the MCIWndOpen command
#define MCIWNDOPENF_NEW	            0x0001  // open a new file

// window styles
#define MCIWNDF_NOAUTOSIZEWINDOW    0x0001  // when movie size changes
#define MCIWNDF_NOPLAYBAR           0x0002  // no toolbar
#define MCIWNDF_NOAUTOSIZEMOVIE     0x0004  // when window size changes
#define MCIWNDF_NOMENU              0x0008  // no popup menu from RBUTTONDOWN
#define MCIWNDF_SHOWNAME            0x0010  // show name in caption
#define MCIWNDF_SHOWPOS             0x0020  // show position in caption
#define MCIWNDF_SHOWMODE            0x0040  // show mode in caption
#define MCIWNDF_SHOWALL             0x0070  // show all

#ifdef WIN32

// some notifications include text strings.
// to receive notifications in ANSI instead of unicode set the
// MCIWNDF_NOTIFYANSI style bit. The macros below include this bit
// by default unless you define UNICODE in your application.

#define MCIWNDF_NOTIFYANSI	    0x0080

#define MCIWNDF_NOTIFYMODEW         0x0100  // tell parent of mode change
#define MCIWNDF_NOTIFYPOSW          0x0200  // tell parent of pos change
#define MCIWNDF_NOTIFYSIZEW         0x0400  // tell parent of size change
#define MCIWNDF_NOTIFYMEDIAW        0x0800  // tell parent of media change
#define MCIWNDF_NOTIFYERRORW        0x1000  // tell parent of an error
#define MCIWNDF_NOTIFYALLW          0x1F00  // tell all

#define MCIWNDF_NOTIFYMODEA         0x0180  // tell parent of mode change
#define MCIWNDF_NOTIFYPOSA          0x0280  // tell parent of pos change
#define MCIWNDF_NOTIFYSIZEA         0x0480  // tell parent of size change
#define MCIWNDF_NOTIFYMEDIAA        0x0880  // tell parent of media change
#define MCIWNDF_NOTIFYERRORA        0x1080  // tell parent of an error
#define MCIWNDF_NOTIFYALLA          0x1F80  // tell all

#ifdef UNICODE
#define MCIWNDF_NOTIFYMODE	    MCIWNDF_NOTIFYMODEW
#define MCIWNDF_NOTIFYPOS           MCIWNDF_NOTIFYPOSW
#define MCIWNDF_NOTIFYSIZE          MCIWNDF_NOTIFYSIZEW
#define MCIWNDF_NOTIFYMEDIA         MCIWNDF_NOTIFYMEDIAW
#define MCIWNDF_NOTIFYERROR         MCIWNDF_NOTIFYERRORW
#define MCIWNDF_NOTIFYALL           MCIWNDF_NOTIFYALLW
#else
#define MCIWNDF_NOTIFYMODE          MCIWNDF_NOTIFYMODEA
#define MCIWNDF_NOTIFYPOS           MCIWNDF_NOTIFYPOSA
#define MCIWNDF_NOTIFYSIZE          MCIWNDF_NOTIFYSIZEA
#define MCIWNDF_NOTIFYMEDIA         MCIWNDF_NOTIFYMEDIAA
#define MCIWNDF_NOTIFYERROR         MCIWNDF_NOTIFYERRORA
#define MCIWNDF_NOTIFYALL           MCIWNDF_NOTIFYALLA
#endif

#else
#define MCIWNDF_NOTIFYMODE          0x0100  // tell parent of mode change
#define MCIWNDF_NOTIFYPOS           0x0200  // tell parent of pos change
#define MCIWNDF_NOTIFYSIZE          0x0400  // tell parent of size change
#define MCIWNDF_NOTIFYMEDIA         0x0800  // tell parent of media change
#define MCIWNDF_NOTIFYERROR         0x1000  // tell parent of an error
#define MCIWNDF_NOTIFYALL           0x1F00  // tell all
#endif


#define MCIWNDF_RECORD              0x2000  // Give a record button
#define MCIWNDF_NOERRORDLG          0x4000  // Show Error Dlgs for MCI cmds?
#define MCIWNDF_NOOPEN		    0x8000  // Don't allow user to open things




// can macros

#define MCIWndCanPlay(hwnd)         (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_PLAY,0,0)
#define MCIWndCanRecord(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_RECORD,0,0)
#define MCIWndCanSave(hwnd)         (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_SAVE,0,0)
#define MCIWndCanWindow(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_WINDOW,0,0)
#define MCIWndCanEject(hwnd)        (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_EJECT,0,0)
#define MCIWndCanConfig(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_CONFIG,0,0)
#define MCIWndPaletteKick(hwnd)     (BOOL)MCIWndSM(hwnd,MCIWNDM_PALETTEKICK,0,0)

#define MCIWndSave(hwnd, szFile)    (LONG)MCIWndSM(hwnd, MCI_SAVE, 0, (LPARAM)(LPVOID)(szFile))
#define MCIWndSaveDialog(hwnd)      MCIWndSave(hwnd, -1)

// if you dont give a device it will use the current device....
#define MCIWndNew(hwnd, lp)         (LONG)MCIWndSM(hwnd, MCIWNDM_NEW, 0, (LPARAM)(LPVOID)(lp))

#define MCIWndRecord(hwnd)          (LONG)MCIWndSM(hwnd, MCI_RECORD, 0, 0)
#ifdef WIN32
#define MCIWndOpen(hwnd, sz, f)     (LONG)MCIWndSM(hwnd, MCIWNDM_OPEN, (WPARAM)(UINT)(f),(LPARAM)(LPVOID)(sz))
#else
#define MCIWndOpen(hwnd, sz, f)     (LONG)MCIWndSM(hwnd, MCI_OPEN, (WPARAM)(UINT)(f),(LPARAM)(LPVOID)(sz))
#endif
#define MCIWndOpenDialog(hwnd)      MCIWndOpen(hwnd, -1, 0)
#define MCIWndClose(hwnd)           (LONG)MCIWndSM(hwnd, MCI_CLOSE, 0, 0)
#define MCIWndPlay(hwnd)            (LONG)MCIWndSM(hwnd, MCI_PLAY, 0, 0)
#define MCIWndStop(hwnd)            (LONG)MCIWndSM(hwnd, MCI_STOP, 0, 0)
#define MCIWndPause(hwnd)           (LONG)MCIWndSM(hwnd, MCI_PAUSE, 0, 0)
#define MCIWndResume(hwnd)          (LONG)MCIWndSM(hwnd, MCI_RESUME, 0, 0)
#define MCIWndSeek(hwnd, lPos)      (LONG)MCIWndSM(hwnd, MCI_SEEK, 0, (LPARAM)(LONG)(lPos))
#define MCIWndEject(hwnd)           (LONG)MCIWndSM(hwnd, MCIWNDM_EJECT, 0, 0)

#define MCIWndHome(hwnd)            MCIWndSeek(hwnd, MCIWND_START)
#define MCIWndEnd(hwnd)             MCIWndSeek(hwnd, MCIWND_END)

#define MCIWndGetSource(hwnd, prc)  (LONG)MCIWndSM(hwnd, MCIWNDM_GET_SOURCE, 0, (LPARAM)(LPRECT)(prc))
#define MCIWndPutSource(hwnd, prc)  (LONG)MCIWndSM(hwnd, MCIWNDM_PUT_SOURCE, 0, (LPARAM)(LPRECT)(prc))

#define MCIWndGetDest(hwnd, prc)    (LONG)MCIWndSM(hwnd, MCIWNDM_GET_DEST, 0, (LPARAM)(LPRECT)(prc))
#define MCIWndPutDest(hwnd, prc)    (LONG)MCIWndSM(hwnd, MCIWNDM_PUT_DEST, 0, (LPARAM)(LPRECT)(prc))

#define MCIWndPlayReverse(hwnd)     (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYREVERSE, 0, 0)
#define MCIWndPlayFrom(hwnd, lPos)  (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYFROM, 0, (LPARAM)(LONG)(lPos))
#define MCIWndPlayTo(hwnd, lPos)    (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYTO,   0, (LPARAM)(LONG)(lPos))
#define MCIWndPlayFromTo(hwnd, lStart, lEnd) (MCIWndSeek(hwnd, lStart), MCIWndPlayTo(hwnd, lEnd))

#define MCIWndGetDeviceID(hwnd)     (UINT)MCIWndSM(hwnd, MCIWNDM_GETDEVICEID, 0, 0)
#define MCIWndGetAlias(hwnd)        (UINT)MCIWndSM(hwnd, MCIWNDM_GETALIAS, 0, 0)
#define MCIWndGetMode(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETMODE, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndGetPosition(hwnd)     (LONG)MCIWndSM(hwnd, MCIWNDM_GETPOSITION, 0, 0)
#define MCIWndGetPositionString(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETPOSITION, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndGetStart(hwnd)        (LONG)MCIWndSM(hwnd, MCIWNDM_GETSTART, 0, 0)
#define MCIWndGetLength(hwnd)       (LONG)MCIWndSM(hwnd, MCIWNDM_GETLENGTH, 0, 0)
#define MCIWndGetEnd(hwnd)          (LONG)MCIWndSM(hwnd, MCIWNDM_GETEND, 0, 0)

#define MCIWndStep(hwnd, n)         (LONG)MCIWndSM(hwnd, MCI_STEP, 0,(LPARAM)(long)(n))

#define MCIWndDestroy(hwnd)         (VOID)MCIWndSM(hwnd, WM_CLOSE, 0, 0)
#define MCIWndSetZoom(hwnd,iZoom)   (VOID)MCIWndSM(hwnd, MCIWNDM_SETZOOM, 0, (LPARAM)(UINT)(iZoom))
#define MCIWndGetZoom(hwnd)         (UINT)MCIWndSM(hwnd, MCIWNDM_GETZOOM, 0, 0)
#define MCIWndSetVolume(hwnd,iVol)  (LONG)MCIWndSM(hwnd, MCIWNDM_SETVOLUME, 0, (LPARAM)(UINT)(iVol))
#define MCIWndGetVolume(hwnd)       (LONG)MCIWndSM(hwnd, MCIWNDM_GETVOLUME, 0, 0)
#define MCIWndSetSpeed(hwnd,iSpeed) (LONG)MCIWndSM(hwnd, MCIWNDM_SETSPEED, 0, (LPARAM)(UINT)(iSpeed))
#define MCIWndGetSpeed(hwnd)        (LONG)MCIWndSM(hwnd, MCIWNDM_GETSPEED, 0, 0)
#define MCIWndSetTimeFormat(hwnd, lp) (LONG)MCIWndSM(hwnd, MCIWNDM_SETTIMEFORMAT, 0, (LPARAM)(LPTSTR)(lp))
#define MCIWndGetTimeFormat(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETTIMEFORMAT, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndValidateMedia(hwnd)   (VOID)MCIWndSM(hwnd, MCIWNDM_VALIDATEMEDIA, 0, 0)

#define MCIWndSetRepeat(hwnd,f)     (void)MCIWndSM(hwnd, MCIWNDM_SETREPEAT, 0, (LPARAM)(BOOL)(f))
#define MCIWndGetRepeat(hwnd)       (BOOL)MCIWndSM(hwnd, MCIWNDM_GETREPEAT, 0, 0)

#define MCIWndUseFrames(hwnd)       MCIWndSetTimeFormat(hwnd, TEXT("frames"))
#define MCIWndUseTime(hwnd)         MCIWndSetTimeFormat(hwnd, TEXT("ms"))

#define MCIWndSetActiveTimer(hwnd, active)				\
	(VOID)MCIWndSM(hwnd, MCIWNDM_SETACTIVETIMER,			\
	(WPARAM)(UINT)(active), 0L)
#define MCIWndSetInactiveTimer(hwnd, inactive)				\
	(VOID)MCIWndSM(hwnd, MCIWNDM_SETINACTIVETIMER,		\
	(WPARAM)(UINT)(inactive), 0L)
#define MCIWndSetTimers(hwnd, active, inactive)				      \
	    (VOID)MCIWndSM(hwnd, MCIWNDM_SETTIMERS,(WPARAM)(UINT)(active), \
	    (LPARAM)(UINT)(inactive))
#define MCIWndGetActiveTimer(hwnd)					\
	(UINT)MCIWndSM(hwnd, MCIWNDM_GETACTIVETIMER,	0, 0L);
#define MCIWndGetInactiveTimer(hwnd)					\
	(UINT)MCIWndSM(hwnd, MCIWNDM_GETINACTIVETIMER, 0, 0L);

#define MCIWndRealize(hwnd, fBkgnd) (LONG)MCIWndSM(hwnd, MCIWNDM_REALIZE,(WPARAM)(BOOL)(fBkgnd),0)

#define MCIWndSendString(hwnd, sz)  (LONG)MCIWndSM(hwnd, MCIWNDM_SENDSTRING, 0, (LPARAM)(LPTSTR)(sz))
#define MCIWndReturnString(hwnd, lp, len)  (LONG)MCIWndSM(hwnd, MCIWNDM_RETURNSTRING, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))
#define MCIWndGetError(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETERROR, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))

//#define MCIWndActivate(hwnd, f)     (void)MCIWndSM(hwnd, WM_ACTIVATE, (WPARAM)(BOOL)(f), 0)

#define MCIWndGetPalette(hwnd)      (HPALETTE)MCIWndSM(hwnd, MCIWNDM_GETPALETTE, 0, 0)
#define MCIWndSetPalette(hwnd, hpal) (LONG)MCIWndSM(hwnd, MCIWNDM_SETPALETTE, (WPARAM)(HPALETTE)(hpal), 0)

#define MCIWndGetFileName(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETFILENAME, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))
#define MCIWndGetDevice(hwnd, lp, len)   (LONG)MCIWndSM(hwnd, MCIWNDM_GETDEVICE, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))

#define MCIWndGetStyles(hwnd) (UINT)MCIWndSM(hwnd, MCIWNDM_GETSTYLES, 0, 0L)
#define MCIWndChangeStyles(hwnd, mask, value) (LONG)MCIWndSM(hwnd, MCIWNDM_CHANGESTYLES, (WPARAM)(UINT)(mask), (LPARAM)(LONG)(value))

#define MCIWndOpenInterface(hwnd, pUnk)  (LONG)MCIWndSM(hwnd, MCIWNDM_OPENINTERFACE, 0, (LPARAM)(LPUNKNOWN)(pUnk))

#define MCIWndSetOwner(hwnd, hwndP)  (LONG)MCIWndSM(hwnd, MCIWNDM_SETOWNER, (WPARAM)(hwndP), 0)


// Messages an app will send to MCIWND

// all the text-related messages are defined out of order above (they need
// to be defined before the MCIWndOpen() macros

#define MCIWNDM_GETDEVICEID	(WM_USER + 100)
#define MCIWNDM_GETSTART	(WM_USER + 103)
#define MCIWNDM_GETLENGTH	(WM_USER + 104)
#define MCIWNDM_GETEND		(WM_USER + 105)
#define MCIWNDM_EJECT		(WM_USER + 107)
#define MCIWNDM_SETZOOM		(WM_USER + 108)
#define MCIWNDM_GETZOOM         (WM_USER + 109)
#define MCIWNDM_SETVOLUME	(WM_USER + 110)
#define MCIWNDM_GETVOLUME	(WM_USER + 111)
#define MCIWNDM_SETSPEED	(WM_USER + 112)
#define MCIWNDM_GETSPEED	(WM_USER + 113)
#define MCIWNDM_SETREPEAT	(WM_USER + 114)
#define MCIWNDM_GETREPEAT	(WM_USER + 115)
#define MCIWNDM_REALIZE         (WM_USER + 118)
#define MCIWNDM_VALIDATEMEDIA   (WM_USER + 121)
#define MCIWNDM_PLAYFROM	(WM_USER + 122)
#define MCIWNDM_PLAYTO          (WM_USER + 123)
#define MCIWNDM_GETPALETTE      (WM_USER + 126)
#define MCIWNDM_SETPALETTE      (WM_USER + 127)
#define MCIWNDM_SETTIMERS	(WM_USER + 129)
#define MCIWNDM_SETACTIVETIMER	(WM_USER + 130)
#define MCIWNDM_SETINACTIVETIMER (WM_USER + 131)
#define MCIWNDM_GETACTIVETIMER	(WM_USER + 132)
#define MCIWNDM_GETINACTIVETIMER (WM_USER + 133)
#define MCIWNDM_CHANGESTYLES	(WM_USER + 135)
#define MCIWNDM_GETSTYLES	(WM_USER + 136)
#define MCIWNDM_GETALIAS	(WM_USER + 137)
#define MCIWNDM_PLAYREVERSE	(WM_USER + 139)
#define MCIWNDM_GET_SOURCE      (WM_USER + 140)
#define MCIWNDM_PUT_SOURCE      (WM_USER + 141)
#define MCIWNDM_GET_DEST        (WM_USER + 142)
#define MCIWNDM_PUT_DEST        (WM_USER + 143)
#define MCIWNDM_CAN_PLAY        (WM_USER + 144)
#define MCIWNDM_CAN_WINDOW      (WM_USER + 145)
#define MCIWNDM_CAN_RECORD      (WM_USER + 146)
#define MCIWNDM_CAN_SAVE        (WM_USER + 147)
#define MCIWNDM_CAN_EJECT       (WM_USER + 148)
#define MCIWNDM_CAN_CONFIG      (WM_USER + 149)
#define MCIWNDM_PALETTEKICK     (WM_USER + 150)
#define MCIWNDM_OPENINTERFACE	(WM_USER + 151)
#define MCIWNDM_SETOWNER	(WM_USER + 152)


#ifdef WIN32

//define both A and W messages
#define MCIWNDM_SENDSTRINGA	(WM_USER + 101)
#define MCIWNDM_GETPOSITIONA	(WM_USER + 102)
#define MCIWNDM_GETMODEA	(WM_USER + 106)
#define MCIWNDM_SETTIMEFORMATA  (WM_USER + 119)
#define MCIWNDM_GETTIMEFORMATA  (WM_USER + 120)
#define MCIWNDM_GETFILENAMEA    (WM_USER + 124)
#define MCIWNDM_GETDEVICEA      (WM_USER + 125)
#define MCIWNDM_GETERRORA       (WM_USER + 128)
#define MCIWNDM_NEWA		(WM_USER + 134)
#define MCIWNDM_RETURNSTRINGA	(WM_USER + 138)
#define MCIWNDM_OPENA		(WM_USER + 153)

#define MCIWNDM_SENDSTRINGW	(WM_USER + 201)
#define MCIWNDM_GETPOSITIONW	(WM_USER + 202)
#define MCIWNDM_GETMODEW	(WM_USER + 206)
#define MCIWNDM_SETTIMEFORMATW  (WM_USER + 219)
#define MCIWNDM_GETTIMEFORMATW  (WM_USER + 220)
#define MCIWNDM_GETFILENAMEW    (WM_USER + 224)
#define MCIWNDM_GETDEVICEW      (WM_USER + 225)
#define MCIWNDM_GETERRORW       (WM_USER + 228)
#define MCIWNDM_NEWW		(WM_USER + 234)
#define MCIWNDM_RETURNSTRINGW	(WM_USER + 238)
#define MCIWNDM_OPENW		(WM_USER + 252)

// map defaults to A or W depending on app's UNICODE setting
#ifdef UNICODE
#define MCIWNDM_SENDSTRING      MCIWNDM_SENDSTRINGW
#define MCIWNDM_GETPOSITION     MCIWNDM_GETPOSITIONW
#define MCIWNDM_GETMODE         MCIWNDM_GETMODEW
#define MCIWNDM_SETTIMEFORMAT   MCIWNDM_SETTIMEFORMATW
#define MCIWNDM_GETTIMEFORMAT   MCIWNDM_GETTIMEFORMATW
#define MCIWNDM_GETFILENAME     MCIWNDM_GETFILENAMEW
#define MCIWNDM_GETDEVICE       MCIWNDM_GETDEVICEW
#define MCIWNDM_GETERROR        MCIWNDM_GETERRORW
#define MCIWNDM_NEW             MCIWNDM_NEWW
#define MCIWNDM_RETURNSTRING    MCIWNDM_RETURNSTRINGW
#define MCIWNDM_OPEN		MCIWNDM_OPENW
#else
#define MCIWNDM_SENDSTRING      MCIWNDM_SENDSTRINGA
#define MCIWNDM_GETPOSITION     MCIWNDM_GETPOSITIONA
#define MCIWNDM_GETMODE         MCIWNDM_GETMODEA
#define MCIWNDM_SETTIMEFORMAT   MCIWNDM_SETTIMEFORMATA
#define MCIWNDM_GETTIMEFORMAT   MCIWNDM_GETTIMEFORMATA
#define MCIWNDM_GETFILENAME     MCIWNDM_GETFILENAMEA
#define MCIWNDM_GETDEVICE       MCIWNDM_GETDEVICEA
#define MCIWNDM_GETERROR        MCIWNDM_GETERRORA
#define MCIWNDM_NEW             MCIWNDM_NEWA
#define MCIWNDM_RETURNSTRING    MCIWNDM_RETURNSTRINGA
#define MCIWNDM_OPEN		MCIWNDM_OPENA
#endif

// note that the source text for MCIWND will thus contain
// support for eg MCIWNDM_SENDSTRING (both the 16-bit entrypoint and
// in win32 mapped to MCIWNDM_SENDSTRINGW), and MCIWNDM_SENDSTRINGA (the
// win32 ansi thunk).

#else

// 16-bit Windows defines

#define MCIWNDM_SENDSTRING	(WM_USER + 101)
#define MCIWNDM_GETPOSITION	(WM_USER + 102)
#define MCIWNDM_GETMODE		(WM_USER + 106)
#define MCIWNDM_SETTIMEFORMAT   (WM_USER + 119)
#define MCIWNDM_GETTIMEFORMAT   (WM_USER + 120)
#define MCIWNDM_GETFILENAME     (WM_USER + 124)
#define MCIWNDM_GETDEVICE       (WM_USER + 125)
#define MCIWNDM_GETERROR        (WM_USER + 128)
#define MCIWNDM_NEW		(WM_USER + 134)
#define MCIWNDM_RETURNSTRING	(WM_USER + 138)

#endif






// Messages MCIWND will send to an app
#define MCIWNDM_NOTIFYMODE      (WM_USER + 200)  // wp = hwnd, lp = mode
#define MCIWNDM_NOTIFYPOS	(WM_USER + 201)  // wp = hwnd, lp = pos
#define MCIWNDM_NOTIFYSIZE	(WM_USER + 202)  // wp = hwnd
#define MCIWNDM_NOTIFYMEDIA     (WM_USER + 203)  // wp = hwnd, lp = fn
#define MCIWNDM_NOTIFYERROR     (WM_USER + 205)  // wp = hwnd, lp = error

// special seek values for START and END
#define MCIWND_START                -1
#define MCIWND_END                  -2

#ifndef MCI_PLAY
    /* MCI command message identifiers */
#ifndef WIN32
    // win32 apps send MCIWNDM_OPEN
    #define MCI_OPEN                        0x0803
#endif
    #define MCI_CLOSE                       0x0804
    #define MCI_PLAY                        0x0806
    #define MCI_SEEK                        0x0807
    #define MCI_STOP                        0x0808
    #define MCI_PAUSE                       0x0809
    #define MCI_STEP                        0x080E
    #define MCI_RECORD                      0x080F
    #define MCI_SAVE                        0x0813
    #define MCI_CUT                         0x0851
    #define MCI_COPY                        0x0852
    #define MCI_PASTE                       0x0853
    #define MCI_RESUME                      0x0855
    #define MCI_DELETE                      0x0856
#endif

#ifndef MCI_MODE_NOT_READY
    /* return values for 'status mode' command */
    #define MCI_MODE_NOT_READY      (524)
    #define MCI_MODE_STOP           (525)
    #define MCI_MODE_PLAY           (526)
    #define MCI_MODE_RECORD         (527)
    #define MCI_MODE_SEEK           (528)
    #define MCI_MODE_PAUSE          (529)
    #define MCI_MODE_OPEN           (530)
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\mmreg.h ===
/****************************************************************************
 *
 *   mmreg.h  - Registered Multimedia Information Public Header File
 *
 *   Copyright (c) 1991,1992,1993 Microsoft Corporation.  All Rights Reserved.
 *
 * Multimedia Registration
 *
 * Place this system include file in your INCLUDE path with the Windows SDK
 * include files.
 *
 * Obtain the Multimedia Developer Registration Kit from:
 *
 *  Heidi Breslauer
 *  Microsoft Corporation
 *  Multimedia Technology Group
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 * Developer Services:
 * 800-227-4679 x11771
 *
 * Last Update:  10/04/93
 *
 ***************************************************************************/

// Define the following to skip definitions
//
// NOMMIDS      Multimedia IDs are not defined
// NONEWWAVE    No new waveform types are defined except WAVEFORMATEX
// NONEWRIFF    No new RIFF forms are defined
// NOJPEGDIB    No JPEG DIB definitions
// NONEWIC      No new Image Compressor types are defined

#ifndef _INC_MMREG
/* use version number to verify compatibility */
#define _INC_MMREG     142      // version * 100 + revision

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef NOMMIDS
    
/* manufacturer IDs */
#ifndef MM_MICROSOFT
#define MM_MICROSOFT            1   /* Microsoft Corporation */
#endif
#define MM_CREATIVE             2   /* Creative Labs Inc. */
#define MM_MEDIAVISION          3   /* Media Vision Inc. */
#define MM_FUJITSU              4
#define MM_ARTISOFT             20  /* Artisoft Inc. */
#define MM_TURTLE_BEACH         21      
#define MM_IBM                  22  /* International Bussiness Machines Corp. */
#define MM_VOCALTEC             23  /* Vocaltec LTD. */
#define MM_ROLAND               24
#define MM_DIGISPEECH           25  /* Digispeech, Inc. */
#define MM_NEC                  26  /* NEC */
#define MM_ATI                  27  /* ATI */
#define MM_WANGLABS             28  /* Wang Laboratories, Inc. */
#define MM_TANDY                29  /* Tandy Corporation */
#define MM_VOYETRA              30  /* Voyetra */
#define MM_ANTEX                31  /* Antex */
#define MM_ICL_PS               32
#define MM_INTEL                33
#define MM_GRAVIS               34
#define MM_VAL                  35  /* Video Associates Labs */
#define MM_INTERACTIVE          36  /* InterActive, Inc. */
#define MM_YAMAHA               37  /* Yamaha Corp. of America */
#define MM_EVEREX               38  /* Everex Systems, Inc. */
#define MM_ECHO                 39  /* Echo Speech Corporation */
#define MM_SIERRA               40  /* Sierra Semiconductor */
#define MM_CAT                  41  /* Computer Aided Technologies */
#define MM_APPS                 42  /* APPS Software International */
#define MM_DSP_GROUP            43  /* DSP Group, Inc. */
#define MM_MELABS               44  /* microEngineering Labs */
#define MM_COMPUTER_FRIENDS     45  /* Computer Friends, Inc */
#define MM_ESS                  46  /* ESS Technology */
#define MM_AUDIOFILE            47  /* Audio, Inc. */
#define MM_MOTOROLA             48  /* Motorola, Inc. */
#define MM_CANOPUS              49  /* Canopus Co., Ltd. */
#define MM_EPSON                50  /* Seiko Epson Corp. */
#define MM_TRUEVISION           51  /* Truevision */
#define MM_AZTECH               52  /* Aztech Labs, Inc.*/
#define MM_VIDEOLOGIC           53  /* VideoLogic */
#define MM_SCALACS              54  /* SCALACS */
#define MM_KORG                 55  /* Toshihiko Okuhara, Korg Inc.*/
#define MM_APT                  56  /* Audio Processing Technology */
#define MM_ICS                  57  /* Integrated Circuit Systems */
#define MM_ITERATEDSYS          58  /* Iterated Systems Inc.*/
#define MM_METHEUS              59  /* Metheus Corp*/
#define MM_LOGITECH             60  /* Logitech Inc, Fremont, CA*/
#define MM_WINNOV               61  /* Winnov, Inc., Sunnyvale, CA*/

/* MM_MICROSOFT product IDs */
#ifndef MM_MIDI_MAPPER

#define MM_MIDI_MAPPER          1   /* MIDI Mapper */
#define MM_WAVE_MAPPER          2   /* Wave Mapper */
#define MM_SNDBLST_MIDIOUT      3   /* Sound Blaster MIDI output port */
#define MM_SNDBLST_MIDIIN       4   /* Sound Blaster MIDI input port */
#define MM_SNDBLST_SYNTH        5   /* Sound Blaster internal synthesizer */
#define MM_SNDBLST_WAVEOUT      6   /* Sound Blaster waveform output */
#define MM_SNDBLST_WAVEIN       7   /* Sound Blaster waveform input */
#define MM_ADLIB                9   /* Ad Lib-compatible synthesizer */
#define MM_MPU401_MIDIOUT      10   /* MPU401-compatible MIDI output port */
#define MM_MPU401_MIDIIN       11   /* MPU401-compatible MIDI input port */
#define MM_PC_JOYSTICK         12   /* Joystick adapter */

#endif

#define MM_PCSPEAKER_WAVEOUT            13  /* PC Speaker waveform output */

#define MM_MSFT_WSS_WAVEIN              14  /* MS Audio Board waveform input */
#define MM_MSFT_WSS_WAVEOUT             15  /* MS Audio Board waveform output */
#define MM_MSFT_WSS_FMSYNTH_STEREO      16  /* MS Audio Board Stereo FM synthesizer */
#define MM_MSFT_WSS_MIXER               17  /* MS Audio Board Mixer Driver */
#define MM_MSFT_WSS_OEM_WAVEIN          18  /* MS OEM Audio Board waveform input */
#define MM_MSFT_WSS_OEM_WAVEOUT         19  /* MS OEM Audio Board waveform Output */
#define MM_MSFT_WSS_OEM_FMSYNTH_STEREO  20  /* MS OEM Audio Board Stereo FM synthesizer */
#define MM_MSFT_WSS_AUX                 21  /* MS Audio Board Auxiliary Port */
#define MM_MSFT_WSS_OEM_AUX             22  /* MS OEM Audio Auxiliary Port */

#define MM_MSFT_GENERIC_WAVEIN          23  /* MS vanilla driver waveform input */
#define MM_MSFT_GENERIC_WAVEOUT         24  /* MS vanilla driver waveform output */
#define MM_MSFT_GENERIC_MIDIIN          25  /* MS vanilla driver MIDI input */
#define MM_MSFT_GENERIC_MIDIOUT         26  /* MS vanilla driver external MIDI output */
#define MM_MSFT_GENERIC_MIDISYNTH       27  /* MS vanilla driver MIDI synthesizer */
#define MM_MSFT_GENERIC_AUX_LINE        28  /* MS vanilla driver aux (line in) */
#define MM_MSFT_GENERIC_AUX_MIC         29  /* MS vanilla driver aux (mic) */
#define MM_MSFT_GENERIC_AUX_CD          30  /* MS vanilla driver aux (CD) */

#define MM_MSFT_WSS_OEM_MIXER           31  /* MS OEM Audio Board Mixer Driver */

#define MM_MSFT_MSACM                   32  /* MS Audio Compression Manager*/
#define MM_MSFT_ACM_MSADPCM             33  /* MS ADPCM codec*/
#define MM_MSFT_ACM_IMAADPCM            34  /* IMA ADPCM codec*/
#define MM_MSFT_ACM_MSFILTER            35  /* MS Filter*/
#define MM_MSFT_ACM_GSM610              36  /* GSM 610 codec*/
#define MM_MSFT_ACM_G711                37  /* G.711 codec*/
#define MM_MSFT_ACM_PCM                 38  /* PCM converter */

#define MM_MSFT_SB16_WAVEIN             39  /* Sound Blaster 16 waveform input */
#define MM_MSFT_SB16_WAVEOUT            40  /* Sound Blaster 16 waveform output */
#define MM_MSFT_SB16_MIDIIN             41  /* Sound Blaster 16 midi-in */
#define MM_MSFT_SB16_MIDIOUT            42  /* Sound Blaster 16 midi-out */
#define MM_MSFT_SB16_SYNTH              43  /* Sound Blaster 16 FM synthesis */
#define MM_MSFT_SB16_AUX_LINE           44  /* Sound Blaster 16 aux (line in) */
#define MM_MSFT_SB16_AUX_CD             45  /* Sound Blaster 16 aux (CD) */
#define MM_MSFT_SB16_MIXER              46  /* Sound Blaster 16 mixer device */

#define MM_MSFT_SBPRO_WAVEIN            47  /* Sound Blaster Pro waveform input */
#define MM_MSFT_SBPRO_WAVEOUT           48  /* Sound Blaster Pro waveform output */
#define MM_MSFT_SBPRO_MIDIIN            49  /* Sound Blaster Pro midi-in */
#define MM_MSFT_SBPRO_MIDIOUT           50  /* Sound Blaster Pro midi-out */
#define MM_MSFT_SBPRO_SYNTH             51  /* Sound Blaster Pro FM synthesis */
#define MM_MSFT_SBPRO_AUX_LINE          52  /* Sound Blaster Pro aux (line in) */
#define MM_MSFT_SBPRO_AUX_CD            53  /* Sound Blaster Pro aux (CD) */
#define MM_MSFT_SBPRO_MIXER             54  /* Sound Blaster Pro mixer */

/* MM_CREATIVE product IDs */
#define MM_CREATIVE_SB15_WAVEIN         1   /* SB (r) 1.5 waveform input */
#define MM_CREATIVE_SB20_WAVEIN         2   /* SB (r) 2.0 waveform input */
#define MM_CREATIVE_SBPRO_WAVEIN        3   /* SB Pro (r) waveform input */
#define MM_CREATIVE_SBP16_WAVEIN        4   /* SBP16 (r) waveform input */
#define MM_CREATIVE_SB15_WAVEOUT      101   /* SB (r) 1.5 waveform output */
#define MM_CREATIVE_SB20_WAVEOUT      102   /* SB (r) 2.0 waveform output */
#define MM_CREATIVE_SBPRO_WAVEOUT     103   /* SB Pro (r) waveform output */
#define MM_CREATIVE_SBP16_WAVEOUT     104   /* SBP16 (r) waveform output */
#define MM_CREATIVE_MIDIOUT           201   /* SB (r) MIDI output port */
#define MM_CREATIVE_MIDIIN            202   /* SB (r) MIDI input port */
#define MM_CREATIVE_FMSYNTH_MONO      301   /* SB (r) FM synthesizer */
#define MM_CREATIVE_FMSYNTH_STEREO    302   /* SB Pro (r) stereo FM synthesizer */
#define MM_CREATIVE_AUX_CD            401   /* SB Pro (r) aux (CD) */
#define MM_CREATIVE_AUX_LINE          402   /* SB Pro (r) aux (line in) */
#define MM_CREATIVE_AUX_MIC           403   /* SB Pro (r) aux (mic) */


/* MM_ARTISOFT product IDs */
#define MM_ARTISOFT_SBWAVEIN    1   /* Artisoft Sounding Board waveform input */
#define MM_ARTISOFT_SBWAVEOUT   2   /* Artisoft Sounding Board waveform output */

/* MM_IBM Product IDs */
#define MM_MMOTION_WAVEAUX      1       /* IBM M-Motion Auxiliary Device */
#define MM_MMOTION_WAVEOUT      2       /* IBM M-Motion Waveform Output */
#define MM_MMOTION_WAVEIN       3       /* IBM M-Motion Waveform Input */

/* MM_MEDIAVISION Product IDs */
// Original Pro AudioSpectrum
#define MM_MEDIAVISION_PROAUDIO 0x10
#define MM_PROAUD_MIDIOUT               (MM_MEDIAVISION_PROAUDIO+1)
#define MM_PROAUD_MIDIIN                (MM_MEDIAVISION_PROAUDIO+2)
#define MM_PROAUD_SYNTH                 (MM_MEDIAVISION_PROAUDIO+3)
#define MM_PROAUD_WAVEOUT               (MM_MEDIAVISION_PROAUDIO+4)
#define MM_PROAUD_WAVEIN                (MM_MEDIAVISION_PROAUDIO+5)
#define MM_PROAUD_MIXER                 (MM_MEDIAVISION_PROAUDIO+6)
#define MM_PROAUD_AUX                   (MM_MEDIAVISION_PROAUDIO+7)

// Thunder board
#define MM_MEDIAVISION_THUNDER          0x20
#define MM_THUNDER_SYNTH                (MM_MEDIAVISION_THUNDER+3)
#define MM_THUNDER_WAVEOUT              (MM_MEDIAVISION_THUNDER+4)
#define MM_THUNDER_WAVEIN               (MM_MEDIAVISION_THUNDER+5)
#define MM_THUNDER_AUX                  (MM_MEDIAVISION_THUNDER+7)

// Audio Port
#define MM_MEDIAVISION_TPORT            0x40
#define MM_TPORT_WAVEOUT                (MM_MEDIAVISION_TPORT+1)
#define MM_TPORT_WAVEIN                 (MM_MEDIAVISION_TPORT+2)
#define MM_TPORT_SYNTH                  (MM_MEDIAVISION_TPORT+3)

// Pro AudioSpectrum Plus
#define MM_MEDIAVISION_PROAUDIO_PLUS    0x50
#define MM_PROAUD_PLUS_MIDIOUT          (MM_MEDIAVISION_PROAUDIO_PLUS+1)
#define MM_PROAUD_PLUS_MIDIIN           (MM_MEDIAVISION_PROAUDIO_PLUS+2)
#define MM_PROAUD_PLUS_SYNTH            (MM_MEDIAVISION_PROAUDIO_PLUS+3)
#define MM_PROAUD_PLUS_WAVEOUT          (MM_MEDIAVISION_PROAUDIO_PLUS+4)
#define MM_PROAUD_PLUS_WAVEIN           (MM_MEDIAVISION_PROAUDIO_PLUS+5)
#define MM_PROAUD_PLUS_MIXER            (MM_MEDIAVISION_PROAUDIO_PLUS+6)
#define MM_PROAUD_PLUS_AUX              (MM_MEDIAVISION_PROAUDIO_PLUS+7)


// Pro AudioSpectrum 16
#define MM_MEDIAVISION_PROAUDIO_16      0x60
#define MM_PROAUD_16_MIDIOUT            (MM_MEDIAVISION_PROAUDIO_16+1)
#define MM_PROAUD_16_MIDIIN             (MM_MEDIAVISION_PROAUDIO_16+2)
#define MM_PROAUD_16_SYNTH              (MM_MEDIAVISION_PROAUDIO_16+3)
#define MM_PROAUD_16_WAVEOUT            (MM_MEDIAVISION_PROAUDIO_16+4)
#define MM_PROAUD_16_WAVEIN             (MM_MEDIAVISION_PROAUDIO_16+5)
#define MM_PROAUD_16_MIXER              (MM_MEDIAVISION_PROAUDIO_16+6)
#define MM_PROAUD_16_AUX                (MM_MEDIAVISION_PROAUDIO_16+7)


// CDPC
#define MM_MEDIAVISION_CDPC             0x70
#define MM_CDPC_MIDIOUT                 (MM_MEDIAVISION_CDPC+1)
#define MM_CDPC_MIDIIN                  (MM_MEDIAVISION_CDPC+2)
#define MM_CDPC_SYNTH                   (MM_MEDIAVISION_CDPC+3)
#define MM_CDPC_WAVEOUT                 (MM_MEDIAVISION_CDPC+4)
#define MM_CDPC_WAVEIN                  (MM_MEDIAVISION_CDPC+5)
#define MM_CDPC_MIXER                   (MM_MEDIAVISION_CDPC+6)
#define MM_CDPC_AUX                     (MM_MEDIAVISION_CDPC+7)

//
// Opus MV1208 Chipset
//
#define MM_MEDIAVISION_OPUS1208         0x80
#define MM_OPUS401_MIDIOUT              (MM_MEDIAVISION_OPUS1208+1)
#define MM_OPUS401_MIDIIN               (MM_MEDIAVISION_OPUS1208+2)
#define MM_OPUS1208_SYNTH               (MM_MEDIAVISION_OPUS1208+3)
#define MM_OPUS1208_WAVEOUT             (MM_MEDIAVISION_OPUS1208+4)
#define MM_OPUS1208_WAVEIN              (MM_MEDIAVISION_OPUS1208+5)
#define MM_OPUS1208_MIXER               (MM_MEDIAVISION_OPUS1208+6)
#define MM_OPUS1208_AUX                 (MM_MEDIAVISION_OPUS1208+7)


//
// Opus MV1216 Chipset
//
#define MM_MEDIAVISION_OPUS1216 0x90
#define MM_OPUS1216_MIDIOUT             (MM_MEDIAVISION_OPUS1216+1)
#define MM_OPUS1216_MIDIIN              (MM_MEDIAVISION_OPUS1216+2)
#define MM_OPUS1216_SYNTH               (MM_MEDIAVISION_OPUS1216+3)
#define MM_OPUS1216_WAVEOUT             (MM_MEDIAVISION_OPUS1216+4)
#define MM_OPUS1216_WAVEIN              (MM_MEDIAVISION_OPUS1216+5)
#define MM_OPUS1216_MIXER               (MM_MEDIAVISION_OPUS1216+6)
#define MM_OPUS1216_AUX                 (MM_MEDIAVISION_OPUS1216+7)


// Pro Audio Studio 16
#define MM_MEDIAVISION_PROSTUDIO_16     0x60
#define MM_STUDIO_16_MIDIOUT            (MM_MEDIAVISION_PROSTUDIO_16+1)
#define MM_STUDIO_16_MIDIIN             (MM_MEDIAVISION_PROSTUDIO_16+2)
#define MM_STUDIO_16_SYNTH              (MM_MEDIAVISION_PROSTUDIO_16+3)
#define MM_STUDIO_16_WAVEOUT            (MM_MEDIAVISION_PROSTUDIO_16+4)
#define MM_STUDIO_16_WAVEIN             (MM_MEDIAVISION_PROSTUDIO_16+5)
#define MM_STUDIO_16_MIXER              (MM_MEDIAVISION_PROSTUDIO_16+6)
#define MM_STUDIO_16_AUX                (MM_MEDIAVISION_PROSTUDIO_16+7)

/* MM_VOCALTEC Product IDs */
#define MM_VOCALTEC_WAVEOUT     1       /* Vocaltec Waveform output port */
#define MM_VOCALTEC_WAVEIN      2       /* Vocaltec Waveform input port */
			
/* MM_ROLAND Product IDs */
#define MM_ROLAND_MPU401_MIDIOUT    15
#define MM_ROLAND_MPU401_MIDIIN     16
#define MM_ROLAND_SMPU_MIDIOUTA     17
#define MM_ROLAND_SMPU_MIDIOUTB     18
#define MM_ROLAND_SMPU_MIDIINA      19
#define MM_ROLAND_SMPU_MIDIINB      20
#define MM_ROLAND_SC7_MIDIOUT       21
#define MM_ROLAND_SC7_MIDIIN        22
			

/* MM_DIGISPEECH Product IDs */
#define MM_DIGISP_WAVEOUT       1       /* Digispeech Waveform output port */
#define MM_DIGISP_WAVEIN        2       /* Digispeech Waveform input port */
			
/* MM_NEC Product IDs */
			
/* MM_ATI Product IDs */

/* MM_WANGLABS Product IDs */

#define MM_WANGLABS_WAVEIN1             1
/* Input audio wave device present on the CPU board of the following Wang models: Exec 4010, 4030 and 3450; PC 251/25C, PC 461/25S and PC 461/33C */
#define MM_WANGLABS_WAVEOUT1            2
/* Output audio wave device present on the CPU board of the Wang models listed above. */

/* MM_TANDY Product IDs                  */
#define MM_TANDY_VISWAVEIN              1
#define MM_TANDY_VISWAVEOUT             2
#define MM_TANDY_VISBIOSSYNTH           3
#define MM_TANDY_SENS_MMAWAVEIN         4
#define MM_TANDY_SENS_MMAWAVEOUT        5
#define MM_TANDY_SENS_MMAMIDIIN         6
#define MM_TANDY_SENS_MMAMIDIOUT        7
#define MM_TANDY_SENS_VISWAVEOUT        8
#define MM_TANDY_PSSJWAVEIN             9
#define MM_TANDY_PSSJWAVEOUT            10



/* MM_VOYETRA Product IDs */

/* MM_ANTEX Product IDs */

/* MM_ICL_PS Product IDs */

/* MM_INTEL Product IDs */

#define MM_INTELOPD_WAVEIN      1       // HID2 WaveAudio Input driver
#define MM_INTELOPD_WAVEOUT     101     // HID2 WaveAudio Output driver
#define MM_INTELOPD_AUX         401     // HID2 Auxiliary driver (required for mixing functions)

/* MM_GRAVIS Product IDs */

/* MM_VAL Product IDs */

// values not defined by Manufacturer

// #define MM_VAL_MICROKEY_AP_WAVEIN    ???     // Microkey/AudioPort Waveform Input
// #define MM_VAL_MICROKEY_AP_WAVEOUT   ???     // Microkey/AudioPort Waveform Output

/* MM_INTERACTIVE Product IDs */

#define MM_INTERACTIVE_WAVEIN   0x45    // no comment provided by Manufacturer
#define MM_INTERACTIVE_WAVEOUT  0x45    // no comment provided by Manufacturer

/* MM_YAMAHA Product IDs */

#define MM_YAMAHA_GSS_SYNTH     0x01    // Yamaha Gold Sound Standard FM sythesis driver
#define MM_YAMAHA_GSS_WAVEOUT   0x02    // Yamaha Gold Sound Standard wave output driver
#define MM_YAMAHA_GSS_WAVEIN    0x03    // Yamaha Gold Sound Standard wave input driver
#define MM_YAMAHA_GSS_MIDIOUT   0x04    // Yamaha Gold Sound Standard midi output driver
#define MM_YAMAHA_GSS_MIDIIN    0x05    // Yamaha Gold Sound Standard midi input driver
#define MM_YAMAHA_GSS_AUX       0x06    // Yamaha Gold Sound Standard auxillary driver for mixer functions

/* MM_EVEREX Product IDs */

#define MM_EVEREX_CARRIER       0x01    // Everex Carrier SL/25 Notebook

/* MM_ECHO Product IDs */

#define MM_ECHO_SYNTH   0x01    // Echo EuSythesis driver
#define MM_ECHO_WAVEOUT 0x02    // Wave output driver
#define MM_ECHO_WAVEIN  0x03    // Wave input driver
#define MM_ECHO_MIDIOUT 0x04    // MIDI output driver
#define MM_ECHO_MIDIIN  0x05    // MIDI input driver
#define MM_ECHO_AUX     0x06    // auxillary driver for mixer functions


/* MM_SIERRA Product IDs */

#define MM_SIERRA_ARIA_MIDIOUT  0x14    // Sierra Aria MIDI output
#define MM_SIERRA_ARIA_MIDIIN   0x15    // Sierra Aria MIDI input
#define MM_SIERRA_ARIA_SYNTH    0x16    // Sierra Aria Synthesizer
#define MM_SIERRA_ARIA_WAVEOUT  0x17    // Sierra Aria Waveform output
#define MM_SIERRA_ARIA_WAVEIN   0x18    // Sierra Aria Waveform input
#define MM_SIERRA_ARIA_AUX      0x19    // Siarra Aria Auxiliary device

/* MM_CAT Product IDs */

/* MM_APPS Product IDs */

/* MM_DSP_GROUP Product IDs */

#define MM_DSP_GROUP_TRUESPEECH 0x01    // High quality 9.54:1 Speech Compression Vocoder

/* MM_MELABS Product IDs */

#define MM_MELABS_MIDI2GO       0x01    // parellel port MIDI interface

/* MM_COMPUTER_FRIENDS Product IDs */

/* MM_ESS Product IDs */

#define MM_ESS_AMWAVEOUT        0x01    // ESS Audio Magician Waveform Output Port
#define MM_ESS_AMWAVEIN         0x02    // ESS Audio Magician Waveform Input Port
#define MM_ESS_AMAUX            0x03    // ESS Audio Magician Auxiliary Port
#define MM_ESS_AMSYNTH          0x04    // ESS Audio Magician Internal Music Synthesizer Port
#define MM_ESS_AMMIDIOOUT       0x05    // ESS Audio Magician MIDI Output Port
#define MM_ESS_AMMIDIIN         0x06    // ESS Audio Magician MIDI Input Port

/* MM_TRUEVISION Product IDs */
#define MM_TRUEVISION_WAVEIN1   1
#define MM_TRUEVISION_WAVEOUT1  2

/* MM_AZTECH Product ID's */
#define MM_AZETCH_MIDIOUT       3
#define MM_AZETCH_MIDIIN        4
#define MM_AZETCH_WAVEIN        17
#define MM_AZETCH_WAVEOUT       18
#define MM_AZETCH_FMSYNTH       20
#define MM_AZETCH_PRO16_WAVEIN  33
#define MM_AZETCH_PRO16_WAVEOUT 34
#define MM_AZETCH_PRO16_FMSYNTH 38
#define MM_AZETCH_DSP16_WAVEIN  65
#define MM_AZETCH_DSP16_WAVEOUT 66
#define MM_AZETCH_DSP16_FMSYNTH 68
#define MM_AZETCH_DSP16_WAVESYNTH       70
#define MM_AZETCH_AUX_CD        401
#define MM_AZETCH_AUX_LINE      402
#define MM_AZETCH_AUX_MIC       403

/* MM_VIDEOLOGIC Product IDs */
#define MM_VIDEOLOGIC_MSWAVEIN  1
#define MM_VIDEOLOGIC_MSWAVEOUT 2

/* MM_APT Product ID's */
#define MM_APT_ACE100CD         1

/*MM_ICS Product ID's  */
#define MM_ICS_BIZAUDIO_WAVEOUT 1

/* MM_KORG Product ID's */
#define MM_KORG_PCIF_MIDIOUT    1       /* Korg PC I/F Driver */
#define MM_KORG_PCIF_MIDIIN     2       /* Korg PC I/F Driver */

/* MM_METHEUS product ID's */
#define MM_METHEUS_ZIPPER       1

/* MM_WINNOV Products IDs  */
#define MM_WINNOV_CAVIAR_WAVEIN         1
#define MM_WINNOV_CAVIAR_WAVEOUT        2
#define MM_WINNOV_CAVIAR_VIDC           3
#define MM_WINNOV_CAVIAR_CHAMPAGNE      4 /* FOURCC is CHAM */
#define MM_WINNOV_CAVIAR_YUV8           5 /* FOURCC is YUV8 */


#endif

/*////////////////////////////////////////////////////////////////////////// */

/*              INFO LIST CHUNKS (from the Multimedia Programmer's Reference
					plus new ones)
*/
#define RIFFINFO_IARL      mmioFOURCC ('I', 'A', 'R', 'L')     /*Archival location  */
#define RIFFINFO_IART      mmioFOURCC ('I', 'A', 'R', 'T')     /*Artist  */
#define RIFFINFO_ICMS      mmioFOURCC ('I', 'C', 'M', 'S')     /*Commissioned  */
#define RIFFINFO_ICMT      mmioFOURCC ('I', 'C', 'M', 'T')     /*Comments  */
#define RIFFINFO_ICOP      mmioFOURCC ('I', 'C', 'O', 'P')     /*Copyright  */
#define RIFFINFO_ICRD      mmioFOURCC ('I', 'C', 'R', 'D')     /*Creation date of subject  */
#define RIFFINFO_ICRP      mmioFOURCC ('I', 'C', 'R', 'P')     /*Cropped  */
#define RIFFINFO_IDIM      mmioFOURCC ('I', 'D', 'I', 'M')     /*Dimensions  */
#define RIFFINFO_IDPI      mmioFOURCC ('I', 'D', 'P', 'I')     /*Dots per inch  */
#define RIFFINFO_IENG      mmioFOURCC ('I', 'E', 'N', 'G')     /*Engineer  */
#define RIFFINFO_IGNR      mmioFOURCC ('I', 'G', 'N', 'R')     /*Genre  */
#define RIFFINFO_IKEY      mmioFOURCC ('I', 'K', 'E', 'Y')     /*Keywords  */
#define RIFFINFO_ILGT      mmioFOURCC ('I', 'L', 'G', 'T')     /*Lightness settings  */
#define RIFFINFO_IMED      mmioFOURCC ('I', 'M', 'E', 'D')     /*Medium  */
#define RIFFINFO_INAM      mmioFOURCC ('I', 'N', 'A', 'M')     /*Name of subject  */
#define RIFFINFO_IPLT      mmioFOURCC ('I', 'P', 'L', 'T')     /*Palette Settings. No. of colors requested.   */
#define RIFFINFO_IPRD      mmioFOURCC ('I', 'P', 'R', 'D')     /*Product  */
#define RIFFINFO_ISBJ      mmioFOURCC ('I', 'S', 'B', 'J')     /*Subject description  */
#define RIFFINFO_ISFT      mmioFOURCC ('I', 'S', 'F', 'T')     /*Software. Name of package used to create file.  */
#define RIFFINFO_ISHP      mmioFOURCC ('I', 'S', 'H', 'P')     /*Sharpness.  */
#define RIFFINFO_ISRC      mmioFOURCC ('I', 'S', 'R', 'C')     /*Source.   */
#define RIFFINFO_ISRF      mmioFOURCC ('I', 'S', 'R', 'F')     /*Source Form. ie slide, paper  */
#define RIFFINFO_ITCH      mmioFOURCC ('I', 'T', 'C', 'H')     /*Technician who digitized the subject.  */

/* New INFO Chunks as of August 30, 1993: */
#define RIFFINFO_ISMP      mmioFOURCC ('I', 'S', 'M', 'P')     /*SMPTE time code  */
/* ISMP: SMPTE time code of digitization start point expressed as a NULL terminated
		text string "HH:MM:SS:FF". If performing MCI capture in AVICAP, this
		chunk will be automatically set based on the MCI start time.
*/
#define RIFFINFO_IDIT      mmioFOURCC ('I', 'D', 'I', 'T')     /*Digitization Time  */
/* IDIT: "Digitization Time" Specifies the time and date that the digitization commenced.
		The digitization time is contained in an ASCII string which 
		contains exactly 26 characters and is in the format 
		"Wed Jan 02 02:03:55 1990\n\0".
		The ctime(), asctime(), functions can be used to create strings
		in this format. This chunk is automatically added to the capture 
		file based on the current system time at the moment capture is initiated.
*/

/*Template line for new additions*/
/*#define RIFFINFO_I      mmioFOURCC ('I', '', '', '')        */


/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/

#ifndef NONEWWAVE

/* WAVE form wFormatTag IDs */
#define WAVE_FORMAT_UNKNOWN             (0x0000)
#define WAVE_FORMAT_ADPCM               (0x0002)
#define WAVE_FORMAT_IBM_CVSD            (0x0005)
#define WAVE_FORMAT_ALAW                (0x0006)
#define WAVE_FORMAT_MULAW               (0x0007)
#define WAVE_FORMAT_OKI_ADPCM           (0x0010)
#define WAVE_FORMAT_DVI_ADPCM           (0x0011)
#define WAVE_FORMAT_IMA_ADPCM           (WAVE_FORMAT_DVI_ADPCM)
#define WAVE_FORMAT_DIGISTD             (0x0015)
#define WAVE_FORMAT_DIGIFIX             (0x0016)
#define WAVE_FORMAT_YAMAHA_ADPCM        (0x0020)
#define WAVE_FORMAT_SONARC              (0x0021)
#define WAVE_FORMAT_DSPGROUP_TRUESPEECH (0x0022)
#define WAVE_FORMAT_ECHOSC1             (0x0023)
#define WAVE_FORMAT_AUDIOFILE_AF36      (0x0024)
#define WAVE_FORMAT_CREATIVE_ADPCM      (0x0200)
#define WAVE_FORMAT_APTX                (0x0025)
#define WAVE_FORMAT_AUDIOFILE_AF10      (0X0026)
#define WAVE_FORMAT_DOLBY_AC2           (0X0030)
#define WAVE_FORMAT_MEDIASPACE_ADPCM    (0x0012)
#define WAVE_FORMAT_SIERRA_ADPCM        (0x0013)
#define WAVE_FORMAT_G723_ADPCM          (0x0014)
#define WAVE_FORMAT_GSM610              (0x0031)
#define WAVE_FORMAT_G721_ADPCM          (0x0040)




//
//  the WAVE_FORMAT_DEVELOPMENT format tag can be used during the
//  development phase of a new wave format.  Before shipping, you MUST
//  acquire an official format tag from Microsoft.
//
#define WAVE_FORMAT_DEVELOPMENT         (0xFFFF)

#endif /* NONEWWAVE */


#ifndef WAVE_FORMAT_PCM

/* general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT;
typedef WAVEFORMAT       *PWAVEFORMAT;
typedef WAVEFORMAT NEAR *NPWAVEFORMAT;
typedef WAVEFORMAT FAR  *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1

/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT;
typedef PCMWAVEFORMAT       *PPCMWAVEFORMAT;
typedef PCMWAVEFORMAT NEAR *NPPCMWAVEFORMAT;
typedef PCMWAVEFORMAT FAR  *LPPCMWAVEFORMAT;


#endif /* WAVE_FORMAT_PCM */



/* general extended waveform format structure 
   Use this for all NON PCM formats 
   (information common to all formats)
*/
#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_
typedef struct tWAVEFORMATEX
{
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
    WORD    wBitsPerSample;    /* Number of bits per sample of mono data */
    WORD    cbSize;            /* The count in bytes of the size of
				    extra information (after cbSize) */

} WAVEFORMATEX;
typedef WAVEFORMATEX       *PWAVEFORMATEX;
typedef WAVEFORMATEX NEAR *NPWAVEFORMATEX;
typedef WAVEFORMATEX FAR  *LPWAVEFORMATEX;
#endif /* _WAVEFORMATEX_ */


#ifndef NONEWWAVE

/* Define data for MS ADPCM */

typedef struct adpcmcoef_tag {
	short   iCoef1;
	short   iCoef2;
} ADPCMCOEFSET;
typedef ADPCMCOEFSET       *PADPCMCOEFSET;
typedef ADPCMCOEFSET NEAR *NPADPCMCOEFSET;
typedef ADPCMCOEFSET FAR  *LPADPCMCOEFSET;


/*
 *  this pragma disables the warning issued by the Microsoft C compiler
 *  when using a zero size array as place holder when compiling for
 *  C++ or with -W4.
 *
 */
#ifdef _MSC_VER
#pragma warning(disable:4200)
#endif

typedef struct adpcmwaveformat_tag {
	WAVEFORMATEX    wfx;
	WORD            wSamplesPerBlock;
	WORD            wNumCoef;
	ADPCMCOEFSET    aCoef[];
} ADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT       *PADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT NEAR *NPADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT FAR  *LPADPCMWAVEFORMAT;

#ifdef _MSC_VER
#pragma warning(default:4200)
#endif

//
//  Intel's DVI ADPCM structure definitions
//
//      for WAVE_FORMAT_DVI_ADPCM   (0x0011)
//
//

typedef struct dvi_adpcmwaveformat_tag {
	WAVEFORMATEX    wfx;
	WORD            wSamplesPerBlock;
} DVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT       *PDVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT NEAR *NPDVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT FAR  *LPDVIADPCMWAVEFORMAT;


//
//  IMA endorsed ADPCM structure definitions--note that this is exactly
//  the same format as Intel's DVI ADPCM.
//
//      for WAVE_FORMAT_IMA_ADPCM   (0x0011)
//
//

typedef struct ima_adpcmwaveformat_tag {
	WAVEFORMATEX    wfx;
	WORD            wSamplesPerBlock;
} IMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT       *PIMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT NEAR *NPIMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT FAR  *LPIMAADPCMWAVEFORMAT;


//
//  Speech Compression's Sonarc structure definitions
//
//      for WAVE_FORMAT_SONARC   (0x0021)
//
//

typedef struct sonarcwaveformat_tag {
	WAVEFORMATEX    wfx;
	WORD            wCompType;
} SONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT       *PSONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT NEAR *NPSONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT FAR  *LPSONARCWAVEFORMAT;

//
//  DSP Groups's TRUESPEECH structure definitions
//
//      for WAVE_FORMAT_DSPGROUP_TRUESPEECH   (0x0022)
//
//

typedef struct truespeechwaveformat_tag {
	WAVEFORMATEX    wfx;
	WORD            wRevision;
	WORD            nSamplesPerBlock;
	BYTE            abReserved[28];
} TRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT       *PTRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT NEAR *NPTRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT FAR  *LPTRUESPEECHWAVEFORMAT;



//
//  Creative's ADPCM structure definitions
//
//      for WAVE_FORMAT_CREATIVE_ADPCM   (0x0200)
//
//

typedef struct creative_adpcmwaveformat_tag {
	WAVEFORMATEX    wfx;
	WORD            wRevision;
} CREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT       *PCREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT NEAR *NPCREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT FAR  *LPCREATIVEADPCMWAVEFORMAT;

/*
//VideoLogic's Media Space ADPCM Structure definitions
// for  WAVE_FORMAT_MEDIASPACE_ADPCM    (0x0012)
//
//
*/
typedef struct mediaspace_adpcmwaveformat_tag {
	WAVEFORMATEX    wfx;
	WORD    wRevision;
} MEDIASPACEADPCMWAVEFORMAT;
typedef MEDIASPACEADPCMWAVEFORMAT           *PMEDIASPACEADPCMWAVEFORMAT;
typedef MEDIASPACEADPCMWAVEFORMAT NEAR     *NPMEDIASPACEADPCMWAVEFORMAT;
typedef MEDIASPACEADPCMWAVEFORMAT FAR      *LPMEDIASPACEADPCMWAVEFORMAT;

/*
// Sierra Semiconductor ADPCM 
*/
typedef struct sierra_adpcmwaveformat_tag {
	WAVEFORMATEX    wfx;
	WORD            wRevision;
} SIERRAADPCMWAVEFORMAT;
typedef SIERRAADPCMWAVEFORMAT           *PSIERRAADPCMWAVEFORMAT;
typedef SIERRAADPCMWAVEFORMAT NEAR     *NPSIERRAADPCMWAVEFORMAT;
typedef SIERRAADPCMWAVEFORMAT FAR      *LPSIERRAADPCMWAVEFORMAT;

/* Dolby's AC-2 wave format structure definition */
typedef struct dolbyac2waveformat_tag {
	WAVEFORMATEX    wfx;
	WORD            nAuxBitsCode;
} DOLBYAC2WAVEFORMAT;







//==========================================================================;
//
//  ACM Wave Filters
//
//
//==========================================================================;

#ifndef _ACM_WAVEFILTER
#define _ACM_WAVEFILTER
    
#define WAVE_FILTER_UNKNOWN	    0x0000
#define WAVE_FILTER_DEVELOPMENT	   (0xFFFF)
            
typedef struct wavefilter_tag {
    DWORD   cbStruct;           /* Size of the filter in bytes */
    DWORD   dwFilterTag;        /* fitler type */
    DWORD   fdwFilter;          /* Flags for the filter (Universal Dfns) */
    DWORD   dwReserved[5];      /* Reserved for system use */
} WAVEFILTER;
typedef WAVEFILTER       *PWAVEFILTER;
typedef WAVEFILTER NEAR *NPWAVEFILTER;
typedef WAVEFILTER FAR  *LPWAVEFILTER;

#endif  /* _ACM_WAVEFILTER */


#ifndef WAVE_FILTER_VOLUME
#define WAVE_FILTER_VOLUME      0x0001


typedef struct wavefilter_volume_tag {
        WAVEFILTER      wfltr;
        DWORD           dwVolume;
} VOLUMEWAVEFILTER;
typedef VOLUMEWAVEFILTER       *PVOLUMEWAVEFILTER;
typedef VOLUMEWAVEFILTER NEAR *NPVOLUMEWAVEFILTER;
typedef VOLUMEWAVEFILTER FAR  *LPVOLUMEWAVEFILTER;

#endif  /* WAVE_FILTER_VOLUME */

#ifndef WAVE_FILTER_ECHO
#define WAVE_FILTER_ECHO        0x0002


typedef struct wavefilter_echo_tag {
        WAVEFILTER      wfltr;
        DWORD           dwVolume;
        DWORD           dwDelay;
} ECHOWAVEFILTER;
typedef ECHOWAVEFILTER       *PECHOWAVEFILTER;
typedef ECHOWAVEFILTER NEAR *NPECHOWAVEFILTER;
typedef ECHOWAVEFILTER FAR  *LPECHOWAVEFILTER;

#endif  /* WAVEFILTER_ECHO */
    



/*//////////////////////////////////////////////////////////////////////////
//
// New RIFF WAVE Chunks
//
*/

#define RIFFWAVE_inst   mmioFOURCC('i','n','s','t')

struct tag_s_RIFFWAVE_inst {
    BYTE    bUnshiftedNote;
    char    chFineTune;
    char    chGain;
    BYTE    bLowNote;
    BYTE    bHighNote;
    BYTE    bLowVelocity;
    BYTE    bHighVelocity;
};

typedef struct tag_s_RIFFWAVE_INST s_RIFFWAVE_inst;

#endif

/*//////////////////////////////////////////////////////////////////////////
//
// New RIFF Forms
//
*/

#ifndef NONEWRIFF

/* RIFF AVI */

//
// AVI file format is specified in a seperate file (AVIFMT.H),
// which is available from the sources listed in MSFTMM
//

/* RIFF CPPO */

#define RIFFCPPO        mmioFOURCC('C','P','P','O')

#define RIFFCPPO_objr   mmioFOURCC('o','b','j','r')
#define RIFFCPPO_obji   mmioFOURCC('o','b','j','i')

#define RIFFCPPO_clsr   mmioFOURCC('c','l','s','r')
#define RIFFCPPO_clsi   mmioFOURCC('c','l','s','i')

#define RIFFCPPO_mbr    mmioFOURCC('m','b','r',' ')

#define RIFFCPPO_char   mmioFOURCC('c','h','a','r')


#define RIFFCPPO_byte   mmioFOURCC('b','y','t','e')
#define RIFFCPPO_int    mmioFOURCC('i','n','t',' ')
#define RIFFCPPO_word   mmioFOURCC('w','o','r','d')
#define RIFFCPPO_long   mmioFOURCC('l','o','n','g')
#define RIFFCPPO_dwrd   mmioFOURCC('d','w','r','d')
#define RIFFCPPO_flt    mmioFOURCC('f','l','t',' ')
#define RIFFCPPO_dbl    mmioFOURCC('d','b','l',' ')
#define RIFFCPPO_str    mmioFOURCC('s','t','r',' ')


#endif

/*
//////////////////////////////////////////////////////////////////////////
//
// DIB Compression Defines
//
*/

#ifndef BI_BITFIELDS
#define BI_BITFIELDS    3
#endif

#ifndef QUERYDIBSUPPORT

#define QUERYDIBSUPPORT 3073
#define QDI_SETDIBITS   0x0001
#define QDI_GETDIBITS   0x0002
#define QDI_DIBTOSCREEN 0x0004
#define QDI_STRETCHDIB  0x0008


#endif

#ifndef NOBITMAP
/* Structure definitions */

typedef struct tagEXBMINFOHEADER {
	BITMAPINFOHEADER    bmi;
	/* extended BITMAPINFOHEADER fields */
	DWORD   biExtDataOffset;
	
	/* Other stuff will go here */

	/* ... */

	/* Format-specific information */
	/* biExtDataOffset points here */
	
} EXBMINFOHEADER;

#endif	//NOBITMAP

/* New DIB Compression Defines */

#define BICOMP_IBMULTIMOTION    mmioFOURCC('U', 'L', 'T', 'I')
#define BICOMP_IBMPHOTOMOTION   mmioFOURCC('P', 'H', 'M', 'O')
#define BICOMP_CREATIVEYUV      mmioFOURCC('c', 'y', 'u', 'v')

#ifndef NOJPEGDIB

/* New DIB Compression Defines */
#define JPEG_DIB        mmioFOURCC('J','P','E','G')    /* Still image JPEG DIB biCompression */
#define MJPG_DIB        mmioFOURCC('M','J','P','G')    /* Motion JPEG DIB biCompression     */

/* JPEGProcess Definitions */
#define JPEG_PROCESS_BASELINE           0       /* Baseline DCT */

/* AVI File format extensions */
#define AVIIF_CONTROLFRAME              0x00000200L     /* This is a control frame */

    /* JIF Marker byte pairs in JPEG Interchange Format sequence */
#define JIFMK_SOF0    0xFFC0   /* SOF Huff  - Baseline DCT*/
#define JIFMK_SOF1    0xFFC1   /* SOF Huff  - Extended sequential DCT*/
#define JIFMK_SOF2    0xFFC2   /* SOF Huff  - Progressive DCT*/
#define JIFMK_SOF3    0xFFC3   /* SOF Huff  - Spatial (sequential) lossless*/
#define JIFMK_SOF5    0xFFC5   /* SOF Huff  - Differential sequential DCT*/
#define JIFMK_SOF6    0xFFC6   /* SOF Huff  - Differential progressive DCT*/
#define JIFMK_SOF7    0xFFC7   /* SOF Huff  - Differential spatial*/
#define JIFMK_JPG     0xFFC8   /* SOF Arith - Reserved for JPEG extensions*/
#define JIFMK_SOF9    0xFFC9   /* SOF Arith - Extended sequential DCT*/
#define JIFMK_SOF10   0xFFCA   /* SOF Arith - Progressive DCT*/
#define JIFMK_SOF11   0xFFCB   /* SOF Arith - Spatial (sequential) lossless*/
#define JIFMK_SOF13   0xFFCD   /* SOF Arith - Differential sequential DCT*/
#define JIFMK_SOF14   0xFFCE   /* SOF Arith - Differential progressive DCT*/
#define JIFMK_SOF15   0xFFCF   /* SOF Arith - Differential spatial*/
#define JIFMK_DHT     0xFFC4   /* Define Huffman Table(s) */
#define JIFMK_DAC     0xFFCC   /* Define Arithmetic coding conditioning(s) */
#define JIFMK_RST0    0xFFD0   /* Restart with modulo 8 count 0 */
#define JIFMK_RST1    0xFFD1   /* Restart with modulo 8 count 1 */
#define JIFMK_RST2    0xFFD2   /* Restart with modulo 8 count 2 */
#define JIFMK_RST3    0xFFD3   /* Restart with modulo 8 count 3 */
#define JIFMK_RST4    0xFFD4   /* Restart with modulo 8 count 4 */
#define JIFMK_RST5    0xFFD5   /* Restart with modulo 8 count 5 */
#define JIFMK_RST6    0xFFD6   /* Restart with modulo 8 count 6 */
#define JIFMK_RST7    0xFFD7   /* Restart with modulo 8 count 7 */
#define JIFMK_SOI     0xFFD8   /* Start of Image */
#define JIFMK_EOI     0xFFD9   /* End of Image */
#define JIFMK_SOS     0xFFDA   /* Start of Scan */
#define JIFMK_DQT     0xFFDB   /* Define quantization Table(s) */
#define JIFMK_DNL     0xFFDC   /* Define Number of Lines */
#define JIFMK_DRI     0xFFDD   /* Define Restart Interval */
#define JIFMK_DHP     0xFFDE   /* Define Hierarchical progression */
#define JIFMK_EXP     0xFFDF   /* Expand Reference Component(s) */
#define JIFMK_APP0    0xFFE0   /* Application Field 0*/
#define JIFMK_APP1    0xFFE1   /* Application Field 1*/
#define JIFMK_APP2    0xFFE2   /* Application Field 2*/
#define JIFMK_APP3    0xFFE3   /* Application Field 3*/
#define JIFMK_APP4    0xFFE4   /* Application Field 4*/
#define JIFMK_APP5    0xFFE5   /* Application Field 5*/
#define JIFMK_APP6    0xFFE6   /* Application Field 6*/
#define JIFMK_APP7    0xFFE7   /* Application Field 7*/
#define JIFMK_JPG0    0xFFF0   /* Reserved for JPEG extensions */
#define JIFMK_JPG1    0xFFF1   /* Reserved for JPEG extensions */
#define JIFMK_JPG2    0xFFF2   /* Reserved for JPEG extensions */
#define JIFMK_JPG3    0xFFF3   /* Reserved for JPEG extensions */
#define JIFMK_JPG4    0xFFF4   /* Reserved for JPEG extensions */
#define JIFMK_JPG5    0xFFF5   /* Reserved for JPEG extensions */
#define JIFMK_JPG6    0xFFF6   /* Reserved for JPEG extensions */
#define JIFMK_JPG7    0xFFF7   /* Reserved for JPEG extensions */
#define JIFMK_JPG8    0xFFF8   /* Reserved for JPEG extensions */
#define JIFMK_JPG9    0xFFF9   /* Reserved for JPEG extensions */
#define JIFMK_JPG10   0xFFFA   /* Reserved for JPEG extensions */
#define JIFMK_JPG11   0xFFFB   /* Reserved for JPEG extensions */
#define JIFMK_JPG12   0xFFFC   /* Reserved for JPEG extensions */
#define JIFMK_JPG13   0xFFFD   /* Reserved for JPEG extensions */
#define JIFMK_COM     0xFFFE   /* Comment */
#define JIFMK_TEM     0xFF01   /* for temp private use arith code */
#define JIFMK_RES     0xFF02   /* Reserved */
#define JIFMK_00      0xFF00   /* Zero stuffed byte - entropy data */
#define JIFMK_FF      0xFFFF   /* Fill byte */

 
/* JPEGColorSpaceID Definitions */
#define JPEG_Y          1       /* Y only component of YCbCr */
#define JPEG_YCbCr      2       /* YCbCr as define by CCIR 601 */
#define JPEG_RGB        3       /* 3 component RGB */

/* Structure definitions */

typedef struct tagJPEGINFOHEADER {
    /* compression-specific fields */
    /* these fields are defined for 'JPEG' and 'MJPG' */
    DWORD       JPEGSize;
    DWORD       JPEGProcess;

    /* Process specific fields */
    DWORD       JPEGColorSpaceID;
    DWORD       JPEGBitsPerSample;
    DWORD       JPEGHSubSampling;
    DWORD       JPEGVSubSampling;
} JPEGINFOHEADER;


#ifdef MJPGDHTSEG_STORAGE

/* Default DHT Segment */

MJPGHDTSEG_STORAGE BYTE MJPGDHTSeg[0x1A0] = {
 /* JPEG DHT Segment for YCrCb omitted from MJPG data */
0xFF,0xC4,0xA2,0x01,
0x00,0x00,0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x10,0x00,0x03,0x01,0x01,0x01,0x01, 
0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07, 
0x08,0x09,0x0A,0x0B,0x01,0x00,0x02,0x01,0x03,0x03,0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00, 
0x00,0x01,0x7D,0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61, 
0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,0x52,0xD1,0xF0,0x24, 
0x33,0x62,0x72,0x82,0x09,0x0A,0x16,0x17,0x18,0x19,0x1A,0x25,0x26,0x27,0x28,0x29,0x2A,0x34, 
0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56, 
0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78, 
0x79,0x7A,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99, 
0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9, 
0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9, 
0xDA,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7, 
0xF8,0xF9,0xFA,0x11,0x00,0x02,0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,0x04,0x04,0x00,0x01, 
0x02,0x77,0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71, 
0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xA1,0xB1,0xC1,0x09,0x23,0x33,0x52,0xF0,0x15,0x62, 
0x72,0xD1,0x0A,0x16,0x24,0x34,0xE1,0x25,0xF1,0x17,0x18,0x19,0x1A,0x26,0x27,0x28,0x29,0x2A, 
0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56, 
0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78, 
0x79,0x7A,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98, 
0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8, 
0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8, 
0xD9,0xDA,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8, 
0xF9,0xFA
};

/* End DHT default */
#endif

/* End JPEG */
#endif

/*//////////////////////////////////////////////////////////////////////////
//
// Defined IC types
*/

#ifndef NONEWIC

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#endif
/*
//   Misc. FOURCC registration
*/

/* Sierra Semiconductor: RDSP- Confidential RIFF file format  
//       for the storage and downloading of DSP
//       code for Audio and communications devices. 
*/
#define FOURCC_RDSP mmioFOURCC('R', 'D', 'S', 'P')



#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_MMREG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\mmsystem.inc ===
;==========================================================================;
;  mmsystem.h -- Include file for Multimedia API's
;  Version 4.00
;  Copyright (C) 1992-1994 Microsoft Corporation.  All Rights Reserved.
;--------------------------------------------------------------------------;
;  Define:         Prevent inclusion of:
;  --------------  --------------------------------------------------------
;  MMNODRV         Installable driver support
;  MMNOSOUND       Sound support
;  MMNOWAVE        Waveform support
;  MMNOMIDI        MIDI support
;  MMNOAUX         Auxiliary audio support
;  MMNOMIXER       Mixer support
;  MMNOTIMER       Timer support
;  MMNOJOY         Joystick support
;  MMNOMCI         MCI support
;  MMNOMMIO        Multimedia file I/O support
;  MMNOMMSYSTEM    General MMSYSTEM functions
;==========================================================================;
; general constants
MAXPNAMELEN	EQU	32     ; max product name length (including NULL)
MAXERRORLENGTH	EQU	256    ; max error text length (including NULL)

MMTIME	STRUC
mmt_wType	DW	?
mmt_TimeUnion	DD	?
MMTIME	ENDS

SMPTE	STRUC
smpte_hour	DB	?
smpte_min	DB	?
smpte_sec	DB	?
smpte_frame	DB	?
smpte_fps	DB	?
smpte_reserved	DB	?
SMPTE	ENDS
; types for wType field in MMTIME struct
TIME_MS	EQU	0001H  ; time in milliseconds
TIME_SAMPLES	EQU	0002H  ; number of wave samples
TIME_BYTES	EQU	0004H  ; current byte offset
TIME_SMPTE	EQU	0008H  ; SMPTE time
TIME_MIDI	EQU	0010H  ; MIDI time
TIME_TICKS	EQU	0020H  ; Ticks within MIDI stream
MM_JOY1MOVE	EQU	3A0H           ; joystick
MM_JOY2MOVE	EQU	3A1H
MM_JOY1ZMOVE	EQU	3A2H
MM_JOY2ZMOVE	EQU	3A3H
MM_JOY1BUTTONDOWN	EQU	3B5H
MM_JOY2BUTTONDOWN	EQU	3B6H
MM_JOY1BUTTONUP	EQU	3B7H
MM_JOY2BUTTONUP	EQU	3B8H
MM_MCINOTIFY	EQU	3B9H           ; MCI
MM_WOM_OPEN	EQU	3BBH           ; waveform output
MM_WOM_CLOSE	EQU	3BCH
MM_WOM_DONE	EQU	3BDH
MM_WIM_OPEN	EQU	3BEH           ; waveform input
MM_WIM_CLOSE	EQU	3BFH
MM_WIM_DATA	EQU	3C0H
MM_MIM_OPEN	EQU	3C1H           ; MIDI input
MM_MIM_CLOSE	EQU	3C2H
MM_MIM_DATA	EQU	3C3H
MM_MIM_LONGDATA	EQU	3C4H
MM_MIM_ERROR	EQU	3C5H
MM_MIM_LONGERROR	EQU	3C6H
MM_MOM_OPEN	EQU	3C7H           ; MIDI output
MM_MOM_CLOSE	EQU	3C8H
MM_MOM_DONE	EQU	3C9H
MMSYSERR_BASE	EQU	0
WAVERR_BASE	EQU	32
MIDIERR_BASE	EQU	64
TIMERR_BASE	EQU	96
JOYERR_BASE	EQU	160
MCIERR_BASE	EQU	256
MIXERR_BASE	EQU	1024
MCI_STRING_OFFSET	EQU	512
MCI_VD_OFFSET	EQU	1024
MCI_CD_OFFSET	EQU	1088
MCI_WAVE_OFFSET	EQU	1152
MCI_SEQ_OFFSET	EQU	1216
;***************************************************************************
;	General error return values
;*************************************************************************
; general error return values
MMSYSERR_NOERROR	EQU	0                    ; no error
MMSYSERR_ERROR	EQU	(MMSYSERR_BASE+1)  ; unspecified error
MMSYSERR_BADDEVICEID	EQU	(MMSYSERR_BASE+2)  ; device ID out of range
MMSYSERR_NOTENABLED	EQU	(MMSYSERR_BASE+3)  ; driver failed enable
MMSYSERR_ALLOCATED	EQU	(MMSYSERR_BASE+4)  ; device already allocated
MMSYSERR_INVALHANDLE	EQU	(MMSYSERR_BASE+5)  ; device handle is invalid
MMSYSERR_NODRIVER	EQU	(MMSYSERR_BASE+6)  ; no device driver present
MMSYSERR_NOMEM	EQU	(MMSYSERR_BASE+7)  ; memory allocation error
MMSYSERR_NOTSUPPORTED	EQU	(MMSYSERR_BASE+8)  ; function isn't supported
MMSYSERR_BADERRNUM	EQU	(MMSYSERR_BASE+9)  ; error value out of range
MMSYSERR_INVALFLAG	EQU	(MMSYSERR_BASE+10) ; invalid flag passed
MMSYSERR_INVALPARAM	EQU	(MMSYSERR_BASE+11) ; invalid parameter passed
MMSYSERR_HANDLEBUSY	EQU	(MMSYSERR_BASE+12) ; handle being used
						   ; simultaneously on another
						   ; thread (eg callback)
MMSYSERR_INVALIDALIAS	EQU	(MMSYSERR_BASE+13) ; specified alias not found
MMSYSERR_BADDB	EQU	(MMSYSERR_BASE+14) ; bad registry database
MMSYSERR_KEYNOTFOUND	EQU	(MMSYSERR_BASE+15) ; registry key not found
MMSYSERR_READERROR	EQU	(MMSYSERR_BASE+16) ; registry read error
MMSYSERR_WRITEERROR	EQU	(MMSYSERR_BASE+17) ; registry write error
MMSYSERR_DELETEERROR	EQU	(MMSYSERR_BASE+18) ; registry delete error
MMSYSERR_VALNOTFOUND	EQU	(MMSYSERR_BASE+19) ; registry value not found
MMSYSERR_LASTERROR	EQU	(MMSYSERR_BASE+19) ; last error in range
ifndef MMNODRV
ifndef DRV_RESERVED
DRV_RESERVED	EQU	0800H
DRV_USER	EQU	4000H
endif
DRV_MCI_FIRST	EQU	DRV_RESERVED
DRV_MCI_LAST	EQU	(DRV_RESERVED+0FFFH)
endif  ; ifndef MMNODRV
;***************************************************************************
;	  Driver callback support
;*************************************************************************
; flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and
; midiOutOpen() to specify the type of the dwCallback parameter.
CALLBACK_TYPEMASK	EQU	00070000H    ; callback type mask
CALLBACK_NULL	EQU	00000000H    ; no callback
CALLBACK_WINDOW	EQU	00010000H    ; dwCallback is a HWND
CALLBACK_TASK	EQU	00020000H    ; dwCallback is a HTASK
CALLBACK_FUNCTION	EQU	00030000H    ; dwCallback is a FARPROC
ifdef WIN32
CALLBACK_THREAD	EQU	(CALLBACK_TASK) ; thread ID replaces 16 bit task
CALLBACK_EVENT	EQU	00050000H    ; dwCallback is an EVENT
endif
SND_SYNC	EQU	0000H  ; play synchronously (default)
SND_ASYNC	EQU	0001H  ; play asynchronously
SND_NODEFAULT	EQU	0002H  ; silence (!default) if sound not found
SND_MEMORY	EQU	0004H  ; pszSound points to a memory file
SND_LOOP	EQU	0008H  ; loop the sound until next sndPlaySound
SND_NOSTOP	EQU	0010H  ; don't stop any currently playing sound
ifndef MMNOWAVE
;***************************************************************************
;	Waveform audio support
;*************************************************************************
; waveform audio error return values
WAVERR_BADFORMAT	EQU	(WAVERR_BASE+0)    ; unsupported wave format
WAVERR_STILLPLAYING	EQU	(WAVERR_BASE+1)    ; still something playing
WAVERR_UNPREPARED	EQU	(WAVERR_BASE+2)    ; header not prepared
WAVERR_SYNC	EQU	(WAVERR_BASE+3)    ; device is synchronous
WAVERR_LASTERROR	EQU	(WAVERR_BASE+3)    ; last error in range
; wave callback messages
WOM_OPEN	EQU	MM_WOM_OPEN
WOM_CLOSE	EQU	MM_WOM_CLOSE
WOM_DONE	EQU	MM_WOM_DONE
WIM_OPEN	EQU	MM_WIM_OPEN
WIM_CLOSE	EQU	MM_WIM_CLOSE
WIM_DATA	EQU	MM_WIM_DATA
; device ID for wave device mapper
WAVE_MAPPER	EQU	(-1)
; flags for dwFlags parameter in waveOutOpen() and waveInOpen()
WAVE_FORMAT_QUERY	EQU	0001H
WAVE_ALLOWSYNC	EQU	0002H

WAVEHDR	STRUC
lpWaveData	DD	?
dwWaveBufferLength	DD	?
dwWaveBytesRecorded	DD	?
dwWaveUser	DD	?
dwWaveFlags	DD	?
dwWaveLoops	DD	?
lpWaveNext	DD	?
Wavereserved	DD	?
WAVEHDR	ENDS
; flags for dwFlags field of WAVEHDR
WHDR_DONE	EQU	00000001H  ; done bit
WHDR_PREPARED	EQU	00000002H  ; set if this header has been prepared
WHDR_BEGINLOOP	EQU	00000004H  ; loop start block
WHDR_ENDLOOP	EQU	00000008H  ; loop end block
WHDR_INQUEUE	EQU	00000010H  ; reserved for driver

WAVEOUTCAPS	STRUC
woc_wMid	DW	?
woc_wPid	DW	?
woc_vDriverVersion	DW	?
woc_szPname	DB	MAXPNAMELEN DUP (?)
woc_dwFormats	DD	?
woc_wChannels	DW	?
woc_dwSupport	DD	?
WAVEOUTCAPS	ENDS
; flags for dwSupport field of WAVEOUTCAPS
WAVECAPS_PITCH	EQU	0001H   ; supports pitch control
WAVECAPS_PLAYBACKRATE	EQU	0002H   ; supports playback rate control
WAVECAPS_VOLUME	EQU	0004H   ; supports volume control
WAVECAPS_LRVOLUME	EQU	0008H   ; separate left-right volume control
WAVECAPS_SYNC	EQU	0010H

WAVEINCAPS	STRUC
wic_wMid	DW	?
wic_wPid	DW	?
wic_vDriverVersion	DW	?
wic_szPname	DB	MAXPNAMELEN DUP (?)
wic_dwFormats	DD	?
wic_wChannels	DW	?
WAVEINCAPS	ENDS
; defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
WAVE_INVALIDFORMAT	EQU	00000000H       ; invalid format
WAVE_FORMAT_1M08	EQU	00000001H       ; 11.025 kHz, Mono,   8-bit
WAVE_FORMAT_1S08	EQU	00000002H       ; 11.025 kHz, Stereo, 8-bit
WAVE_FORMAT_1M16	EQU	00000004H       ; 11.025 kHz, Mono,   16-bit
WAVE_FORMAT_1S16	EQU	00000008H       ; 11.025 kHz, Stereo, 16-bit
WAVE_FORMAT_2M08	EQU	00000010H       ; 22.05  kHz, Mono,   8-bit
WAVE_FORMAT_2S08	EQU	00000020H       ; 22.05  kHz, Stereo, 8-bit
WAVE_FORMAT_2M16	EQU	00000040H       ; 22.05  kHz, Mono,   16-bit
WAVE_FORMAT_2S16	EQU	00000080H       ; 22.05  kHz, Stereo, 16-bit
WAVE_FORMAT_4M08	EQU	00000100H       ; 44.1   kHz, Mono,   8-bit
WAVE_FORMAT_4S08	EQU	00000200H       ; 44.1   kHz, Stereo, 8-bit
WAVE_FORMAT_4M16	EQU	00000400H       ; 44.1   kHz, Mono,   16-bit
WAVE_FORMAT_4S16	EQU	00000800H       ; 44.1   kHz, Stereo, 16-bit

WAVEFORMAT	STRUC
wfmt_wFormatTag	DW	?
wfmt_nChannels	DW	?
wfmt_nSamplesPerSec	DD	?
wfmt_nAvgBytesPerSec	DD	?
wfmt_nBlockAlign	DW	?
WAVEFORMAT	ENDS
; flags for wFormatTag field of WAVEFORMAT
WAVE_FORMAT_PCM	EQU	1

PCMWAVEFORMAT	STRUC
pcm_wf	DB	SIZE WAVEFORMAT DUP (?)
pcm_wBitsPerSample	DW	?
PCMWAVEFORMAT	ENDS
endif  ; ifndef MMNOWAVE
ifndef MMNOMIDI
;***************************************************************************
;	    MIDI audio support
;*************************************************************************
; MIDI error return values
MIDIERR_UNPREPARED	EQU	(MIDIERR_BASE+0)   ; header not prepared
MIDIERR_STILLPLAYING	EQU	(MIDIERR_BASE+1)   ; still something playing
MIDIERR_NOMAP	EQU	(MIDIERR_BASE+2)   ; no configured instruments
MIDIERR_NOTREADY	EQU	(MIDIERR_BASE+3)   ; hardware is still busy
MIDIERR_NODEVICE	EQU	(MIDIERR_BASE+4)   ; port no longer connected
MIDIERR_INVALIDSETUP	EQU	(MIDIERR_BASE+5)   ; invalid MIF
MIDIERR_BADOPENMODE	EQU	(MIDIERR_BASE+6)   ; operation unsupported w/ open mode
MIDIERR_LASTERROR	EQU	(MIDIERR_BASE+6)   ; last error in range
MIDIPATCHSIZE	EQU	128
; MIDI callback messages
MIM_OPEN	EQU	MM_MIM_OPEN
MIM_CLOSE	EQU	MM_MIM_CLOSE
MIM_DATA	EQU	MM_MIM_DATA
MIM_LONGDATA	EQU	MM_MIM_LONGDATA
MIM_ERROR	EQU	MM_MIM_ERROR
MIM_LONGERROR	EQU	MM_MIM_LONGERROR
MOM_OPEN	EQU	MM_MOM_OPEN
MOM_CLOSE	EQU	MM_MOM_CLOSE
MOM_DONE	EQU	MM_MOM_DONE
; device ID for MIDI mapper
MIDIMAPPER	EQU	(-1)
MIDI_MAPPER	EQU	(-1)
MIDI_CACHE_ALL	EQU	1
MIDI_CACHE_BESTFIT	EQU	2
MIDI_CACHE_QUERY	EQU	3
MIDI_UNCACHE	EQU	4

MIDIOUTCAPS	STRUC
moc_wMid	DW	?
moc_wPid	DW	?
moc_vDriverVersion	DW	?
moc_szPname	DB	MAXPNAMELEN DUP (?)
moc_wTechnology	DW	?
moc_wVoices	DW	?
moc_wNotes	DW	?
moc_wChannelMask	DW	?
moc_dwSupport	DD	?
MIDIOUTCAPS	ENDS
; flags for wTechnology field of MIDIOUTCAPS structure
MOD_MIDIPORT	EQU	1  ; output port
MOD_SYNTH	EQU	2  ; generic internal synth
MOD_SQSYNTH	EQU	3  ; square wave internal synth
MOD_FMSYNTH	EQU	4  ; FM internal synth
MOD_MAPPER	EQU	5  ; MIDI mapper
; flags for dwSupport field of MIDIOUTCAPS structure
MIDICAPS_VOLUME	EQU	0001H  ; supports volume control
MIDICAPS_LRVOLUME	EQU	0002H  ; separate left-right volume control
MIDICAPS_CACHE	EQU	0004H

MIDIINCAPS	STRUC
mic_wMid	DW	?
mic_wPid	DW	?
mic_vDriverVersion	DW	?
mic_szPname	DB	MAXPNAMELEN DUP (?)
MIDIINCAPS	ENDS

MIDIHDR	STRUC
lpMidiData	DD	?
dwMidiBufferLength	DD	?
dwMidiBytesRecorded	DD	?
dwMidiUser	DD	?
dwMidiFlags	DD	?
lpMidiNext	DD	?
Midireserved	DD	?
MIDIHDR	ENDS
; flags for dwFlags field of MIDIHDR structure
MHDR_DONE	EQU	00000001H       ; done bit
MHDR_PREPARED	EQU	00000002H       ; set if header prepared
MHDR_INQUEUE	EQU	00000004H       ; reserved for driver
MHDR_ISPOLY	EQU	00000008H       ; Buffer is polymsg buffer
MHDR_CHANIGNORE	EQU	0FFFF0000H       ; Ignore channels 1-16
endif  ; ifndef MMNOMIDI
ifndef MMNOAUX
;***************************************************************************
;	Auxiliary audio support
;*************************************************************************
; device ID for aux device mapper
AUX_MAPPER	EQU	(-1)

AUXCAPS	STRUC
acaps_wMid	DW	?
acaps_wPid	DW	?
acaps_vDriverVersion	DW	?
acaps_szPname	DB	MAXPNAMELEN DUP (?)
acaps_wTechnology	DW	?
acaps_dwSupport	DD	?
AUXCAPS	ENDS
; flags for wTechnology field in AUXCAPS structure
AUXCAPS_CDAUDIO	EQU	1       ; audio from internal CD-ROM drive
AUXCAPS_AUXIN	EQU	2       ; audio from auxiliary input jacks
; flags for dwSupport field in AUXCAPS structure
AUXCAPS_VOLUME	EQU	0001H  ; supports volume control
AUXCAPS_LRVOLUME	EQU	0002H  ; separate left-right volume control
endif  ; ifndef MMNOAUX
ifndef MMNOTIMER
;***************************************************************************
;	    Timer support
;*************************************************************************
; timer error return values
TIMERR_NOERROR	EQU	(0)                  ; no error
TIMERR_NOCANDO	EQU	(TIMERR_BASE+1)      ; request not completed
TIMERR_STRUCT	EQU	(TIMERR_BASE+33)     ; time struct size
; flags for wFlags parameter of timeSetEvent() function
TIME_ONESHOT	EQU	00H   ; program timer for single event
TIME_PERIODIC	EQU	01H   ; program for continuous periodic event

TIMECAPS	STRUC
tc_wPeriodMin	DW	?
tc_wPeriodMax	DW	?
TIMECAPS	ENDS
endif  ; ifndef MMNOTIMER
ifndef MMNOJOY
;***************************************************************************
;	    Joystick support
;*************************************************************************
; joystick error return values
JOYERR_NOERROR	EQU	(0)                  ; no error
JOYERR_PARMS	EQU	(JOYERR_BASE+5)      ; bad parameters
JOYERR_NOCANDO	EQU	(JOYERR_BASE+6)      ; request not completed
JOYERR_UNPLUGGED	EQU	(JOYERR_BASE+7)      ; joystick is unplugged
; constants used with JOYINFO structure and MM_JOY* messages
JOY_BUTTON1	EQU	0001H
JOY_BUTTON2	EQU	0002H
JOY_BUTTON3	EQU	0004H
JOY_BUTTON4	EQU	0008H
JOY_BUTTON1CHG	EQU	0100H
JOY_BUTTON2CHG	EQU	0200H
JOY_BUTTON3CHG	EQU	0400H
JOY_BUTTON4CHG	EQU	0800H
; joystick ID constants
JOYSTICKID1	EQU	0
JOYSTICKID2	EQU	1

JOYCAPS	STRUC
jcaps_wMid	DW	?
jcaps_wPid	DW	?
jcaps_szPname	DB	MAXPNAMELEN DUP (?)
jcaps_wXmin	DW	?
jcaps_wXmax	DW	?
jcaps_wYmin	DW	?
jcaps_wYmax	DW	?
jcaps_wZmin	DW	?
jcaps_wZmax	DW	?
jcaps_wNumButtons	DW	?
jcaps_wPeriodMin	DW	?
jcaps_wPeriodMax	DW	?
JOYCAPS	ENDS

JOYINFO	STRUC
jinfo_wXpos	DW	?
jinfo_wYpos	DW	?
jinfo_wZpos	DW	?
jinfo_wButtons	DW	?
JOYINFO	ENDS
endif  ; ifndef MMNOJOY
ifndef MMNOMMIO
;***************************************************************************
;	Multimedia File I/O support
;*************************************************************************
; MMIO error return values
MMIOERR_BASE	EQU	256
MMIOERR_FILENOTFOUND	EQU	(MMIOERR_BASE+1)  ; file not found
MMIOERR_OUTOFMEMORY	EQU	(MMIOERR_BASE+2)  ; out of memory
MMIOERR_CANNOTOPEN	EQU	(MMIOERR_BASE+3)  ; cannot open
MMIOERR_CANNOTCLOSE	EQU	(MMIOERR_BASE+4)  ; cannot close
MMIOERR_CANNOTREAD	EQU	(MMIOERR_BASE+5)  ; cannot read
MMIOERR_CANNOTWRITE	EQU	(MMIOERR_BASE+6)  ; cannot write
MMIOERR_CANNOTSEEK	EQU	(MMIOERR_BASE+7)  ; cannot seek
MMIOERR_CANNOTEXPAND	EQU	(MMIOERR_BASE+8)  ; cannot expand file
MMIOERR_CHUNKNOTFOUND	EQU	(MMIOERR_BASE+9)  ; chunk not found
MMIOERR_UNBUFFERED	EQU	(MMIOERR_BASE+10) ;
MMIOERR_PATHNOTFOUND	EQU	(MMIOERR_BASE+11) ; path incorrect
MMIOERR_ACCESSDENIED	EQU	(MMIOERR_BASE+12) ; file was protected
MMIOERR_SHARINGVIOLATION	EQU	(MMIOERR_BASE+13) ; file in use
MMIOERR_NETWORKERROR	EQU	(MMIOERR_BASE+14) ; network not responding
MMIOERR_TOOMANYOPENFILES	EQU	(MMIOERR_BASE+15) ; no more file handles
MMIOERR_INVALIDFILE	EQU	(MMIOERR_BASE+16) ; default error file error
; MMIO constants
CFSEPCHAR	EQU	<'+'>             ; compound file name separator char.

MMIOINFO	STRUC
mmio_dwFlags	DD	?
mmio_fccIOProc	DD	?
mmio_pIOProc	DD	?
mmio_wErrorRet	DW	?
mmio_htask	DW	?
mmio_cchBuffer	DD	?
mmio_pchBuffer	DD	?
mmio_pchNext	DD	?
mmio_pchEndRead	DD	?
mmio_pchEndWrite	DD	?
mmio_lBufOffset	DD	?
mmio_lDiskOffset	DD	?
mmio_adwInfo	DD	3 DUP (?)
mmio_dwReserved1	DD	?
mmio_dwReserved2	DD	?
mmio_hmmio	DW	?
MMIOINFO	ENDS
; bit field masks
MMIO_RWMODE	EQU	00000003H      ; open file for reading/writing/both
MMIO_SHAREMODE	EQU	00000070H      ; file sharing mode number
; constants for dwFlags field of MMIOINFO
MMIO_CREATE	EQU	00001000H      ; create new file (or truncate file)
MMIO_PARSE	EQU	00000100H      ; parse new file returning path
MMIO_DELETE	EQU	00000200H      ; create new file (or truncate file)
MMIO_EXIST	EQU	00004000H      ; checks for existence of file
MMIO_ALLOCBUF	EQU	00010000H      ; mmioOpen() should allocate a buffer
MMIO_GETTEMP	EQU	00020000H      ; mmioOpen() should retrieve temp name
MMIO_DIRTY	EQU	10000000H      ; I/O buffer is dirty
; read/write mode numbers (bit field MMIO_RWMODE)
MMIO_READ	EQU	00000000H      ; open file for reading only
MMIO_WRITE	EQU	00000001H      ; open file for writing only
MMIO_READWRITE	EQU	00000002H      ; open file for reading and writing
; share mode numbers (bit field MMIO_SHAREMODE)
MMIO_COMPAT	EQU	00000000H      ; compatibility mode
MMIO_EXCLUSIVE	EQU	00000010H      ; exclusive-access mode
MMIO_DENYWRITE	EQU	00000020H      ; deny writing to other processes
MMIO_DENYREAD	EQU	00000030H      ; deny reading to other processes
MMIO_DENYNONE	EQU	00000040H      ; deny nothing to other processes
; various MMIO flags
MMIO_FHOPEN	EQU	0010H  ; mmioClose: keep file handle open
MMIO_EMPTYBUF	EQU	0010H  ; mmioFlush: empty the I/O buffer
MMIO_TOUPPER	EQU	0010H  ; mmioStringToFOURCC: to u-case
MMIO_INSTALLPROC	EQU	00010000H  ; mmioInstallIOProc: install MMIOProc
MMIO_GLOBALPROC	EQU	10000000H  ; mmioInstallIOProc: install globally
MMIO_REMOVEPROC	EQU	00020000H  ; mmioInstallIOProc: remove MMIOProc
MMIO_FINDPROC	EQU	00040000H  ; mmioInstallIOProc: find an MMIOProc
MMIO_FINDCHUNK	EQU	0010H  ; mmioDescend: find a chunk by ID
MMIO_FINDRIFF	EQU	0020H  ; mmioDescend: find a LIST chunk
MMIO_FINDLIST	EQU	0040H  ; mmioDescend: find a RIFF chunk
MMIO_CREATERIFF	EQU	0020H  ; mmioCreateChunk: make a LIST chunk
MMIO_CREATELIST	EQU	0040H  ; mmioCreateChunk: make a RIFF chunk
; message numbers for MMIOPROC I/O procedure functions
MMIOM_READ	EQU	MMIO_READ       ; read
MMIOM_WRITE	EQU	MMIO_WRITE       ; write
MMIOM_SEEK	EQU	2       ; seek to a new position in file
MMIOM_OPEN	EQU	3       ; open file
MMIOM_CLOSE	EQU	4       ; close file
MMIOM_WRITEFLUSH	EQU	5       ; write and flush
MMIOM_RENAME	EQU	6       ; rename specified file
MMIOM_USER	EQU	8000H       ; beginning of user-defined messages
; flags for mmioSeek()
ifndef SEEK_SET
SEEK_SET	EQU	0               ; seek to an absolute position
SEEK_CUR	EQU	1               ; seek relative to current position
SEEK_END	EQU	2               ; seek relative to end of file
endif  ; ifndef SEEK_SET
; other constants
MMIO_DEFAULTBUFFER	EQU	8192    ; default buffer size
endif  ; ifndef MMNOMMIO
ifndef MMNOMCI
; MCI error return values
MCIERR_INVALID_DEVICE_ID	EQU	(MCIERR_BASE+1)
MCIERR_UNRECOGNIZED_KEYWORD	EQU	(MCIERR_BASE+3)
MCIERR_UNRECOGNIZED_COMMAND	EQU	(MCIERR_BASE+5)
MCIERR_HARDWARE	EQU	(MCIERR_BASE+6)
MCIERR_INVALID_DEVICE_NAME	EQU	(MCIERR_BASE+7)
MCIERR_OUT_OF_MEMORY	EQU	(MCIERR_BASE+8)
MCIERR_DEVICE_OPEN	EQU	(MCIERR_BASE+9)
MCIERR_CANNOT_LOAD_DRIVER	EQU	(MCIERR_BASE+10)
MCIERR_MISSING_COMMAND_STRING	EQU	(MCIERR_BASE+11)
MCIERR_PARAM_OVERFLOW	EQU	(MCIERR_BASE+12)
MCIERR_MISSING_STRING_ARGUMENT	EQU	(MCIERR_BASE+13)
MCIERR_BAD_INTEGER	EQU	(MCIERR_BASE+14)
MCIERR_PARSER_INTERNAL	EQU	(MCIERR_BASE+15)
MCIERR_DRIVER_INTERNAL	EQU	(MCIERR_BASE+16)
MCIERR_MISSING_PARAMETER	EQU	(MCIERR_BASE+17)
MCIERR_UNSUPPORTED_FUNCTION	EQU	(MCIERR_BASE+18)
MCIERR_FILE_NOT_FOUND	EQU	(MCIERR_BASE+19)
MCIERR_DEVICE_NOT_READY	EQU	(MCIERR_BASE+20)
MCIERR_INTERNAL	EQU	(MCIERR_BASE+21)
MCIERR_DRIVER	EQU	(MCIERR_BASE+22)
MCIERR_CANNOT_USE_ALL	EQU	(MCIERR_BASE+23)
MCIERR_MULTIPLE	EQU	(MCIERR_BASE+24)
MCIERR_EXTENSION_NOT_FOUND	EQU	(MCIERR_BASE+25)
MCIERR_OUTOFRANGE	EQU	(MCIERR_BASE+26)
MCIERR_FLAGS_NOT_COMPATIBLE	EQU	(MCIERR_BASE+28)
MCIERR_FILE_NOT_SAVED	EQU	(MCIERR_BASE+30)
MCIERR_DEVICE_TYPE_REQUIRED	EQU	(MCIERR_BASE+31)
MCIERR_DEVICE_LOCKED	EQU	(MCIERR_BASE+32)
MCIERR_DUPLICATE_ALIAS	EQU	(MCIERR_BASE+33)
MCIERR_BAD_CONSTANT	EQU	(MCIERR_BASE+34)
MCIERR_MUST_USE_SHAREABLE	EQU	(MCIERR_BASE+35)
MCIERR_MISSING_DEVICE_NAME	EQU	(MCIERR_BASE+36)
MCIERR_BAD_TIME_FORMAT	EQU	(MCIERR_BASE+37)
MCIERR_NO_CLOSING_QUOTE	EQU	(MCIERR_BASE+38)
MCIERR_DUPLICATE_FLAGS	EQU	(MCIERR_BASE+39)
MCIERR_INVALID_FILE	EQU	(MCIERR_BASE+40)
MCIERR_NULL_PARAMETER_BLOCK	EQU	(MCIERR_BASE+41)
MCIERR_UNNAMED_RESOURCE	EQU	(MCIERR_BASE+42)
MCIERR_NEW_REQUIRES_ALIAS	EQU	(MCIERR_BASE+43)
MCIERR_NOTIFY_ON_AUTO_OPEN	EQU	(MCIERR_BASE+44)
MCIERR_NO_ELEMENT_ALLOWED	EQU	(MCIERR_BASE+45)
MCIERR_NONAPPLICABLE_FUNCTION	EQU	(MCIERR_BASE+46)
MCIERR_ILLEGAL_FOR_AUTO_OPEN	EQU	(MCIERR_BASE+47)
MCIERR_FILENAME_REQUIRED	EQU	(MCIERR_BASE+48)
MCIERR_EXTRA_CHARACTERS	EQU	(MCIERR_BASE+49)
MCIERR_DEVICE_NOT_INSTALLED	EQU	(MCIERR_BASE+50)
MCIERR_GET_CD	EQU	(MCIERR_BASE+51)
MCIERR_SET_CD	EQU	(MCIERR_BASE+52)
MCIERR_SET_DRIVE	EQU	(MCIERR_BASE+53)
MCIERR_DEVICE_LENGTH	EQU	(MCIERR_BASE+54)
MCIERR_DEVICE_ORD_LENGTH	EQU	(MCIERR_BASE+55)
MCIERR_NO_INTEGER	EQU	(MCIERR_BASE+56)
MCIERR_WAVE_OUTPUTSINUSE	EQU	(MCIERR_BASE+64)
MCIERR_WAVE_SETOUTPUTINUSE	EQU	(MCIERR_BASE+65)
MCIERR_WAVE_INPUTSINUSE	EQU	(MCIERR_BASE+66)
MCIERR_WAVE_SETINPUTINUSE	EQU	(MCIERR_BASE+67)
MCIERR_WAVE_OUTPUTUNSPECIFIED	EQU	(MCIERR_BASE+68)
MCIERR_WAVE_INPUTUNSPECIFIED	EQU	(MCIERR_BASE+69)
MCIERR_WAVE_OUTPUTSUNSUITABLE	EQU	(MCIERR_BASE+70)
MCIERR_WAVE_SETOUTPUTUNSUITABLE	EQU	(MCIERR_BASE+71)
MCIERR_WAVE_INPUTSUNSUITABLE	EQU	(MCIERR_BASE+72)
MCIERR_WAVE_SETINPUTUNSUITABLE	EQU	(MCIERR_BASE+73)
MCIERR_SEQ_DIV_INCOMPATIBLE	EQU	(MCIERR_BASE+80)
MCIERR_SEQ_PORT_INUSE	EQU	(MCIERR_BASE+81)
MCIERR_SEQ_PORT_NONEXISTENT	EQU	(MCIERR_BASE+82)
MCIERR_SEQ_PORT_MAPNODEVICE	EQU	(MCIERR_BASE+83)
MCIERR_SEQ_PORT_MISCERROR	EQU	(MCIERR_BASE+84)
MCIERR_SEQ_TIMER	EQU	(MCIERR_BASE+85)
MCIERR_SEQ_PORTUNSPECIFIED	EQU	(MCIERR_BASE+86)
MCIERR_SEQ_NOMIDIPRESENT	EQU	(MCIERR_BASE+87)
MCIERR_NO_WINDOW	EQU	(MCIERR_BASE+90)
MCIERR_CREATEWINDOW	EQU	(MCIERR_BASE+91)
MCIERR_FILE_READ	EQU	(MCIERR_BASE+92)
MCIERR_FILE_WRITE	EQU	(MCIERR_BASE+93)
MCIERR_NO_IDENTITY	EQU	(MCIERR_BASE+94)
; all custom device driver errors must be >= than this value
MCIERR_CUSTOM_DRIVER_BASE	EQU	(MCIERR_BASE+256)
; MCI command message identifiers
MCI_OPEN	EQU	0803H
MCI_CLOSE	EQU	0804H
MCI_ESCAPE	EQU	0805H
MCI_PLAY	EQU	0806H
MCI_SEEK	EQU	0807H
MCI_STOP	EQU	0808H
MCI_PAUSE	EQU	0809H
MCI_INFO	EQU	080AH
MCI_GETDEVCAPS	EQU	080BH
MCI_SPIN	EQU	080CH
MCI_SET	EQU	080DH
MCI_STEP	EQU	080EH
MCI_RECORD	EQU	080FH
MCI_SYSINFO	EQU	0810H
MCI_BREAK	EQU	0811H
;reserved                              0x0812
MCI_SAVE	EQU	0813H
MCI_STATUS	EQU	0814H
MCI_CUE	EQU	0830H
MCI_REALIZE	EQU	0840H
MCI_WINDOW	EQU	0841H
MCI_PUT	EQU	0842H
MCI_WHERE	EQU	0843H
MCI_FREEZE	EQU	0844H
MCI_UNFREEZE	EQU	0845H
MCI_LOAD	EQU	0850H
MCI_CUT	EQU	0851H
MCI_COPY	EQU	0852H
MCI_PASTE	EQU	0853H
MCI_UPDATE	EQU	0854H
MCI_RESUME	EQU	0855H
MCI_DELETE	EQU	0856H
; all custom MCI command messages must be >= than this value
MCI_USER_MESSAGES	EQU	(DRV_MCI_FIRST+400H)
MCI_ALL_DEVICE_ID	EQU	-1
; constants for predefined MCI device types
MCI_DEVTYPE_VCR	EQU	(MCI_STRING_OFFSET+1)
MCI_DEVTYPE_VIDEODISC	EQU	(MCI_STRING_OFFSET+2)
MCI_DEVTYPE_OVERLAY	EQU	(MCI_STRING_OFFSET+3)
MCI_DEVTYPE_CD_AUDIO	EQU	(MCI_STRING_OFFSET+4)
MCI_DEVTYPE_DAT	EQU	(MCI_STRING_OFFSET+5)
MCI_DEVTYPE_SCANNER	EQU	(MCI_STRING_OFFSET+6)
MCI_DEVTYPE_ANIMATION	EQU	(MCI_STRING_OFFSET+7)
MCI_DEVTYPE_DIGITAL_VIDEO	EQU	(MCI_STRING_OFFSET+8)
MCI_DEVTYPE_OTHER	EQU	(MCI_STRING_OFFSET+9)
MCI_DEVTYPE_WAVEFORM_AUDIO	EQU	(MCI_STRING_OFFSET+10)
MCI_DEVTYPE_SEQUENCER	EQU	(MCI_STRING_OFFSET+11)
MCI_DEVTYPE_FIRST	EQU	MCI_DEVTYPE_VCR
MCI_DEVTYPE_LAST	EQU	MCI_DEVTYPE_SEQUENCER
; return values for 'status mode' command
MCI_MODE_NOT_READY	EQU	(MCI_STRING_OFFSET+12)
MCI_MODE_STOP	EQU	(MCI_STRING_OFFSET+13)
MCI_MODE_PLAY	EQU	(MCI_STRING_OFFSET+14)
MCI_MODE_RECORD	EQU	(MCI_STRING_OFFSET+15)
MCI_MODE_SEEK	EQU	(MCI_STRING_OFFSET+16)
MCI_MODE_PAUSE	EQU	(MCI_STRING_OFFSET+17)
MCI_MODE_OPEN	EQU	(MCI_STRING_OFFSET+18)
; constants used in 'set time format' and 'status time format' commands
MCI_FORMAT_MILLISECONDS	EQU	0
MCI_FORMAT_HMS	EQU	1
MCI_FORMAT_MSF	EQU	2
MCI_FORMAT_FRAMES	EQU	3
MCI_FORMAT_SMPTE_24	EQU	4
MCI_FORMAT_SMPTE_25	EQU	5
MCI_FORMAT_SMPTE_30	EQU	6
MCI_FORMAT_SMPTE_30DROP	EQU	7
MCI_FORMAT_BYTES	EQU	8
MCI_FORMAT_SAMPLES	EQU	9
MCI_FORMAT_TMSF	EQU	10
; flags for wParam of MM_MCINOTIFY message
MCI_NOTIFY_SUCCESSFUL	EQU	0001H
MCI_NOTIFY_SUPERSEDED	EQU	0002H
MCI_NOTIFY_ABORTED	EQU	0004H
MCI_NOTIFY_FAILURE	EQU	0008H
; common flags for dwFlags parameter of MCI command messages
MCI_NOTIFY	EQU	00000001H
MCI_WAIT	EQU	00000002H
MCI_FROM	EQU	00000004H
MCI_TO	EQU	00000008H
MCI_TRACK	EQU	00000010H
; flags for dwFlags parameter of MCI_OPEN command message
MCI_OPEN_SHAREABLE	EQU	00000100H
MCI_OPEN_ELEMENT	EQU	00000200H
MCI_OPEN_ALIAS	EQU	00000400H
MCI_OPEN_ELEMENT_ID	EQU	00000800H
MCI_OPEN_TYPE_ID	EQU	00001000H
MCI_OPEN_TYPE	EQU	00002000H
; flags for dwFlags parameter of MCI_SEEK command message
MCI_SEEK_TO_START	EQU	00000100H
MCI_SEEK_TO_END	EQU	00000200H
; flags for dwFlags parameter of MCI_STATUS command message
MCI_STATUS_ITEM	EQU	00000100H
MCI_STATUS_START	EQU	00000200H
; flags for dwItem field of the MCI_STATUS_PARMS parameter block
MCI_STATUS_LENGTH	EQU	00000001H
MCI_STATUS_POSITION	EQU	00000002H
MCI_STATUS_NUMBER_OF_TRACKS	EQU	00000003H
MCI_STATUS_MODE	EQU	00000004H
MCI_STATUS_MEDIA_PRESENT	EQU	00000005H
MCI_STATUS_TIME_FORMAT	EQU	00000006H
MCI_STATUS_READY	EQU	00000007H
MCI_STATUS_CURRENT_TRACK	EQU	00000008H
; flags for dwFlags parameter of MCI_INFO command message
MCI_INFO_PRODUCT	EQU	00000100H
MCI_INFO_FILE	EQU	00000200H
MCI_INFO_MEDIA_UPC	EQU	00000400H
MCI_INFO_MEDIA_IDENTITY	EQU	00000800H
; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_ITEM	EQU	00000100H
; flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block
MCI_GETDEVCAPS_CAN_RECORD	EQU	00000001H
MCI_GETDEVCAPS_HAS_AUDIO	EQU	00000002H
MCI_GETDEVCAPS_HAS_VIDEO	EQU	00000003H
MCI_GETDEVCAPS_DEVICE_TYPE	EQU	00000004H
MCI_GETDEVCAPS_USES_FILES	EQU	00000005H
MCI_GETDEVCAPS_COMPOUND_DEVICE	EQU	00000006H
MCI_GETDEVCAPS_CAN_EJECT	EQU	00000007H
MCI_GETDEVCAPS_CAN_PLAY	EQU	00000008H
MCI_GETDEVCAPS_CAN_SAVE	EQU	00000009H
; flags for dwFlags parameter of MCI_SYSINFO command message
MCI_SYSINFO_QUANTITY	EQU	00000100H
MCI_SYSINFO_OPEN	EQU	00000200H
MCI_SYSINFO_NAME	EQU	00000400H
MCI_SYSINFO_INSTALLNAME	EQU	00000800H
; flags for dwFlags parameter of MCI_SET command message
MCI_SET_DOOR_OPEN	EQU	00000100H
MCI_SET_DOOR_CLOSED	EQU	00000200H
MCI_SET_TIME_FORMAT	EQU	00000400H
MCI_SET_AUDIO	EQU	00000800H
MCI_SET_VIDEO	EQU	00001000H
MCI_SET_ON	EQU	00002000H
MCI_SET_OFF	EQU	00004000H
; flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS
ifdef WIN32
MCI_SET_AUDIO_ALL	EQU	00004001H
MCI_SET_AUDIO_LEFT	EQU	00004002H
MCI_SET_AUDIO_RIGHT	EQU	00004003H
else
MCI_SET_AUDIO_ALL	EQU	00000000H
MCI_SET_AUDIO_LEFT	EQU	00000001H
MCI_SET_AUDIO_RIGHT	EQU	00000002H
endif
; flags for dwFlags parameter of MCI_BREAK command message
MCI_BREAK_KEY	EQU	00000100H
MCI_BREAK_HWND	EQU	00000200H
MCI_BREAK_OFF	EQU	00000400H
; flags for dwFlags parameter of MCI_RECORD command message
MCI_RECORD_INSERT	EQU	00000100H
MCI_RECORD_OVERWRITE	EQU	00000200H
; flags for dwFlags parameter of MCI_SAVE command message
MCI_SAVE_FILE	EQU	00000100H
; flags for dwFlags parameter of MCI_LOAD command message
MCI_LOAD_FILE	EQU	00000100H

MCI_GENERIC_PARMS	STRUC
mcigen_dwCallback	DD	?
MCI_GENERIC_PARMS	ENDS

MCI_OPEN_PARMS	STRUC
mciopen_dwCallback	DD	?
mciopen_wDeviceID	DW	?
mciopen_wReserved0	DW	?
mciopen_lpstrDeviceType	DD	?
mciopen_lpstrElementName	DD	?
mciopen_lpstrAlias	DD	?
MCI_OPEN_PARMS	ENDS

MCI_PLAY_PARMS	STRUC
mciplay_dwCallback	DD	?
mciplay_dwFrom	DD	?
mciplay_dwTo	DD	?
MCI_PLAY_PARMS	ENDS

MCI_SEEK_PARMS	STRUC
mciseek_dwCallback	DD	?
mciseek_dwTo	DD	?
MCI_SEEK_PARMS	ENDS

MCI_STATUS_PARMS	STRUC
mcistat_dwCallback	DD	?
mcistat_dwReturn	DD	?
mcistat_dwItem	DD	?
mcistat_dwTrack	DD	?
MCI_STATUS_PARMS	ENDS

MCI_INFO_PARMS	STRUC
mciinfo_dwCallback	DD	?
mciinfo_lpstrReturn	DD	?
mciinfo_dwRetSize	DD	?
MCI_INFO_PARMS	ENDS

MCI_GETDEVCAPS_PARMS	STRUC
mcigdc_dwCallback	DD	?
mcigdc_dwReturn	DD	?
mcigdc_dwItem	DD	?
MCI_GETDEVCAPS_PARMS	ENDS

MCI_SYSINFO_PARMS	STRUC
mcisi_dwCallback	DD	?
mcisi_lpstrReturn	DD	?
mcisi_dwRetSize	DD	?
mcisi_dwNumber	DD	?
mcisi_wDeviceType	DW	?
mcisi_wReserved0	DW	?
MCI_SYSINFO_PARMS	ENDS

MCI_SET_PARMS	STRUC
mciset_dwCallback	DD	?
mciset_dwTimeFormat	DD	?
mciset_dwAudio	DD	?
MCI_SET_PARMS	ENDS

MCI_BREAK_PARMS	STRUC
mcibreak_dwCallback	DD	?
mcibreak_nVirtKey	DW	?
mcibreak_wReserved0	DW	?
mcibreak_hwndBreak	DW	?
mcibreak_wReserved1	DW	?
MCI_BREAK_PARMS	ENDS

MCI_SAVE_PARMS	STRUC
mcisave_dwCallback	DD	?
mcisave_lpfilename	DD	?
MCI_SAVE_PARMS	ENDS

MCI_LOAD_PARMS	STRUC
mciload_dwCallback	DD	?
mciload_lpfilename	DD	?
MCI_LOAD_PARMS	ENDS

MCI_RECORD_PARMS	STRUC
mcirec_dwCallback	DD	?
mcirec_dwFrom	DD	?
mcirec_dwTo	DD	?
MCI_RECORD_PARMS	ENDS
; MCI extensions for videodisc devices
; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_STATUS_MODE)
MCI_VD_MODE_PARK	EQU	(MCI_VD_OFFSET+1)
; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE)
MCI_VD_MEDIA_CLV	EQU	(MCI_VD_OFFSET+2)
MCI_VD_MEDIA_CAV	EQU	(MCI_VD_OFFSET+3)
MCI_VD_MEDIA_OTHER	EQU	(MCI_VD_OFFSET+4)
MCI_VD_FORMAT_TRACK	EQU	4001H
; flags for dwFlags parameter of MCI_PLAY command message
MCI_VD_PLAY_REVERSE	EQU	00010000H
MCI_VD_PLAY_FAST	EQU	00020000H
MCI_VD_PLAY_SPEED	EQU	00040000H
MCI_VD_PLAY_SCAN	EQU	00080000H
MCI_VD_PLAY_SLOW	EQU	00100000H
; flag for dwFlags parameter of MCI_SEEK command message
MCI_VD_SEEK_REVERSE	EQU	00010000H
; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_VD_STATUS_SPEED	EQU	00004002H
MCI_VD_STATUS_FORWARD	EQU	00004003H
MCI_VD_STATUS_MEDIA_TYPE	EQU	00004004H
MCI_VD_STATUS_SIDE	EQU	00004005H
MCI_VD_STATUS_DISC_SIZE	EQU	00004006H
; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_VD_GETDEVCAPS_CLV	EQU	00010000H
MCI_VD_GETDEVCAPS_CAV	EQU	00020000H
MCI_VD_SPIN_UP	EQU	00010000H
MCI_VD_SPIN_DOWN	EQU	00020000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_VD_GETDEVCAPS_CAN_REVERSE	EQU	00004002H
MCI_VD_GETDEVCAPS_FAST_RATE	EQU	00004003H
MCI_VD_GETDEVCAPS_SLOW_RATE	EQU	00004004H
MCI_VD_GETDEVCAPS_NORMAL_RATE	EQU	00004005H
; flags for the dwFlags parameter of MCI_STEP command message
MCI_VD_STEP_FRAMES	EQU	00010000H
MCI_VD_STEP_REVERSE	EQU	00020000H
; flag for the MCI_ESCAPE command message
MCI_VD_ESCAPE_STRING	EQU	00000100H

MCI_VD_PLAY_PARMS	STRUC
mcivdplay_dwCallback	DD	?
mcivdplay_dwFrom	DD	?
mcivdplay_dwTo	DD	?
mcivdplay_dwSpeed	DD	?
MCI_VD_PLAY_PARMS	ENDS

MCI_VD_STEP_PARMS	STRUC
mcivdstep_dwCallback	DD	?
mcivdstep_dwFrames	DD	?
MCI_VD_STEP_PARMS	ENDS

MCI_VD_ESCAPE_PARMS	STRUC
mcivcesc_dwCallback	DD	?
mcivcesc_lpstrCommand	DD	?
MCI_VD_ESCAPE_PARMS	ENDS
; MCI extensions for CD audio devices
; flags for the dwItem field of the MCI_STATUS_PARMS parameter block
MCI_CDA_STATUS_TYPE_TRACK	EQU	00004001H
; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK)
MCI_CDA_TRACK_AUDIO	EQU	(MCI_CD_OFFSET+0)
MCI_CDA_TRACK_OTHER	EQU	(MCI_CD_OFFSET+1)
; MCI extensions for waveform audio devices
; flags for the dwFlags parameter of MCI_OPEN command message
MCI_WAVE_OPEN_BUFFER	EQU	00010000H
; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_FORMATTAG	EQU	00010000H
MCI_WAVE_SET_CHANNELS	EQU	00020000H
MCI_WAVE_SET_SAMPLESPERSEC	EQU	00040000H
MCI_WAVE_SET_AVGBYTESPERSEC	EQU	00080000H
MCI_WAVE_SET_BLOCKALIGN	EQU	00100000H
MCI_WAVE_SET_BITSPERSAMPLE	EQU	00200000H
; flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages
MCI_WAVE_INPUT	EQU	00400000H
MCI_WAVE_OUTPUT	EQU	00800000H
; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_WAVE_STATUS_FORMATTAG	EQU	00004001H
MCI_WAVE_STATUS_CHANNELS	EQU	00004002H
MCI_WAVE_STATUS_SAMPLESPERSEC	EQU	00004003H
MCI_WAVE_STATUS_AVGBYTESPERSEC	EQU	00004004H
MCI_WAVE_STATUS_BLOCKALIGN	EQU	00004005H
MCI_WAVE_STATUS_BITSPERSAMPLE	EQU	00004006H
MCI_WAVE_STATUS_LEVEL	EQU	00004007H
; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_ANYINPUT	EQU	04000000H
MCI_WAVE_SET_ANYOUTPUT	EQU	08000000H
; flags for the dwFlags parameter of MCI_GETDEVCAPS command message
MCI_WAVE_GETDEVCAPS_INPUTS	EQU	00004001H
MCI_WAVE_GETDEVCAPS_OUTPUTS	EQU	00004002H

MCI_WAVE_OPEN_PARMS	STRUC
mciwopen_dwCallback	DD	?
mciwopen_wDeviceID	DW	?
mciwopen_wReserved0	DW	?
mciwopen_lpstrDeviceType	DD	?
mciwopen_lpstrElementName	DD	?
mciwopen_lpstrAlias	DD	?
mciwopen_dwBufferSeconds	DD	?
MCI_WAVE_OPEN_PARMS	ENDS

MCI_WAVE_DELETE_PARMS	STRUC
mciwdel_dwCallback	DD	?
mciwdel_dwFrom	DD	?
mciwdel_dwTo	DD	?
MCI_WAVE_DELETE_PARMS	ENDS

MCI_WAVE_SET_PARMS	STRUC
mciwset_dwCallback	DD	?
mciwset_dwTimeFormat	DD	?
mciwset_dwAudio	DD	?
mciwset_wInput	DW	?
mciwset_wReserved0	DW	?
mciwset_wOutput	DW	?
mciwset_wReserved1	DW	?
mciwset_wFormatTag	DW	?
mciwset_wReserved2	DW	?
mciwset_nChannels	DW	?
mciwset_wReserved3	DW	?
mciwset_nSamplesPerSec	DW	?
mciwset_nAvgBytesPerSec	DW	?
mciwset_nBlockAlign	DW	?
mciwset_wReserved4	DW	?
mciwset_wBitsPerSample	DW	?
mciwset_wReserved5	DW	?
MCI_WAVE_SET_PARMS	ENDS
; MCI extensions for MIDI sequencer devices
; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE)
MCI_SEQ_DIV_PPQN	EQU	(0+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_24	EQU	(1+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_25	EQU	(2+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30DROP	EQU	(3+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30	EQU	(4+MCI_SEQ_OFFSET)
; flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block
; MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER)
MCI_SEQ_FORMAT_SONGPTR	EQU	4001H
MCI_SEQ_FILE	EQU	4002H
MCI_SEQ_MIDI	EQU	4003H
MCI_SEQ_SMPTE	EQU	4004H
MCI_SEQ_NONE	EQU	65533
; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_SEQ_STATUS_TEMPO	EQU	00004002H
MCI_SEQ_STATUS_PORT	EQU	00004003H
MCI_SEQ_STATUS_SLAVE	EQU	00004007H
MCI_SEQ_STATUS_MASTER	EQU	00004008H
MCI_SEQ_STATUS_OFFSET	EQU	00004009H
MCI_SEQ_STATUS_DIVTYPE	EQU	0000400AH
; flags for the dwFlags parameter of MCI_SET command message
MCI_SEQ_SET_TEMPO	EQU	00010000H
MCI_SEQ_SET_PORT	EQU	00020000H
MCI_SEQ_SET_SLAVE	EQU	00040000H
MCI_SEQ_SET_MASTER	EQU	00080000H
MCI_SEQ_SET_OFFSET	EQU	01000000H

MCI_SEQ_SET_PARMS	STRUC
mcisset_dwCallback	DD	?
mcisset_dwTimeFormat	DD	?
mcisset_dwAudio	DD	?
mcisset_dwTempo	DD	?
mcisset_dwPort	DD	?
mcisset_dwSlave	DD	?
mcisset_dwMaster	DD	?
mcisset_dwOffset	DD	?
MCI_SEQ_SET_PARMS	ENDS
; MCI extensions for animation devices
; flags for dwFlags parameter of MCI_OPEN command message
MCI_ANIM_OPEN_WS	EQU	00010000H
MCI_ANIM_OPEN_PARENT	EQU	00020000H
MCI_ANIM_OPEN_NOSTATIC	EQU	00040000H
; flags for dwFlags parameter of MCI_PLAY command message
MCI_ANIM_PLAY_SPEED	EQU	00010000H
MCI_ANIM_PLAY_REVERSE	EQU	00020000H
MCI_ANIM_PLAY_FAST	EQU	00040000H
MCI_ANIM_PLAY_SLOW	EQU	00080000H
MCI_ANIM_PLAY_SCAN	EQU	00100000H
; flags for dwFlags parameter of MCI_STEP command message
MCI_ANIM_STEP_REVERSE	EQU	00010000H
MCI_ANIM_STEP_FRAMES	EQU	00020000H
; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_ANIM_STATUS_SPEED	EQU	00004001H
MCI_ANIM_STATUS_FORWARD	EQU	00004002H
MCI_ANIM_STATUS_HWND	EQU	00004003H
MCI_ANIM_STATUS_HPAL	EQU	00004004H
MCI_ANIM_STATUS_STRETCH	EQU	00004005H
; flags for the dwFlags parameter of MCI_INFO command message
MCI_ANIM_INFO_TEXT	EQU	00010000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_ANIM_GETDEVCAPS_CAN_REVERSE	EQU	00004001H
MCI_ANIM_GETDEVCAPS_FAST_RATE	EQU	00004002H
MCI_ANIM_GETDEVCAPS_SLOW_RATE	EQU	00004003H
MCI_ANIM_GETDEVCAPS_NORMAL_RATE	EQU	00004004H
MCI_ANIM_GETDEVCAPS_PALETTES	EQU	00004006H
MCI_ANIM_GETDEVCAPS_CAN_STRETCH	EQU	00004007H
MCI_ANIM_GETDEVCAPS_MAX_WINDOWS	EQU	00004008H
; flags for the MCI_REALIZE command message
MCI_ANIM_REALIZE_NORM	EQU	00010000H
MCI_ANIM_REALIZE_BKGD	EQU	00020000H
; flags for dwFlags parameter of MCI_WINDOW command message
MCI_ANIM_WINDOW_HWND	EQU	00010000H
MCI_ANIM_WINDOW_STATE	EQU	00040000H
MCI_ANIM_WINDOW_TEXT	EQU	00080000H
MCI_ANIM_WINDOW_ENABLE_STRETCH	EQU	00100000H
MCI_ANIM_WINDOW_DISABLE_STRETCH	EQU	00200000H
; flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block
; MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND)
MCI_ANIM_WINDOW_DEFAULT	EQU	00000000H
; flags for dwFlags parameter of MCI_PUT command message
MCI_ANIM_RECT	EQU	00010000H
MCI_ANIM_PUT_SOURCE	EQU	00020000H
MCI_ANIM_PUT_DESTINATION	EQU	00040000H
; flags for dwFlags parameter of MCI_WHERE command message
MCI_ANIM_WHERE_SOURCE	EQU	00020000H
MCI_ANIM_WHERE_DESTINATION	EQU	00040000H
; flags for dwFlags parameter of MCI_UPDATE command message
MCI_ANIM_UPDATE_HDC	EQU	00020000H

MCI_ANIM_OPEN_PARMS	STRUC
mciaopen_dwCallback	DD	?
mciaopen_wDeviceID	DW	?
mciaopen_wReserved0	DW	?
mciaopen_lpstrDeviceType	DD	?
mciaopen_lpstrElementName	DD	?
mciaopen_lpstrAlias	DD	?
mciaopen_dwStyle	DD	?
mciaopen_hWndParent	DW	?
mciaopen_wReserved1	DW	?
MCI_ANIM_OPEN_PARMS	ENDS

MCI_ANIM_PLAY_PARMS	STRUC
mciaplay_dwCallback	DD	?
mciaplay_dwFrom	DD	?
mciaplay_dwTo	DD	?
mciaplay_dwSpeed	DD	?
MCI_ANIM_PLAY_PARMS	ENDS

MCI_ANIM_STEP_PARMS	STRUC
mciastep_dwCallback	DD	?
mciastep_dwFrames	DD	?
MCI_ANIM_STEP_PARMS	ENDS

MCI_ANIM_WINDOW_PARMS	STRUC
mciawin_dwCallback	DD	?
mciawin_hWnd	DW	?
mciawin_wReserved1	DW	?
mciawin_nCmdShow	DW	?
mciawin_wReserved2	DW	?
mciawin_lpstrText	DD	?
MCI_ANIM_WINDOW_PARMS	ENDS

MCI_ANIM_RECT_PARMS	STRUC
mciarect_dwCallback	DD	?
ifdef MCI_USE_OFFEXT
mciarect_ptOffset	DB	SIZE POINT DUP (?)
mciarect_ptExtent	DB	SIZE POINT DUP (?)
else	;ifdef MCI_USE_OFFEXT
mciarect_rc	DB	SIZE RECT DUP (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_ANIM_RECT_PARMS	ENDS

MCI_ANIM_UPDATE_PARMS	STRUC
mciaupd_dwCallback	DD	?
mciaupd_rc	DB	SIZE RECT DUP (?)
mciaupd_hDC	DW	?
MCI_ANIM_UPDATE_PARMS	ENDS
; MCI extensions for video overlay devices
; flags for dwFlags parameter of MCI_OPEN command message
MCI_OVLY_OPEN_WS	EQU	00010000H
MCI_OVLY_OPEN_PARENT	EQU	00020000H
; flags for dwFlags parameter of MCI_STATUS command message
MCI_OVLY_STATUS_HWND	EQU	00004001H
MCI_OVLY_STATUS_STRETCH	EQU	00004002H
; flags for dwFlags parameter of MCI_INFO command message
MCI_OVLY_INFO_TEXT	EQU	00010000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_OVLY_GETDEVCAPS_CAN_STRETCH	EQU	00004001H
MCI_OVLY_GETDEVCAPS_CAN_FREEZE	EQU	00004002H
MCI_OVLY_GETDEVCAPS_MAX_WINDOWS	EQU	00004003H
; flags for dwFlags parameter of MCI_WINDOW command message
MCI_OVLY_WINDOW_HWND	EQU	00010000H
MCI_OVLY_WINDOW_STATE	EQU	00040000H
MCI_OVLY_WINDOW_TEXT	EQU	00080000H
MCI_OVLY_WINDOW_ENABLE_STRETCH	EQU	00100000H
MCI_OVLY_WINDOW_DISABLE_STRETCH	EQU	00200000H
; flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block
MCI_OVLY_WINDOW_DEFAULT	EQU	00000000H
; flags for dwFlags parameter of MCI_PUT command message
MCI_OVLY_RECT	EQU	00010000H
MCI_OVLY_PUT_SOURCE	EQU	00020000H
MCI_OVLY_PUT_DESTINATION	EQU	00040000H
MCI_OVLY_PUT_FRAME	EQU	00080000H
MCI_OVLY_PUT_VIDEO	EQU	00100000H
; flags for dwFlags parameter of MCI_WHERE command message
MCI_OVLY_WHERE_SOURCE	EQU	00020000H
MCI_OVLY_WHERE_DESTINATION	EQU	00040000H
MCI_OVLY_WHERE_FRAME	EQU	00080000H
MCI_OVLY_WHERE_VIDEO	EQU	00100000H

MCI_OVLY_OPEN_PARMS	STRUC
mcioopen_dwCallback	DD	?
mcioopen_wDeviceID	DW	?
mcioopen_wReserved0	DW	?
mcioopen_lpstrDeviceType	DD	?
mcioopen_lpstrElementName	DD	?
mcioopen_lpstrAlias	DD	?
mcioopen_dwStyle	DD	?
mcioopen_hWndParent	DW	?
mcioopen_wReserved1	DW	?
MCI_OVLY_OPEN_PARMS	ENDS

MCI_OVLY_WINDOW_PARMS	STRUC
mciowin_dwCallback	DD	?
mciowin_hWnd	DW	?
mciowin_wReserved1	DW	?
mciowin_nCmdShow	DW	?
mciowin_wReserved2	DW	?
mciowin_lpstrText	DD	?
MCI_OVLY_WINDOW_PARMS	ENDS

MCI_OVLY_RECT_PARMS	STRUC
mciorect_dwCallback	DD	?
ifdef MCI_USE_OFFEXT
mciorect_ptOffset	DB	SIZE POINT DUP (?)
mciorect_ptExtent	DB	SIZE POINT DUP (?)
else	;ifdef MCI_USE_OFFEXT
mciorect_rc	DB	SIZE RECT DUP (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_OVLY_RECT_PARMS	ENDS

MCI_OVLY_SAVE_PARMS	STRUC
mciosave_dwCallback	DD	?
mciosave_lpfilename	DD	?
mciosave_rc	DB	SIZE RECT DUP (?)
MCI_OVLY_SAVE_PARMS	ENDS

MCI_OVLY_LOAD_PARMS	STRUC
mcioload_dwCallback	DD	?
mcioload_lpfilename	DD	?
mcioload_rc	DB	SIZE RECT DUP (?)
MCI_OVLY_LOAD_PARMS	ENDS
endif  ; ifndef MMNOMCI
;***************************************************************************
;	DISPLAY Driver extensions
;*************************************************************************
ifndef C1_TRANSPARENT
CAPS1	EQU	94          ; other caps
C1_TRANSPARENT	EQU	0001H      ; new raster cap
NEWTRANSPARENT	EQU	3           ; use with SetBkMode()
QUERYROPSUPPORT	EQU	40          ; use to determine ROP support
endif  ; ifndef C1_TRANSPARENT
;***************************************************************************
;	DIB Driver extensions
;*************************************************************************
SELECTDIB	EQU	41                      ; DIB.DRV select dib escape
ifndef SC_SCREENSAVE
SC_SCREENSAVE	EQU	0F140H
endif  ; ifndef SC_SCREENSAVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\mmddk.inc ===
;==========================================================================;
;
;  mmddk.inc -- Include file for Multimedia Device Development
;
;  Version 4.00
;
;  Copyright (C) 1992-1994 Microsoft Corporation.  All Rights Reserved.
;
;--------------------------------------------------------------------------;
;
;  Define:         Prevent inclusion of:
;  --------------  --------------------------------------------------------
;  MMNOMIDIDEV     MIDI support
;  MMNOWAVEDEV     Waveform support
;  MMNOAUXDEV      Auxiliary output support
;  MMNOTIMERDEV    Timer support
;  MMNOJOYDEV      Joystick support
;  MMNOMCIDEV      MCI support
;  MMNOTASKDEV     Task support
;
;==========================================================================;

OFFSEL  STRUC
Off     dw  ?
Sel     dw  ?
OFFSEL  ENDS

LOHI    STRUC
Lo      dw  ?
Hi      dw  ?
LOHI    ENDS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                      Helper functions for drivers
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DCB_TYPEMASK                equ 0007h   ; callback type mask
DCB_NULL                    equ 0000h   ; unknown callback type

; flags for wFlags parameter of DriverCallback()
DCB_WINDOW                  equ 0001h   ; dwCallback is a HWND
DCB_TASK                    equ 0002h   ; dwCallback is a HTASK
DCB_FUNCTION                equ 0003h   ; dwCallback is a FARPROC
DCB_WINDOW32                equ 0004h   ; dwCallback is a WINDOW ; Internal

;  message sent by mmsystem to wodMessage(), widMessage(), modMessage(),
;  and midMessage() when it initializes the wave and midi drivers 

DRVM_INIT                   equ 100

;  message base for driver specific messages
;
DRVM_USER                   equ 4000h

ifndef  MMNOWAVEDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
;                      Waveform device driver support
; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; maximum number of wave device drivers loaded
MAXWAVEDRIVERS              equ 10


; waveform input and output device open information structure
WAVEOPENDESC struc
    wod_hWave         dw    ?        ; handle
    wod_lpFormat      dd    ?        ; format of wave data
    wod_dwCallback    dd    ?        ; callback
    wod_dwInstance    dd    ?        ; app's private instance information
WAVEOPENDESC ends

WODM_INIT                   equ DRVM_INIT
WIDM_INIT                   equ DRVM_INIT
WODM_USER                   equ DRVM_USER
WIDM_USER                   equ DRVM_USER

; messages sent to wodMessage() entry-point function
WODM_GETNUMDEVS             equ 3
WODM_GETDEVCAPS             equ 4
WODM_OPEN                   equ 5
WODM_CLOSE                  equ 6
WODM_PREPARE                equ 7
WODM_UNPREPARE              equ 8
WODM_WRITE                  equ 9
WODM_PAUSE                  equ 10
WODM_RESTART                equ 11
WODM_RESET                  equ 12 
WODM_GETPOS                 equ 13
WODM_GETPITCH               equ 14
WODM_SETPITCH               equ 15
WODM_GETVOLUME              equ 16
WODM_SETVOLUME              equ 17
WODM_GETPLAYBACKRATE        equ 18
WODM_SETPLAYBACKRATE        equ 19
WODM_BREAKLOOP              equ 20

; messages sent to widMessage() entry-point function
WIDM_GETNUMDEVS             equ 50
WIDM_GETDEVCAPS             equ 51
WIDM_OPEN                   equ 52
WIDM_CLOSE                  equ 53
WIDM_PREPARE                equ 54
WIDM_UNPREPARE              equ 55
WIDM_ADDBUFFER              equ 56
WIDM_START                  equ 57
WIDM_STOP                   equ 58
WIDM_RESET                  equ 59
WIDM_GETPOS                 equ 60

endif   ;ifndef MMNOWAVEDEV


ifndef  MMNOMIDIDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                         MIDI device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; maximum number of MIDI device drivers loaded
MAXMIDIDRIVERS equ    10

MODM_INIT                   equ DRVM_INIT
MIDM_INIT                   equ DRVM_INIT
MODM_USER                   equ DRVM_USER  
MIDM_USER                   equ DRVM_USER  

; MIDI input and output device open information structure
MIDIOPENDESC struc
    mod_hMidi         dw    ?        ; handle
    mod_dwCallback    dd    ?        ; callback
    mod_dwInstance    dd    ?        ; app's private instance information
MIDIOPENDESC ends

; messages sent to modMessage() entry-point function
MODM_GETNUMDEVS             equ 1
MODM_GETDEVCAPS             equ 2
MODM_OPEN                   equ 3
MODM_CLOSE                  equ 4
MODM_PREPARE                equ 5
MODM_UNPREPARE              equ 6
MODM_DATA                   equ 7
MODM_LONGDATA               equ 8
MODM_RESET                  equ 9
MODM_GETVOLUME              equ 10
MODM_SETVOLUME              equ 11
MODM_CACHEPATCHES           equ 12      
MODM_CACHEDRUMPATCHES       equ 13


; messages sent to midMessage() entry-point function
MIDM_GETNUMDEVS             equ 53
MIDM_GETDEVCAPS             equ 54
MIDM_OPEN                   equ 55
MIDM_CLOSE                  equ 56
MIDM_PREPARE                equ 57
MIDM_UNPREPARE              equ 58
MIDM_ADDBUFFER              equ 59
MIDM_START                  equ 60
MIDM_STOP                   equ 61
MIDM_RESET                  equ 62

endif   ;ifndef MMNOMIDIDEV


ifndef  MMNOAUXDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                   Auxiliary audio device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; maximum number of auxiliary device drivers loaded
MAXAUXDRIVERS               equ 10

AUXM_INIT                   equ DRVM_INIT
AUXM_USER                   equ DRVM_USER

; messages sent to auxMessage() entry-point function
AUXDM_GETNUMDEVS            equ 3
AUXDM_GETDEVCAPS            equ 4
AUXDM_GETVOLUME             equ 5
AUXDM_SETVOLUME             equ 6

endif   ;ifndef MMNOAUXDEV


ifndef  MMNOTIMERDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Timer device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TIMEREVENT struc
    te_wDelay         dw    ?     ; delay required
    te_wResolution    dw    ?     ; resolution required
    te_lpFunction     dd    ?     ; ptr to callback function
    te_dwUser         dd    ?     ; user DWORD
    te_wFlags         dw    ?     ; defines how to program event
TIMEREVENT ends

; messages sent to tddMessage() function
TDD_KILLTIMEREVENT          equ (DRV_RESERVED + 0)  ; indices into a table of
TDD_SETTIMEREVENT           equ (DRV_RESERVED + 4)  ; functions; thus offset by
TDD_GETSYSTEMTIME           equ (DRV_RESERVED + 8)  ; four each time...
TDD_GETDEVCAPS              equ (DRV_RESERVED + 12) ; room for future expansion
TDD_BEGINMINPERIOD          equ (DRV_RESERVED + 16) ; room for future expansion
TDD_ENDMINPERIOD            equ (DRV_RESERVED + 20) ; room for future expansion

endif   ;ifndef MMNOTIMERDEV


ifndef  MMNOJOYDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                      Joystick device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; joystick calibration info structure
JOYCALIBRATE struc
    jcal_wXbase     dw    ?
    jcal_wXdelta    dw    ?
    jcal_wYbase     dw    ?
    jcal_wYdelta    dw    ?
    jcal_wZbase     dw    ?
    jcal_wZdelta    dw    ?
JOYCALIBRATE ends

; messages sent to joystick driver's DriverProc() function
JDD_GETNUMDEVS              equ (DRV_RESERVED + 0001h)
JDD_GETDEVCAPS              equ (DRV_RESERVED + 0002h)
JDD_GETPOS                  equ (DRV_RESERVED + 0101h)
JDD_SETCALIBRATION          equ (DRV_RESERVED + 0102h)

endif   ;ifndef MMNOJOYDEV


ifndef  MMNOMCIDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       MCI device driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; internal MCI messages
MCI_OPEN_DRIVER             equ 0801h
MCI_CLOSE_DRIVER            equ 0802h

MAKEMCIRESOURCE MACRO a,b
        mov     ax,a
        mov     dx,b
        ENDM

; string return values only used with MAKEMCIRESOURCE
MCI_FALSE                   equ (MCI_STRING_OFFSET + 19)
MCI_TRUE                    equ (MCI_STRING_OFFSET + 20)

; resource string return values
MCI_FORMAT_RETURN_BASE      equ MCI_FORMAT_MILLISECONDS_S
MCI_FORMAT_MILLISECONDS_S   equ (MCI_STRING_OFFSET + 21)
MCI_FORMAT_HMS_S            equ (MCI_STRING_OFFSET + 22)
MCI_FORMAT_MSF_S            equ (MCI_STRING_OFFSET + 23)
MCI_FORMAT_FRAMES_S         equ (MCI_STRING_OFFSET + 24)
MCI_FORMAT_SMPTE_24_S       equ (MCI_STRING_OFFSET + 25)
MCI_FORMAT_SMPTE_25_S       equ (MCI_STRING_OFFSET + 26)
MCI_FORMAT_SMPTE_30_S       equ (MCI_STRING_OFFSET + 27)
MCI_FORMAT_SMPTE_30DROP_S   equ (MCI_STRING_OFFSET + 28)
MCI_FORMAT_BYTES_S          equ (MCI_STRING_OFFSET + 29)
MCI_FORMAT_SAMPLES_S        equ (MCI_STRING_OFFSET + 30)
MCI_FORMAT_TMSF_S           equ (MCI_STRING_OFFSET + 31)

MCI_VD_FORMAT_TRACK_S       equ (MCI_VD_OFFSET + 5)

WAVE_FORMAT_PCM_S           equ (MCI_WAVE_OFFSET + 0)
WAVE_MAPPER_S               equ (MCI_WAVE_OFFSET + 1)

MCI_SEQ_MAPPER_S            equ (MCI_SEQ_OFFSET + 5)
MCI_SEQ_FILE_S              equ (MCI_SEQ_OFFSET + 6)
MCI_SEQ_MIDI_S              equ (MCI_SEQ_OFFSET + 7)
MCI_SEQ_SMPTE_S             equ (MCI_SEQ_OFFSET + 8)
MCI_SEQ_FORMAT_SONGPTR_S    equ (MCI_SEQ_OFFSET + 9)
MCI_SEQ_NONE_S              equ (MCI_SEQ_OFFSET + 10)
MIDIMAPPER_S                equ (MCI_SEQ_OFFSET + 11)

; parameters for internal version of MCI_OPEN message sent from
; mciOpenDevice() to the driver
MCI_OPEN_DRIVER_PARMS struc
    mciodrv_wDeviceID           dw    ? ; device ID
    mciodrv_lpstrParams         dw    ? ; parameter string for entry in SYSTEM.INI
    mciodrv_wCustomCommandTable dw    ? ; custom command table (0FFFFh if none)
                                        ; filled in by the driver
    mciodrv_wType               dw    ? ; driver type filled in by the driver
MCI_OPEN_DRIVER_PARMS ends

; maximum length of an MCI device type
MCI_MAX_DEVICE_TYPE_LENGTH  equ 80

; flags for mciSendCommandInternal() which direct mciSendString() how to
; interpret the return value
MCI_RESOURCE_RETURNED       equ 00010000h  ; resource ID
MCI_COLONIZED3_RETURN       equ 00020000h  ; colonized ID, 3 bytes data
MCI_COLONIZED4_RETURN       equ 00040000h  ; colonized ID, 4 bytes data
MCI_INTEGER_RETURNED        equ 00080000h  ; integer conversion needed
MCI_RESOURCE_DRIVER         equ 00100000h  ; driver owns returned resource

; invalid command table ID
MCI_NO_COMMAND_TABLE        equ 0FFFFh

; command table information type tags
MCI_COMMAND_HEAD            equ 0
MCI_STRING                  equ 1
MCI_INTEGER                 equ 2
MCI_END_COMMAND             equ 3
MCI_RETURN                  equ 4
MCI_FLAG                    equ 5
MCI_END_COMMAND_LIST        equ 6
MCI_RECT                    equ 7
MCI_CONSTANT                equ 8
MCI_END_CONSTANT            equ 9

endif   ;ifndef MMNOMCIDEV


ifndef  MMNOTASKDEV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                              Task support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; error return values
TASKERR_NOTASKSUPPORT       equ 1
TASKERR_OUTOFMEMORY         equ 2

endif   ;ifndef MMNOTASKDEV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\model.inc ===
; ========================================================
;
; MODEL.INC
;
; Copyright (c) 1991 - Microsoft Corp.
; All rights reserved.
; Microsoft Confidential
;
;
; Include file which allows globally controlling the memory
; model of a library of assembly modules. Also contains
; macros for writing MASM 6.0 code which will compile
; under DOS 5.1.
;
;
; johnhe - 01-24-92
;
; ========================================================================
; Default to small memory model and C calling conventions if none
; were declared.
;
; ========================================================================


	; Convert old build switches to new type

IFDEF		MODEL_LARGE
  MEM_MODEL EQU <LARGE>
ELSEIFDEF	MODEL_MEDIUM
  MEM_MODEL EQU <MEDIUM> 
ELSEIFDEF	MODEL_COMPACT
  MEM_MODEL EQU <COMPACT>
ELSEIFDEF	MODEL_SMALL
  MEM_MODEL EQU <SMALL>
ENDIF


IFNDEF MEM_MODEL
  MEM_MODEL EQU <SMALL>
ENDIF

IFNDEF	CALL_TYPE
	CALL_TYPE EQU <C>
ENDIF

; ========================================================================
; The following defines the memory model based on one of four constants
; being defined. If none of the constants have been defined the model
; will default to MODEL_SMALL
; ========================================================================

DOSSEG

.MODEL	MEM_MODEL,CALL_TYPE


; ========================================================================
; This macro allows writing code which will assemble with MASM 5.1 or
; 6.0. MASM 6.0 requires an assume statement before using a register
; as the base pointer of a structure.
;
; RegPtr Register:STRUC, Register:STRUC, ...
;
; EXAMPLE:
;
;	RegPtr	DI:MyStruc
;
; ========================================================================

RegPtr MACRO  arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9

  IFB <arg1>
    %out <Assume Macro --> Requires at least 1 argument.>
  ENDIF

  IF @Version GE 600
    IRP X, <arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9>
      IFNB <x>
        ASSUME  x
      ENDIF
    ENDM
  ENDIF

ENDM

; ========================================================================
; Macro which exsplicitly calls a far or near procedure based on the
; current memory model.
;
; call_M PROCEDURE_NAME
;
; ========================================================================

call_M	MACRO	Function

IF 	@codesize			; Call adjusted for memory model

	call	FAR PTR Function	; FAR call if LARGE, MED, or HUGE
ELSE
	call	NEAR PTR Function	; Else NEAR call
ENDIF
ENDM

; ========================================================================
; DS_IF_DATASIZE
;
; Equate to allow DS to be pushed on entry to a function if ptrs are
; far. This macro should be used in conjunction with LoadPtr DS,x,x
; to ensure DS will be saved if its destroyed by a far ptr load.
;
; EXAMPLE:
;
; Function PROC USES DI SI ES FPTR_DS, Buffer:PTR, EndBuf:PTR
;
;	LoadPtr	ES,DI,EndBuf
;	LoadPTr	DS,SI,BUffer
;	...
; Function ENDP
;
; Function PROC USES_FPTR_DS, Buffer:PTR, EndBuf:PTR
;
;	LoadPtr	ES,DI,EndBuf
;	LoadPTr	DS,SI,BUffer
;	...
; Function ENDP
;
; ========================================================================

IF @DATASIZE
	FPTR_DS		EQU	<DS>
	USES_FPTR_DS	EQU	<USES DS>
	DS_IF_DATASIZE	EQU	<DS>
ELSE
	FPTR_DS EQU 		<>
	USES_FPTR_DS	EQU	<>
	DS_IF_DATASIZE	EQU	<>
ENDIF

; ========================================================================
; LoadPtr
;
;	Macro to load a pointer based on the memory model that is in use.
;	Argument checking is included in the macro and the appropriate
;	error message will be displayed.
;	
; LoadPtr MACRO vSegReg, vReg, vPtr
;
;	vSegReg		- Segment register (normally DS or ES but may be any)
;	vReg		- Any general purpose register (AX,BX,CX,DX,SI,DI)
;	vPtr		- Pointer to a memory location.
;			  The value will be treated as a dword ptr in
;			  LARGE/COMPACT model and word ptr in MEDIUM/SMALL.
;
; ========================================================================


LoadPtr MACRO vSegReg, vReg, vPtr

  SEG_OK = 0			;; Variables to specify different errors
  REG_OK = 0
  PTR_OK = 0

				;; Error checking on segment register
  IFNB <vSegReg>
    IRP x, <ES,DS,AX,BX,CX,DX,SI,DI>
      IFIDNI <x>,<vSegReg>
        SEG_OK = 1
      ENDIF
    ENDM 
  ENDIF

				;; Error checking on index register
  IFNB <vReg>
    IRP y, <AX,BX,CX,DX,SI,DI>
      IFIDNI <y>,<vReg>
        REG_OK = 1
      ENDIF
    ENDM 
  ENDIF

				;; Error checking on memory pointer
  IFNB <vPtr>
    PTR_OK = 1
  ENDIF

				;; If errs found display appropriate message
  IF (SEG_OK + REG_OK + PTR_OK) NE 3

    IF SEG_OK EQ 0
      %out <LoadPtr Macro --> Invalid segment register vSegReg was specified.>
    ENDIF

    IF REG_OK EQ 0
      %out <LoadPtr Macro --> Invalid register vReg was specified.>
    ENDIF

    IF PTR_OK EQ 0
      %out <LoadPtr Macro --> No memory pointer was specified.>
    ENDIF

    .ERR

  ELSE			;; Start of code in the macro since no errs found

    IF @DataSize	;; For LARGE & COMPACT models use LDS or LES  opcodes
			
      IFIDNI <vSegReg>,<DS>
        lds	vReg, vPtr
      ELSEIFIDNI <vSegReg>,<ES>
        les vReg, vPtr
      ELSE
        mov vSegReg, WORD PTR vPtr[2]
        mov vReg, WORD PTR vPtr
      ENDIF

    ELSE
			;; If vSegReg == ES we have to set ES to DATA SEG
      IFIDNI <vSegReg>,<ES>
        push	DS
        pop	ES
      ENDIF
			;; Load pointer into specified register
      mov  vReg, vPtr	

    ENDIF

  ENDIF

ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\moniker.h ===
/*****************************************************************************\
*                                                                             *
* moniker.h -  moniker and related interfaces and APIs			      *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#if !defined( _MONIKER_H_ )
#define _MONIKER_H_

#define MK_E_CONNECTMANUALLY        MK_E_FIRST
#define MK_E_EXCEEDEDDEADLINE       (MK_E_FIRST + 1)
#define MK_E_NEEDGENERIC            (MK_E_FIRST + 2)
#define MK_E_UNAVAILABLE            (MK_E_FIRST + 3)
#define MK_E_SYNTAX                 (MK_E_FIRST + 4)
#define MK_E_NOOBJECT               (MK_E_FIRST + 5)
#define MK_E_INVALIDEXTENSION       (MK_E_FIRST + 6)
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED (MK_E_FIRST + 7)
#define MK_E_NOTBINDABLE            (MK_E_FIRST + 8)
#define MK_E_NOTBOUND               (MK_E_FIRST + 9)
                            // called IBindCtx->RevokeObjectBound for an
                            // object which was not bound
#define MK_E_CANTOPENFILE           (MK_E_FIRST + 10)
#define MK_E_MUSTBOTHERUSER         (MK_E_FIRST + 11)
#define MK_E_NOINVERSE              (MK_E_FIRST + 12)
#define MK_E_NOSTORAGE              (MK_E_FIRST + 13)
#define MK_E_NOPREFIX               (MK_E_FIRST + 14)


// reserved                     MK_S_FIRST
// reserved                     (MK_S_FIRST + 1)
#define MK_S_REDUCED_TO_SELF    (MK_S_FIRST + 2)
// reserved                     (MK_S_FIRST + 3)
#define MK_S_ME                 (MK_S_FIRST + 4)
#define MK_S_HIM                (MK_S_FIRST + 5)
#define MK_S_US                 (MK_S_FIRST + 6)
#define MK_S_MONIKERALREADYREGISTERED (MK_S_FIRST + 7)


// bind options; variable sized
typedef struct FARSTRUCT tagBIND_OPTS
{
    DWORD       cbStruct;       //  sizeof(BIND_OPTS)
    DWORD       grfFlags;
    DWORD       grfMode;
    DWORD       dwTickCountDeadline;
} BIND_OPTS, FAR* LPBIND_OPTS;


// bind flags; controls binding; stored in bind options above
typedef enum
{
    BIND_MAYBOTHERUSER = 1,
    BIND_JUSTTESTEXISTENCE = 2
} BIND_FLAGS;


// system moniker types; returned from IsSystemMoniker.
typedef enum tagMKSYS
{
    MKSYS_NONE = 0,
    MKSYS_GENERICCOMPOSITE = 1,
    MKSYS_FILEMONIKER = 2,
    MKSYS_ANTIMONIKER = 3,
    MKSYS_ITEMMONIKER = 4,
    MKSYS_POINTERMONIKER = 5
}MKSYS;


// bit wise enum to control how much reduction takes place.
typedef enum tagMKREDUCE
{
    MKRREDUCE_ONE           =   3<<16,
    MKRREDUCE_TOUSER        =   2<<16,
    MKRREDUCE_THROUGHUSER   =   1<<16,
    MKRREDUCE_ALL           =   0
} MKRREDUCE;


#if defined(__cplusplus)
interface IEnumMoniker;
interface IRunningObjectTable;
#else 
typedef interface IEnumMoniker IEnumMoniker;
typedef interface IRunningObjectTable IRunningObjectTable;
#endif

typedef       IEnumMoniker FAR* LPENUMMONIKER;
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IBindCtx

DECLARE_INTERFACE_(IBindCtx, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBindCtx methods ***
    STDMETHOD(RegisterObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(RevokeObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(ReleaseBoundObjects) (THIS) PURE;
    
    STDMETHOD(SetBindOptions) (THIS_ LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetBindOptions) (THIS_ LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetRunningObjectTable) (THIS_ LPRUNNINGOBJECTTABLE  FAR*
        pprot) PURE;
    STDMETHOD(RegisterObjectParam) (THIS_ LPSTR lpszKey, LPUNKNOWN punk) PURE;
    STDMETHOD(GetObjectParam) (THIS_ LPSTR lpszKey, LPUNKNOWN FAR* ppunk) PURE;
    STDMETHOD(EnumObjectParam) (THIS_ LPENUMSTRING FAR* ppenum) PURE;
    STDMETHOD(RevokeObjectParam) (THIS_ LPSTR lpszKey) PURE;
};
typedef             IBindCtx FAR* LPBC;
typedef         IBindCtx FAR* LPBINDCTX;



#undef  INTERFACE
#define INTERFACE   IMoniker

DECLARE_INTERFACE_(IMoniker, IPersistStream)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize) PURE;

    // *** IMoniker methods ***
    STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riidResult, LPVOID FAR* ppvResult) PURE;
    STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD(Reduce) (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
        ppmkToLeft, LPMONIKER FAR * ppmkReduced) PURE;
    STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
        LPMONIKER FAR* ppmkComposite) PURE;
    STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
        PURE;
    STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker) PURE;
    STDMETHOD(Hash) (THIS_ LPDWORD pdwHash) PURE;
    STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
        pmkNewlyRunning) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        FILETIME FAR* pfiletime) PURE;
    STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(CommonPrefixWith) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkPrefix) PURE;
    STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkRelPath) PURE;
    STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPSTR lpszDisplayName, ULONG FAR* pchEaten,
        LPMONIKER FAR* ppmkOut) PURE;
    STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys) PURE;
};
typedef         IMoniker FAR* LPMONIKER;



#undef  INTERFACE
#define INTERFACE   IRunningObjectTable

DECLARE_INTERFACE_(IRunningObjectTable, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRunningObjectTable methods ***
    STDMETHOD(Register) (THIS_ DWORD grfFlags, LPUNKNOWN punkObject, 
        LPMONIKER pmkObjectName, DWORD FAR * pdwRegister) PURE;
    STDMETHOD(Revoke) (THIS_ DWORD dwRegister) PURE;
    STDMETHOD(IsRunning) (THIS_ LPMONIKER pmkObjectName) PURE;
    STDMETHOD(GetObject) (THIS_ LPMONIKER pmkObjectName,
        LPUNKNOWN FAR* ppunkObject) PURE;
    STDMETHOD(NoteChangeTime) (THIS_ DWORD dwRegister, FILETIME FAR * pfiletime) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPMONIKER pmkObjectName, FILETIME FAR * pfiletime) PURE;
    STDMETHOD(EnumRunning) (THIS_ LPENUMMONIKER FAR * ppenumMoniker ) PURE;
};
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IEnumMoniker

DECLARE_INTERFACE_(IEnumMoniker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOleDataObject methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPMONIKER FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumMoniker FAR* FAR* ppenm) PURE;
};
typedef       IEnumMoniker FAR* LPENUMMONIKER;




STDAPI  BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult, LPVOID FAR* ppvResult);
STDAPI  MkParseDisplayName(LPBC pbc, LPSTR szUserName, 
                ULONG FAR * pchEaten, LPMONIKER FAR * ppmk);
STDAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                FAR* ppmkRelPath, BOOL fCalledFromMethod);
STDAPI  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                LPMONIKER FAR* ppmkCommon);
STDAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc);
STDAPI  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
    LPMONIKER FAR* ppmkComposite);
STDAPI  GetClassFile (LPCSTR szFilename, CLSID FAR* pclsid);

STDAPI  CreateFileMoniker(LPSTR lpszPathName, LPMONIKER FAR* ppmk);
STDAPI  CreateItemMoniker(LPSTR lpszDelim, LPSTR lpszItem,
    LPMONIKER FAR* ppmk);
STDAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk);
STDAPI  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER FAR* ppmk);

STDAPI  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot);


#endif  // _MONIKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the
*   buffer (memory) manipulation routines.
*   [System V]
*
****/

#ifndef _INC_MEMORY

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 


/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
    int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
    size_t);
void * __cdecl memcpy(void *, const void *,
    size_t);
int __cdecl _memicmp(const void *, const void *,
    unsigned int);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
    int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
    size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
    unsigned int);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
    int, unsigned int);
int __cdecl memicmp(const void *, const void *,
    unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_MEMORY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\mmsystem.h ===
/*==========================================================================;
 *
 *  mmsystem.h -- Include file for Multimedia API's
 *
 *  Version 4.00
 *
 *  Copyright (C) 1992-1994 Microsoft Corporation.  All Rights Reserved.
 *
 *--------------------------------------------------------------------------;
 *
 *  Define:         Prevent inclusion of:
 *  --------------  --------------------------------------------------------
 *  MMNODRV         Installable driver support
 *  MMNOSOUND       Sound support
 *  MMNOWAVE        Waveform support
 *  MMNOMIDI        MIDI support
 *  MMNOAUX         Auxiliary audio support
 *  MMNOMIXER       Mixer support
 *  MMNOTIMER       Timer support
 *  MMNOJOY         Joystick support
 *  MMNOMCI         MCI support
 *  MMNOMMIO        Multimedia file I/O support
 *  MMNOMMSYSTEM    General MMSYSTEM functions
 *
 *==========================================================================;
 */

#ifndef _INC_MMSYSTEM
#define _INC_MMSYSTEM   /* #defined if mmsystem.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifdef WIN32
#define	WINMMAPI	DECLSPEC_IMPORT
#ifndef WINVER
#define WINVER  0x0400
#endif
#define _loadds
#define _huge
#else
#define	WINMMAPI
#ifndef LPCTSTR
#define LPCTSTR	LPCSTR
#endif
#ifndef LPTSTR
#define LPTSTR	LPSTR
#endif
#endif


/****************************************************************************

		    General constants and data types

****************************************************************************/


/* general constants */
#define MAXPNAMELEN      32     /* max product name length (including NULL) */
#define MAXERRORLENGTH   256    /* max error text length (including NULL) */


/*
 *  Microsoft Manufacturer and Product ID's (these have been moved to
 *  MMREG.H for Windows 4.00 and above).
 */
#if (WINVER <= 0x030A)
#ifndef MM_MICROSOFT
#define MM_MICROSOFT            1   /* Microsoft Corporation */
#endif

#ifndef MM_MIDI_MAPPER
#define MM_MIDI_MAPPER          1   /* MIDI Mapper */
#define MM_WAVE_MAPPER          2   /* Wave Mapper */
#define MM_SNDBLST_MIDIOUT      3   /* Sound Blaster MIDI output port */
#define MM_SNDBLST_MIDIIN       4   /* Sound Blaster MIDI input port */
#define MM_SNDBLST_SYNTH        5   /* Sound Blaster internal synthesizer */
#define MM_SNDBLST_WAVEOUT      6   /* Sound Blaster waveform output */
#define MM_SNDBLST_WAVEIN       7   /* Sound Blaster waveform input */
#define MM_ADLIB                9   /* Ad Lib-compatible synthesizer */
#define MM_MPU401_MIDIOUT      10   /* MPU401-compatible MIDI output port */
#define MM_MPU401_MIDIIN       11   /* MPU401-compatible MIDI input port */
#define MM_PC_JOYSTICK         12   /* Joystick adapter */
#endif
#endif



/* general data types */

#ifdef WIN32
typedef UINT        MMVERSION;  /* major (high byte), minor (low byte) */
#else
typedef UINT        VERSION;    /* major (high byte), minor (low byte) */
#endif
typedef UINT        MMRESULT;   /* error return code, 0 means no error */
				/* call as if(err=xxxx(...)) Error(err); else */
#define _MMRESULT_

typedef UINT FAR   *LPUINT;



/* MMTIME data structure */
typedef struct mmtime_tag
{
    UINT            wType;      /* indicates the contents of the union */
    union
    {
	DWORD       ms;         /* milliseconds */
	DWORD       sample;     /* samples */
	DWORD       cb;         /* byte count */
	DWORD       ticks;      /* ticks in MIDI stream */

	/* SMPTE */
	struct
	{
	    BYTE    hour;       /* hours */
	    BYTE    min;        /* minutes */
	    BYTE    sec;        /* seconds */
	    BYTE    frame;      /* frames  */
	    BYTE    fps;        /* frames per second */
	    BYTE    dummy;      /* pad */
	} smpte;

	/* MIDI */
	struct
	{
	    DWORD songptrpos;   /* song pointer position */
	} midi;
    } u;
} MMTIME, *PMMTIME, NEAR *NPMMTIME, FAR *LPMMTIME;

/* types for wType field in MMTIME struct */
#define TIME_MS         0x0001  /* time in milliseconds */
#define TIME_SAMPLES    0x0002  /* number of wave samples */
#define TIME_BYTES      0x0004  /* current byte offset */
#define TIME_SMPTE      0x0008  /* SMPTE time */
#define TIME_MIDI       0x0010  /* MIDI time */
#define TIME_TICKS      0x0020  /* Ticks within MIDI stream */


/*
 *
 *
 */
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
		((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
		((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))



/****************************************************************************

		    Multimedia Extensions Window Messages

****************************************************************************/

#define MM_JOY1MOVE         0x3A0           /* joystick */
#define MM_JOY2MOVE         0x3A1
#define MM_JOY1ZMOVE        0x3A2
#define MM_JOY2ZMOVE        0x3A3
#define MM_JOY1BUTTONDOWN   0x3B5
#define MM_JOY2BUTTONDOWN   0x3B6
#define MM_JOY1BUTTONUP     0x3B7
#define MM_JOY2BUTTONUP     0x3B8

#define MM_MCINOTIFY        0x3B9           /* MCI */

#define MM_WOM_OPEN         0x3BB           /* waveform output */
#define MM_WOM_CLOSE        0x3BC
#define MM_WOM_DONE         0x3BD

#define MM_WIM_OPEN         0x3BE           /* waveform input */
#define MM_WIM_CLOSE        0x3BF
#define MM_WIM_DATA         0x3C0

#define MM_MIM_OPEN         0x3C1           /* MIDI input */
#define MM_MIM_CLOSE        0x3C2
#define MM_MIM_DATA         0x3C3
#define MM_MIM_LONGDATA     0x3C4
#define MM_MIM_ERROR        0x3C5
#define MM_MIM_LONGERROR    0x3C6

#define MM_MOM_OPEN         0x3C7           /* MIDI output */
#define MM_MOM_CLOSE        0x3C8
#define MM_MOM_DONE         0x3C9

/* these are also in msvideo.h */
#ifndef MM_DRVM_OPEN
 #define MM_DRVM_OPEN       0x3D0           /* installable drivers */
 #define MM_DRVM_CLOSE      0x3D1
 #define MM_DRVM_DATA       0x3D2
 #define MM_DRVM_ERROR      0x3D3
#endif

/* these are used by msacm.h */
#define MM_STREAM_OPEN	    0x3D4
#define MM_STREAM_CLOSE	    0x3D5
#define MM_STREAM_DONE	    0x3D6
#define MM_STREAM_ERROR	    0x3D7

#if (WINVER >= 0x0400)
#define MM_MOM_POSITIONCB   0x3CA           /* Callback for PMSG_POSITIONCB */

#ifndef MM_MCISIGNAL
 #define MM_MCISIGNAL        0x3CB
#endif

#define MM_MIM_POLYDONE     0x3CE           /* PolyMsg in complete */

#define MM_SOUNDEVENT_DONE  0x3CF           /* sound event notifications */

#define MM_MIXM_LINE_CHANGE     0x3D0       /* mixer line change notify */
#define MM_MIXM_CONTROL_CHANGE  0x3D1       /* mixer control change notify */

#endif

/****************************************************************************

		String resource number bases (internal use)

****************************************************************************/

#define MMSYSERR_BASE          0
#define WAVERR_BASE            32
#define MIDIERR_BASE           64
#define TIMERR_BASE            96
#define JOYERR_BASE            160
#define MCIERR_BASE            256
#define MIXERR_BASE            1024

#define MCI_STRING_OFFSET      512
#define MCI_VD_OFFSET          1024
#define MCI_CD_OFFSET          1088
#define MCI_WAVE_OFFSET        1152
#define MCI_SEQ_OFFSET         1216

/****************************************************************************

			General error return values

****************************************************************************/

/* general error return values */
#define MMSYSERR_NOERROR      0                    /* no error */
#define MMSYSERR_ERROR        (MMSYSERR_BASE + 1)  /* unspecified error */
#define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  /* device ID out of range */
#define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  /* driver failed enable */
#define MMSYSERR_ALLOCATED    (MMSYSERR_BASE + 4)  /* device already allocated */
#define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  /* device handle is invalid */
#define MMSYSERR_NODRIVER     (MMSYSERR_BASE + 6)  /* no device driver present */
#define MMSYSERR_NOMEM        (MMSYSERR_BASE + 7)  /* memory allocation error */
#define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  /* function isn't supported */
#define MMSYSERR_BADERRNUM    (MMSYSERR_BASE + 9)  /* error value out of range */
#define MMSYSERR_INVALFLAG    (MMSYSERR_BASE + 10) /* invalid flag passed */
#define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) /* invalid parameter passed */
#if (WINVER >= 0x0400)
#define MMSYSERR_HANDLEBUSY   (MMSYSERR_BASE + 12) // handle being used
						   // simultaneously on another
						   // thread (eg callback)
#define MMSYSERR_INVALIDALIAS (MMSYSERR_BASE + 13) /* specified alias not found */
#define MMSYSERR_BADDB        (MMSYSERR_BASE + 14) /* bad registry database */
#define MMSYSERR_KEYNOTFOUND  (MMSYSERR_BASE + 15) /* registry key not found */
#define MMSYSERR_READERROR    (MMSYSERR_BASE + 16) /* registry read error */
#define MMSYSERR_WRITEERROR   (MMSYSERR_BASE + 17) /* registry write error */
#define MMSYSERR_DELETEERROR  (MMSYSERR_BASE + 18) /* registry delete error */
#define MMSYSERR_VALNOTFOUND  (MMSYSERR_BASE + 19) /* registry value not found */
#define MMSYSERR_LASTERROR    (MMSYSERR_BASE + 19) /* last error in range */
#else
#define MMSYSERR_LASTERROR    (MMSYSERR_BASE + 11) /* last error in range */
#endif


#if (WINVER < 0x030a) || defined(WIN32)
DECLARE_HANDLE(HDRVR);
#endif /* ifdef WINVER < 0x030a */

#ifndef MMNODRV
/****************************************************************************

			Installable driver support

****************************************************************************/

#ifdef WIN32
typedef struct DRVCONFIGINFOEX {
    DWORD   dwDCISize;
    LPCWSTR  lpszDCISectionName;
    LPCWSTR  lpszDCIAliasName;
    DWORD    dnDevNode;
} DRVCONFIGINFOEX, *PDRVCONFIGINFOEX, NEAR *NPDRVCONFIGINFOEX, FAR *LPDRVCONFIGINFOEX;

#else
typedef struct DRVCONFIGINFOEX {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
    DWORD    dnDevNode;
} DRVCONFIGINFOEX, *PDRVCONFIGINFOEX, NEAR *NPDRVCONFIGINFOEX, FAR *LPDRVCONFIGINFOEX;
#endif

#if (WINVER < 0x030a) || defined(WIN32)

#ifndef DRV_LOAD

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_POWER               0x000F
#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
#ifdef WIN32
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCWSTR  lpszDCISectionName;
    LPCWSTR  lpszDCIAliasName;
} DRVCONFIGINFO, *PDRVCONFIGINFO, NEAR *NPDRVCONFIGINFO, FAR *LPDRVCONFIGINFO;
#else
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO, *PDRVCONFIGINFO, NEAR *NPDRVCONFIGINFO, FAR *LPDRVCONFIGINFO;
#endif

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL           0x0000
#define DRVCNF_OK               0x0001
#define DRVCNF_RESTART          0x0002

/* installable driver function prototypes */
#ifdef WIN32

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

WINMMAPI LRESULT   WINAPI CloseDriver(HDRVR hDriver, LONG lParam1, LONG lParam2);
WINMMAPI HDRVR     WINAPI OpenDriver(LPCWSTR szDriverName, LPCWSTR szSectionName, LONG lParam2);
WINMMAPI LRESULT   WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LONG lParam1, LONG lParam2);
WINMMAPI LRESULT   WINAPI DrvSendMessage(HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
WINMMAPI HMODULE   WINAPI DrvGetModuleHandle(HDRVR hDriver);
WINMMAPI HMODULE   WINAPI GetDriverModuleHandle(HDRVR hDriver);
WINMMAPI LRESULT   WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
#else
LRESULT   WINAPI DrvClose(HDRVR hdrvr, LPARAM lParam1, LPARAM lParam2);
HDRVR     WINAPI DrvOpen(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT   WINAPI DrvSendMessage(HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
HINSTANCE WINAPI DrvGetModuleHandle(HDRVR hdrvr);
LRESULT   WINAPI DrvDefDriverProc(DWORD dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
#define DefDriverProc DrvDefDriverProc
#endif /* ifdef WIN32 */
#endif /* DRV_LOAD */
#endif /* ifdef (WINVER < 0x030a) || defined(WIN32) */

#if (WINVER >= 0x030a)
/* return values from DriverProc() function */
#define DRV_CANCEL             DRVCNF_CANCEL
#define DRV_OK                 DRVCNF_OK
#define DRV_RESTART            DRVCNF_RESTART

#endif /* ifdef WINVER >= 0x030a */

#define DRV_MCI_FIRST          DRV_RESERVED
#define DRV_MCI_LAST           (DRV_RESERVED + 0xFFF)

#endif  /* ifndef MMNODRV */


/****************************************************************************

			  Driver callback support

****************************************************************************/

/* flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and */
/* midiOutOpen() to specify the type of the dwCallback parameter. */

#define CALLBACK_TYPEMASK   0x00070000l    /* callback type mask */
#define CALLBACK_NULL       0x00000000l    /* no callback */
#define CALLBACK_WINDOW     0x00010000l    /* dwCallback is a HWND */
#define CALLBACK_TASK       0x00020000l    /* dwCallback is a HTASK */
#define CALLBACK_FUNCTION   0x00030000l    /* dwCallback is a FARPROC */
#ifdef WIN32
#define CALLBACK_THREAD     (CALLBACK_TASK) /* thread ID replaces 16 bit task */
#define CALLBACK_EVENT      0x00050000l    /* dwCallback is an EVENT */
#endif


/* driver callback prototypes */
typedef void (CALLBACK DRVCALLBACK)(HDRVR hdrvr, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef DRVCALLBACK FAR *LPDRVCALLBACK;


#ifndef MMNOMMSYSTEM
/****************************************************************************

		    General MMSYSTEM support

****************************************************************************/

WINMMAPI UINT WINAPI mmsystemGetVersion(void);
#ifdef WIN32
#define OutputDebugStr  OutputDebugString
#else
void WINAPI OutputDebugStr(LPCSTR);
#endif

#endif  /* ifndef MMNOMMSYSTEM */


#ifndef MMNOSOUND
/****************************************************************************

			    Sound support

****************************************************************************/

#ifdef WIN32
WINMMAPI BOOL WINAPI sndPlaySoundA(LPCSTR pszSound, UINT fuSound);
WINMMAPI BOOL WINAPI sndPlaySoundW(LPCWSTR pszSound, UINT fuSound);
#ifdef UNICODE
#define sndPlaySound    sndPlaySoundW
#else
#define sndPlaySound    sndPlaySoundA
#endif
#else
BOOL WINAPI sndPlaySound(LPCSTR pszSound, UINT fuSound);
#endif

/*
 *  flag values for fuSound and fdwSound arguments on [snd]PlaySound
 */
#define SND_SYNC            0x0000  /* play synchronously (default) */
#define SND_ASYNC           0x0001  /* play asynchronously */
#define SND_NODEFAULT       0x0002  /* silence (!default) if sound not found */
#define SND_MEMORY          0x0004  /* pszSound points to a memory file */
#define SND_LOOP            0x0008  /* loop the sound until next sndPlaySound */
#define SND_NOSTOP          0x0010  /* don't stop any currently playing sound */


#if (WINVER >= 0x0400)
/*  the following flags are only supported by PlaySound.	*/
#define SND_PURGE           0x0040  /* purge non-static events for task */
#define SND_APPLICATION     0x0080  /* look for application specific association */

#define SND_NOWAIT	0x00002000L /* don't wait if the driver is busy */
#define SND_ALIAS       0x00010000L /* name is a registry alias */
#define SND_ALIAS_ID	0x00110000L /* alias is a predefined ID */
#define SND_FILENAME    0x00020000L /* name is file name */
#define SND_RESOURCE    0x00040004L /* name is resource name or atom */

#define SND_ALIAS_START	0           /* alias base */
#define	sndAlias(ch0, ch1)	(SND_ALIAS_START + (DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8))

/*
 *
 */
#ifdef WIN32
WINMMAPI BOOL WINAPI PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
WINMMAPI BOOL WINAPI PlaySoundW(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound);
#ifdef UNICODE
#define PlaySound       PlaySoundW
#else
#define PlaySound       PlaySoundA
#endif
#else
BOOL WINAPI PlaySound(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
#endif
#endif





#endif  /* ifndef MMNOSOUND */

#ifndef MMNOWAVE
/****************************************************************************

			Waveform audio support

****************************************************************************/

/* waveform audio error return values */
#define WAVERR_BADFORMAT      (WAVERR_BASE + 0)    /* unsupported wave format */
#define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    /* still something playing */
#define WAVERR_UNPREPARED     (WAVERR_BASE + 2)    /* header not prepared */
#define WAVERR_SYNC           (WAVERR_BASE + 3)    /* device is synchronous */
#define WAVERR_LASTERROR      (WAVERR_BASE + 3)    /* last error in range */

/* waveform audio data types */
DECLARE_HANDLE(HWAVE);
DECLARE_HANDLE(HWAVEIN);
DECLARE_HANDLE(HWAVEOUT);
typedef HWAVEIN FAR *LPHWAVEIN;
typedef HWAVEOUT FAR *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK FAR *LPWAVECALLBACK;

/* wave callback messages */
#define WOM_OPEN        MM_WOM_OPEN
#define WOM_CLOSE       MM_WOM_CLOSE
#define WOM_DONE        MM_WOM_DONE
#define WIM_OPEN        MM_WIM_OPEN
#define WIM_CLOSE       MM_WIM_CLOSE
#define WIM_DATA        MM_WIM_DATA

/* device ID for wave device mapper */
#define WAVE_MAPPER     ((UINT)-1)

/* flags for dwFlags parameter in waveOutOpen() and waveInOpen() */
#define  WAVE_FORMAT_QUERY     0x0001
#define  WAVE_ALLOWSYNC        0x0002
#if (WINVER >= 0x0400)
#define  WAVE_MAPPED           0x0004
#endif


/* wave data block header */
typedef struct wavehdr_tag {
    LPSTR       lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* length of data buffer */
    DWORD       dwBytesRecorded;        /* used for input only */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwLoops;                /* loop control counter */
    struct wavehdr_tag FAR *lpNext;     /* reserved for driver */
    DWORD       reserved;               /* reserved for driver */
} WAVEHDR, *PWAVEHDR, NEAR *NPWAVEHDR, FAR *LPWAVEHDR;

/* flags for dwFlags field of WAVEHDR */
#define WHDR_DONE       0x00000001  /* done bit */
#define WHDR_PREPARED   0x00000002  /* set if this header has been prepared */
#define WHDR_BEGINLOOP  0x00000004  /* loop start block */
#define WHDR_ENDLOOP    0x00000008  /* loop end block */
#define WHDR_INQUEUE    0x00000010  /* reserved for driver */


/* waveform output device capabilities structure */
#ifdef WIN32
typedef struct tagWAVEOUTCAPSA {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPSA, *PWAVEOUTCAPSA, *NPWAVEOUTCAPSA, *LPWAVEOUTCAPSA;
typedef struct tagWAVEOUTCAPSW {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPSW, *PWAVEOUTCAPSW, *NPWAVEOUTCAPSW, *LPWAVEOUTCAPSW;
#ifdef UNICODE
typedef WAVEOUTCAPSW WAVEOUTCAPS, *PWAVEOUTCAPS, *NPWAVEOUTCAPS, *LPWAVEOUTCAPS;
#else
typedef WAVEOUTCAPSA WAVEOUTCAPS, *PWAVEOUTCAPS, *NPWAVEOUTCAPS, *LPWAVEOUTCAPS;
#endif
#else
typedef struct waveoutcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPS, *PWAVEOUTCAPS, NEAR *NPWAVEOUTCAPS, FAR *LPWAVEOUTCAPS;
#endif

/* flags for dwSupport field of WAVEOUTCAPS */
#define WAVECAPS_PITCH          0x0001   /* supports pitch control */
#define WAVECAPS_PLAYBACKRATE   0x0002   /* supports playback rate control */
#define WAVECAPS_VOLUME         0x0004   /* supports volume control */
#define WAVECAPS_LRVOLUME       0x0008   /* separate left-right volume control */
#define WAVECAPS_SYNC           0x0010


/* waveform input device capabilities structure */
#ifdef WIN32
typedef struct tagWAVEINCAPSA {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    MMVERSION vDriverVersion;        /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
} WAVEINCAPSA, *PWAVEINCAPSA, *NPWAVEINCAPSA, *LPWAVEINCAPSA;
typedef struct tagWAVEINCAPSW {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    MMVERSION vDriverVersion;        /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
} WAVEINCAPSW, *PWAVEINCAPSW, *NPWAVEINCAPSW, *LPWAVEINCAPSW;
#ifdef UNICODE
typedef WAVEINCAPSW WAVEINCAPS, *PWAVEINCAPS, *NPWAVEINCAPS, *LPWAVEINCAPS;
#else
typedef WAVEINCAPSA WAVEINCAPS, *PWAVEINCAPS, *NPWAVEINCAPS, *LPWAVEINCAPS;
#endif
#else
typedef struct waveincaps_tag {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    VERSION vDriverVersion;          /* version of the driver */
    char    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
} WAVEINCAPS, *PWAVEINCAPS, NEAR *NPWAVEINCAPS, FAR *LPWAVEINCAPS;
#endif

/* defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS */
#define WAVE_INVALIDFORMAT     0x00000000       /* invalid format */
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */


/* OLD general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo, etc.) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT, *PWAVEFORMAT, NEAR *NPWAVEFORMAT, FAR *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1


/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT, *PPCMWAVEFORMAT, NEAR *NPPCMWAVEFORMAT, FAR *LPPCMWAVEFORMAT;

#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_

/*
 *  extended waveform format structure used for all non-PCM formats. this
 *  structure is common to all non-PCM formats.
 */
typedef struct tWAVEFORMATEX
{
    WORD        wFormatTag;         /* format type */
    WORD        nChannels;          /* number of channels (i.e. mono, stereo...) */
    DWORD       nSamplesPerSec;     /* sample rate */
    DWORD       nAvgBytesPerSec;    /* for buffer estimation */
    WORD        nBlockAlign;        /* block size of data */
    WORD        wBitsPerSample;     /* number of bits per sample of mono data */
    WORD        cbSize;             /* the count in bytes of the size of */
				    /* extra information (after cbSize) */
} WAVEFORMATEX, *PWAVEFORMATEX, NEAR *NPWAVEFORMATEX, FAR *LPWAVEFORMATEX;

#endif /* _WAVEFORMATEX_ */

/* waveform audio function prototypes */
WINMMAPI UINT WINAPI waveOutGetNumDevs(void);
#ifdef WIN32
WINMMAPI MMRESULT WINAPI waveOutGetDevCapsA(UINT uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc);
WINMMAPI MMRESULT WINAPI waveOutGetDevCapsW(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc);
#ifdef UNICODE
#define waveOutGetDevCaps       waveOutGetDevCapsW
#else
#define waveOutGetDevCaps       waveOutGetDevCapsA
#endif
#else
WINMMAPI MMRESULT WINAPI waveOutGetDevCaps(UINT uDeviceID, LPWAVEOUTCAPS pwoc, UINT cbwoc);
#endif
#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI waveOutGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume);
#else
WINMMAPI MMRESULT WINAPI waveOutGetVolume(UINT uId, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI waveOutSetVolume(UINT uId, DWORD dwVolume);
#endif
#ifdef WIN32
WINMMAPI MMRESULT WINAPI waveOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI waveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define waveOutGetErrorText     waveOutGetErrorTextW
#else
#define waveOutGetErrorText     waveOutGetErrorTextA
#endif
#else
MMRESULT WINAPI waveOutGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif
#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID,
    const WAVEFORMATEX FAR* pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
#else
WINMMAPI MMRESULT WINAPI waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID,
    const WAVEFORMAT FAR* pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
#endif
WINMMAPI MMRESULT WINAPI waveOutClose(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutPause(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutRestart(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutReset(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutBreakLoop(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutGetPosition(HWAVEOUT hwo, LPMMTIME pmmt, UINT cbmmt);
WINMMAPI MMRESULT WINAPI waveOutGetPitch(HWAVEOUT hwo, LPDWORD pdwPitch);
WINMMAPI MMRESULT WINAPI waveOutSetPitch(HWAVEOUT hwo, DWORD dwPitch);
WINMMAPI MMRESULT WINAPI waveOutGetPlaybackRate(HWAVEOUT hwo, LPDWORD pdwRate);
WINMMAPI MMRESULT WINAPI waveOutSetPlaybackRate(HWAVEOUT hwo, DWORD dwRate);
WINMMAPI MMRESULT WINAPI waveOutGetID(HWAVEOUT hwo, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
WINMMAPI DWORD WINAPI waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

WINMMAPI UINT WINAPI waveInGetNumDevs(void);
#ifdef WIN32
WINMMAPI MMRESULT WINAPI waveInGetDevCapsA(UINT uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic);
WINMMAPI MMRESULT WINAPI waveInGetDevCapsW(UINT uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic);
#ifdef UNICODE
#define waveInGetDevCaps        waveInGetDevCapsW
#else
#define waveInGetDevCaps        waveInGetDevCapsA
#endif
#else
MMRESULT WINAPI waveInGetDevCaps(UINT uDeviceID, LPWAVEINCAPS pwic, UINT cbwic);
#endif
#ifdef WIN32
WINMMAPI MMRESULT WINAPI waveInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI waveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define waveInGetErrorText      waveInGetErrorTextW
#else
#define waveInGetErrorText      waveInGetErrorTextA
#endif
#else
MMRESULT WINAPI waveInGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif
#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI waveInOpen(LPHWAVEIN phwi, UINT uDeviceID,
    const WAVEFORMATEX FAR* pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
#else
WINMMAPI MMRESULT WINAPI waveInOpen(LPHWAVEIN phwi, UINT uDeviceID,
    const WAVEFORMAT FAR* pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
#endif
WINMMAPI MMRESULT WINAPI waveInClose(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInStart(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInStop(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInReset(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInGetPosition(HWAVEIN hwi, LPMMTIME pmmt, UINT cbmmt);
WINMMAPI MMRESULT WINAPI waveInGetID(HWAVEIN hwi, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
WINMMAPI DWORD WINAPI waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

#endif  /* ifndef MMNOWAVE */


#ifndef MMNOMIDI
/****************************************************************************

			    MIDI audio support

****************************************************************************/

/* MIDI error return values */
#define MIDIERR_UNPREPARED    (MIDIERR_BASE + 0)   /* header not prepared */
#define MIDIERR_STILLPLAYING  (MIDIERR_BASE + 1)   /* still something playing */
#define MIDIERR_NOMAP         (MIDIERR_BASE + 2)   /* no configured instruments */
#define MIDIERR_NOTREADY      (MIDIERR_BASE + 3)   /* hardware is still busy */
#define MIDIERR_NODEVICE      (MIDIERR_BASE + 4)   /* port no longer connected */
#define MIDIERR_INVALIDSETUP  (MIDIERR_BASE + 5)   /* invalid MIF */
#define MIDIERR_BADOPENMODE   (MIDIERR_BASE + 6)   /* operation unsupported w/ open mode */
#define MIDIERR_LASTERROR     (MIDIERR_BASE + 6)   /* last error in range */

/* MIDI audio data types */
DECLARE_HANDLE(HMIDI);
DECLARE_HANDLE(HMIDIIN);
DECLARE_HANDLE(HMIDIOUT);
typedef HMIDIIN FAR *LPHMIDIIN;
typedef HMIDIOUT FAR *LPHMIDIOUT;
typedef DRVCALLBACK MIDICALLBACK;
typedef MIDICALLBACK FAR *LPMIDICALLBACK;
#define MIDIPATCHSIZE   128
typedef WORD PATCHARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPPATCHARRAY;
typedef WORD KEYARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPKEYARRAY;

/* MIDI callback messages */
#define MIM_OPEN        MM_MIM_OPEN
#define MIM_CLOSE       MM_MIM_CLOSE
#define MIM_DATA        MM_MIM_DATA
#define MIM_LONGDATA    MM_MIM_LONGDATA
#define MIM_ERROR       MM_MIM_ERROR
#define MIM_LONGERROR   MM_MIM_LONGERROR
#if (WINVER >= 0x0400)
#define MIM_POLYDONE    MM_MIM_POLYDONE
#endif
#define MOM_OPEN        MM_MOM_OPEN
#define MOM_CLOSE       MM_MOM_CLOSE
#define MOM_DONE        MM_MOM_DONE

/* device ID for MIDI mapper */
#define MIDIMAPPER     ((UINT)-1)
#define MIDI_MAPPER    ((UINT)-1)

#if (WINVER >= 0x0400)
/* flags for dwFlags parm of midiInOpen() */
#define MIDI_IO_PACKED      0x00000000L     /* Compatibility mode */
#define MIDI_IO_RAW         0x00000001L
#define MIDI_IO_COOKED      0x00000002L
#define MIDI_IO_MAPPED      0x00000004L
#define MIDI_IO_CONTROL     0x00000008L
#endif

/* flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches() */                             
#define MIDI_CACHE_ALL      1                            
#define MIDI_CACHE_BESTFIT  2                            
#define MIDI_CACHE_QUERY    3                            
#define MIDI_UNCACHE        4                            


/* MIDI output device capabilities structure */
#ifdef WIN32
typedef struct tagMIDIOUTCAPSA {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPSA, *PMIDIOUTCAPSA, *NPMIDIOUTCAPSA, *LPMIDIOUTCAPSA;
typedef struct tagMIDIOUTCAPSW {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPSW, *PMIDIOUTCAPSW, *NPMIDIOUTCAPSW, *LPMIDIOUTCAPSW;
#ifdef UNICODE
typedef MIDIOUTCAPSW MIDIOUTCAPS, *PMIDIOUTCAPS, *NPMIDIOUTCAPS, *LPMIDIOUTCAPS;
#else
typedef MIDIOUTCAPSA MIDIOUTCAPS, *PMIDIOUTCAPS, *NPMIDIOUTCAPS, *LPMIDIOUTCAPS;
#endif
#else
typedef struct midioutcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS, *PMIDIOUTCAPS, NEAR *NPMIDIOUTCAPS, FAR *LPMIDIOUTCAPS;
#endif

/* flags for wTechnology field of MIDIOUTCAPS structure */
#define MOD_MIDIPORT    1  /* output port */
#define MOD_SYNTH       2  /* generic internal synth */
#define MOD_SQSYNTH     3  /* square wave internal synth */
#define MOD_FMSYNTH     4  /* FM internal synth */
#define MOD_MAPPER      5  /* MIDI mapper */

/* flags for dwSupport field of MIDIOUTCAPS structure */
#define MIDICAPS_VOLUME          0x0001  /* supports volume control */
#define MIDICAPS_LRVOLUME        0x0002  /* separate left-right volume control */
#define MIDICAPS_CACHE           0x0004  
#if (WINVER >= 0x0400)
#define MIDICAPS_POLYMSG         0x0008  /* driver supports midiOutPolyMsg directly */
#endif


/* MIDI output device capabilities structure */
#ifdef WIN32
typedef struct tagMIDIINCAPSA {
    WORD        wMid;                   // manufacturer ID
    WORD        wPid;                   // product ID
    MMVERSION   vDriverVersion;         // version of the driver
    CHAR        szPname[MAXPNAMELEN];   // product name (NULL terminated string)
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPSA, *PMIDIINCAPSA, *NPMIDIINCAPSA, *LPMIDIINCAPSA;
typedef struct tagMIDIINCAPSW {
    WORD        wMid;                   // manufacturer ID
    WORD        wPid;                   // product ID
    MMVERSION   vDriverVersion;         // version of the driver
    WCHAR       szPname[MAXPNAMELEN];   // product name (NULL terminated string)
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPSW, *PMIDIINCAPSW, *NPMIDIINCAPSW, *LPMIDIINCAPSW;
#ifdef UNICODE
typedef MIDIINCAPSW MIDIINCAPS, *PMIDIINCAPS, *NPMIDIINCAPS, *LPMIDIINCAPS;
#else
typedef MIDIINCAPSA MIDIINCAPS, *PMIDIINCAPS, *NPMIDIINCAPS, *LPMIDIINCAPS;
#endif
#else
typedef struct midiincaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPS, *PMIDIINCAPS, NEAR *NPMIDIINCAPS, FAR *LPMIDIINCAPS;
#endif


/* MIDI data block header */
typedef struct midihdr_tag {
    LPSTR       lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    DWORD       dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    struct midihdr_tag far *lpNext;   /* reserved for driver */
    DWORD       reserved;             /* reserved for driver */
} MIDIHDR, *PMIDIHDR, NEAR *NPMIDIHDR, FAR *LPMIDIHDR;

/* flags for dwFlags field of MIDIHDR structure */
#define MHDR_DONE       0x00000001       /* done bit */
#define MHDR_PREPARED   0x00000002       /* set if header prepared */
#define MHDR_INQUEUE    0x00000004       /* reserved for driver */
#define MHDR_ISPOLY     0x00000008       /* Buffer is polymsg buffer */
#define MHDR_CHANIGNORE 0xFFFF0000       /* Ignore channels 1-16 */

#if (WINVER >= 0x0400)
//
// Type codes which go in the high byte of the event DWORD of a polymsg buffer
//
// Type codes 00-7F contain parameters within the low 24 bits
// Type codes 80-FF contain a length of their parameter in the low 24
// bits, followed by their parameter data in the buffer. The event
// DWORD contains the exact byte length; the parm data itself must be
// padded to be an even multiple of 4 bytes long.
//
#define PMSG_EVENTTYPE(x)   ((BYTE)(((x)>>24)&0xFF))
#define PMSG_EVENTPARM(x)   ((DWORD)((x)&0x00FFFFFFL))

#define PMSG_SHORTMSG       ((BYTE)0x00)    /* parm = shortmsg for midiOutShortMsg */
#define PMSG_TEMPO          ((BYTE)0x01)    /* parm = new tempo in microsec/qn     */
#define PMSG_NOP            ((BYTE)0x02)    /* parm = unused; does nothing         */
#define PMSG_ENDOFBUFFER    ((BYTE)0x03)    /* parm = unused; flags end of buffer  */
// 0x04-0x7F reserved

#define PMSG_LENGTHEVENT    ((BYTE)0x80)    /* This event stores length            */
#define PMSG_LONGMSG        ((BYTE)0x80)    /* parm = bytes to send verbatim       */
#define PMSG_POSITIONCB     ((BYTE)0x81)    /* parm = 1 DWORD of user callback     */         
// 0x81-0xFF reserved

#define PMSG_PACKSTART      (0x0100)        /* Special for midiOutPack             */


typedef struct midipackitem_tag
{
    DWORD   cbStruct;
    DWORD   dwDelta;
    DWORD   dwEvent;
    union
    {
	//
	// These are just packed in the low 24 bits of the short event
	//
	DWORD   dwShortMsg;     // PMSG_SHORTMSG
	DWORD   dwTempo;        // PMSG_TEMPO

	//
	// A generic long event
	//
	struct 
	{
	    DWORD   cbLongMsg;
	    LPBYTE  lpLongMsg;
	} longmsg;              // PMSG_LONGMSG

	//
	// !!! This one is special !!! Since we need to guarantee passing
	// a whole 32 bit userdata, it is packed as a long event
	//
	// 0x81000004L      Long event, type=0x81, length=4 bytes
	// 0x00C70042L      32 bits of user callback data (pointer, etc.)
	//
	DWORD   dwUserData;     // PMSG_POSITIONCB

	//
	// Generic for as-yet unassigned short & long events
	//
	DWORD   dwShortEventParm;
	struct 
	{
	    DWORD   cbLongEvent;
	    LPBYTE  lpLongEvent;
	}   longevent;
    } event;
} MIDIPACKITEM, FAR *LPMIDIPACKITEM;

//
// Structures and defines for midiStreamProperty
//
#define MIDIPROP_SET        0x80000000L
#define MIDIPROP_GET        0x40000000L

// These are intentionally both non-zero so the app cannot accidentally
// leave the operation off and happen to appear to work due to default
// action.

#define MIDIPROP_TIMEDIV    0x00000001L
#define MIDIPROP_TEMPO      0x00000002L
#define MIDIPROP_CBTIMEOUT  0x00000003L

typedef struct midiproptimediv_tag
{
    DWORD       cbStruct;
    DWORD       dwTimeDiv;
} MIDIPROPTIMEDIV, FAR *LPMIDIPROPTIMEDIV;

typedef struct midiproptempo_tag
{
    DWORD       cbStruct;
    DWORD       dwTempo;
} MIDIPROPTEMPO, FAR *LPMIDIPROPTEMPO;

typedef struct midipropcbtimeout_tag
{
    DWORD       cbStruct;
    DWORD       dwTimeout;
} MIDIPROPCBTIMEOUT, FAR *LPMIDIPROPCBTIMEOUT;


#endif

/* MIDI function prototypes */
WINMMAPI UINT WINAPI midiOutGetNumDevs(void);
#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI midiStreamProperty(HMIDI hm, LPBYTE lppropdata, DWORD dwProperty);
#endif

#ifdef WIN32
WINMMAPI MMRESULT WINAPI midiOutGetDevCapsA(UINT uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc);
WINMMAPI MMRESULT WINAPI midiOutGetDevCapsW(UINT uDeviceID, LPMIDIOUTCAPSW pmoc, UINT cbmoc);
#ifdef UNICODE
#define midiOutGetDevCaps       midiOutGetDevCapsW
#else
#define midiOutGetDevCaps       midiOutGetDevCapsA
#endif
#else
MMRESULT WINAPI midiOutGetDevCaps(UINT uDeviceID, LPMIDIOUTCAPS pmoc, UINT cbmoc);
#endif
#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume);
#else
WINMMAPI MMRESULT WINAPI midiOutGetVolume(UINT uId, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI midiOutSetVolume(UINT uId, DWORD dwVolume);
#endif
#ifdef WIN32
WINMMAPI MMRESULT WINAPI midiOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI midiOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define midiOutGetErrorText     midiOutGetErrorTextW
#else
#define midiOutGetErrorText     midiOutGetErrorTextA
#endif
#else
WINMMAPI MMRESULT WINAPI midiOutGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif
WINMMAPI MMRESULT WINAPI midiOutOpen(LPHMIDIOUT phmo, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiOutClose(HMIDIOUT hmo);
WINMMAPI MMRESULT WINAPI midiOutPrepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutUnprepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutShortMsg(HMIDIOUT hmo, DWORD dwMsg);
WINMMAPI MMRESULT WINAPI midiOutLongMsg(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutReset(HMIDIOUT hmo);
WINMMAPI MMRESULT WINAPI midiOutCachePatches(HMIDIOUT hmo, UINT uBank, LPWORD pwpa, UINT fuCache);
WINMMAPI MMRESULT WINAPI midiOutCacheDrumPatches(HMIDIOUT hmo, UINT uPatch, LPWORD pwkya, UINT fuCache);
WINMMAPI MMRESULT WINAPI midiOutGetID(HMIDIOUT hmo, LPUINT puDeviceID);

#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI midiOutPolyMsg(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutPack(LPMIDIHDR pmh, UINT cbmh, const MIDIPACKITEM FAR* pmpi);
WINMMAPI MMRESULT WINAPI midiOutGetPosition(HMIDIOUT hmo, LPMMTIME lpmmt, UINT cbmmt);
WINMMAPI MMRESULT WINAPI midiOutPause(HMIDIOUT hmo);
WINMMAPI MMRESULT WINAPI midiOutRestart(HMIDIOUT hmo);
WINMMAPI MMRESULT WINAPI midiOutStop(HMIDIOUT hmo);
#endif

#if (WINVER >= 0x030a)
WINMMAPI DWORD WINAPI midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

WINMMAPI UINT WINAPI midiInGetNumDevs(void);
#ifdef WIN32
WINMMAPI MMRESULT WINAPI midiInGetDevCapsA(UINT uDeviceID, LPMIDIINCAPSA pmic, UINT cbmic);
WINMMAPI MMRESULT WINAPI midiInGetDevCapsW(UINT uDeviceID, LPMIDIINCAPSW pmic, UINT cbmic);
#ifdef UNICODE
#define midiInGetDevCaps        midiInGetDevCapsW
#else
#define midiInGetDevCaps        midiInGetDevCapsA
#endif
#else
MMRESULT WINAPI midiInGetDevCaps(UINT uDeviceID, LPMIDIINCAPS pmic, UINT cbmic);
#endif
#ifdef WIN32
WINMMAPI MMRESULT WINAPI midiInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI midiInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define midiInGetErrorText      midiInGetErrorTextW
#else
#define midiInGetErrorText      midiInGetErrorTextA
#endif
#else
WINMMAPI MMRESULT WINAPI midiInGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif
WINMMAPI MMRESULT WINAPI midiInOpen(LPHMIDIIN phmi, UINT uDeviceID,
	DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiInClose(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInPrepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInUnprepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInAddBuffer(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInStart(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInStop(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInReset(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInGetID(HMIDIIN hmi, LPUINT puDeviceID);

#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI midiInGetPosition(HMIDIIN hmi, LPMMTIME lpmmt, UINT cbmmt);
#endif

#if (WINVER >= 0x030a)
WINMMAPI DWORD WINAPI midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */


#endif  /* ifndef MMNOMIDI */


#ifndef MMNOAUX
/****************************************************************************

			Auxiliary audio support

****************************************************************************/

/* device ID for aux device mapper */
#define AUX_MAPPER     ((UINT)-1)


/* Auxiliary audio device capabilities structure */
#ifdef WIN32
typedef struct tagAUXCAPSA {
    WORD        wMid;                /* manufacturer ID */
    WORD        wPid;                /* product ID */
    MMVERSION   vDriverVersion;      /* version of the driver */
    CHAR        szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    WORD        wTechnology;         /* type of device */
    DWORD       dwSupport;           /* functionality supported by driver */
} AUXCAPSA, *PAUXCAPSA, *NPAUXCAPSA, *LPAUXCAPSA;
typedef struct tagAUXCAPSW {
    WORD        wMid;                /* manufacturer ID */
    WORD        wPid;                /* product ID */
    MMVERSION   vDriverVersion;      /* version of the driver */
    WCHAR       szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    WORD        wTechnology;         /* type of device */
    DWORD       dwSupport;           /* functionality supported by driver */
} AUXCAPSW, *PAUXCAPSW, *NPAUXCAPSW, *LPAUXCAPSW;
#ifdef UNICODE
typedef AUXCAPSW AUXCAPS, *PAUXCAPS, *NPAUXCAPS, *LPAUXCAPS;
#else
typedef AUXCAPSA AUXCAPS, *PAUXCAPS, *NPAUXCAPS, *LPAUXCAPS;
#endif
#else
typedef struct auxcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    DWORD   dwSupport;             /* functionality supported by driver */
} AUXCAPS, *PAUXCAPS, NEAR *NPAUXCAPS, FAR *LPAUXCAPS;
#endif

/* flags for wTechnology field in AUXCAPS structure */
#define AUXCAPS_CDAUDIO    1       /* audio from internal CD-ROM drive */
#define AUXCAPS_AUXIN      2       /* audio from auxiliary input jacks */

/* flags for dwSupport field in AUXCAPS structure */
#define AUXCAPS_VOLUME          0x0001  /* supports volume control */
#define AUXCAPS_LRVOLUME        0x0002  /* separate left-right volume control */

/* auxiliary audio function prototypes */
WINMMAPI UINT WINAPI auxGetNumDevs(void);
#ifdef WIN32
WINMMAPI MMRESULT WINAPI auxGetDevCapsA(UINT uDeviceID, LPAUXCAPSA pac, UINT cbac);
WINMMAPI MMRESULT WINAPI auxGetDevCapsW(UINT uDeviceID, LPAUXCAPSW pac, UINT cbac);
#ifdef UNICODE
#define auxGetDevCaps   auxGetDevCapsW
#else
#define auxGetDevCaps   auxGetDevCapsA
#endif
#else
MMRESULT WINAPI auxGetDevCaps(UINT uDeviceID, LPAUXCAPS pac, UINT cbac);
#endif
WINMMAPI MMRESULT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
WINMMAPI MMRESULT WINAPI auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume);

#if (WINVER >= 0x030a)
WINMMAPI DWORD WINAPI auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

#endif  /* ifndef MMNOAUX */



#if (WINVER >= 0x0400)
#ifndef MMNOMIXER
/****************************************************************************

			    Mixer Support

****************************************************************************/

DECLARE_HANDLE(HMIXEROBJ);
typedef HMIXEROBJ FAR *LPHMIXEROBJ;

DECLARE_HANDLE(HMIXER);
typedef HMIXER     FAR *LPHMIXER;

#define MIXER_SHORT_NAME_CHARS   16
#define MIXER_LONG_NAME_CHARS    64

//
//  MMRESULT error return values specific to the mixer API
//
//
#define MIXERR_INVALLINE            (MIXERR_BASE + 0)
#define MIXERR_INVALCONTROL         (MIXERR_BASE + 1)
#define MIXERR_INVALVALUE           (MIXERR_BASE + 2)
#define MIXERR_LASTERROR            (MIXERR_BASE + 2)


#define MIXER_OBJECTF_HANDLE    0x80000000L
#define MIXER_OBJECTF_MIXER     0x00000000L
#define MIXER_OBJECTF_HMIXER    (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIXER)
#define MIXER_OBJECTF_WAVEOUT   0x10000000L
#define MIXER_OBJECTF_HWAVEOUT  (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_WAVEOUT)
#define MIXER_OBJECTF_WAVEIN    0x20000000L
#define MIXER_OBJECTF_HWAVEIN   (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_WAVEIN)
#define MIXER_OBJECTF_MIDIOUT   0x30000000L
#define MIXER_OBJECTF_HMIDIOUT  (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIDIOUT)
#define MIXER_OBJECTF_MIDIIN    0x40000000L
#define MIXER_OBJECTF_HMIDIIN   (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIDIIN)
#define MIXER_OBJECTF_AUX       0x50000000L


WINMMAPI UINT WINAPI mixerGetNumDevs(void);

#ifdef WIN32
typedef struct tagMIXERCAPSA {
    WORD            wMid;                   // manufacturer id
    WORD            wPid;                   // product id
    MMVERSION       vDriverVersion;         // version of the driver
    CHAR            szPname[MAXPNAMELEN];   // product name
    DWORD           fdwSupport;             // misc. support bits
    DWORD           cDestinations;          // count of destinations
} MIXERCAPSA, *PMIXERCAPSA, *LPMIXERCAPSA;
typedef struct tagMIXERCAPSW {
    WORD            wMid;                   // manufacturer id
    WORD            wPid;                   // product id
    MMVERSION       vDriverVersion;         // version of the driver
    WCHAR           szPname[MAXPNAMELEN];   // product name
    DWORD           fdwSupport;             // misc. support bits
    DWORD           cDestinations;          // count of destinations
} MIXERCAPSW, *PMIXERCAPSW, *LPMIXERCAPSW;
#ifdef UNICODE
typedef MIXERCAPSW MIXERCAPS, *PMIXERCAPS, *LPMIXERCAPS;
#else
typedef MIXERCAPSA MIXERCAPS, *PMIXERCAPS, *LPMIXERCAPS;
#endif
#else
typedef struct tMIXERCAPS {
    WORD            wMid;                   // manufacturer id
    WORD            wPid;                   // product id
    VERSION         vDriverVersion;         // version of the driver
    char            szPname[MAXPNAMELEN];   // product name
    DWORD           fdwSupport;             // misc. support bits
    DWORD           cDestinations;          // count of destinations
} MIXERCAPS, *PMIXERCAPS, FAR *LPMIXERCAPS;
#endif



#ifdef WIN32
WINMMAPI MMRESULT WINAPI mixerGetDevCapsA(UINT uMxId, LPMIXERCAPSA pmxcaps, UINT cbmxcaps);
WINMMAPI MMRESULT WINAPI mixerGetDevCapsW(UINT uMxId, LPMIXERCAPSW pmxcaps, UINT cbmxcaps);
#ifdef UNICODE
#define mixerGetDevCaps mixerGetDevCapsW
#else
#define mixerGetDevCaps mixerGetDevCapsA
#endif
#else
MMRESULT WINAPI mixerGetDevCaps(UINT uMxId, LPMIXERCAPS pmxcaps, UINT cbmxcaps);
#endif

WINMMAPI MMRESULT WINAPI mixerOpen(LPHMIXER phmx, UINT uMxId, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);


WINMMAPI MMRESULT WINAPI mixerClose(HMIXER hmx);

WINMMAPI DWORD WINAPI mixerMessage(HMIXER hmx, UINT uMsg, DWORD dwParam1, DWORD dwParam2);

#ifdef WIN32
typedef struct tagMIXERLINEA {
    DWORD       cbStruct;               // size of MIXERLINE structure
    DWORD       dwDestination;          // zero based destination index
    DWORD       dwSource;               // zero based source index (if source)
    DWORD       dwLineID;               // unique line id for mixer device
    DWORD       fdwLine;                // state/information about line
    DWORD       dwUser;                 // driver specific information
    DWORD       dwComponentType;        // component type line connects to
    DWORD       cChannels;              // number of channels line supports
    DWORD       cConnections;           // number of connections [possible]
    DWORD       cControls;              // number of controls at this line
    CHAR        szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR        szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 // MIXERLINE_TARGETTYPE_xxxx
	DWORD   dwDeviceID;             // target device ID of device type
	WORD    wMid;                   // of target device
	WORD    wPid;                   //      "
	MMVERSION vDriverVersion;       //      "
	CHAR    szPname[MAXPNAMELEN];   //      "
    } Target;
} MIXERLINEA, *PMIXERLINEA, *LPMIXERLINEA;
typedef struct tagMIXERLINEW {
    DWORD       cbStruct;               // size of MIXERLINE structure
    DWORD       dwDestination;          // zero based destination index
    DWORD       dwSource;               // zero based source index (if source)
    DWORD       dwLineID;               // unique line id for mixer device
    DWORD       fdwLine;                // state/information about line
    DWORD       dwUser;                 // driver specific information
    DWORD       dwComponentType;        // component type line connects to
    DWORD       cChannels;              // number of channels line supports
    DWORD       cConnections;           // number of connections [possible]
    DWORD       cControls;              // number of controls at this line
    WCHAR       szShortName[MIXER_SHORT_NAME_CHARS];
    WCHAR       szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 // MIXERLINE_TARGETTYPE_xxxx
	DWORD   dwDeviceID;             // target device ID of device type
	WORD    wMid;                   // of target device
	WORD    wPid;                   //      "
	MMVERSION vDriverVersion;       //      "
	WCHAR   szPname[MAXPNAMELEN];   //      "
    } Target;
} MIXERLINEW, *PMIXERLINEW, *LPMIXERLINEW;
#ifdef UNICODE
typedef MIXERLINEW MIXERLINE, *PMIXERLINE, *LPMIXERLINE;
#else
typedef MIXERLINEA MIXERLINE, *PMIXERLINE, *LPMIXERLINE;
#endif
#else
typedef struct tMIXERLINE {
    DWORD       cbStruct;               // size of MIXERLINE structure
    DWORD       dwDestination;          // zero based destination index
    DWORD       dwSource;               // zero based source index (if source)
    DWORD       dwLineID;               // unique line id for mixer device
    DWORD       fdwLine;                // state/information about line
    DWORD       dwUser;                 // driver specific information
    DWORD       dwComponentType;        // component type line connects to
    DWORD       cChannels;              // number of channels line supports
    DWORD       cConnections;           // number of connections [possible]
    DWORD       cControls;              // number of controls at this line
    char        szShortName[MIXER_SHORT_NAME_CHARS];
    char        szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 // MIXERLINE_TARGETTYPE_xxxx
	DWORD   dwDeviceID;             // target device ID of device type
	WORD    wMid;                   // of target device
	WORD    wPid;                   //      "
	VERSION vDriverVersion;         //      "
	char    szPname[MAXPNAMELEN];   //      "
    } Target;
} MIXERLINE, *PMIXERLINE, FAR *LPMIXERLINE;
#endif

//
//  MIXERLINE.fdwLine
//
//
#define MIXERLINE_LINEF_ACTIVE              0x00000001L
#define MIXERLINE_LINEF_DISCONNECTED        0x00008000L
#define MIXERLINE_LINEF_SOURCE              0x80000000L


//
//  MIXERLINE.dwComponentType
//
//  component types for destinations and sources
//
//
#define MIXERLINE_COMPONENTTYPE_DST_FIRST       0x00000000L
#define MIXERLINE_COMPONENTTYPE_DST_UNDEFINED   (MIXERLINE_COMPONENTTYPE_DST_FIRST + 0)
#define MIXERLINE_COMPONENTTYPE_DST_DIGITAL     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 1)
#define MIXERLINE_COMPONENTTYPE_DST_LINE        (MIXERLINE_COMPONENTTYPE_DST_FIRST + 2)
#define MIXERLINE_COMPONENTTYPE_DST_MONITOR     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 3)
#define MIXERLINE_COMPONENTTYPE_DST_SPEAKERS    (MIXERLINE_COMPONENTTYPE_DST_FIRST + 4)
#define MIXERLINE_COMPONENTTYPE_DST_HEADPHONES  (MIXERLINE_COMPONENTTYPE_DST_FIRST + 5)
#define MIXERLINE_COMPONENTTYPE_DST_TELEPHONE   (MIXERLINE_COMPONENTTYPE_DST_FIRST + 6)
#define MIXERLINE_COMPONENTTYPE_DST_WAVEIN      (MIXERLINE_COMPONENTTYPE_DST_FIRST + 7)
#define MIXERLINE_COMPONENTTYPE_DST_VOICEIN     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 8)
#define MIXERLINE_COMPONENTTYPE_DST_LAST        (MIXERLINE_COMPONENTTYPE_DST_FIRST + 8)

#define MIXERLINE_COMPONENTTYPE_SRC_FIRST       0x00001000L
#define MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 0)
#define MIXERLINE_COMPONENTTYPE_SRC_DIGITAL     (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 1)
#define MIXERLINE_COMPONENTTYPE_SRC_LINE        (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 2)
#define MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE  (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 3)
#define MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 4)
#define MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 5)
#define MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 6)
#define MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 7)
#define MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT     (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 8)
#define MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 9)
#define MIXERLINE_COMPONENTTYPE_SRC_ANALOG      (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 10)
#define MIXERLINE_COMPONENTTYPE_SRC_LAST        (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 10)


//
//  MIXERLINE.Target.dwType
//
//
#define MIXERLINE_TARGETTYPE_UNDEFINED      0
#define MIXERLINE_TARGETTYPE_WAVEOUT        1
#define MIXERLINE_TARGETTYPE_WAVEIN         2
#define MIXERLINE_TARGETTYPE_MIDIOUT        3
#define MIXERLINE_TARGETTYPE_MIDIIN         4
#define MIXERLINE_TARGETTYPE_AUX            5

#ifdef WIN32
WINMMAPI MMRESULT WINAPI mixerGetLineInfoA(HMIXEROBJ hmxobj, LPMIXERLINEA pmxl, DWORD fdwInfo);
WINMMAPI MMRESULT WINAPI mixerGetLineInfoW(HMIXEROBJ hmxobj, LPMIXERLINEW pmxl, DWORD fdwInfo);
#ifdef UNICODE
#define mixerGetLineInfo        mixerGetLineInfoW
#else
#define mixerGetLineInfo        mixerGetLineInfoA
#endif
#else
MMRESULT WINAPI mixerGetLineInfo(HMIXEROBJ hmxobj, LPMIXERLINE pmxl, DWORD fdwInfo);
#endif

#define MIXER_GETLINEINFOF_DESTINATION      0x00000000L
#define MIXER_GETLINEINFOF_SOURCE           0x00000001L
#define MIXER_GETLINEINFOF_LINEID           0x00000002L
#define MIXER_GETLINEINFOF_COMPONENTTYPE    0x00000003L
#define MIXER_GETLINEINFOF_TARGETTYPE       0x00000004L

#define MIXER_GETLINEINFOF_QUERYMASK        0x0000000FL



WINMMAPI MMRESULT WINAPI mixerGetID(HMIXEROBJ hmxobj, UINT FAR *puMxId, DWORD fdwId);



//
//  MIXERCONTROL
//
//
#ifdef WIN32
typedef struct tagMIXERCONTROLA {
    DWORD           cbStruct;           // size in bytes of MIXERCONTROL
    DWORD           dwControlID;        // unique control id for mixer device
    DWORD           dwControlType;      // MIXERCONTROL_CONTROLTYPE_xxx
    DWORD           fdwControl;         // MIXERCONTROL_CONTROLF_xxx
    DWORD           cMultipleItems;     // if MIXERCONTROL_CONTROLF_MULTIPLE set
    CHAR            szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR            szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           // signed minimum for this control
	    LONG    lMaximum;           // signed maximum for this control
	};
	struct {
	    DWORD   dwMinimum;          // unsigned minimum for this control
	    DWORD   dwMaximum;          // unsigned maximum for this control
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             // # of steps between min & max
	DWORD       cbCustomData;       // size in bytes of custom data
	DWORD       dwReserved[6];      // !!! needed? we have cbStruct....
    } Metrics;
} MIXERCONTROLA, *PMIXERCONTROLA, *LPMIXERCONTROLA;
typedef struct tagMIXERCONTROLW {
    DWORD           cbStruct;           // size in bytes of MIXERCONTROL
    DWORD           dwControlID;        // unique control id for mixer device
    DWORD           dwControlType;      // MIXERCONTROL_CONTROLTYPE_xxx
    DWORD           fdwControl;         // MIXERCONTROL_CONTROLF_xxx
    DWORD           cMultipleItems;     // if MIXERCONTROL_CONTROLF_MULTIPLE set
    WCHAR           szShortName[MIXER_SHORT_NAME_CHARS];
    WCHAR           szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           // signed minimum for this control
	    LONG    lMaximum;           // signed maximum for this control
	};
	struct {
	    DWORD   dwMinimum;          // unsigned minimum for this control
	    DWORD   dwMaximum;          // unsigned maximum for this control
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             // # of steps between min & max
	DWORD       cbCustomData;       // size in bytes of custom data
	DWORD       dwReserved[6];      // !!! needed? we have cbStruct....
    } Metrics;
} MIXERCONTROLW, *PMIXERCONTROLW, *LPMIXERCONTROLW;
#ifdef UNICODE
typedef MIXERCONTROLW MIXERCONTROL, *PMIXERCONTROL, *LPMIXERCONTROL;
#else
typedef MIXERCONTROLA MIXERCONTROL, *PMIXERCONTROL, *LPMIXERCONTROL;
#endif
#else
typedef struct tMIXERCONTROL {
    DWORD           cbStruct;           // size in bytes of MIXERCONTROL
    DWORD           dwControlID;        // unique control id for mixer device
    DWORD           dwControlType;      // MIXERCONTROL_CONTROLTYPE_xxx
    DWORD           fdwControl;         // MIXERCONTROL_CONTROLF_xxx
    DWORD           cMultipleItems;     // if MIXERCONTROL_CONTROLF_MULTIPLE set
    char            szShortName[MIXER_SHORT_NAME_CHARS];
    char            szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           // signed minimum for this control
	    LONG    lMaximum;           // signed maximum for this control
	};
	struct {
	    DWORD   dwMinimum;          // unsigned minimum for this control
	    DWORD   dwMaximum;          // unsigned maximum for this control
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             // # of steps between min & max
	DWORD       cbCustomData;       // size in bytes of custom data
	DWORD       dwReserved[6];      // !!! needed? we have cbStruct....
    } Metrics;
} MIXERCONTROL, *PMIXERCONTROL, FAR *LPMIXERCONTROL;
#endif

//
//  MIXERCONTROL.fdwControl
//
//
#define MIXERCONTROL_CONTROLF_UNIFORM   0x00000001L
#define MIXERCONTROL_CONTROLF_MULTIPLE  0x00000002L
#define MIXERCONTROL_CONTROLF_DISABLED  0x80000000L




//
//  MIXERCONTROL_CONTROLTYPE_xxx building block defines
//
//
#define MIXERCONTROL_CT_CLASS_MASK          0xF0000000L
#define MIXERCONTROL_CT_CLASS_CUSTOM        0x00000000L
#define MIXERCONTROL_CT_CLASS_METER         0x10000000L
#define MIXERCONTROL_CT_CLASS_SWITCH        0x20000000L
#define MIXERCONTROL_CT_CLASS_NUMBER        0x30000000L
#define MIXERCONTROL_CT_CLASS_SLIDER        0x40000000L
#define MIXERCONTROL_CT_CLASS_FADER         0x50000000L
#define MIXERCONTROL_CT_CLASS_TIME          0x60000000L
#define MIXERCONTROL_CT_CLASS_LIST          0x70000000L


#define MIXERCONTROL_CT_SUBCLASS_MASK       0x0F000000L

#define MIXERCONTROL_CT_SC_SWITCH_BOOLEAN   0x00000000L
#define MIXERCONTROL_CT_SC_SWITCH_BUTTON    0x01000000L

#define MIXERCONTROL_CT_SC_METER_POLLED     0x00000000L

#define MIXERCONTROL_CT_SC_TIME_MICROSECS   0x00000000L
#define MIXERCONTROL_CT_SC_TIME_MILLISECS   0x01000000L

#define MIXERCONTROL_CT_SC_LIST_SINGLE      0x00000000L
#define MIXERCONTROL_CT_SC_LIST_MULTIPLE    0x01000000L


#define MIXERCONTROL_CT_UNITS_MASK          0x00FF0000L
#define MIXERCONTROL_CT_UNITS_CUSTOM        0x00000000L
#define MIXERCONTROL_CT_UNITS_BOOLEAN       0x00010000L
#define MIXERCONTROL_CT_UNITS_SIGNED        0x00020000L
#define MIXERCONTROL_CT_UNITS_UNSIGNED      0x00030000L
#define MIXERCONTROL_CT_UNITS_DECIBELS      0x00040000L // in 10ths
#define MIXERCONTROL_CT_UNITS_PERCENT       0x00050000L // in 10ths


//
//  Commonly used control types for specifying MIXERCONTROL.dwControlType
//

#define MIXERCONTROL_CONTROLTYPE_CUSTOM         (MIXERCONTROL_CT_CLASS_CUSTOM | MIXERCONTROL_CT_UNITS_CUSTOM)
#define MIXERCONTROL_CONTROLTYPE_BOOLEANMETER   (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_SIGNEDMETER    (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_PEAKMETER      (MIXERCONTROL_CONTROLTYPE_SIGNEDMETER + 1)
#define MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER  (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_BOOLEAN        (MIXERCONTROL_CT_CLASS_SWITCH | MIXERCONTROL_CT_SC_SWITCH_BOOLEAN | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_ONOFF          (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 1)
#define MIXERCONTROL_CONTROLTYPE_MUTE           (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 2)
#define MIXERCONTROL_CONTROLTYPE_MONO           (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 3)
#define MIXERCONTROL_CONTROLTYPE_LOUDNESS       (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 4)
#define MIXERCONTROL_CONTROLTYPE_STEREOENH      (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 5)
#define MIXERCONTROL_CONTROLTYPE_BUTTON         (MIXERCONTROL_CT_CLASS_SWITCH | MIXERCONTROL_CT_SC_SWITCH_BUTTON | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_DECIBELS       (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_DECIBELS)
#define MIXERCONTROL_CONTROLTYPE_SIGNED         (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_UNSIGNED       (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_PERCENT        (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_PERCENT)
#define MIXERCONTROL_CONTROLTYPE_SLIDER         (MIXERCONTROL_CT_CLASS_SLIDER | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_PAN            (MIXERCONTROL_CONTROLTYPE_SLIDER + 1)
#define MIXERCONTROL_CONTROLTYPE_QSOUNDPAN      (MIXERCONTROL_CONTROLTYPE_SLIDER + 2)
#define MIXERCONTROL_CONTROLTYPE_FADER          (MIXERCONTROL_CT_CLASS_FADER | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_VOLUME         (MIXERCONTROL_CONTROLTYPE_FADER + 1)
#define MIXERCONTROL_CONTROLTYPE_BASS           (MIXERCONTROL_CONTROLTYPE_FADER + 2)
#define MIXERCONTROL_CONTROLTYPE_TREBLE         (MIXERCONTROL_CONTROLTYPE_FADER + 3)
#define MIXERCONTROL_CONTROLTYPE_EQUALIZER      (MIXERCONTROL_CONTROLTYPE_FADER + 4)
#define MIXERCONTROL_CONTROLTYPE_SINGLESELECT   (MIXERCONTROL_CT_CLASS_LIST | MIXERCONTROL_CT_SC_LIST_SINGLE | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_MUX            (MIXERCONTROL_CONTROLTYPE_SINGLESELECT + 1)
#define MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT (MIXERCONTROL_CT_CLASS_LIST | MIXERCONTROL_CT_SC_LIST_MULTIPLE | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_MIXER          (MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT + 1)
#define MIXERCONTROL_CONTROLTYPE_MICROTIME      (MIXERCONTROL_CT_CLASS_TIME | MIXERCONTROL_CT_SC_TIME_MICROSECS | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_MILLITIME      (MIXERCONTROL_CT_CLASS_TIME | MIXERCONTROL_CT_SC_TIME_MILLISECS | MIXERCONTROL_CT_UNITS_UNSIGNED)

//
//  MIXERLINECONTROLS
//
#ifdef WIN32
typedef struct tagMIXERLINECONTROLSA {
    DWORD           cbStruct;       // size in bytes of MIXERLINECONTROLS
    DWORD           dwLineID;       // line id (from MIXERLINE.dwLineID)
    union {
	DWORD       dwControlID;    // MIXER_GETLINECONTROLSF_ONEBYID
	DWORD       dwControlType;  // MIXER_GETLINECONTROLSF_ONEBYTYPE
    };
    DWORD           cControls;      // count of controls pmxctrl points to
    DWORD           cbmxctrl;       // size in bytes of _one_ MIXERCONTROL
    LPMIXERCONTROLA pamxctrl;       // pointer to first MIXERCONTROL array
} MIXERLINECONTROLSA, *PMIXERLINECONTROLSA, *LPMIXERLINECONTROLSA;
typedef struct tagMIXERLINECONTROLSW {
    DWORD           cbStruct;       // size in bytes of MIXERLINECONTROLS
    DWORD           dwLineID;       // line id (from MIXERLINE.dwLineID)
    union {
	DWORD       dwControlID;    // MIXER_GETLINECONTROLSF_ONEBYID
	DWORD       dwControlType;  // MIXER_GETLINECONTROLSF_ONEBYTYPE
    };
    DWORD           cControls;      // count of controls pmxctrl points to
    DWORD           cbmxctrl;       // size in bytes of _one_ MIXERCONTROL
    LPMIXERCONTROLW pamxctrl;       // pointer to first MIXERCONTROL array
} MIXERLINECONTROLSW, *PMIXERLINECONTROLSW, *LPMIXERLINECONTROLSW;
#ifdef UNICODE
typedef MIXERLINECONTROLSW MIXERLINECONTROLS, *PMIXERLINECONTROLS, *LPMIXERLINECONTROLS;
#else
typedef MIXERLINECONTROLSA MIXERLINECONTROLS, *PMIXERLINECONTROLS, *LPMIXERLINECONTROLS;
#endif
#else
typedef struct tMIXERLINECONTROLS {
    DWORD           cbStruct;       // size in bytes of MIXERLINECONTROLS
    DWORD           dwLineID;       // line id (from MIXERLINE.dwLineID)
    union {
	DWORD       dwControlID;    // MIXER_GETLINECONTROLSF_ONEBYID
	DWORD       dwControlType;  // MIXER_GETLINECONTROLSF_ONEBYTYPE
    };
    DWORD           cControls;      // count of controls pmxctrl points to
    DWORD           cbmxctrl;       // size in bytes of _one_ MIXERCONTROL
    LPMIXERCONTROL  pamxctrl;       // pointer to first MIXERCONTROL array
} MIXERLINECONTROLS, *PMIXERLINECONTROLS, FAR *LPMIXERLINECONTROLS;
#endif


//
//
//
#ifdef WIN32
WINMMAPI MMRESULT WINAPI mixerGetLineControlsA(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSA pmxlc, DWORD fdwControls);
WINMMAPI MMRESULT WINAPI mixerGetLineControlsW(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSW pmxlc, DWORD fdwControls);
#ifdef UNICODE
#define mixerGetLineControls    mixerGetLineControlsW
#else
#define mixerGetLineControls    mixerGetLineControlsA
#endif
#else
MMRESULT WINAPI mixerGetLineControls(HMIXEROBJ hmxobj, LPMIXERLINECONTROLS pmxlc, DWORD fdwControls);
#endif

#define MIXER_GETLINECONTROLSF_ALL          0x00000000L
#define MIXER_GETLINECONTROLSF_ONEBYID      0x00000001L
#define MIXER_GETLINECONTROLSF_ONEBYTYPE    0x00000002L

#define MIXER_GETLINECONTROLSF_QUERYMASK    0x0000000FL



typedef struct tMIXERCONTROLDETAILS {
    DWORD           cbStruct;       // size in bytes of MIXERCONTROLDETAILS
    DWORD           dwControlID;    // control id to get/set details on
    DWORD           cChannels;      // number of channels in paDetails array
    union {
	HWND        hwndOwner;      // for MIXER_SETCONTROLDETAILSF_CUSTOM
	DWORD       cMultipleItems; // if _MULTIPLE, the number of items per channel
    };
    DWORD           cbDetails;      // size of _one_ details_XX struct
    LPVOID          paDetails;      // pointer to array of details_XX structs
} MIXERCONTROLDETAILS, *PMIXERCONTROLDETAILS, FAR *LPMIXERCONTROLDETAILS;


//
//  MIXER_GETCONTROLDETAILSF_LISTTEXT
//
//
#ifdef WIN32
typedef struct tagMIXERCONTROLDETAILS_LISTTEXTA {
    DWORD           dwParam1;
    DWORD           dwParam2;
    CHAR            szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXTA, *PMIXERCONTROLDETAILS_LISTTEXTA, *LPMIXERCONTROLDETAILS_LISTTEXTA;
typedef struct tagMIXERCONTROLDETAILS_LISTTEXTW {
    DWORD           dwParam1;
    DWORD           dwParam2;
    WCHAR           szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXTW, *PMIXERCONTROLDETAILS_LISTTEXTW, *LPMIXERCONTROLDETAILS_LISTTEXTW;
#ifdef UNICODE
typedef MIXERCONTROLDETAILS_LISTTEXTW MIXERCONTROLDETAILS_LISTTEXT, *PMIXERCONTROLDETAILS_LISTTEXT, *LPMIXERCONTROLDETAILS_LISTTEXT;
#else
typedef MIXERCONTROLDETAILS_LISTTEXTA MIXERCONTROLDETAILS_LISTTEXT, *PMIXERCONTROLDETAILS_LISTTEXT, *LPMIXERCONTROLDETAILS_LISTTEXT;
#endif
#else
typedef struct tMIXERCONTROLDETAILS_LISTTEXT {
    DWORD           dwParam1;
    DWORD           dwParam2;
    char            szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXT, *PMIXERCONTROLDETAILS_LISTTEXT, FAR *LPMIXERCONTROLDETAILS_LISTTEXT;
#endif

//
//  MIXER_GETCONTROLDETAILSF_VALUE
//
//
typedef struct tMIXERCONTROLDETAILS_BOOLEAN {
    LONG            fValue;
}       MIXERCONTROLDETAILS_BOOLEAN, 
      *PMIXERCONTROLDETAILS_BOOLEAN, 
 FAR *LPMIXERCONTROLDETAILS_BOOLEAN;

typedef struct tMIXERCONTROLDETAILS_SIGNED {
    LONG            lValue;
}       MIXERCONTROLDETAILS_SIGNED,
      *PMIXERCONTROLDETAILS_SIGNED,
 FAR *LPMIXERCONTROLDETAILS_SIGNED;


typedef struct tMIXERCONTROLDETAILS_UNSIGNED {
    DWORD           dwValue;
}       MIXERCONTROLDETAILS_UNSIGNED,
      *PMIXERCONTROLDETAILS_UNSIGNED,
 FAR *LPMIXERCONTROLDETAILS_UNSIGNED;


#ifdef WIN32
WINMMAPI MMRESULT WINAPI mixerGetControlDetailsA(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
WINMMAPI MMRESULT WINAPI mixerGetControlDetailsW(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
#ifdef UNICODE
#define mixerGetControlDetails  mixerGetControlDetailsW
#else
#define mixerGetControlDetails  mixerGetControlDetailsA
#endif
#else
MMRESULT WINAPI mixerGetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
#endif

#define MIXER_GETCONTROLDETAILSF_VALUE      0x00000000L
#define MIXER_GETCONTROLDETAILSF_LISTTEXT   0x00000001L

#define MIXER_GETCONTROLDETAILSF_QUERYMASK  0x0000000FL



WINMMAPI MMRESULT WINAPI mixerSetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);

#define MIXER_SETCONTROLDETAILSF_VALUE      0x00000000L
#define MIXER_SETCONTROLDETAILSF_CUSTOM     0x00000001L

#define MIXER_SETCONTROLDETAILSF_QUERYMASK  0x0000000FL


#endif /* ifndef MMNOMIXER */
#endif /* ifdef WINVER >= 0x0400 */


#ifndef MMNOTIMER
/****************************************************************************

			    Timer support

****************************************************************************/

/* timer error return values */
#define TIMERR_NOERROR        (0)                  /* no error */
#define TIMERR_NOCANDO        (TIMERR_BASE+1)      /* request not completed */
#define TIMERR_STRUCT         (TIMERR_BASE+33)     /* time struct size */

/* timer data types */
typedef void (CALLBACK TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef TIMECALLBACK FAR *LPTIMECALLBACK;

/* flags for wFlags parameter of timeSetEvent() function */
#define TIME_ONESHOT    0x00   /* program timer for single event */
#define TIME_PERIODIC   0x01   /* program for continuous periodic event */


/* timer device capabilities data structure */
typedef struct timecaps_tag {
    UINT    wPeriodMin;     /* minimum period supported  */
    UINT    wPeriodMax;     /* maximum period supported  */
} TIMECAPS, *PTIMECAPS, NEAR *NPTIMECAPS, FAR *LPTIMECAPS;

/* timer function prototypes */
WINMMAPI MMRESULT WINAPI timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt);
WINMMAPI DWORD WINAPI timeGetTime(void);
WINMMAPI MMRESULT WINAPI timeSetEvent(UINT uDelay, UINT uResolution,
    LPTIMECALLBACK fptc, DWORD dwUser, UINT fuEvent);
WINMMAPI MMRESULT WINAPI timeKillEvent(UINT uTimerID);
WINMMAPI MMRESULT WINAPI timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc);
WINMMAPI MMRESULT WINAPI timeBeginPeriod(UINT uPeriod);
WINMMAPI MMRESULT WINAPI timeEndPeriod(UINT uPeriod);

#endif  /* ifndef MMNOTIMER */


#ifndef MMNOJOY
/****************************************************************************

			    Joystick support

****************************************************************************/

/* joystick error return values */
#define JOYERR_NOERROR        (0)                  /* no error */
#define JOYERR_PARMS          (JOYERR_BASE+5)      /* bad parameters */
#define JOYERR_NOCANDO        (JOYERR_BASE+6)      /* request not completed */
#define JOYERR_UNPLUGGED      (JOYERR_BASE+7)      /* joystick is unplugged */

/* constants used with JOYINFO structure and MM_JOY* messages */
#define JOY_BUTTON1         0x0001
#define JOY_BUTTON2         0x0002
#define JOY_BUTTON3         0x0004
#define JOY_BUTTON4         0x0008
#define JOY_BUTTON1CHG      0x0100
#define JOY_BUTTON2CHG      0x0200
#define JOY_BUTTON3CHG      0x0400
#define JOY_BUTTON4CHG      0x0800

/* joystick ID constants */
#define JOYSTICKID1         0
#define JOYSTICKID2         1


/* joystick device capabilities data structure */
#ifdef WIN32
typedef struct tagJOYCAPSA {
    WORD    wMid;                /* manufacturer ID */
    WORD    wPid;                /* product ID */
    CHAR    szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    UINT    wXmin;               /* minimum x position value */
    UINT    wXmax;               /* maximum x position value */
    UINT    wYmin;               /* minimum y position value */
    UINT    wYmax;               /* maximum y position value */
    UINT    wZmin;               /* minimum z position value */
    UINT    wZmax;               /* maximum z position value */
    UINT    wNumButtons;         /* number of buttons */
    UINT    wPeriodMin;          /* minimum message period when captured */
    UINT    wPeriodMax;          /* maximum message period when captured */
} JOYCAPSA, *PJOYCAPSA, *NPJOYCAPSA, *LPJOYCAPSA;
typedef struct tagJOYCAPSW {
    WORD    wMid;                /* manufacturer ID */
    WORD    wPid;                /* product ID */
    WCHAR   szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    UINT    wXmin;               /* minimum x position value */
    UINT    wXmax;               /* maximum x position value */
    UINT    wYmin;               /* minimum y position value */
    UINT    wYmax;               /* maximum y position value */
    UINT    wZmin;               /* minimum z position value */
    UINT    wZmax;               /* maximum z position value */
    UINT    wNumButtons;         /* number of buttons */
    UINT    wPeriodMin;          /* minimum message period when captured */
    UINT    wPeriodMax;          /* maximum message period when captured */
} JOYCAPSW, *PJOYCAPSW, *NPJOYCAPSW, *LPJOYCAPSW;
#ifdef UNICODE
typedef JOYCAPSW JOYCAPS, *PJOYCAPS, *NPJOYCAPS, *LPJOYCAPS;
#else
typedef JOYCAPSA JOYCAPS, *PJOYCAPS, *NPJOYCAPS, *LPJOYCAPS;
#endif
#else
typedef struct joycaps_tag {
    WORD wMid;                  /* manufacturer ID */
    WORD wPid;                  /* product ID */
    char szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT wXmin;                 /* minimum x position value */
    UINT wXmax;                 /* maximum x position value */
    UINT wYmin;                 /* minimum y position value */
    UINT wYmax;                 /* maximum y position value */
    UINT wZmin;                 /* minimum z position value */
    UINT wZmax;                 /* maximum z position value */
    UINT wNumButtons;           /* number of buttons */
    UINT wPeriodMin;            /* minimum message period when captured */
    UINT wPeriodMax;            /* maximum message period when captured */
} JOYCAPS, *PJOYCAPS, NEAR *NPJOYCAPS, FAR *LPJOYCAPS;
#endif


/* joystick information data structure */
typedef struct joyinfo_tag {
    UINT wXpos;                 /* x position */
    UINT wYpos;                 /* y position */
    UINT wZpos;                 /* z position */
    UINT wButtons;              /* button states */
} JOYINFO, *PJOYINFO, NEAR *NPJOYINFO, FAR *LPJOYINFO;

/* joystick function prototypes */
WINMMAPI UINT WINAPI joyGetNumDevs(void);
#ifdef WIN32
WINMMAPI MMRESULT WINAPI joyGetDevCapsA(UINT uJoyID, LPJOYCAPSA pjc, UINT cbjc);
WINMMAPI MMRESULT WINAPI joyGetDevCapsW(UINT uJoyID, LPJOYCAPSW pjc, UINT cbjc);
#ifdef UNICODE
#define joyGetDevCaps   joyGetDevCapsW
#else
#define joyGetDevCaps   joyGetDevCapsA
#endif
#else
MMRESULT WINAPI joyGetDevCaps(UINT uJoyID, LPJOYCAPS pjc, UINT cbjc);
#endif
WINMMAPI MMRESULT WINAPI joyGetPos(UINT uJoyID, LPJOYINFO pji);
WINMMAPI MMRESULT WINAPI joyGetThreshold(UINT uJoyID, LPUINT puThreshold);
WINMMAPI MMRESULT WINAPI joyReleaseCapture(UINT uJoyID);
WINMMAPI MMRESULT WINAPI joySetCapture(HWND hwnd, UINT uJoyID, UINT uPeriod,
    BOOL fChanged);
WINMMAPI MMRESULT WINAPI joySetThreshold(UINT uJoyID, UINT uThreshold);

#endif  /* ifndef MMNOJOY */


#ifndef MMNOMMIO
/****************************************************************************

			Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */
#define MMIOERR_BASE                256
#define MMIOERR_FILENOTFOUND        (MMIOERR_BASE + 1)  /* file not found */
#define MMIOERR_OUTOFMEMORY         (MMIOERR_BASE + 2)  /* out of memory */
#define MMIOERR_CANNOTOPEN          (MMIOERR_BASE + 3)  /* cannot open */
#define MMIOERR_CANNOTCLOSE         (MMIOERR_BASE + 4)  /* cannot close */
#define MMIOERR_CANNOTREAD          (MMIOERR_BASE + 5)  /* cannot read */
#define MMIOERR_CANNOTWRITE         (MMIOERR_BASE + 6)  /* cannot write */
#define MMIOERR_CANNOTSEEK          (MMIOERR_BASE + 7)  /* cannot seek */
#define MMIOERR_CANNOTEXPAND        (MMIOERR_BASE + 8)  /* cannot expand file */
#define MMIOERR_CHUNKNOTFOUND       (MMIOERR_BASE + 9)  /* chunk not found */
#define MMIOERR_UNBUFFERED          (MMIOERR_BASE + 10) /*  */
#define MMIOERR_PATHNOTFOUND        (MMIOERR_BASE + 11) /* path incorrect */
#define MMIOERR_ACCESSDENIED        (MMIOERR_BASE + 12) /* file was protected */
#define MMIOERR_SHARINGVIOLATION    (MMIOERR_BASE + 13) /* file in use */
#define MMIOERR_NETWORKERROR        (MMIOERR_BASE + 14) /* network not responding */
#define MMIOERR_TOOMANYOPENFILES    (MMIOERR_BASE + 15) /* no more file handles  */
#define MMIOERR_INVALIDFILE         (MMIOERR_BASE + 16) /* default error file error */

/* MMIO constants */
#define CFSEPCHAR       '+'             /* compound file name separator char. */

/* MMIO data types */
typedef DWORD           FOURCC;         /* a four character code */
typedef char _huge *    HPSTR;          /* a huge version of LPSTR */
DECLARE_HANDLE(HMMIO);                  /* a handle to an open file */
typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg,
	    LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC FAR *LPMMIOPROC;


/* general MMIO information data structure */
typedef struct _MMIOINFO
{
	/* general fields */
	DWORD           dwFlags;        /* general status flags */
	FOURCC          fccIOProc;      /* pointer to I/O procedure */
	LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
	UINT            wErrorRet;      /* place for error to be returned */
	HTASK           htask;          /* alternate local task */

	/* fields maintained by MMIO functions during buffered I/O */
	LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
	HPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
	HPSTR           pchNext;        /* pointer to next byte to read/write */
	HPSTR           pchEndRead;     /* pointer to last valid byte to read */
	HPSTR           pchEndWrite;    /* pointer to last byte to write */
	LONG            lBufOffset;     /* disk offset of start of buffer */

	/* fields maintained by I/O procedure */
	LONG            lDiskOffset;    /* disk offset of next read or write */
	DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

	/* other fields maintained by MMIO */
	DWORD           dwReserved1;    /* reserved for MMIO use */
	DWORD           dwReserved2;    /* reserved for MMIO use */
	HMMIO           hmmio;          /* handle to open file */
} MMIOINFO, *PMMIOINFO, NEAR *NPMMIOINFO, FAR *LPMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
	FOURCC          ckid;           /* chunk ID */
	DWORD           cksize;         /* chunk size */
	FOURCC          fccType;        /* form type or list type */
	DWORD           dwDataOffset;   /* offset of data portion of chunk */
	DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO, *PMMCKINFO, NEAR *NPMMCKINFO, FAR *LPMMCKINFO;

/* bit field masks */
#define MMIO_RWMODE     0x00000003      /* open file for reading/writing/both */
#define MMIO_SHAREMODE  0x00000070      /* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */

#define MMIO_DIRTY      0x10000000      /* I/O buffer is dirty */


/* read/write mode numbers (bit field MMIO_RWMODE) */
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
#define MMIO_COMPAT     0x00000000      /* compatibility mode */
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */

/* various MMIO flags */
#define MMIO_FHOPEN             0x0010  /* mmioClose: keep file handle open */
#define MMIO_EMPTYBUF           0x0010  /* mmioFlush: empty the I/O buffer */
#define MMIO_TOUPPER            0x0010  /* mmioStringToFOURCC: to u-case */
#define MMIO_INSTALLPROC    0x00010000  /* mmioInstallIOProc: install MMIOProc */
#define MMIO_GLOBALPROC     0x10000000  /* mmioInstallIOProc: install globally */
#define MMIO_REMOVEPROC     0x00020000  /* mmioInstallIOProc: remove MMIOProc */
#define MMIO_FINDPROC       0x00040000  /* mmioInstallIOProc: find an MMIOProc */
#define MMIO_FINDCHUNK          0x0010  /* mmioDescend: find a chunk by ID */
#define MMIO_FINDRIFF           0x0020  /* mmioDescend: find a LIST chunk */
#define MMIO_FINDLIST           0x0040  /* mmioDescend: find a RIFF chunk */
#define MMIO_CREATERIFF         0x0020  /* mmioCreateChunk: make a LIST chunk */
#define MMIO_CREATELIST         0x0040  /* mmioCreateChunk: make a RIFF chunk */


/* message numbers for MMIOPROC I/O procedure functions */
#define MMIOM_READ      MMIO_READ       /* read */
#define MMIOM_WRITE    MMIO_WRITE       /* write */
#define MMIOM_SEEK              2       /* seek to a new position in file */
#define MMIOM_OPEN              3       /* open file */
#define MMIOM_CLOSE             4       /* close file */
#define MMIOM_WRITEFLUSH        5       /* write and flush */

#if (WINVER >= 0x030a)
#define MMIOM_RENAME            6       /* rename specified file */
#endif /* ifdef WINVER >= 0x030a */

#define MMIOM_USER         0x8000       /* beginning of user-defined messages */

/* standard four character codes */
#define FOURCC_RIFF     mmioFOURCC('R', 'I', 'F', 'F')
#define FOURCC_LIST     mmioFOURCC('L', 'I', 'S', 'T')

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_DOS      mmioFOURCC('D', 'O', 'S', ' ')
#define FOURCC_MEM      mmioFOURCC('M', 'E', 'M', ' ')

/* flags for mmioSeek() */
#ifndef SEEK_SET
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
#endif  /* ifndef SEEK_SET */

/* other constants */
#define MMIO_DEFAULTBUFFER      8192    /* default buffer size */

/* MMIO macros */
#define mmioFOURCC(ch0, ch1, ch2, ch3)  MAKEFOURCC(ch0, ch1, ch2, ch3)

/* MMIO function prototypes */
#ifdef WIN32
WINMMAPI FOURCC WINAPI mmioStringToFOURCCA(LPCSTR sz, UINT uFlags);
WINMMAPI FOURCC WINAPI mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags);
#ifdef UNICODE
#define mmioStringToFOURCC      mmioStringToFOURCCW
#else
#define mmioStringToFOURCC      mmioStringToFOURCCA
#endif
#else
FOURCC WINAPI mmioStringToFOURCC(LPCSTR sz, UINT uFlags);
#endif
#ifdef WIN32
WINMMAPI LPMMIOPROC WINAPI mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
WINMMAPI LPMMIOPROC WINAPI mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
#ifdef UNICODE
#define mmioInstallIOProc       mmioInstallIOProcW
#else
#define mmioInstallIOProc       mmioInstallIOProcA
#endif
#else
LPMMIOPROC WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
#endif
#ifdef WIN32
WINMMAPI HMMIO WINAPI mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
WINMMAPI HMMIO WINAPI mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
#ifdef UNICODE
#define mmioOpen        mmioOpenW
#else
#define mmioOpen        mmioOpenA
#endif
#else
HMMIO WINAPI mmioOpen(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
#endif

#if (WINVER >= 0x030a)
#ifdef WIN32
WINMMAPI MMRESULT WINAPI mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, const MMIOINFO FAR* pmmioinfo, DWORD fdwRename);
WINMMAPI MMRESULT WINAPI mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, const MMIOINFO FAR* pmmioinfo, DWORD fdwRename);
#ifdef UNICODE
#define mmioRename      mmioRenameW
#else
#define mmioRename      mmioRenameA
#endif
#else
MMRESULT WINAPI mmioRename(LPCSTR pszFileName, LPCSTR pszNewFileName, const MMIOINFO FAR* pmmioinfo, DWORD fdwRename);
#endif
#endif /* ifdef WINVER >= 0x030a */

WINMMAPI MMRESULT WINAPI mmioClose(HMMIO hmmio, UINT fuClose);
WINMMAPI LONG WINAPI mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
WINMMAPI LONG WINAPI mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch);
WINMMAPI LONG WINAPI mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
WINMMAPI MMRESULT WINAPI mmioGetInfo(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo);
WINMMAPI MMRESULT WINAPI mmioSetInfo(HMMIO hmmio, const MMIOINFO FAR* pmmioinfo, UINT fuInfo);
WINMMAPI MMRESULT WINAPI mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer,
    UINT fuBuffer);
WINMMAPI MMRESULT WINAPI mmioFlush(HMMIO hmmio, UINT fuFlush);
WINMMAPI MMRESULT WINAPI mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance);
WINMMAPI LRESULT WINAPI mmioSendMessage(HMMIO hmmio, UINT uMsg,
    LPARAM lParam1, LPARAM lParam2);
WINMMAPI MMRESULT WINAPI mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki,
    const MMCKINFO FAR* pmmckiParent, UINT fuDescend);
WINMMAPI MMRESULT WINAPI mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend);
WINMMAPI MMRESULT WINAPI mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate);

#endif  /* ifndef MMNOMMIO */


#ifndef MMNOMCI
/****************************************************************************

			    MCI support

****************************************************************************/

#ifndef _MCIERROR_              /* MCIERROR is defined in some post 3.1 apps */
#define _MCIERROR_
typedef DWORD   MCIERROR;       /* error return code, 0 means no error */
#endif

#ifndef _MCIDEVICEID_           /* Same with MCIDEVICEID */
#define _MCIDEVICEID_
typedef UINT    MCIDEVICEID;    /* MCI device ID type */
#endif


typedef UINT (CALLBACK *YIELDPROC)(MCIDEVICEID mciId, DWORD dwYieldData);

/* MCI function prototypes */
#ifdef WIN32
WINMMAPI MCIERROR WINAPI mciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
WINMMAPI MCIERROR WINAPI mciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
#ifdef UNICODE
#define mciSendCommand  mciSendCommandW
#else
#define mciSendCommand  mciSendCommandA
#endif
#else
MCIERROR WINAPI mciSendCommand(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
#endif
#ifdef WIN32
WINMMAPI MCIERROR  WINAPI mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
WINMMAPI MCIERROR  WINAPI mciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
#ifdef UNICODE
#define mciSendString   mciSendStringW
#else
#define mciSendString   mciSendStringA
#endif
#else
MCIERROR  WINAPI mciSendString(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
#endif
#ifdef WIN32
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDA(LPCSTR pszDevice);
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDW(LPCWSTR pszDevice);
#ifdef UNICODE
#define mciGetDeviceID  mciGetDeviceIDW
#else
#define mciGetDeviceID  mciGetDeviceIDA
#endif
#else
MCIDEVICEID WINAPI mciGetDeviceID(LPCSTR pszDevice);
#endif
#ifdef WIN32
WINMMAPI BOOL WINAPI mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText);
WINMMAPI BOOL WINAPI mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define mciGetErrorString       mciGetErrorStringW
#else
#define mciGetErrorString       mciGetErrorStringA
#endif
#else
BOOL WINAPI mciGetErrorString(MCIERROR mcierr, LPSTR pszText, UINT cchText);
#endif
WINMMAPI BOOL WINAPI mciSetYieldProc(MCIDEVICEID mciId, YIELDPROC fpYieldProc,
    DWORD dwYieldData);

#if (WINVER >= 0x030a)
WINMMAPI HTASK WINAPI mciGetCreatorTask(MCIDEVICEID mciId);
WINMMAPI YIELDPROC WINAPI mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData);
#endif /* ifdef WINVER >= 0x030a */

#if (WINVER < 0x030a)
WINMMAPI BOOL WINAPI mciExecute(LPCSTR pszCommand);
#endif /* ifdef WINVER < 0x030a */

/* MCI error return values */
#define MCIERR_INVALID_DEVICE_ID        (MCIERR_BASE + 1)
#define MCIERR_UNRECOGNIZED_KEYWORD     (MCIERR_BASE + 3)
#define MCIERR_UNRECOGNIZED_COMMAND     (MCIERR_BASE + 5)
#define MCIERR_HARDWARE                 (MCIERR_BASE + 6)
#define MCIERR_INVALID_DEVICE_NAME      (MCIERR_BASE + 7)
#define MCIERR_OUT_OF_MEMORY            (MCIERR_BASE + 8)
#define MCIERR_DEVICE_OPEN              (MCIERR_BASE + 9)
#define MCIERR_CANNOT_LOAD_DRIVER       (MCIERR_BASE + 10)
#define MCIERR_MISSING_COMMAND_STRING   (MCIERR_BASE + 11)
#define MCIERR_PARAM_OVERFLOW           (MCIERR_BASE + 12)
#define MCIERR_MISSING_STRING_ARGUMENT  (MCIERR_BASE + 13)
#define MCIERR_BAD_INTEGER              (MCIERR_BASE + 14)
#define MCIERR_PARSER_INTERNAL          (MCIERR_BASE + 15)
#define MCIERR_DRIVER_INTERNAL          (MCIERR_BASE + 16)
#define MCIERR_MISSING_PARAMETER        (MCIERR_BASE + 17)
#define MCIERR_UNSUPPORTED_FUNCTION     (MCIERR_BASE + 18)
#define MCIERR_FILE_NOT_FOUND           (MCIERR_BASE + 19)
#define MCIERR_DEVICE_NOT_READY         (MCIERR_BASE + 20)
#define MCIERR_INTERNAL                 (MCIERR_BASE + 21)
#define MCIERR_DRIVER                   (MCIERR_BASE + 22)
#define MCIERR_CANNOT_USE_ALL           (MCIERR_BASE + 23)
#define MCIERR_MULTIPLE                 (MCIERR_BASE + 24)
#define MCIERR_EXTENSION_NOT_FOUND      (MCIERR_BASE + 25)
#define MCIERR_OUTOFRANGE               (MCIERR_BASE + 26)
#define MCIERR_FLAGS_NOT_COMPATIBLE     (MCIERR_BASE + 28)
#define MCIERR_FILE_NOT_SAVED           (MCIERR_BASE + 30)
#define MCIERR_DEVICE_TYPE_REQUIRED     (MCIERR_BASE + 31)
#define MCIERR_DEVICE_LOCKED            (MCIERR_BASE + 32)
#define MCIERR_DUPLICATE_ALIAS          (MCIERR_BASE + 33)
#define MCIERR_BAD_CONSTANT             (MCIERR_BASE + 34)
#define MCIERR_MUST_USE_SHAREABLE       (MCIERR_BASE + 35)
#define MCIERR_MISSING_DEVICE_NAME      (MCIERR_BASE + 36)
#define MCIERR_BAD_TIME_FORMAT          (MCIERR_BASE + 37)
#define MCIERR_NO_CLOSING_QUOTE         (MCIERR_BASE + 38)
#define MCIERR_DUPLICATE_FLAGS          (MCIERR_BASE + 39)
#define MCIERR_INVALID_FILE             (MCIERR_BASE + 40)
#define MCIERR_NULL_PARAMETER_BLOCK     (MCIERR_BASE + 41)
#define MCIERR_UNNAMED_RESOURCE         (MCIERR_BASE + 42)
#define MCIERR_NEW_REQUIRES_ALIAS       (MCIERR_BASE + 43)
#define MCIERR_NOTIFY_ON_AUTO_OPEN      (MCIERR_BASE + 44)
#define MCIERR_NO_ELEMENT_ALLOWED       (MCIERR_BASE + 45)
#define MCIERR_NONAPPLICABLE_FUNCTION   (MCIERR_BASE + 46)
#define MCIERR_ILLEGAL_FOR_AUTO_OPEN    (MCIERR_BASE + 47)
#define MCIERR_FILENAME_REQUIRED        (MCIERR_BASE + 48)
#define MCIERR_EXTRA_CHARACTERS         (MCIERR_BASE + 49)
#define MCIERR_DEVICE_NOT_INSTALLED     (MCIERR_BASE + 50)
#define MCIERR_GET_CD                   (MCIERR_BASE + 51)
#define MCIERR_SET_CD                   (MCIERR_BASE + 52)
#define MCIERR_SET_DRIVE                (MCIERR_BASE + 53)
#define MCIERR_DEVICE_LENGTH            (MCIERR_BASE + 54)
#define MCIERR_DEVICE_ORD_LENGTH        (MCIERR_BASE + 55)
#define MCIERR_NO_INTEGER               (MCIERR_BASE + 56)

#define MCIERR_WAVE_OUTPUTSINUSE        (MCIERR_BASE + 64)
#define MCIERR_WAVE_SETOUTPUTINUSE      (MCIERR_BASE + 65)
#define MCIERR_WAVE_INPUTSINUSE         (MCIERR_BASE + 66)
#define MCIERR_WAVE_SETINPUTINUSE       (MCIERR_BASE + 67)
#define MCIERR_WAVE_OUTPUTUNSPECIFIED   (MCIERR_BASE + 68)
#define MCIERR_WAVE_INPUTUNSPECIFIED    (MCIERR_BASE + 69)
#define MCIERR_WAVE_OUTPUTSUNSUITABLE   (MCIERR_BASE + 70)
#define MCIERR_WAVE_SETOUTPUTUNSUITABLE (MCIERR_BASE + 71)
#define MCIERR_WAVE_INPUTSUNSUITABLE    (MCIERR_BASE + 72)
#define MCIERR_WAVE_SETINPUTUNSUITABLE  (MCIERR_BASE + 73)

#define MCIERR_SEQ_DIV_INCOMPATIBLE     (MCIERR_BASE + 80)
#define MCIERR_SEQ_PORT_INUSE           (MCIERR_BASE + 81)
#define MCIERR_SEQ_PORT_NONEXISTENT     (MCIERR_BASE + 82)
#define MCIERR_SEQ_PORT_MAPNODEVICE     (MCIERR_BASE + 83)
#define MCIERR_SEQ_PORT_MISCERROR       (MCIERR_BASE + 84)
#define MCIERR_SEQ_TIMER                (MCIERR_BASE + 85)
#define MCIERR_SEQ_PORTUNSPECIFIED      (MCIERR_BASE + 86)
#define MCIERR_SEQ_NOMIDIPRESENT        (MCIERR_BASE + 87)

#define MCIERR_NO_WINDOW                (MCIERR_BASE + 90)
#define MCIERR_CREATEWINDOW             (MCIERR_BASE + 91)
#define MCIERR_FILE_READ                (MCIERR_BASE + 92)
#define MCIERR_FILE_WRITE               (MCIERR_BASE + 93)

#define MCIERR_NO_IDENTITY              (MCIERR_BASE + 94)

/* all custom device driver errors must be >= than this value */
#define MCIERR_CUSTOM_DRIVER_BASE       (MCIERR_BASE + 256)

/* MCI command message identifiers */
#define MCI_OPEN                        0x0803
#define MCI_CLOSE                       0x0804
#define MCI_ESCAPE                      0x0805
#define MCI_PLAY                        0x0806
#define MCI_SEEK                        0x0807
#define MCI_STOP                        0x0808
#define MCI_PAUSE                       0x0809
#define MCI_INFO                        0x080A
#define MCI_GETDEVCAPS                  0x080B
#define MCI_SPIN                        0x080C
#define MCI_SET                         0x080D
#define MCI_STEP                        0x080E
#define MCI_RECORD                      0x080F
#define MCI_SYSINFO                     0x0810
#define MCI_BREAK                       0x0811
//reserved                              0x0812
#define MCI_SAVE                        0x0813
#define MCI_STATUS                      0x0814
#define MCI_CUE                         0x0830
#define MCI_REALIZE                     0x0840
#define MCI_WINDOW                      0x0841
#define MCI_PUT                         0x0842
#define MCI_WHERE                       0x0843
#define MCI_FREEZE                      0x0844
#define MCI_UNFREEZE                    0x0845
#define MCI_LOAD                        0x0850
#define MCI_CUT                         0x0851
#define MCI_COPY                        0x0852
#define MCI_PASTE                       0x0853
#define MCI_UPDATE                      0x0854
#define MCI_RESUME                      0x0855
#define MCI_DELETE                      0x0856

/* all custom MCI command messages must be >= than this value */
#define MCI_USER_MESSAGES               (DRV_MCI_FIRST + 0x400)


/* device ID for "all devices" */
#define MCI_ALL_DEVICE_ID               ((MCIDEVICEID)-1)

/* constants for predefined MCI device types */
#define MCI_DEVTYPE_VCR                 (MCI_STRING_OFFSET + 1)
#define MCI_DEVTYPE_VIDEODISC           (MCI_STRING_OFFSET + 2)
#define MCI_DEVTYPE_OVERLAY             (MCI_STRING_OFFSET + 3)
#define MCI_DEVTYPE_CD_AUDIO            (MCI_STRING_OFFSET + 4)
#define MCI_DEVTYPE_DAT                 (MCI_STRING_OFFSET + 5)
#define MCI_DEVTYPE_SCANNER             (MCI_STRING_OFFSET + 6)
#define MCI_DEVTYPE_ANIMATION           (MCI_STRING_OFFSET + 7)
#define MCI_DEVTYPE_DIGITAL_VIDEO       (MCI_STRING_OFFSET + 8)
#define MCI_DEVTYPE_OTHER               (MCI_STRING_OFFSET + 9)
#define MCI_DEVTYPE_WAVEFORM_AUDIO      (MCI_STRING_OFFSET + 10)
#define MCI_DEVTYPE_SEQUENCER           (MCI_STRING_OFFSET + 11)

#define MCI_DEVTYPE_FIRST               MCI_DEVTYPE_VCR
#define MCI_DEVTYPE_LAST                MCI_DEVTYPE_SEQUENCER

/* return values for 'status mode' command */
#define MCI_MODE_NOT_READY              (MCI_STRING_OFFSET + 12)
#define MCI_MODE_STOP                   (MCI_STRING_OFFSET + 13)
#define MCI_MODE_PLAY                   (MCI_STRING_OFFSET + 14)
#define MCI_MODE_RECORD                 (MCI_STRING_OFFSET + 15)
#define MCI_MODE_SEEK                   (MCI_STRING_OFFSET + 16)
#define MCI_MODE_PAUSE                  (MCI_STRING_OFFSET + 17)
#define MCI_MODE_OPEN                   (MCI_STRING_OFFSET + 18)

/* constants used in 'set time format' and 'status time format' commands */
#define MCI_FORMAT_MILLISECONDS         0
#define MCI_FORMAT_HMS                  1
#define MCI_FORMAT_MSF                  2
#define MCI_FORMAT_FRAMES               3
#define MCI_FORMAT_SMPTE_24             4
#define MCI_FORMAT_SMPTE_25             5
#define MCI_FORMAT_SMPTE_30             6
#define MCI_FORMAT_SMPTE_30DROP         7
#define MCI_FORMAT_BYTES                8
#define MCI_FORMAT_SAMPLES              9
#define MCI_FORMAT_TMSF                 10

/* MCI time format conversion macros */
#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
						  ((WORD)(s)<<8)) | \
						 (((DWORD)(BYTE)(f))<<16)))

#define MCI_TMSF_TRACK(tmsf)            ((BYTE)(tmsf))
#define MCI_TMSF_MINUTE(tmsf)           ((BYTE)(((WORD)(tmsf)) >> 8))
#define MCI_TMSF_SECOND(tmsf)           ((BYTE)((tmsf)>>16))
#define MCI_TMSF_FRAME(tmsf)            ((BYTE)((tmsf)>>24))

#define MCI_MAKE_TMSF(t, m, s, f)       ((DWORD)(((BYTE)(t) | \
						  ((WORD)(m)<<8)) | \
						 (((DWORD)(BYTE)(s) | \
						   ((WORD)(f)<<8))<<16)))

#define MCI_HMS_HOUR(hms)               ((BYTE)(hms))
#define MCI_HMS_MINUTE(hms)             ((BYTE)(((WORD)(hms)) >> 8))
#define MCI_HMS_SECOND(hms)             ((BYTE)((hms)>>16))

#define MCI_MAKE_HMS(h, m, s)           ((DWORD)(((BYTE)(h) | \
						  ((WORD)(m)<<8)) | \
						 (((DWORD)(BYTE)(s))<<16)))


/* flags for wParam of MM_MCINOTIFY message */
#define MCI_NOTIFY_SUCCESSFUL           0x0001
#define MCI_NOTIFY_SUPERSEDED           0x0002
#define MCI_NOTIFY_ABORTED              0x0004
#define MCI_NOTIFY_FAILURE              0x0008


/* common flags for dwFlags parameter of MCI command messages */
#define MCI_NOTIFY                      0x00000001L
#define MCI_WAIT                        0x00000002L
#define MCI_FROM                        0x00000004L
#define MCI_TO                          0x00000008L
#define MCI_TRACK                       0x00000010L

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OPEN_SHAREABLE              0x00000100L
#define MCI_OPEN_ELEMENT                0x00000200L
#define MCI_OPEN_ALIAS                  0x00000400L
#define MCI_OPEN_ELEMENT_ID             0x00000800L
#define MCI_OPEN_TYPE_ID                0x00001000L
#define MCI_OPEN_TYPE                   0x00002000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_SEEK_TO_START               0x00000100L
#define MCI_SEEK_TO_END                 0x00000200L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_STATUS_ITEM                 0x00000100L
#define MCI_STATUS_START                0x00000200L

/* flags for dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_STATUS_LENGTH               0x00000001L
#define MCI_STATUS_POSITION             0x00000002L
#define MCI_STATUS_NUMBER_OF_TRACKS     0x00000003L
#define MCI_STATUS_MODE                 0x00000004L
#define MCI_STATUS_MEDIA_PRESENT        0x00000005L
#define MCI_STATUS_TIME_FORMAT          0x00000006L
#define MCI_STATUS_READY                0x00000007L
#define MCI_STATUS_CURRENT_TRACK        0x00000008L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_INFO_PRODUCT                0x00000100L
#define MCI_INFO_FILE                   0x00000200L
#define MCI_INFO_MEDIA_UPC              0x00000400L
#define MCI_INFO_MEDIA_IDENTITY         0x00000800L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_GETDEVCAPS_ITEM             0x00000100L

/* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_GETDEVCAPS_CAN_RECORD       0x00000001L
#define MCI_GETDEVCAPS_HAS_AUDIO        0x00000002L
#define MCI_GETDEVCAPS_HAS_VIDEO        0x00000003L
#define MCI_GETDEVCAPS_DEVICE_TYPE      0x00000004L
#define MCI_GETDEVCAPS_USES_FILES       0x00000005L
#define MCI_GETDEVCAPS_COMPOUND_DEVICE  0x00000006L
#define MCI_GETDEVCAPS_CAN_EJECT        0x00000007L
#define MCI_GETDEVCAPS_CAN_PLAY         0x00000008L
#define MCI_GETDEVCAPS_CAN_SAVE         0x00000009L

/* flags for dwFlags parameter of MCI_SYSINFO command message */
#define MCI_SYSINFO_QUANTITY            0x00000100L
#define MCI_SYSINFO_OPEN                0x00000200L
#define MCI_SYSINFO_NAME                0x00000400L
#define MCI_SYSINFO_INSTALLNAME         0x00000800L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_SET_DOOR_OPEN               0x00000100L
#define MCI_SET_DOOR_CLOSED             0x00000200L
#define MCI_SET_TIME_FORMAT             0x00000400L
#define MCI_SET_AUDIO                   0x00000800L
#define MCI_SET_VIDEO                   0x00001000L
#define MCI_SET_ON                      0x00002000L
#define MCI_SET_OFF                     0x00004000L

/* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS */
#ifdef WIN32
#define MCI_SET_AUDIO_ALL               0x00004001L
#define MCI_SET_AUDIO_LEFT              0x00004002L
#define MCI_SET_AUDIO_RIGHT             0x00004003L
#else
#define MCI_SET_AUDIO_ALL               0x00000000L
#define MCI_SET_AUDIO_LEFT              0x00000001L
#define MCI_SET_AUDIO_RIGHT             0x00000002L
#endif

/* flags for dwFlags parameter of MCI_BREAK command message */
#define MCI_BREAK_KEY                   0x00000100L
#define MCI_BREAK_HWND                  0x00000200L
#define MCI_BREAK_OFF                   0x00000400L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_RECORD_INSERT               0x00000100L
#define MCI_RECORD_OVERWRITE            0x00000200L

/* flags for dwFlags parameter of MCI_SAVE command message */
#define MCI_SAVE_FILE                   0x00000100L

/* flags for dwFlags parameter of MCI_LOAD command message */
#define MCI_LOAD_FILE                   0x00000100L


/* generic parameter block for MCI command messages with no special parameters */
typedef struct tagMCI_GENERIC_PARMS {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS, FAR *LPMCI_GENERIC_PARMS;


/* parameter block for MCI_OPEN command message */
#ifdef WIN32
typedef struct tagMCI_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR     lpstrDeviceType;
    LPCSTR     lpstrElementName;
    LPCSTR     lpstrAlias;
} MCI_OPEN_PARMSA, *LPMCI_OPEN_PARMSA;
typedef struct tagMCI_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR    lpstrDeviceType;
    LPCWSTR    lpstrElementName;
    LPCWSTR    lpstrAlias;
} MCI_OPEN_PARMSW, *LPMCI_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_OPEN_PARMSW MCI_OPEN_PARMS, *LPMCI_OPEN_PARMS;
#else
typedef MCI_OPEN_PARMSA MCI_OPEN_PARMS, *LPMCI_OPEN_PARMS;
#endif
#else
typedef struct tagMCI_OPEN_PARMS {
    DWORD       dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
} MCI_OPEN_PARMS, FAR *LPMCI_OPEN_PARMS;
#endif


/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS, FAR *LPMCI_PLAY_PARMS;


/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS, FAR *LPMCI_SEEK_PARMS;


/* parameter block for MCI_STATUS command message */
typedef struct tagMCI_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS, FAR * LPMCI_STATUS_PARMS;


/* parameter block for MCI_INFO command message */
#ifdef WIN32
typedef struct tagMCI_INFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSA, * LPMCI_INFO_PARMSA;
typedef struct tagMCI_INFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSW, * LPMCI_INFO_PARMSW;
#ifdef UNICODE
typedef MCI_INFO_PARMSW MCI_INFO_PARMS, *LPMCI_INFO_PARMS;
#else
typedef MCI_INFO_PARMSA MCI_INFO_PARMS, *LPMCI_INFO_PARMS;
#endif
#else
typedef struct tagMCI_INFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS, FAR * LPMCI_INFO_PARMS;
#endif


/* parameter block for MCI_GETDEVCAPS command message */
typedef struct tagMCI_GETDEVCAPS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS, FAR * LPMCI_GETDEVCAPS_PARMS;


/* parameter block for MCI_SYSINFO command message */
#ifdef WIN32
typedef struct tagMCI_SYSINFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSA, * LPMCI_SYSINFO_PARMSA;
typedef struct tagMCI_SYSINFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSW, * LPMCI_SYSINFO_PARMSW;
#ifdef UNICODE
typedef MCI_SYSINFO_PARMSW MCI_SYSINFO_PARMS, *LPMCI_SYSINFO_PARMS;
#else
typedef MCI_SYSINFO_PARMSA MCI_SYSINFO_PARMS, *LPMCI_SYSINFO_PARMS;
#endif
#else
typedef struct tagMCI_SYSINFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    WORD    wDeviceType;
    WORD    wReserved0;
} MCI_SYSINFO_PARMS, FAR * LPMCI_SYSINFO_PARMS;
#endif


/* parameter block for MCI_SET command message */
typedef struct tagMCI_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS, FAR *LPMCI_SET_PARMS;


/* parameter block for MCI_BREAK command message */
typedef struct tagMCI_BREAK_PARMS {
    DWORD   dwCallback;
#ifdef WIN32
    int     nVirtKey;
    HWND    hwndBreak;
#else
    short   nVirtKey;
    WORD    wReserved0;             /* padding for Win 16 */
    HWND    hwndBreak;
    WORD    wReserved1;             /* padding for Win 16 */
#endif
} MCI_BREAK_PARMS, FAR * LPMCI_BREAK_PARMS;


/* parameter block for MCI_SAVE command message */
#ifdef WIN32
typedef struct tagMCI_SAVE_PARMSA {
    DWORD    dwCallback;
    LPCSTR    lpfilename;
} MCI_SAVE_PARMSA, * LPMCI_SAVE_PARMSA;
typedef struct tagMCI_SAVE_PARMSW {
    DWORD    dwCallback;
    LPCWSTR   lpfilename;
} MCI_SAVE_PARMSW, * LPMCI_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_SAVE_PARMSW MCI_SAVE_PARMS, *LPMCI_SAVE_PARMS;
#else
typedef MCI_SAVE_PARMSA MCI_SAVE_PARMS, *LPMCI_SAVE_PARMS;
#endif
#else
typedef struct tagMCI_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_SAVE_PARMS, FAR * LPMCI_SAVE_PARMS;
#endif


/* parameter block for MCI_LOAD command message */
#ifdef WIN32
typedef struct tagMCI_LOAD_PARMSA {
    DWORD    dwCallback;
    LPCSTR    lpfilename;
} MCI_LOAD_PARMSA, * LPMCI_LOAD_PARMSA;
typedef struct tagMCI_LOAD_PARMSW {
    DWORD    dwCallback;
    LPCWSTR   lpfilename;
} MCI_LOAD_PARMSW, * LPMCI_LOAD_PARMSW;
#ifdef UNICODE
typedef MCI_LOAD_PARMSW MCI_LOAD_PARMS, *LPMCI_LOAD_PARMS;
#else
typedef MCI_LOAD_PARMSA MCI_LOAD_PARMS, *LPMCI_LOAD_PARMS;
#endif
#else
typedef struct tagMCI_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_LOAD_PARMS, FAR * LPMCI_LOAD_PARMS;
#endif


/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS, FAR *LPMCI_RECORD_PARMS;


/* MCI extensions for videodisc devices */

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_STATUS_MODE) */
#define MCI_VD_MODE_PARK                (MCI_VD_OFFSET + 1)

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE) */
#define MCI_VD_MEDIA_CLV                (MCI_VD_OFFSET + 2)
#define MCI_VD_MEDIA_CAV                (MCI_VD_OFFSET + 3)
#define MCI_VD_MEDIA_OTHER              (MCI_VD_OFFSET + 4)

#define MCI_VD_FORMAT_TRACK             0x4001

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VD_PLAY_REVERSE             0x00010000L
#define MCI_VD_PLAY_FAST                0x00020000L
#define MCI_VD_PLAY_SPEED               0x00040000L
#define MCI_VD_PLAY_SCAN                0x00080000L
#define MCI_VD_PLAY_SLOW                0x00100000L

/* flag for dwFlags parameter of MCI_SEEK command message */
#define MCI_VD_SEEK_REVERSE             0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VD_STATUS_SPEED             0x00004002L
#define MCI_VD_STATUS_FORWARD           0x00004003L
#define MCI_VD_STATUS_MEDIA_TYPE        0x00004004L
#define MCI_VD_STATUS_SIDE              0x00004005L
#define MCI_VD_STATUS_DISC_SIZE         0x00004006L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_VD_GETDEVCAPS_CLV           0x00010000L
#define MCI_VD_GETDEVCAPS_CAV           0x00020000L

#define MCI_VD_SPIN_UP                  0x00010000L
#define MCI_VD_SPIN_DOWN                0x00020000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VD_GETDEVCAPS_CAN_REVERSE   0x00004002L
#define MCI_VD_GETDEVCAPS_FAST_RATE     0x00004003L
#define MCI_VD_GETDEVCAPS_SLOW_RATE     0x00004004L
#define MCI_VD_GETDEVCAPS_NORMAL_RATE   0x00004005L

/* flags for the dwFlags parameter of MCI_STEP command message */
#define MCI_VD_STEP_FRAMES              0x00010000L
#define MCI_VD_STEP_REVERSE             0x00020000L

/* flag for the MCI_ESCAPE command message */
#define MCI_VD_ESCAPE_STRING            0x00000100L


/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VD_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_VD_PLAY_PARMS, FAR *LPMCI_VD_PLAY_PARMS;


/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VD_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS, FAR *LPMCI_VD_STEP_PARMS;


/* parameter block for MCI_ESCAPE command message */
#ifdef WIN32
typedef struct tagMCI_VD_ESCAPE_PARMSA {
    DWORD   dwCallback;
    LPCSTR    lpstrCommand;
} MCI_VD_ESCAPE_PARMSA, *LPMCI_VD_ESCAPE_PARMSA;
typedef struct tagMCI_VD_ESCAPE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR   lpstrCommand;
} MCI_VD_ESCAPE_PARMSW, *LPMCI_VD_ESCAPE_PARMSW;
#ifdef UNICODE
typedef MCI_VD_ESCAPE_PARMSW MCI_VD_ESCAPE_PARMS, *LPMCI_VD_ESCAPE_PARMS;
#else
typedef MCI_VD_ESCAPE_PARMSA MCI_VD_ESCAPE_PARMS, *LPMCI_VD_ESCAPE_PARMS;
#endif
#else
typedef struct tagMCI_VD_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS, FAR *LPMCI_VD_ESCAPE_PARMS;
#endif

/* MCI extensions for CD audio devices */

/* flags for the dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_CDA_STATUS_TYPE_TRACK       0x00004001L

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK) */
#define MCI_CDA_TRACK_AUDIO             (MCI_CD_OFFSET + 0)
#define MCI_CDA_TRACK_OTHER             (MCI_CD_OFFSET + 1)

/* MCI extensions for waveform audio devices */

/* flags for the dwFlags parameter of MCI_OPEN command message */
#define MCI_WAVE_OPEN_BUFFER            0x00010000L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_FORMATTAG          0x00010000L
#define MCI_WAVE_SET_CHANNELS           0x00020000L
#define MCI_WAVE_SET_SAMPLESPERSEC      0x00040000L
#define MCI_WAVE_SET_AVGBYTESPERSEC     0x00080000L
#define MCI_WAVE_SET_BLOCKALIGN         0x00100000L
#define MCI_WAVE_SET_BITSPERSAMPLE      0x00200000L

/* flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages */
#define MCI_WAVE_INPUT                  0x00400000L
#define MCI_WAVE_OUTPUT                 0x00800000L

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_WAVE_STATUS_FORMATTAG       0x00004001L
#define MCI_WAVE_STATUS_CHANNELS        0x00004002L
#define MCI_WAVE_STATUS_SAMPLESPERSEC   0x00004003L
#define MCI_WAVE_STATUS_AVGBYTESPERSEC  0x00004004L
#define MCI_WAVE_STATUS_BLOCKALIGN      0x00004005L
#define MCI_WAVE_STATUS_BITSPERSAMPLE   0x00004006L
#define MCI_WAVE_STATUS_LEVEL           0x00004007L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_ANYINPUT           0x04000000L
#define MCI_WAVE_SET_ANYOUTPUT          0x08000000L

/* flags for the dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_WAVE_GETDEVCAPS_INPUTS      0x00004001L
#define MCI_WAVE_GETDEVCAPS_OUTPUTS     0x00004002L


/* parameter block for MCI_OPEN command message */
#ifdef WIN32
typedef struct tagMCI_WAVE_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR    lpstrDeviceType;
    LPCSTR    lpstrElementName;
    LPCSTR    lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSA, *LPMCI_WAVE_OPEN_PARMSA;
typedef struct tagMCI_WAVE_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR   lpstrDeviceType;
    LPCWSTR   lpstrElementName;
    LPCWSTR   lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSW, *LPMCI_WAVE_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_WAVE_OPEN_PARMSW MCI_WAVE_OPEN_PARMS, *LPMCI_WAVE_OPEN_PARMS;
#else
typedef MCI_WAVE_OPEN_PARMSA MCI_WAVE_OPEN_PARMS, *LPMCI_WAVE_OPEN_PARMS;
#endif
#else
typedef struct tagMCI_WAVE_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS, FAR *LPMCI_WAVE_OPEN_PARMS;
#endif


/* parameter block for MCI_DELETE command message */
typedef struct tagMCI_WAVE_DELETE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_WAVE_DELETE_PARMS, FAR *LPMCI_WAVE_DELETE_PARMS;


/* parameter block for MCI_SET command message */
typedef struct tagMCI_WAVE_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
#ifdef WIN32
    UINT    wInput;
    UINT    wOutput;
#else
    WORD    wInput;
    WORD    wReserved0;
    WORD    wOutput;
    WORD    wReserved1;
#endif
    WORD    wFormatTag;
    WORD    wReserved2;
    WORD    nChannels;
    WORD    wReserved3;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
    WORD    wReserved4;
    WORD    wBitsPerSample;
    WORD    wReserved5;
} MCI_WAVE_SET_PARMS, FAR * LPMCI_WAVE_SET_PARMS;


/* MCI extensions for MIDI sequencer devices */

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE) */
#define     MCI_SEQ_DIV_PPQN            (0 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_24        (1 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_25        (2 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30DROP    (3 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30        (4 + MCI_SEQ_OFFSET)

/* flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block */
/* MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER) */
#define     MCI_SEQ_FORMAT_SONGPTR      0x4001
#define     MCI_SEQ_FILE                0x4002
#define     MCI_SEQ_MIDI                0x4003
#define     MCI_SEQ_SMPTE               0x4004
#define     MCI_SEQ_NONE                65533

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_SEQ_STATUS_TEMPO            0x00004002L
#define MCI_SEQ_STATUS_PORT             0x00004003L
#define MCI_SEQ_STATUS_SLAVE            0x00004007L
#define MCI_SEQ_STATUS_MASTER           0x00004008L
#define MCI_SEQ_STATUS_OFFSET           0x00004009L
#define MCI_SEQ_STATUS_DIVTYPE          0x0000400AL

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_SEQ_SET_TEMPO               0x00010000L
#define MCI_SEQ_SET_PORT                0x00020000L
#define MCI_SEQ_SET_SLAVE               0x00040000L
#define MCI_SEQ_SET_MASTER              0x00080000L
#define MCI_SEQ_SET_OFFSET              0x01000000L


/* parameter block for MCI_SET command message */
typedef struct tagMCI_SEQ_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS, FAR * LPMCI_SEQ_SET_PARMS;


/* MCI extensions for animation devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_ANIM_OPEN_WS                0x00010000L
#define MCI_ANIM_OPEN_PARENT            0x00020000L
#define MCI_ANIM_OPEN_NOSTATIC          0x00040000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_ANIM_PLAY_SPEED             0x00010000L
#define MCI_ANIM_PLAY_REVERSE           0x00020000L
#define MCI_ANIM_PLAY_FAST              0x00040000L
#define MCI_ANIM_PLAY_SLOW              0x00080000L
#define MCI_ANIM_PLAY_SCAN              0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_ANIM_STEP_REVERSE           0x00010000L
#define MCI_ANIM_STEP_FRAMES            0x00020000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_ANIM_STATUS_SPEED           0x00004001L
#define MCI_ANIM_STATUS_FORWARD         0x00004002L
#define MCI_ANIM_STATUS_HWND            0x00004003L
#define MCI_ANIM_STATUS_HPAL            0x00004004L
#define MCI_ANIM_STATUS_STRETCH         0x00004005L

/* flags for the dwFlags parameter of MCI_INFO command message */
#define MCI_ANIM_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_ANIM_GETDEVCAPS_CAN_REVERSE 0x00004001L
#define MCI_ANIM_GETDEVCAPS_FAST_RATE   0x00004002L
#define MCI_ANIM_GETDEVCAPS_SLOW_RATE   0x00004003L
#define MCI_ANIM_GETDEVCAPS_NORMAL_RATE 0x00004004L
#define MCI_ANIM_GETDEVCAPS_PALETTES    0x00004006L
#define MCI_ANIM_GETDEVCAPS_CAN_STRETCH 0x00004007L
#define MCI_ANIM_GETDEVCAPS_MAX_WINDOWS 0x00004008L

/* flags for the MCI_REALIZE command message */
#define MCI_ANIM_REALIZE_NORM           0x00010000L
#define MCI_ANIM_REALIZE_BKGD           0x00020000L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_ANIM_WINDOW_HWND            0x00010000L
#define MCI_ANIM_WINDOW_STATE           0x00040000L
#define MCI_ANIM_WINDOW_TEXT            0x00080000L
#define MCI_ANIM_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_ANIM_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block */
/* MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND) */
#define MCI_ANIM_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_ANIM_RECT                   0x00010000L
#define MCI_ANIM_PUT_SOURCE             0x00020000L
#define MCI_ANIM_PUT_DESTINATION        0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_ANIM_WHERE_SOURCE           0x00020000L
#define MCI_ANIM_WHERE_DESTINATION      0x00040000L

/* flags for dwFlags parameter of MCI_UPDATE command message */
#define MCI_ANIM_UPDATE_HDC             0x00020000L


/* parameter block for MCI_OPEN command message */
#ifdef WIN32
typedef struct tagMCI_ANIM_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR    lpstrDeviceType;
    LPCSTR    lpstrElementName;
    LPCSTR    lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSA, *LPMCI_ANIM_OPEN_PARMSA;
typedef struct tagMCI_ANIM_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR   lpstrDeviceType;
    LPCWSTR   lpstrElementName;
    LPCWSTR   lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSW, *LPMCI_ANIM_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_ANIM_OPEN_PARMSW MCI_ANIM_OPEN_PARMS, *LPMCI_ANIM_OPEN_PARMS;
#else
typedef MCI_ANIM_OPEN_PARMSA MCI_ANIM_OPEN_PARMS, *LPMCI_ANIM_OPEN_PARMS;
#endif
#else
typedef struct tagMCI_ANIM_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwStyle;
    HWND        hWndParent;
    WORD        wReserved1;
} MCI_ANIM_OPEN_PARMS, FAR *LPMCI_ANIM_OPEN_PARMS;
#endif


/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_ANIM_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS, FAR *LPMCI_ANIM_PLAY_PARMS;


/* parameter block for MCI_STEP command message */
typedef struct tagMCI_ANIM_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS, FAR *LPMCI_ANIM_STEP_PARMS;


/* parameter block for MCI_WINDOW command message */
#ifdef WIN32
typedef struct tagMCI_ANIM_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR   lpstrText;
} MCI_ANIM_WINDOW_PARMSA, * LPMCI_ANIM_WINDOW_PARMSA;
typedef struct tagMCI_ANIM_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMSW, * LPMCI_ANIM_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_ANIM_WINDOW_PARMSW MCI_ANIM_WINDOW_PARMS, *LPMCI_ANIM_WINDOW_PARMS;
#else
typedef MCI_ANIM_WINDOW_PARMSA MCI_ANIM_WINDOW_PARMS, *LPMCI_ANIM_WINDOW_PARMS;
#endif
#else
typedef struct tagMCI_ANIM_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS, FAR * LPMCI_ANIM_WINDOW_PARMS;
#endif


/* parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages */
typedef struct tagMCI_ANIM_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS FAR * LPMCI_ANIM_RECT_PARMS;


/* parameter block for MCI_UPDATE PARMS */
typedef struct tagMCI_ANIM_UPDATE_PARMS {
    DWORD   dwCallback;
    RECT    rc;
    HDC     hDC;
} MCI_ANIM_UPDATE_PARMS, FAR * LPMCI_ANIM_UPDATE_PARMS;


/* MCI extensions for video overlay devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OVLY_OPEN_WS                0x00010000L
#define MCI_OVLY_OPEN_PARENT            0x00020000L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_OVLY_STATUS_HWND            0x00004001L
#define MCI_OVLY_STATUS_STRETCH         0x00004002L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_OVLY_INFO_TEXT              0x00010000L 

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_OVLY_GETDEVCAPS_CAN_STRETCH 0x00004001L
#define MCI_OVLY_GETDEVCAPS_CAN_FREEZE  0x00004002L
#define MCI_OVLY_GETDEVCAPS_MAX_WINDOWS 0x00004003L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_OVLY_WINDOW_HWND            0x00010000L
#define MCI_OVLY_WINDOW_STATE           0x00040000L
#define MCI_OVLY_WINDOW_TEXT            0x00080000L
#define MCI_OVLY_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_OVLY_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block */
#define MCI_OVLY_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_OVLY_RECT                   0x00010000L
#define MCI_OVLY_PUT_SOURCE             0x00020000L
#define MCI_OVLY_PUT_DESTINATION        0x00040000L
#define MCI_OVLY_PUT_FRAME              0x00080000L
#define MCI_OVLY_PUT_VIDEO              0x00100000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_OVLY_WHERE_SOURCE           0x00020000L
#define MCI_OVLY_WHERE_DESTINATION      0x00040000L
#define MCI_OVLY_WHERE_FRAME            0x00080000L
#define MCI_OVLY_WHERE_VIDEO            0x00100000L


/* parameter block for MCI_OPEN command message */
#ifdef WIN32
typedef struct tagMCI_OVLY_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR    lpstrDeviceType;
    LPCSTR    lpstrElementName;
    LPCSTR    lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSA, *LPMCI_OVLY_OPEN_PARMSA;
typedef struct tagMCI_OVLY_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR   lpstrDeviceType;
    LPCWSTR   lpstrElementName;
    LPCWSTR   lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSW, *LPMCI_OVLY_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_OPEN_PARMSW MCI_OVLY_OPEN_PARMS, *LPMCI_OVLY_OPEN_PARMS;
#else
typedef MCI_OVLY_OPEN_PARMSA MCI_OVLY_OPEN_PARMS, *LPMCI_OVLY_OPEN_PARMS;
#endif
#else
typedef struct tagMCI_OVLY_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwStyle;
    HWND        hWndParent;
    WORD        wReserved1;
} MCI_OVLY_OPEN_PARMS, FAR *LPMCI_OVLY_OPEN_PARMS;
#endif


/* parameter block for MCI_WINDOW command message */
#ifdef WIN32
typedef struct tagMCI_OVLY_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR    lpstrText;
} MCI_OVLY_WINDOW_PARMSA, * LPMCI_OVLY_WINDOW_PARMSA;
typedef struct tagMCI_OVLY_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR   lpstrText;
} MCI_OVLY_WINDOW_PARMSW, * LPMCI_OVLY_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_WINDOW_PARMSW MCI_OVLY_WINDOW_PARMS, *LPMCI_OVLY_WINDOW_PARMS;
#else
typedef MCI_OVLY_WINDOW_PARMSA MCI_OVLY_WINDOW_PARMS, *LPMCI_OVLY_WINDOW_PARMS;
#endif
#else
typedef struct tagMCI_OVLY_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    WORD    wReserved1;
    UINT    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS, FAR * LPMCI_OVLY_WINDOW_PARMS;
#endif


/* parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages */
typedef struct tagMCI_OVLY_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_OVLY_RECT_PARMS, FAR * LPMCI_OVLY_RECT_PARMS;


/* parameter block for MCI_SAVE command message */
#ifdef WIN32
typedef struct tagMCI_OVLY_SAVE_PARMSA {
    DWORD   dwCallback;
    LPCSTR    lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSA, * LPMCI_OVLY_SAVE_PARMSA;
typedef struct tagMCI_OVLY_SAVE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR   lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSW, * LPMCI_OVLY_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_SAVE_PARMSW MCI_OVLY_SAVE_PARMS, *LPMCI_OVLY_SAVE_PARMS;
#else
typedef MCI_OVLY_SAVE_PARMSA MCI_OVLY_SAVE_PARMS, *LPMCI_OVLY_SAVE_PARMS;
#endif
#else
typedef struct tagMCI_OVLY_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMS, FAR * LPMCI_OVLY_SAVE_PARMS;
#endif


/* parameter block for MCI_LOAD command message */
#ifdef WIN32
typedef struct tagMCI_OVLY_LOAD_PARMSA {
    DWORD   dwCallback;
    LPCSTR    lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSA, * LPMCI_OVLY_LOAD_PARMSA;
typedef struct tagMCI_OVLY_LOAD_PARMSW {
    DWORD   dwCallback;
    LPCWSTR   lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSW, * LPMCI_OVLY_LOAD_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_LOAD_PARMSW MCI_OVLY_LOAD_PARMS, *LPMCI_OVLY_LOAD_PARMS;
#else
typedef MCI_OVLY_LOAD_PARMSA MCI_OVLY_LOAD_PARMS, *LPMCI_OVLY_LOAD_PARMS;
#endif
#else
typedef struct tagMCI_OVLY_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMS, FAR * LPMCI_OVLY_LOAD_PARMS;
#endif

#endif  /* ifndef MMNOMCI */

/****************************************************************************

			DISPLAY Driver extensions

****************************************************************************/

#ifndef C1_TRANSPARENT
    #define CAPS1           94          /* other caps */
    #define C1_TRANSPARENT  0x0001      /* new raster cap */
    #define NEWTRANSPARENT  3           /* use with SetBkMode() */

    #define QUERYROPSUPPORT 40          /* use to determine ROP support */
#endif  /* ifndef C1_TRANSPARENT */

/****************************************************************************

			DIB Driver extensions

****************************************************************************/

#define SELECTDIB       41                      /* DIB.DRV select dib escape */
#define DIBINDEX(n)     MAKELONG((n),0x10FF)


/****************************************************************************

			ScreenSaver support

    The current application will receive a syscommand of SC_SCREENSAVE just
    before the screen saver is invoked.  If the app wishes to prevent a
    screen save, return non-zero value, otherwise call DefWindowProc().

****************************************************************************/

#ifndef SC_SCREENSAVE

    #define SC_SCREENSAVE   0xF140

#endif  /* ifndef SC_SCREENSAVE */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif  /* _INC_MMSYSTEM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\mmddk.h ===
/*==========================================================================;
 *
 *  mmddk.h -- Include file for Multimedia Device Development
 *
 *  Version 4.00
 *
 *  Copyright (C) 1992-1994 Microsoft Corporation.  All rights reserved.
 *
 *--------------------------------------------------------------------------;
 *  Note: You must include the WINDOWS.H and MMSYSTEM.H header files
 *        before including this file.
 *
 *  Define:         Prevent inclusion of:
 *  --------------  --------------------------------------------------------
 *  MMNOMIDIDEV     MIDI support
 *  MMNOWAVEDEV     Waveform support
 *  MMNOAUXDEV      Auxiliary output support
 *  MMNOMIXERDEV    Mixer support
 *  MMNOTIMERDEV    Timer support
 *  MMNOJOYDEV      Joystick support
 *  MMNOMCIDEV      MCI support
 *  MMNOTASKDEV     Task support
 *
 *==========================================================================;
 */

#ifndef _INC_MMDDK
#define _INC_MMDDK   /* #defined if mmddk.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/***************************************************************************

                       Helper functions for drivers

***************************************************************************/

#ifdef WIN32

#ifndef NODRIVERS
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A

#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

#define DRIVERS_SECTION  TEXT("DRIVERS32")     // Section name for installed drivers
#define MCI_SECTION      TEXT("MCI32")         // Section name for installed MCI drivers

LRESULT   WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
#endif /* !NODRIVERS */

#endif /* ifdef WIN32 */

#if (WINVER < 0x0400)
#define DCB_NOSWITCH   0x0008           /* obsolete switch */
#endif
#define DCB_TYPEMASK   0x0007           /* callback type mask */
#define DCB_NULL       0x0000           /* unknown callback type */

/* flags for wFlags parameter of DriverCallback() */
#define DCB_WINDOW     0x0001           /* dwCallback is a HWND */
#define DCB_TASK       0x0002           /* dwCallback is a HTASK */
#define DCB_FUNCTION   0x0003           /* dwCallback is a FARPROC */
#define DCB_WINDOW32   0x0004           /* dwCallback is a WINDOW */ /* ;Internal */

BOOL WINAPI DriverCallback(DWORD dwCallback, UINT uFlags,
    HANDLE hDevice, UINT uMessage, DWORD dwUser, DWORD dwParam1, DWORD dwParam2);

#if (WINVER < 0x0400)
void WINAPI StackEnter(void);
void WINAPI StackLeave(void);
#endif

/* generic prototype for audio device driver entry-point functions */
/* midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage() */
typedef DWORD (CALLBACK SOUNDDEVMSGPROC)(UINT uDeviceID, UINT uMessage,
    DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
typedef SOUNDDEVMSGPROC FAR *LPSOUNDDEVMSGPROC;

/* 
 * Message sent by mmsystem to media specific entry points when it first
 * initializes the drivers, and when they are closed.
 */

#define DRVM_INIT               100
#define DRVM_EXIT		101

// message base for driver specific messages.
// 
#define DRVM_MAPPER             0x2000
#define DRVM_USER               0x4000
#define DRVM_MAPPER_STATUS      (DRVM_MAPPER+0)
#define	DRVM_MAPPER_RECONFIGURE	(DRVM_MAPPER+1)

#if (WINVER >= 0x0400)
#define DRV_QUERYDRVENTRY    (DRV_RESERVED + 1)
#define DRV_QUERYDEVNODE     (DRV_RESERVED + 2)
#define DRV_QUERYNAME        (DRV_RESERVED + 3)

#define	DRV_F_ADD	0x00000000
#define	DRV_F_REMOVE	0x00000001
#define	DRV_F_CHANGE	0x00000002
#define DRV_F_PROP_INSTR 0x00000004
#define DRV_F_PARAM_IS_DEVNODE 0x10000000
#endif

/* PnP version of device caps */
typedef struct {
    DWORD	cbSize;
    LPVOID	pCaps;
} DEVICECAPSEX;

#ifndef MMNOWAVEDEV
/****************************************************************************
 
                       Waveform device driver support
 
****************************************************************************/

/* maximum number of wave device drivers loaded */
#define MAXWAVEDRIVERS          10

/* waveform input and output device open information structure */
typedef struct waveopendesc_tag {
    HWAVE          hWave;             /* handle */
    const WAVEFORMAT FAR* lpFormat;   /* format of wave data */
    DWORD          dwCallback;        /* callback */
    DWORD          dwInstance;        /* app's private instance information */
    UINT           uMappedDeviceID;   /* device to map to if WAVE_MAPPED set */
    DWORD         dnDevNode;          /* if device is PnP */
} WAVEOPENDESC;
typedef WAVEOPENDESC FAR *LPWAVEOPENDESC;

#define WODM_USER               DRVM_USER
#define WIDM_USER               DRVM_USER
#define WODM_MAPPER             DRVM_MAPPER
#define WIDM_MAPPER             DRVM_MAPPER

#define WODM_INIT               DRVM_INIT
#define WIDM_INIT               DRVM_INIT

/* messages sent to wodMessage() entry-point function */
#define WODM_GETNUMDEVS         3
#define WODM_GETDEVCAPS         4
#define WODM_OPEN               5
#define WODM_CLOSE              6
#define WODM_PREPARE            7
#define WODM_UNPREPARE          8
#define WODM_WRITE              9
#define WODM_PAUSE              10
#define WODM_RESTART            11
#define WODM_RESET              12 
#define WODM_GETPOS             13
#define WODM_GETPITCH           14
#define WODM_SETPITCH           15
#define WODM_GETVOLUME          16
#define WODM_SETVOLUME          17
#define WODM_GETPLAYBACKRATE    18
#define WODM_SETPLAYBACKRATE    19
#define WODM_BREAKLOOP          20
#if (WINVER >= 0x0400)
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
#endif

/* messages sent to widMessage() entry-point function */
#define WIDM_GETNUMDEVS         50
#define WIDM_GETDEVCAPS         51
#define WIDM_OPEN               52
#define WIDM_CLOSE              53
#define WIDM_PREPARE            54
#define WIDM_UNPREPARE          55
#define WIDM_ADDBUFFER          56
#define WIDM_START              57
#define WIDM_STOP               58
#define WIDM_RESET              59
#define WIDM_GETPOS             60
#if (WINVER >= 0x0400)
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
#endif
#endif  /*ifndef MMNOWAVEDEV */


#ifndef MMNOMIDIDEV
/****************************************************************************

                          MIDI device driver support

****************************************************************************/

/* maximum number of MIDI device drivers loaded */
#define MAXMIDIDRIVERS 10

#define MODM_USER      DRVM_USER
#define MIDM_USER      DRVM_USER
#define MODM_MAPPER    DRVM_MAPPER
#define MIDM_MAPPER    DRVM_MAPPER

#define MODM_INIT      DRVM_INIT
#define MIDM_INIT      DRVM_INIT

/* MIDI input and output device open information structure */
typedef struct midiopendesc_tag {
    HMIDI          hMidi;             /* handle */
    DWORD          dwCallback;        /* callback */
    DWORD          dwInstance;        /* app's private instance information */
    UINT           uMappedDeviceID;   /* device to map to if WAVE_MAPPED set */
    DWORD          dnDevNode;         /* if device is PnP */
} MIDIOPENDESC;
typedef MIDIOPENDESC FAR *LPMIDIOPENDESC;

#if (WINVER >= 0x0400)
/* structure pointed to by lParam1 for MODM_GET/MODM_SETTIMEPARMS */

typedef struct miditimeparms_tag {
    DWORD	    dwTimeDivision;   /* time division ala MIDI file spec */
    DWORD	    dwTempo;	      /* tempo ala MIDI file spec */
} MIDITIMEPARMS,
  FAR *LPMIDITIMEPARMS;

#endif


/* messages sent to modMessage() entry-point function */
#define MODM_GETNUMDEVS             1
#define MODM_GETDEVCAPS             2
#define MODM_OPEN                   3
#define MODM_CLOSE                  4
#define MODM_PREPARE                5
#define MODM_UNPREPARE              6
#define MODM_DATA                   7
#define MODM_LONGDATA               8
#define MODM_RESET                  9
#define MODM_GETVOLUME              10
#define MODM_SETVOLUME              11
#define MODM_CACHEPATCHES           12      
#define MODM_CACHEDRUMPATCHES	    13

#if (WINVER >= 0x0400)
#define MODM_POLYMSG                14
//#define MODM_SETTIMEPARMS           15
//#define MODM_GETTIMEPARMS           16
#define MODM_GETPOS                 17
#define MODM_PAUSE                  18
#define MODM_RESTART                19
#define MODM_STOP                   20
#define MODM_PROPERTIES             21
#define MODM_RECONFIGURE			(MODM_USER+0x0768)
#endif



/* messages sent to midMessage() entry-point function */
#define MIDM_GETNUMDEVS             53
#define MIDM_GETDEVCAPS             54
#define MIDM_OPEN                   55
#define MIDM_CLOSE                  56
#define MIDM_PREPARE                57
#define MIDM_UNPREPARE              58
#define MIDM_ADDBUFFER              59
#define MIDM_START                  60
#define MIDM_STOP                   61
#define MIDM_RESET                  62
#if (WINVER >= 0x0400)
//#define MIDM_SETTIMEPARMS           63
//#define MIDM_GETTIMEPARMS           64  /* Who will need to call this? */
#define MIDM_GETPOS                 65
#define MIDM_PROPERTIES             66
#endif

#endif  /*ifndef MMNOMIDIDEV */


#ifndef MMNOAUXDEV
/****************************************************************************

                    Auxiliary audio device driver support

****************************************************************************/

/* maximum number of auxiliary device drivers loaded */
#define MAXAUXDRIVERS           10

#define AUXM_INIT               DRVM_INIT
#define AUXM_USER               DRVM_USER
#define AUXDM_MAPPER            DRVM_MAPPER

/* messages sent to auxMessage() entry-point function */
#define AUXDM_GETNUMDEVS        3
#define AUXDM_GETDEVCAPS        4
#define AUXDM_GETVOLUME         5
#define AUXDM_SETVOLUME         6

#endif  /*ifndef MMNOAUXDEV */




#ifndef MMNOMIXERDEV
#if (WINVER >= 0x0400)
/****************************************************************************

                        Mixer Driver Support

****************************************************************************/

//
//  maximum number of mixer drivers that can be loaded by MSMIXMGR.DLL
//
#define MAXMIXERDRIVERS         10

//
//  mixer device open information structure
//
//
typedef struct tMIXEROPENDESC
{
    HMIXER          hmx;            // handle that will be used
    LPVOID          pReserved0;     // reserved--driver should ignore
    DWORD           dwCallback;     // callback
    DWORD           dwInstance;     // app's private instance information
    DWORD           dnDevNode;      // if device is PnP

} MIXEROPENDESC, *PMIXEROPENDESC, FAR *LPMIXEROPENDESC;

//
//
//
//
#define MXDM_INIT                  DRVM_INIT
#define MXDM_USER                  DRVM_USER
#define MXDM_MAPPER                DRVM_MAPPER

#define MXDM_BASE                   (1)
#define MXDM_GETNUMDEVS             (MXDM_BASE + 0)
#define MXDM_GETDEVCAPS             (MXDM_BASE + 1)
#define MXDM_OPEN                   (MXDM_BASE + 2)
#define MXDM_CLOSE                  (MXDM_BASE + 3)
#define MXDM_GETLINEINFO            (MXDM_BASE + 4)
#define MXDM_GETLINECONTROLS        (MXDM_BASE + 5)
#define MXDM_GETCONTROLDETAILS      (MXDM_BASE + 6)
#define MXDM_SETCONTROLDETAILS      (MXDM_BASE + 7)

#endif /* ifdef WINVER >= 0x0400 */
#endif /* ifndef MMNOMIXERDEV */


#ifndef MMNOTIMERDEV
/****************************************************************************

                        Timer device driver support

****************************************************************************/

typedef struct timerevent_tag {
    UINT                wDelay;         /* delay required */
    UINT                wResolution;    /* resolution required */
    LPTIMECALLBACK      lpFunction;     /* ptr to callback function */
    DWORD               dwUser;         /* user DWORD */
    UINT                wFlags;         /* defines how to program event */
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

/* messages sent to tddMessage() function */
#define TDD_KILLTIMEREVENT      (DRV_RESERVED + 0)  /* indices into a table of */
#define TDD_SETTIMEREVENT       (DRV_RESERVED + 4)  /* functions; thus offset by */
#define TDD_GETSYSTEMTIME       (DRV_RESERVED + 8)  /* four each time... */
#define TDD_GETDEVCAPS          (DRV_RESERVED + 12) /* room for future expansion */
#define TDD_BEGINMINPERIOD      (DRV_RESERVED + 16) /* room for future expansion */
#define TDD_ENDMINPERIOD        (DRV_RESERVED + 20) /* room for future expansion */

#endif  /*ifndef MMNOTIMERDEV */


#ifndef MMNOJOYDEV
/****************************************************************************

                       Joystick device driver support

****************************************************************************/

/* joystick calibration info structure */
typedef struct joycalibrate_tag {
    UINT    wXbase;
    UINT    wXdelta;
    UINT    wYbase;
    UINT    wYdelta;
    UINT    wZbase;
    UINT    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

/* prototype for joystick message function */
typedef UINT (CALLBACK JOYDEVMSGPROC)(DWORD dwID, UINT uMessage, LPARAM lParam1, LPARAM lParam2);
typedef JOYDEVMSGPROC FAR *LPJOYDEVMSGPROC;

/* messages sent to joystick driver's DriverProc() function */
#define JDD_GETNUMDEVS          (DRV_RESERVED + 0x0001)
#define JDD_GETDEVCAPS          (DRV_RESERVED + 0x0002)
#define JDD_GETPOS              (DRV_RESERVED + 0x0101)
#define JDD_SETCALIBRATION      (DRV_RESERVED + 0x0102)

#endif  /*ifndef MMNOJOYDEV */


#ifndef MMNOMCIDEV
/****************************************************************************

                        MCI device driver support

****************************************************************************/

/* internal MCI messages */
#define MCI_OPEN_DRIVER         (DRV_RESERVED + 0x0001)
#define MCI_CLOSE_DRIVER        (DRV_RESERVED + 0x0002)

#define MAKEMCIRESOURCE(wRet, wRes) MAKELRESULT((wRet), (wRes))

/* string return values only used with MAKEMCIRESOURCE */
#define MCI_FALSE                   (MCI_STRING_OFFSET + 19)
#define MCI_TRUE                    (MCI_STRING_OFFSET + 20)

/* resource string return values */
#define MCI_FORMAT_RETURN_BASE      MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S   (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S            (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S            (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S         (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S       (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S       (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S       (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S   (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S          (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S        (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S           (MCI_STRING_OFFSET + 31)

#define MCI_VD_FORMAT_TRACK_S       (MCI_VD_OFFSET + 5)

#define WAVE_FORMAT_PCM_S           (MCI_WAVE_OFFSET + 0)
#define WAVE_MAPPER_S               (MCI_WAVE_OFFSET + 1)

#define MCI_SEQ_MAPPER_S            (MCI_SEQ_OFFSET + 5)
#define MCI_SEQ_FILE_S              (MCI_SEQ_OFFSET + 6)
#define MCI_SEQ_MIDI_S              (MCI_SEQ_OFFSET + 7)
#define MCI_SEQ_SMPTE_S             (MCI_SEQ_OFFSET + 8)
#define MCI_SEQ_FORMAT_SONGPTR_S    (MCI_SEQ_OFFSET + 9)
#define MCI_SEQ_NONE_S              (MCI_SEQ_OFFSET + 10)
#define MIDIMAPPER_S                (MCI_SEQ_OFFSET + 11)

/* parameters for internal version of MCI_OPEN message sent from */
/* mciOpenDevice() to the driver */
typedef struct {
    MCIDEVICEID wDeviceID;         /* device ID */
    LPCSTR  lpstrParams;           /* parameter string for entry in SYSTEM.INI */
    UINT    wCustomCommandTable;   /* custom command table (0xFFFF if none) */
                                   /* filled in by the driver */
    UINT    wType;                 /* driver type */
                                   /* filled in by the driver */
} MCI_OPEN_DRIVER_PARMS,
FAR *LPMCI_OPEN_DRIVER_PARMS;

/* maximum length of an MCI device type */
#define MCI_MAX_DEVICE_TYPE_LENGTH 80

/* flags for mciSendCommandInternal() which direct mciSendString() how to */
/* interpret the return value */
#define MCI_RESOURCE_RETURNED   0x00010000  /* resource ID */
#define MCI_COLONIZED3_RETURN   0x00020000  /* colonized ID, 3 bytes data */
#define MCI_COLONIZED4_RETURN   0x00040000  /* colonized ID, 4 bytes data */
#define MCI_INTEGER_RETURNED    0x00080000  /* integer conversion needed */
#define MCI_RESOURCE_DRIVER     0x00100000  /* driver owns returned resource */

/* invalid command table ID */
#define MCI_NO_COMMAND_TABLE    -1

/* command table information type tags */
#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9

/* function prototypes for MCI driver functions */
DWORD WINAPI mciGetDriverData(UINT uDeviceID);
BOOL  WINAPI mciSetDriverData(UINT uDeviceID, DWORD dwData);
UINT  WINAPI mciDriverYield(UINT uDeviceID);
BOOL  WINAPI mciDriverNotify(HWND hwndCallback, UINT uDeviceID,
    UINT uStatus);
#ifdef WIN32
UINT  WINAPI mciLoadCommandResource(HINSTANCE hInstance, LPCWSTR lpResName, UINT uType);
#else
UINT  WINAPI mciLoadCommandResource(HINSTANCE hInstance, LPCSTR lpResName, UINT uType);
#endif
BOOL  WINAPI mciFreeCommandResource(UINT uTable);

#endif  /*ifndef MMNOMCIDEV */


#ifndef MMNOTASKDEV
/*****************************************************************************

                               Task support

*****************************************************************************/

/* error return values */
#define TASKERR_NOTASKSUPPORT   1
#define TASKERR_OUTOFMEMORY     2

/* task support function prototypes */
#ifdef  BUILDDLL                                        /* ;Internal */
typedef void (FAR PASCAL TASKCALLBACK) (DWORD dwInst);  /* ;Internal */
#else   /*ifdef BUILDDLL*/                              /* ;Internal */
typedef void (CALLBACK TASKCALLBACK) (DWORD dwInst);
#endif  /*ifdef BUILDDLL*/                              /* ;Internal */

typedef TASKCALLBACK FAR *LPTASKCALLBACK;

UINT    WINAPI mmTaskCreate(LPTASKCALLBACK lpfnTaskProc, HTASK FAR * lphTask, DWORD dwInst);
UINT    WINAPI mmTaskBlock(HTASK h);
BOOL    WINAPI mmTaskSignal(HTASK h);
void    WINAPI mmTaskYield(void);
HTASK   WINAPI mmGetCurrentTask(void);


#endif  /*ifndef MMNOTASKDEV */

#define MMDDKINC                /* ;Internal */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif  /* _INC_MMDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\msacmdlg.h ===
/***************************************************************************
 *
 *  msacmdlg.h
 *
 *  Copyright (c) 1991-1994 Microsoft Corporation.  All Rights Reserved.
 *
 *  Description:
 *      Audio Compression Manager Common Dialogs Identifiers
 *
 ***************************************************************************/


#define DLG_ACMFORMATCHOOSE_ID              70
#define IDD_ACMFORMATCHOOSE_BTN_HELP        9
#define IDD_ACMFORMATCHOOSE_CMB_CUSTOM      100
#define IDD_ACMFORMATCHOOSE_CMB_FORMATTAG   101
#define IDD_ACMFORMATCHOOSE_CMB_FORMAT      102
#define IDD_ACMFORMATCHOOSE_BTN_SETNAME     103
#define IDD_ACMFORMATCHOOSE_BTN_DELNAME     104


#define DLG_ACMFILTERCHOOSE_ID              71
#define IDD_ACMFILTERCHOOSE_BTN_HELP        9
#define IDD_ACMFILTERCHOOSE_CMB_CUSTOM      100
#define IDD_ACMFILTERCHOOSE_CMB_FILTERTAG   101
#define IDD_ACMFILTERCHOOSE_CMB_FILTER      102
#define IDD_ACMFILTERCHOOSE_BTN_SETNAME     103
#define IDD_ACMFILTERCHOOSE_BTN_DELNAME     104
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\msprintx.h ===
//////////////////////////////////////////////////////////////////////////
//
// This is the public header file for apps that call MSPRINT.DLL
//
//////////////////////////////////////////////////////////////////////////

#ifndef SETUPX_INC
typedef WORD RETERR;
#endif

typedef RETERR (FAR PASCAL* PRINTERSETUPPROC)(HWND,WORD,LPSTR,WORD);

RETERR WINAPI PrinterSetup(HWND hWnd,WORD wAction,LPSTR lpBuffer,WORD wBufSize);

#ifdef WIN32

typedef BOOL (WINAPI* PRINTERSETUPPROC32)(HWND,WORD,WORD,LPBYTE,LPWORD);

BOOL WINAPI PrinterSetup32(HWND,WORD,WORD,LPBYTE,LPWORD);

#endif

#define MSPRINT_PRINTERSETUP (MAKEINTRESOURCE(50))

#define MSP_NEWPRINTER            1
#define MSP_NETPRINTER            2
#define MSP_NEWDRIVER             3
#define MSP_NETADMIN              4
#define MSP_TESTPAGEFULLPROMPT    5
#define MSP_TESTPAGEPARTIALPROMPT 7
#define MSP_TESTPAGENOPROMPT      8

// These are obsolete and will be going away soon...
#define MSPRINT_NEWPRINTER (MAKEINTRESOURCE(100))
#define MSPRINT_SETUPENTRY (MAKEINTRESOURCE(101))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\mpr.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* MNR.H -- Definitions for multi-network provider router DLL.
 *
 * History:
 *  03/19/93    lens    Added definitions
 *
 */

#ifndef _INC_NETMPR
#include "..\inc\mpr.h"
#endif /* _INC_NETMPR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\mrci.inc ===
;----------------------------------------------------------------------------
;  MRCI.INC - Microsoft Real-Time Compression Interface definitions
;
;  Microsoft Confidential
;  Copyright (C) Microsoft Corporation 1992
;  All Rights Reserved.
;
;  History:
;    18-Jul-92 bens	 Initial version.
;    25-Jul-92 billkru	 Adapted for use by MS-Flash & ROMDOS environment.
;----------------------------------------------------------------------------
intMRCIROM	   equ	   1Ah	   ; ROM MRCI interrupt number
mrciDETECTROM	   equ	   0B001h  ; ROM intMRCI AX for detecting MRCI server
intMRCI 	 equ	 2Fh	   ; MRCI interrupt number
mrciDETECT	 equ	 4a12h	   ; intMRCI AX for detecting MRCI server

mrciBackPatch	 equ	 4a13h

;----------------------------------------------------------------------------
;  sigOLD_CX, sigOLD_DX, sigNEW_CX, sigNEW_DX - MRCI Server detection
;
;  These values are used to verify that the response from issuing
;  intMRCI is coming from an MRCI server, and not some other piece
;  of code.
;
;  The *old* values are passed on the mrciQUERY call, and the server
;  must change CX/DX to the *new* values, so that the caller can
;  trust that the MRCI server was responding, and not some other
;  interrupt hooker.
;
;  The Server uses this code sequence to transform CX/DX:
;
;	    ;------------- entry: cx='ab'  dx='cd'
;	    xchg    ch,cl	; cx='ba'  dx='cd'
;	    xchg    dh,dl	; cx='ba'  dx='dc'
;	    xchg    dx,cx	; cx='dc'  dx='ba'
;----------------------------------------------------------------------------
sigOLD_CX   equ 'MR'
sigOLD_DX   equ 'CI'

sigNEW_CX   equ 'IC'
sigNEW_DX   equ 'RM'

;----------------------------------------------------------------------------
;    mcXXXX - flag values passed to MRCI operations
;
;	MRCCompress and MRCDecompress take a flag to indicate whether the
;	client is a *system* component (and hence may call with InDOS
;	set), or an *application*.
;
;	If a system client calls MRCCompress/MRCDecompress with mcSYSTEM,
;	then it is the clients responsibility to ensure that one of the
;	following is true:
;	    1)	InDOS is set
;	    2)	The call is made at interrupt time.
;
;	FAILING TO FOLLOW THE ABOVE RULE WILL LIKELY RESULT IN A SYSTEM
;	HANG AND LOSS OF USER DATA.
;----------------------------------------------------------------------------
mcAPPLICATION		equ	0	; Client is an application
mcSYSTEM		equ	1	; Client is a file system driver

;----------------------------------------------------------------------------
;  MRCI Server Busy flag values
;----------------------------------------------------------------------------
MRCI_SERVER_IDLE	equ	0

;----------------------------------------------------------------------------
;    MRCINFO - MRC Information data structure
;
;	A pointer to an MRCINFO structure is returned from MRCQuery, and sent
;	on MRCNotifyLoad.  This structure contains information on the MRCI
;	server and its capabilities.
;----------------------------------------------------------------------------
MRCINFO 		struc
mi_lVendor		dd	?	; A 4-byte vendor ID.
					; Microsoft's vendor ID is "MSFT".

mi_wVendorVersion	dw	?	; Version number of the MRC server.
					; High byte is major number, low byte is minor.
					; EXAMPLES: v3.20 = 0314h, v10.01 = 0A01h

mi_wMRCIVersion 	dw	?	; Version number of the MRCI supported by
					; this server.

mi_pfnOperate		dd	?	; Far pointer of the server compression entry
					; point.

mi_flCapability 	dw	?	; Bit field of server capabilities
					; See micapXXX for bit definitions

mi_flHWAssist		dw	?	; Bit field of hardware assisted
					; server capabilities.	One-to-one
					; correspondance with mi_flCapability
					; bits.  A bit set in this field
					; indicates the corresponding
					; capability is hardware assisted.

mi_cbMax		dw	?	; Maximum number of bytes that the compression
					; services provider can compress or decompress.
					; Requests to compress or decompress buffers in
					; excess of this length will fail.
					; All MRCI servers must support at least
					; 8192 byte (8Kb) blocks.
MRCINFO 		ends

;----------------------------------------------------------------------------
;    micapXXXXX - bit flags for MRCINFO.mi_flCapabilities
;
;	These define both the capabilities of the Server, and also double
;	as *operation* codes passed to the mi_pfnOperate entry point in
;	the server.
;			111111
;			5432109876543210
;----------------------------------------------------------------------------
micapNONE	equ	0000000000000000b	; No capabilities
micapSTANDARD	equ	0000000000000001b	; Standard compress
micapDECOMPRESS equ	0000000000000010b	; Standard compress
micapUPDATE	equ	0000000000000100b	; Update compress
micapSUPER	equ	0000000000001000b	; SuperCompress(tm)
micapSUPERUPDATE equ	0000000000010000b	; Update SuperCompress(tm)
micapINCDECOMP	equ	0000000000100000b	; Incremental Decompress
						; Remaining bits (6..14) are RESERVED and must be 0
micapREADONLY	equ	1000000000000000b	; MRCINFO structure is read-only
micapDEINSTALL	equ	1111111111111111b	; Server deinstall service

;----------------------------------------------------------------------------
;  MRCREQUEST - MRC compress/decompress Request packet
;
;  This structure is used to pass parameters to the server for
;  compress/decompress operations.
;
;  General Notes
;  -------------
;  1) <mr_pbSrc,mr_cbSrc> and <mr_pbDst,mr_cbDst> MUST NOT OVERLAP!
;
;  2) The safest practice is for mr_cbSrc and mr_cbDst to be identical
;     (except for decompress where mr_cbSrc is ignored and mr_cbDst is
;      the count of bytes to uncompress).
;
;  Details on Structure Members
;  ----------------------------
;  mr_pbSrc
;    This points to the *source* buffer.
;
;    On a *compress* operation, the contents of this buffer are
;    *uncompressed* data.
;
;    On an *update* operation, the contents of this buffer starting
;    at offset mr_offUpdate is valid, uncompressed data.  The contents
;    from the start of the buffer to the byte just prior to
;    mr_OffUpdate are ignored.
;
;    On a *decompress* operation, the contents of this buffer are
;    *compressed* data.
;
;  mr_cbSrc
;    This is the size of the *source* buffer.
;
;    This is the amount of data to be compressed or decompressed.
;    NOTE: For a decompress operation, this value may be ignored
;	   by many implentations, since the MRC Format encoding has
;	   a special code to indicate the end of the compressed data.
;
;  mr_offUpdate
;    NOTE: This is used for Update(Super)Compress only.
;
;    On INPUT, this is the offset (same segment as mr_pbSrc) in the
;    *source* buffer where the changed uncompressed data starts.
;
;    On OUTPUT, this is the offset (same segment as mr_pbDst) in the
;    *destination* buffer where the changed compressed data starts.
;
;  mr_pbDst
;    This points to the *destination* buffer.
;
;    On a *compress* operation, this buffer receives the *compressed*
;    result of the operation.
;
;    On an *update* operation, the contents of this buffer MUST be
;    the compressed representation of the uncompressed data in the
;    *source* buffer.  After the operation is completed, this buffer
;    receives the *compressed* result of the operation.
;
;    On a *decompress* operation, this buffer receives the
;    *uncompressed* result of the operation.
;
;  mr_cbDst
;    On a *compress* operation and on INPUT, this is the size of
;    the *destination* buffer.	If, during the operation, the
;    Server would overflow this buffer length, then the operation
;    fails and the server returns the error MRCI_ERROR_BUFFER_OVERFLOW.
;
;    On a *decompress* operation and on INPUT, this is what the
;    *decompressed* size should be.  If, during the operation, the
;    Server would overflow this length, then the operation fails
;    and the server returns the error MRCI_ERROR_BUFFER_OVERFLOW.
;
;    On OUTPUT, the Server updates this field with the actual size
;    of the resulting compressed/uncompressed data.
;
;  mr_cbChunk
;    This is information that the Server compress routines can use to
;    "early out" of the compression as early as possible.
;
;    Valid values are 1 (client is interested in savings as small as
;    1 byte) to 32767.	DblSpace passes 512, and MS-Flash passes 1.
;
;    This field is most easily explained by giving an example:
;
;    Example:
;      DblSpace does space allocation in chunks of 512 bytes (the
;      common sector size on a disk).
;
;      The compression server can use this information for two
;      optimizations:
;
;      1) If the Server cannot compress the uncompressed data
;	  enough to save at least 512 bytes, then the data is
;	  *incompressible* as far as DblSpace is concerned, even
;	  if it could be compressed to save fewer than 512 bytes.
;
;      2) While compressing, if the Server gets to a point where
;	  the remaining uncompressed data is of such a length that
;	  it can be encoded simply (without table lookups, etc.)
;	  and not cross a 512 byte boundary, then the Server can
;	  do the simple encoding.
;
;      It is likely that these optimizations will be hard to perform
;      quickly in software, but it is possible that hardware can do
;      these optimizations without any performance loss.
;----------------------------------------------------------------------------
MRCREQUEST	struc
mr_pbSrc	dd	?	; Pointer to source buffer
mr_cbSrc	dw	?	; Size of source buffer, in bytes
mr_offUpdate	dw	?	; For UpdateCompress only: offset of (source) destination
				; buffer where changed (un)compressed data starts.
mr_pbDst	dd	?	; Pointer to destination buffer
mr_cbDst	dw	?	; Size of destination buffer, in bytes
mr_cbChunk	dw	?	; Client compressed data storage chunk size (see above!)
mr_dwIncDecomp	dd	?	; Incremental Decompression state
MRCREQUEST	ends


;----------------------------------------------------------------------------
;  MRCI_ERROR_XXX definitions
;
;  Error codes returned from a request
;----------------------------------------------------------------------------
MRCI_ERROR_NONE 	    equ     0	; No error
MRCI_ERROR_NOT_SUPPORTED    equ     1	; Unsupported operation requested
MRCI_ERROR_BUSY 	    equ     2	; Server is busy
MRCI_ERROR_BUFFER_OVERFLOW  equ     3	; Destination buffer too small
MRCI_ERROR_NOT_COMPRESSIBLE equ     4	; Data could not be compressed
MRCI_ERROR_BAD_MRC_FORMAT   equ     5	; Compressed data format is bad


;---------------------------------------------------------------------------
; DblSpace MRCI Server constants
;---------------------------------------------------------------------------


MRCIVERSION	equ	0100h		; MRCI version supported by this server
MYVERSION	equ	0100h		; Version of this server/driver

MYVENDOR	equ	5446534Dh	; "MSFT" (reversed for byte ordering)
MYVENDORhi	equ	5446h		; High word of MYVENDOR
MYVENDORlo	equ	534Dh		; Low word of MYVENDOR

; Max buffer size set to 32k to avoid problems with compression code and
; buffer offsets near 0E000h.  See comments in rcomp.asm for details.

MYCBMAX 	equ	(32*1024)	; Maximum compression buffer size

;  This server's capabilities.

micapMINE	=	micapSTANDARD or micapDECOMPRESS or micapINCDECOMP


MYHWASSIST	equ	0		;we have no hardware assist
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\msacm.h ===
//==========================================================================;
//
//  msacm.h
//
//  Copyright (c) 1992-1994 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      Audio Compression Manager Public Header File
//
//  History:
//
//==========================================================================;

#ifndef _INC_ACM
#define _INC_ACM        /* #defined if msacm.h has been included */

#if !defined(_INC_MMREG) || (_INC_MMREG < 142)
#ifndef RC_INVOKED
#error MMREG.H version 142 or greater to be included first
#endif
#endif

#if defined(WIN32) && !defined(_WIN32)
#ifndef RC_INVOKED
#pragma message("MSACM.H: defining _WIN32 because application defined WIN32")
#endif
#define _WIN32
#endif

#if defined(UNICODE) && !defined(_UNICODE)
#ifndef RC_INVOKED
#pragma message("MSACM.H: defining _UNICODE because application defined UNICODE")
#endif
#define _UNICODE
#endif

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef DRV_MAPPER_PREFERRED_INPUT_GET
#define DRV_MAPPER_PREFERRED_INPUT_GET  (DRV_USER + 0)
#endif

#ifndef DRV_MAPPER_PREFERRED_OUTPUT_GET
#define DRV_MAPPER_PREFERRED_OUTPUT_GET (DRV_USER + 2)
#endif


#ifndef DRVM_MAPPER_STATUS
#define DRVM_MAPPER_STATUS              (0x2000)
#endif

#ifndef WIDM_MAPPER_STATUS
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
#endif

#ifndef WODM_MAPPER_STATUS
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
    #define ACMAPI              WINAPI
#else
#ifdef _WINDLL
    #define ACMAPI              _far _pascal _loadds
#else
    #define ACMAPI              _far _pascal
#endif
#endif


//--------------------------------------------------------------------------;
//
//  ACM General API's and Defines
//
//
//
//
//--------------------------------------------------------------------------;

//
//  there are four types of 'handles' used by the ACM. the first three
//  are unique types that define specific objects:
//
//  HACMDRIVERID: used to _identify_ an ACM driver. this identifier can be
//  used to _open_ the driver for querying details, etc about the driver.
//
//  HACMDRIVER: used to manage a driver (codec, filter, etc). this handle
//  is much like a handle to other media drivers--you use it to send
//  messages to the converter, query for capabilities, etc.
//
//  HACMSTREAM: used to manage a 'stream' (conversion channel) with the
//  ACM. you use a stream handle to convert data from one format/type
//  to another--much like dealing with a file handle.
//
//
//  the fourth handle type is a generic type used on ACM functions that
//  can accept two or more of the above handle types (for example the
//  acmMetrics and acmDriverID functions).
//
//  HACMOBJ: used to identify ACM objects. this handle is used on functions
//  that can accept two or more ACM handle types.
//
DECLARE_HANDLE(HACMDRIVERID);
typedef HACMDRIVERID       *PHACMDRIVERID;
typedef HACMDRIVERID   FAR *LPHACMDRIVERID;

DECLARE_HANDLE(HACMDRIVER);
typedef HACMDRIVER         *PHACMDRIVER;
typedef HACMDRIVER     FAR *LPHACMDRIVER;

DECLARE_HANDLE(HACMSTREAM);
typedef HACMSTREAM         *PHACMSTREAM;
typedef HACMSTREAM     FAR *LPHACMSTREAM;

DECLARE_HANDLE(HACMOBJ);
typedef HACMOBJ            *PHACMOBJ;
typedef HACMOBJ        FAR *LPHACMOBJ;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Error Codes
//
//  Note that these error codes are specific errors that apply to the ACM
//  directly--general errors are defined as MMSYSERR_*.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef _MMRESULT_
#define _MMRESULT_
typedef UINT                MMRESULT;
#endif

#define ACMERR_BASE         (512)
#define ACMERR_NOTPOSSIBLE  (ACMERR_BASE + 0)
#define ACMERR_BUSY         (ACMERR_BASE + 1)
#define ACMERR_UNPREPARED   (ACMERR_BASE + 2)
#define ACMERR_CANCELED     (ACMERR_BASE + 3)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Window Messages
//
//  These window messages are sent by the ACM or ACM drivers to notify
//  applications of events.
//
//  Note that these window message numbers will also be defined in
//  mmsystem.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define MM_ACM_OPEN         (MM_STREAM_OPEN)  // conversion callback messages
#define MM_ACM_CLOSE        (MM_STREAM_CLOSE)
#define MM_ACM_DONE         (MM_STREAM_DONE)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmGetVersion()
//
//  the ACM version is a 32 bit number that is broken into three parts as 
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows:
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) & 
//      wBuild = LOWORD(dwVersion)
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

DWORD ACMAPI acmGetVersion
(
    void
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmMetrics()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmMetrics
(
    HACMOBJ                 hao,
    UINT                    uMetric,
    LPVOID                  pMetric
);

#define ACM_METRIC_COUNT_DRIVERS            1
#define ACM_METRIC_COUNT_CODECS             2
#define ACM_METRIC_COUNT_CONVERTERS         3
#define ACM_METRIC_COUNT_FILTERS            4
#define ACM_METRIC_COUNT_DISABLED           5
#define ACM_METRIC_COUNT_HARDWARE           6
#define ACM_METRIC_COUNT_LOCAL_DRIVERS      20
#define ACM_METRIC_COUNT_LOCAL_CODECS       21
#define ACM_METRIC_COUNT_LOCAL_CONVERTERS   22
#define ACM_METRIC_COUNT_LOCAL_FILTERS      23
#define ACM_METRIC_COUNT_LOCAL_DISABLED     24
#define ACM_METRIC_HARDWARE_WAVE_INPUT      30
#define ACM_METRIC_HARDWARE_WAVE_OUTPUT     31
#define ACM_METRIC_MAX_SIZE_FORMAT          50
#define ACM_METRIC_MAX_SIZE_FILTER          51
#define ACM_METRIC_DRIVER_SUPPORT           100
#define ACM_METRIC_DRIVER_PRIORITY          101


//--------------------------------------------------------------------------;
//
//  ACM Drivers
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverEnum()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef BOOL (CALLBACK *ACMDRIVERENUMCB)
(
    HACMDRIVERID            hadid,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmDriverEnum
(
    ACMDRIVERENUMCB         fnCallback,
    DWORD                   dwInstance,
    DWORD                   fdwEnum
);

#define ACM_DRIVERENUMF_NOLOCAL     0x40000000L
#define ACM_DRIVERENUMF_DISABLED    0x80000000L




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverID()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverID
(
    HACMOBJ                 hao,
    LPHACMDRIVERID          phadid,
    DWORD                   fdwDriverID
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverAdd()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
MMRESULT ACMAPI acmDriverAddA
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
);

MMRESULT ACMAPI acmDriverAddW
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
);

#ifdef _UNICODE
#define acmDriverAdd        acmDriverAddW
#else
#define acmDriverAdd        acmDriverAddA
#endif
#else
MMRESULT ACMAPI acmDriverAdd
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
);
#endif

#define ACM_DRIVERADDF_FUNCTION     0x00000003L  // lParam is a procedure
#define ACM_DRIVERADDF_NOTIFYHWND   0x00000004L  // lParam is notify hwnd
#define ACM_DRIVERADDF_TYPEMASK     0x00000007L  // driver type mask
#define ACM_DRIVERADDF_LOCAL        0x00000000L  // is local to current task
#define ACM_DRIVERADDF_GLOBAL       0x00000008L  // is global



//
//  prototype for ACM driver procedures that are installed as _functions_
//  or _notifations_ instead of as a standalone installable driver.
//
typedef LRESULT (CALLBACK *ACMDRIVERPROC)(DWORD, HACMDRIVERID, UINT, LPARAM, LPARAM);
typedef ACMDRIVERPROC FAR *LPACMDRIVERPROC;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverRemove()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverRemove
(
    HACMDRIVERID            hadid,
    DWORD                   fdwRemove
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverOpen()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverOpen
(
    LPHACMDRIVER            phad, 
    HACMDRIVERID            hadid,
    DWORD                   fdwOpen
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverClose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverClose
(
    HACMDRIVER              had,
    DWORD                   fdwClose
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverMessage()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LRESULT ACMAPI acmDriverMessage
(
    HACMDRIVER              had,
    UINT                    uMsg, 
    LPARAM                  lParam1,
    LPARAM                  lParam2
);


//
//
//
//
#define ACMDM_USER                  (DRV_USER + 0x0000)
#define ACMDM_RESERVED_LOW          (DRV_USER + 0x2000)
#define ACMDM_RESERVED_HIGH         (DRV_USER + 0x2FFF)

#define ACMDM_BASE                  ACMDM_RESERVED_LOW

#define ACMDM_DRIVER_ABOUT          (ACMDM_BASE + 11)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverPriority
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverPriority
(
    HACMDRIVERID            hadid,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
);


#define ACM_DRIVERPRIORITYF_ENABLE      0x00000001L
#define ACM_DRIVERPRIORITYF_DISABLE     0x00000002L
#define ACM_DRIVERPRIORITYF_ABLEMASK    0x00000003L
#define ACM_DRIVERPRIORITYF_BEGIN       0x00010000L
#define ACM_DRIVERPRIORITYF_END         0x00020000L
#define ACM_DRIVERPRIORITYF_DEFERMASK   0x00030000L





//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  ACMDRIVERDETAILS
//
//  the ACMDRIVERDETAILS structure is used to get various capabilities from
//  an ACM driver (codec, converter, filter).
//
#define ACMDRIVERDETAILS_SHORTNAME_CHARS    32
#define ACMDRIVERDETAILS_LONGNAME_CHARS     128
#define ACMDRIVERDETAILS_COPYRIGHT_CHARS    80
#define ACMDRIVERDETAILS_LICENSING_CHARS    128
#define ACMDRIVERDETAILS_FEATURES_CHARS     512

#ifdef _WIN32
typedef struct tACMDRIVERDETAILSA
{
    DWORD           cbStruct;           // number of valid bytes in structure

    FOURCC          fccType;            // compressor type 'audc'
    FOURCC          fccComp;            // sub-type (not used; reserved)

    WORD            wMid;               // manufacturer id
    WORD            wPid;               // product id

    DWORD           vdwACM;             // version of the ACM *compiled* for
    DWORD           vdwDriver;          // version of the driver

    DWORD           fdwSupport;         // misc. support flags
    DWORD           cFormatTags;        // total unique format tags supported
    DWORD           cFilterTags;        // total unique filter tags supported

    HICON           hicon;              // handle to custom icon

    char            szShortName[ACMDRIVERDETAILS_SHORTNAME_CHARS];
    char            szLongName[ACMDRIVERDETAILS_LONGNAME_CHARS];
    char            szCopyright[ACMDRIVERDETAILS_COPYRIGHT_CHARS];
    char            szLicensing[ACMDRIVERDETAILS_LICENSING_CHARS];
    char            szFeatures[ACMDRIVERDETAILS_FEATURES_CHARS];

} ACMDRIVERDETAILSA, *PACMDRIVERDETAILSA, FAR *LPACMDRIVERDETAILSA;

typedef struct tACMDRIVERDETAILSW
{
    DWORD           cbStruct;           // number of valid bytes in structure

    FOURCC          fccType;            // compressor type 'audc'
    FOURCC          fccComp;            // sub-type (not used; reserved)

    WORD            wMid;               // manufacturer id
    WORD            wPid;               // product id

    DWORD           vdwACM;             // version of the ACM *compiled* for
    DWORD           vdwDriver;          // version of the driver

    DWORD           fdwSupport;         // misc. support flags
    DWORD           cFormatTags;        // total unique format tags supported
    DWORD           cFilterTags;        // total unique filter tags supported

    HICON           hicon;              // handle to custom icon

    WCHAR           szShortName[ACMDRIVERDETAILS_SHORTNAME_CHARS];
    WCHAR           szLongName[ACMDRIVERDETAILS_LONGNAME_CHARS];
    WCHAR           szCopyright[ACMDRIVERDETAILS_COPYRIGHT_CHARS];
    WCHAR           szLicensing[ACMDRIVERDETAILS_LICENSING_CHARS];
    WCHAR           szFeatures[ACMDRIVERDETAILS_FEATURES_CHARS];

} ACMDRIVERDETAILSW, *PACMDRIVERDETAILSW, FAR *LPACMDRIVERDETAILSW;

#ifdef _UNICODE
#define ACMDRIVERDETAILS        ACMDRIVERDETAILSW
#define PACMDRIVERDETAILS       PACMDRIVERDETAILSW
#define LPACMDRIVERDETAILS      LPACMDRIVERDETAILSW
#else
#define ACMDRIVERDETAILS        ACMDRIVERDETAILSA
#define PACMDRIVERDETAILS       PACMDRIVERDETAILSA
#define LPACMDRIVERDETAILS      LPACMDRIVERDETAILSA
#endif
#else
typedef struct tACMDRIVERDETAILS
{
    DWORD           cbStruct;           // number of valid bytes in structure

    FOURCC          fccType;            // compressor type 'audc'
    FOURCC          fccComp;            // sub-type (not used; reserved)

    WORD            wMid;               // manufacturer id
    WORD            wPid;               // product id

    DWORD           vdwACM;             // version of the ACM *compiled* for
    DWORD           vdwDriver;          // version of the driver

    DWORD           fdwSupport;         // misc. support flags
    DWORD           cFormatTags;        // total unique format tags supported
    DWORD           cFilterTags;        // total unique filter tags supported

    HICON           hicon;              // handle to custom icon

    char            szShortName[ACMDRIVERDETAILS_SHORTNAME_CHARS];
    char            szLongName[ACMDRIVERDETAILS_LONGNAME_CHARS];
    char            szCopyright[ACMDRIVERDETAILS_COPYRIGHT_CHARS];
    char            szLicensing[ACMDRIVERDETAILS_LICENSING_CHARS];
    char            szFeatures[ACMDRIVERDETAILS_FEATURES_CHARS];

} ACMDRIVERDETAILS, *PACMDRIVERDETAILS, FAR *LPACMDRIVERDETAILS;
#endif

//
//  ACMDRIVERDETAILS.fccType
//
//  ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC: the FOURCC used in the fccType
//  field of the ACMDRIVERDETAILS structure to specify that this is an ACM
//  codec designed for audio.
//
//
//  ACMDRIVERDETAILS.fccComp
//
//  ACMDRIVERDETAILS_FCCCOMP_UNDEFINED: the FOURCC used in the fccComp
//  field of the ACMDRIVERDETAILS structure. this is currently an unused
//  field.
//
#define ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC mmioFOURCC('a', 'u', 'd', 'c')
#define ACMDRIVERDETAILS_FCCCOMP_UNDEFINED  mmioFOURCC('\0', '\0', '\0', '\0')


//
//  the following flags are used to specify the type of conversion(s) that
//  the converter/codec/filter supports. these are placed in the fdwSupport
//  field of the ACMDRIVERDETAILS structure. note that a converter can
//  support one or more of these flags in any combination.
//
//  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver supports
//  conversions from one format tag to another format tag. for example, if a
//  converter compresses WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM, then this bit
//  should be set.
//
//  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the driver
//  supports conversions on the same format tag. as an example, the PCM
//  converter that is built into the ACM sets this bit (and only this bit)
//  because it converts only PCM formats (bits, sample rate).
//
//  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver supports
//  transformations on a single format. for example, a converter that changed
//  the 'volume' of PCM data would set this bit. 'echo' and 'reverb' are
//  also filter types.
//
//  ACMDRIVERDETAILS_SUPPORTF_HARDWARE: this flag is set if the driver supports
//  hardware input and/or output through a waveform device.
//
//  ACMDRIVERDETAILS_SUPPORTF_ASYNC: this flag is set if the driver supports
//  async conversions.
//
//
//  ACMDRIVERDETAILS_SUPPORTF_LOCAL: this flag is set _by the ACM_ if a
//  driver has been installed local to the current task. this flag is also
//  set in the fdwSupport argument to the enumeration callback function
//  for drivers.
//
//  ACMDRIVERDETAILS_SUPPORTF_DISABLED: this flag is set _by the ACM_ if a
//  driver has been disabled. this flag is also passed set in the fdwSupport
//  argument to the enumeration callback function for drivers.
//
#define ACMDRIVERDETAILS_SUPPORTF_CODEC     0x00000001L
#define ACMDRIVERDETAILS_SUPPORTF_CONVERTER 0x00000002L
#define ACMDRIVERDETAILS_SUPPORTF_FILTER    0x00000004L
#define ACMDRIVERDETAILS_SUPPORTF_HARDWARE  0x00000008L
#define ACMDRIVERDETAILS_SUPPORTF_ASYNC     0x00000010L
#define ACMDRIVERDETAILS_SUPPORTF_LOCAL     0x40000000L
#define ACMDRIVERDETAILS_SUPPORTF_DISABLED  0x80000000L


#ifdef _WIN32
MMRESULT ACMAPI acmDriverDetailsA
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSA     padd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmDriverDetailsW
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSW     padd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmDriverDetails    acmDriverDetailsW
#else
#define acmDriverDetails    acmDriverDetailsA
#endif
#else
MMRESULT ACMAPI acmDriverDetails
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILS      padd,
    DWORD                   fdwDetails
);
#endif



 
//--------------------------------------------------------------------------;
//
//  ACM Format Tags
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatTagDetails()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFORMATTAGDETAILS_FORMATTAG_CHARS 48

#ifdef _WIN32
typedef struct tACMFORMATTAGDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];

} ACMFORMATTAGDETAILSA, *PACMFORMATTAGDETAILSA, FAR *LPACMFORMATTAGDETAILSA;

typedef struct tACMFORMATTAGDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    WCHAR           szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];

} ACMFORMATTAGDETAILSW, *PACMFORMATTAGDETAILSW, FAR *LPACMFORMATTAGDETAILSW;

#ifdef _UNICODE
#define ACMFORMATTAGDETAILS     ACMFORMATTAGDETAILSW
#define PACMFORMATTAGDETAILS    PACMFORMATTAGDETAILSW
#define LPACMFORMATTAGDETAILS   LPACMFORMATTAGDETAILSW
#else
#define ACMFORMATTAGDETAILS     ACMFORMATTAGDETAILSA
#define PACMFORMATTAGDETAILS    PACMFORMATTAGDETAILSA
#define LPACMFORMATTAGDETAILS   LPACMFORMATTAGDETAILSA
#endif
#else
typedef struct tACMFORMATTAGDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];

} ACMFORMATTAGDETAILS, *PACMFORMATTAGDETAILS, FAR *LPACMFORMATTAGDETAILS;
#endif

#ifdef _WIN32
MMRESULT ACMAPI acmFormatTagDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFormatTagDetailsW
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSW  paftd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmFormatTagDetails     acmFormatTagDetailsW
#else
#define acmFormatTagDetails     acmFormatTagDetailsA
#endif
#else
MMRESULT ACMAPI acmFormatTagDetails
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FORMATTAGDETAILSF_INDEX         0x00000000L
#define ACM_FORMATTAGDETAILSF_FORMATTAG     0x00000001L
#define ACM_FORMATTAGDETAILSF_LARGESTSIZE   0x00000002L
#define ACM_FORMATTAGDETAILSF_QUERYMASK     0x0000000FL



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatTagEnum()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFORMATTAGENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILSA  paftd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatTagEnumA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    ACMFORMATTAGENUMCBA     fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);
typedef BOOL (CALLBACK *ACMFORMATTAGENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILSW  paftd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatTagEnumW
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSW  paftd,
    ACMFORMATTAGENUMCBW     fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFORMATTAGENUMCB      ACMFORMATTAGENUMCBW
#define acmFormatTagEnum        acmFormatTagEnumW
#else
#define ACMFORMATTAGENUMCB      ACMFORMATTAGENUMCBA
#define acmFormatTagEnum        acmFormatTagEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFORMATTAGENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatTagEnum
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    ACMFORMATTAGENUMCB      fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);
#endif



//--------------------------------------------------------------------------;
//
//  ACM Formats
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFORMATDETAILS_FORMAT_CHARS   128

#ifdef _WIN32
typedef struct tACMFORMATDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFormatIndex;
    DWORD           dwFormatTag;
    DWORD           fdwSupport;
    LPWAVEFORMATEX  pwfx;
    DWORD           cbwfx;
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];

} ACMFORMATDETAILSA, *PACMFORMATDETAILSA, FAR *LPACMFORMATDETAILSA;

typedef struct tACMFORMATDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFormatIndex;
    DWORD           dwFormatTag;
    DWORD           fdwSupport;
    LPWAVEFORMATEX  pwfx;
    DWORD           cbwfx;
    WCHAR           szFormat[ACMFORMATDETAILS_FORMAT_CHARS];

} ACMFORMATDETAILSW, *PACMFORMATDETAILSW, FAR *LPACMFORMATDETAILSW;

#ifdef _UNICODE
#define ACMFORMATDETAILS    ACMFORMATDETAILSW
#define PACMFORMATDETAILS   PACMFORMATDETAILSW
#define LPACMFORMATDETAILS  LPACMFORMATDETAILSW
#else
#define ACMFORMATDETAILS    ACMFORMATDETAILSA
#define PACMFORMATDETAILS   PACMFORMATDETAILSA
#define LPACMFORMATDETAILS  LPACMFORMATDETAILSA
#endif
#else
typedef struct tACMFORMATDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFormatIndex;
    DWORD           dwFormatTag;
    DWORD           fdwSupport;
    LPWAVEFORMATEX  pwfx;
    DWORD           cbwfx;
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];

} ACMFORMATDETAILS, *PACMFORMATDETAILS, FAR *LPACMFORMATDETAILS;
#endif


#ifdef _WIN32
MMRESULT ACMAPI acmFormatDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFormatDetailsW
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmFormatDetails    acmFormatDetailsW
#else
#define acmFormatDetails    acmFormatDetailsA
#endif
#else
MMRESULT ACMAPI acmFormatDetails
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FORMATDETAILSF_INDEX        0x00000000L
#define ACM_FORMATDETAILSF_FORMAT       0x00000001L
#define ACM_FORMATDETAILSF_QUERYMASK    0x0000000FL



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatEnum()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFORMATENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILSA     pafd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatEnumA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    ACMFORMATENUMCBA        fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);

typedef BOOL (CALLBACK *ACMFORMATENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILSW     pafd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatEnumW
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    ACMFORMATENUMCBW        fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFORMATENUMCB     ACMFORMATENUMCBW
#define acmFormatEnum       acmFormatEnumW
#else
#define ACMFORMATENUMCB     ACMFORMATENUMCBA
#define acmFormatEnum       acmFormatEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFORMATENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILS      pafd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatEnum
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);
#endif

#define ACM_FORMATENUMF_WFORMATTAG       0x00010000L
#define ACM_FORMATENUMF_NCHANNELS        0x00020000L
#define ACM_FORMATENUMF_NSAMPLESPERSEC   0x00040000L
#define ACM_FORMATENUMF_WBITSPERSAMPLE   0x00080000L
#define ACM_FORMATENUMF_CONVERT          0x00100000L
#define ACM_FORMATENUMF_SUGGEST          0x00200000L
#define ACM_FORMATENUMF_HARDWARE         0x00400000L
#define ACM_FORMATENUMF_INPUT            0x00800000L
#define ACM_FORMATENUMF_OUTPUT           0x01000000L


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatSuggest()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmFormatSuggest
(
    HACMDRIVER          had,
    LPWAVEFORMATEX      pwfxSrc,
    LPWAVEFORMATEX      pwfxDst,
    DWORD               cbwfxDst,
    DWORD               fdwSuggest
);

#define ACM_FORMATSUGGESTF_WFORMATTAG       0x00010000L
#define ACM_FORMATSUGGESTF_NCHANNELS        0x00020000L
#define ACM_FORMATSUGGESTF_NSAMPLESPERSEC   0x00040000L
#define ACM_FORMATSUGGESTF_WBITSPERSAMPLE   0x00080000L

#define ACM_FORMATSUGGESTF_TYPEMASK         0x00FF0000L


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatChoose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
#define ACMHELPMSGSTRINGA       "acmchoose_help"
#define ACMHELPMSGSTRINGW       L"acmchoose_help"
#ifdef _UNICODE
#define ACMHELPMSGSTRING        ACMHELPMSGSTRINGW
#else
#define ACMHELPMSGSTRING        ACMHELPMSGSTRINGA
#endif
#else
#define ACMHELPMSGSTRING        "acmchoose_help"
#endif

//
//  MM_ACM_FORMATCHOOSE is sent to hook callbacks by the Format Chooser
//  Dialog...
//
#define MM_ACM_FORMATCHOOSE             (0x8000)

#define FORMATCHOOSE_MESSAGE            0
#define FORMATCHOOSE_FORMATTAG_VERIFY   (FORMATCHOOSE_MESSAGE+0)
#define FORMATCHOOSE_FORMAT_VERIFY      (FORMATCHOOSE_MESSAGE+1)
#define FORMATCHOOSE_CUSTOM_VERIFY      (FORMATCHOOSE_MESSAGE+2)


#ifdef _WIN32
typedef UINT (CALLBACK *ACMFORMATCHOOSEHOOKPROCA)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

typedef UINT (CALLBACK *ACMFORMATCHOOSEHOOKPROCW)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

#ifdef _UNICODE
#define ACMFORMATCHOOSEHOOKPROC     ACMFORMATCHOOSEHOOKPROCW
#else
#define ACMFORMATCHOOSEHOOKPROC     ACMFORMATCHOOSEHOOKPROCA
#endif
#else
typedef UINT (CALLBACK *ACMFORMATCHOOSEHOOKPROC)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);
#endif

//
//
//
//
#ifdef _WIN32
typedef struct tACMFORMATCHOOSEA
{
    DWORD           cbStruct;           // sizeof(ACMFORMATCHOOSE)
    DWORD           fdwStyle;           // chooser style flags
    
    HWND            hwndOwner;          // caller's window handle

    LPWAVEFORMATEX  pwfx;               // ptr to wfx buf to receive choice
    DWORD           cbwfx;              // size of mem buf for pwfx
    LPCSTR          pszTitle;           // dialog box title bar
    
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];    

    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // format enumeration restrictions
    LPWAVEFORMATEX  pwfxEnum;           // format describing restrictions
    
    //
    //  the following members are used for custom templates only--which
    //  are enabled by specifying ACMFORMATCHOOSE_STYLEF_ENABLEHOOK in the
    //  fdwStyle member.
    //
    //  these members are IGNORED if ACMFORMATCHOOSE_STYLEF_ENABLEHOOK is
    //  not specified.
    //
    HINSTANCE       hInstance;          // .EXE containing cust. dlg. template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFORMATCHOOSEHOOKPROCA pfnHook;    // ptr to hook function

} ACMFORMATCHOOSEA, *PACMFORMATCHOOSEA, FAR *LPACMFORMATCHOOSEA;

typedef struct tACMFORMATCHOOSEW
{
    DWORD           cbStruct;           // sizeof(ACMFORMATCHOOSE)
    DWORD           fdwStyle;           // chooser style flags
    
    HWND            hwndOwner;          // caller's window handle

    LPWAVEFORMATEX  pwfx;               // ptr to wfx buf to receive choice
    DWORD           cbwfx;              // size of mem buf for pwfx
    LPCWSTR         pszTitle;           // dialog box title bar
    
    WCHAR           szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    WCHAR           szFormat[ACMFORMATDETAILS_FORMAT_CHARS];    

    LPWSTR          pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // format enumeration restrictions
    LPWAVEFORMATEX  pwfxEnum;           // format describing restrictions
    
    //
    //  the following members are used for custom templates only--which
    //  are enabled by specifying ACMFORMATCHOOSE_STYLEF_ENABLEHOOK in the
    //  fdwStyle member.
    //
    //  these members are IGNORED if ACMFORMATCHOOSE_STYLEF_ENABLEHOOK is
    //  not specified.
    //
    HINSTANCE       hInstance;          // .EXE containing cust. dlg. template
    LPCWSTR         pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFORMATCHOOSEHOOKPROCW pfnHook;    // ptr to hook function

} ACMFORMATCHOOSEW, *PACMFORMATCHOOSEW, FAR *LPACMFORMATCHOOSEW;

#ifdef _UNICODE
#define ACMFORMATCHOOSE     ACMFORMATCHOOSEW
#define PACMFORMATCHOOSE    PACMFORMATCHOOSEW
#define LPACMFORMATCHOOSE   LPACMFORMATCHOOSEW
#else
#define ACMFORMATCHOOSE     ACMFORMATCHOOSEA
#define PACMFORMATCHOOSE    PACMFORMATCHOOSEA
#define LPACMFORMATCHOOSE   LPACMFORMATCHOOSEA
#endif
#else
typedef struct tACMFORMATCHOOSE
{
    DWORD           cbStruct;           // sizeof(ACMFORMATCHOOSE)
    DWORD           fdwStyle;           // chooser style flags
    
    HWND            hwndOwner;          // caller's window handle

    LPWAVEFORMATEX  pwfx;               // ptr to wfx buf to receive choice
    DWORD           cbwfx;              // size of mem buf for pwfx
    LPCSTR          pszTitle;           // dialog box title bar
    
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];    

    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // format enumeration restrictions
    LPWAVEFORMATEX  pwfxEnum;           // format describing restrictions
    
    //
    //  the following members are used for custom templates only--which
    //  are enabled by specifying ACMFORMATCHOOSE_STYLEF_ENABLEHOOK in the
    //  fdwStyle member.
    //
    //  these members are IGNORED if ACMFORMATCHOOSE_STYLEF_ENABLEHOOK is
    //  not specified.
    //
    HINSTANCE       hInstance;          // .EXE containing cust. dlg. template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFORMATCHOOSEHOOKPROC pfnHook;    // ptr to hook function

} ACMFORMATCHOOSE, *PACMFORMATCHOOSE, FAR *LPACMFORMATCHOOSE;
#endif

//
//  ACMFORMATCHOOSE.fdwStyle
//
//
//
#define ACMFORMATCHOOSE_STYLEF_SHOWHELP              0x00000004L
#define ACMFORMATCHOOSE_STYLEF_ENABLEHOOK            0x00000008L
#define ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE        0x00000010L
#define ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE  0x00000020L
#define ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT       0x00000040L

#ifdef _WIN32
MMRESULT ACMAPI acmFormatChooseA
(
    LPACMFORMATCHOOSEA      pafmtc
);

MMRESULT ACMAPI acmFormatChooseW
(
    LPACMFORMATCHOOSEW      pafmtc
);

#ifdef _UNICODE
#define acmFormatChoose     acmFormatChooseW
#else
#define acmFormatChoose     acmFormatChooseA
#endif
#else
MMRESULT ACMAPI acmFormatChoose
(
    LPACMFORMATCHOOSE       pafmtc
);
#endif


//--------------------------------------------------------------------------;
//
//  ACM Filter Tags
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterTagDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFILTERTAGDETAILS_FILTERTAG_CHARS 48

#ifdef _WIN32
typedef struct tACMFILTERTAGDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFilterTagIndex;
    DWORD           dwFilterTag;
    DWORD           cbFilterSize;
    DWORD           fdwSupport;
    DWORD           cStandardFilters;
    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];

} ACMFILTERTAGDETAILSA, *PACMFILTERTAGDETAILSA, FAR *LPACMFILTERTAGDETAILSA;

typedef struct tACMFILTERTAGDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFilterTagIndex;
    DWORD           dwFilterTag;
    DWORD           cbFilterSize;
    DWORD           fdwSupport;
    DWORD           cStandardFilters;
    WCHAR           szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];

} ACMFILTERTAGDETAILSW, *PACMFILTERTAGDETAILSW, FAR *LPACMFILTERTAGDETAILSW;

#ifdef _UNICODE
#define ACMFILTERTAGDETAILS     ACMFILTERTAGDETAILSW
#define PACMFILTERTAGDETAILS    PACMFILTERTAGDETAILSW
#define LPACMFILTERTAGDETAILS   LPACMFILTERTAGDETAILSW
#else
#define ACMFILTERTAGDETAILS     ACMFILTERTAGDETAILSA
#define PACMFILTERTAGDETAILS    PACMFILTERTAGDETAILSA
#define LPACMFILTERTAGDETAILS   LPACMFILTERTAGDETAILSA
#endif
#else
typedef struct tACMFILTERTAGDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFilterTagIndex;
    DWORD           dwFilterTag;
    DWORD           cbFilterSize;
    DWORD           fdwSupport;
    DWORD           cStandardFilters;
    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];

} ACMFILTERTAGDETAILS, *PACMFILTERTAGDETAILS, FAR *LPACMFILTERTAGDETAILS;
#endif

#ifdef _WIN32
MMRESULT ACMAPI acmFilterTagDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFilterTagDetailsW
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSW  paftd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmFilterTagDetails     acmFilterTagDetailsW
#else
#define acmFilterTagDetails     acmFilterTagDetailsA
#endif
#else
MMRESULT ACMAPI acmFilterTagDetails
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FILTERTAGDETAILSF_INDEX         0x00000000L
#define ACM_FILTERTAGDETAILSF_FILTERTAG     0x00000001L
#define ACM_FILTERTAGDETAILSF_LARGESTSIZE   0x00000002L
#define ACM_FILTERTAGDETAILSF_QUERYMASK     0x0000000FL



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterTagEnum()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFILTERTAGENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILSA  paftd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterTagEnumA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    ACMFILTERTAGENUMCBA     fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);

typedef BOOL (CALLBACK *ACMFILTERTAGENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILSW  paftd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterTagEnumW
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSW  paftd,
    ACMFILTERTAGENUMCBW     fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFILTERTAGENUMCB  ACMFILTERTAGENUMCBW
#define acmFilterTagEnum    acmFilterTagEnumW
#else
#define ACMFILTERTAGENUMCB  ACMFILTERTAGENUMCBA
#define acmFilterTagEnum    acmFilterTagEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFILTERTAGENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterTagEnum
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    ACMFILTERTAGENUMCB      fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);
#endif



//--------------------------------------------------------------------------;
//
//  ACM Filters
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFILTERDETAILS_FILTER_CHARS   128

#ifdef _WIN32
typedef struct tACMFILTERDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFilterIndex;
    DWORD           dwFilterTag;
    DWORD           fdwSupport;
    LPWAVEFILTER    pwfltr;
    DWORD           cbwfltr;
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];

} ACMFILTERDETAILSA, *PACMFILTERDETAILSA, FAR *LPACMFILTERDETAILSA;

typedef struct tACMFILTERDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFilterIndex;
    DWORD           dwFilterTag;
    DWORD           fdwSupport;
    LPWAVEFILTER    pwfltr;
    DWORD           cbwfltr;
    WCHAR           szFilter[ACMFILTERDETAILS_FILTER_CHARS];

} ACMFILTERDETAILSW, *PACMFILTERDETAILSW, FAR *LPACMFILTERDETAILSW;

#ifdef _UNICODE
#define ACMFILTERDETAILS    ACMFILTERDETAILSW
#define PACMFILTERDETAILS   PACMFILTERDETAILSW
#define LPACMFILTERDETAILS  LPACMFILTERDETAILSW
#else
#define ACMFILTERDETAILS    ACMFILTERDETAILSA
#define PACMFILTERDETAILS   PACMFILTERDETAILSA
#define LPACMFILTERDETAILS  LPACMFILTERDETAILSA
#endif
#else
typedef struct tACMFILTERDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFilterIndex;
    DWORD           dwFilterTag;
    DWORD           fdwSupport;
    LPWAVEFILTER    pwfltr;
    DWORD           cbwfltr;
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];

} ACMFILTERDETAILS, *PACMFILTERDETAILS, FAR *LPACMFILTERDETAILS;
#endif

#ifdef _WIN32
MMRESULT ACMAPI acmFilterDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFilterDetailsW
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSW     pafd,
    DWORD                   fdwDetails
);
#ifdef _UNICODE
#define acmFilterDetails    acmFilterDetailsW
#else
#define acmFilterDetails    acmFilterDetailsA
#endif
#else
MMRESULT ACMAPI acmFilterDetails
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FILTERDETAILSF_INDEX        0x00000000L
#define ACM_FILTERDETAILSF_FILTER       0x00000001L
#define ACM_FILTERDETAILSF_QUERYMASK    0x0000000FL



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterEnum()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFILTERENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFILTERDETAILSA     pafd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterEnumA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    ACMFILTERENUMCBA        fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);

typedef BOOL (CALLBACK *ACMFILTERENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFILTERDETAILSW     pafd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterEnumW
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSW     pafd,
    ACMFILTERENUMCBW        fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFILTERENUMCB     ACMFILTERENUMCBW
#define acmFilterEnum       acmFilterEnumW
#else
#define ACMFILTERENUMCB     ACMFILTERENUMCBA
#define acmFilterEnum       acmFilterEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFILTERENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFILTERDETAILS      pafd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterEnum
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    ACMFILTERENUMCB         fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
);
#endif

#define ACM_FILTERENUMF_DWFILTERTAG         0x00010000L




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterChoose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  MM_ACM_FILTERCHOOSE is sent to hook callbacks by the Filter Chooser
//  Dialog...
//
#define MM_ACM_FILTERCHOOSE             (0x8000)

#define FILTERCHOOSE_MESSAGE            0
#define FILTERCHOOSE_FILTERTAG_VERIFY   (FILTERCHOOSE_MESSAGE+0)
#define FILTERCHOOSE_FILTER_VERIFY      (FILTERCHOOSE_MESSAGE+1)
#define FILTERCHOOSE_CUSTOM_VERIFY      (FILTERCHOOSE_MESSAGE+2)


#ifdef _WIN32
typedef UINT (CALLBACK *ACMFILTERCHOOSEHOOKPROCA)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

typedef UINT (CALLBACK *ACMFILTERCHOOSEHOOKPROCW)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

#ifdef _UNICODE
#define ACMFILTERCHOOSEHOOKPROC     ACMFILTERCHOOSEHOOKPROCW
#else
#define ACMFILTERCHOOSEHOOKPROC     ACMFILTERCHOOSEHOOKPROCA
#endif
#else
typedef UINT (CALLBACK *ACMFILTERCHOOSEHOOKPROC)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);
#endif

//
//  ACMFILTERCHOOSE
//
//
#ifdef _WIN32
typedef struct tACMFILTERCHOOSEA
{
    DWORD           cbStruct;           // sizeof(ACMFILTERCHOOSE)
    DWORD           fdwStyle;           // chooser style flags

    HWND            hwndOwner;          // caller's window handle

    LPWAVEFILTER    pwfltr;             // ptr to wfltr buf to receive choice
    DWORD           cbwfltr;            // size of mem buf for pwfltr

    LPCSTR          pszTitle;

    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];
    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // filter enumeration restrictions
    LPWAVEFILTER    pwfltrEnum;         // filter describing restrictions
    
    //
    //  the following members are used for custom templates only--which
    //  are enabled by specifying ACMFILTERCHOOSE_STYLEF_ENABLEHOOK in the
    //  fdwStyle member.
    //
    //  these members are IGNORED if ACMFILTERCHOOSE_STYLEF_ENABLEHOOK is not
    //  specified.
    //
    HINSTANCE       hInstance;          // .EXE containing cust. dlg. template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFILTERCHOOSEHOOKPROCA pfnHook;    // ptr to hook function

} ACMFILTERCHOOSEA, *PACMFILTERCHOOSEA, FAR *LPACMFILTERCHOOSEA;

typedef struct tACMFILTERCHOOSEW
{
    DWORD           cbStruct;           // sizeof(ACMFILTERCHOOSE)
    DWORD           fdwStyle;           // chooser style flags

    HWND            hwndOwner;          // caller's window handle

    LPWAVEFILTER    pwfltr;             // ptr to wfltr buf to receive choice
    DWORD           cbwfltr;            // size of mem buf for pwfltr

    LPCWSTR         pszTitle;

    WCHAR           szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];
    WCHAR           szFilter[ACMFILTERDETAILS_FILTER_CHARS];
    LPWSTR          pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // filter enumeration restrictions
    LPWAVEFILTER    pwfltrEnum;         // filter describing restrictions
    
    //
    //  the following members are used for custom templates only--which
    //  are enabled by specifying ACMFILTERCHOOSE_STYLEF_ENABLEHOOK in the
    //  fdwStyle member.
    //
    //  these members are IGNORED if ACMFILTERCHOOSE_STYLEF_ENABLEHOOK is not
    //  specified.
    //
    HINSTANCE       hInstance;          // .EXE containing cust. dlg. template
    LPCWSTR         pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFILTERCHOOSEHOOKPROCW pfnHook;    // ptr to hook function

} ACMFILTERCHOOSEW, *PACMFILTERCHOOSEW, FAR *LPACMFILTERCHOOSEW;

#ifdef _UNICODE
#define ACMFILTERCHOOSE     ACMFILTERCHOOSEW
#define PACMFILTERCHOOSE    PACMFILTERCHOOSEW
#define LPACMFILTERCHOOSE   LPACMFILTERCHOOSEW
#else
#define ACMFILTERCHOOSE     ACMFILTERCHOOSEA
#define PACMFILTERCHOOSE    PACMFILTERCHOOSEA
#define LPACMFILTERCHOOSE   LPACMFILTERCHOOSEA
#endif
#else
typedef struct tACMFILTERCHOOSE
{
    DWORD           cbStruct;           // sizeof(ACMFILTERCHOOSE)
    DWORD           fdwStyle;           // chooser style flags

    HWND            hwndOwner;          // caller's window handle

    LPWAVEFILTER    pwfltr;             // ptr to wfltr buf to receive choice
    DWORD           cbwfltr;            // size of mem buf for pwfltr

    LPCSTR          pszTitle;

    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];
    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // filter enumeration restrictions
    LPWAVEFILTER    pwfltrEnum;         // filter describing restrictions
    
    //
    //  the following members are used for custom templates only--which
    //  are enabled by specifying ACMFILTERCHOOSE_STYLEF_ENABLEHOOK in the
    //  fdwStyle member.
    //
    //  these members are IGNORED if ACMFILTERCHOOSE_STYLEF_ENABLEHOOK is not
    //  specified.
    //
    HINSTANCE       hInstance;          // .EXE containing cust. dlg. template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFILTERCHOOSEHOOKPROC pfnHook;    // ptr to hook function

} ACMFILTERCHOOSE, *PACMFILTERCHOOSE, FAR *LPACMFILTERCHOOSE;
#endif

//
//  ACMFILTERCHOOSE.fdwStyle
//
//
#define ACMFILTERCHOOSE_STYLEF_SHOWHELP              0x00000004L
#define ACMFILTERCHOOSE_STYLEF_ENABLEHOOK            0x00000008L
#define ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE        0x00000010L
#define ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE  0x00000020L
#define ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT    0x00000040L

#ifdef _WIN32
MMRESULT ACMAPI acmFilterChooseA
(
    LPACMFILTERCHOOSEA      pafltrc
);

MMRESULT ACMAPI acmFilterChooseW
(
    LPACMFILTERCHOOSEW      pafltrc
);

#ifdef _UNICODE
#define acmFilterChoose     acmFilterChooseW
#else
#define acmFilterChoose     acmFilterChooseA
#endif
#else
MMRESULT ACMAPI acmFilterChoose
(
    LPACMFILTERCHOOSE       pafltrc
);
#endif


//--------------------------------------------------------------------------;
//
//  ACM Stream API's
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamOpen()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tACMSTREAMHEADER
{
    DWORD           cbStruct;               // sizeof(ACMSTREAMHEADER)
    DWORD           fdwStatus;              // ACMSTREAMHEADER_STATUSF_*
    DWORD           dwUser;                 // user instance data for hdr
    LPBYTE          pbSrc;
    DWORD           cbSrcLength;
    DWORD           cbSrcLengthUsed;
    DWORD           dwSrcUser;              // user instance data for src
    LPBYTE          pbDst;
    DWORD           cbDstLength;
    DWORD           cbDstLengthUsed;
    DWORD           dwDstUser;              // user instance data for dst
    DWORD           dwReservedDriver[10];   // driver reserved work space

} ACMSTREAMHEADER, *PACMSTREAMHEADER, FAR *LPACMSTREAMHEADER;

//
//  ACMSTREAMHEADER.fdwStatus
//
//  ACMSTREAMHEADER_STATUSF_DONE: done bit for async conversions.
//
#define ACMSTREAMHEADER_STATUSF_DONE        0x00010000L
#define ACMSTREAMHEADER_STATUSF_PREPARED    0x00020000L
#define ACMSTREAMHEADER_STATUSF_INQUEUE     0x00100000L



MMRESULT ACMAPI acmStreamOpen
(
    LPHACMSTREAM            phas,       // pointer to stream handle
    HACMDRIVER              had,        // optional driver handle
    LPWAVEFORMATEX          pwfxSrc,    // source format to convert
    LPWAVEFORMATEX          pwfxDst,    // required destination format
    LPWAVEFILTER            pwfltr,     // optional filter
    DWORD                   dwCallback, // callback
    DWORD                   dwInstance, // callback instance data
    DWORD                   fdwOpen     // ACM_STREAMOPENF_* and CALLBACK_*
);

#define ACM_STREAMOPENF_QUERY           0x00000001
#define ACM_STREAMOPENF_ASYNC           0x00000002
#define ACM_STREAMOPENF_NONREALTIME     0x00000004


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamClose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamClose
(
    HACMSTREAM              has,
    DWORD                   fdwClose
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamSize()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamSize
(
    HACMSTREAM              has,
    DWORD                   cbInput,
    LPDWORD                 pdwOutputBytes,
    DWORD                   fdwSize
);

#define ACM_STREAMSIZEF_SOURCE          0x00000000L
#define ACM_STREAMSIZEF_DESTINATION     0x00000001L
#define ACM_STREAMSIZEF_QUERYMASK       0x0000000FL



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamReset()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamReset
(
    HACMSTREAM              has,
    DWORD                   fdwReset
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamConvert()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamConvert
(
    HACMSTREAM              has, 
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwConvert
);

#define ACM_STREAMCONVERTF_BLOCKALIGN   0x00000004
#define ACM_STREAMCONVERTF_START        0x00000010
#define ACM_STREAMCONVERTF_END          0x00000020


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamPrepareHeader()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamPrepareHeader
(
    HACMSTREAM          has,
    LPACMSTREAMHEADER   pash,
    DWORD               fdwPrepare
);




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamUnprepareHeader()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamUnprepareHeader
(
    HACMSTREAM          has,
    LPACMSTREAMHEADER   pash,
    DWORD               fdwUnprepare
);
                                       


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_ACM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\msacmdrv.h ===
//==========================================================================;
//
//  msacmdrv.h
//
//  Copyright (c) 1992-1993 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      Audio Compression Manager Public Header File for Drivers
//
//  History:
//
//==========================================================================;

#ifndef _INC_ACMDRV
#define _INC_ACMDRV         /* #defined if msacmdrv.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)             /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {                /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as 
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows:
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) & 
//      wBuild = LOWORD(dwVersion)
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define MAKE_ACM_VERSION(mjr, mnr, bld) (((long)(mjr)<<24)| \
                                         ((long)(mnr)<<16)| \
                                         ((long)bld))


//
//
//
//
//
#define ACMDRVOPENDESC_SECTIONNAME_CHARS    

#ifdef _WIN32
typedef struct tACMDRVOPENDESCA
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCSTR          pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCSTR          pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName

} ACMDRVOPENDESCA, *PACMDRVOPENDESCA, FAR *LPACMDRVOPENDESCA;

typedef struct tACMDRVOPENDESCW
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCWSTR         pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCWSTR         pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName

} ACMDRVOPENDESCW, *PACMDRVOPENDESCW, FAR *LPACMDRVOPENDESCW;

#ifdef _UNICODE
#define ACMDRVOPENDESC      ACMDRVOPENDESCW
#define PACMDRVOPENDESC     PACMDRVOPENDESCW
#define LPACMDRVOPENDESC    LPACMDRVOPENDESCW
#else
#define ACMDRVOPENDESC      ACMDRVOPENDESCA
#define PACMDRVOPENDESC     PACMDRVOPENDESCA
#define LPACMDRVOPENDESC    LPACMDRVOPENDESCA
#endif
#else
typedef struct tACMDRVOPENDESC
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCSTR          pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCSTR          pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName

} ACMDRVOPENDESC, *PACMDRVOPENDESC, FAR *LPACMDRVOPENDESC;
#endif


//
//
//
//
//
typedef struct tACMDRVSTREAMINSTANCE
{
    DWORD               cbStruct;
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    LPWAVEFILTER        pwfltr;
    DWORD               dwCallback;
    DWORD               dwInstance;
    DWORD               fdwOpen;
    DWORD               fdwDriver;
    DWORD               dwDriver;
    HACMSTREAM          has;

} ACMDRVSTREAMINSTANCE, *PACMDRVSTREAMINSTANCE, FAR *LPACMDRVSTREAMINSTANCE;


//
//  NOTE! this structure must match the ACMSTREAMHEADER in msacm.h but
//  defines more information for the driver writing convenience
//
typedef struct tACMDRVSTREAMHEADER FAR *LPACMDRVSTREAMHEADER;
typedef struct tACMDRVSTREAMHEADER
{
    DWORD                   cbStruct;
    DWORD                   fdwStatus;
    DWORD                   dwUser;
    LPBYTE                  pbSrc;
    DWORD                   cbSrcLength;
    DWORD                   cbSrcLengthUsed;
    DWORD                   dwSrcUser;
    LPBYTE                  pbDst;
    DWORD                   cbDstLength;
    DWORD                   cbDstLengthUsed;
    DWORD                   dwDstUser;

    DWORD                   fdwConvert;     // flags passed from convert func
    LPACMDRVSTREAMHEADER    padshNext;      // for async driver queueing
    DWORD                   fdwDriver;      // driver instance flags
    DWORD                   dwDriver;       // driver instance data

    //
    //  all remaining fields are used by the ACM for bookkeeping purposes.
    //  an ACM driver should never use these fields (though than can be
    //  helpful for debugging)--note that the meaning of these fields
    //  may change, so do NOT rely on them in shipping code.
    //
    DWORD                   fdwPrepared;
    DWORD                   dwPrepared;
    LPBYTE                  pbPreparedSrc;
    DWORD                   cbPreparedSrcLength;
    LPBYTE                  pbPreparedDst;
    DWORD                   cbPreparedDstLength;

} ACMDRVSTREAMHEADER, *PACMDRVSTREAMHEADER;


//
//  structure for ACMDM_STREAM_SIZE message
//
//
typedef struct tACMDRVSTREAMSIZE
{
    DWORD               cbStruct;
    DWORD               fdwSize;
    DWORD               cbSrcLength;
    DWORD               cbDstLength;

} ACMDRVSTREAMSIZE, *PACMDRVSTREAMSIZE, FAR *LPACMDRVSTREAMSIZE;



//
//  structure containing the information for the ACMDM_FORMAT_SUGGEST message
//
//
typedef struct tACMDRVFORMATSUGGEST
{
    DWORD               cbStruct;           // sizeof(ACMDRVFORMATSUGGEST)
    DWORD               fdwSuggest;         // Suggest flags
    LPWAVEFORMATEX      pwfxSrc;            // Source Format
    DWORD               cbwfxSrc;           // Source Size
    LPWAVEFORMATEX      pwfxDst;            // Dest format
    DWORD               cbwfxDst;           // Dest Size

} ACMDRVFORMATSUGGEST, *PACMDRVFORMATSUGGEST, FAR *LPACMDRVFORMATSUGGEST;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//
//
#ifndef WIN32
    LRESULT ACMAPI acmApplicationExit(HTASK htask, LPARAM lParam);
    BOOL ACMAPI acmHugePageLock(LPBYTE pbArea, DWORD cbBuffer);
    void ACMAPI acmHugePageUnlock(LPBYTE pbArea, DWORD cbBuffer);
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Messages
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMDM_DRIVER_NOTIFY             (ACMDM_BASE + 1)
#define ACMDM_DRIVER_DETAILS            (ACMDM_BASE + 10)

#define ACMDM_HARDWARE_WAVE_CAPS_INPUT  (ACMDM_BASE + 20)
#define ACMDM_HARDWARE_WAVE_CAPS_OUTPUT (ACMDM_BASE + 21)

#define ACMDM_FORMATTAG_DETAILS         (ACMDM_BASE + 25)
#define ACMDM_FORMAT_DETAILS            (ACMDM_BASE + 26)
#define ACMDM_FORMAT_SUGGEST            (ACMDM_BASE + 27)

#define ACMDM_FILTERTAG_DETAILS         (ACMDM_BASE + 50)
#define ACMDM_FILTER_DETAILS            (ACMDM_BASE + 51)

#define ACMDM_STREAM_OPEN               (ACMDM_BASE + 76)
#define ACMDM_STREAM_CLOSE              (ACMDM_BASE + 77)
#define ACMDM_STREAM_SIZE               (ACMDM_BASE + 78)
#define ACMDM_STREAM_CONVERT            (ACMDM_BASE + 79)
#define ACMDM_STREAM_RESET              (ACMDM_BASE + 80)
#define ACMDM_STREAM_PREPARE            (ACMDM_BASE + 81)
#define ACMDM_STREAM_UNPREPARE          (ACMDM_BASE + 82)


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_ACMDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video drivers           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		3

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103)

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)
#define DVM_STREAM_FINI                 (DVM_START + 301)
#define DVM_STREAM_GETERROR             (DVM_START + 302)
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)
#define DVM_STREAM_INIT                 (DVM_START + 304)
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)
#define DVM_STREAM_STOP                 (DVM_START + 308)
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)

// Following added post VFW1.1a
#define DVM_STREAM_ALLOCHDRANDBUFFER    (DVM_START + 310)
#define DVM_STREAM_FREEHDRANDBUFFER     (DVM_START + 311)

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
#ifdef WIN32
       LPWSTR lpText;		// Text buffer to fill
#else
       LPSTR lpText;		// Text buffer to fill
#endif
       DWORD  dwLength;		// Size of text buffer in characters
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD  dwCallback;
       DWORD  dwCallbackInst;
       DWORD  dwFlags;
       DWORD  hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\msshrui.h ===
/*****************************************************************/ 
/**						 Microsoft Windows						**/
/**				Copyright (C) Microsoft Corp., 1993				**/
/*****************************************************************/ 

/*
    msshrui.h
    Prototypes and definitions for sharing APIs

    FILE HISTORY:
    gregj	06/03/93	Created
*/

#ifndef _INC_MSSHRUI
#define _INC_MSSHRUI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


BOOL WINAPI IsPathShared(LPCSTR lpPath, BOOL fRefresh);
UINT WINAPI ShareDirectoryNotify(HWND hwnd, LPCSTR lpDir, DWORD dwOper);

#ifndef WNDN_MKDIR
#define WNDN_MKDIR  1
#define WNDN_RMDIR  2
#define WNDN_MVDIR  3
#endif

#define ORD_SHARESHUTDOWNNOTIFY	12

BOOL WINAPI ShareShutdownNotify(DWORD dwFlags, UINT uiMessage, WPARAM wParam, LPARAM lParam);
typedef BOOL (WINAPI *pfnShareShutdownNotify)(DWORD dwFlags, UINT uiMessage, WPARAM wParam, LPARAM lParam);


#ifndef RC_INVOKED
#pragma pack()
#endif

#ifdef __cplusplus
};
#endif  /* __cplusplus */

#endif  /* !_INC_MSSHRUI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\msvideo.h ===
/****************************************************************************/
/*                                                                          */
/*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY   */
/*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE     */
/*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR   */
/*  PURPOSE.								    */
/*        MSVIDEO.H - Include file for Video APIs                           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDEO
#define _INC_MSVIDEO    50      /* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _RCINVOKED


/* video data types */
DECLARE_HANDLE(HVIDEO);                 // generic handle
typedef HVIDEO FAR * LPHVIDEO;
#endif                                  // ifndef RCINVOKED

/****************************************************************************

                        version api

****************************************************************************/

DWORD FAR PASCAL VideoForWindowsVersion(void);

/****************************************************************************

                            Error Return Values

****************************************************************************/
#define DV_ERR_OK               (0)                  /* No error */
#define DV_ERR_BASE             (1)                  /* Error Base */
#define DV_ERR_NONSPECIFIC      (DV_ERR_BASE)
#define DV_ERR_BADFORMAT        (DV_ERR_BASE + 1)
				/* unsupported video format */
#define DV_ERR_STILLPLAYING     (DV_ERR_BASE + 2)
				/* still something playing */
#define DV_ERR_UNPREPARED       (DV_ERR_BASE + 3)
				/* header not prepared */
#define DV_ERR_SYNC             (DV_ERR_BASE + 4)
				/* device is synchronous */
#define DV_ERR_TOOMANYCHANNELS  (DV_ERR_BASE + 5)
				/* number of channels exceeded */
#define DV_ERR_NOTDETECTED	(DV_ERR_BASE + 6)    /* HW not detected */
#define DV_ERR_BADINSTALL	(DV_ERR_BASE + 7)    /* Can not get Profile */
#define DV_ERR_CREATEPALETTE	(DV_ERR_BASE + 8)
#define DV_ERR_SIZEFIELD	(DV_ERR_BASE + 9)
#define DV_ERR_PARAM1		(DV_ERR_BASE + 10)
#define DV_ERR_PARAM2		(DV_ERR_BASE + 11)
#define DV_ERR_CONFIG1		(DV_ERR_BASE + 12)
#define DV_ERR_CONFIG2		(DV_ERR_BASE + 13)
#define DV_ERR_FLAGS		(DV_ERR_BASE + 14)
#define DV_ERR_13		(DV_ERR_BASE + 15)

#define DV_ERR_NOTSUPPORTED     (DV_ERR_BASE + 16)   /* function not suported */
#define DV_ERR_NOMEM            (DV_ERR_BASE + 17)   /* out of memory */
#define DV_ERR_ALLOCATED        (DV_ERR_BASE + 18)   /* device is allocated */
#define DV_ERR_BADDEVICEID      (DV_ERR_BASE + 19)
#define DV_ERR_INVALHANDLE      (DV_ERR_BASE + 20)
#define DV_ERR_BADERRNUM        (DV_ERR_BASE + 21)
#define DV_ERR_NO_BUFFERS       (DV_ERR_BASE + 22)   /* out of buffers */

#define DV_ERR_MEM_CONFLICT     (DV_ERR_BASE + 23)   /* Mem conflict detected */
#define DV_ERR_IO_CONFLICT      (DV_ERR_BASE + 24)   /* I/O conflict detected */
#define DV_ERR_DMA_CONFLICT     (DV_ERR_BASE + 25)   /* DMA conflict detected */
#define DV_ERR_INT_CONFLICT     (DV_ERR_BASE + 26)   /* Interrupt conflict detected */
#define DV_ERR_PROTECT_ONLY     (DV_ERR_BASE + 27)   /* Can not run in standard mode */
#define DV_ERR_LASTERROR        (DV_ERR_BASE + 27)

//#define DV_IDS_PROFILING        (DV_ERR_BASE + 900)
//#define DV_IDS_LISTBOX          (DV_ERR_BASE + 901)

#define DV_ERR_USER_MSG         (DV_ERR_BASE + 1000) /* Hardware specific errors */

/****************************************************************************

                         Callback Messages

Note that the values for all installable driver callback messages are
identical, (ie. MM_DRVM_DATA has the same value for capture drivers,
installable video codecs, and the audio compression manager).
****************************************************************************/
#ifndef _RCINVOKED

#ifndef MM_DRVM_OPEN
#define MM_DRVM_OPEN       0x3D0
#define MM_DRVM_CLOSE      0x3D1
#define MM_DRVM_DATA       0x3D2
#define MM_DRVM_ERROR      0x3D3
#endif

#define DV_VM_OPEN         MM_DRVM_OPEN         // Obsolete messages
#define DV_VM_CLOSE        MM_DRVM_CLOSE
#define DV_VM_DATA         MM_DRVM_DATA
#define DV_VM_ERROR        MM_DRVM_ERROR

/****************************************************************************

                         Structures

****************************************************************************/
/* video data block header */
typedef struct videohdr_tag {
    LPBYTE      lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* Length of data buffer */
    DWORD       dwBytesUsed;            /* Bytes actually used */
    DWORD       dwTimeCaptured;         /* Milliseconds from start of stream */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwReserved[4];          /* reserved for driver */
} VIDEOHDR, NEAR *PVIDEOHDR, FAR * LPVIDEOHDR;

/* dwFlags field of VIDEOHDR */
#define VHDR_DONE       0x00000001  /* Done bit */
#define VHDR_PREPARED   0x00000002  /* Set if this header has been prepared */
#define VHDR_INQUEUE    0x00000004  /* Reserved for driver */
#define VHDR_KEYFRAME   0x00000008  /* Key Frame */

/* Channel capabilities structure */
typedef struct channel_caps_tag {
    DWORD       dwFlags;                /* Capability flags*/
    DWORD       dwSrcRectXMod;          /* Granularity of src rect in x */
    DWORD       dwSrcRectYMod;          /* Granularity of src rect in y */
    DWORD       dwSrcRectWidthMod;      /* Granularity of src rect width */
    DWORD       dwSrcRectHeightMod;     /* Granularity of src rect height */
    DWORD       dwDstRectXMod;          /* Granularity of dst rect in x */
    DWORD       dwDstRectYMod;          /* Granularity of dst rect in y */
    DWORD       dwDstRectWidthMod;      /* Granularity of dst rect width */
    DWORD       dwDstRectHeightMod;     /* Granularity of dst rect height */
} CHANNEL_CAPS, NEAR *PCHANNEL_CAPS, FAR * LPCHANNEL_CAPS;

/* dwFlags of CHANNEL_CAPS */
#define VCAPS_OVERLAY       0x00000001      /* overlay channel */
#define VCAPS_SRC_CAN_CLIP  0x00000002      /* src rect can clip */
#define VCAPS_DST_CAN_CLIP  0x00000004      /* dst rect can clip */
#define VCAPS_CAN_SCALE     0x00000008      /* allows src != dst */

/****************************************************************************

   videoXXXX API's are only available on Win 3.x!  they are Not in Win32

****************************************************************************/

#if !defined WIN32

/****************************************************************************

                        video APIs

****************************************************************************/


DWORD WINAPI videoGetNumDevs(void);

DWORD WINAPI videoOpen  (LPHVIDEO lphVideo,
              DWORD dwDevice, DWORD dwFlags);
DWORD WINAPI videoClose (HVIDEO hVideo);
DWORD WINAPI videoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
                DWORD dwSize);
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC);
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2);

DWORD WINAPI videoConfigureStorage (HVIDEO hVideo,
                      LPSTR lpstrIdent, DWORD dwFlags);

DWORD WINAPI videoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
DWORD WINAPI videoMessage(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);

/* streaming APIs */
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwErrorFirst,
        LPDWORD lpdwErrorLast);

DWORD WINAPI videoGetErrorText(HVIDEO hVideo, UINT wError,
              LPSTR lpText, UINT wSize);

DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, MMTIME FAR* lpInfo,
              DWORD dwSize);
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD dwCallback,
              DWORD dwCallbackInst, DWORD dwFlags);
DWORD WINAPI videoStreamFini(HVIDEO hVideo);
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamReset(HVIDEO hVideo);
DWORD WINAPI videoStreamStart(HVIDEO hVideo);
DWORD WINAPI videoStreamStop(HVIDEO hVideo);
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);

// Added post VFW1.1a
DWORD WINAPI videoStreamAllocHdrAndBuffer(HVIDEO hVideo,
              LPVIDEOHDR FAR * plpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamFreeHdrAndBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr);


#endif // ! win32


/****************************************************************************

			API Flags

****************************************************************************/

// Types of channels to open with the videoOpen function
#define VIDEO_EXTERNALIN		0x0001
#define VIDEO_EXTERNALOUT		0x0002
#define VIDEO_IN			0x0004
#define VIDEO_OUT			0x0008

// Is a driver dialog available for this channel?
#define VIDEO_DLG_QUERY			0x0010

// videoConfigure (both GET and SET)
#define VIDEO_CONFIGURE_QUERY   	0x8000

// videoConfigure (SET only)
#define VIDEO_CONFIGURE_SET		0x1000

// videoConfigure (GET only)
#define VIDEO_CONFIGURE_GET		0x2000
#define VIDEO_CONFIGURE_QUERYSIZE	0x0001

#define VIDEO_CONFIGURE_CURRENT		0x0010
#define VIDEO_CONFIGURE_NOMINAL		0x0020
#define VIDEO_CONFIGURE_MIN		0x0040
#define VIDEO_CONFIGURE_MAX		0x0080

/****************************************************************************

			CONFIGURE MESSAGES

****************************************************************************/
#define DVM_USER                        0X4000

#define DVM_CONFIGURE_START		0x1000
#define DVM_CONFIGURE_END		0x1FFF

#define DVM_PALETTE			(DVM_CONFIGURE_START + 1)
#define DVM_FORMAT			(DVM_CONFIGURE_START + 2)
#define DVM_PALETTERGB555		(DVM_CONFIGURE_START + 3)
#define DVM_SRC_RECT    		(DVM_CONFIGURE_START + 4)
#define DVM_DST_RECT    		(DVM_CONFIGURE_START + 5)

#endif  /* ifndef _RCINVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDEO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\nddeapi.h ===
/*****************************************************************************\
*                                                                             *
* nddeapi.h -   Network DDE share manipulation and control functions          *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef          _INC_NDDEAPI
#define          _INC_NDDEAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif    /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI          FAR PASCAL
#define CALLBACK        FAR PASCAL
#define LPCSTR          LPSTR
#define UINT            WORD
#define LPARAM          LONG
#define WPARAM          WORD
#define LRESULT         LONG
#define HMODULE         HANDLE
#define HINSTANCE       HANDLE
#define HLOCAL          HANDLE
#define HGLOBAL         HANDLE
#endif  /* WINAPI */

#ifndef CNLEN           /* If not included with netapi header */
#define CNLEN           15                  /* Computer name length     */
#define UNCLEN          (CNLEN+2)           /* UNC computer name length */
#endif /* CNLEN */

/* API error codes  */
#define NDDE_NO_ERROR                  0
#define NDDE_ACCESS_DENIED             1
#define NDDE_BUF_TOO_SMALL             2
#define NDDE_ERROR_MORE_DATA           3
#define NDDE_INVALID_SERVER            4
#define NDDE_INVALID_SHARE             5
#define NDDE_INVALID_PARAMETER         6
#define NDDE_INVALID_LEVEL             7
#define NDDE_INVALID_PASSWORD          8
#define NDDE_INVALID_ITEMNAME          9
#define NDDE_INVALID_TOPIC             10
#define NDDE_INTERNAL_ERROR            11
#define NDDE_OUT_OF_MEMORY             12
#define NDDE_INVALID_APPNAME           13
#define NDDE_NOT_IMPLEMENTED           14
#define NDDE_SHARE_ALREADY_EXIST       15
#define NDDE_SHARE_NOT_EXIST           16
#define NDDE_INVALID_FILENAME          17
#define NDDE_NOT_RUNNING               18
#define NDDE_INVALID_WINDOW            19
#define NDDE_INVALID_SESSION           20

/* string size constants */
#define MAX_NDDESHARENAME       64
#define MAX_PASSWORD            15
#define MAX_USERNAME            15
#define MAX_DOMAINNAME          15
#define MAX_APPNAME             255
#define MAX_TOPICNAME           255
#define MAX_ITEMNAME            255

/* permission mask bits */
#define NDDEACCESS_REQUEST      0x00000001L
#define NDDEACCESS_ADVISE       0x00000002L
#define NDDEACCESS_POKE         0x00000004L
#define NDDEACCESS_EXECUTE      0x00000008L
#define NDDEACCESS_START_APP    0x00000010L

/* connectFlags bits for ndde service affix */
#define NDDEF_NOPASSWORDPROMPT  0x0001
#define NDDEF_NOCACHELOOKUP     0x0002
#define NDDEF_STRIP_NDDE        0x0004


/* NDDESHAREITEMINFO - contains information about item security */

struct NDdeShareItemInfo_tag {
        LPSTR                   lpszItem;
        DWORD                   dwPermissions;
};
typedef struct NDdeShareItemInfo_tag NDDESHAREITEMINFO;
typedef struct NDdeShareItemInfo_tag * PNDDESHAREITEMINFO;
typedef struct NDdeShareItemInfo_tag far * LPNDDESHAREITEMINFO;

/* NDDESHAREINFO - contains information about a NDDE share */

struct NDdeShareInfo_tag {
        char                    szShareName[ MAX_NDDESHARENAME+1 ];
        LPSTR                   lpszTargetApp;
        LPSTR                   lpszTargetTopic;
        LPBYTE                  lpbPassword1;
        DWORD                   cbPassword1;
        DWORD                   dwPermissions1;                                                      
        LPBYTE                  lpbPassword2;
        DWORD                   cbPassword2;
        DWORD                   dwPermissions2;                                                      
        LPSTR                   lpszItem;
        LONG                    cAddItems;
        LPNDDESHAREITEMINFO     lpNDdeShareItemInfo;
};
typedef struct NDdeShareInfo_tag NDDESHAREINFO;
typedef struct NDdeShareInfo_tag * PNDDESHAREINFO;
typedef struct NDdeShareInfo_tag far * LPNDDESHAREINFO;

/* ddesess_Status defines */
#define NDDESESS_CONNECTING_WAIT_NET_INI                1
#define NDDESESS_CONNECTING_WAIT_OTHR_ND                2
#define NDDESESS_CONNECTED                              3
#define NDDESESS_DISCONNECTING                          4       

/* NDDESESSINFO - contains information about a NDDE session */

struct NDdeSessInfo_tag {
                char        szClientName[UNCLEN+1];
                short       Status;
                DWORD       UniqueID;
};
typedef struct NDdeSessInfo_tag NDDESESSINFO;
typedef struct NDdeSessInfo_tag * PNDDESESSINFO;
typedef struct NDdeSessInfo_tag far * LPNDDESESSINFO;

/* ddeconn_Status defines */
#define NDDECONN_WAIT_LOCAL_INIT_ACK    1
#define NDDECONN_WAIT_NET_INIT_ACK      2
#define NDDECONN_OK                     3
#define NDDECONN_TERMINATING            4
#define NDDECONN_WAIT_USER_PASSWORD     5

/* NDDECONNINFO - contains information about a NDDE conversation */

struct NDdeConnInfo_tag {
        LPSTR   lpszShareName;
        short   Status;
        short   pad;
};
typedef struct NDdeConnInfo_tag NDDECONNINFO;
typedef struct NDdeConnInfo_tag * PNDDECONNINFO;
typedef struct NDdeConnInfo_tag far * LPNDDECONNINFO;

UINT WINAPI NDdeShareAdd(LPSTR, UINT, LPBYTE, DWORD );
UINT WINAPI NDdeShareDel(LPSTR, LPSTR, UINT );
UINT WINAPI NDdeShareEnum(LPSTR, UINT, LPBYTE, DWORD, LPDWORD, LPDWORD );
UINT WINAPI NDdeShareGetInfo(LPSTR, LPSTR, UINT, LPBYTE, DWORD, LPDWORD, LPWORD);
UINT WINAPI NDdeShareSetInfo(LPSTR, LPSTR, UINT, LPBYTE, DWORD, WORD);
UINT WINAPI NDdeGetErrorString(UINT, LPSTR, DWORD);
BOOL WINAPI NDdeIsValidShareName(LPSTR);
BOOL WINAPI NDdeIsValidPassword(LPSTR);
BOOL WINAPI NDdeIsValidTopic(LPSTR);
BOOL WINAPI NDdeIsSharingAllowed(VOID);
UINT WINAPI NDdeSessionEnum(LPSTR, UINT, LPBYTE, DWORD, LPDWORD, LPDWORD);
UINT WINAPI NDdeConnectionEnum(LPSTR, LPSTR, DWORD, UINT, LPBYTE, DWORD, LPDWORD, LPDWORD);
UINT WINAPI NDdeSessionClose(LPSTR, LPSTR, DWORD);                      
HWND WINAPI NDdeGetWindow(VOID);
UINT WINAPI NDdeGetClientInfo(HWND, LPSTR, LONG, LPSTR, LONG);
UINT WINAPI NDdeGetNodeName(LPSTR, LONG);

#ifdef __cplusplus
}
#endif    /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* _INC_NDDEAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\oldboot.inc ===
db	0EBH,03CH,090H,04DH,053H,044H,04FH,053H
	db	037H,02EH,030H,000H,002H,008H,001H,000H
	db	002H,000H,002H,003H,051H,0F8H,008H,000H
	db	011H,000H,004H,000H,001H,000H,000H,000H
	db	000H,000H,000H,000H,080H,000H,029H,000H
	db	000H,000H,000H,04EH,04FH,020H,04EH,041H
	db	04DH,045H,020H,020H,020H,020H,046H,041H
	db	054H,031H,032H,020H,020H,020H,0FAH,033H
	db	0C0H,08EH,0D0H,0BCH,000H,07CH,016H,007H
	db	0BBH,078H,000H,036H,0C5H,037H,01EH,056H
	db	016H,053H,0BFH,03EH,07CH,0B9H,00BH,000H
	db	0FCH,0F3H,0A4H,006H,01FH,0C6H,045H,0FEH
	db	00FH,08BH,00EH,018H,07CH,088H,04DH,0F9H
	db	089H,047H,002H,0C7H,007H,03EH,07CH,0FBH
	db	0CDH,013H,072H,079H,033H,0C0H,039H,006H
	db	013H,07CH,074H,008H,08BH,00EH,013H,07CH
	db	089H,00EH,020H,07CH,0A0H,010H,07CH,0F7H
	db	026H,016H,07CH,003H,006H,01CH,07CH,013H
	db	016H,01EH,07CH,003H,006H,00EH,07CH,083H
	db	0D2H,000H,0A3H,050H,07CH,089H,016H,052H
	db	07CH,0A3H,049H,07CH,089H,016H,04BH,07CH
	db	0B8H,020H,000H,0F7H,026H,011H,07CH,08BH
	db	01EH,00BH,07CH,003H,0C3H,048H,0F7H,0F3H
	db	001H,006H,049H,07CH,083H,016H,04BH,07CH
	db	000H,0BBH,000H,005H,08BH,016H,052H,07CH
	db	0A1H,050H,07CH,0E8H,092H,000H,072H,01DH
	db	0B0H,001H,0E8H,0ACH,000H,072H,016H,08BH
	db	0FBH,0B9H,00BH,000H,0BEH,0E6H,07DH,0F3H
	db	0A6H,075H,00AH,08DH,07FH,020H,0B9H,00BH
	db	000H,0F3H,0A6H,074H,018H,0BEH,09EH,07DH
	db	0E8H,05FH,000H,033H,0C0H,0CDH,016H,05EH
	db	01FH,08FH,004H,08FH,044H,002H,0CDH,019H
	db	058H,058H,058H,0EBH,0E8H,08BH,047H,01AH
	db	048H,048H,08AH,01EH,00DH,07CH,032H,0FFH
	db	0F7H,0E3H,003H,006H,049H,07CH,013H,016H
	db	04BH,07CH,0BBH,000H,007H,0B9H,003H,000H
	db	050H,052H,051H,0E8H,03AH,000H,072H,0D8H
	db	0B0H,001H,0E8H,054H,000H,059H,05AH,058H
	db	072H,0BBH,005H,001H,000H,083H,0D2H,000H
	db	003H,01EH,00BH,07CH,0E2H,0E2H,08AH,02EH
	db	015H,07CH,08AH,016H,024H,07CH,08BH,01EH
	db	049H,07CH,0A1H,04BH,07CH,0EAH,000H,000H
	db	070H,000H,0ACH,00AH,0C0H,074H,029H,0B4H
	db	00EH,0BBH,007H,000H,0CDH,010H,0EBH,0F2H
	db	03BH,016H,018H,07CH,073H,019H,0F7H,036H
	db	018H,07CH,0FEH,0C2H,088H,016H,04FH,07CH
	db	033H,0D2H,0F7H,036H,01AH,07CH,088H,016H
	db	025H,07CH,0A3H,04DH,07CH,0F8H,0C3H,0F9H
	db	0C3H,0B4H,002H,08BH,016H,04DH,07CH,0B1H
	db	006H,0D2H,0E6H,00AH,036H,04FH,07CH,08BH
	db	0CAH,086H,0E9H,08AH,016H,024H,07CH,08AH
	db	036H,025H,07CH,0CDH,013H,0C3H,00AH,00DH
	db	04EH,06FH,06EH,02DH,053H,079H,073H,074H
	db	065H,06DH,020H,064H,069H,073H,06BH,020H
	db	06FH,072H,020H,064H,069H,073H,06BH,020H
	db	065H,072H,072H,06FH,072H,00AH,00DH,052H
	db	065H,070H,06CH,061H,063H,065H,020H,061H
	db	06EH,064H,020H,070H,072H,065H,073H,073H
	db	020H,061H,06EH,079H,020H,06BH,065H,079H
	db	020H,077H,068H,065H,06EH,020H,072H,065H
	db	061H,064H,079H,00AH,00DH,000H,049H,04FH
	db	020H,020H,020H,020H,020H,020H,053H,059H
	db	053H,04DH,053H,044H,04FH,053H,020H,020H
	db	020H,053H,059H,053H,000H,000H,055H,0AAH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains the function declarations for C++ memory allocation functions.
*
****/

#ifndef _INC_NEW

#ifdef __cplusplus


/* constants for based heap routines */

#define _NULLSEG    ((__segment)0)
#define _NULLOFF    ((void __based(void) *)0xffff)

/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

typedef int (__cdecl * _PNH)( size_t );
typedef int (__cdecl * _PNHH)( unsigned long, size_t );
typedef int (__cdecl * _PNHB)( __segment, size_t );

/* function prototypes */

_PNH __cdecl _set_new_handler( _PNH );
_PNH __cdecl _set_nnew_handler( _PNH );
_PNH __cdecl _set_fnew_handler( _PNH );
_PNHH __cdecl _set_hnew_handler( _PNHH );
_PNHB __cdecl _set_bnew_handler( _PNHB );

#else 

/* handler functions only supported in C++, emit appropriate error */
#error Functions declared in new.h can only be used in C++ source

#endif 

#define _INC_NEW
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\netdi.h ===
//**********************************************************************
//
//  NETDI.H
//
//  Copyright (c) 1994 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Chicago Network Device Installer services.
//
//**********************************************************************

#ifndef _INC_NETDI
#define _INC_NETDI          // NETDI.H signature
#include <prsht.h>          // Property sheet API
#include <setupx.h>         // Device Installer API

// Return error codes for NDI_ messages.
#define NDI_ERROR           (1200)  // BUGBUG see setupx.h for error #
enum _ERR_NET_DEVICE_INSTALL
{
    ERR_NDI_ERROR               = NDI_ERROR,  // generic failure
    ERR_NDI_INVALID_HNDI,
    ERR_NDI_INVALID_DEVICE_INFO,
    ERR_NDI_INVALID_DRIVER_PROC,
    ERR_NDI_LOW_MEM,
    ERR_NDI_REG_API,
    ERR_NDI_NOTBOUND,
    ERR_NDI_NO_MATCH,
    ERR_NDI_INVALID_NETCLASS,
    ERR_NDI_INSTANCE_ONCE,
    ERR_NDI_CANCEL,
};


// Network Driver Info Handle
DECLARE_HANDLE(HNDI);

// Network Driver Installer Callback
typedef RETERR (CALLBACK* NDIPROC)(HNDI, UINT, WPARAM, LPARAM);
RETERR WINAPI DefNdiProc(HNDI,UINT,WPARAM,LPARAM);

// Network Driver Installer Messages
#define NDI_NULL                0x0000
#define NDI_CREATE              0x0001
#define NDI_DESTROY             0x0002
#define NDI_VALIDATE            0x0003
#define NDI_INSTALL             0x0004
// johnri 3/8/84 removed-using property sheets only
//#define NDI_ASSIGNRESOURCES     0x0005
#define NDI_HASPROPPAGES        0x0005
#define NDI_ADDPROPPAGES        0x0006
// lpapp = (LPNDIADDPROPPAGES)lParam;
typedef BOOL (CALLBACK* LPFNADDNDIPROPPAGE)(LPCPROPSHEETPAGE,LPARAM,BOOL);
typedef struct tagNDIADDPROPPAGES
{
    LPFNADDNDIPROPPAGE      lpfnAddNdiPropPage;
    LPARAM                  lParam;
} NDIADDPROPPAGES, FAR* LPNDIADDPROPPAGES;

#define NDI_REMOVE              0x0007
#define NDI_FIRSTTIMESETUP      0x0008
#define NDI_QUERY_BIND          0x0009
#define NDI_NOTIFY_BIND         0x000A
#define NDI_NOTIFY_UNBIND       0x000B
#define NDI_GETTEXT             0x000C
#define NDI_SETTEXT             0x000D

#define NDI_NDICREATE           0x0040
#define NDI_NDIDESTROY          0x0041

// Messages above NDI_INSTALLER are reserved for installer dlls
#define NDI_INSTALLER           0x8000


// General NDI management
HNDI   WINAPI NdiGetFirst(VOID);
HNDI   WINAPI NdiGetNext(HNDI hndi);
HNDI   WINAPI NdiFindNdi(HNDI ndiRelation, WORD wNetClass, LPCSTR lpszDeviceId);
RETERR WINAPI NdiIsNdi(HNDI hndi);
RETERR WINAPI NdiCallInstaller(HNDI hndi,UINT,WPARAM,LPARAM);
RETERR WINAPI NdiAddNewDriver(HNDI FAR* lphndi, LPDEVICE_INFO lpdi, LPCSTR lpszDeviceID, UINT uFlags);
    #define NDI_ADD_NO_DISELECT 0x0001


// Device Manager
RETERR WINAPI NdiValidate(HNDI hndi, HWND hwndParent);
RETERR WINAPI NdiInstall(HNDI hndi);
RETERR WINAPI NdiRemove(HNDI hndi);
RETERR WINAPI NdiProperties(HNDI hndi, HWND hwndParent);


// Bindings
RETERR WINAPI NdiBind(HNDI hndiLower, HNDI hndiUpper);
RETERR WINAPI NdiUnbind(HNDI hndiLower, HNDI hndiUpper);
RETERR WINAPI NdiQueryBind(HNDI hndiLower, HNDI hndiUpper, UINT uBindType);
RETERR WINAPI NdiIsBound(HNDI hndiLower, HNDI hndiUpper);
RETERR WINAPI NdiGetBinding(HNDI hndi, HNDI FAR* lphndi, UINT uBindType);
enum _NDIBIND {
    NDIBIND_UPPER       = 1,
    NDIBIND_UPPER_FIRST = NDIBIND_UPPER,
    NDIBIND_UPPER_NEXT,
    NDIBIND_LOWER,
    NDIBIND_LOWER_FIRST = NDIBIND_LOWER,
    NDIBIND_LOWER_NEXT};


// General NDI Object Properties
RETERR WINAPI NdiGetText(HNDI hndi, LPSTR, UINT);
RETERR WINAPI NdiSetText(HNDI hndi, LPSTR);
RETERR WINAPI NdiGetDeviceInfo(HNDI hndi, LPLPDEVICE_INFO);
RETERR WINAPI NdiGetClass(HNDI hndi, LPWORD lpwClass);
enum _NDICLASS {    // lpwClass
    NDI_CLASS_NET,
    NDI_CLASS_TRANS,
    NDI_CLASS_CLIENT,
    NDI_CLASS_SERVICE};
RETERR WINAPI NdiGetProperties(HNDI hndi, LPVOID FAR* lplpvProperties);
RETERR WINAPI NdiSetProperties(HNDI hndi, LPVOID lpvProperties);
RETERR WINAPI NdiGetOwnerWindow(HNDI hndi, HWND FAR* lphwnd);
RETERR WINAPI NdiGetDeviceId(HNDI hndi, LPSTR, UINT);
RETERR WINAPI NdiGetFlags(HNDI hndi, LPDWORD lpdwFlags);
    #define NDIF_ADDED                  0x00000001
    #define NDIF_REMOVED                0x00000002
    #define NDIF_MODIFIED_BINDINGS      0x00000004
    #define NDIF_MODIFIED_PROPERTIES    0x00000008
    #define NDIF_SAVE_MASK              0x0000000F
    #define NDIF_DEFAULT                0x00000010
    #define NDIF_INVISIBLE              0x00000020
    #define NDIF_HAS_PARAMS             0x00000040


// Interfaces
RETERR WINAPI NdiCompareInterface(HNDI ndi, UINT uRelation, HNDI ndi2, UINT uRelation2);
RETERR WINAPI NdiGetInterface(HNDI ndi, UINT uRelation, UINT index, LPSTR lpsz, UINT cbSizeOflpsz);
RETERR WINAPI NdiAddInterface(HNDI ndi, UINT uRelation, LPCSTR lpsz);
RETERR WINAPI NdiRemoveInterface(HNDI ndi, UINT uRelation, LPCSTR lpsz);
enum _NDIEDGERELATION {
    NDI_EDGE_ALL=100,               // used to free all edges and marker for first in edge class
    NDI_EDGE_UPPER,
    NDI_EDGE_LOWER,
    NDI_EDGE_UPPERRANGE,
    NDI_EDGE_LOWERRANGE,
    NDI_EDGE_REQUIRELOWER,
    NDI_EDGE_REQUIREANY,
    NDI_EDGE_EXCLUDELOWER,
    NDI_EDGE_EXCLUDEANY,
    NDI_EDGE_ORGUPPER,
    NDI_EDGE_ORGLOWER,
    NDI_EDGE_END,                   // marker only for end of edges
    NDI_COMATIBLE_ALL=200,          // used to free all edges and marker for first in compatible class
    NDI_COMPATIBLE_REQUIREDUPPER,
    NDI_COMPATIBLE_REQUIREDLOWER,
    NDI_COMPATIBLE_REQUIREDALL,
    NDI_COMPATIBLE_EXCLUDEUPPER,
    NDI_COMPATIBLE_EXCLUDELOWER,
    NDI_COMPATIBLE_EXCLUDEALL,
    NDI_COMPATIBLE_END };           // marker only for end of edges


// Driver Registry Access
RETERR WINAPI NdiRegOpenKey(HNDI hndi, LPCSTR lpszSubKey, LPHKEY lphk);
RETERR WINAPI NdiRegCreateKey(HNDI hndi, LPCSTR lpszSubKey, LPHKEY lphk);
RETERR WINAPI NdiRegCloseKey(HKEY hkey);
RETERR WINAPI NdiRegQueryValue(HNDI hndi, LPCSTR lpszSubKey, LPCSTR lpszValueName, LPSTR lpValue, DWORD cbValue);
RETERR WINAPI NdiRegSetValue(HNDI hndi, LPCSTR lpszSubKey, LPCSTR lpszValueName, DWORD dwType, LPCSTR lpValue, DWORD cbValue);
RETERR WINAPI NdiRegDeleteValue(HNDI hndi,LPCSTR lpszSubKey, LPCSTR lpszValueName);




// Entry point called by NETCPL.
RETERR WINAPI NdiCplProperties(HWND hwndCpl);

#endif // _INC_NETDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\multinet.h ===
#ifndef _multinet_h_
#define _multinet_h_

//////////////////////////////////////////////////////////////////////////////
//          Microsoft LAN Manager                   //
//      Copyright(c) Microsoft Corp., 1992              //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                      //
// COMPONENT:   Windows Dual Network DLL/Winball DLL.               //
//                                      //
// FILE:    MULTINET.H                          //
//                                      //
// PURPOSE: General C include file to be included by modules that use   //
//      the multi-network extensions to the WINNET interface.       //
//                                      //
// REVISION HISTORY:                                //
//  lens    20-Apr-1992 First revision for Winball.             //
//                                      //
//////////////////////////////////////////////////////////////////////////////

//
// Return status codes from device/resource/file utilities.
//
#define DN_PT_UNKNOWN       0       /* Unknown or bad device or resource syntax */
#define DN_PT_PRINTER       1       /* Device is a printer */
#define DN_PT_DISK      2       /* Device is a disk drive */
#define DN_PT_UNC       3       /* Resource is a UNC name */
#define DN_PT_ALIAS     4       /* Resource is an alias name */
#define DN_PT_NETWARE       5       /* Resource follows NetWare convention */
#define DN_PT_FILELISTDEVICE    6       /* Device is first entry in file list */

//
// Masks for individual network information
//
#define MNM_NET_PRIMARY     0x0001      /* Network is primary network (Windows network) */

//
// Function prototypes for multi-net extensions
//
HANDLE FAR PASCAL __export MNetGetLastTarget ( void );
WORD   FAR PASCAL __export MNetSetNextTarget ( HANDLE hNetwork );
WORD   FAR PASCAL __export MNetNetworkEnum   ( HANDLE FAR *hNetwork );
WORD   FAR PASCAL __export MNetGetNetInfo    ( HANDLE hNetwork, LPWORD lpwNetInfo, LPSTR lpszButton, LPINT lpcbButton, LPHANDLE lphInstance );

#endif /* _multinet_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\newexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *	(C) Copyright Microsoft Corp 1984-1994
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERESWDS]; /* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    unsigned short int  ne_magic;       /* Magic number NE_MAGIC */
    char                ne_ver;         /* Version number */
    char                ne_rev;         /* Revision number */
    unsigned short int  ne_enttab;      /* Offset of Entry Table */
    unsigned short int  ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short int  ne_flags;       /* Flag word */
    unsigned short int  ne_autodata;    /* Automatic data segment number */
    unsigned short int  ne_heap;        /* Initial heap allocation */
    unsigned short int  ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short int  ne_cseg;        /* Count of file segments */
    unsigned short int  ne_cmod;        /* Entries in Module Reference Table */
    unsigned short int  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short int  ne_segtab;      /* Offset of Segment Table */
    unsigned short int  ne_rsrctab;     /* Offset of Resource Table */
    unsigned short int  ne_restab;      /* Offset of resident name table */
    unsigned short int  ne_modtab;      /* Offset of Module Reference Table */
    unsigned short int  ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short int  ne_cmovent;     /* Count of movable entries */
    unsigned short int  ne_align;       /* Segment alignment shift count */
    unsigned short int  ne_cres;        /* Count of resource segments */
    unsigned char	ne_exetyp;	/* Target Operating system */
    unsigned char	ne_flagsothers;	/* Other .EXE flags */
    unsigned short int  ne_pretthunks;  /* offset to return thunks */
    unsigned short int  ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int  ne_swaparea;    /* Minimum code swap area size */
    unsigned short int  ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res
#define NE_EXETYPE(x)	(x).ne_exetyp

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   c                                  Non-conforming
 *    e                                 Errors in image
 *     xxxxxxxxx                        Unused
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
    unsigned short      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    char                nr_stype;       /* Source type */
    char                nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            char        nr_segno;       /* Target segment number */
            char        nr_res;         /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define OSFIXUP 	0x03		/* Floating point fixup */


/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;            /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004      /* True if handler proc return handle */

#define RNCOMPR     0x0200	/* Resource is compressed in ROM */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

/* Target operating systems:  Possible values of ne_exetyp field */

#define NE_UNKNOWN	0	/* Unknown (any "new-format" OS) */
#define NE_OS2		1	/* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS	2	/* Microsoft Windows		 */
#define NE_DOS4 	3	/* Microsoft MS-DOS 4.x		 */
#define NE_DEV386	4	/* Microsoft Windows 386	 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\ole2ver.h ===
#define rmj		0
#define rmm		23
#define rup		430
#define szVerName	""
#define szVerUser	"OLE2BUILD"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\ole.h ===
/*****************************************************************************\
*                                                                             *
* ole.h -   Object Linking and Embedding functions, types, and definitions    *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* NOTE: windows.h must be #included first				      *
*                                                                             *
* Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_OLE
#define _INC_OLE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    UINT otdDeviceNameOffset;
    UINT otdDriverNameOffset;
    UINT otdPortNameOffset;
    UINT otdExtDevmodeOffset;
    UINT otdExtDevmodeSize;
    UINT otdEnvironmentOffset;
    UINT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY         /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none, 
    olerender_draw, 
    olerender_format 
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifndef OLE_INTERNAL
    oleupdate_oncall
#else
    oleupdate_oncall,
    oleupdate_onclose
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


#ifndef OLE_INTERNAL
/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);
    
    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);
    
/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif  /* !OLE_NTERNAL */

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_OLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\ole1cls.h ===
/* This file is the master definition of all GUIDs for OLE1 classes.
   
   All such GUIDs are of the form:

       0003xxxx-0000-0000-C000-000000000046

    The last parameter to DEFINE_OLE1GUID is the old 1.0 class name,
    i.e., its key in the registration database.

    Do not remove or change GUIDs.

    Do not add anything to this file except comments and DEFINE_OLE1GUID macros.
*/

#ifndef DEFINE_OLE1GUID
#define DEFINE_OLE1GUID(a,b,c,d,e) DEFINE_OLEGUID (a,b,c,d)
#endif
   
DEFINE_OLE1GUID(CLSID_ExcelWorksheet,   0x00030000, 0, 0, "ExcelWorksheet");
DEFINE_OLE1GUID(CLSID_ExcelChart,       0x00030001, 0, 0, "ExcelChart");
DEFINE_OLE1GUID(CLSID_ExcelMacrosheet,  0x00030002, 0, 0, "ExcelMacrosheet");
DEFINE_OLE1GUID(CLSID_WordDocument,     0x00030003, 0, 0, "WordDocument");
DEFINE_OLE1GUID(CLSID_MSPowerPoint,     0x00030004, 0, 0, "MSPowerPoint");
DEFINE_OLE1GUID(CLSID_MSPowerPointSho,  0x00030005, 0, 0, "MSPowerPointSho");
DEFINE_OLE1GUID(CLSID_MSGraph,          0x00030006, 0, 0, "MSGraph");
DEFINE_OLE1GUID(CLSID_MSDraw,               0x00030007, 0, 0, "MSDraw");
DEFINE_OLE1GUID(CLSID_Note_It,          0x00030008, 0, 0, "Note-It");
DEFINE_OLE1GUID(CLSID_WordArt,          0x00030009, 0, 0, "WordArt");
DEFINE_OLE1GUID(CLSID_PBrush,               0x0003000a, 0, 0, "PBrush");
DEFINE_OLE1GUID(CLSID_Equation,         0x0003000b, 0, 0, "Equation");
DEFINE_OLE1GUID(CLSID_Package,          0x0003000c, 0, 0, "Package");
DEFINE_OLE1GUID(CLSID_SoundRec,         0x0003000d, 0, 0, "SoundRec");
DEFINE_OLE1GUID(CLSID_MPlayer,          0x0003000e, 0, 0, "MPlayer");

/* test apps */
DEFINE_OLE1GUID(CLSID_ServerDemo,       0x0003000f, 0, 0, "ServerDemo");
DEFINE_OLE1GUID(CLSID_Srtest,               0x00030010, 0, 0, "Srtest");
DEFINE_OLE1GUID(CLSID_SrtInv,               0x00030011, 0, 0, "SrtInv");
DEFINE_OLE1GUID(CLSID_OleDemo,          0x00030012, 0, 0, "OleDemo");

/* External ISVs */
// Coromandel / Dorai Swamy / 718-793-7963
DEFINE_OLE1GUID(CLSID_CoromandelIntegra,    0x00030013, 0, 0, "CoromandelIntegra");
DEFINE_OLE1GUID(CLSID_CoromandelObjServer,0x00030014, 0, 0, "CoromandelObjServer");

// 3-d Visions Corp / Peter Hirsch / 310-325-1339
DEFINE_OLE1GUID(CLSID_StanfordGraphics, 0x00030015, 0, 0, "StanfordGraphics");

// Deltapoint / Nigel Hearne / 408-648-4000
DEFINE_OLE1GUID(CLSID_DGraphCHART,          0x00030016, 0, 0, "DGraphCHART");
DEFINE_OLE1GUID(CLSID_DGraphDATA,           0x00030017, 0, 0, "DGraphDATA");

// Corel / Richard V. Woodend / 613-728-8200 x1153
DEFINE_OLE1GUID(CLSID_PhotoPaint,           0x00030018, 0, 0, "PhotoPaint");
DEFINE_OLE1GUID(CLSID_CShow,                    0x00030019, 0, 0, "CShow");
DEFINE_OLE1GUID(CLSID_CorelChart,           0x0003001a, 0, 0, "CorelChart");
DEFINE_OLE1GUID(CLSID_CDraw,                    0x0003001b, 0, 0, "CDraw");

// Inset Systems / Mark Skiba / 203-740-2400
DEFINE_OLE1GUID(CLSID_HJWIN1_0,             0x0003001c, 0, 0, "HJWIN1.0");

// Mark V Systems / Mark McGraw / 818-995-7671
DEFINE_OLE1GUID(CLSID_ObjMakerOLE,          0x0003001d, 0, 0, "ObjMakerOLE");

// IdentiTech / Mike Gilger / 407-951-9503
DEFINE_OLE1GUID(CLSID_FYI,                      0x0003001e, 0, 0, "FYI");
DEFINE_OLE1GUID(CLSID_FYIView,                  0x0003001f, 0, 0, "FYIView");

// Inventa Corporation / Balaji Varadarajan / 408-987-0220
DEFINE_OLE1GUID(CLSID_Stickynote,       0x00030020, 0, 0, "Stickynote");

// ShapeWare Corp. / Lori Pearce / 206-467-6723
DEFINE_OLE1GUID(CLSID_ShapewareVISIO10, 0x00030021, 0, 0, "ShapewareVISIO10");
DEFINE_OLE1GUID(CLSID_ImportServer,     0x00030022, 0, 0, "ImportServer");


// test app SrTest
DEFINE_OLE1GUID(CLSID_SrvrTest,          0x00030023, 0, 0, "SrvrTest");

// Special clsid for when a 1.0 client pastes an embedded object
// that is a link.
// **This CLSID is obsolete. Do not reuse number.
//DEFINE_OLE1GUID(CLSID_10EmbedObj,        0x00030024, 0, 0, "OLE2_Embedded_Link");

// test app ClTest.  Doesn't really work as a server but is in reg db
DEFINE_OLE1GUID(CLSID_ClTest,            0x00030025, 0, 0, "Cltest");

// Microsoft ClipArt Gallery   Sherry Larsen-Holmes
DEFINE_OLE1GUID(CLSID_MS_ClipArt_Gallery,0x00030026, 0, 0, "MS_ClipArt_Gallery");

// Microsoft Project  Cory Reina
DEFINE_OLE1GUID(CLSID_MSProject,         0x00030027, 0, 0, "MSProject");

// Microsoft Works Chart
DEFINE_OLE1GUID(CLSID_MSWorksChart,      0x00030028, 0, 0, "MSWorksChart");

// Microsoft Works Spreadsheet
DEFINE_OLE1GUID(CLSID_MSWorksSpreadsheet,0x00030029, 0, 0, "MSWorksSpreadsheet");

// AFX apps - Dean McCrory
DEFINE_OLE1GUID(CLSID_MinSvr,            0x0003002A, 0, 0, "MinSvr");
DEFINE_OLE1GUID(CLSID_HierarchyList,     0x0003002B, 0, 0, "HierarchyList");
DEFINE_OLE1GUID(CLSID_BibRef,            0x0003002C, 0, 0, "BibRef");
DEFINE_OLE1GUID(CLSID_MinSvrMI,          0x0003002D, 0, 0, "MinSvrMI");
DEFINE_OLE1GUID(CLSID_TestServ,          0x0003002E, 0, 0, "TestServ");

// Ami Pro
DEFINE_OLE1GUID(CLSID_AmiProDocument,    0x0003002F, 0, 0, "AmiProDocument");

// WordPerfect Presentations For Windows
DEFINE_OLE1GUID(CLSID_WPGraphics,       0x00030030, 0, 0, "WPGraphics");
DEFINE_OLE1GUID(CLSID_WPCharts,         0x00030031, 0, 0, "WPCharts");


// MicroGrafx Charisma
DEFINE_OLE1GUID(CLSID_Charisma,         0x00030032, 0, 0, "Charisma");
DEFINE_OLE1GUID(CLSID_Charisma_30,      0x00030033, 0, 0, "Charisma_30");
DEFINE_OLE1GUID(CLSID_CharPres_30,      0x00030034, 0, 0, "CharPres_30");

// MicroGrafx Draw
DEFINE_OLE1GUID(CLSID_Draw,             0x00030035, 0, 0, "Draw");

// MicroGrafx Designer
DEFINE_OLE1GUID(CLSID_Designer_40,      0x00030036, 0, 0, "Designer_40");


#undef DEFINE_OLE1GUID

/* as we discover OLE 1 servers we will add them to the end of this list;
   there is room for 64K of them!
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\olenls.h ===
/***
*olenls.h - National language support functions.
*
*  Copyright (C) 1992, Microsoft Corporation.  All Rights Reserved.
*  Information Contained Herein Is Proprietary and Confidential.
*
*Purpose:
*  This describes the NLSAPI functions for Win16.  This is a subset
*  of Win32 NLSAPI, and is a non-Unicode version.
*
*Implementation Notes:
*  This files is largely ported from the Win32 header winnls.h.
*
*****************************************************************************/

#ifndef _OLENLS_
#define _OLENLS_

#ifndef NONLS

#ifdef __cplusplus
extern "C" {
#endif // __cpluscplus

/***************************************************************************\
* Constants
*
* Define all constants for the NLS component here.
\***************************************************************************/

/*
 *  Character Type Flags.
 */
#define CT_CTYPE1            0x00000001     /* ctype 1 information */
#define CT_CTYPE2            0x00000002     /* ctype 2 information */
#define CT_CTYPE3            0x00000004     /* ctype 3 information */

/*
 *  CType 1 Flag Bits.
 */
#define C1_UPPER             0x0001         /* upper case */
#define C1_LOWER             0x0002         /* lower case */
#define C1_DIGIT             0x0004         /* decimal digits */
#define C1_SPACE             0x0008         /* spacing characters */
#define C1_PUNCT             0x0010         /* punctuation characters */
#define C1_CNTRL             0x0020         /* control characters */
#define C1_BLANK             0x0040         /* blank characters */
#define C1_XDIGIT            0x0080         /* other digits */
#define C1_ALPHA             0x0100         /* any letter */

/*
 *  CType 2 Flag Bits.
 */
#define C2_LEFTTORIGHT       0x1            /* left to right */
#define C2_RIGHTTOLEFT       0x2            /* right to left */

#define C2_EUROPENUMBER      0x3            /* European number, digit */
#define C2_EUROPESEPARATOR   0x4            /* European numeric separator */
#define C2_EUROPETERMINATOR  0x5            /* European numeric terminator */
#define C2_ARABICNUMBER      0x6            /* Arabic number */
#define C2_COMMONSEPARATOR   0x7            /* common numeric separator */

#define C2_BLOCKSEPARATOR    0x8            /* block separator */
#define C2_SEGMENTSEPARATOR  0x9            /* segment separator */
#define C2_WHITESPACE        0xA            /* white space */
#define C2_OTHERNEUTRAL      0xB            /* other neutrals */

#define C2_NOTAPPLICABLE     0x0            /* no implicit directionality */

/*
 *  CType 3 Flag Bits.
 */
#define C3_NONSPACING        0x0001         /* nonspacing character */
#define C3_DIACRITIC         0x0002         /* diacritic mark */
#define C3_VOWELMARK         0x0004         /* vowel mark */
#define C3_SYMBOL            0x0008         /* symbols */

#define C3_NOTAPPLICABLE     0x0            /* ctype 3 is not applicable */


/*
 *  String Flags.
 */
#define NORM_IGNORECASE      0x00000001     /* ignore case */
#define NORM_IGNORENONSPACE  0x00000002     /* ignore nonspacing chars */
#define NORM_IGNORESYMBOLS   0x00000004     /* ignore symbols */


/*
 *  Locale Dependent Mapping Flags.
 */
#define LCMAP_LOWERCASE      0x00000100     /* lower case letters */
#define LCMAP_UPPERCASE      0x00000200     /* upper case letters */
#define LCMAP_SORTKEY        0x00000400     /* WC sort key (normalize) */



/*
 *  Language IDs.
 *
 *  The following two combinations of primary language ID and
 *  sublanguage ID have special semantics: 
 *
 *    Primary Language ID   Sublanguage ID      Result
 *    -------------------   ---------------     ------------------------
 *    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
 *    LANG_NEUTRAL          SUBLANG_DEFAULT     Process default language
 */

/*
 *  Primary language IDs.
 */
#define LANG_NEUTRAL                     0x00

#define LANG_ALBANIAN                    0x1c
#define LANG_ARABIC                      0x01
#define LANG_BAHASA                      0x21
#define LANG_BULGARIAN                   0x02
#define LANG_CATALAN                     0x03
#define LANG_CHINESE                     0x04
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_HEBREW                      0x0d
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KOREAN                      0x12
#define LANG_NORWEGIAN                   0x14
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_RHAETO_ROMAN                0x17
#define LANG_ROMANIAN                    0x18
#define LANG_RUSSIAN                     0x19
#define LANG_SERBO_CROATIAN              0x1a
#define LANG_SLOVAK                      0x1b
#define LANG_SPANISH                     0x0a
#define LANG_SWEDISH                     0x1d
#define LANG_THAI                        0x1e
#define LANG_TURKISH                     0x1f
#define LANG_URDU                        0x20

/*
 *  Sublanguage IDs.
 *
 *  The name immediately following SUBLANG_ dictates which primary
 *  language ID that sublanguage ID can be combined with to form a
 *  valid language ID.
 */
#define SUBLANG_NEUTRAL                  0x00    /* language neutral */
#define SUBLANG_DEFAULT                  0x01    /* user default */
#define SUBLANG_SYS_DEFAULT              0x02    /* system default */

#define SUBLANG_CHINESE_SIMPLIFIED       0x02    /* Chinese (Simplified) */
#define SUBLANG_CHINESE_TRADITIONAL      0x01    /* Chinese (Traditional) */ 
#define SUBLANG_DUTCH                    0x01    /* Dutch */
#define SUBLANG_DUTCH_BELGIAN            0x02    /* Dutch (Belgian) */
#define SUBLANG_ENGLISH_US               0x01    /* English (USA) */
#define SUBLANG_ENGLISH_UK               0x02    /* English (UK) */
#define SUBLANG_ENGLISH_AUS              0x03    /* English (Australian) */
#define SUBLANG_ENGLISH_CAN              0x04    /* English (Canadian) */
#define SUBLANG_ENGLISH_NZ               0x05    /* English (New Zealand) */
#define SUBLANG_FRENCH                   0x01    /* French */
#define SUBLANG_FRENCH_BELGIAN           0x02    /* French (Belgian) */
#define SUBLANG_FRENCH_CANADIAN          0x03    /* French (Canadian) */
#define SUBLANG_FRENCH_SWISS             0x04    /* French (Swiss) */
#define SUBLANG_GERMAN                   0x01    /* German */
#define SUBLANG_GERMAN_SWISS             0x02    /* German (Swiss) */
#define SUBLANG_GERMAN_AUSTRIAN          0x03    /* German (Austrian) */
#define SUBLANG_ITALIAN                  0x01    /* Italian */
#define SUBLANG_ITALIAN_SWISS            0x02    /* Italian (Swiss) */
#define SUBLANG_NORWEGIAN_BOKMAL         0x01    /* Norwegian (Bokmal) */
#define SUBLANG_NORWEGIAN_NYNORSK        0x02    /* Norwegian (Nynorsk) */
#define SUBLANG_PORTUGUESE               0x02    /* Portuguese */
#define SUBLANG_PORTUGUESE_BRAZILIAN     0x01    /* Portuguese (Brazilian) */
#define SUBLANG_SERBO_CROATIAN_CYRILLIC  0x02    /* Serbo-Croatian (Cyrillic) */
#define SUBLANG_SERBO_CROATIAN_LATIN     0x01    /* Croato-Serbian (Latin) */
#define SUBLANG_SPANISH                  0x01    /* Spanish */
#define SUBLANG_SPANISH_MEXICAN          0x02    /* Spanish (Mexican) */
#define SUBLANG_SPANISH_MODERN           0x03    /* Spanish (Modern) */


/*
 *  Country Codes.
 */
#define CTRY_DEFAULT                     0

#define CTRY_AUSTRALIA                   61      /* Australia */
#define CTRY_AUSTRIA                     43      /* Austria */
#define CTRY_BELGIUM                     32      /* Belgium */
#define CTRY_BRAZIL                      55      /* Brazil */
#define CTRY_CANADA                      2       /* Canada */
#define CTRY_DENMARK                     45      /* Denmark */
#define CTRY_FINLAND                     358     /* Finland */
#define CTRY_FRANCE                      33      /* France */
#define CTRY_GERMANY                     49      /* Germany */
#define CTRY_ICELAND                     354     /* Iceland */
#define CTRY_IRELAND                     353     /* Ireland */
#define CTRY_ITALY                       39      /* Italy */
#define CTRY_JAPAN                       81      /* Japan */
#define CTRY_MEXICO                      52      /* Mexico */
#define CTRY_NETHERLANDS                 31      /* Netherlands */
#define CTRY_NEW_ZEALAND                 64      /* New Zealand */
#define CTRY_NORWAY                      47      /* Norway */
#define CTRY_PORTUGAL                    351     /* Portugal */
#define CTRY_PRCHINA                     86      /* PR China */
#define CTRY_KOREA                       82      /* Korea */
#define CTRY_SPAIN                       34      /* Spain */
#define CTRY_SWEDEN                      46      /* Sweden */
#define CTRY_SWITZERLAND                 41      /* Switzerland */
#define CTRY_TAIWAN                      886     /* Taiwan */
#define CTRY_UNITED_KINGDOM              44      /* United Kingdom */
#define CTRY_UNITED_STATES               1       /* United States */


/*
 *  Locale Types.
 *
 *  These types are used for the GetLocaleInfoA NLS API routine.
 */
#define LOCALE_ILANGUAGE            0x0001    /* language id */
#define LOCALE_SLANGUAGE            0x0002    /* localized name of language */
#define LOCALE_SENGLANGUAGE         0x1001    /* English name of language */
#define LOCALE_SABBREVLANGNAME      0x0003    /* abbreviated language name */
#define LOCALE_SNATIVELANGNAME      0x0004    /* native name of language */
#define LOCALE_ICOUNTRY             0x0005    /* country code */
#define LOCALE_SCOUNTRY             0x0006    /* localized name of country */  
#define LOCALE_SENGCOUNTRY          0x1002    /* English name of country */  
#define LOCALE_SABBREVCTRYNAME      0x0007    /* abbreviated country name */
#define LOCALE_SNATIVECTRYNAME      0x0008    /* native name of country */  
#define LOCALE_IDEFAULTLANGUAGE     0x0009    /* default language id */
#define LOCALE_IDEFAULTCOUNTRY      0x000A    /* default country code */
#define LOCALE_IDEFAULTCODEPAGE     0x000B    /* default code page */
                                            
#define LOCALE_SLIST                0x000C    /* list item separator */
#define LOCALE_IMEASURE             0x000D    /* 0 = metric, 1 = US */
                                            
#define LOCALE_SDECIMAL             0x000E    /* decimal separator */
#define LOCALE_STHOUSAND            0x000F    /* thousand separator */
#define LOCALE_SGROUPING            0x0010    /* digit grouping */
#define LOCALE_IDIGITS              0x0011    /* number of fractional digits */
#define LOCALE_ILZERO               0x0012    /* leading zeros for decimal */
#define LOCALE_SNATIVEDIGITS        0x0013    /* native ascii 0-9 */
                                            
#define LOCALE_SCURRENCY            0x0014    /* local monetary symbol */
#define LOCALE_SINTLSYMBOL          0x0015    /* intl monetary symbol */
#define LOCALE_SMONDECIMALSEP       0x0016    /* monetary decimal separator */
#define LOCALE_SMONTHOUSANDSEP      0x0017    /* monetary thousand separator */
#define LOCALE_SMONGROUPING         0x0018    /* monetary grouping */
#define LOCALE_ICURRDIGITS          0x0019    /* # local monetary digits */
#define LOCALE_IINTLCURRDIGITS      0x001A    /* # intl monetary digits */
#define LOCALE_ICURRENCY            0x001B    /* positive currency mode */
#define LOCALE_INEGCURR             0x001C    /* negative currency mode */
                                            
#define LOCALE_SDATE                0x001D    /* date separator */
#define LOCALE_STIME                0x001E    /* time separator */
#define LOCALE_SSHORTDATE           0x001F    /* short date-time separator */
#define LOCALE_SLONGDATE            0x0020    /* long date-time separator */
#define LOCALE_IDATE                0x0021    /* short date format ordering */
#define LOCALE_ILDATE               0x0022    /* long date format ordering */
#define LOCALE_ITIME                0x0023    /* time format specifier */
#define LOCALE_ICENTURY             0x0024    /* century format specifier */
#define LOCALE_ITLZERO              0x0025    /* leading zeros in time field */
#define LOCALE_IDAYLZERO            0x0026    /* leading zeros in day field */
#define LOCALE_IMONLZERO            0x0027    /* leading zeros in month field */
#define LOCALE_S1159                0x0028    /* AM designator */
#define LOCALE_S2359                0x0029    /* PM designator */
                                            
#define LOCALE_SDAYNAME1            0x002A    /* long name for Monday */
#define LOCALE_SDAYNAME2            0x002B    /* long name for Tuesday */
#define LOCALE_SDAYNAME3            0x002C    /* long name for Wednesday */
#define LOCALE_SDAYNAME4            0x002D    /* long name for Thursday */
#define LOCALE_SDAYNAME5            0x002E    /* long name for Friday */
#define LOCALE_SDAYNAME6            0x002F    /* long name for Saturday */
#define LOCALE_SDAYNAME7            0x0030    /* long name for Sunday */
#define LOCALE_SABBREVDAYNAME1      0x0031    /* abbreviated name for Monday */   
#define LOCALE_SABBREVDAYNAME2      0x0032    /* abbreviated name for Tuesday */  
#define LOCALE_SABBREVDAYNAME3      0x0033    /* abbreviated name for Wednesday */
#define LOCALE_SABBREVDAYNAME4      0x0034    /* abbreviated name for Thursday */ 
#define LOCALE_SABBREVDAYNAME5      0x0035    /* abbreviated name for Friday */   
#define LOCALE_SABBREVDAYNAME6      0x0036    /* abbreviated name for Saturday */ 
#define LOCALE_SABBREVDAYNAME7      0x0037    /* abbreviated name for Sunday */   
#define LOCALE_SMONTHNAME1          0x0038    /* long name for January */
#define LOCALE_SMONTHNAME2          0x0039    /* long name for February */
#define LOCALE_SMONTHNAME3          0x003A    /* long name for March */
#define LOCALE_SMONTHNAME4          0x003B    /* long name for April */
#define LOCALE_SMONTHNAME5          0x003C    /* long name for May */
#define LOCALE_SMONTHNAME6          0x003D    /* long name for June */
#define LOCALE_SMONTHNAME7          0x003E    /* long name for July */
#define LOCALE_SMONTHNAME8          0x003F    /* long name for August */
#define LOCALE_SMONTHNAME9          0x0040    /* long name for September */
#define LOCALE_SMONTHNAME10         0x0041    /* long name for October */
#define LOCALE_SMONTHNAME11         0x0042    /* long name for November */
#define LOCALE_SMONTHNAME12         0x0043    /* long name for December */
#define LOCALE_SABBREVMONTHNAME1    0x0044    /* abbreviated name for January */
#define LOCALE_SABBREVMONTHNAME2    0x0045    /* abbreviated name for February */
#define LOCALE_SABBREVMONTHNAME3    0x0046    /* abbreviated name for March */
#define LOCALE_SABBREVMONTHNAME4    0x0047    /* abbreviated name for April */
#define LOCALE_SABBREVMONTHNAME5    0x0048    /* abbreviated name for May */
#define LOCALE_SABBREVMONTHNAME6    0x0049    /* abbreviated name for June */
#define LOCALE_SABBREVMONTHNAME7    0x004A    /* abbreviated name for July */
#define LOCALE_SABBREVMONTHNAME8    0x004B    /* abbreviated name for August */
#define LOCALE_SABBREVMONTHNAME9    0x004C    /* abbreviated name for September */
#define LOCALE_SABBREVMONTHNAME10   0x004D    /* abbreviated name for October */
#define LOCALE_SABBREVMONTHNAME11   0x004E    /* abbreviated name for November */
#define LOCALE_SABBREVMONTHNAME12   0x004F    /* abbreviated name for December */
                                            
#define LOCALE_SPOSITIVESIGN        0x0050    /* positive sign */
#define LOCALE_SNEGATIVESIGN        0x0051    /* negative sign */
#define LOCALE_IPOSSIGNPOSN         0x0052    /* positive sign position */
#define LOCALE_INEGSIGNPOSN         0x0053    /* negative sign position */
#define LOCALE_IPOSSYMPRECEDES      0x0054    /* mon sym precedes pos amt */
#define LOCALE_IPOSSEPBYSPACE       0x0055    /* mon sym sep by space from pos */ 
#define LOCALE_INEGSYMPRECEDES      0x0056    /* mon sym precedes neg amt */
#define LOCALE_INEGSEPBYSPACE       0x0057    /* mon sym sep by space from neg */
        
#define LOCALE_NOUSEROVERRIDE   0x80000000    /* OR in to avoid user override */
        
/***************************************************************************\
* Typedefs
*
* Define all types for the NLS component here.
\***************************************************************************/

/*
 *  IDs.
 */
typedef DWORD   LCID;                       /* locale ID */
typedef WORD    LANGID;                     /* language ID */
typedef DWORD   LCTYPE;                     /* locale type constant */

#define _LCID_DEFINED



/***************************************************************************\
* Macros
*
* Define all macros for the NLS component here.
\***************************************************************************/

/*
 *  A language ID is a 16 bit value which is the combination of a
 *  primary language ID and a secondary language ID.  The bits are
 *  allocated as follows:
 *
 *       +-----------------------+-------------------------+
 *       |      Sublanguage ID   |   Primary Language ID   |
 *       +-----------------------+-------------------------+
 *        15                   10 9                       0   bit
 *
 *
 *  Language ID creation/extraction macros:
 *
 *    MAKELANGID    - construct language id from primary language id and
 *                    sublanguage id.
 *    PRIMARYLANGID - extract primary language id from a language id.
 *    SUBLANGID     - extract sublanguage id from a language id.
 */
#define MAKELANGID(p, s)       ((((WORD)(s)) << 10) | (WORD)(p))
#define PRIMARYLANGID(lgid)    ((WORD)(lgid) & 0x3ff)
#define SUBLANGID(lgid)        ((WORD)(lgid) >> 10)


/*
 *  A locale ID is a 32 bit value which is the combination of a
 *  language ID and a reserved area.  The bits are allocated as follows:
 *
 *       +-----------------------+-------------------------+
 *       |       Reserved        |      Language ID        |
 *       +-----------------------+-------------------------+
 *        31                   16 15                      0   bit
 *
 *
 *  Locale ID creation macro:
 *
 *    MAKELCID - construct locale id from a language id.
 */
#define MAKELCID(lgid)  ((DWORD)(((WORD)(lgid)) | (((DWORD)((WORD)(0))) << 16)))


/*
 *  Get the language id from a locale id.
 */
#define LANGIDFROMLCID(lcid)   ((WORD)(lcid))


/*
 *  Default System and User IDs for language and locale.
 */
#define LANG_SYSTEM_DEFAULT    (MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT))
#define LANG_USER_DEFAULT      (MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT))

#define LOCALE_SYSTEM_DEFAULT  (MAKELCID(LANG_SYSTEM_DEFAULT))
#define LOCALE_USER_DEFAULT    (MAKELCID(LANG_USER_DEFAULT))



/***************************************************************************\
* Function Prototypes
*
* Only prototypes for the NLS APIs should go here.
\***************************************************************************/


int    WINAPI  CompareStringA(LCID, DWORD, LPCSTR, int, LPCSTR, int);
int    WINAPI  LCMapStringA(LCID, DWORD, LPCSTR, int, LPSTR, int);
int    WINAPI  GetLocaleInfoA(LCID, LCTYPE, LPSTR, int);
BOOL   WINAPI  GetStringTypeA(LCID, DWORD, LPCSTR, int, LPWORD);

LANGID WINAPI  GetSystemDefaultLangID(void);
LANGID WINAPI  GetUserDefaultLangID(void);
LCID   WINAPI  GetSystemDefaultLCID(void);
LCID   WINAPI  GetUserDefaultLCID(void);

#ifdef __cplusplus
}
#endif // __cpluscplus


#endif   // NONLS

#endif   // _OLENLS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\ostream.h ===
/***
*ostream.h - definitions/declarations for the ostream class
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the ostream class.
*   [AT&T C++]
*
****/

#ifndef _INC_OSTREAM
#define _INC_OSTREAM

#include <ios.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef long streamoff, streampos;

class ostream : virtual public ios {

public:
    ostream(streambuf*);
    virtual ~ostream();

    ostream& flush();
    int  opfx();
    void osfx();

inline  ostream& operator<<(ostream& (*f)(ostream&));
inline  ostream& operator<<(ios& (*f)(ios&));
    ostream& operator<<(const char _HFAR_ *);
inline  ostream& operator<<(const unsigned char _HFAR_ *);
inline  ostream& operator<<(const signed char _HFAR_ *);
inline  ostream& operator<<(char);
    ostream& operator<<(unsigned char);
inline  ostream& operator<<(signed char);
    ostream& operator<<(short);
    ostream& operator<<(unsigned short);
    ostream& operator<<(int);
    ostream& operator<<(unsigned int);
    ostream& operator<<(long);
    ostream& operator<<(unsigned long);
inline  ostream& operator<<(float);
    ostream& operator<<(double);
    ostream& operator<<(long double);
    ostream& operator<<(const void _HFAR_ *);
    ostream& operator<<(streambuf*);
inline  ostream& put(char);
    ostream& put(unsigned char);
inline  ostream& put(signed char);
    ostream& write(const char _HFAR_ *,int);
inline  ostream& write(const unsigned char _HFAR_ *,int);
inline  ostream& write(const signed char _HFAR_ *,int);
    ostream& seekp(streampos);
    ostream& seekp(streamoff,ios::seek_dir);
    streampos tellp();

protected:
    ostream();
    ostream(const ostream&);    // treat as private
    ostream& operator=(streambuf*); // treat as private
    ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
    int do_opfx(int);       // not used
    void do_osfx();         // not used

private:
    ostream(ios&);
    ostream& writepad(const char _HFAR_ *, const char _HFAR_ *);
    int x_floatused;
};

inline ostream& ostream::operator<<(ostream& (*f)(ostream&)) { (*f)(*this); return *this; }
inline ostream& ostream::operator<<(ios& (*f)(ios& )) { (*f)(*this); return *this; }

inline  ostream& ostream::operator<<(char c) { return operator<<((unsigned char) c); }
inline  ostream& ostream::operator<<(signed char c) { return operator<<((unsigned char) c); }

inline  ostream& ostream::operator<<(const unsigned char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
inline  ostream& ostream::operator<<(const signed char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }

inline  ostream& ostream::operator<<(float f) { x_floatused = 1; return operator<<((double) f); }

inline  ostream& ostream::put(char c) { return put((unsigned char) c); }
inline  ostream& ostream::put(signed char c) { return put((unsigned char) c); }

inline  ostream& ostream::write(const unsigned char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
inline  ostream& ostream::write(const signed char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }


class ostream_withassign : public ostream {
    public:
        ostream_withassign();
        ostream_withassign(streambuf* _is);
        ~ostream_withassign();
    ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
    ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
};

#ifndef _WINDLL
extern ostream_withassign cout;
extern ostream_withassign cerr;
extern ostream_withassign clog;
#endif 

inline ostream& flush(ostream& _outs) { return _outs.flush(); }
inline ostream& endl(ostream& _outs) { return _outs << '\n' << flush; }
inline ostream& ends(ostream& _outs) { return _outs << char('\0'); }

ios&        dec(ios&);
ios&        hex(ios&);
ios&        oct(ios&);

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\oleguid.h ===
/* this file is the master definition of all public GUIDs specific to OLE 
   and is included in ole2.h.
   
   NOTE: The second least significant byte of all of these GUIDs is 1.
*/
   

DEFINE_OLEGUID(IID_IEnumUnknown,            0x00000100, 0, 0);
DEFINE_OLEGUID(IID_IEnumString,             0x00000101, 0, 0);
DEFINE_OLEGUID(IID_IEnumMoniker,            0x00000102, 0, 0);
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
DEFINE_OLEGUID(IID_IEnumOLEVERB,            0x00000104, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATDATA,           0x00000105, 0, 0);

DEFINE_OLEGUID(IID_IEnumGeneric,            0x00000106, 0, 0);
DEFINE_OLEGUID(IID_IEnumHolder,             0x00000107, 0, 0);
DEFINE_OLEGUID(IID_IEnumCallback,           0x00000108, 0, 0);

DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
DEFINE_OLEGUID(IID_IPersistStorage,         0x0000010a, 0, 0);
DEFINE_OLEGUID(IID_IPersistFile,            0x0000010b, 0, 0);
DEFINE_OLEGUID(IID_IPersist,                0x0000010c, 0, 0);

DEFINE_OLEGUID(IID_IViewObject,             0x0000010d, 0, 0);
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
DEFINE_OLEGUID(IID_IAdviseSink,             0x0000010f, 0, 0);
DEFINE_OLEGUID(IID_IDataAdviseHolder,       0x00000110, 0, 0);
DEFINE_OLEGUID(IID_IOleAdviseHolder,        0x00000111, 0, 0);

DEFINE_OLEGUID(IID_IOleObject,              0x00000112, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObject,       0x00000113, 0, 0);
DEFINE_OLEGUID(IID_IOleWindow,              0x00000114, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceUIWindow,     0x00000115, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceFrame,        0x00000116, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceActiveObject, 0x00000117, 0, 0);

DEFINE_OLEGUID(IID_IOleClientSite,          0x00000118, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSite,         0x00000119, 0, 0);

DEFINE_OLEGUID(IID_IParseDisplayName,       0x0000011a, 0, 0);
DEFINE_OLEGUID(IID_IOleContainer,           0x0000011b, 0, 0);
DEFINE_OLEGUID(IID_IOleItemContainer,       0x0000011c, 0, 0);

DEFINE_OLEGUID(IID_IOleLink,                0x0000011d, 0, 0);
DEFINE_OLEGUID(IID_IOleCache,               0x0000011e, 0, 0);
DEFINE_OLEGUID(IID_IOleManager,             0x0000011f, 0, 0);
DEFINE_OLEGUID(IID_IOlePresObj,             0x00000120, 0, 0);

DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);

DEFINE_OLEGUID(IID_IDebug,                  0x00000123, 0, 0);
DEFINE_OLEGUID(IID_IDebugStream,            0x00000124, 0, 0);

DEFINE_OLEGUID(IID_IAdviseSink2,            0x00000125, 0, 0);


/* NOTE: LSB values 0x26 through 0xff are reserved */


/* GUIDs defined in OLE's private range */
DEFINE_OLEGUID(CLSID_StaticMetafile,        0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_StaticDib,             0x00000316, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\ole2.h ===
/*****************************************************************************\
*                                                                             *
* ole2.h  - main ole2 header; includes all subcomponents		      *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#if !defined( _OLE2_H_ )
#define _OLE2_H_

#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif  /* RC_INVOKED */

#include <string.h>

/****** Standard Object Definitions *****************************************/

#include <compobj.h>


// *************** FACILITY_ITF scodes common to all interfaces ************
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an interface returns a FACILITY_ITF
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//

// error codes

#define OLE_E_OLEVERB               (OLE_E_FIRST)
// invalid OLEVERB structure

#define OLE_E_ADVF                  (OLE_E_FIRST+1)
// invalid advise flags

#define OLE_E_ENUM_NOMORE           (OLE_E_FIRST+2)
// you can't enuemrate any more, because the associated data is missing

#define OLE_E_ADVISENOTSUPPORTED    (OLE_E_FIRST+3)
// this implementation doesn't take advises

#define OLE_E_NOCONNECTION          (OLE_E_FIRST+4)
// there is no connection for this connection id

#define OLE_E_NOTRUNNING            (OLE_E_FIRST+5)
// need run the object to perform this operation

#define OLE_E_NOCACHE               (OLE_E_FIRST+6)
// there is no cache to operate on

#define OLE_E_BLANK                 (OLE_E_FIRST+7)
// Uninitialized object

#define OLE_E_CLASSDIFF             (OLE_E_FIRST+8)
// linked object's source class has changed

#define OLE_E_CANT_GETMONIKER       (OLE_E_FIRST+9)
// not able to get the moniker of the object

#define OLE_E_CANT_BINDTOSOURCE     (OLE_E_FIRST+10)
// not able to bind to the source

#define OLE_E_STATIC                (OLE_E_FIRST+11)
// object is static, operation not allowed

#define OLE_E_PROMPTSAVECANCELLED   (OLE_E_FIRST+12)
// user cancelled out of save dialog

#define OLE_E_INVALIDRECT           (OLE_E_FIRST+13)
// invalid rectangle

#define OLE_E_WRONGCOMPOBJ          (OLE_E_FIRST+14)
// compobj.dll is too old for the ole2.dll initialized

#define OLE_E_INVALIDHWND           (OLE_E_FIRST+15)
// invalid window handle

#define OLE_E_NOT_INPLACEACTIVE     (OLE_E_FIRST+16)
// object is not in any of the inplace active states

#define DVGEN_E_FIRST               (OLE_E_FIRST+100)

#define DV_E_FORMATETC              (DVGEN_E_FIRST)
// invalid FORMATETC structure

#define DV_E_DVTARGETDEVICE         (DVGEN_E_FIRST+1)
// invalid DVTARGETDEVICE structure

#define DV_E_STGMEDIUM              (DVGEN_E_FIRST+2)
// invalid STDGMEDIUM structure

#define DV_E_STATDATA               (DVGEN_E_FIRST+3)
// invalid STATDATA structure

#define DV_E_LINDEX                 (DVGEN_E_FIRST+4)
// invalid lindex

#define DV_E_TYMED                  (DVGEN_E_FIRST+5)
// invalid tymed

#define DV_E_CLIPFORMAT             (DVGEN_E_FIRST+6)
// invalid clipboard format

#define DV_E_DVASPECT               (DVGEN_E_FIRST+7)
// invalid aspect(s)

#define DV_E_DVTARGETDEVICE_SIZE    (DVGEN_E_FIRST+8)
// tdSize paramter of the DVTARGETDEVICE structure is invalid

#define DV_E_NOIVIEWOBJECT          (DVGEN_E_FIRST+9)
// object doesn't support IViewObject interface


// Success codes

#define OLE_S_USEREG                (OLE_S_FIRST)
// use the reg database to provide the requested info

#define OLE_S_STATIC                (OLE_S_FIRST+1)
// success, but static

#define OLE_S_MAC_CLIPFORMAT        (OLE_S_FIRST+2)
// macintosh clipboard format

//*************************** Interface or API specific scodes *************

// Errors for OleConvertOLESTREAMToIStorage and OleConvertIStorageToOLESTREAM

// OLESTREAM Get method failed
#define CONVERT10_E_OLESTREAM_GET       (CONVERT10_E_FIRST + 0)

// OLESTREAM Put method failed
#define CONVERT10_E_OLESTREAM_PUT       (CONVERT10_E_FIRST + 1)

// Contents of the OLESTREAM not in correct format
#define CONVERT10_E_OLESTREAM_FMT       (CONVERT10_E_FIRST + 2)

// There was in an error in a Windows GDI call while converting the bitmap
// to a DIB.
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB (CONVERT10_E_FIRST + 3)

// Contents of the IStorage not in correct format
#define CONVERT10_E_STG_FMT             (CONVERT10_E_FIRST + 4)

// Contents of IStorage is missing one of the standard streams ("\1CompObj",
// "\1Ole", "\2OlePres000").  This may be the storage for a DLL object, or a
// class that does not use the def handler.
#define CONVERT10_E_STG_NO_STD_STREAM   (CONVERT10_E_FIRST + 5)

// There was in an error in a Windows GDI call while converting the DIB
// to a bitmap.
#define CONVERT10_E_STG_DIB_TO_BITMAP   (CONVERT10_E_FIRST + 6)


// Returned by either API, this scode indicates that the original object
//  had no presentation, therefore the converted object does not either.
#define CONVERT10_S_NO_PRESENTATION     (CONVERT10_S_FIRST + 0)


// Errors for Clipboard functions

// OpenClipboard Failed
#define CLIPBRD_E_CANT_OPEN     (CLIPBRD_E_FIRST + 0)

// EmptyClipboard Failed
#define CLIPBRD_E_CANT_EMPTY        (CLIPBRD_E_FIRST + 1)

// SetClipboard Failed
#define CLIPBRD_E_CANT_SET          (CLIPBRD_E_FIRST + 2)

// Data on clipboard is invalid
#define CLIPBRD_E_BAD_DATA          (CLIPBRD_E_FIRST + 3)

// CloseClipboard Failed
#define CLIPBRD_E_CANT_CLOSE        (CLIPBRD_E_FIRST + 4)


/****** OLE value types *****************************************************/

/* rendering options */
typedef enum tagOLERENDER
{
    OLERENDER_NONE   = 0,
    OLERENDER_DRAW   = 1,
    OLERENDER_FORMAT = 2,
    OLERENDER_ASIS   = 3
} OLERENDER;
typedef  OLERENDER FAR* LPOLERENDER;

// OLE verb; returned by IEnumOLEVERB
typedef struct FARSTRUCT tagOLEVERB
{
    LONG    lVerb;
    LPSTR   lpszVerbName;
    DWORD   fuFlags;
    DWORD grfAttribs;
} OLEVERB, FAR* LPOLEVERB;


// Bitwise verb attributes used in OLEVERB.grfAttribs
typedef enum tagOLEVERBATTRIB // bitwise
{
    OLEVERBATTRIB_NEVERDIRTIES = 1,
    OLEVERBATTRIB_ONCONTAINERMENU = 2
} OLEVERBATTRIB;


// IOleObject::GetUserType optons; determines which form of the string to use
typedef enum tagUSERCLASSTYPE
{
    USERCLASSTYPE_FULL = 1,
    USERCLASSTYPE_SHORT= 2,
    USERCLASSTYPE_APPNAME= 3,
} USERCLASSTYPE;


// bits returned from IOleObject::GetMistStatus
typedef enum tagOLEMISC // bitwise
{
    OLEMISC_RECOMPOSEONRESIZE   = 1,
    OLEMISC_ONLYICONIC          = 2,
    OLEMISC_INSERTNOTREPLACE    = 4,
    OLEMISC_STATIC              = 8,
    OLEMISC_CANTLINKINSIDE      = 16,
    OLEMISC_CANLINKBYOLE1       = 32,
    OLEMISC_ISLINKOBJECT        = 64,
    OLEMISC_INSIDEOUT           = 128,
    OLEMISC_ACTIVATEWHENVISIBLE = 256
} OLEMISC;


// IOleObject::Close options
typedef enum tagOLECLOSE
{
    OLECLOSE_SAVEIFDIRTY = 0,
    OLECLOSE_NOSAVE      = 1,
    OLECLOSE_PROMPTSAVE  = 2
} OLECLOSE;


// IOleObject::GetMoniker and IOleClientSite::GetMoniker options; determines
// if and how monikers should be assigned.
typedef enum tagOLEGETMONIKER
{
    OLEGETMONIKER_ONLYIFTHERE=1,
    OLEGETMONIKER_FORCEASSIGN=2,
    OLEGETMONIKER_UNASSIGN=3,
    OLEGETMONIKER_TEMPFORUSER=4
} OLEGETMONIKER;


// IOleObject::GetMoniker, IOleObject::SetMoniker and
// IOleClientSite::GetMoniker options; determines which moniker to use
typedef enum tagOLEWHICHMK
{
    OLEWHICHMK_CONTAINER=1,
    OLEWHICHMK_OBJREL=2,
    OLEWHICHMK_OBJFULL=3
} OLEWHICHMK;


#ifdef WIN32
#define LPSIZEL PSIZEL
#elif (WINVER < 0x0400)
typedef struct FARSTRUCT tagSIZEL
{
    long cx;
    long cy;
} SIZEL, FAR* LPSIZEL;
#endif


#ifdef WIN32
#define LPRECTL PRECTL
#elif (WINVER < 0x0400)
typedef struct FARSTRUCT tagRECTL
{
    long    left;
    long    top;
    long    right;
    long    bottom;
} RECTL, FAR* LPRECTL;

typedef struct FARSTRUCT tagPOINTL {
    LONG x;
    LONG y;
} POINTL;

#endif


#ifndef LPCRECT
typedef const RECT FAR* LPCRECT;
#endif

#ifndef LPCRECTL
typedef const RECTL FAR* LPCRECTL;
#endif


/***** OLE 1.0 OLESTREAM declarations *************************************/

typedef struct _OLESTREAM FAR*  LPOLESTREAM;

typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, const void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL lpstbl;
} OLESTREAM;


/****** Clipboard Data structures *****************************************/

typedef struct tagOBJECTDESCRIPTOR
{
   ULONG    cbSize;              // Size of structure in bytes
   CLSID    clsid;               // CLSID of data being transferred
   DWORD    dwDrawAspect;        // Display aspect of the object
                                 //     normally DVASPECT_CONTENT or ICON.
                                 //     dwDrawAspect will be 0 (which is NOT
                                 //     DVASPECT_CONTENT) if the copier or
                                 //     dragsource didn't draw the object to
                                 //     begin with.
   SIZEL    sizel;               // size of the object in HIMETRIC
                                 //    sizel is opt.: will be (0,0) for apps
                                 //    which don't draw the object being
                                 //    transferred
   POINTL   pointl;              // Offset in HIMETRIC units from the
                                 //    upper-left corner of the obj where the
                                 //    mouse went down for the drag.
                                 //    NOTE: y coordinates increase downward.
                                 //          x coordinates increase to right
                                 //    pointl is opt.; it is only meaningful
                                 //    if object is transfered via drag/drop.
                                 //    (0, 0) if mouse position is unspecified
                                 //    (eg. when obj transfered via clipboard)
   DWORD    dwStatus;            // Misc. status flags for object. Flags are
                                 //    defined by OLEMISC enum. these flags
                                 //    are as would be returned
                                 //    by IOleObject::GetMiscStatus.
   DWORD    dwFullUserTypeName;  // Offset from beginning of structure to
                                 //    null-terminated string that specifies
                                 //    Full User Type Name of the object.
                                 //    0 indicates string not present.
   DWORD    dwSrcOfCopy;         // Offset from beginning of structure to
                                 //    null-terminated string that specifies
                                 //    source of the transfer.
                                 //    dwSrcOfCOpy is normally implemented as
                                 //    the display name of the temp-for-user
                                 //    moniker which identifies the source of
                                 //    the data.
                                 //    0 indicates string not present.
                                 //    NOTE: moniker assignment is NOT forced.
                                 //    see IOleObject::GetMoniker(
                                 //                OLEGETMONIKER_TEMPFORUSER)

 /* variable sized string data may appear here */

} OBJECTDESCRIPTOR,  *POBJECTDESCRIPTOR,  FAR *LPOBJECTDESCRIPTOR,
  LINKSRCDESCRIPTOR, *PLINKSRCDESCRIPTOR, FAR *LPLINKSRCDESCRIPTOR;



/* verbs */
#define OLEIVERB_PRIMARY            (0L)
#define OLEIVERB_SHOW               (-1L)
#define OLEIVERB_OPEN               (-2L)
#define OLEIVERB_HIDE               (-3L)
#define OLEIVERB_UIACTIVATE         (-4L)
#define OLEIVERB_INPLACEACTIVATE    (-5L)
#define OLEIVERB_DISCARDUNDOSTATE   (-6L)


//      forward type declarations
#if defined(__cplusplus)
interface IOleClientSite;
interface IOleContainer;
interface IOleObject;
#else
typedef interface IOleClientSite IOleClientSite;
typedef interface IOleContainer IOleContainer;
typedef interface IOleObject IOleObject;
#endif

typedef         IOleObject FAR* LPOLEOBJECT;
typedef     IOleClientSite FAR* LPOLECLIENTSITE;
typedef       IOleContainer FAR* LPOLECONTAINER;


/****** OLE GUIDs *********************************************************/

#include "oleguid.h"


/****** Other Major Interfaces ********************************************/

#include <dvobj.h>

#include <storage.h>



/****** IDrop??? Interfaces ********************************************/

#define MK_ALT 0x0020


#define DROPEFFECT_NONE     0
#define DROPEFFECT_COPY     1
#define DROPEFFECT_MOVE     2
#define DROPEFFECT_LINK     4
#define DROPEFFECT_SCROLL   0x80000000

// default inset-width of the hot zone, in pixels
#define DD_DEFSCROLLINSET 11

// default delay before scrolling, in milliseconds
#define DD_DEFSCROLLDELAY 50


/* Dragdrop specific error codes */

#define DRAGDROP_E_NOTREGISTERED        (DRAGDROP_E_FIRST)
// trying to revoke a drop target that has not been registered

#define DRAGDROP_E_ALREADYREGISTERED    (DRAGDROP_E_FIRST+1)
// this window has already been registered as a drop target

#define DRAGDROP_E_INVALIDHWND          (DRAGDROP_E_FIRST+2)
// invalid HWND


#define DRAGDROP_S_DROP                 (DRAGDROP_S_FIRST + 0)
// successful drop took place

#define DRAGDROP_S_CANCEL               (DRAGDROP_S_FIRST + 1)
// drag-drop operation canceled

#define DRAGDROP_S_USEDEFAULTCURSORS    (DRAGDROP_S_FIRST + 2)
// use the default cursor


#undef INTERFACE
#define INTERFACE   IDropTarget

DECLARE_INTERFACE_(IDropTarget, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropTarget methods ***
    STDMETHOD(DragEnter) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
    STDMETHOD(DragOver) (THIS_ DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
    STDMETHOD(DragLeave) (THIS) PURE;
    STDMETHOD(Drop) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
};
typedef         IDropTarget FAR* LPDROPTARGET;



#undef INTERFACE
#define INTERFACE   IDropSource

DECLARE_INTERFACE_(IDropSource, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropSource methods ***
    STDMETHOD(QueryContinueDrag) (THIS_ BOOL fEscapePressed, DWORD grfKeyState) PURE;
    STDMETHOD(GiveFeedback) (THIS_ DWORD dwEffect) PURE;
};
typedef         IDropSource FAR* LPDROPSOURCE;



/****** IPersist??? Interfaces ********************************************/


#undef INTERFACE
#define INTERFACE   IPersist

DECLARE_INTERFACE_(IPersist, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;
};
typedef            IPersist FAR* LPPERSIST;



#undef INTERFACE
#define INTERFACE   IPersistStorage

DECLARE_INTERFACE_(IPersistStorage, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStorage methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(InitNew) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Load) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Save) (THIS_ LPSTORAGE pStgSave, BOOL fSameAsLoad) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPSTORAGE pStgNew) PURE;
    STDMETHOD(HandsOffStorage) (THIS) PURE;
};
typedef         IPersistStorage FAR* LPPERSISTSTORAGE;



#undef INTERFACE
#define INTERFACE   IPersistStream

DECLARE_INTERFACE_(IPersistStream, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize) PURE;
};
typedef          IPersistStream FAR* LPPERSISTSTREAM;



#undef INTERFACE
#define INTERFACE   IPersistFile

DECLARE_INTERFACE_(IPersistFile, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistFile methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPCSTR lpszFileName, DWORD grfMode) PURE;
    STDMETHOD(Save) (THIS_ LPCSTR lpszFileName, BOOL fRemember) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPCSTR lpszFileName) PURE;
    STDMETHOD(GetCurFile) (THIS_ LPSTR FAR * lplpszFileName) PURE;
};
typedef            IPersistFile FAR* LPPERSISTFILE;


/****** Moniker Object Interfaces ******************************************/

#include <moniker.h>


/****** OLE Object Interfaces ******************************************/


#undef  INTERFACE
#define INTERFACE   IEnumOLEVERB

DECLARE_INTERFACE_(IEnumOLEVERB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOLEVERB methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPOLEVERB rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumOLEVERB FAR* FAR* ppenm) PURE;
};
typedef         IEnumOLEVERB FAR* LPENUMOLEVERB;




#undef  INTERFACE
#define INTERFACE   IOleObject

#define OLEOBJ_E_NOVERBS                (OLEOBJ_E_FIRST + 0)

#define OLEOBJ_E_INVALIDVERB            (OLEOBJ_E_FIRST + 1)

#define OLEOBJ_S_INVALIDVERB            (OLEOBJ_S_FIRST + 0)

#define OLEOBJ_S_CANNOT_DOVERB_NOW      (OLEOBJ_S_FIRST + 1)
// verb number is valid but verb cannot be done now, for instance
// hiding a link or hiding a visible OLE 1.0 server

#define OLEOBJ_S_INVALIDHWND            (OLEOBJ_S_FIRST + 2)
// invalid hwnd passed


DECLARE_INTERFACE_(IOleObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleObject methods ***
    STDMETHOD(SetClientSite) (THIS_ LPOLECLIENTSITE pClientSite) PURE;
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR* ppClientSite) PURE;
    STDMETHOD(SetHostNames) (THIS_ LPCSTR szContainerApp, LPCSTR szContainerObj) PURE;
    STDMETHOD(Close) (THIS_ DWORD dwSaveOption) PURE;
    STDMETHOD(SetMoniker) (THIS_ DWORD dwWhichMoniker, LPMONIKER pmk) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker,
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(InitFromData) (THIS_ LPDATAOBJECT pDataObject,
                BOOL fCreation,
                DWORD dwReserved) PURE;
    STDMETHOD(GetClipboardData) (THIS_ DWORD dwReserved,
                LPDATAOBJECT FAR* ppDataObject) PURE;
    STDMETHOD(DoVerb) (THIS_ LONG iVerb,
                LPMSG lpmsg,
                LPOLECLIENTSITE pActiveSite,
                LONG lindex,
                HWND hwndParent,
                LPCRECT lprcPosRect) PURE;
    STDMETHOD(EnumVerbs) (THIS_ LPENUMOLEVERB FAR* ppenumOleVerb) PURE;
    STDMETHOD(Update) (THIS) PURE;
    STDMETHOD(IsUpToDate) (THIS) PURE;
    STDMETHOD(GetUserClassID) (THIS_ CLSID FAR* pClsid) PURE;
    STDMETHOD(GetUserType) (THIS_ DWORD dwFormOfType, LPSTR FAR* pszUserType) PURE;
    STDMETHOD(SetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) PURE;
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) PURE;

    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
    STDMETHOD(GetMiscStatus) (THIS_ DWORD dwAspect, DWORD FAR* pdwStatus) PURE;
    STDMETHOD(SetColorScheme) (THIS_ LPLOGPALETTE lpLogpal) PURE;
};
typedef      IOleObject FAR* LPOLEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleClientSite

DECLARE_INTERFACE_(IOleClientSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleClientSite methods ***
    STDMETHOD(SaveObject) (THIS) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker,
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(GetContainer) (THIS_ LPOLECONTAINER FAR* ppContainer) PURE;
    STDMETHOD(ShowObject) (THIS) PURE;
    STDMETHOD(OnShowWindow) (THIS_ BOOL fShow) PURE;
    STDMETHOD(RequestNewObjectLayout) (THIS) PURE;
};
typedef      IOleClientSite FAR* LPOLECLIENTSITE;



#undef  INTERFACE
#define INTERFACE   IParseDisplayName

DECLARE_INTERFACE_(IParseDisplayName, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;
};
typedef       IParseDisplayName FAR* LPPARSEDISPLAYNAME;


#undef  INTERFACE
#define INTERFACE   IOleContainer

DECLARE_INTERFACE_(IOleContainer, IParseDisplayName)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) ( DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;
};
typedef IOleContainer FAR* LPOLECONTAINER;


typedef enum tagBINDSPEED
{
    BINDSPEED_INDEFINITE    = 1,
    BINDSPEED_MODERATE      = 2,
    BINDSPEED_IMMEDIATE     = 3
} BINDSPEED;

typedef enum tagOLECONTF
{
    OLECONTF_EMBEDDINGS     =  1,
    OLECONTF_LINKS          =  2,
    OLECONTF_OTHERS         =  4,
    OLECONTF_ONLYUSER       =  8,
    OLECONTF_ONLYIFRUNNING  = 16
} OLECONTF;


#undef  INTERFACE
#define INTERFACE   IOleItemContainer

DECLARE_INTERFACE_(IOleItemContainer, IOleContainer)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) (THIS_ DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;

    // *** IOleItemContainer methods ***
    STDMETHOD(GetObject) (THIS_ LPSTR lpszItem, DWORD dwSpeedNeeded,
        LPBINDCTX pbc, REFIID riid, LPVOID FAR* ppvObject) PURE;
    STDMETHOD(GetObjectStorage) (THIS_ LPSTR lpszItem, LPBINDCTX pbc,
        REFIID riid, LPVOID FAR* ppvStorage) PURE;
    STDMETHOD(IsRunning) (THIS_ LPSTR lpszItem) PURE;
};
typedef       IOleItemContainer FAR* LPOLEITEMCONTAINER;



#undef  INTERFACE
#define INTERFACE   IOleAdviseHolder

DECLARE_INTERFACE_(IOleAdviseHolder, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD(SendOnSave)(THIS) PURE;
    STDMETHOD(SendOnClose)(THIS) PURE;
};
typedef      IOleAdviseHolder FAR* LPOLEADVISEHOLDER;


/****** OLE Link Interface ************************************************/

/* Link update options */
typedef enum tagOLEUPDATE
{
    OLEUPDATE_ALWAYS=1,
    OLEUPDATE_ONCALL=3
} OLEUPDATE;
typedef  OLEUPDATE FAR* LPOLEUPDATE;


// for IOleLink::BindToSource
typedef enum tagOLELINKBIND
{
    OLELINKBIND_EVENIFCLASSDIFF = 1,
} OLELINKBIND;


#undef  INTERFACE
#define INTERFACE   IOleLink

DECLARE_INTERFACE_(IOleLink, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleLink methods ***
    STDMETHOD(SetUpdateOptions) (THIS_ DWORD dwUpdateOpt) PURE;
    STDMETHOD(GetUpdateOptions) (THIS_ LPDWORD pdwUpdateOpt) PURE;
    STDMETHOD(SetSourceMoniker) (THIS_ LPMONIKER pmk, REFCLSID rclsid) PURE;
    STDMETHOD(GetSourceMoniker) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(SetSourceDisplayName) (THIS_ LPCSTR lpszDisplayName) PURE;
    STDMETHOD(GetSourceDisplayName) (THIS_ LPSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(BindToSource) (THIS_ DWORD bindflags, LPBINDCTX pbc) PURE;
    STDMETHOD(BindIfRunning) (THIS) PURE;
    STDMETHOD(GetBoundSource) (THIS_ LPUNKNOWN FAR* ppUnk) PURE;
    STDMETHOD(UnbindSource) (THIS) PURE;
    STDMETHOD(Update) (THIS_ LPBINDCTX pbc) PURE;
};
typedef         IOleLink FAR* LPOLELINK;


/****** OLE InPlace Editing Interfaces ************************************/

#ifdef _MAC
typedef Handle  HOLEMENU;
typedef long    SIZE;
typedef long    HACCEL;
#else
DECLARE_HANDLE(HOLEMENU);
#endif

typedef struct FARSTRUCT tagOIFI          // OleInPlaceFrameInfo
{
    UINT    cb;
    BOOL    fMDIApp;
    HWND    hwndFrame;
    HACCEL  haccel;
    int     cAccelEntries;
} OLEINPLACEFRAMEINFO, FAR* LPOLEINPLACEFRAMEINFO;


typedef struct FARSTRUCT tagOleMenuGroupWidths
{
    LONG    width[6];
} OLEMENUGROUPWIDTHS, FAR* LPOLEMENUGROUPWIDTHS;

typedef RECT    BORDERWIDTHS;
typedef LPRECT  LPBORDERWIDTHS;
typedef LPCRECT LPCBORDERWIDTHS;

/* Inplace editing specific error codes */

#define INPLACE_E_NOTUNDOABLE   (INPLACE_E_FIRST)
// undo is not avaiable

#define INPLACE_E_NOTOOLSPACE       (INPLACE_E_FIRST+1)
// Space for tools is not available

#define INPLACE_S_TRUNCATED     (INPLACE_S_FIRST)
// Message is too long, some of it had to be truncated before displaying


//      forward type declarations
#if defined(__cplusplus)
interface IOleInPlaceUIWindow;
#else
typedef interface IOleInPlaceUIWindow IOleInPlaceUIWindow;
#endif

typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;


#undef  INTERFACE
#define INTERFACE   IOleWindow

DECLARE_INTERFACE_(IOleWindow, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
};

typedef         IOleWindow FAR* LPOLEWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceObject

DECLARE_INTERFACE_(IOleInPlaceObject, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceObject methods ***
    STDMETHOD(InPlaceDeactivate) (THIS) PURE;
    STDMETHOD(UIDeactivate) (THIS) PURE;
    STDMETHOD(SetObjectRects) (THIS_ LPCRECT lprcPosRect,
                    LPCRECT lprcClipRect) PURE;
    STDMETHOD(ReactivateAndUndo) (THIS) PURE;
};
typedef         IOleInPlaceObject FAR* LPOLEINPLACEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceActiveObject

DECLARE_INTERFACE_(IOleInPlaceActiveObject, IOleWindow)
{
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceActiveObject methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;
    STDMETHOD(OnFrameWindowActivate) (THIS_ BOOL fActivate) PURE;
    STDMETHOD(OnDocWindowActivate) (THIS_ BOOL fActivate) PURE;
    STDMETHOD(ResizeBorder) (THIS_ LPCRECT lprectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL fFrameWindow) PURE;
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
};
typedef         IOleInPlaceActiveObject FAR* LPOLEINPLACEACTIVEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceUIWindow

DECLARE_INTERFACE_(IOleInPlaceUIWindow, IOleWindow)
{
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                        LPCSTR lpszObjName) PURE;
};
typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceFrame

DECLARE_INTERFACE_(IOleInPlaceFrame, IOleInPlaceUIWindow)
{
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                    LPCSTR lpszObjName) PURE;


    // *** IOleInPlaceFrame methods ***
    STDMETHOD(InsertMenus) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths) PURE;
    STDMETHOD(SetMenu) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject) PURE;
    STDMETHOD(RemoveMenus) (THIS_ HMENU hmenuShared) PURE;
    STDMETHOD(SetStatusText) (THIS_ LPCSTR lpszStatusText) PURE;
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg, WORD wID) PURE;
};
typedef     IOleInPlaceFrame FAR* LPOLEINPLACEFRAME;


#undef  INTERFACE
#define INTERFACE   IOleInPlaceSite

DECLARE_INTERFACE_(IOleInPlaceSite, IOleWindow)
{
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceSite methods ***
    STDMETHOD(CanInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnUIActivate) (THIS) PURE;
    STDMETHOD(GetWindowContext) (THIS_ LPOLEINPLACEFRAME FAR* lplpFrame,
                        LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                        LPRECT lprcPosRect,
                        LPRECT lprcClipRect,
                        LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
    STDMETHOD(Scroll) (THIS_ SIZE scrollExtent) PURE;
    STDMETHOD(OnUIDeactivate) (THIS_ BOOL fUndoable) PURE;
    STDMETHOD(OnInPlaceDeactivate) (THIS) PURE;
    STDMETHOD(DiscardUndoState) (THIS) PURE;
    STDMETHOD(DeactivateAndUndo) (THIS) PURE;
    STDMETHOD(OnPosRectChange) (THIS_ LPCRECT lprcPosRect) PURE;
};
typedef         IOleInPlaceSite FAR* LPOLEINPLACESITE;



/****** OLE API Prototypes ************************************************/

STDAPI_(DWORD) OleBuildVersion( VOID );

/* helper functions */
STDAPI ReadClassStg(LPSTORAGE pStg, CLSID FAR* pclsid);
STDAPI WriteClassStg(LPSTORAGE pStg, REFCLSID rclsid);
STDAPI ReadClassStm(LPSTREAM pStm, CLSID FAR* pclsid);
STDAPI WriteClassStm(LPSTREAM pStm, REFCLSID rclsid);
STDAPI WriteFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT cf, LPSTR lpszUserType);
STDAPI ReadFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT FAR* pcf, LPSTR FAR* lplpszUserType);


/* init/term */

STDAPI OleInitialize(LPMALLOC pMalloc);
STDAPI_(void) OleUninitialize(void);


/* APIs to query whether (Embedded/Linked) object can be created from
   the data object */

STDAPI  OleQueryLinkFromData(LPDATAOBJECT pSrcDataObject);
STDAPI  OleQueryCreateFromData(LPDATAOBJECT pSrcDataObject);


/* Object creation APIs */

STDAPI  OleCreate(REFCLSID rclsid, REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, LPOLECLIENTSITE pClientSite,
                LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleCreateFromData(LPDATAOBJECT pSrcDataObj, REFIID riid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkFromData(LPDATAOBJECT pSrcDataObj, REFIID riid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID FAR* ppvObj);

STDAPI  OleCreateStaticFromData(LPDATAOBJECT pSrcDataObj, REFIID iid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID FAR* ppvObj);


STDAPI  OleCreateLink(LPMONIKER pmkLinkSrc, REFIID riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkToFile(LPCSTR lpszFileName, REFIID riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleCreateFromFile(REFCLSID rclsid, LPCSTR lpszFileName, REFIID riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleLoad(LPSTORAGE pStg, REFIID riid, LPOLECLIENTSITE pClientSite,
            LPVOID FAR* ppvObj);

STDAPI  OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad);

STDAPI  OleLoadFromStream( LPSTREAM pStm, REFIID iidInterface, LPVOID FAR* ppvObj);
STDAPI  OleSaveToStream( LPPERSISTSTREAM pPStm, LPSTREAM pStm );


STDAPI  OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained);
STDAPI  OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible);


/* Drag/Drop APIs */

STDAPI  RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget);
STDAPI  RevokeDragDrop(HWND hwnd);
STDAPI  DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
            DWORD dwOKEffects, LPDWORD pdwEffect);

/* Clipboard APIs */

STDAPI  OleSetClipboard(LPDATAOBJECT pDataObj);
STDAPI  OleGetClipboard(LPDATAOBJECT FAR* ppDataObj);
STDAPI  OleFlushClipboard(void);
STDAPI  OleIsCurrentClipboard(LPDATAOBJECT pDataObj);


/* InPlace Editing APIs */

STDAPI_(HOLEMENU)   OleCreateMenuDescriptor (HMENU hmenuCombined,
                                LPOLEMENUGROUPWIDTHS lpMenuWidths);
STDAPI              OleSetMenuDescriptor (HOLEMENU holemenu, HWND hwndFrame,
                                HWND hwndActiveObject,
                                LPOLEINPLACEFRAME lpFrame,
                                LPOLEINPLACEACTIVEOBJECT lpActiveObj);
STDAPI              OleDestroyMenuDescriptor (HOLEMENU holemenu);

STDAPI              OleTranslateAccelerator (LPOLEINPLACEFRAME lpFrame,
                            LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg);


/* Helper APIs */
STDAPI_(HANDLE) OleDuplicateData (HANDLE hSrc, CLIPFORMAT cfFormat,
                        UINT uiFlags);

STDAPI          OleDraw (LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw,
                    LPCRECT lprcBounds);

STDAPI          OleRun(LPUNKNOWN pUnknown);
STDAPI_(BOOL)   OleIsRunning(LPOLEOBJECT pObject);

STDAPI_(void)   ReleaseStgMedium(LPSTGMEDIUM);
STDAPI          CreateOleAdviseHolder(LPOLEADVISEHOLDER FAR* ppOAHolder);

STDAPI          OleCreateDefaultHandler(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    REFIID riid, LPVOID FAR* lplpObj);

/* OLE 1.0 conversion APIS */

STDAPI OleConvertOLESTREAMToIStorage
    (LPOLESTREAM                lpolestream,
    LPSTORAGE                   pstg,
    const DVTARGETDEVICE FAR*   ptd);

STDAPI OleConvertIStorageToOLESTREAM
    (LPSTORAGE      pstg,
    LPOLESTREAM     lpolestream);


/* Storage Utility APIs */
STDAPI GetHGlobalFromILockBytes (LPLOCKBYTES plkbyt, HGLOBAL FAR* phglobal);
STDAPI CreateILockBytesOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                    LPLOCKBYTES FAR* pplkbyt);

STDAPI GetHGlobalFromStream (LPSTREAM pstm, HGLOBAL FAR* phglobal);
STDAPI CreateStreamOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                LPSTREAM FAR* ppstm);


/* ConvertTo APIS */

STDAPI OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew);
STDAPI OleGetAutoConvert(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew);
STDAPI GetConvertStg(LPSTORAGE pStg);
STDAPI SetConvertStg(LPSTORAGE pStg, BOOL fConvert);


#endif // _OLE2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\penreg.h ===
/* PENREG.h: Pen Windows Registry defines

	Copyright 1993-1994 Microsoft Corporation.  All rights reserved.
	Microsoft Confidential.

		Registry defines for Pen Windows et al.
		This file should not be localized!
	
*/

#ifndef _INCLUDE_PENREGH
#define _INCLUDE_PENREGH


/****************** Includes ***********************************************/
#ifndef WIN32
#include "\dev\sdk\inc\regstr.h"
#endif //!WIN32
#ifndef WINPAD
#include <winerror.h>
#endif
/****************** Defines ************************************************/
#define keyUndef			0x0000	// Undefined key
#define keyPenHlmCv		0x0001	// Sys stuff not editable by pen cpl
#define keyPenHlmCpl		0x0002	// Sys stuff editable by pen cpl
#define keyPenHlmBedit	0x0003	// Bedit stuff (editable by cpl for Kanji)
#define keyPenHcuCpl		0x0004	// Per-user stuff editable by pen cpl

#if defined(JAPAN) && defined(DBCS_IME)
#define keyPenHlmIme		0x0005	// Ime stuff not editable by pen cpl
#endif

// Parent Key: HKEY_LOCAL_MACHINE
#define REGSTR_PATH_CONTROL\
	"System\\CurrentControlSet\\Control"
#define REGSTR_PATH_PENHLMCV\
	"Software\\Microsoft\\Windows\\CurrentVersion\\Pen"
#define REGSTR_PATH_PENHLMCPL\
	"Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Pen"
#define REGSTR_PATH_PENHLMBEDIT\
	"Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Pen\\BEdit"

#if defined(JAPAN) && defined(DBCS_IME)
#define REGSTR_PATH_PENHLMIME\
	"Software\\Microsoft\\Windows\\CurrentVersion\\Pen\\Ime"
#endif

// Parent key: HKEY_CURRENT_USER
#define REGSTR_PATH_PENHCUCPL					"Control Panel\\Pen"

#define REGSTR_VAL_CURRENTUSER				"Current User"

#define REGSTR_VAL_PENBEDIT_BASEHEIGHT		"BaseHeight"
#define REGSTR_VAL_PENBEDIT_BASEHORZ		"BaseHorz"
#define REGSTR_VAL_PENBEDIT_CELLHEIGHT		"CellHeight"
#define REGSTR_VAL_PENBEDIT_CELLWIDTH		"CellWidth"
#define REGSTR_VAL_PENBEDIT_CUSPHEIGHT		"CuspHeight"
#define REGSTR_VAL_PENBEDIT_ENDCUSPHEIGHT	"EndCuspHeight"
#define REGSTR_VAL_PENBEDIT_GUIDECROSS		"GuideCross"
#define REGSTR_VAL_PENBEDIT_GUIDESTYLE		"GuideStyle"

// Per user items which cannot be modified from pencp.cpl.
#define REGSTR_VAL_PEN_BARRELEVENT			"BarrelEvent"
#define REGSTR_VAL_PEN_LENS					"Lens"
#define REGSTR_VAL_PEN_RECOG 					"Recognizer"
#define REGSTR_VAL_PEN_SELECTTIMEOUT		"SelectTimeOut"
#define REGSTR_VAL_PEN_USER					"User"				// May go away

// Per user items which can be modified from pencp.cpl.
#define REGSTR_VAL_PENCPL_ACTIONHANDLES	"ActionHandles"	// May go away
#define REGSTR_VAL_PENCPL_AUTOWRITE			"AutoWrite"
#define REGSTR_VAL_PENCPL_INPUTCURSOR		"InputCursor"
#define REGSTR_VAL_PENCPL_INKCOLOR			"InkColor"
#define REGSTR_VAL_PENCPL_INKWIDTH			"InkWidth"
#define REGSTR_VAL_PENCPL_INTLPREF			"IntlPreferences"
#define REGSTR_VAL_PENCPL_MENU				"MenuDropAlignment"
#define REGSTR_VAL_PENCPL_PREF				"Preferences"
#define REGSTR_VAL_PENCPL_TIMEOUT			"TimeOut"


#endif 	// _INCLUDE_PENREGH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\plan16.h ===
/*****************************************************************************\
* PLAN16.H - PORTABILITY MAPPING HEADER FILE FOR LANMAN API
*
* This file provides macros to map portable lanman code to its 16 bit form.
*
* Copyright (c) 1994, Microsoft Corp.	All rights reserved.
*
\*****************************************************************************/

/*-----------------------------------LANMAN----------------------------------*/

/* LANMAN MACROS: */

#define COPYTOARRAY(pDest, pSource)     strcpy(pDest, pSource)

/* LANMAN API: */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\pif.inc ===
ifndef _INC_PIF
_INC_PIF	EQU	1
PIFNAMESIZE	EQU	30
PIFSTARTLOCSIZE	EQU	63
PIFDEFPATHSIZE	EQU	64
PIFPARAMSSIZE	EQU	64
PIFSHPROGSIZE	EQU	64
PIFSHDATASIZE	EQU	64
PIFDEFFILESIZE	EQU	80
ifndef LF_FACESIZE
LF_FACESIZE	EQU	32
endif
LARGEST_GROUP	EQU	SIZE STDPIF
OPENPROPS_NONE	EQU	0000H
OPENPROPS_RAWIO	EQU	0001H
GETPROPS_NONE	EQU	0000H
GETPROPS_RAWIO	EQU	0001H
GETPROPS_EXTENDED	EQU	0004H
SETPROPS_NONE	EQU	0000H
SETPROPS_RAWIO	EQU	0001H
SETPROPS_CACHE	EQU	0002H
SETPROPS_EXTENDED	EQU	0004H
FLUSHPROPS_NONE	EQU	0000H
FLUSHPROPS_DISCARD	EQU	0001H
CLOSEPROPS_NONE	EQU	0000H
CLOSEPROPS_DISCARD	EQU	0001H
LOADPROPLIB_DEFER	EQU	0001H
ifdef  RECT
_INC_WINDOWS	EQU	1
endif
ifndef _INC_WINDOWS
RECT    struc
        rcLeft      dw  ?
        rcTop       dw  ?
        rcRight     dw  ?
        rcBottom    dw  ?
RECT    ends

endif
GROUP_PRG	EQU	1
PRG_DEFAULT	EQU	<(PRG_CLOSEONEXIT OR PRG_AUTOWINEXEC)>
PRG_CLOSEONEXIT	EQU	0001H
PRG_AUTOWINEXEC	EQU	0004H
PRGINIT_DEFAULT	EQU	0
PRGINIT_MINIMIZED	EQU	0001H
PRGINIT_MAXIMIZED	EQU	0002H
PRGINIT_USEPIFICON	EQU	0004H
PRGINIT_REALMODE	EQU	0008H
PRGINIT_NOPIF	EQU	1000H
PRGINIT_DEFAULTPIF	EQU	2000H
ICONFILE_DEFAULT	EQU	<"PIFMGR.DLL">
ICONINDEX_DEFAULT	EQU	0

PROPPRG	STRUC
flPrg	DW	?
flPrgInit	DW	?
achTitle	DB	PIFNAMESIZE DUP (?)
achCmdLine	DB	PIFSTARTLOCSIZE DUP (?)
achWorkDir	DB	PIFDEFPATHSIZE DUP (?)
wHotKey	DW	?
rgbReserved	DB	6 DUP (?)
achIconFile	DB	PIFDEFFILESIZE DUP (?)
wIconIndex	DW	?
achPIFFile	DB	PIFDEFFILESIZE DUP (?)
PROPPRG	ENDS
GROUP_TSK	EQU	2
TSK_DEFAULT	EQU	<(TSK_BACKGROUND)>
TSK_ALLOWCLOSE	EQU	0001H
TSK_BACKGROUND	EQU	0002H
TSK_EXCLUSIVE	EQU	0004H
TSK_FAKEBOOST	EQU	0008H
TSK_NOWARNTERMINATE	EQU	0010H
TSK_NOSCREENSAVER	EQU	0020H
TSKINIT_DEFAULT	EQU	0
TSKFGND_DEFAULT	EQU	75
TSKBGND_DEFAULT	EQU	25
TSKFGND_OLD_DEFAULT	EQU	100
TSKBGND_OLD_DEFAULT	EQU	50
TSKBOOSTTIME_MIN	EQU	0
TSKBOOSTTIME_DEFAULT	EQU	1
TSKBOOSTTIME_MAX	EQU	5000
TSKIDLEDELAY_MIN	EQU	0
TSKIDLEDELAY_DEFAULT	EQU	500
TSKIDLEDELAY_MAX	EQU	5000
TSKIDLESENS_DEFAULT	EQU	50

PROPTSK	STRUC
flTsk	DW	?
flTskInit	DW	?
iFgndBoost	DW	?
iBgndBoost	DW	?
msKeyBoostTime	DW	?
msKeyIdleDelay	DW	?
wIdleSensitivity	DW	?
PROPTSK	ENDS
GROUP_VID	EQU	3
VID_DEFAULT	EQU	<(VID_TEXTEMULATE OR VID_FULLSCREENGRFX OR VID_AUTOSUSPEND)>
VID_TEXTEMULATE	EQU	0001H
VID_TEXTTRAP	EQU	0002H
VID_LOGRFXTRAP	EQU	0004H
VID_HIGRFXTRAP	EQU	0008H
VID_RETAINMEMORY	EQU	0080H
VID_FULLSCREEN	EQU	0100H
VID_FULLSCREENGRFX	EQU	0200H
VIDINIT_DEFAULT	EQU	0
VIDMODE_DEFAULT	EQU	<VIDMODE_TEXT>
VIDMODE_TEXT	EQU	1
VIDMODE_LOGRFX	EQU	2
VIDMODE_HIGRFX	EQU	3
VIDSCROLLFREQ_MIN	EQU	1
VIDSCROLLFREQ_DEFAULT	EQU	2
VIDSCROLLFREQ_MAX	EQU	25
VIDUPDATEFREQ_MIN	EQU	10
VIDUPDATEFREQ_DEFAULT	EQU	50
VIDUPDATEFREQ_MAX	EQU	5000
VIDSCREENLINES_MIN	EQU	0
VIDSCREENLINES_DEFAULT	EQU	0

PROPVID	STRUC
flVid	DW	?
flVidInit	DW	?
iVidMode	DW	?
cScrollFreq	DW	?
msUpdateFreq	DW	?
cScreenLines	DW	?
abTextColorRemap	DB	16 DUP (?)
PROPVID	ENDS
GROUP_MEM	EQU	4
MEM_DEFAULT	EQU	0
MEMINIT_DEFAULT	EQU	0
MEMINIT_NOHMA	EQU	0001H
MEMINIT_LOWLOCKED	EQU	0002H
MEMINIT_EMSLOCKED	EQU	0004H
MEMINIT_XMSLOCKED	EQU	0008H
MEMINIT_GLOBALPROTECT	EQU	0010H
MEMINIT_STRAYPTRDETECT	EQU	0020H
MEMLOW_MIN_MIN	EQU	0FFFFH
MEMLOW_MIN_DEFAULT	EQU	0
MEMLOW_MIN_MAX	EQU	640
MEMLOW_MAX_MIN	EQU	0FFFFH
MEMLOW_MAX_DEFAULT	EQU	0FFFFH
MEMLOW_MAX_MAX	EQU	640
MEMEMS_MIN_MIN	EQU	0
MEMEMS_MIN_DEFAULT	EQU	0
MEMEMS_MIN_MAX	EQU	16384
MEMEMS_MAX_MIN	EQU	0FFFFH
MEMEMS_MAX_DEFAULT	EQU	1024
MEMEMS_MAX_MAX	EQU	16384
MEMXMS_MIN_MIN	EQU	0
MEMXMS_MIN_DEFAULT	EQU	0
MEMXMS_MIN_MAX	EQU	16384
MEMXMS_MAX_MIN	EQU	0FFFFH
MEMXMS_MAX_DEFAULT	EQU	1024
MEMXMS_MAX_MAX	EQU	16384

PROPMEM	STRUC
flMem	DW	?
flMemInit	DW	?
wMinLow	DW	?
wMaxLow	DW	?
wMinEMS	DW	?
wMaxEMS	DW	?
wMinXMS	DW	?
wMaxXMS	DW	?
PROPMEM	ENDS
GROUP_KBD	EQU	5
KBD_DEFAULT	EQU	<(KBD_FASTPASTE)>
KBD_FASTPASTE	EQU	0001H
KBD_NOALTTAB	EQU	0020H
KBD_NOALTESC	EQU	0040H
KBD_NOALTSPACE	EQU	0080H
KBD_NOALTENTER	EQU	0100H
KBD_NOALTPRTSC	EQU	0200H
KBD_NOPRTSC	EQU	0400H
KBD_NOCTRLESC	EQU	0800H
KBDINIT_DEFAULT	EQU	0
KBDALTDELAY_MIN	EQU	1
KBDALTDELAY_DEFAULT	EQU	5
KBDALTDELAY_MAX	EQU	5000
KBDALTPASTEDELAY_MIN	EQU	1
KBDALTPASTEDELAY_DEFAULT	EQU	25
KBDALTPASTEDELAY_MAX	EQU	5000
KBDPASTEDELAY_MIN	EQU	1
KBDPASTEDELAY_DEFAULT	EQU	3
KBDPASTEDELAY_MAX	EQU	5000
KBDPASTEFULLDELAY_MIN	EQU	1
KBDPASTEFULLDELAY_DEFAULT	EQU	200
KBDPASTEFULLDELAY_MAX	EQU	5000
KBDPASTETIMEOUT_MIN	EQU	1
KBDPASTETIMEOUT_DEFAULT	EQU	1000
KBDPASTETIMEOUT_MAX	EQU	5000
KBDPASTESKIP_MIN	EQU	1
KBDPASTESKIP_DEFAULT	EQU	2
KBDPASTESKIP_MAX	EQU	100
KBDPASTECRSKIP_MIN	EQU	1
KBDPASTECRSKIP_DEFAULT	EQU	10
KBDPASTECRSKIP_MAX	EQU	100

PROPKBD	STRUC
flKbd	DW	?
flKbdInit	DW	?
msAltDelay	DW	?
msAltPasteDelay	DW	?
msPasteDelay	DW	?
msPasteFullDelay	DW	?
msPasteTimeout	DW	?
cPasteSkip	DW	?
cPasteCRSkip	DW	?
PROPKBD	ENDS
GROUP_MSE	EQU	6
MSE_DEFAULT	EQU	<(MSE_WINDOWENABLE)>
MSE_WINDOWENABLE	EQU	0001H
MSE_EXCLUSIVE	EQU	0002H
MSEINIT_DEFAULT	EQU	0

PROPMSE	STRUC
flMse	DW	?
flMseInit	DW	?
PROPMSE	ENDS
GROUP_TMR	EQU	7
TMR_DEFAULT	EQU	0
TMR_TRAPTMRPORTS	EQU	0001H
TMR_FULLBGNDTICKS	EQU	0002H
TMR_BURSTMODE	EQU	0004H
TMR_PATCHEOI	EQU	0008H
TMRINIT_DEFAULT	EQU	0
TMRBURSTDELAY_MIN	EQU	0
TMRBURSTDELAY_DEFAULT	EQU	0
TMRBURSTDELAY_MAX	EQU	100

PROPTMR	STRUC
flTmr	DW	?
flTmrInit	DW	?
wBurstDelay	DW	?
PROPTMR	ENDS

PROPTMREXT	STRUC
tmrData	DB	SIZE PROPTMR DUP (?)
msIntFreq	DW	?
wExecPercent	DW	?
PROPTMREXT	ENDS
GROUP_FNT	EQU	11
FNT_DEFAULT	EQU	<(FNT_BOTHFONTS)>
FNT_RASTERFONTS	EQU	0004H
FNT_TTFONTS	EQU	0008H
FNT_BOTHFONTS	EQU	(FNT_RASTERFONTS OR FNT_TTFONTS)
FNT_AUTOSIZE	EQU	0010H
FNT_RASTER	EQU	0400H
FNT_TT	EQU	0800H
FNT_FONTMASK	EQU	(FNT_BOTHFONTS)
FNT_FONTMASKBITS	EQU	2
FNTINIT_DEFAULT	EQU	0
FNTINIT_NORESTORE	EQU	0001H

PROPFNT	STRUC
flFnt	DW	?
flFntInit	DW	?
cxFont	DW	?
cyFont	DW	?
cxFontActual	DW	?
cyFontActual	DW	?
achRasterFaceName	DB	LF_FACESIZE DUP (?)
achTTFaceName	DB	LF_FACESIZE DUP (?)
ifdef JAPAN
wCharSet	DW	?
endif
PROPFNT	ENDS
GROUP_WIN	EQU	12
WIN_DEFAULT	EQU	<(WIN_SAVESETTINGS)>
WIN_SAVESETTINGS	EQU	0001H
WIN_TOOLBAR	EQU	0002H
WININIT_DEFAULT	EQU	0
WININIT_NORESTORE	EQU	0001H

PROPWIN	STRUC
flWin	DW	?
flWinInit	DW	?
cxCells	DW	?
cyCells	DW	?
cxClient	DW	?
cyClient	DW	?
cxWindow	DW	?
cyWindow	DW	?
ifdef WPF_SETMINPOSITION
wp	DB	SIZE WINDOWPLACEMENT DUP (?)
else
wLength	DW	?
wShowFlags	DW	?
wShowCmd	DW	?
xMinimize	DW	?
yMinimize	DW	?
xMaximize	DW	?
yMaximize	DW	?
rcNormal	DB	SIZE RECT DUP (?)
endif
PROPWIN	ENDS
GROUP_ENV	EQU	13
ENV_DEFAULT	EQU	0
ENVINIT_DEFAULT	EQU	<(ENVINIT_INSTRUCTIONS)>
ENVINIT_INSTRUCTIONS	EQU	0001H
ENVSIZE_MIN	EQU	0
ENVSIZE_DEFAULT	EQU	0
ENVSIZE_MAX	EQU	4096

PROPENV	STRUC
flEnv	DW	?
flEnvInit	DW	?
achBatchFile	DB	PIFDEFFILESIZE DUP (?)
cbEnvironment	DW	?
ifdef JAPAN
wCodePage	DW	?
wInitCodePage	DW	?
endif
PROPENV	ENDS
MAX_GROUP	EQU	0FFH
MAX_VALID_GROUP	EQU	GROUP_ENV
EXT_GROUP_QUERY	EQU	100H
EXT_GROUP_UPDATE	EQU	200H
PIFEXTSIGSIZE	EQU	16
MAX_GROUP_NAME	EQU	PIFEXTSIGSIZE
STDHDRSIG	EQU	<"MICROSOFT PIFEX">
LASTHDRPTR	EQU	0FFFFH
W286HDRSIG30	EQU	<"WINDOWS 286 3.0">
W386HDRSIG30	EQU	<"WINDOWS 386 3.0">
WENHHDRSIG40	EQU	<"WINDOWS PIF.402">
WENHICOSIG001	EQU	<"WINDOWS ICO.001">

PIFEXTHDR	STRUC
extsig	DB	PIFEXTSIGSIZE DUP (?)
extnxthdrfloff	DW	?
extfileoffset	DW	?
extsizebytes	DW	?
PIFEXTHDR	ENDS
fResident	EQU	01H
fGraphics	EQU	02H
fNoSwitch	EQU	04H
fNoGrab	EQU	08H
fDestroy	EQU	10H
fCOM2	EQU	40H
fCOM1	EQU	80H
MEMMASK	EQU	fResident
GRAPHMASK	EQU	fGraphics
TEXTMASK	EQU	((NOT GRAPHMASK))
PSMASK	EQU	fNoSwitch
SGMASK	EQU	fNoGrab
EXITMASK	EQU	fDestroy
COM2MASK	EQU	fCOM2
COM1MASK	EQU	fCOM1
fScreen	EQU	80H
fForeground	EQU	40H
f8087	EQU	20H
fKeyboard	EQU	10H
SCRMASK	EQU	(fScreen+fForeground)
MASK8087	EQU	f8087
KEYMASK	EQU	fKeyboard
SWAPMASK	EQU	20H
PARMMASK	EQU	40H

STDPIF	STRUC
unknown	DB	?
id	DB	?
appname	DB	PIFNAMESIZE DUP (?)
maxmem	DW	?
minmem	DW	?
startfile	DB	PIFSTARTLOCSIZE DUP (?)
MSflags	DB	?
reserved	DB	?
defpath	DB	PIFDEFPATHSIZE DUP (?)
params	DB	PIFPARAMSSIZE DUP (?)
screen	DB	?
cPages	DB	?
lowVector	DB	?
highVector	DB	?
rows	DB	?
cols	DB	?
rowoff	DB	?
coloff	DB	?
sysmem	DW	?
shprog	DB	PIFSHPROGSIZE DUP (?)
shdata	DB	PIFSHDATASIZE DUP (?)
behavior	DB	?
sysflags	DB	?
STDPIF	ENDS
fALTTABdis286	EQU	0001H
fALTESCdis286	EQU	0002H
fALTPRTSCdis286	EQU	0004H
fPRTSCdis286	EQU	0008H
fCTRLESCdis286	EQU	0010H
fNoSaveVid286	EQU	0020H
fCOM3_286	EQU	4000H
fCOM4_286	EQU	8000H

W286PIF30	STRUC
PfMaxXmsK	DW	?
PfMinXmsK	DW	?
PfW286Flags	DW	?
W286PIF30	ENDS
fEnableClose	EQU	00000001H
fEnableCloseBit	EQU	0
fBackground	EQU	00000002H
fBackgroundBit	EQU	1
fExclusive	EQU	00000004H
fExclusiveBit	EQU	2
fFullScreen	EQU	00000008H
fFullScreenBit	EQU	3
fALTTABdis	EQU	00000020H
fALTTABdisBit	EQU	5
fALTESCdis	EQU	00000040H
fALTESCdisBit	EQU	6
fALTSPACEdis	EQU	00000080H
fALTSPACEdisBit	EQU	7
fALTENTERdis	EQU	00000100H
fALTENTERdisBit	EQU	8
fALTPRTSCdis	EQU	00000200H
fALTPRTSCdisBit	EQU	9
fPRTSCdis	EQU	00000400H
fPRTSCdisBit	EQU	10
fCTRLESCdis	EQU	00000800H
fCTRLESCdisBit	EQU	11
fPollingDetect	EQU	00001000H
fPollingDetectBit	EQU	12
fNoHMA	EQU	00002000H
fNoHMABit	EQU	13
fHasHotKey	EQU	00004000H
fHasHotKeyBit	EQU	14
fEMSLocked	EQU	00008000H
fEMSLockedBit	EQU	15
fXMSLocked	EQU	00010000H
fXMSLockedBit	EQU	16
fINT16Paste	EQU	00020000H
fINT16PasteBit	EQU	17
fVMLocked	EQU	00040000H
fVMLockedBit	EQU	18
fGlobalProtect	EQU	00080000H
fGlobalProtectBit	EQU	19
fMinimized	EQU	00100000H
fMinimizedBit	EQU	20
fMaximized	EQU	00200000H
fMaximizedBit	EQU	21
fRealMode	EQU	00800000H
fRealModeBit	EQU	23
fDisAutoWinExec	EQU	01000000H
fDisAutoWinExecBit	EQU	24
fStrayPtrDetect	EQU	02000000H
fStrayPtrDetectBit	EQU	25
fVDDMask	EQU	0000FFFFH
fVDDMinBit	EQU	0
fVDDMaxBit	EQU	15
fVidTxtEmulate	EQU	00000001H
fVidTxtEmulateBit	EQU	0
fVidNoTrpTxt	EQU	00000002H
fVidNoTrpTxtBit	EQU	1
fVidNoTrpLRGrfx	EQU	00000004H
fVidNoTrpLRGrfxBit	EQU	2
fVidNoTrpHRGrfx	EQU	00000008H
fVidNoTrpHRGrfxBit	EQU	3
fVidTextMd	EQU	00000010H
fVidTextMdBit	EQU	4
fVidLowRsGrfxMd	EQU	00000020H
fVidLowRsGrfxMdBit	EQU	5
fVidHghRsGrfxMd	EQU	00000040H
fVidHghRsGrfxMdBit	EQU	6
fVidRetainAllo	EQU	00000080H
fVidRetainAlloBit	EQU	7
PifDescMask	EQU	(fALTTABdis+fALTESCdis+fALTSPACEdis+fALTENTERdis+fALTPRTSCdis+fPRTSCdis+fCTRLESCdis+fPollingDetect+fNoHMA+fHasHotKey+fEMSLocked+fXMSLocked+fINT16Paste+fVMLocked)

W386PIF30	STRUC
PfW386maxmem	DW	?
PfW386minmem	DW	?
PfFPriority	DW	?
PfBPriority	DW	?
PfMaxEMMK	DW	?
PfMinEMMK	DW	?
PfMaxXmsK	DW	?
PfMinXmsK	DW	?
PfW386Flags	DD	?
PfW386Flags2	DD	?
PfHotKeyScan	DW	?
PfHotKeyShVal	DW	?
PfHotKeyShMsk	DW	?
PfHotKeyVal	DB	?
PfHotKeyPad	DB	9 DUP (?)
PfW386params	DB	PIFPARAMSSIZE DUP (?)
W386PIF30	ENDS
HVM_ASSOCIATION	EQU	1
HWND_ASSOCIATION	EQU	2
SHEETTYPE_SIMPLE	EQU	0
SHEETTYPE_ADVANCED	EQU	1
ORD_OPENPROPERTIES	EQU	2
ORD_GETPROPERTIES	EQU	3
ORD_SETPROPERTIES	EQU	4
ORD_EDITPROPERTIES	EQU	5
ORD_FLUSHPROPERTIES	EQU	6
ORD_ENUMPROPERTIES	EQU	7
ORD_ASSOCIATEPROPERTIES	EQU	8
ORD_CLOSEPROPERTIES	EQU	9
ORD_LOADPROPERTYLIB	EQU	10
ORD_ENUMPROPERTYLIBS	EQU	11
ORD_FREEPROPERTYLIB	EQU	12
ORD_ADDPROPERTYSHEET	EQU	13
ORD_REMOVEPROPERTYSHEET	EQU	14
ORD_LOADPROPERTYSHEETS	EQU	15
ORD_ENUMPROPERTYSHEETS	EQU	16
ORD_FREEPROPERTYSHEETS	EQU	17
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\port1632.h ===
/***************************************************************************\
* Module Name: 1632PORT.H
*
* Copyright (c) 1985-1994, Microsoft Corporation
*
* Master include file for Portable Windows applications.
*
\***************************************************************************/

/*
 * This file maps a Meta-API for Windows to specific 16-bit or 32-bit forms
 * allowing a single portable C source for windows to work on multiple
 * versions of Windows.
 */

#ifndef _PORT1632_
#define _PORT1632_

#if defined(WIN16)
/* ---------------- Maps to windows 3.0 and 3.1 16-bit APIs ----------------*/
#include "ptypes16.h"
#include "pwin16.h"
#include "plan16.h"
/* -------------------------------------------------------------------------*/

#elif defined(WIN32)
/* ---------------- Maps to windows 3.2 and 4.0 32-bit APIs ----------------*/
#include "ptypes32.h"
#include "pcrt32.h"
#include "pwin32.h"
#include "plan32.h"
/* -------------------------------------------------------------------------*/
#else
#error You must define either WIN32 or WIN16
#endif /* WIN32 or WIN16 */
#endif /* ndef _PORT1632_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\penwin.h ===
/****************************************************************************\
*                                                                            *
* penwin.h -    Pen Windows functions, types, and definitions                *
*                                                                            *
*               Version 2.0                                                  *
*                                                                            *
*               Copyright (c) 1992-1993 Microsoft Corp. All rights reserved. *
*                                                                            *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file;
* (indented identifiers are included by the previous main identifier):
*
* #define:				To prevent inclusion of:
*
* PENVER					Pen Windows version number (0x0200).  To exclude
*							definitions introduced in version 2.0 (or above)
*							#define PENVER 0x0100 before #including <penwin.h>
*
* NOPENALC           Alphabet Code definitions and macros
* NOPENAPPS				Pen Applications: Screen Keyboard
* NOPENCTL				H/BEDIT, IEDIT, and pen-enabled USER controls, including:
*   NOPENBEDIT			 : Boxed Edit Control
*   NOPENIEDIT			 : Ink Edit Control
*   NOPENHEDIT        : (H)Edit control
* NOPENDATA				PenData APIs and definitions
* NOPENDICT				Dictionary support
* NOPENDRIVER			Pen Driver definitions, incl OEM
* NOPENGEST				Gesture macros and Gesture Mapper (1.0)
* NOPENHRC				Handwriting Recognizer APIs and definitions
* NOPENINKPUT			Inking and Input APIs and definitions
* NOPENMISC				Miscellaneous Info and Utility APIs and definitions
* NOPENMSGS				Pen Messages and definitions
* NOPENNLS				National Language Support
* NOPENRC1				Recognition Context APIs and definitions (1.0)
* NOPENRES				Pen resources, including:
*   NOPENBMP			 : Pen-related bitmaps
*   NOPENCURS			 : Pen-related cursors
* NOPENTARGET			Targeting APIs and definitions
* NOPENVIRTEVENT		Virtual Event layer APIs
*
* WINPAD             non-WinPad components, subincludes:
*                     : NOPENAPPS, NOPENDICT, NOPENGEST, NOPENRC1
*
* "FBC" in the comments means that the feature exists only for
* backward compatibility. It should not be used by new applications.
\****************************************************************************/

#ifndef _INC_PENWIN
#define _INC_PENWIN

#include <windows.h>

#ifndef RC_INVOKED
#pragma pack(1)
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


#ifndef PENVER		/* may be pre-defined; otherwise assume version 2.0 */
	#define PENVER  0x0200
#endif //!PENVER

#ifdef WINPAD
	#define NOPENAPPS
	#define NOPENDICT
	#define NOPENGEST
	#define NOPENRC1
#endif //WINPAD

#ifndef NOPENAPPS	// not available in WINPAD
#ifndef RC_INVOKED
	#include <skbapi.h>
#endif /* !RC_INVOKED */
#endif /*!NOPENAPPS */

// other subsets:

#ifdef NOPENCTL
	#define NOPENBEDIT
	#define NOPENIEDIT
#endif /* NOPENCTL */

#ifdef NOPENRES
	#define NOPENBMP
	#define NOPENCURS
#endif /* NOPENRES */


//////////////////////////////////////////////////////////////////////////////
/****** Definitions 1: for everything including RC compiler *****************/

//---------------------------------------------------------------------------
#ifndef NOPENALC

// Enabled Alphabet:
#define ALC_DEFAULT				0x00000000L	// nothing
#define ALC_LCALPHA				0x00000001L	// a..z
#define ALC_UCALPHA				0x00000002L	// A..Z
#define ALC_NUMERIC				0x00000004L	// 0..9
#define ALC_PUNC					0x00000008L	// !-;`"?()&.,; and backslash
#define ALC_MATH					0x00000010L	// %^*()-+={}<>,/.
#define ALC_MONETARY				0x00000020L	// ,.$ or local
#define ALC_OTHER					0x00000040L	// @#|_~[]
#define ALC_ASCII					0x00000080L	// restrict to 7-bit chars 20..7f
#define ALC_WHITE					0x00000100L	// white space
#define ALC_NONPRINT				0x00000200L	// sp tab ret ctrl glyphs
#define ALC_DBCS					0x00000400L	// allow DBCS variety of SBCS
#define ALC_JIS1					0x00000800L	// kanji JPN, ShiftJIS 1 only
#define ALC_GESTURE				0x00004000L	// gestures
#define ALC_USEBITMAP			0x00008000L	// use rc.rgbfAlc to enable chars
#define ALC_HIRAGANA				0x00010000L	// hiragana JPN
#define ALC_KATAKANA				0x00020000L	// katakana JPN
#define ALC_KANJI					0x00040000L	// kanji JPN, ShiftJIS 1+2+3
#define ALC_OEM					0x0FF80000L	// OEM recognizer-specific
#define ALC_RESERVED				0xF0003000L	// avail for future use
#define ALC_NOPRIORITY			0x00000000L	// for alcPriority == none

#define ALC_ALPHA\
	(ALC_LCALPHA | ALC_UCALPHA)											// 0x00000003L

#define ALC_ALPHANUMERIC\
	(ALC_ALPHA | ALC_NUMERIC)												// 0x00000007L

#define ALC_SYSMINIMUM\
	(ALC_ALPHANUMERIC | ALC_PUNC | ALC_WHITE | ALC_GESTURE) 		// 0x0000410FL	

#define ALC_ALL\
	(ALC_SYSMINIMUM | ALC_MATH | ALC_MONETARY\
	| ALC_OTHER | ALC_NONPRINT)											// 0x0000437FL

#define ALC_KANJISYSMINIMUM\
	(ALC_SYSMINIMUM | ALC_HIRAGANA | ALC_KATAKANA | ALC_JIS1)	// 0x0003490FL

#define ALC_KANJIALL\
	(ALC_ALL | ALC_HIRAGANA | ALC_KATAKANA | ALC_KANJI)			// 0x0007437FL

#endif /*!NOPENALC */


//---------------------------------------------------------------------------
#ifndef NOPENBMP

// Public Bitmaps :
#define OBM_SKBBTNUP				32767
#define OBM_SKBBTNDOWN			32766
#define OBM_SKBBTNDISABLED		32765

#define OBM_ZENBTNUP				32764
#define OBM_ZENBTNDOWN			32763
#define OBM_ZENBTNDISABLED		32762

#define OBM_HANBTNUP				32761
#define OBM_HANBTNDOWN			32760
#define OBM_HANBTNDISABLED		32759

#define OBM_KKCBTNUP				32758
#define OBM_KKCBTNDOWN			32757
#define OBM_KKCBTNDISABLED		32756

#define OBM_SIPBTNUP				32755
#define OBM_SIPBTNDOWN			32754
#define OBM_SIPBTNDISABLED		32753

#define OBM_PTYBTNUP				32752
#define OBM_PTYBTNDOWN			32751
#define OBM_PTYBTNDISABLED		32750
#endif /*!NOPENBMP */


//---------------------------------------------------------------------------
#ifndef NOPENCURS
// Default pen cursor to indicate writing, points northwest
#define IDC_PEN					MAKEINTRESOURCE(32631)

// alternate select cursor: upsidedown standard arrow, points southeast
#define IDC_ALTSELECT			MAKEINTRESOURCE(32501)

#endif /*!NOPENCURS */


//---------------------------------------------------------------------------
#ifndef NOPENBEDIT
// box edit styles:
#define BXS_NONE					0x0000U	// none
#define BXS_RECT					0x0001U	// use rectangle instead of cusp
#define BXS_BOXCROSS				0x0004U	// use cross at box center
#define BXS_MASK					0x0007U	// mask for above

#endif /*!NOPENBEDIT */

//---------------------------------------------------------------------------
#ifndef NOPENIEDIT

// IEdit Pop-up Menu Command Items
#define IEM_UNDO					1			// Undo
#define IEM_CUT					2			// Cut
#define IEM_COPY					3			// Copy
#define IEM_PASTE					4			// Paste
#define IEM_CLEAR					5			// Clear 
#define IEM_SELECTALL			6			// Select All Strokes
#define IEM_ERASE					7			// Use Eraser
#define IEM_PROPERTIES			8			// DoProperties
#define IEM_HELP					9			// Help
#define IEM_LASSO					10			// Use Lasso
#define IEM_RESIZE				11			// Resize
// #define IEM_EDIT		  		12			// Edit... (Formats)
// #define IEM_COLOR				13			// Ink Color
// #define IEM_NIB		  		14			// Ink Nib
// #define IEM_SELECT	  		15			// Select...	
// #define IEM_OPTIONS	  		16			// Options...
//								  		17-99		// Reserved
#define IEM_USER					100		// first menu item# available to app

// IEdit Style Attributes
#define IES_BORDER				0x0001	// ctl has a border
#define IES_HSCROLL				0x0002	// ctl is horizontally scrollable
#define IES_VSCROLL				0x0004	// ctl is vertically scrollable
#define IES_OWNERDRAW			0x0008	// ctl will be drawn by parent window
#ifdef WINPAD
#define IES_READONLY				0x0010	// ctl is read only
#define IES_NTPARENT				0x0020	// 
#endif //WINPAD

#endif /*!NOPENIEDIT */


#ifndef RC_INVOKED	// ... rest of file of no interest to rc compiler
//////////////////////////////////////////////////////////////////////////////

/****** Definitions 2: RC compiler excluded ********************************/

//---------------------------------------------------------------------------
#ifndef NOPENDATA

// PenData API constants:


// ANIMATEINFO callback options:
#define AI_CBSTROKE				0xFFFF 	// Animate callback after every stroke

// ANIMATEINFO options:
#define AI_SKIPUPSTROKES		0x0001	// ignore upstrokes in animation

// CompressPenData() API options:
#define CMPD_COMPRESS			0x0001
#define CMPD_DECOMPRESS			0x0002

// CreatePenDataRegion types:
#define CPDR_BOX					1			// bounding box
#define CPDR_LASSO				2			// lasso

// CreatePenData (CPD) and Pen Hardware (PHW) Flags;
// The order of PHW flags is important:
#define CPD_DEFAULT				0x047F	// CPD_TIME | PHW_ALL
#define CPD_USERBYTE				0x0100	// alloc 8 bits/stroke
#define CPD_USERWORD				0x0200	// alloc 16 bits/stroke
#define CPD_USERDWORD			0x0300	// alloc 32 bits/stroke
#define CPD_TIME					0x0400	// maintain abs time info per stroke

// DrawPenDataEx() flags/options:
#define DPD_HDCPEN				0x0001	// use pen selected in HDC
#define DPD_DRAWSEL				0x0002 	// draw the selection

// ExtractPenDataPoints options (EPDP_xx):
#define EPDP_REMOVE				0x0001	// Remove points from the pendata

// ExtractPenDataStrokes options and modifiers (EPDS_xx):
#define EPDS_SELECT				1			// selected strokes
#define EPDS_STROKEINDEX		2			// index
#define EPDS_USER					3			// user-specific value
#define EPDS_PENTIP				4			// complete pentip
#define EPDS_TIPCOLOR			5			// pentip color
#define EPDS_TIPWIDTH			6			// pentip width
#define EPDS_TIPNIB				7			// pentip nib style
#define EPDS_INKSET				8			// inkset match

#define EPDS_EQ					0x0000	// default: same as
#define EPDS_LT					0x0010	// all strokes less than
#define EPDS_GT					0x0020	// all strokes greater than
#define EPDS_NOT					0x0040	// all strokes not matching
#define EPDS_NE					0x0040	// alias
#define EPDS_GTE					0x0050	// alias for NOT LT
#define EPDS_LTE					0x0060	// alias for NOT GT

#define EPDS_REMOVE				0x8000	// remove matching strokes from source

// GetPenDataAttributes options (GPA_xx):
#define GPA_MAXLEN				1	// length of longest stroke
#define GPA_POINTS				2	// total number of points
#define GPA_PDTS					3	// PDTS_xx bits
#define GPA_RATE					4	// get sampling rate
#define GPA_RECTBOUND			5	// bounding rect of all points
#define GPA_RECTBOUNDINK		6	// ditto, adj for fat ink
#define GPA_SIZE					7	// size of pendata in bytes
#define GPA_STROKES				8	// total number of strokes
#define GPA_TIME					9	// absolute time at creation of pendata
#define GPA_USER					10	// number of user bytes available: 0, 1, 2, 4
#define GPA_VERSION				11	// version number of pendata

// GetStrokeAttributes options (GSA_xx):
#define GSA_PENTIP				1	// get stroke pentip (color, width, nib)
#define GSA_PENTIPCLASS			2	// same as GSA_PENTIP
#define GSA_USER					3	// get stroke user value
#define GSA_USERCLASS			4	// get stroke's class user value
#define GSA_TIME					5	// get time of stroke
#define GSA_SIZE					6	// get size of stroke in points and bytes
#define GSA_SELECT				7	// get selection status of stroke
#define GSA_DOWN					8	// get up/down state of stroke
#define GSA_RECTBOUND			9	// get the bounding rectangle of the stroke

// GetStrokeTableAttributes options (GSA_xx):
#define GSA_PENTIPTABLE			10	// get table-indexed pentip
#define GSA_SIZETABLE			11	// get count of Stroke Class Table entries
#define GSA_USERTABLE			12	// get table-indexed user value


#ifndef IX_END
#define IX_END						0xFFFF	// to or past last available index
#endif //!IX_END

// PenTip:
#define PENTIP_NIBDEFAULT		((BYTE)0)		// default pen tip nib style
#define PENTIP_HEIGHTDEFAULT	((BYTE)0)		// default pen tip nib height
#define PENTIP_OPAQUE			((BYTE)0xFF)	// default opaque ink
#define PENTIP_HILITE			((BYTE)0x80)
#define PENTIP_TRANSPARENT		((BYTE)0)

// General PenData API return values (PDR_xx):
#define PDR_NOHIT					3			// hit test failed
#define PDR_HIT					2			// hit test succeeded
#define PDR_OK						1			// success
#define PDR_CANCEL				0			// callback cancel or impasse

#define PDR_ERROR					(-1)		// parameter or unspecified error
#define PDR_PNDTERR				(-2)		// bad pendata
#define PDR_VERSIONERR			(-3)		// pendata version error
#define PDR_COMPRESSED			(-4)		// pendata is compressed
#define PDR_STRKINDEXERR		(-5)		// stroke index error
#define PDR_PNTINDEXERR			(-6)		// point index error
#define PDR_MEMERR				(-7)		// memory error
#define PDR_INKSETERR			(-8)		// bad inkset
#define PDR_ABORT					(-9)		// pendata has become invalid, e.g.
#define PDR_NA						(-10)		// option not available (pw kernel)

#define PDR_USERDATAERR			(-16)		// user data error
#define PDR_SCALINGERR			(-17)		// scale error
#define PDR_TIMESTAMPERR		(-18)		// timestamp error
#define PDR_OEMDATAERR			(-19)		// OEM data error
#define PDR_SCTERR				(-20)		// SCT error (full)

// PenData Scaling (PDTS):
#define PDTS_LOMETRIC			0			// 0.01mm
#define PDTS_HIMETRIC			1			// 0.001mm
#define PDTS_HIENGLISH			2			// 0.001"
#define PDTS_STANDARDSCALE		2			// PDTS_HIENGLISH	alias
#define PDTS_DISPLAY				3			// display pixel
#define PDTS_ARBITRARY			4			// app-specific scaling
#define PDTS_SCALEMASK			0x000F	// scaling values in low nibble

// CompactPenData() API trim options:
#define PDTT_DEFAULT				0x0000         
#define PDTT_PENINFO				0x0100
#define PDTT_UPPOINTS			0x0200
#define PDTT_OEMDATA				0x0400
#define PDTT_COLLINEAR			0x0800 
#define PDTT_COLINEAR			0x0800 	// alt sp alias
#define PDTT_DECOMPRESS			0x4000	// decompress the data
#define PDTT_COMPRESS			0x8000
#define PDTT_ALL					0x0F00	// PENINFO|UPPOINTS|OEMDATA|COLLINEAR

#define PHW_NONE					0x0000	// no OEMdata
#define PHW_PRESSURE				0x0001	// report pressure in OEMdata if avail
#define PHW_HEIGHT				0x0002	// ditto height
#define PHW_ANGLEXY				0x0004	// ditto xy angle
#define PHW_ANGLEZ				0x0008	// ditto z angle
#define PHW_BARRELROTATION		0x0010	// ditto barrel rotation
#define PHW_OEMSPECIFIC			0x0020	// ditto OEM-specific value
#define PHW_PDK					0x0040	// report per-point PDK_xx in OEM data
#define PHW_ALL					0x007F	// report everything


// compact pen data trim options: matches PDTT_values (see above)
#define PDTS_COMPRESS2NDDERIV	0x0010	// compress using 2nd deriv
#define PDTS_COMPRESSMETHOD	0x00F0	// sum of compress method flags
#define PDTS_NOPENINFO			0x0100	// removes PENINFO struct from header
#define PDTS_NOUPPOINTS			0x0200	// remove up pts
#define PDTS_NOOEMDATA			0x0400	// remove OEM data
#define PDTS_NOCOLLINEAR		0x0800	// remove successive identical pts
#define PDTS_NOCOLINEAR			0x0800	// alt sp alias
#define PDTS_NOTICK				0x1000	// remove timing info (2.0)
#define PDTS_NOUSER				0x2000	// remove user info (2.0)
#define PDTS_NOEMPTYSTROKES	0x4000	// remove empty strokes (2.0)
#define PDTS_COMPRESSED			0x8000	// perform lossless compression


// SetStrokeAttributes options (SSA_xx):
#define SSA_PENTIP				1			// set stroke tip (color, width, nib)
#define SSA_PENTIPCLASS			2			// set stroke's class pentip
#define SSA_USER					3			// set stroke user value
#define SSA_USERCLASS			4			// set stroke's class user value
#define SSA_TIME					5			// set time of stroke
#define SSA_SELECT				6			// set selection status of stroke
#define SSA_DOWN					7			// set up/down state of stroke

// SetStrokeTableAttributes options (SSA_xx):
#define SSA_PENTIPTABLE			8			// set table-indexed pentip
#define SSA_USERTABLE			9			// set table-indexed user value

// PenTip flag bits:
#define TIP_ERASECOLOR			1			// erase specific color pentip.rgb

// TrimPenData() API options:
#define TPD_RECALCSIZE			0x0000	// no trim, used for resize calc
#define TPD_USER					0x0080	// per-stroke user info
#define TPD_TIME					0x0100	// per-stroke timing info
#define TPD_UPPOINTS				0x0200	// x-y data up points
#define TPD_COLLINEAR			0x0400	// colinear and coincident points
#define TPD_COLINEAR				0x0400	// alt sp alias
#define TPD_PENINFO				0x0800	// PenInfo struct and all OEM
#define TPD_PHW					0x1000	// OEM & pdk except stroke tick or user
#define TPD_OEMDATA				0x1000	// ditto
#define TPD_EMPTYSTROKES		0x2000	// strokes with zero points
#define TPD_EVERYTHING			0x3FFF	// everything (incl PHW_xx) except down pts

#endif /*!NOPENDATA */

//---------------------------------------------------------------------------
#ifndef NOPENDICT	// not available in WINPAD

// Dictionary:
#define cbDictPathMax			255
#define DIRQ_QUERY				1
#define DIRQ_DESCRIPTION		2
#define DIRQ_CONFIGURE			3
#define DIRQ_OPEN					4
#define DIRQ_CLOSE				5
#define DIRQ_SETWORDLISTS		6
#define DIRQ_STRING				7
#define DIRQ_SUGGEST				8
#define DIRQ_ADD					9
#define DIRQ_DELETE				10
#define DIRQ_FLUSH				11
#define DIRQ_RCCHANGE			12
#define DIRQ_SYMBOLGRAPH		13
#define DIRQ_INIT					14
#define DIRQ_CLEANUP				15
#define DIRQ_COPYRIGHT			16
#define DIRQ_USER					4096
#endif /*!NOPENDICT */


//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

// Pen driver:
#define BITPENUP					0x8000

// Pen Driver messages:
#define DRV_SetPenDriverEntryPoints    DRV_RESERVED+1
#define DRV_RemovePenDriverEntryPoints DRV_RESERVED+2
#define DRV_SetPenSamplingRate         DRV_RESERVED+3
#define DRV_SetPenSamplingDist         DRV_RESERVED+4
#define DRV_GetName                    DRV_RESERVED+5
#define DRV_GetVersion                 DRV_RESERVED+6
#define DRV_GetPenInfo                 DRV_RESERVED+7
#define DRV_PenPlayStart					DRV_RESERVED+8
#define DRV_PenPlayBack						DRV_RESERVED+9
#define DRV_PenPlayStop						DRV_RESERVED+10
#define DRV_GetCalibration             DRV_RESERVED+11
#define DRV_SetCalibration             DRV_RESERVED+12

#define MAXOEMDATAWORDS			6			// rgwOemData[MAXOEMDATAWORDS]

// Pen Collection Mode termination conditions:
// (note update doc for PCMINFO struct if change these)
#define PCM_PENUP					0x00000001L	// stop on penup
#define PCM_RANGE					0x00000002L	// stop on leaving range
#define PCM_INVERT				0x00000020L	// stop on tap of opposite end
#define PCM_RECTEXCLUDE			0x00002000L	// click in exclude rect
#define PCM_RECTBOUND			0x00004000L	// click outside bounds rect
#define PCM_TIMEOUT				0x00008000L	// no activity for timeout ms
// new for 2.0:
#define PCM_RGNBOUND				0x00010000L   // click outside bounding region
#define PCM_RGNEXCLUDE			0x00020000L   // click in exclude region
#define PCM_DOPOLLING			0x00040000L   // polling mode
#define PCM_TAPNHOLD				0x00080000L   // check for Tap And Hold
//#define PCM_VERMASK				0x70000000L   TODO
#define PCM_ADDDEFAULTS			RC_LDEFAULTFLAGS /* 0x80000000L */

// Pen Device Capabilities:
#define PDC_INTEGRATED			0x00000001L	// display==digitizer
#define PDC_PROXIMITY			0x00000002L	// detect non-contacting pen
#define PDC_RANGE					0x00000004L	// event on out-of-range
#define PDC_INVERT				0x00000008L	// pen opposite end detect
#define PDC_RELATIVE				0x00000010L	// pen driver coords
#define PDC_BARREL1				0x00000020L	// barrel button 1 present
#define PDC_BARREL2				0x00000040L	// ditto 2
#define PDC_BARREL3				0x00000080L	// ditto 3

// Pen Driver Kit states:
#define PDK_NULL					0x0000	// default to no flags set
#define PDK_UP						0x0000	// PDK_NULL alias
#define PDK_DOWN					0x0001	// pentip switch ON due to contact
#define PDK_BARREL1				0x0002	// barrel1 switch depressed
#define PDK_BARREL2				0x0004	// ditto 2
#define PDK_BARREL3				0x0008	// ditto 3
#define PDK_SWITCHES				0x000f	// sum of down + barrels 1,2,3
#define PDK_TRANSITION			0x0010	// set by GetPenHwData
#define PDK_UNUSED10				0x0020
#define PDK_UNUSED20				0x0040
#define PDK_INVERTED				0x0080	// other end of pen used as tip
#define PDK_PENIDMASK			0x0F00	// bits 8..11 physical pen id (0..15)
#define PDK_UNUSED1000			0x1000
#define PDK_INKSTOPPED			0x2000  // Inking stopped
#define PDK_OUTOFRANGE			0x4000	// pen left range (OEM data invalid)
#define PDK_DRIVER				0x8000	// pen (not mouse) event

#define PDK_TIPMASK				0x0001	// mask for testing PDK_DOWN

// OEM-specific values for Pen Driver:
#define PDT_NULL					0
#define PDT_PRESSURE				1			// pressure supported
#define PDT_HEIGHT				2			// height above tablet
#define PDT_ANGLEXY				3			// xy (horiz) angle supported
#define PDT_ANGLEZ				4			// z (vert) angle supported
#define PDT_BARRELROTATION		5			// barrel is rotated
#define PDT_OEMSPECIFIC			16		// max

// Denotes the ID of the current packet
#define PID_CURRENT				(UINT)(-1)

// Recognition and GetPenHwData Returns:
#define REC_OEM					(-1024)	// first recognizer-specific debug val
#define REC_LANGUAGE				(-48)	// unsupported language field
#define REC_GUIDE					(-47)	// invalid GUIDE struct
#define REC_PARAMERROR			(-46)	// bad param
#define REC_INVALIDREF			(-45)	// invalid data ref param
#define REC_RECTEXCLUDE			(-44)	// invalid rect
#define REC_RECTBOUND			(-43)	// invalid rect
#define REC_PCM					(-42)	// invalid lPcm parameter
#define REC_RESULTMODE			(-41)
#define REC_HWND					(-40)	// invalid window to send results to
#define REC_ALC					(-39)	// invalid enabled alphabet
#define REC_ERRORLEVEL			(-38)	// invalid errorlevel
#define REC_CLVERIFY				(-37)	// invalid verification level
#define REC_DICT					(-36)	// invalid dict params
#define REC_HREC					(-35)	// invalid recognition handle
#define REC_BADEVENTREF			(-33)	// invalid wEventRef
#define REC_NOCOLLECTION		(-32)	// collection mode not set
#define REC_DEBUG					(-32) // beginning of debug values
#define REC_POINTEREVENT		(-31)	// tap or tap&hold event
#define REC_BADHPENDATA			(-9)  // invalid hpendata header or locking
#define REC_OOM					(-8)	// out of memory error
#define REC_NOINPUT				(-7)	// no data collected before termination
#define REC_NOTABLET				(-6)	// tablet not physically present
#define REC_BUSY					(-5)	// another task is using recognizer
#define REC_BUFFERTOOSMALL		(-4)	// ret by GetPenHwEventData()
#define REC_ABORT					(-3)	// recog stopped by EndPenCollection()
#define REC_NA						(-2)	// function not available
#define REC_OVERFLOW				(-1)	// data overflow
#define REC_OK						0		// interrim completion
#define REC_TERMBOUND			1		// hit outside bounding rect
#define REC_TERMEX				2		// hit inside exclusion rect
#define REC_TERMPENUP			3		// pen up
#define REC_TERMRANGE			4		// pen left proximity
#define REC_TERMTIMEOUT			5		// no writing for timeout ms
#define REC_DONE					6		// normal completion
#define REC_TERMOEM				512	// first recognizer-specific retval

#endif /*!NOPENDRIVER */


//---------------------------------------------------------------------------
#ifndef NOPENGEST	// not available in WINPAD

// Gesture Mapping aliases:
#define MAP_GESTOGES				(RCRT_GESTURE|RCRT_GESTURETRANSLATED)
#define MAP_GESTOVKEYS			(RCRT_GESTURETOKEYS|RCRT_ALREADYPROCESSED)

#endif /*!NOPENGEST */


//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:

// GetResultsHRC options:
#define GRH_ALL					0			// get all results
#define GRH_GESTURE				1			// get only gesture results
#define GRH_NONGESTURE			2			// get all but gesture results

// Gesture sets for EnableGestureSetHRC (bit flags):
#define GST_SEL					0x00000001L		// sel & lasso
#define GST_CLIP					0x00000002L		// cut copy paste
#define GST_WHITE					0x00000004L		// sp bs tab ret
#define GST_DEL					0x00000008L		// clear clearword
#define GST_EDIT					0x00000010L		// insert correct undo
#define GST_SYS					0x0000001FL		// all of the above
#define GST_CIRCLELO				0x00000100L		// lowercase circle
#define GST_CIRCLEUP				0x00000200L		// uppercase circle
#define GST_CIRCLE				0x00000300L		// all circle
#define GST_ALL					0x0000031FL		// all of the above

// General HRC API return values (HRCR_xx):
#define HRCR_NORESULTS			4			// No possible results  to be found
#define HRCR_COMPLETE			3			// finished recognition
#define HRCR_GESTURE				2			// recognized gesture
#define HRCR_OK					1			// success
#define HRCR_INCOMPLETE			0			// recognizer is processing input
#define HRCR_ERROR				(-1)		// invalid param or unspecified error
#define HRCR_MEMERR				(-2)		// memory error
#define HRCR_INVALIDGUIDE		(-3)		// invalid GUIDE struct
#define HRCR_INVALIDPNDT		(-4)		// invalid pendata
#define HRCR_UNSUPPORTED		(-5)		// recognizer does not support feature
#define HRCR_CONFLICT			(-6)		// training conflict
#define HRCR_HOOKED				(-8)		// hookasaurus ate the result

// system wordlist for AddWordsHWL:
#define HWL_SYSTEM				((HWL)1)	// magic value means system wordlist

// inkset returns:
#define ISR_ERROR					(-1)		// Memory or other error
#define ISR_BADINKSET			(-2)		// bad source inkset
#define ISR_BADINDEX				(-3)		// bad inkset index

#ifndef IX_END
#define IX_END						0xFFFF	// to or past last available index
#endif //!IX_END

#define MAXHOTSPOT				8			// max number of hotspots possible

// ProcessHRC time constants:
#define PH_MAX						0xFFFFFFFFL	// recognize rest of ink
#define PH_DEFAULT				0xFFFFFFFEL	// reasonable time
#define PH_MIN						0xFFFFFFFDL	// minimum time

// ResultsHookHRC options:
#define RHH_STD					0			// GetResultsHRC
#define RHH_BOX					1			// GetBoxResultsHRC

// SetWordlistCoercionHRC options:
#define SCH_NONE					0			// turn off coercion
#define SCH_REJECT				1			// recog results rejected if no match
#define SCH_ADVISE				2			// macro is hint only
#define SCH_FORCE					3			// some result is forced from macro

// Symbol Context Insert Modes
#define SCIM_INSERT				0			// insert
#define SCIM_OVERWRITE			1			// overwrite

// SetResultsHookHREC options:
#define SRH_HOOKALL				(HREC)1	// hook all recognizers

// SetInternationalHRC options:
#define SSH_RD						1			// to right and down (English)
#define SSH_RU						2			// to right and up
#define SSH_LD						3			// to left and down (Hebrew)
#define SSH_LU						4			// to left and up
#define SSH_DL						5			// down and to the left (Chinese)
#define SSH_DR						6			// down and to the right (Chinese)
#define SSH_UL						7			// up and to the left
#define SSH_UR						8			// up and to the right

#define SIH_ALLANSICHAR			1			// use all ANSI

// special SYV values:
#define SYV_NULL					0x00000000L
#define SYV_UNKNOWN				0x00000001L
#define SYV_EMPTY					0x00000003L
#define SYV_BEGINOR				0x00000010L
#define SYV_ENDOR					0x00000011L
#define SYV_OR						0x00000012L
#define SYV_SOFTNEWLINE			0x00000020L
#define SYV_SPACENULL			0x00010000L	// SyvCharacterToSymbol('\0')

// SYV values for gestures:
#define SYV_SELECTFIRST			0x0002FFC0L   // . means circle in following
#define SYV_LASSO					0x0002FFC1L   // lasso o-tap
#define SYV_SELECTLEFT			0x0002FFC2L   // no glyph
#define SYV_SELECTRIGHT			0x0002FFC3L   // no glyph
#define SYV_SELECTLAST			0x0002FFCFL   // 16 SYVs reserved for selection

#define SYV_CLEARCHAR			0x0002FFD2L   // d.
#define SYV_HELP					0x0002FFD3L   // no glyph
#define SYV_KKCONVERT			0x0002FFD4L   // k.
#define SYV_CLEAR					0x0002FFD5L   // d.
#define SYV_INSERT				0x0002FFD6L   // ^.
#define SYV_CONTEXT				0x0002FFD7L   // m.
#define SYV_EXTENDSELECT		0x0002FFD8L   // no glyph
#define SYV_UNDO					0x0002FFD9L   // u.
#define SYV_COPY					0x0002FFDAL   // c.
#define SYV_CUT					0x0002FFDBL   // x.
#define SYV_PASTE					0x0002FFDCL   // p.
#define SYV_CLEARWORD			0x0002FFDDL   // no glyph
#define SYV_USER					0x0002FFDEL   // reserved
#define SYV_CORRECT				0x0002FFDFL   // check.

#define SYV_BACKSPACE			0x00020008L   // no glyph
#define SYV_TAB					0x00020009L   // t.
#define SYV_RETURN				0x0002000DL   // n.
#define SYV_SPACE					0x00020020L   // s.

// Application specific gestures, Circle a-z and Circle A-Z:
#define SYV_APPGESTUREMASK		0x00020000L
#define SYV_CIRCLEUPA			0x000224B6L		// map into Unicode space
#define SYV_CIRCLEUPZ			0x000224CFL		// 	for circled letters
#define SYV_CIRCLELOA			0x000224D0L
#define SYV_CIRCLELOZ			0x000224E9L

// SYV definitions for shapes:
#define SYV_SHAPELINE			0x00040001L
#define SYV_SHAPEELLIPSE		0x00040002L
#define SYV_SHAPERECT			0x00040003L
#define SYV_SHAPEMIN				SYV_SHAPELINE	// alias
#define SYV_SHAPEMAX				SYV_SHAPERECT	// alias

// SYV classes:
#define SYVHI_SPECIAL			0
#define SYVHI_ANSI				1
#define SYVHI_GESTURE			2
#define SYVHI_KANJI				3
#define SYVHI_SHAPE				4
#define SYVHI_UNICODE			5
#define SYVHI_VKEY				6

// TrainHREC options:
#define TH_QUERY					0			// query the user if conflict
#define TH_FORCE					1			// ditto no query
#define TH_SUGGEST				2			// abandon training if conflict

// Return values for WCR_TRAIN Function
#define TRAIN_NONE				0x0000
#define TRAIN_DEFAULT			0x0001
#define TRAIN_CUSTOM				0x0002
#define TRAIN_BOTH				(TRAIN_DEFAULT | TRAIN_CUSTOM)

// Control values for TRAINSAVE
#define TRAIN_SAVE				0			// save changes that have been made
#define TRAIN_REVERT				1			// discard changes that have been made
#define TRAIN_RESET				2			// use factory settings

// ConfigRecognizer and ConfigHREC options:
#define WCR_RECOGNAME			0			// ConfigRecognizer 1.0
#define WCR_QUERY					1
#define WCR_CONFIGDIALOG		2
#define WCR_DEFAULT				3
#define WCR_RCCHANGE				4
#define WCR_VERSION				5
#define WCR_TRAIN					6
#define WCR_TRAINSAVE			7
#define WCR_TRAINMAX				8
#define WCR_TRAINDIRTY			9
#define WCR_TRAINCUSTOM			10
#define WCR_QUERYLANGUAGE		11
#define WCR_USERCHANGE			12

// ConfigHREC options:
#define WCR_PWVERSION			13			// ver of PenWin recognizer supports
#define WCR_GETALCPRIORITY		14			// get recognizer's ALC priority
#define WCR_SETALCPRIORITY		15			// set recognizer's ALC priority
#define WCR_GETANSISTATE		16			// get ALLANSICHAR state
#define WCR_SETANSISTATE		17			// set ALLANSICHAR if T

#define WCR_PRIVATE				1024

// sub-functions of WCR_USERCHANGE
#define CRUC_NOTIFY				0			// user name change
#define CRUC_REMOVE				1			// user name deleted

// Word List Types:
#define WLT_STRING				0			// one string
#define WLT_STRINGTABLE			1			// array of strings
#define WLT_EMPTY					2			// empty wordlist
#define WLT_WORDLIST				3			// handle to a wordlist

#endif /*!NOPENHRC */

//---------------------------------------------------------------------------
#ifndef NOPENIEDIT

// IEdit Background Options
#define IEB_DEFAULT				0			// default (use COLOR_WINDOW)
#define IEB_BRUSH					1			// paint background with brush
#define IEB_BIT_UL				2			// bitmap, upper-left aligned
#define IEB_BIT_CENTER			3			// bitmap, centered in control
#define IEB_BIT_TILE				4			// bitmap, tiled repeatedly in ctl
#define IEB_BIT_STRETCH			5			// bitmap, stretched to fit ctl
#define IEB_OWNERDRAW			6			// parent window will draw background

// IEdit Drawing Options
#define IEDO_NONE					0x0000	// no drawing
#define IEDO_FAST					0x0001	// ink drawn as fast as possible (def)
#define IEDO_SAVEUPSTROKES		0x0002	// save upstrokes
#define IEDO_RESERVED			0xFFFC	// reserved bits

// IEdit Input Options
#define IEI_MOVE					0x0001	// move ink into ctl
#define IEI_RESIZE				0x0002	// resize ink to fit within ctl
#define IEI_CROP					0x0004	// discard ink outside of ctl
#define IEI_DISCARD				0x0008	// discard all ink if any outside ctl	
#define IEI_RESERVED				0xFFF0	// reserved

// IEdit IE_GETINK options
#define IEGI_ALL					0x0000	// get all ink from control
#define IEGI_SELECTION			0x0001	// get selected ink from control

// IEdit IE_SETMODE/IE_GETMODE (mode) options
#define IEMODE_READY				0			// default inking, moving, sizing mode
#define IEMODE_ERASE				1			// erasing Mode
#define IEMODE_LASSO				2			// lasso selection mode

// IEdit	Notification Bits
#define IEN_NULL					0x0000	// null notification
#define IEN_PDEVENT				0x0001	// notify about pointing device events
#define IEN_PAINT					0x0002	// send painting-related notifications
#define IEN_FOCUS					0x0004	// send focus-related notifications
#define IEN_SCROLL				0x0008	// send scrolling notifications
#define IEN_EDIT					0x0010	// send editing/change notifications
#define IEN_RESERVED				0xFFC0	// reserved

// IEdit Return Values
#define IER_OK						0			// success
#define IER_NO						0			// ctl cannot do request
#define IER_YES					1			// ctl can do request
#define IER_ERROR					(-1)		// unspecified error; operation failed
#define IER_PARAMERR				(-2)		// bogus lParam value, bad handle, etc
#define IER_OWNERDRAW			(-3)		// can't set drawopts in ownerdraw ctl
#define IER_SECURITY				(-4)		// security protection disallows action
#define IER_SELECTION			(-5)		// nothing selected in control
#define IER_SCALE					(-6)		// merge:  incompatible scaling factors
#define IER_MEMERR				(-7)		// memory error
#define IER_NOCOMMAND			(-8)		// tried IE_GETCOMMAND w/no command
#define IER_NOGESTURE			(-9)		// tried IE_GETGESTURE w/no gesture
#define IER_NOPDEVENT			(-10)		// tried IE_GETPDEVENT but no event
#define IER_NOTINPAINT			(-11)		// tried IE_GETPAINTSTRUCT but no paint
#define IER_PENDATA				(-12)		// can't do request with NULL hpd in ctl


// IEdit Recognition Options
#define IEREC_NONE				0x0000	// No recognition
#define IEREC_GESTURE			0x0001	// Gesture recognition
#define IEREC_ALL					(IEREC_GESTURE)
#define IEREC_RESERVED			0xFFFE	// Reserved

// IEdit Security Options
#define IESEC_NOCOPY				0x0001	// copying disallowed
#define IESEC_NOCUT				0x0002	// cutting disallowed
#define IESEC_NOPASTE			0x0004	// pasting disallowed
#define IESEC_NOUNDO				0x0008	// undoing disallowed
#define IESEC_NOINK				0x0010	// inking  disallowed
#define IESEC_NOERASE			0x0020	// erasing disallowed
#define IESEC_NOGET				0x0040	// IE_GETINK message verboten
#define IESEC_NOSET				0x0080	// IE_SETINK message verboten
#define IESEC_RESERVED			0xFF00	// reserved

// IEdit IE_SETFORMAT/IE_GETFORMAT options
#define IESF_ALL					0x0001	// set/get stk fmt of all ink
#define IESF_SELECTION			0x0002	// set/get stk fmt of selected ink
#define IESF_STROKE				0x0004	// set/get stk fmt of specified stroke
//
#define IESF_TIPCOLOR			0x0008	// set color
#define IESF_TIPWIDTH			0x0010	// set width
#define IESF_PENTIP				(IESF_TIPCOLOR|IESF_TIPWIDTH)
//

// IEdit IE_SETINK options
#define IESI_REPLACE				0x0000	// replace ink in control
#define IESI_APPEND				0x0001	// append ink to existing control ink

// Ink Edit Control (IEdit) definitions
// IEdit Notifications
#define IN_PDEVENT		((IEN_PDEVENT<<8)|0)	// pointing device event occurred
#define IN_ERASEBKGND	((IEN_NULL<<8)|1)		// control needs bkgnd erased
#define IN_PREPAINT		((IEN_PAINT<<8)|2)	// before control paints its ink
#define IN_PAINT			((IEN_NULL<<8)|3)		// control needs to be painted
#define IN_POSTPAINT		((IEN_PAINT<<8)|4)	// after control has painted
#define IN_MODECHANGED	((IEN_EDIT<<8)|5)		// mode changed
#define IN_CHANGE			((IEN_EDIT<<8)|6)		// contents changed & painted
#define IN_UPDATE			((IEN_EDIT<<8)|7)		// contents changed & !painted
#define IN_SETFOCUS		((IEN_FOCUS<<8)|8)	// IEdit is getting focus
#define IN_KILLFOCUS		((IEN_FOCUS<<8)|9)	// IEdit is losing focus
#define IN_MEMERR			((IEN_NULL<<8)|10)	// Memory error
#define IN_HSCROLL		((IEN_SCROLL<<8)|11)	// horz scrolled, not painted
#define IN_VSCROLL		((IEN_SCROLL<<8)|12)	// vert scrolled, not painted
#define IN_GESTURE		((IEN_EDIT<<8)|13)	// user has gestured on control
#define IN_COMMAND		((IEN_EDIT<<8)|14)	// command selected from menu
#define IN_CLOSE			((IEN_NULL<<8)|15)	// I-Edit is being closed

#endif /*!NOPENIEDIT */


//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

// PenIn[k]put API constants

// Default Processing
#define LRET_DONE					1L
#define LRET_ABORT				(-1L)
#define LRET_HRC					(-2L)
#define LRET_HPENDATA			(-3L)
#define LRET_PRIVATE				(-4L)

// Inkput:
#define PCMR_OK					0
#define PCMR_ALREADYCOLLECTING (-1)
#define PCMR_INVALIDCOLLECTION (-2)
#define PCMR_EVENTLOCK			(-3)
#define PCMR_INVALID_PACKETID	(-4)
#define PCMR_TERMTIMEOUT		(-5)
#define PCMR_TERMRANGE			(-6)
#define PCMR_TERMPENUP			(-7)
#define PCMR_TERMEX				(-8)
#define PCMR_TERMBOUND			(-9)
#define PCMR_APPTERMINATED		(-10)
#define PCMR_TAP					(-11)	// alias PCMR_TAPNHOLD_LAST
#define PCMR_SELECT				(-12)	// ret because of tap & hold
#define PCMR_OVERFLOW			(-13)
#define PCMR_ERROR				(-14)	// parameter or unspecified error
#define PCMR_DISPLAYERR			(-15)	// inking only
#define PCMR_NA					(-16)	// not available


#define PII_INKCLIPRECT			0x0001
#define PII_INKSTOPRECT			0x0002
#define PII_INKCLIPRGN			0x0004
#define PII_INKSTOPRGN			0x0008
#define PII_INKPENTIP			0x0010
#define PII_SAVEBACKGROUND		0x0020
#define PII_CLIPSTOP				0x0040

#define PIT_RGNBOUND				0x0001
#define PIT_RGNEXCLUDE			0x0002
#define PIT_TIMEOUT				0x0004
#define PIT_TAPNHOLD				0x0008

#endif /*!NOPENINKPUT */


//---------------------------------------------------------------------------
#ifndef NOPENMISC

// Misc RC Definitions:
#define CL_NULL					0
#define CL_MINIMUM				1			// minimum confidence level
#define CL_MAXIMUM				100		// max (require perfect recog)
#define cwRcReservedMax			8			// rc.rgwReserved[cwRcReservedMax]
#define ENUM_MINIMUM				1
#define ENUM_MAXIMUM				4096

#define HKP_SETHOOK				0			// SetRecogHook()
#define HKP_UNHOOK				0xFFFF

#define HWR_RESULTS				0
#define HWR_APPWIDE				1

#define iSycNull					(-1)
#define LPDFNULL					((LPDF)NULL)
#define MAXDICTIONARIES			16			// rc.rglpdf[MAXDICTIONARIES]
#define wPntAll					(UINT)0xFFFF
#define cbRcLanguageMax				44		// rc.lpLanguage[cbRcLanguageMax]
#define cbRcUserMax					32		// rc.lpUser[cbRcUserMax]
#define cbRcrgbfAlcMax				32		// rc.rgbfAlc[cbRcrgbfAlcMax]
#define RC_WDEFAULT					0xffff
#define RC_LDEFAULT					0xffffffffL
#define RC_WDEFAULTFLAGS			0x8000
#define RC_LDEFAULTFLAGS			0x80000000L

// CorrectWriting() API constants:
// LOWORD values: 
#define CWR_STRIPCR				0x0001	// strip carriage ret (\r)
#define CWR_STRIPLF				0x0002	// strip	linefeed (\n)
#define CWR_STRIPTAB				0x0004	// strip tab (\t)
#define CWR_SINGLELINEEDIT		(CWR_STRIPCR|CWR_STRIPLF|CWR_STRIPTAB)	// all of the above
#define CWR_INSERT				0x0008   // use "Insert Text" instead of "Edit Text" in the title
#define CWR_TITLE					0x0010	// interp dwReserved as LPSTR
#define CWR_KKCONVERT			0x0020	// JPN initiate IME

// HIWORD values: keyboard types
#define CWRK_DEFAULT          0   		// default keyboard type
#define CWRK_BASIC            1   		// basic keyboard
#define CWRK_FULL             2   		// full keyboard
#define CWRK_NUMPAD           3   		// numeric keyboard
#define CWRK_ATMPAD           4   		// ATM type keyboard

#ifdef JAPAN
#define GPMI_OK					0L
#define GPMI_INVALIDPMI			0x8000L
#endif // JAPAN

// inkwidth limits
#define INKWIDTH_MINIMUM		0			// 0 invisible, 1..15 pixel widths
#define INKWIDTH_MAXIMUM		15			// max width in pixels

// Get/SetPenMiscInfo:
// PMI_RCCHANGE is for WM_GLOBALRCCHANGE compatability only:
#define PMI_RCCHANGE					0	// invalid for Get/SetPenMiscInfo

#define PMI_BEDIT						1	// boxed edit info
#define PMI_IMECOLOR             2	// input method editor color
#define PMI_CXTABLET					3	// tablet width
#define PMI_CYTABLET					4	// tablet height
#define PMI_COUNTRY					5	// country
#define PMI_PENTIP					6	// pen tip: color, width, nib
#define PMI_ENABLEFLAGS				7	// PWE_xx enablements
#define PMI_TIMEOUT					8	// handwriting timeout
#define PMI_TIMEOUTGEST				9	// gesture timeout
#define PMI_TIMEOUTSEL				10	// select (press&hold) timeout
#define PMI_SYSFLAGS					11	// component load configuration
#define PMI_INDEXFROMRGB			12	// color table index from RGB
#define PMI_RGBFROMINDEX			13	// RGB from color table index
#define PMI_SYSREC					14	// handle to system recognizer
#define PMI_TICKREF					15 // reference absolute time
#define PMI_USER						16 // name of user

#define PMI_SAVE						0x1000	// save setting to file

// Set/GetPenMiscInfo/PMI_ENABLEFLAGS flags:
#define PWE_AUTOWRITE				0x0001	// pen functionality where IBeam
#define PWE_ACTIONHANDLES			0x0002	// action handles in controls
#define PWE_INPUTCURSOR				0x0004	// show cursor while writing
#define PWE_LENS						0x0008	// allow lens popup

// GetPenMiscInfo/PMI_SYSFLAGS flags:
#define PWF_RC1						0x0001	// Windows for Pen 1.0 RC support
#define PWF_PEN						0x0004	// pen drv loaded & hdwe init'd
#define PWF_INKDISPLAY				0x0008	// ink-compatible display drv loaded
#define PWF_RECOGNIZER				0x0010	// system recognizer installed
#define PWF_SKB						0x0020	// screen keyboard available
#define PWF_BEDIT						0x0100	// boxed edit support
#define PWF_HEDIT						0x0200	// free input edit support
#define PWF_IEDIT						0x0400	// ink edit support
#define PWF_ENHANCED					0x1000	// enh features (gest, 1ms timing)
#define PWF_FULL\
	PWF_RC1	|PWF_PEN		|PWF_INKDISPLAY	|PWF_RECOGNIZER	|PWF_SKB|\
	PWF_BEDIT|PWF_HEDIT	|PWF_IEDIT			|PWF_ENHANCED


// RegisterPenApp() API constants:
#define RPA_DEFAULT					0x0001	// == RPA_HEDIT
#define RPA_HEDIT						0x0001	// convert EDIT to HEDIT
#define RPA_KANJIFIXEDBEDIT		0x0002
#define RPA_DBCSPRIORITY			0x0004	// assume DBCS has priority (Japan)

#define PMIR_OK						0L
#define PMIR_INDEX					(-1L)
#define PMIR_VALUE					(-2L)
#define PMIR_INVALIDBOXEDITINFO	(-3L)
#define PMIR_INIERROR				(-4L)
#define PMIR_ERROR					(-5L)
#define PMIR_NA						(-6L)

#ifdef JAPAN
#define SPMI_OK						0L
#define SPMI_INVALIDBOXEDITINFO	1L
#define SPMI_INIERROR				2L
#define SPMI_INVALIDPMI				0x8000L
#endif //JAPAN

#endif /*!NOPENMISC */


//---------------------------------------------------------------------------
#ifndef NOPENRC1	// not available in WINPAD

// RC Options and Flags:
// GetGlobalRC() API return codes:
#define GGRC_OK					0			// no err
#define GGRC_DICTBUFTOOSMALL	1			// lpDefDict buffer too small for path
#define GGRC_PARAMERROR			2			// invalid params: call ignored
#define GGRC_NA					3			// function not available

// RC Direction:
#define RCD_DEFAULT				0			// def none
#define RCD_LR						1			// left to right like English
#define RCD_RL						2			// right to left like Arabic
#define RCD_TB						3			// top to bottom like Japanese
#define RCD_BT						4			// bottom to top like some Chinese

// RC International Preferences:
#define RCIP_ALLANSICHAR		0x0001	// all ANSI chars
#define RCIP_MASK					0x0001

// RC Options:
#define RCO_NOPOINTEREVENT		0x00000001L	// no recog tap, tap/hold
#define RCO_SAVEALLDATA			0x00000002L	// save pen data like upstrokes
#define RCO_SAVEHPENDATA		0x00000004L	// save pen data for app
#define RCO_NOFLASHUNKNOWN		0x00000008L	// no ? cursor on unknown
#define RCO_TABLETCOORD			0x00000010L	// tablet coords used in RC
#define RCO_NOSPACEBREAK		0x00000020L	// no space break recog -> dict
#define RCO_NOHIDECURSOR		0x00000040L	// display cursor during inking
#define RCO_NOHOOK				0x00000080L	// disallow ink hook (passwords)
#define RCO_BOXED					0x00000100L	// valid rc.guide provided
#define RCO_SUGGEST				0x00000200L	// for dict suggest
#define RCO_DISABLEGESMAP		0x00000400L	// disable gesture mapping
#define RCO_NOFLASHCURSOR		0x00000800L	// no cursor feedback
#define RCO_BOXCROSS				0x00001000L	// show + at boxedit center
#define RCO_COLDRECOG			0x00008000L	// result is from cold recog
#define RCO_SAVEBACKGROUND		0x00010000L // Save background from ink
#define RCO_DODEFAULT			0x00020000L // do default gesture processing

// RC Orientation of Tablet:
#define RCOR_NORMAL				1			// tablet not rotated
#define RCOR_RIGHT				2			// rotated 90 deg anticlockwise
#define RCOR_UPSIDEDOWN			3			// rotated 180 deg
#define RCOR_LEFT					4			// rotated 90 deg clockwise

// RC Preferences:
#define RCP_LEFTHAND				0x0001	// left handed input
#define RCP_MAPCHAR				0x0004	// fill in syg.lpsyc (ink) for training

// RCRESULT wResultsType values:
#define RCRT_DEFAULT				0x0000	// normal ret
#define RCRT_UNIDENTIFIED		0x0001 	// result contains unidentified results
#define RCRT_GESTURE				0x0002	// result is a gesture
#define RCRT_NOSYMBOLMATCH		0x0004	// nothing recognized (no ink match)
#define RCRT_PRIVATE				0x4000	// recognizer-specific symbol
#define RCRT_NORECOG				0x8000	// no recog attempted, only data ret
#define RCRT_ALREADYPROCESSED	0x0008	// GestMgr hooked it
#define RCRT_GESTURETRANSLATED 0x0010	// GestMgr translated it to ANSI value
#define RCRT_GESTURETOKEYS		0x0020	// ditto to set of virtual keys

// RC Result Return Mode specification:
#define RRM_STROKE				0			// return results after each stroke
#define RRM_SYMBOL				1			// per symbol (e.g. boxed edits)
#define RRM_WORD					2			// on recog of a word
#define RRM_NEWLINE				3			// on recog of a line break
#define RRM_COMPLETE				16		// on PCM_xx specified completion

// SetGlobalRC() API return code flags:
#define SGRC_OK					0x0000	// no err
#define SGRC_USER					0x0001	// invalid User name
#define SGRC_PARAMERROR			0x0002	// param error: call ignored
#define SGRC_RC					0x0004	// supplied RC has errors
#define SGRC_RECOGNIZER			0x0008	// DefRecog name invalid
#define SGRC_DICTIONARY			0x0010	// lpDefDict path invalid
#define SGRC_INIFILE				0x0020	// error saving to penwin.ini
#define SGRC_NA					0x8000	// function not available

#endif /*!NOPENRC1 */


//---------------------------------------------------------------------------

#ifndef NOPENTARGET

#define TPT_CLOSEST				0x0001   // Assign to the closest target   
#define TPT_INTERSECTINK		0x0002   // target with intersecting ink
#define TPT_TEXTUAL				0x0004   // apply textual heuristics
#define TPT_DEFAULT				(TPT_TEXTUAL | TPT_INTERSECTINK | TPT_CLOSEST)

#endif /*!NOPENTARGET */


//---------------------------------------------------------------------------
#ifndef NOPENVIRTEVENT

// Virtual Event Layer:
#define VWM_MOUSEMOVE			0x0001
#define VWM_MOUSELEFTDOWN		0x0002
#define VWM_MOUSELEFTUP			0x0004
#define VWM_MOUSERIGHTDOWN		0x0008
#define VWM_MOUSERIGHTUP		0x0010
#endif /*!NOPENVIRTEVENT */


#endif /* RC_INVOKED */	// ... all the way back from definitions:2

/****** Messages and Defines ************************************************/

// Windows Messages WM_PENWINFIRST (0x0380) and WM_PENWINLAST (0x038F)
// are defined in windows.h and winmin.h



//---------------------------------------------------------------------------
#ifndef NOPENMSGS

#ifndef NOPENRC1	// not available in WINPAD
#define WM_RCRESULT				(WM_PENWINFIRST+1)	// 0x381
#define WM_HOOKRCRESULT			(WM_PENWINFIRST+2)	// 0x382
#endif /*!NOPENRC1*/

#define WM_PENMISCINFO			(WM_PENWINFIRST+3)	// 0x383
#define WM_GLOBALRCCHANGE		(WM_PENWINFIRST+3)	// alias

#ifndef NOPENAPPS	// not available in WINPAD
#define WM_SKB						(WM_PENWINFIRST+4)	// 0x384
#endif /*!NOPENAPPS */

#define WM_PENCTL					(WM_PENWINFIRST+5)	// 0x385
#define WM_HEDITCTL				(WM_PENWINFIRST+5)	// FBC: alias

// WM_HEDITCTL (WM_PENCTL) wParam options:
#ifndef WINPAD
#define HE_GETRC					3		// FBC: get RC from HEDIT/BEDIT control
#define HE_SETRC					4		// FBC: ditto set
#endif //!WINPAD
#define HE_GETINFLATE			5		// FBC: get inflate rect
#define HE_SETINFLATE			6		// FBC: ditto set
#define HE_GETUNDERLINE		 	7		// get underline mode
#define HE_SETUNDERLINE		 	8		// ditto set
#define HE_GETINKHANDLE		 	9		// get handle to captured ink
#define HE_SETINKMODE			10		// begin HEDIT cold recog mode
#define HE_STOPINKMODE			11		// end cold recog mode
#define HE_GETRCRESULTCODE	 	12		// FBC: result of recog after HN_ENDREC
#define HE_DEFAULTFONT			13		// switch BEDIT to def font
#define HE_CHARPOSITION		 	14		// BEDIT byte offset -> char position
#define HE_CHAROFFSET			15		// BEDIT char position -> byte offset
#define HE_GETBOXLAYOUT		 	20		// get BEDIT layout
#define HE_SETBOXLAYOUT		 	21		// ditto set
#define HE_GETRCRESULT			22		// FBC: get RCRESULT after HN_RCRESULT
#define HE_KKCONVERT			 	30		// JPN start kana-kanji conversion
#define HE_GETKKCONVERT		 	31		// JPN get KK state
#define HE_CANCELKKCONVERT	 	32		// JPN cancel KK conversion
#define HE_FIXKKCONVERT		 	33		// JPN force KK result
#define HE_ENABLEALTLIST		40		// en/disable dropdown recog alt's
#define HE_SHOWALTLIST			41		// show dropdown (assume enabled)
#define HE_HIDEALTLIST			42		// hide dropdown alternatives

//------------------------------
// JPN KanaKanji conversion subfunctions:
#define HEKK_DEFAULT				0		// def
#define HEKK_CONVERT				1		// convert in place
#define HEKK_CANDIDATE			2		// start conversion dialog

// HE_STOPINKMODE (stop cold recog) options:
#define HEP_NORECOG				0		// don't recog ink
#define HEP_RECOG					1		// recog ink
#define HEP_WAITFORTAP			2		// recog after tap in window

// WM_PENCTL notifications:
#define HN_ENDREC					4		// recog complete
#define HN_DELAYEDRECOGFAIL	5		// HE_STOPINKMODE (cold recog) failed
#define HN_RESULT 				20		// HEDIT/BEDIT has received new ink/recognition result
#define HN_RCRESULT           HN_RESULT
#define HN_ENDKKCONVERT			30		// JPN KK conversion complete
#define HN_BEGINDIALOG			40		// Lens/EditText/garbage detection dialog is about 
                                    // to come up on this hedit/bedit
#define HN_ENDDIALOG			   41		// Lens/EditText/garbage detection dialog has
                                    // just been destroyed 

//------------------------------
#ifndef NOPENIEDIT

// Messages common with other controls:
#define IE_GETMODIFY			(EM_GETMODIFY)		// gets the mod'n (dirty) bit
#define IE_SETMODIFY			(EM_SETMODIFY)		// sets the mod'n (dirty) bit
#define IE_CANUNDO			(EM_CANUNDO)		// queries whether can undo
#define IE_UNDO				(EM_UNDO)			// undo
#define IE_EMPTYUNDOBUFFER	(EM_EMPTYUNDOBUFFER)	// clears IEDIT undo buffer

#define IE_MSGFIRST			(WM_USER+150)		// 0x496 == 1174

// IEdit and WinPad common messages:
#define IE_GETINK				(IE_MSGFIRST+0)	// gets ink from the control
#define IE_SETINK				(IE_MSGFIRST+1)	// sets ink into the control
#define IE_GETPENTIP			(IE_MSGFIRST+2)	// gets the cur def ink pentip
#define IE_SETPENTIP			(IE_MSGFIRST+3)	// sets the cur def ink pentip
#define IE_GETERASERTIP		(IE_MSGFIRST+4)	// gets the cur eraser pentip
#define IE_SETERASERTIP		(IE_MSGFIRST+5)	// sets the cur eraser pentip
#define IE_GETBKGND			(IE_MSGFIRST+6)	// gets the bkgnd options
#define IE_SETBKGND			(IE_MSGFIRST+7)	// sets the bkgnd options
#define IE_GETGRIDORIGIN	(IE_MSGFIRST+8)	// gets the bkgnd grid origin
#define IE_SETGRIDORIGIN 	(IE_MSGFIRST+9)	// sets the bkgnd grid origin
#define IE_GETGRIDPEN		(IE_MSGFIRST+10)	// gets the bkgnd grid pen
#define IE_SETGRIDPEN		(IE_MSGFIRST+11)	// sets the bkgnd grid pen
#define IE_GETGRIDSIZE		(IE_MSGFIRST+12)	// gets the bkgnd grid size
#define IE_SETGRIDSIZE		(IE_MSGFIRST+13)	// sets the bkgnd grid size
#define IE_GETMODE			(IE_MSGFIRST+14)	// gets the current pen mode
#define IE_SETMODE			(IE_MSGFIRST+15)	// sets the current pen mode
#define IE_GETINKRECT		(IE_MSGFIRST+16)	// gets the rectbound of the ink

// Winpad-specific messages:
#ifdef WINPAD
#define IE_GETORIGIN 		(IE_MSGFIRST+17)	// gets the control origin
#define IE_SETORIGIN 		(IE_MSGFIRST+18)	// sets the control origin
#define IE_GETSCROLLSTEP 	(IE_MSGFIRST+19)	// gets the scrolling step
#define IE_SETSCROLLSTEP 	(IE_MSGFIRST+20)	// sets the scrolling step
#define IE_GETCHANGEINK		(IE_MSGFIRST+21)	// gets last changed ink
#define IE_SCALEINK 			(IE_MSGFIRST+22)	// scales the control ink
#define IE_GETTAPCONVERT 	(IE_MSGFIRST+23)	// gets the cur turd dection 
#define IE_SETTAPCONVERT 	(IE_MSGFIRST+24)	// sets the cur turd dection
#define IE_GETTAPPOS 		(IE_MSGFIRST+25)	// gets the tap position
#define IE_GETPALETTE 		(IE_MSGFIRST+26)	// gets the palette
#define IE_SETPALETTE 		(IE_MSGFIRST+27)	// gets the palette
#define IE_HHUNUSED1			(IE_MSGFIRST+28)	// Unused
#define IE_HHUNUSED2			(IE_MSGFIRST+29)	// Unused
#define IE_HHUNUSED3			(IE_MSGFIRST+30)	// Unused
#define IE_HHUNUSED4			(IE_MSGFIRST+31)	// Unused
#define IE_HHUNUSED5			(IE_MSGFIRST+32)	// Unused
#define IE_HHUNUSED6			(IE_MSGFIRST+33)	// Unused
#endif //WINPAD

// IEdit-specific messages:
#ifndef WINPAD
#define IE_GETAPPDATA		(IE_MSGFIRST+34)	// gets the user-defined datum
#define IE_SETAPPDATA		(IE_MSGFIRST+35)	// sets the user-defined data
#define IE_GETDRAWOPTS		(IE_MSGFIRST+36)	// gets the ink draw options
#define IE_SETDRAWOPTS		(IE_MSGFIRST+37)	// sets the ink options
#define IE_GETFORMAT			(IE_MSGFIRST+38)	// gets format of stroke(s)
#define IE_SETFORMAT			(IE_MSGFIRST+39)	// sets format of stroke(s)
#define IE_GETINKINPUT		(IE_MSGFIRST+40)	// gets the ink input option
#define IE_SETINKINPUT		(IE_MSGFIRST+41)	// sets the ink input option
#define IE_GETNOTIFY			(IE_MSGFIRST+42)	// gets the notification bits
#define IE_SETNOTIFY			(IE_MSGFIRST+43)	// sets the notification bits
#define IE_GETRECOG			(IE_MSGFIRST+44)	// gets recognition options
#define IE_SETRECOG			(IE_MSGFIRST+45)	// sets recognition options
#define IE_GETSECURITY		(IE_MSGFIRST+46)	// gets the security options
#define IE_SETSECURITY		(IE_MSGFIRST+47)	// sets the security options
#define IE_GETSEL				(IE_MSGFIRST+48)	// gets sel status of a stroke
#define IE_SETSEL				(IE_MSGFIRST+49)	// sets sel status of a stroke
#define IE_DOCOMMAND			(IE_MSGFIRST+50)	// send command to IEdit
#define IE_GETCOMMAND		(IE_MSGFIRST+51)	// gets user command
#define IE_GETCOUNT			(IE_MSGFIRST+52)	// gets count of strks in I-Edit
#define IE_GETGESTURE		(IE_MSGFIRST+53)	// gets details on user gesture
#define IE_GETMENU			(IE_MSGFIRST+54)	// gets handle to pop-up menu
#define IE_GETPAINTDC		(IE_MSGFIRST+55)	// gets the HDC for painting
#define IE_GETPDEVENT		(IE_MSGFIRST+56)	// gets details of last pd event
#define IE_GETSELCOUNT		(IE_MSGFIRST+57)	// gets count of selected strks
#define IE_GETSELITEMS		(IE_MSGFIRST+58)	// gets indices of all sel strks
#define IE_GETSTYLE			(IE_MSGFIRST+59)	// gets IEdit control styles
#endif //!WINPAD

#endif /*!NOPENIEDIT */

//------------------------------
#ifndef NOPENHEDIT

// (H)Edit Control:
// CTLINITHDIT.dwFlags values
#define CIH_NOGDMSG           0x0001  // disable garbage detection message box for this edit
#define CIH_NOACTIONHANDLE    0x0002  // disable action handles for this edit
#define CIH_NOEDITTEXT        0x0004  // disable Lens/Edit/Insert text for this edit
#define CIH_NOFLASHCURSOR     0x0008  // don't flash cursor on tap-n-hold in this (h)edit

#endif /* !NOPENHEDIT */

//------------------------------
#ifndef NOPENBEDIT

// Boxed Edit Control:
// box edit alternative list:
#define HEAL_DEFAULT				-1L     // AltList def value for lParam

// box edit Info:
#define BEI_FACESIZE				32		// max size of font name, = LF_FACESIZE
#define BEIF_BOXCROSS			0x0001

// box edit size:
#define BESC_DEFAULT				0
#define BESC_ROMANFIXED			1
#define BESC_KANJIFIXED			2
#define BESC_USERDEFINED		3

// CTLINITBEDIT.wFlags values
#define CIB_NOGDMSG           0x0001  // disable garbage detection message box for this bedit
#define CIB_NOACTIONHANDLE    0x0002  // disable action handles for this bedit
#define CIB_NOFLASHCURSOR     0x0004  // don't flash cursor on tap-n-hold in this bedit

#define BXD_CELLWIDTH			12
#define BXD_CELLHEIGHT			16
#define BXD_BASEHEIGHT			13
#define BXD_BASEHORZ				0
#define BXD_MIDFROMBASE			0
#define BXD_CUSPHEIGHT			2
#define BXD_ENDCUSPHEIGHT		4

#define BXDK_CELLWIDTH			32
#define BXDK_CELLHEIGHT			32
#define BXDK_BASEHEIGHT			28
#define BXDK_BASEHORZ			0
#define BXDK_MIDFROMBASE		0
#define BXDK_CUSPHEIGHT			28
#define BXDK_ENDCUSPHEIGHT		10

#ifdef JAPAN
// IME colors for bedit
#define COLOR_BE_INPUT			   0 
#define COLOR_BE_INPUT_TEXT		1 
#define COLOR_BE_CONVERT		   2 
#define COLOR_BE_CONVERT_TEXT	   3 
#define COLOR_BE_CONVERTED		   4 
#define COLOR_BE_CONVERTED_TEXT	5 
#define COLOR_BE_UNCONVERT	      6 
#define COLOR_BE_UNCONVERT_TEXT	7 
#define COLOR_BE_CURSOR			   8 
#define COLOR_BE_CURSOR_TEXT	   9 
#define COLOR_BE_PRECONVERT		10
#define COLOR_BE_PRECONVERT_TEXT	11
#define MAXIMECOLORS			      12
#endif

#endif /*!NOPENBEDIT */

#define WM_PENMISC				(WM_PENWINFIRST+6)	// 0x386

// WM_PENMISC message constants:
#define PMSC_BEDITCHANGE		1	// broadcast when BEDIT changes
#define PMSC_PENUICHANGE		2	// JPN broadcast when PENUI changes
#define PMSC_SUBINPCHANGE		3	// JPN broadcast when SUBINPUT changes
#define PMSC_KKCTLENABLE		4	// JPN
#define PMSC_GETPCMINFO			5	// query the window's PCMINFO
#define PMSC_SETPCMINFO			6	// set the window's PCMINFO
#define PMSC_GETINKINGINFO		7	// query the window's INKINGINFO
#define PMSC_SETINKINGINFO		8	// set the window's INKINGINFO
#define PMSC_GETHRC				9	// query the window's HRC
#define PMSC_SETHRC				10	// set the window's HRC
#define PMSC_GETSYMBOLCOUNT	11	// count of symbols in result recd by window
#define PMSC_GETSYMBOLS 		12	// ditto symbols
#define PMSC_SETSYMBOLS 		13	// ditto set symbols
#ifndef WINPAD
#define PMSC_LOADPW				15	// broadcast load state on penwin
#endif //!WINPAD
#define PMSC_INKSTOP				16	// 

// PMSCL_xx lParam values for PMSC_xx:
#define PMSCL_UNLOADED			0L	// penwin just unloaded
#define PMSCL_LOADED				1L	// penwin just loaded
#define PMSCL_UNLOADING			2L	// penwin about to unload



#define WM_CTLINIT				(WM_PENWINFIRST+7)	// 0x387

// WM_CTLINIT message constants:
#define CTLINIT_HEDIT			1
#define CTLINIT_BEDIT			7
#define CTLINIT_IEDIT			9
#define CTLINIT_MAX				10

#define WM_PENEVENT				(WM_PENWINFIRST+8)	// 0x388

// WM_PENEVENT message values for wParam:
#define PE_PENDOWN				1	// pen tip down
#define PE_PENUP					2	// pen tip went from down to up
#define PE_PENMOVE				3	// pen moved without a tip transition
#define PE_TERMINATING			4	// Peninput about to terminate
#define PE_TERMINATED			5	// Peninput terminated
#define PE_BUFFERWARNING		6	// Buffer half full.
#define PE_BEGININPUT			7	// begin default input
#define PE_SETTARGETS			8	// set target data structure (TARGINFO)
#define PE_BEGINDATA				9	// init message to all targets
#define PE_MOREDATA				10	// target gets more data
#define PE_ENDDATA				11	// termination message to all targets
#define PE_GETPCMINFO			12	// get input collection info
#define PE_GETINKINGINFO		13	// get inking info
#define PE_ENDINPUT				14	// Input termination message to window
                                	// 	starting default input 
#define PE_RESULT             15 // sent after ProcessHRC but before GetResultsHRC

#endif /*!NOPENMSGS */


/****** Definitions 3: RC compiler excluded ********************************/

#ifndef RC_INVOKED	// ... rest of file of no interest to rc compiler



//////////////////////////////////////////////////////////////////////////////
/****** Macros **************************************************************/


// misc macros:
//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

#define FPenUpX(x)				((BOOL)(((x) & BITPENUP) != 0))
#define GetWEventRef()			(LOWORD(GetMessageExtraInfo()))
#endif /*!NOPENDRIVER */

//---------------------------------------------------------------------------
#ifndef NOPENALC

// ALC macros:

#define MpAlcB(lprc,i)			((lprc)->rgbfAlc[((i) & 0xff) >> 3])
#define MpIbf(i)					((BYTE)(1 << ((i) & 7)))
#define SetAlcBitAnsi(lprc,i)	do {MpAlcB(lprc,i) |= MpIbf(i);} while (0)
#define ResetAlcBitAnsi(lprc,i) do {MpAlcB(lprc,i) &= ~MpIbf(i);} while (0)
#define IsAlcBitAnsi(lprc, i)	((MpAlcB(lprc,i) & MpIbf(i)) != 0)
#endif /*!NOPENALC */

//---------------------------------------------------------------------------
#ifndef NOPENGEST	// not available in WINPAD

// Gesture Macros:

#define FIsLoAppGesture(syv)	(syv >= SYV_CIRCLELOA && syv <= SYV_CIRCLELOZ)
#define FIsUpAppGesture(syv)	(syv >= SYV_CIRCLEUPA && syv <= SYV_CIRCLEUPZ)
#define FIsAppGesture(syv)		(syv>=SYV_CIRCLEUPA && syv<=SYV_CIRCLELOZ)
#define SyvAppGestureFromLoAnsi(ansi)	((DWORD)(BYTE)ansi- 'a'+SYV_CIRCLELOA)
#define SyvAppGestureFromUpAnsi(ansi)	((DWORD)(BYTE)ansi- 'A'+SYV_CIRCLEUPA)
#define AnsiFromSyvAppGesture(syv)		ChSyvToAnsi( \
	syv-(FIsUpAppGesture(syv)? SYV_CIRCLEUPA-(SYV)'A': SYV_CIRCLELOA-(SYV)'a'))

#define IsGestureToGesture(lprcresult) \
	(((lprcresult)->wResultstype & MAP_GESTOGES) == MAP_GESTOGES)

#define IsGestureToVkeys(lprcresult) \
	(((lprcresult)->wResultstype & MAP_GESTOVKEYS) == MAP_GESTOVKEYS)

#define SetAlreadyProcessed(lprcresult) \
	((lprcresult)->wResultsType = ((lprcresult)->wResultsType \
	& ~RCRT_GESTURETOKEYS) | RCRT_ALREADYPROCESSED)
#endif /*!NOPENGEST */


//---------------------------------------------------------------------------
#ifndef NOPENDATA

// draw 2.0 pendata using internal stroke formats:
#define DrawPenDataFmt(hdc, lprect, hpndt)\
	DrawPenDataEx(hdc, lprect, hpndt, 0, IX_END, 0, IX_END, NULL, NULL, 0)

#endif /*!NOPENDATA */

//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:

// Intervals:
// difference of two absolute times (at2 > at1 for positive result):
#define dwDiffAT(at1, at2)\
	(1000L*((at2).sec - (at1).sec) - (DWORD)(at1).ms + (DWORD)(at2).ms)

// comparison of two absolute times (TRUE if at1 < at2):
#define FLTAbsTime(at1, at2)\
	((at1).sec < (at2).sec || ((at1).sec == (at2).sec && (at1).ms < (at2).ms))

#define FLTEAbsTime(at1, at2)\
	((at1).sec < (at2).sec || ((at1).sec == (at2).sec && (at1).ms <= (at2).ms))

#define FEQAbsTime(at1, at2)\
	((at1).sec == (at2).sec && (at1).ms == (at2).ms)

// test if abstime is within an interval:
#define FAbsTimeInInterval(at, lpi)\
	(FLTEAbsTime((lpi)->atBegin, at) && FLTEAbsTime(at, (lpi)->atEnd))

// test if interval (lpiT) is within an another interval (lpiS):
#define FIntervalInInterval(lpiT, lpiS)\
	(FLTEAbsTime((lpiS)->atBegin, (lpiT)->atBegin)\
	&& FLTEAbsTime((lpiT)->atEnd, (lpiS)->atEnd))

// test if interval (lpiT) intersects another interval (lpiS):
#define FIntervalXInterval(lpiT, lpiS)\
	(!(FLTAbsTime((lpiT)->atEnd, (lpiS)->atBegin)\
	|| FLTAbsTime((lpiS)->atEnd, (lpiT)->atBegin)))

// duration of an LPINTERVAL in ms:
#define dwDurInterval(lpi)	dwDiffAT((lpi)->atBegin, (lpi)->atEnd)

// fill a pointer to an ABSTIME structure from a count of seconds and ms:
#define MakeAbsTime(lpat, sec, ms) do {\
	(lpat)->sec = sec + ((ms) / 1000);\
	(lpat)->ms = (ms) % 1000;\
	} while (0)


// SYV macros:
#define FIsSpecial(syv)			(HIWORD((syv))==SYVHI_SPECIAL)
#define FIsAnsi(syv)				(HIWORD((syv))==SYVHI_ANSI)
#define FIsGesture(syv)			(HIWORD((syv))==SYVHI_GESTURE)
#define FIsKanji(syv)			(HIWORD((syv))==SYVHI_KANJI)
#define FIsShape(syv)			(HIWORD((syv))==SYVHI_SHAPE)
#define FIsUniCode(syv)			(HIWORD((syv))==SYVHI_UNICODE)
#define FIsVKey(syv)				(HIWORD((syv))==SYVHI_VKEY)

#define ChSyvToAnsi(syv)			((BYTE) (LOBYTE(LOWORD((syv)))))
#define WSyvToKanji(syv)			((WORD) (LOWORD((syv))))
#define SyvCharacterToSymbol(c)	((LONG)(unsigned char)(c) | 0x00010000)
#define SyvKanjiToSymbol(c)		((LONG)(UINT)(c) | 0x00030000)

#define FIsSelectGesture(syv)	\
   ((syv) >= SYVSELECTFIRST && (syv) <= SYVSELECTLAST)

#define FIsStdGesture(syv)		\
   (									\
   FIsSelectGesture(syv)		\
   || (syv)==SYV_CLEAR			\
   || (syv)==SYV_HELP			\
   || (syv)==SYV_EXTENDSELECT	\
   || (syv)==SYV_UNDO			\
   || (syv)==SYV_COPY			\
   || (syv)==SYV_CUT				\
   || (syv)==SYV_PASTE			\
   || (syv)==SYV_CLEARWORD		\
   || (syv)==SYV_KKCONVERT		\
   || (syv)==SYV_USER			\
   || (syv)==SYV_CORRECT		\
   )

#define FIsAnsiGesture(syv)	\
   (									\
   (syv) == SYV_BACKSPACE		\
   || (syv) == SYV_TAB			\
   || (syv) == SYV_RETURN		\
   || (syv) == SYV_SPACE		\
   )

#endif /*!NOPENHRC */      

//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

#define EventRefFromLparam(lParam)        (LOWORD((lParam)))
#define TerminationFromLparam(lParam)     ((int)(LOWORD((lParam))))
#define HpcmFromLparam(lParam)            ((HPCM)HIWORD((lParam)))
#endif   /*!NOPENINKPUT*/

//---------------------------------------------------------------------------
#ifndef NOPENTARGET
#define HwndFromHtrg(htrg)              ((HWND)(htrg))
#define HtrgFromHwnd(hwnd)               ((HTRG)(struct hwnd__ FAR*)(hwnd))
#endif /*!NOPENTARGET*/



//////////////////////////////////////////////////////////////////////////////
/****** Typedefs ************************************************************/


// Simple:
typedef LONG						ALC;		// Enabled Alphabet
typedef int							CL;		// Confidence Level
typedef UINT						HKP;		// Hook Parameter
typedef int							REC;		// recognition result
typedef LONG						SYV;		// Symbol Value
typedef DWORD						HTRG;		// handle to target

DECLARE_HANDLE(HPCM);					   // Handle to Pen Collection Info
DECLARE_HANDLE(HPENDATA);					// handle to ink
DECLARE_HANDLE(HREC);						// handle to recognizer

// Pointer Types:
typedef ALC FAR*					LPALC;			// ptr to ALC
typedef LPVOID						LPOEM;			// alias
typedef SYV FAR*					LPSYV;			// ptr to SYV
typedef HPENDATA FAR*			LPHPENDATA;		// ptr to HPENDATA

// Function Prototypes:
typedef int			(CALLBACK *ENUMPROC)(LPSYV, int, VOID FAR*);
typedef int			(CALLBACK *LPDF)(int, LPVOID, LPVOID, int, DWORD, DWORD);
typedef BOOL		(CALLBACK *RCYIELDPROC)(VOID);



// Structures:

#ifdef WINPAD
typedef struct tagRECTL
	{
   LONG left;
   LONG top;
   LONG right;
   LONG bottom;
	}
	RECTL, *PRECTL, NEAR *NPRECTL, FAR *LPRECTL, const FAR *LPCRECTL;
#endif //WINPAD

typedef struct tagABSTIME		// 2.0 absolute date/time
	{
	DWORD sec;	// number of seconds since 1/1/1970, ret by CRTlib time() fn
	WORD ms;		// additional offset in ms, 0..999 (NB WORD not UINT)
	}
	ABSTIME, FAR *LPABSTIME;

//---------------------------------------------------------------------------
#ifndef NOPENHEDIT

typedef struct tagCTLINITHEDIT // 2.0 init struct for (h)edit
   {
	DWORD cbSize;					// sizeof(CTLINITHEDIT)
   HWND hwnd;						// (h)edit window handle
   int id;							// its id
   DWORD dwFlags;             // CIE_xx
   DWORD dwReserved;				// for future use
   }
   CTLINITHEDIT, FAR *LPCTLINITHEDIT;
#endif /* !NOPENHEDIT */


//---------------------------------------------------------------------------
#ifndef NOPENBEDIT

typedef struct tagBOXLAYOUT	 // 1.0 box edit layout
   {
   int cyCusp;      				 // pixel height of box (BXS_RECT) or cusp
   int cyEndCusp;					 // pixel height of cusps at extreme ends
   UINT style;      				 // BXS_xx style
   DWORD dwReserved1;			 // reserved
   DWORD dwReserved2;			 // reserved
   DWORD dwReserved3;			 // reserved
   }
   BOXLAYOUT, FAR *LPBOXLAYOUT;

typedef struct tagIMECOLORS	// 2.0 IME undetermined string color info.
	{
	int cColors;					// count of colors to be set/get
	LPINT lpnElem;					// address of array of elements
	COLORREF FAR *lprgbIme;		// address of array of RGB values
	}
	IMECOLORS, FAR *LPIMECOLORS;

typedef struct tagCTLINITBEDIT // 2.0 init struct for box edit
   {
	DWORD cbSize;					// sizeof(CTLINITBEDIT)
   HWND hwnd;						// box edit window handle
   int id;							// its id
   WORD wSizeCategory;			// BESC_xx
   WORD wFlags;               // CIB_xx
   WORD wReserved;				// for future use
   }
   CTLINITBEDIT, FAR *LPCTLINITBEDIT;

typedef struct tagBOXEDITINFO	 // 1.1 box edit Size Info
   {
   int cxBox;						 // width of a single box
   int cyBox;						 // ditto height
   int cxBase;						 // in-box x-margin to guideline
   int cyBase;						 // in-box y offset from top to baseline
   int cyMid;						 // 0 or distance from baseline to midline
   BOXLAYOUT boxlayout;			 // embedded BOXLAYOUT structure
   UINT wFlags;					 // BEIF_xx
   BYTE szFaceName[BEI_FACESIZE];	// font face name
   UINT wFontHeight;				 // font height
   UINT rgwReserved[8];			 // for future use
   }
   BOXEDITINFO, FAR *LPBOXEDITINFO;
#endif /*!NOPENBEDIT */


//---------------------------------------------------------------------------
#ifndef NOPENCTL

typedef struct tagRECTOFS		 // 1.0 rectangle offset for nonisometric inflation
   {
   int dLeft;						 // inflation leftwards from left side
   int dTop;						 // ditto upwards from top
   int dRight;						 // ditto rightwards from right
   int dBottom;					 // ditto downwards from bottom
   }
   RECTOFS, FAR *LPRECTOFS;
#endif /*!NOPENCTL */


//---------------------------------------------------------------------------
#ifndef NOPENDATA

typedef struct tagPENDATAHEADER	// 1.0 main pen data header
   {
   UINT wVersion;					 // pen data format version
   UINT cbSizeUsed;        	 // size of pendata mem block in bytes
   UINT cStrokes;          	 // number of strokes (incl up-strokes)
   UINT cPnt;              	 // count of all points
   UINT cPntStrokeMax;			 // length (in points) of longest stroke
   RECT rectBound;				 // bounding rect of all down points
   UINT wPndts;            	 // PDTS_xx bits
   int  nInkWidth;				 // ink width in pixels
   DWORD rgbInk;					 // ink color
   }
   PENDATAHEADER, FAR *LPPENDATAHEADER, FAR *LPPENDATA;

typedef struct tagSTROKEINFO	 // 1.0 stroke header
   {
   UINT cPnt;        			 // count of points in stroke
   UINT cbPnts;    				 // size of stroke in bytes
   UINT wPdk;        			 // state of stroke
   DWORD dwTick;    				 // time at beginning of stroke
   }
   STROKEINFO, FAR *LPSTROKEINFO;

typedef struct tagPENTIP		// 2.0 Pen Tip characteristics
	{
	DWORD		cbSize;				// sizeof(PENTIP)
   BYTE     btype;         	// pen type/nib (calligraphic nib, etc.)
 	BYTE		bwidth;				// width of Nib (typically == nInkWidth)
 	BYTE		bheight;				// height of Nib
	BYTE		bOpacity;			// 0=transparent, 0x80=hilite, 0xFF=opaque
   COLORREF rgb;	         	// pen color
	DWORD		dwFlags;				// TIP_xx flags
	DWORD 	dwReserved;			// for future expansion
	}
	PENTIP, FAR *LPPENTIP;


typedef BOOL (CALLBACK *ANIMATEPROC)(HPENDATA, UINT, UINT, UINT FAR*, LPARAM);

typedef struct tagANIMATEINFO	// 2.0 Animation parameters
	{
	DWORD		cbSize;				// sizeof(ANIMATEINFO)
	UINT		uSpeedPct;			// speed percent to animate at
	UINT		uPeriodCB;			// time between calls to callback in ms
	UINT		fuFlags;				// animation flags
	LPARAM	lParam;				// value to pass to callback
	DWORD		dwReserved;			// reserved
	}
	ANIMATEINFO, FAR *LPANIMATEINFO;
#endif /*!NOPENDATA */


//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

typedef struct tagOEMPENINFO	// 1.0 OEM pen/tablet hdwe info
   {
   UINT wPdt;						// pen data type
   UINT wValueMax;				// largest val ret by device
   UINT wDistinct;				// number of distinct readings possible
   }
   OEMPENINFO, FAR *LPOEMPENINFO;

typedef struct tagPENPACKET	// 1.0 pen packet
   {
   UINT wTabletX;					// x in raw coords
   UINT wTabletY;					// ditto y
   UINT wPDK;						// state bits
   UINT rgwOemData[MAXOEMDATAWORDS];	// OEM-specific data
   }
   PENPACKET, FAR *LPPENPACKET;

typedef struct tagOEM_PENPACKET	// 2.0 
   {
   UINT wTabletX;					// x in raw coords
   UINT wTabletY;					// ditto y
   UINT wPDK;						// state bits
   UINT rgwOemData[MAXOEMDATAWORDS];	// OEM-specific data
   DWORD dwTime;
   }
	OEM_PENPACKET, FAR *LPOEM_PENPACKET;

typedef struct tagPENINFO		// 1.0 pen/tablet hdwe info
   {
   UINT cxRawWidth;       		// max x coord and tablet width in 0.001"
   UINT cyRawHeight;       	// ditto y, height
   UINT wDistinctWidth;   		// number of distinct x values tablet ret
   UINT wDistinctHeight;  		// ditto y
   int nSamplingRate; 			// samples / second
   int nSamplingDist; 			// min distance to move before generating event
   LONG lPdc;        			// Pen Device Capabilities
   int cPens;        			// number of pens supported
   int cbOemData;    			// width of OEM data packet
   OEMPENINFO rgoempeninfo[MAXOEMDATAWORDS];	// supported OEM data types
   UINT rgwReserved[7];     	// for internal use
   UINT fuOEM;						// which OEM data, timing, PDK_xx to report
   }
   PENINFO, FAR *LPPENINFO;

typedef struct tagCALBSTRUCT  // 1.0 pen calibration
   {
   int wOffsetX;
   int wOffsetY;
   int wDistinctWidth;
   int wDistinctHeight;
   }
   CALBSTRUCT, FAR *LPCALBSTRUCT;

typedef BOOL		(CALLBACK *LPFNRAWHOOK)(LPPENPACKET);
#endif /*!NOPENDRIVER */


//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:
typedef DWORD						HRC;			// Handwriting Recognition Context
typedef DWORD						HRCRESULT;	// HRC result
typedef DWORD						HWL;			// Handwriting wordlist

typedef HRC							FAR *LPHRC;
typedef HRCRESULT					FAR *LPHRCRESULT;
typedef HWL							FAR *LPHWL;

typedef BOOL (CALLBACK *HRCRESULTHOOKPROC)
	(HREC, HRC, UINT, UINT, UINT, LPVOID);

// Inksets:
DECLARE_HANDLE(HINKSET);								// handle to an inkset
typedef HINKSET					FAR* LPHINKSET;	// ptr to HINKSET

typedef struct tagINTERVAL		// 2.0 interval structure for inksets
	{
	ABSTIME atBegin;				// begining of 1-ms granularity interval
	ABSTIME atEnd;					// 1 ms past end of interval
	}
	INTERVAL, FAR *LPINTERVAL;

typedef struct tagBOXRESULTS	// 2.0 
	{
   int indxBox;
   HINKSET hinksetBox;
   SYV rgSyv[1];
	}
	BOXRESULTS, FAR *LPBOXRESULTS;

typedef struct tagGUIDE			 // 1.0 guide structure
   {
   int xOrigin;    				 // left edge of first box (screen coord))
   int yOrigin;					 // ditto top edge
   int cxBox;						 // width of a single box
   int cyBox;						 // ditto height
   int cxBase;						 // in-box x-margin to guideline
   int cyBase;						 // in-box y offset from top to baseline
   int cHorzBox;					 // count of boxed columns
   int cVertBox;					 // ditto rows
   int cyMid;						 // 0 or distance from baseline to midline
   }
   GUIDE, FAR *LPGUIDE;

#endif /*!NOPENHRC */

//---------------------------------------------------------------------------
#ifndef NOPENIEDIT

#ifndef WINPAD
typedef struct tagCTLINITIEDIT		// 2.0 init struct for Ink Edit
	{
	DWORD		cbSize;				// sizeof(CTLINITIEDIT)
	HWND		hwnd;					// IEdit window handle
	int		id;					// its ID
	WORD		ieb;					// IEB_* (background) bits
	WORD		iedo;					// IEDO_* (draw options) bits
	WORD		iei;					// IEI_* (ink input) bits
	WORD		ien;					// IEN_* (notification) bits
	WORD		ierec;				// IEREC_* (recognition) bits
	WORD		ies;					// IES_* (style) bits
	WORD		iesec;				// IESEC_* (security) bits
	HPENDATA	hpndt;				// initial pendata (or NULL if none)
	WORD		pdts;					// initial pendata scale factor (PDTS_*)
	HGDIOBJ	hgdiobj;				// background brush or bitmap handle
	HPEN		hpenGrid;			// pen to use in drawing grid
	POINT		ptOrgGrid;			// grid lines point of origin
	WORD		wVGrid;				// vertical gridline spacing
	WORD		wHGrid;				// horizontal gridline spacing
	DWORD		dwApp;				// application-defined data
	DWORD		dwReserved;			// reserved for future use
	}
	CTLINITIEDIT, FAR *LPCTLINITIEDIT;
#endif //!WINPAD

typedef struct tagPDEVENT		// 2.0 
	{
	DWORD		cbSize;				// sizeof(PDEVENT)
	HWND		hwnd;					// window handle of I-Edit
	UINT		wm;					// WM_* (window message) of event
	WPARAM	wParam;				// wParam of message
	LPARAM	lParam;				// lParam of message
	POINT		pt;					// event pt in I-Edit client co-ords
	BOOL		fPen;					// TRUE if pen (or other inking device)
	LONG		lExInfo;				// GetMessageExtraInfo() return value
	DWORD		dwReserved;			// for future use
	}
	PDEVENT, FAR *LPPDEVENT;

typedef struct tagSTRKFMT		// 2.0 
	{
	DWORD		cbSize;				// sizeof(STRKFMT)
	WORD		iesf;					// stroke format flags and return bits
	UINT		iStrk;				// stroke index if IESF_STROKE
	PENTIP	tip;					// ink tip attributes
	DWORD		dwUser;				// user data for strokes
	DWORD		dwReserved;			// for future use
	}
	STRKFMT, FAR *LPSTRKFMT;
#endif /*!NOPENIEDIT */


//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

typedef struct tagPCMINFO		// 2.0 Pen Collection Mode Information
   {
	DWORD cbSize;					// sizeof(PCMINFO)
   DWORD dwPcm;					// PCM_xxx flags
   RECT  rectBound;				// if finish on pendown outside this rect
   RECT  rectExclude;			// if finish on pendown inside this rect
   HRGN  hrgnBound;				// if finish on pendown outside this region
   HRGN  hrgnExclude;			// if finish on pendown inside this region
   DWORD dwTimeout;				// if finish after timeout, this many ms
   }
	PCMINFO, FAR *LPPCMINFO;

typedef struct tagINKINGINFO	// 2.0 Pen Inking Information
   {
	DWORD    cbSize;				// sizeof(INKINGINFO)
   UINT     wFlags;				// One of the PII_xx flags
	PENTIP	tip;					// Pen type, size and color
   RECT     rectClip;      	// Clipping rect for the ink
   RECT     rectInkStop;   	// Rect in which a pen down stops inking
   HRGN     hrgnClip;      	// Clipping region for the ink
   HRGN     hrgnInkStop;   	// Region in which a pen down stops inking
   } 
	INKINGINFO, FAR *LPINKINGINFO;
#endif /*!NOPENINKPUT */


//---------------------------------------------------------------------------
#ifndef NOPENRC1	// not available in WINPAD

typedef struct tagSYC			// 1.0 Symbol Correspondence for Ink
   {
   UINT wStrokeFirst;			// first stroke, inclusive
   UINT wPntFirst;				// first point in first stroke, inclusive
   UINT wStrokeLast;				// last stroke, inclusive
   UINT wPntLast;					// last point in last stroke, inclusive
   BOOL fLastSyc;					// T: no more SYCs follow for current SYE
   }
   SYC, FAR *LPSYC;
    

typedef struct tagSYE			// 1.0 Symbol Element
   {
   SYV syv;							// symbol value
   LONG lRecogVal;				// for internal use by recognizer
   CL cl;							// confidence level
   int iSyc;						// SYC index
   }
   SYE, FAR *LPSYE;


typedef struct tagSYG			// 1.0 Symbol Graph
   {
   POINT rgpntHotSpots[MAXHOTSPOT]; // hot spots (max 8)
   int cHotSpot;					// number of valid hot spots in rgpntHotSpots
   int nFirstBox;					// row-major index to box of 1st char in result
   LONG lRecogVal;				// reserved for use by recoognizer
   LPSYE lpsye;					// nodes of symbol graph
   int cSye;						// number of SYEs in symbol graph
   LPSYC lpsyc;					// ptr to corresp symbol ink
   int cSyc;						// ditto count
   }
   SYG, FAR *LPSYG;


typedef struct tagRC				// 1.0 Recognition Context (RC)
   {
   HREC hrec;						// handle of recognizer to use
   HWND hwnd;						// window to send results to
   UINT wEventRef;        		// index into ink buffer
   UINT wRcPreferences;			// flags: RCP_xx Preferences
   LONG lRcOptions;				// RCO_xx options
   RCYIELDPROC lpfnYield;		// procedure called during Yield()
   BYTE lpUser[cbRcUserMax];	// current writer
   UINT wCountry;					// country code
   UINT wIntlPreferences;		// flags: RCIP_xx
   char lpLanguage[cbRcLanguageMax];	// language strings
   LPDF rglpdf[MAXDICTIONARIES];			// list of dictionary functions
   UINT wTryDictionary;			// max enumerations to search
   CL clErrorLevel;				// level where recognizer should reject input
   ALC alc;							// enabled alphabet
   ALC alcPriority;				// prioritizes the ALC_ codes
   BYTE rgbfAlc[cbRcrgbfAlcMax];	// bit field for enabled characters
   UINT wResultMode;				// RRM_xx when to send (asap or when complete)
   UINT wTimeOut;					// recognition timeout in ms
   LONG lPcm;						// flags: PCM_xx for ending recognition
   RECT rectBound;				// bounding rect for inking (def:screen coords)
   RECT rectExclude;				// pen down inside this terminates recognition
   GUIDE guide;					// struct: defines guidelines for recognizer
   UINT wRcOrient;				// RCOR_xx orientation of writing wrt tablet
   UINT wRcDirect;				// RCD_xx direction of writing
   int nInkWidth;					// ink width 0 (none) or 1..15 pixels
   COLORREF rgbInk;				// ink color
   DWORD dwAppParam;				// for application use
   DWORD dwDictParam;			// for app use to be passed on to dictionaries
   DWORD dwRecognizer;			// for app use to be passed on to recognizer
   UINT rgwReserved[cwRcReservedMax];	// reserved for future use by Windows
   }
   RC, FAR *LPRC;


typedef struct tagRCRESULT		// 1.0 Recognition Result
   {
   SYG syg;							// symbol graph
   UINT wResultsType;			// see RCRT_xx
   int cSyv;						// count of symbol values
   LPSYV lpsyv;					// NULL-term ptr to recog's best guess
   HANDLE hSyv;					// globally-shared handle to lpsyv mem
   int nBaseLine;					// 0 or baseline of input writing
   int nMidLine;					// ditto midline
   HPENDATA hpendata;			// pen data mem
   RECT rectBoundInk;			// ink data bounds
   POINT pntEnd;					// pt that terminated recog
   LPRC lprc;						// recog context used
   }
   RCRESULT, FAR *LPRCRESULT;

typedef int			(CALLBACK *LPFUNCRESULTS)(LPRCRESULT, REC);

#endif /*!NOPENRC1 */


//---------------------------------------------------------------------------
#ifndef NOPENTARGET

typedef struct tagTARGET		// 2.0 Geometry for a single target.
   {
   DWORD dwFlags;					// individual target flags
   WORD idTarget;					// TARGINFO.rgTarget[] index
   HTRG  htrgTarget;				// DWORD equiv
   RECTL rectBound;				// Bounding rect of the target
   DWORD dwData;					// data collection info per target
   RECTL rectBoundInk;			// Reserved for internal use, must be zero
   RECTL rectBoundLastInk;		// Reserved for internal use, must be zero
   }
   TARGET, FAR *LPTARGET;

typedef struct tagTARGINFO		// 2.0 A set of targets
   {
	DWORD cbSize;					// sizeof(TARGINFO)
   DWORD dwFlags;					// flags
   HTRG htrgOwner;				// DWORD equiv
   WORD cTargets;					// count of targets
   WORD iTargetLast;				// last target, used by TargetPoints API
										// if TPT_TEXTUAL flag is set
   TARGET rgTarget[1];			// variable-length array of targets
   }
   TARGINFO, FAR *LPTARGINFO;

typedef struct tagINPPARAMS	// 2.0 
   {
   DWORD cbSize;              // sizeof(INPPARAMS)
   DWORD dwFlags;
   HPENDATA hpndt;
   TARGET target;					// target structure
   }
	INPPARAMS, FAR *LPINPPARAMS;
#endif /*!NOPENTARGET */


//////////////////////////////////////////////////////////////////////////////
/****** APIs and Prototypes *************************************************/
																										

LRESULT CALLBACK	DefPenWindowProc(HWND, UINT, WPARAM, LPARAM);

//---------------------------------------------------------------------------
#ifndef NOPENAPPS	// not available in WINPAD

// Pen System Applications:
BOOL		WINAPI ShowKeyboard(HWND, UINT, LPPOINT, LPSKBINFO);

#endif /*!NOPENAPPS */

//---------------------------------------------------------------------------
#ifndef NOPENDATA	// these APIs are implemented in PKPD.DLL

// PenData:
HPENDATA	WINAPI AddPointsPenData(HPENDATA, LPPOINT, LPVOID, LPSTROKEINFO);
LPPENDATA WINAPI BeginEnumStrokes(HPENDATA);
HPENDATA	WINAPI CompactPenData(HPENDATA, UINT);
int		WINAPI CompressPenData(HPENDATA, UINT, DWORD);
HPENDATA	WINAPI CreatePenData(LPPENINFO, int, UINT, UINT);
HPENDATA	WINAPI CreatePenDataEx(LPPENINFO, UINT, UINT, UINT);
HRGN		WINAPI CreatePenDataRegion(HPENDATA, UINT);
BOOL		WINAPI DestroyPenData(HPENDATA);
VOID		WINAPI DrawPenData(HDC, LPRECT, HPENDATA);
int		WINAPI DrawPenDataEx(HDC, LPRECT, HPENDATA, UINT, UINT, UINT, UINT,
						ANIMATEPROC, LPANIMATEINFO, UINT);
HPENDATA	 WINAPI DuplicatePenData(HPENDATA, UINT);
LPPENDATA WINAPI EndEnumStrokes(HPENDATA);
int		WINAPI ExtractPenDataPoints(HPENDATA, UINT, UINT, UINT, LPPOINT,
						LPVOID, UINT);
int		WINAPI ExtractPenDataStrokes(HPENDATA, UINT, LPARAM,
						LPHPENDATA, UINT);
int		WINAPI GetPenDataAttributes(HPENDATA, LPVOID, UINT);
BOOL		WINAPI GetPenDataInfo(HPENDATA, LPPENDATAHEADER, LPPENINFO, DWORD);
BOOL		WINAPI GetPenDataStroke(LPPENDATA, UINT, LPPOINT FAR*,
						LPVOID FAR*,	LPSTROKEINFO );
BOOL		WINAPI GetPointsFromPenData(HPENDATA, UINT, UINT, UINT, LPPOINT);
int		WINAPI GetStrokeAttributes(HPENDATA, UINT, LPVOID, UINT);
int		WINAPI GetStrokeTableAttributes(HPENDATA, UINT, LPVOID, UINT);
int		WINAPI HitTestPenData(HPENDATA, LPPOINT, UINT, UINT FAR*, UINT FAR*);
int		WINAPI InsertPenData(HPENDATA, HPENDATA, UINT);
int		WINAPI InsertPenDataPoints(HPENDATA, UINT, UINT, UINT,
						LPPOINT, LPVOID);
int		WINAPI InsertPenDataStroke(HPENDATA, UINT, LPPOINT, LPVOID, 
						LPSTROKEINFO);
BOOL		WINAPI MetricScalePenData(HPENDATA, UINT);
BOOL		WINAPI OffsetPenData(HPENDATA, int, int);
int		WINAPI PenDataFromBuffer(LPHPENDATA, UINT, LPBYTE, int, LPDWORD);
int		WINAPI PenDataToBuffer(HPENDATA, LPBYTE, int, LPDWORD);
BOOL		WINAPI RedisplayPenData(HDC, HPENDATA, LPPOINT, LPPOINT,
						int, DWORD);
int		WINAPI RemovePenDataStrokes(HPENDATA, UINT, UINT);
BOOL		WINAPI ResizePenData(HPENDATA, LPRECT);
int		WINAPI SetStrokeAttributes(HPENDATA, UINT, LPARAM, UINT);
int		WINAPI SetStrokeTableAttributes(HPENDATA, UINT, LPARAM, UINT);
int		WINAPI TrimPenData(HPENDATA, DWORD, DWORD);


#endif /*!NOPENDATA */

//---------------------------------------------------------------------------
#ifndef NOPENDICT	// not available in WINPAD

// Dictionary:
BOOL		WINAPI DictionarySearch(LPRC, LPSYE, int, LPSYV, int);
#endif /*!NOPENDICT */

//---------------------------------------------------------------------------
#ifndef NOPENDRIVER

// Pen Hardware/Driver:
BOOL		WINAPI EndPenCollection(REC);
BOOL		WINAPI GetPenAsyncState(UINT);
REC		WINAPI GetPenHwData(LPPOINT, LPVOID, int, UINT, LPSTROKEINFO);
REC		WINAPI GetPenHwEventData(UINT, UINT, LPPOINT, LPVOID,
						int, LPSTROKEINFO);
BOOL		WINAPI IsPenEvent(UINT, LONG);
BOOL		WINAPI SetPenHook(HKP, LPFNRAWHOOK);
VOID		WINAPI UpdatePenInfo(LPPENINFO);
#endif /*!NOPENDRIVER */

//---------------------------------------------------------------------------
#ifndef NOPENGEST	// not available in WINPAD

// Gesture Management:
BOOL		WINAPI ExecuteGesture(HWND, SYV, LPRCRESULT);
#endif /*!NOPENGEST */

//---------------------------------------------------------------------------
#ifndef NOPENHRC

// Handwriting Recognizer:
int		WINAPI AddPenDataHRC(HRC, HPENDATA);
int		WINAPI AddPenInputHRC(HRC, LPPOINT, LPVOID, UINT, LPSTROKEINFO);
int		WINAPI AddWordsHWL(HWL, LPSTR, UINT);
int		WINAPI ConfigHREC(HREC, UINT, WPARAM, LPARAM);
HRC		WINAPI CreateCompatibleHRC(HRC, HREC);
HWL		WINAPI CreateHWL(HREC, LPVOID, UINT, DWORD);
HINKSET	WINAPI CreateInksetHRCRESULT(HRCRESULT, UINT, UINT);
HPENDATA WINAPI CreatePenDataHRC(HRC);
int		WINAPI DestroyHRC(HRC);
int		WINAPI DestroyHRCRESULT(HRCRESULT);
int		WINAPI DestroyHWL(HWL);
int		WINAPI EnableGestureSetHRC(HRC, SYV, BOOL);
int		WINAPI EnableSystemDictionaryHRC(HRC, BOOL);
int		WINAPI EndPenInputHRC(HRC);
int		WINAPI GetAlphabetHRC(HRC, LPALC, LPBYTE);
int		WINAPI GetAlphabetPriorityHRC(HRC, LPALC, LPBYTE);
int		WINAPI GetAlternateWordsHRCRESULT(HRCRESULT, UINT, UINT,
						LPHRCRESULT, UINT);
int		WINAPI GetBoxMappingHRCRESULT(HRCRESULT, UINT, UINT, UINT FAR*);
int      WINAPI GetBoxResultsHRC(HRC, UINT, UINT, UINT, LPBOXRESULTS, BOOL);
int		WINAPI GetGuideHRC(HRC, LPGUIDE, UINT FAR*);
int		WINAPI GetHotspotsHRCRESULT(HRCRESULT, UINT, LPPOINT, UINT);
HREC		WINAPI GetHRECFromHRC(HRC);
int		WINAPI GetInternationalHRC(HRC, UINT FAR*, LPSTR, UINT FAR*,
						UINT FAR*);
int		WINAPI GetMaxResultsHRC(HRC);
int		WINAPI GetResultsHRC(HRC, UINT, LPHRCRESULT, UINT);
int		WINAPI GetSymbolCountHRCRESULT(HRCRESULT);
int		WINAPI GetSymbolsHRCRESULT(HRCRESULT, UINT, LPSYV, UINT);
int		WINAPI GetWordlistHRC(HRC, LPHWL);
int		WINAPI GetWordlistCoercionHRC(HRC);
int		WINAPI ProcessHRC(HRC, DWORD);
int		WINAPI ReadHWL(HWL, HFILE);
int		WINAPI SetAlphabetHRC(HRC, ALC, LPBYTE);
int		WINAPI SetAlphabetPriorityHRC(HRC, ALC, LPBYTE);
int		WINAPI SetBoxAlphabetHRC(HRC, LPALC, UINT);
int		WINAPI SetGuideHRC(HRC, LPGUIDE, UINT);
int		WINAPI SetInternationalHRC(HRC, UINT, LPCSTR, UINT, UINT);
int		WINAPI SetMaxResultsHRC(HRC, UINT);
int		WINAPI SetResultsHookHREC(HREC, HRCRESULTHOOKPROC);
int		WINAPI SetWordlistCoercionHRC(HRC, UINT);
int		WINAPI SetWordlistHRC(HRC, HWL);
int		WINAPI TrainHREC(HREC, LPSYV, UINT, HPENDATA, UINT);
int		WINAPI UnhookResultsHookHREC(HREC, HRCRESULTHOOKPROC);
int		WINAPI WriteHWL(HWL, HFILE);

// Recognizer Installation:
HREC		WINAPI InstallRecognizer(LPSTR);
VOID		WINAPI UninstallRecognizer(HREC);

// Inksets:
BOOL		WINAPI AddInksetInterval(HINKSET, LPINTERVAL);
HINKSET	WINAPI CreateInkset(UINT);
BOOL		WINAPI DestroyInkset(HINKSET);
int		WINAPI GetInksetInterval(HINKSET, UINT, LPINTERVAL);
int		WINAPI GetInksetIntervalCount(HINKSET);

// Symbol Values:
int		WINAPI CharacterToSymbol(LPSTR, int, LPSYV);
BOOL		WINAPI SymbolToCharacter(LPSYV, int, LPSTR, LPINT);
#endif /*!NOPENHRC */

//---------------------------------------------------------------------------
#ifndef NOPENINKPUT

// Pen Input/Inking:
int		WINAPI DoDefaultPenInput(HWND, UINT);
int		WINAPI GetPenInput(HPCM, LPPOINT, LPVOID, UINT, UINT, LPSTROKEINFO);
int		WINAPI PeekPenInput(HPCM, UINT, LPPOINT, LPVOID, UINT);
int		WINAPI StartInking(HPCM, UINT, LPINKINGINFO);
HPCM		WINAPI StartPenInput(HWND, UINT, LPPCMINFO, LPINT);
int		WINAPI StopInking(HPCM);
int		WINAPI StopPenInput(HPCM, UINT, int);
#endif /*!NOPENINKPUT */

//---------------------------------------------------------------------------
#ifndef NOPENMISC

// Miscellaneous/Utilities:
VOID		WINAPI BoundingRectFromPoints(LPPOINT, int, LPRECT);
BOOL		WINAPI DPtoTP(LPPOINT, int);
UINT		WINAPI GetPenAppFlags(VOID);
LONG		WINAPI GetPenMiscInfo(WPARAM, LPARAM);
UINT		WINAPI GetVersionPenWin(VOID);
UINT		WINAPI IsPenAware(VOID);
VOID		WINAPI RegisterPenApp(UINT, UINT);
LONG		WINAPI SetPenMiscInfo(WPARAM, LPARAM);
BOOL		WINAPI TPtoDP(LPPOINT, int);

#ifndef WINPAD
BOOL		WINAPI CorrectWriting(HWND, LPSTR, UINT, LPVOID, DWORD, DWORD);
#endif //!WINPAD

#endif /*!NOPENMISC */

//---------------------------------------------------------------------------
#ifndef NOPENRC1	// not available in WINPAD

// RC1:
VOID		WINAPI EmulatePen(BOOL);
UINT		WINAPI EnumSymbols(LPSYG, UINT, ENUMPROC, LPVOID);
VOID		WINAPI FirstSymbolFromGraph(LPSYG, LPSYV, int, LPINT);
UINT		WINAPI GetGlobalRC(LPRC, LPSTR, LPSTR, int);
int		WINAPI GetSymbolCount(LPSYG);
int		WINAPI GetSymbolMaxLength(LPSYG);
VOID		WINAPI InitRC(HWND, LPRC);
REC		WINAPI ProcessWriting(HWND, LPRC);    
REC		WINAPI Recognize(LPRC);
REC		WINAPI RecognizeData(LPRC, HPENDATA);
UINT		WINAPI SetGlobalRC(LPRC, LPSTR, LPSTR);
BOOL		WINAPI SetRecogHook(UINT, UINT, HWND);
BOOL		WINAPI TrainContext(LPRCRESULT, LPSYE, int, LPSYC, int);
BOOL		WINAPI TrainInk(LPRC, HPENDATA, LPSYV);

// Custom Recognizer functions - not PenWin APIs (formerly in penwoem.h):
VOID		WINAPI CloseRecognizer(VOID);
UINT		WINAPI ConfigRecognizer(UINT, WPARAM, LPARAM);
BOOL		WINAPI InitRecognizer(LPRC);
REC 		WINAPI RecognizeDataInternal(LPRC, HPENDATA, LPFUNCRESULTS);
REC 		WINAPI RecognizeInternal(LPRC, LPFUNCRESULTS);
BOOL		WINAPI TrainContextInternal(LPRCRESULT, LPSYE, int, LPSYC, int);
BOOL		WINAPI TrainInkInternal(LPRC, HPENDATA, LPSYV);
#endif /*!NOPENRC1 */

//---------------------------------------------------------------------------
#ifndef NOPENTARGET

// Ink Targeting:
int		WINAPI TargetPoints(LPTARGINFO, LPPOINT, DWORD, UINT, LPSTROKEINFO);

#endif /*!NOPENTARGET */


//---------------------------------------------------------------------------
#ifndef NOPENVIRTEVENT

// Virtual Event Layer:
VOID		WINAPI AtomicVirtualEvent(BOOL);
VOID		WINAPI PostVirtualKeyEvent(UINT, BOOL);
VOID		WINAPI PostVirtualMouseEvent(UINT, int, int);
#endif /*!NOPENVIRTEVENT */

//---------------------------------------------------------------------------

#ifdef  JAPAN
// Kanji
BOOL		WINAPI KKConvert(HWND hwndConvert, HWND hwndCaller,
						LPSTR lpBuf, UINT cbBuf, LPPOINT lpPnt);
#endif //  JAPAN


#endif /* RC_INVOKED */	// ... all the way back from definitions:3

/****** End of Header Info *************************************************/


#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif /* RC_INVOKED */

#endif /* #define _INC_PENWIN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\pif.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1991-1994
 *  All Rights Reserved.
 *
 *
 *  PIF.H
 *  DOS Program Information File structures, constants, etc.
 */


#ifndef _INC_PIF
#define _INC_PIF

#define PIFNAMESIZE     30
#define PIFSTARTLOCSIZE 63
#define PIFDEFPATHSIZE  64
#define PIFPARAMSSIZE   64
#define PIFSHPROGSIZE   64
#define PIFSHDATASIZE   64
#define PIFDEFFILESIZE  80

#ifndef LF_FACESIZE
#define LF_FACESIZE     32
#endif

#define LARGEST_GROUP   sizeof(STDPIF)

#define OPENPROPS_NONE          0x0000
#define OPENPROPS_RAWIO         0x0001

#define GETPROPS_NONE           0x0000
#define GETPROPS_RAWIO          0x0001
#define GETPROPS_EXTENDED       0x0004

#define SETPROPS_NONE           0x0000
#define SETPROPS_RAWIO          0x0001
#define SETPROPS_CACHE          0x0002
#define SETPROPS_EXTENDED       0x0004

#define FLUSHPROPS_NONE         0x0000
#define FLUSHPROPS_DISCARD      0x0001

#define CLOSEPROPS_NONE         0x0000
#define CLOSEPROPS_DISCARD      0x0001

#define LOADPROPLIB_DEFER       0x0001


/* XLATOFF */
#ifndef FAR
#define FAR
#endif
/* XLATON */

#ifdef  RECT
#define _INC_WINDOWS
#endif

#ifndef _INC_WINDOWS

/* ASM
RECT    struc
        rcLeft      dw  ?
        rcTop       dw  ?
        rcRight     dw  ?
        rcBottom    dw  ?
RECT    ends
*/

/* XLATOFF */
typedef struct tagRECT {
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT *PRECT;
typedef RECT FAR *LPRECT;
/* XLATON */

#endif


/*
 *  Property groups, used by PIFMGR.DLL and VxD interfaces
 *
 *  The structures for each of the pre-defined, ordinal-based groups
 *  is a logical view of data in the associated PIF file, if any -- not a
 *  physical view.
 */

#define GROUP_PRG               1           // program group

#define PRG_DEFAULT		(PRG_CLOSEONEXIT | PRG_AUTOWINEXEC)
#define PRG_CLOSEONEXIT         0x0001      // MSflags & EXITMASK
//#define PRG_RESERVED          0x0002      // Reserved
#define PRG_AUTOWINEXEC 	0x0004	    // !(PfW386Flags & fDisAutoWinExec)

#define PRGINIT_DEFAULT         0
#define PRGINIT_MINIMIZED       0x0001      // PfW386Flags & fMinimized  (NEW)
#define PRGINIT_MAXIMIZED       0x0002      // PfW386Flags & fMaximized  (NEW)
#define PRGINIT_USEPIFICON      0x0004      // PfW386Flags & fUsePIFIcon (NEW)
#define PRGINIT_REALMODE        0x0008      // PfW386Flags & fRealMode   (NEW)
#define PRGINIT_NOPIF           0x1000      // (NEW -- informational only)
#define PRGINIT_DEFAULTPIF      0x2000      // (NEW -- informational only)

#define ICONFILE_DEFAULT        "PIFMGR.DLL"
#define ICONINDEX_DEFAULT       0

typedef struct PROPPRG {                    /* prg */
    WORD    flPrg;                          // see PRG_ flags
    WORD    flPrgInit;                      // see PRGINIT_ flags
    char    achTitle[PIFNAMESIZE];          // name[30]
    char    achCmdLine[PIFSTARTLOCSIZE];    // startfile[63] + params[64]
    char    achWorkDir[PIFDEFPATHSIZE];     // defpath[64]
    WORD    wHotKey;			    // PfHotKeyScan thru PfHotKeyVal
    BYTE    rgbReserved[6];		    // (Reserved)
    char    achIconFile[PIFDEFFILESIZE];    // (NEW)
    WORD    wIconIndex;                     // (NEW)
    char    achPIFFile[PIFDEFFILESIZE];     // (NEW)
} PROPPRG;
typedef PROPPRG *PPROPPRG;
typedef PROPPRG FAR *LPPROPPRG;
typedef const PROPPRG FAR *LPCPROPPRG;


#define GROUP_TSK               2           // multi-tasking group

#define TSK_DEFAULT             (TSK_BACKGROUND)
#define TSK_ALLOWCLOSE          0x0001      // PfW386Flags & fEnableClose (SAME BIT)
#define TSK_BACKGROUND          0x0002      // PfW386Flags & fBackground  (SAME BIT)
#define TSK_EXCLUSIVE           0x0004      // PfW386Flags & fExclusive   (SAME BIT)
#define TSK_FAKEBOOST           0x0008      // (NEW -- informational only)
#define TSK_NOWARNTERMINATE	0x0010	    // Don't warn before terminating (NEW)
#define TSK_NOSCREENSAVER	0x0020	    // Do not activate screen saver (NEW)

#define TSKINIT_DEFAULT         0

#define TSKFGND_DEFAULT         75          // normal fgnd % (NEW)
#define TSKBGND_DEFAULT         25          // normal bgnd % (NEW)

#define TSKFGND_OLD_DEFAULT     100         // normal fgnd setting
#define TSKBGND_OLD_DEFAULT     50          // normal bgnd setting

#define TSKBOOSTTIME_MIN        0           // in # milliseconds
#define TSKBOOSTTIME_DEFAULT    1           // in # milliseconds
#define TSKBOOSTTIME_MAX        5000        // in # milliseconds
#define TSKIDLEDELAY_MIN        0           // in # milliseconds
#define TSKIDLEDELAY_DEFAULT    500         // in # milliseconds
#define TSKIDLEDELAY_MAX        5000        // in # milliseconds
#define TSKIDLESENS_DEFAULT     50          // % (min-max == 0-100)

typedef struct PROPTSK {                    /* tsk */
    WORD    flTsk;                          // see TSK_ flags
    WORD    flTskInit;                      // see TSKINIT_ flags
    short   iFgndBoost;                     // PfFPriority (NEW, converted to boost)
    short   iBgndBoost;                     // PfBPriority (NEW, converted to boost)
    WORD    msKeyBoostTime;                 // ([386Enh]:KeyBoostTime)
    WORD    msKeyIdleDelay;                 // ([386Enh]:KeyIdleDelay)
    WORD    wIdleSensitivity;               // PfW386Flags & fPollingDetect (NEW, %)
} PROPTSK;
typedef PROPTSK *PPROPTSK;
typedef PROPTSK FAR *LPPROPTSK;


#define GROUP_VID               3           // video group

#define VID_DEFAULT             (VID_TEXTEMULATE | VID_FULLSCREENGRFX | VID_AUTOSUSPEND)
#define VID_TEXTEMULATE         0x0001      // PfW386Flags2 & fVidTxtEmulate  (SAME BIT)
#define VID_TEXTTRAP            0x0002      // PfW386Flags2 & fVidNoTrpTxt    (INVERTED BIT)
#define VID_LOGRFXTRAP          0x0004      // PfW386Flags2 & fVidNoTrpLRGrfx (INVERTED BIT)
#define VID_HIGRFXTRAP          0x0008      // PfW386Flags2 & fVidNoTrpHRGrfx (INVERTED BIT)
#define VID_RETAINMEMORY        0x0080      // PfW386Flags2 & fVidRetainAllo  (SAME BIT)
#define VID_FULLSCREEN          0x0100      // PfW386Flags  & fFullScreen
#define VID_FULLSCREENGRFX      0x0200      // PfW386Flags2 & fFullScreenGrfx (NEW)

#define VIDINIT_DEFAULT         0

#define VIDMODE_DEFAULT         VIDMODE_TEXT
#define VIDMODE_TEXT            1           // PfW386Flags2 & fVidTextMd
#define VIDMODE_LOGRFX          2           // PfW386Flags2 & fVidLowRsGrfxMd
#define VIDMODE_HIGRFX          3           // PfW386Flags2 & fVidHghRsGrfxMd

#define VIDSCROLLFREQ_MIN       1           // in # lines
#define VIDSCROLLFREQ_DEFAULT   2           // in # lines
#define VIDSCROLLFREQ_MAX       25          // in # lines

#define VIDUPDATEFREQ_MIN       10          // in # milliseconds
#define VIDUPDATEFREQ_DEFAULT   50          // in # milliseconds
#define VIDUPDATEFREQ_MAX       5000        // in # milliseconds

#define VIDSCREENLINES_MIN      0           // in # lines (0 = use VDD value)
#define VIDSCREENLINES_DEFAULT  0           // in # lines

typedef struct PROPVID {                    /* vid */
    WORD    flVid;                          // see VID_ flags
    WORD    flVidInit;                      // see VIDINIT_ flags
    WORD    iVidMode;                       // see VIDMODE_ ordinals
    WORD    cScrollFreq;                    // ([386Enh]:ScrollFrequency)
    WORD    msUpdateFreq;                   // ([386Enh]:WindowUpdateTime)
    WORD    cScreenLines;                   // ([NonWindowsApp]:ScreenLines)
    BYTE    abTextColorRemap[16];           // (NEW)
} PROPVID;
typedef PROPVID *PPROPVID;
typedef PROPVID FAR *LPPROPVID;


#define GROUP_MEM               4           // memory group

#define MEM_DEFAULT             0

#define MEMINIT_DEFAULT         0
#define MEMINIT_NOHMA           0x0001      // PfW386Flags & fNoHMA
#define MEMINIT_LOWLOCKED       0x0002      // PfW386Flags & fVMLocked
#define MEMINIT_EMSLOCKED       0x0004      // PfW386Flags & fEMSLocked
#define MEMINIT_XMSLOCKED       0x0008      // PfW386Flags & fXMSLocked
#define MEMINIT_GLOBALPROTECT   0x0010      // PfW386Flags & fGlobalProtect (NEW)
#define MEMINIT_STRAYPTRDETECT  0x0020      // PfW386Flags & fStrayPtrDetect(NEW)

#define MEMLOW_MIN_MIN          0xFFFF      // in KB
#define MEMLOW_MIN_DEFAULT      0           // in KB
#define MEMLOW_MIN_MAX          640         // in KB

#define MEMLOW_MAX_MIN          0xFFFF      // in KB
#define MEMLOW_MAX_DEFAULT      0xFFFF      // in KB
#define MEMLOW_MAX_MAX          640         // in KB

#define MEMEMS_MIN_MIN          0           // in KB
#define MEMEMS_MIN_DEFAULT      0           // in KB
#define MEMEMS_MIN_MAX          16384       // in KB

#define MEMEMS_MAX_MIN          0xFFFF      // in KB (-1 means "no limit")
#define MEMEMS_MAX_DEFAULT      1024        // in KB
#define MEMEMS_MAX_MAX          16384       // in KB

#define MEMXMS_MIN_MIN          0           // in KB
#define MEMXMS_MIN_DEFAULT      0           // in KB
#define MEMXMS_MIN_MAX          16384       // in KB

#define MEMXMS_MAX_MIN          0xFFFF      // in KB (-1 means "no limit")
#define MEMXMS_MAX_DEFAULT      1024        // in KB
#define MEMXMS_MAX_MAX          16384       // in KB

typedef struct PROPMEM {                    /* mem */
    WORD    flMem;                          // see MEM_ flags
    WORD    flMemInit;                      // see MEMINIT_ flags
    WORD    wMinLow;                        // PfW386minmem
    WORD    wMaxLow;                        // PfW386maxmem
    WORD    wMinEMS;                        // PfMinEMMK
    WORD    wMaxEMS;                        // PfMaxEMMK
    WORD    wMinXMS;                        // PfMinXmsK
    WORD    wMaxXMS;                        // PfMaxXmsK
} PROPMEM;
typedef PROPMEM *PPROPMEM;
typedef PROPMEM FAR *LPPROPMEM;


#define GROUP_KBD               5           // keyboard group

#define KBD_DEFAULT             (KBD_FASTPASTE)
#define KBD_FASTPASTE           0x0001      // PfW386Flags & fINT16Paste
#define KBD_NOALTTAB            0x0020      // PfW386Flags & fALTTABdis   (SAME BIT)
#define KBD_NOALTESC            0x0040      // PfW386Flags & fALTESCdis   (SAME BIT)
#define KBD_NOALTSPACE          0x0080      // PfW386Flags & fALTSPACEdis (SAME BIT)
#define KBD_NOALTENTER          0x0100      // PfW386Flags & fALTENTERdis (SAME BIT)
#define KBD_NOALTPRTSC          0x0200      // PfW386Flags & fALTPRTSCdis (SAME BIT)
#define KBD_NOPRTSC             0x0400      // PfW386Flags & fPRTSCdis    (SAME BIT)
#define KBD_NOCTRLESC           0x0800      // PfW386Flags & fCTRLESCdis  (SAME BIT)

#define KBDINIT_DEFAULT         0

#define KBDALTDELAY_MIN             1
#define KBDALTDELAY_DEFAULT         5
#define KBDALTDELAY_MAX             5000

#define KBDALTPASTEDELAY_MIN        1
#define KBDALTPASTEDELAY_DEFAULT    25
#define KBDALTPASTEDELAY_MAX        5000

#define KBDPASTEDELAY_MIN           1
#define KBDPASTEDELAY_DEFAULT       3
#define KBDPASTEDELAY_MAX           5000

#define KBDPASTEFULLDELAY_MIN       1
#define KBDPASTEFULLDELAY_DEFAULT   200
#define KBDPASTEFULLDELAY_MAX       5000

#define KBDPASTETIMEOUT_MIN         1
#define KBDPASTETIMEOUT_DEFAULT     1000
#define KBDPASTETIMEOUT_MAX         5000

#define KBDPASTESKIP_MIN            1
#define KBDPASTESKIP_DEFAULT        2
#define KBDPASTESKIP_MAX            100

#define KBDPASTECRSKIP_MIN          1
#define KBDPASTECRSKIP_DEFAULT      10
#define KBDPASTECRSKIP_MAX          100

typedef struct PROPKBD {                    /* kbd */
    WORD    flKbd;                          // see KBD_ flags
    WORD    flKbdInit;                      // see KBDINIT_ flags
    WORD    msAltDelay;                     // ([386Enh]:AltKeyDelay)
    WORD    msAltPasteDelay;                // ([386Enh]:AltPasteDelay)
    WORD    msPasteDelay;                   // ([386Enh]:KeyPasteDelay)
    WORD    msPasteFullDelay;               // ([386Enh]:KeyBufferDelay)
    WORD    msPasteTimeout;                 // ([386Enh]:KeyPasteTimeOut)
    WORD    cPasteSkip;                     // ([386Enh]:KeyPasteSkipCount)
    WORD    cPasteCRSkip;                   // ([386Enh]:KeyPasteCRSkipCount)
} PROPKBD;
typedef PROPKBD *PPROPKBD;
typedef PROPKBD FAR *LPPROPKBD;


#define GROUP_MSE               6           // mouse group

/* No VxD currently pays attention to PROPMSE. VMDOSAPP should know how to
 * handle all cases resulting from a change in these flags.
 *
 * Note that MSE_WINDOWENABLE corresponds to the Windows NT "QuickEdit"
 * property, except backwards.
 */

#define MSE_DEFAULT             (MSE_WINDOWENABLE)
#define MSE_WINDOWENABLE        0x0001      // ([NonWindowsApp]:MouseInDosBox)
#define MSE_EXCLUSIVE		0x0002	    // (NEW)

#define MSEINIT_DEFAULT         0           // default flags

typedef struct PROPMSE {                    /* mse */
    WORD    flMse;                          // see MSE_ flags
    WORD    flMseInit;                      // see MSEINIT_ flags
} PROPMSE;
typedef PROPMSE *PPROPMSE;
typedef PROPMSE FAR *LPPROPMSE;


#define GROUP_TMR               7           // timer group

#define TMR_DEFAULT             0
#define TMR_TRAPTMRPORTS        0x0001      // (NEW)
#define TMR_FULLBGNDTICKS       0x0002      // (NEW)
#define TMR_BURSTMODE           0x0004      // (NEW)
#define TMR_PATCHEOI            0x0008      // (NEW)

#define TMRINIT_DEFAULT         0

#define TMRBURSTDELAY_MIN       0
#define TMRBURSTDELAY_DEFAULT   0
#define TMRBURSTDELAY_MAX       100

typedef struct PROPTMR {                    /* tmr */
    WORD    flTmr;                          // see TMR_ flags
    WORD    flTmrInit;                      // see TMRINIT_ flags
    WORD    wBurstDelay;
} PROPTMR;
typedef PROPTMR *PPROPTMR;
typedef PROPTMR FAR *LPPROPTMR;

// Extended TIMER data

typedef struct PROPTMREXT {                 /* tmrext */
    PROPTMR tmrData;                        //
    WORD    msIntFreq;                      // current interrupt frequency (in ms.)
    WORD    wExecPercent;                   // current *actual* execution percentage
} PROPTMREXT;
typedef PROPTMREXT *PPROPTMREXT;
typedef PROPTMREXT FAR *LPPROPTMREXT;


#define GROUP_FNT               11          // font group

#define FNT_DEFAULT             (FNT_BOTHFONTS)
#define FNT_RASTERFONTS         0x0004      // allow raster fonts in dialog
#define FNT_TTFONTS             0x0008      // allow truetype fonts in dialog
#define FNT_BOTHFONTS           (FNT_RASTERFONTS | FNT_TTFONTS)
#define FNT_AUTOSIZE            0x0010      // enable auto-sizing
#define FNT_RASTER              0x0400      // specified font is raster
#define FNT_TT                  0x0800      // specified font is truetype

#define FNT_FONTMASK            (FNT_BOTHFONTS)
#define FNT_FONTMASKBITS        2           // # of bits shifted left

#define FNTINIT_DEFAULT         0
#define FNTINIT_NORESTORE       0x0001      // don't restore on restart

typedef struct PROPFNT {                    /* fnt */
    WORD    flFnt;                          // see FNT_ flags
    WORD    flFntInit;                      // see FNTINIT_ flags
    WORD    cxFont;                         // width of desired font
    WORD    cyFont;                         // height of desired font
    WORD    cxFontActual;                   // actual width of desired font
    WORD    cyFontActual;                   // actual height of desired font
    char    achRasterFaceName[LF_FACESIZE]; // name to use for raster font
    char    achTTFaceName[LF_FACESIZE];     // name to use for tt font
#ifdef JAPAN //CodePage Support
    WORD    wCharSet;                       // Character Set
#endif
} PROPFNT;
typedef PROPFNT *PPROPFNT;
typedef PROPFNT FAR *LPPROPFNT;

#define GROUP_WIN               12          // window group

#define WIN_DEFAULT             (WIN_SAVESETTINGS)
#define WIN_SAVESETTINGS        0x0001      // save settings on exit (default)
#define WIN_TOOLBAR             0x0002      // enable toolbar

#define WININIT_DEFAULT         0
#define WININIT_NORESTORE       0x0001      // don't restore on restart

typedef struct PROPWIN {                    /* win */
    WORD    flWin;                          // see WIN_ flags
    WORD    flWinInit;                      // see WININIT flags
    WORD    cxCells;                        // width in cells
    WORD    cyCells;                        // height in cells
    WORD    cxClient;                       // width of client window
    WORD    cyClient;                       // height of client window
    WORD    cxWindow;                       // width of entire window
    WORD    cyWindow;                       // height of entire window
#ifdef WPF_SETMINPOSITION                   // if windows.h is included
    WINDOWPLACEMENT wp;                     // then use WINDOWPLACEMENT type
#else                                       // else define equivalent structure
    WORD    wLength;
    WORD    wShowFlags;
    WORD    wShowCmd;
    WORD    xMinimize;
    WORD    yMinimize;
    WORD    xMaximize;
    WORD    yMaximize;
    RECT    rcNormal;
#endif
} PROPWIN;
typedef PROPWIN *PPROPWIN;
typedef PROPWIN FAR *LPPROPWIN;

#define GROUP_ENV               13          // environment/startup group

#define ENV_DEFAULT             0

#define ENVINIT_DEFAULT         (ENVINIT_INSTRUCTIONS)
#define ENVINIT_INSTRUCTIONS    0x0001      // ([386Enh]:DOSPromptExitInstruc)

#define ENVSIZE_MIN             0
#define ENVSIZE_DEFAULT         0
#define ENVSIZE_MAX             4096

typedef struct PROPENV {                    /* env */
    WORD    flEnv;                          // see ENV_ flags
    WORD    flEnvInit;                      // see ENVINIT_ flags
    char    achBatchFile[PIFDEFFILESIZE];   // (NEW)
    WORD    cbEnvironment;                  // ([386Enh]:CommandEnvSize)
#ifdef JAPAN //CodePage Support
    WORD    wCodePage;                      // Current CodePage
    WORD    wInitCodePage;                  // Initial CodePage
#endif
} PROPENV;
typedef PROPENV *PPROPENV;
typedef PROPENV FAR *LPPROPENV;


#define MAX_GROUP               0x0FF
#define MAX_VALID_GROUP         GROUP_ENV

/*
 * Additional group ordinal bits that can be passed to VxD property hooks
 */
#define EXT_GROUP_QUERY         0x100
#define EXT_GROUP_UPDATE        0x200


/*
 *  PIF "file" structures, used by .PIFs
 */

#define PIFEXTSIGSIZE   16                  // Length of extension signatures
#define MAX_GROUP_NAME  PIFEXTSIGSIZE       //
#define STDHDRSIG       "MICROSOFT PIFEX"   // extsig value for stdpifext
#define LASTHDRPTR      0xFFFF              // This value in the
                                            //  extnxthdrfloff field indicates
                                            //   there are no more extensions.
#define W286HDRSIG30    "WINDOWS 286 3.0"
#define W386HDRSIG30    "WINDOWS 386 3.0"
#define WENHHDRSIG40    "WINDOWS PIF.402"   // (NEW)
#define WENHICOSIG001   "WINDOWS ICO.001"   // (NEW)


typedef struct PIFEXTHDR {                  /* peh */
    char    extsig[PIFEXTSIGSIZE];
    WORD    extnxthdrfloff;
    WORD    extfileoffset;
    WORD    extsizebytes;
} PIFEXTHDR;
typedef PIFEXTHDR *PPIFEXTHDR;
typedef PIFEXTHDR FAR *LPPIFEXTHDR;


/* Flags for MSflags
 */

#define fResident       0x01    // Directly Modifies: Memory
#define fGraphics       0x02    // Screen Exchange: Graphics/Text
#define fNoSwitch       0x04    // Program Switch: Prevent
#define fNoGrab         0x08    // Screen Exchange: None
#define fDestroy        0x10    // Close Window on exit
#define fCOM2           0x40    // Directly Modifies: COM2
#define fCOM1           0x80    // Directly Modifies: COM1

#define MEMMASK         fResident
#define GRAPHMASK       fGraphics
#define TEXTMASK        ((BYTE)(~GRAPHMASK))
#define PSMASK          fNoSwitch
#define SGMASK          fNoGrab
#define EXITMASK        fDestroy
#define COM2MASK        fCOM2
#define COM1MASK        fCOM1

/* Flags for behavior
 */
#define fScreen         0x80    // Directly Modifies: Screen
#define fForeground     0x40    // Set same as fScreen (alias)
#define f8087           0x20    // No PIFEDIT control
#define fKeyboard       0x10    // Directly Modifies: Keyboard

#define SCRMASK         (fScreen + fForeground)
#define MASK8087        f8087
#define KEYMASK         fKeyboard

/* Flags for sysflags
 */

#define SWAPMASK        0x20
#define PARMMASK        0x40

/*
 * All strings in the STDPIF are in the OEM character set.
 */
typedef struct STDPIF {                     /* std */ //Examples
    BYTE    unknown;                        // 0x00     0x00
    BYTE    id;                             // 0x01     0x78
    char    appname[PIFNAMESIZE];           // 0x02     'MS-DOS Prompt'
    WORD    maxmem;                         // 0x20     0x0200 (512Kb)
    WORD    minmem;                         // 0x22     0x0080 (128Kb)
    char    startfile[PIFSTARTLOCSIZE];     // 0x24     "COMMAND.COM"
    BYTE    MSflags;                        // 0x63     0x10
    BYTE    reserved;                       // 0x64     0x00
    char    defpath[PIFDEFPATHSIZE];        // 0x65     "\"
    char    params[PIFPARAMSSIZE];          // 0xA5     ""
    BYTE    screen;                         // 0xE5     0x00
    BYTE    cPages;                         // 0xE6     0x01 (ALWAYS!)
    BYTE    lowVector;                      // 0xE7     0x00 (ALWAYS!)
    BYTE    highVector;                     // 0xE8     0xFF (ALWAYS!)
    BYTE    rows;                           // 0xE9     0x19 (Not used)
    BYTE    cols;                           // 0xEA     0x50 (Not used)
    BYTE    rowoff;                         // 0xEB     0x00 (Not used)
    BYTE    coloff;                         // 0xEC     0x00 (Not used)
    WORD    sysmem;                         // 0xED   0x0007 (Not used; 7=>Text, 23=>Grfx/Mult Text)
    char    shprog[PIFSHPROGSIZE];          // 0xEF     0's  (Not used)
    char    shdata[PIFSHDATASIZE];          // 0x12F    0's  (Not used)
    BYTE    behavior;                       // 0x16F    0x00
    BYTE    sysflags;                       // 0x170    0x00 (Not used)
} STDPIF;
typedef STDPIF *PSTDPIF;
typedef STDPIF FAR *LPSTDPIF;


/* Flags for PfW286Flags
 */

#define fALTTABdis286   0x0001
#define fALTESCdis286   0x0002
#define fALTPRTSCdis286 0x0004
#define fPRTSCdis286    0x0008
#define fCTRLESCdis286  0x0010
#define fNoSaveVid286   0x0020              // New for 3.10
#define fCOM3_286       0x4000
#define fCOM4_286       0x8000

typedef struct W286PIF30 {                  /* 286 */ //Examples
    WORD    PfMaxXmsK;                      // 0x19D    0x0000
    WORD    PfMinXmsK;                      // 0x19F    0x0000
    WORD    PfW286Flags;                    // 0x1A1    0x0000
} W286PIF30;
typedef W286PIF30 *PW286PIF30;
typedef W286PIF30 FAR *LPW286PIF30;


/* Flags for PfW386Flags
 */

#define fEnableClose    0x00000001          //
#define fEnableCloseBit             0       //
#define fBackground     0x00000002          //
#define fBackgroundBit              1       //
#define fExclusive      0x00000004          //
#define fExclusiveBit               2       //
#define fFullScreen     0x00000008          //
#define fFullScreenBit              3       //
#define fALTTABdis      0x00000020          //
#define fALTTABdisBit               5       //
#define fALTESCdis      0x00000040          //
#define fALTESCdisBit               6       //
#define fALTSPACEdis    0x00000080          //
#define fALTSPACEdisBit             7       //
#define fALTENTERdis    0x00000100          //
#define fALTENTERdisBit             8       //
#define fALTPRTSCdis    0x00000200          //
#define fALTPRTSCdisBit             9       //
#define fPRTSCdis       0x00000400          //
#define fPRTSCdisBit                10      //
#define fCTRLESCdis     0x00000800          //
#define fCTRLESCdisBit              11      //
#define fPollingDetect  0x00001000          //
#define fPollingDetectBit           12      //
#define fNoHMA          0x00002000          //
#define fNoHMABit                   13      //
#define fHasHotKey      0x00004000          //
#define fHasHotKeyBit               14      //
#define fEMSLocked      0x00008000          //
#define fEMSLockedBit               15      //
#define fXMSLocked      0x00010000          //
#define fXMSLockedBit               16      //
#define fINT16Paste     0x00020000          //
#define fINT16PasteBit              17      //
#define fVMLocked       0x00040000          //
#define fVMLockedBit                18      //
#define fGlobalProtect  0x00080000          //  New for 4.00
#define fGlobalProtectBit           19      //  New for 4.00
#define fMinimized      0x00100000          //  New for 4.00
#define fMinimizedBit               20      //  New for 4.00
#define fMaximized      0x00200000          //  New for 4.00
#define fMaximizedBit               21      //  New for 4.00
#define fRealMode       0x00800000          //  New for 4.00
#define fRealModeBit                23      //  New for 4.00
#define fDisAutoWinExec 0x01000000          //  New for 4.00
#define fDisAutoWinExecBit	    24	    //	New for 4.00
#define fStrayPtrDetect 0x02000000          //  New for 4.00
#define fStrayPtrDetectBit          25      //  New for 4.00

/* Flags for PfW386Flags2
 *
 *  NOTE THAT THE LOW 16 BITS OF THIS DWORD ARE VDD RELATED
 *  NOTE THAT ALL OF THE LOW 16 BITS ARE RESERVED FOR VIDEO BITS
 *
 *  You cannot monkey with these bits locations without breaking
 *  all VDDs as well as all old PIFs. SO DON'T MESS WITH THEM.
 */

#define fVDDMask        0x0000FFFF          //
#define fVDDMinBit                  0       //
#define fVDDMaxBit                  15      //

#define fVidTxtEmulate  0x00000001          //
#define fVidTxtEmulateBit           0       //
#define fVidNoTrpTxt    0x00000002          //
#define fVidNoTrpTxtBit             1       //
#define fVidNoTrpLRGrfx 0x00000004          //
#define fVidNoTrpLRGrfxBit          2       //
#define fVidNoTrpHRGrfx 0x00000008          //
#define fVidNoTrpHRGrfxBit          3       //
#define fVidTextMd      0x00000010          //
#define fVidTextMdBit               4       //
#define fVidLowRsGrfxMd 0x00000020          //
#define fVidLowRsGrfxMdBit          5       //
#define fVidHghRsGrfxMd 0x00000040          //
#define fVidHghRsGrfxMdBit          6       //
#define fVidRetainAllo  0x00000080          //
#define fVidRetainAlloBit           7       //

/*
 * This mask is used to isolate status bits shared with VM_Descriptor
 */

#define PifDescMask \
(fALTTABdis   + fALTESCdis    + fALTSPACEdis + \
 fALTENTERdis + fALTPRTSCdis  + fPRTSCdis + \
 fCTRLESCdis  + fPollingDetect+ fNoHMA + \
 fHasHotKey   + fEMSLocked    + fXMSLocked + \
 fINT16Paste  + fVMLocked)


typedef struct W386PIF30 {                  /* 386 */ //Examples
    // These new maxmem/minmem fields allow values
    // that will not conflict with the 286-specific values
    WORD    PfW386maxmem;                   // 0x1B9    0xFFFF (-1)
    WORD    PfW386minmem;                   // 0x1BB    0xFFFF (-1)
    WORD    PfFPriority;                    // 0x1BD    0x0064 (100)
    WORD    PfBPriority;                    // 0x1BF    0x0032 (50)
    WORD    PfMaxEMMK;                      // 0x1C1    0x0000 (0)
    WORD    PfMinEMMK;                      // 0x1C3    0x0000 (0)
    WORD    PfMaxXmsK;                      // 0x1C5    0x0800 (2048)
    WORD    PfMinXmsK;                      // 0x1C7    0x0000 (0)
    DWORD   PfW386Flags;                    // 0x1C9    0x00021003
    DWORD   PfW386Flags2;                   // 0x1CD    0x0000001F
    WORD    PfHotKeyScan;                   // 0x1D1    Scan code in lower byte
    WORD    PfHotKeyShVal;                  // 0x1D3    Shift state
    WORD    PfHotKeyShMsk;                  // 0x1D5    Mask for shift states interested in
    BYTE    PfHotKeyVal;                    // 0x1D7    Enhanced flags
    BYTE    PfHotKeyPad[9];                 // 0x1D8    Pad Hot key section to 16 bytes
    char    PfW386params[PIFPARAMSSIZE];    // 0x1E1
} W386PIF30;
typedef W386PIF30 *PW386PIF30;
typedef W386PIF30 FAR *LPW386PIF30;


/* AssociateProperties associations
 */

#define HVM_ASSOCIATION         1
#define HWND_ASSOCIATION        2


/* SHEETTYPEs for AddPropertySheet/EnumPropertySheets
 */

#define SHEETTYPE_SIMPLE    0
#define SHEETTYPE_ADVANCED  1


/*  External function ordinals and prototypes
 */

#define ORD_OPENPROPERTIES      2
#define ORD_GETPROPERTIES       3
#define ORD_SETPROPERTIES       4
#define ORD_EDITPROPERTIES      5
#define ORD_FLUSHPROPERTIES     6
#define ORD_ENUMPROPERTIES      7
#define ORD_ASSOCIATEPROPERTIES 8
#define ORD_CLOSEPROPERTIES     9
#define ORD_LOADPROPERTYLIB     10
#define ORD_ENUMPROPERTYLIBS    11
#define ORD_FREEPROPERTYLIB     12
#define ORD_ADDPROPERTYSHEET    13
#define ORD_REMOVEPROPERTYSHEET 14
#define ORD_LOADPROPERTYSHEETS  15
#define ORD_ENUMPROPERTYSHEETS  16
#define ORD_FREEPROPERTYSHEETS  17


/* XLATOFF */
#ifdef WINAPI

int  WINAPI OpenProperties(LPCSTR lpszApp, int hInf, int flOpt);
int  WINAPI GetProperties(int hProps, LPCSTR lpszGroup, LPVOID lpProps, int cbProps, int flOpt);
int  WINAPI SetProperties(int hProps, LPCSTR lpszGroup, CONST VOID FAR *lpProps, int cbProps, int flOpt);
int  WINAPI EditProperties(int hProps, LPCSTR lpszTitle, UINT uStartPage, HWND hwnd, UINT uMsgPost);
int  WINAPI FlushProperties(int hProps, int flOpt);
int  WINAPI EnumProperties(int hProps);
long WINAPI AssociateProperties(int hProps, int iAssociate, long lData);
int  WINAPI CloseProperties(int hProps, int flOpt);

#ifdef  PIF_PROPERTY_SHEETS
int  WINAPI LoadPropertyLib(LPCSTR lpszDLL, int fLoad);
int  WINAPI EnumPropertyLibs(int iLib, LPHANDLE lphDLL, LPSTR lpszDLL, int cbszDLL);
BOOL WINAPI FreePropertyLib(int hLib);
int  WINAPI AddPropertySheet(const PROPSHEETPAGE FAR *lppsi, int iType);
BOOL WINAPI RemovePropertySheet(int hSheet);
int  WINAPI LoadPropertySheets(int hProps, int flags);
int  WINAPI EnumPropertySheets(int hProps, int iType, int iSheet, LPPROPSHEETPAGE lppsi);
int  WINAPI FreePropertySheets(int hProps, int flags);
#endif

#endif
/* XLATON */

#endif // _INC_PIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\pgchart.h ===
/***
*pgchart.h - Declare constants, functions and macros for charting library.
*
*  Copyright (c) 1988-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*  This file declares the presentation graphics library functions and
*  the structures and manifest constants that are used with them.
*
***************************************************************************/


#ifdef __cplusplus
extern "C" {				/* allow use with C++ */
#endif

#if (_MSC_VER <= 600)
#define	__cdecl	_cdecl
#define	__far	_far
#endif

/* Force word alignment to avoid possible -Zp override */
#pragma	pack(2)


/* Required for the missing value definition */
#ifndef	FLT_MAX
#define FLT_MAX			3.402823466e+38F	/* max value */
#endif

#define _PG_PALETTELEN		16	/* Number of entries in internal palette */
#define _PG_MAXCHARTTYPE	5	/* Maximum available chart type */
#define _PG_MAXCHARTSTYLE	2	/* Maximum chart style */
#define _PG_TITLELEN		70	/* Maximum title text length */

#define _PG_LEFT		1	/* Positions used for titles and legends */
#define _PG_CENTER		2
#define _PG_RIGHT		3
#define _PG_BOTTOM		4
#define _PG_OVERLAY		5

#define _PG_LINEARAXIS		1	/* Used to specify axis types */
#define _PG_LOGAXIS		2

#define _PG_DECFORMAT		1	/* Used to specify tic mark label format */
#define _PG_EXPFORMAT		2

#define _PG_BARCHART		1	/* Charttype for a bar chart */
#define _PG_COLUMNCHART		2	/* Charttype for a column chart */
#define  _PG_PLAINBARS		1	/* Styles for bar and column charts */
#define  _PG_STACKEDBARS	2

#define _PG_LINECHART		3	/* Charttype for a line chart */
#define _PG_SCATTERCHART	4	/* Charttype for a scatter chart */
#define _PG_POINTANDLINE	1	/* Styles for line and scatter charts */
#define _PG_POINTONLY		2

#define _PG_PIECHART		5	/* Charttype for pie chart */
#define _PG_PERCENT		1	/* Styles for pie charts */
#define _PG_NOPERCENT		2

#define _PG_MISSINGVALUE	(-FLT_MAX) /* Indicates missing data values */


/* Error codes */

/* Numbers greater than 100 will terminate chart routine, others will cause
 * default values to be used
 */
#define	_PG_NOTINITIALIZED	102	/* If library not initialized */
#define	_PG_BADSCREENMODE	103	/* Graphics mode not set before charting */
#define	_PG_BADCHARTSTYLE	04	/* Chart style invalid */
#define	_PG_BADCHARTTYPE	104	/* Chart type invalid */
#define	_PG_BADLEGENDWINDOW	105	/* Invalid legend window specified */
#define	_PG_BADCHARTWINDOW	07	/* x1=x2 or y1=y2 in chart window spec. */
#define	_PG_BADDATAWINDOW	107	/* If chart window is too small */
#define	_PG_NOMEMORY		108	/* Not enough memory for data arrays */
#define	_PG_BADLOGBASE		05	/* Log base <= 0 */
#define	_PG_BADSCALEFACTOR	06	/* Scale factor = 0 */
#define	_PG_TOOSMALLN		109	/* Number of data points <= 0 */
#define	_PG_TOOFEWSERIES	110	/* Number of series <= 0 */


/* Typedefs */

/* Typedef for chart title */
#ifndef _TITLETYPE_DEFINED
typedef	struct	{
	char	title[_PG_TITLELEN];	/* Title text */
	short	titlecolor;		/* Internal palette color for title text */
	short	justify;		/* _PG_LEFT, _PG_CENTER, _PG_RIGHT */
} _titletype;
#define _TITLETYPE_DEFINED
#endif

/* Typedef for chart axes */
#ifndef _AXISTYPE_DEFINED
typedef	struct	{
	short		grid;		/* TRUE=grid lines drawn; FALSE no lines */
	short		gridstyle;	/* Style number from style pool for grid lines */
	_titletype	axistitle;	/* Title definition for axis */
	short		axiscolor;	/* Color for axis */
	short		labeled;	/* TRUE=tic marks and titles drawn */
	short		rangetype;	/* _PG_LINEARAXIS, _PG_LOGAXIS */
	float		logbase;	/* Base used if log axis */
	short		autoscale;	/* TRUE=next 7 values calculated by system */
	float		scalemin;	/* Minimum value of scale */
	float		scalemax;	/* Maximum value of scale */
	float		scalefactor;	/* Scale factor for data on this axis */
	_titletype	scaletitle;	/* Title definition for scaling factor */
	float		ticinterval;	/* Distance between tic marks (world coord.) */
	short		ticformat;	/* _PG_EXPFORMAT or _PG_DECFORMAT for tic labels */
	short		ticdecimals;	/* Number of decimals for tic labels (max=9)*/
} _axistype;
#define _AXISTYPE_DEFINED
#endif

/* Typedef used for defining chart and data windows */
#ifndef _WINDOWTYPE_DEFINED
typedef	struct	{
	short		x1;		/* Left edge of window in pixels */
	short		y1;		/* Top edge of window in pixels */
	short		x2;		/* Right edge of window in pixels */
	short		y2;		/* Bottom edge of window in pixels */
	short		border;		/* TRUE for border, FALSE otherwise */
	short		background;	/* Internal palette color for window bgnd */
	short		borderstyle;	/* Style bytes for window border */
	short		bordercolor;	/* Internal palette color for window border */
} _windowtype;
#define _WINDOWTYPE_DEFINED
#endif

/* Typedef for legend definition */
#ifndef _LEGENDTYPE_DEFINED
typedef struct	{
	short		legend;		/* TRUE=draw legend; FALSE=no legend */
	short		place;		/* _PG_RIGHT, _PG_BOTTOM, _PG_OVERLAY */
	short		textcolor;	/* Internal palette color for text */
	short		autosize;	/* TRUE=system calculates size */
	_windowtype	legendwindow;	/* Window definition for legend */
} _legendtype;
#define _LEGENDTYPE_DEFINED
#endif

/* Typedef for legend definition */
#ifndef _CHARTENV_DEFINED
typedef struct	{
	short		charttype;	/* _PG_BARCHART, _PG_COLUMNCHART,
					_PG_LINECHART, _PG_SCATTERCHART,
						 _PG_PIECHART */
	short		chartstyle;	/* Style for selected chart type */
	_windowtype	chartwindow;	/* Window definition for overall chart */
	_windowtype	datawindow;	/* Window definition for data part of chart */
	_titletype	maintitle;	/* Main chart title */
	_titletype	subtitle;	/* Chart sub-title */
	_axistype	xaxis;		/* Definition for X-axis */
	_axistype	yaxis;		/* Definition for Y-axis */
	_legendtype	legend;		/* Definition for legend */
} _chartenv;
#define _CHARTENV_DEFINED
#endif

/* Typedef for character bitmap */
#ifndef _CHARMAP_DEFINED
typedef unsigned char _charmap[8];
#define _CHARMAP_DEFINED
#endif

/* Typedef for pattern bitmap */
#ifndef _FILLMAP_DEFINED
typedef unsigned char _fillmap[8];
#define _FILLMAP_DEFINED
#endif

/* Typedef for palette entry definition */
#ifndef _PALETTEENTRY_DEFINED
typedef struct {
	unsigned short	color;
	unsigned short	style;
	_fillmap	fill;
	char		plotchar;
} _paletteentry;
#define _PALETTEENTRY_DEFINED
#endif

/* Typedef for palette definition */
#ifndef _PALETTETYPE_DEFINED
typedef _paletteentry _palettetype[_PG_PALETTELEN];
#define _PALETTETYPE_DEFINED
#endif

/* Typedef for style sets */
#ifndef _STYLESET_DEFINED
typedef unsigned short _styleset[_PG_PALETTELEN];
#define _STYLESET_DEFINED
#endif

#ifndef __STDC__ 
/* Non-ANSI names for compatibility */ 
#define titletype     _titletype 
#define axistype      _axistype 
#define windowtype    _windowtype 
#define legendtype    _legendtype 
#define chartenv      _chartenv 
#define charmap       _charmap 
#define fillmap       _fillmap 
#define paletteentry  _paletteentry 
#define palettetype   _palettetype 
#define styleset      _styleset 
#endif 


/* Function prototypes for charting routines	*/

short __far __cdecl _pg_initchart(void);
short __far __cdecl _pg_defaultchart(_chartenv __far *, short, short);

short __far __cdecl _pg_chart(_chartenv __far *, const char __far * const __far *, const float __far *, short);
short __far __cdecl _pg_chartms(_chartenv __far *, const char __far * const __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_chartscatter(_chartenv __far *, const float __far *, const float __far *, short);
short __far __cdecl _pg_chartscatterms(_chartenv __far *, const float __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_chartpie(_chartenv __far *, const char __far * const __far *, const float __far *, const short __far *, short);

/* Function prototypes for support routines	*/

short __far __cdecl _pg_hlabelchart(_chartenv __far *, short, short, short, const char __far *);
short __far __cdecl _pg_vlabelchart(_chartenv __far *, short, short, short, const char __far *);

short __far __cdecl _pg_analyzechart(_chartenv __far *, const char __far * const __far *, const float __far *, short);
short __far __cdecl _pg_analyzechartms(_chartenv __far *, const char __far * const __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_analyzescatter(_chartenv __far *, const float __far *, const float __far *, short);
short __far __cdecl _pg_analyzescatterms(_chartenv __far *, const float __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_analyzepie(_chartenv __far *, const char __far * const __far *, const float __far *, const short __far *, short);

short __far __cdecl _pg_getpalette(_paletteentry __far *);
short __far __cdecl _pg_setpalette(const _paletteentry __far *);
short __far __cdecl _pg_resetpalette(void);

void  __far __cdecl _pg_getstyleset(unsigned short __far *);
void  __far __cdecl _pg_setstyleset(const unsigned short __far *);
void  __far __cdecl _pg_resetstyleset(void);

short __far __cdecl _pg_getchardef(short, unsigned char __far *);
short __far __cdecl _pg_setchardef(short, const unsigned char __far *);


/* Restore default packing */
#pragma pack()

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\ptypes16.h ===
/*****************************************************************************\
* PTYPES16.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides typedefs for portable 16/32 bit code.
*
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.
*
\*****************************************************************************/

/* TEMPORARY FIXES: */

#ifndef CCHDEVICENAME
#include <drivinit.h>
#endif

#define ERROR_GETADDR_FAILED     0x8001
#define ERROR_ALLOCATION_FAILURE 0x8002

#define INITWINDOWS()

/* TYPES: */

#ifndef WIN31

typedef  unsigned int   UINT           ;
typedef  WORD           WPARAM         ;
typedef  LONG           LPARAM         ;
typedef  int            HFILE          ;
typedef  HANDLE         HINSTANCE      ;
typedef  HANDLE         HMODULE        ;

#endif /* !WIN31 */

typedef  int            INT            ;
typedef  signed char    SCHAR          ;
typedef  WORD           WORD2DWORD     ;
typedef  char           CHAR           ;
typedef  char           CHARPARM       ;
typedef  int            SHORTPARM      ;
typedef  int            SHORT          ;
typedef  WORD           VERSION        ;
typedef  HANDLE         HMF            ;
typedef  WORD           PDLLMEM        ;
typedef  char           CHAR2ULONG     ;
typedef  unsigned short USHORT2ULONG   ;
typedef  short          SHORT2ULONG    ;
typedef  int            INT2DWORD      ;
typedef  int            INT2WORD       ;
typedef  char           BYTE2WORD      ;
typedef  POINT          MPOINT         ;

#define  WNDPROC        FARPROC
#define  PROC           FARPROC
#define  APIENTRY       FAR PASCAL
#define  HUGE_T         huge

#define HFILE2INT(h, flags)     (INT)(h)
#define INT2HFILE(i)            (HFILE)(i)
#define DUPHFILE(h)             (HFILE)dup((INT)(h))
#define MGLOBALPTR(p)           HIWORD((LONG)p)

/* PRAGMAS */

#define _LOADDS _loadds
#define _EXPORT _export
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\prsht.h ===
//----------------------------------------------------------------------------
//
// prsht.h  - PropSheet definitions
//
// Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved
//
//----------------------------------------------------------------------------

#ifndef _PRSHT_H_
#define _PRSHT_H_

#ifdef __cplusplus
extern "C" {
#endif

#define MAXPROPPAGES 24

struct _PSP;
typedef struct _PSP FAR* HPROPSHEETPAGE;

typedef struct _PROPSHEETPAGE FAR *LPPROPSHEETPAGE;     // forward declaration

//
// Property sheet page helper function
//
typedef void (CALLBACK FAR * LPFNRELEASEPROPSHEETPAGE)(LPPROPSHEETPAGE ppsp);

#define PSP_DEFAULT             0x0000
#define PSP_DLGINDIRECT         0x0001 // use pResource instead of pszTemplate
#define PSP_USEHICON            0x0002
#define PSP_USEICONID           0x0004
#define PSP_USETITLE            0x0008
#define PSP_USERELEASEFUNC      0x0020
#define PSP_USEREFPARENT        0x0040

// this structure is passed to CreatePropertySheetPage() and is in the LPARAM on
// of the WM_INITDIALOG message when a property sheet page is created
typedef struct _PROPSHEETPAGE {
        DWORD           dwSize;             // size of this structure (including extra data)
        DWORD           dwFlags;            // PSP_ bits define the use and meaning of fields
        HINSTANCE       hInstance;	    // instance to load the template from
        union {
            LPCSTR          pszTemplate;    // template to use
#ifdef WIN32
            LPCDLGTEMPLATE  pResource;      // PSP_DLGINDIRECT: pointer to resource in memory
#else
            const VOID FAR *pResource;	    // PSP_DLGINDIRECT: pointer to resource in memory
#endif
        };
        union {
            HICON       hIcon;              // PSP_USEICON: hIcon to use
            LPCSTR      pszIcon;            // PSP_USEICONID: or icon name string or icon id
        };
        LPCSTR          pszTitle;	    // name to override the template title or string id
        DLGPROC         pfnDlgProc;	    // dlg proc
        LPARAM          lParam;		    // user data
        LPFNRELEASEPROPSHEETPAGE pfnRelease;// PSP_USERELEASEFUNC: function will be called before HPROPSHEETPAGE is destroyed
        UINT FAR * pcRefParent;		    // PSP_USERREFPARENT: pointer to ref count variable
} PROPSHEETPAGE, FAR *LPPROPSHEETPAGE;
typedef const PROPSHEETPAGE FAR *LPCPROPSHEETPAGE;

#define PSH_DEFAULT             0x0000
#define PSH_PROPTITLE           0x0001 // use "Properties for <lpszCaption>" as the title
#define PSH_USEHICON            0x0002 // use specified hIcon for the caption
#define PSH_USEICONID           0x0004 // use lpszIcon to load the icon
#define PSH_PROPSHEETPAGE       0x0008 // use ppsp instead of phpage (points to array of PROPSHEETPAGE structures)
#define PSH_MULTILINETABS	0x0010 // do multiline tabs

typedef struct _PROPSHEETHEADER {
        DWORD           dwSize;         // size of this structure
        DWORD           dwFlags;        // PSH_
        HWND            hwndParent;
        HINSTANCE       hInstance;      // to load icon or caption string
        union {
            HICON       hIcon;          // PSH_USEHICON: hIcon to use
            LPCSTR      pszIcon;        // PSH_USEICONID: or icon name string or icon id
        };
        LPCSTR          pszCaption;	// PSH_PROPTITLE: dlg caption or "Properties for <lpszCaption>"
					// may be MAKEINTRESOURCE()

        UINT            nPages;	        // # of HPROPSHEETPAGE (or PROPSHEETPAGE) elements in phpage
        UINT            nStartPage;	// initial page to be shown (zero based)
        union {
            LPCPROPSHEETPAGE ppsp;
            HPROPSHEETPAGE FAR *phpage;
        };
} PROPSHEETHEADER, FAR *LPPROPSHEETHEADER;
typedef const PROPSHEETHEADER FAR *LPCPROPSHEETHEADER;


//
// property sheet APIs
//

HPROPSHEETPAGE WINAPI CreatePropertySheetPage(LPCPROPSHEETPAGE);
BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);
int            WINAPI PropertySheet(LPCPROPSHEETHEADER);
#ifdef WIN32
#endif
//
// callback for property sheet extensions to call to add pages
//
typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);

//
// generic routine for prop sheet extensions to export.  this is called
// to have the extension add pages.  specific versions of this will be
// implemented when necessary.
//

typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);





#define PSN_FIRST       (0U-200U)
#define PSN_LAST        (0U-299U)


// PropertySheet notification codes sent to the page.  NOTE: RESULTS
// MUST BE RETURNED BY USING SetWindowLong(hdlg, DWL_MSGRESULT, result)

// page is being activated. initialize the data on the page here if other pages can
// effect this page, otherwise init the page at WM_INITDIALOG time. return value is
// ignored.
#define PSN_SETACTIVE           (PSN_FIRST-0)

// indicates the current page is being switched away from.  validate input
// at this time and return TRUE to keep the page switch from happening.
// to commit changes on page switches commit data after validating on this message.
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)

// indicates that the OK or Apply Now buttons have been pressed (OK will
// destroy the dialog when done)
// return FALSE to force the page to be destroyed and recreated.
#define PSN_APPLY               (PSN_FIRST-2)

// indicates that the cancel button has been pressed, the page may want use this
// as an oportunity to confirm canceling the dialog.
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)

// sent to page to see if the help button should be enabled, the page
// should return TRUE or FALSE
#define PSN_HASHELP             (PSN_FIRST-4)

// sent to page indicating that the help button has been pressed
#define PSN_HELP                (PSN_FIRST-5)




//// MESSAGES sent to the main property sheet dialog

// used to set the current selection
// supply either the hpage or the index to the tab
#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SendMessage(hDlg, PSM_SETCURSEL, (WPARAM)index, (LPARAM)hpage)

// NOT IMPLEMENTED
// remove a page
// wParam = index of page to remove
// lParam = hwnd of page to remove
// NOT IMPLEMENTED
#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SendMessage(hDlg, PSM_REMOVEPAGE, index, (LPARAM)hpage)

// NOT IMPLEMENTED
// add a page
// lParam = hPage of page to remove
// NOT IMPLEMENTED
#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SendMessage(hDlg, PSM_ADDPAGE, 0, (LPARAM)hpage)

// tell the PS manager that that the page has changed and "Apply Now" should be enabled
// (we may mark the visually tab so the user knows that a change has been made)
#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SendMessage(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)


// tell the PS manager that we need to restart windows due to a change made so
// the restart windows dialog will be presented when dismissing the dialog
#define PSM_RESTARTWINDOWS            (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SendMessage(hDlg, PSM_RESTARTWINDOWS, 0, 0L)

// tell the PS manager that we need to reboot due to a change made so
// the reboot windows dialog will be presented when dismissing the dialog
#define PSM_REBOOTSYSTEM              (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SendMessage(hDlg, PSM_REBOOTSYSTEM, 0, 0L)

// change the OK button to Close and disable cancel.  this indicates a non cancelable
// change has been made
#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        SendMessage(hDlg, PSM_CANCELTOCLOSE, 0, 0L)

// have the PS manager forward this query to each initialized tab's hwnd
// until a non-zero value is returned.  This value is returned to the caller.
#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SendMessage(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)

// tell the PS manager the opposite of PSM_CHANGED -- that the page has reverted
// to its previously saved state.  If no pages remain changed, "Apply Now"
// will be disabled.  (we may remove the visually marked tab so that the user
// knows no change has been made)
#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SendMessage(hDlg, PSM_UNCHANGED, (WPARAM)hwnd, 0L)

// tell the PS manager to do an "Apply Now"
#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SendMessage(hDlg, PSM_APPLY, 0, 0L)

// iStyle can be PSH_PROPTITLE or PSH_DEFAULT
// lpszText can be a string or an rcid
#define PSM_SETTITLE            (WM_USER + 111)
#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SendMessage(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCSTR)lpszText)


#define ID_PSRESTARTWINDOWS 0x2
#define ID_PSREBOOTSYSTEM   (ID_PSRESTARTWINDOWS | 0x1)

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif // _PRSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\print.h ===
/*****************************************************************************\
*                                                                             *
* print.h -     Printing helper functions, types, and definitions             *
*                                                                             *
*		Copyright (c) 1985-1994. Microsoft Corp.  All rights reserved.*
*                                                                             *
*******************************************************************************
*
*  PRINTDRIVER  	 - For inclusion with a printer driver
*  NOPQ         	 - Prevent inclusion of priority queue APIs
*  NOEXTDEVMODEPROPSHEET - Prevent inclusion of shlobj.h and defs for printer
*			   property sheet pages
*
\*****************************************************************************/

#ifndef _INC_PRINT
#define _INC_PRINT

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifdef PRINTDRIVER

#define NOTEXTMETRICS
#define NOGDICAPMASKS
#define NOGDIOBJ
#define NOBITMAP
#define NOSOUND
#define NOTEXTMETRIC
#define NOCOMM
#define NOKANJI
#define NOENHMETAFILE

#include <windows.h>

#undef NOENHMETAFILE
#undef NOTEXTMETRICS
#undef NOGDICAPMASKS
#undef NOGDICAPMASKS
#undef NOGDIOBJ
#undef NOBITMAP
#undef NOSOUND
#undef NOTEXTMETRIC
#undef NOCOMM
#undef NOKANJI

#define NOPTRC  /* don't allow gdidefs.inc to redef these */
#define PTTYPE POINT

#define PQERROR (-1)

#ifndef NOPQ

DECLARE_HANDLE(HPQ);

HPQ     WINAPI CreatePQ(int);
int     WINAPI MinPQ(HPQ);
int     WINAPI ExtractPQ(HPQ);
int     WINAPI InsertPQ(HPQ, int, int);
int     WINAPI SizePQ(HPQ, int);
void    WINAPI DeletePQ(HPQ);
#endif  /* !NOPQ */

#endif /* !PRINTDRIVER */




/* Spool routines for use by printer drivers */

typedef HANDLE HPJOB;

HPJOB   WINAPI OpenJob(LPSTR, LPSTR, HPJOB);
int     WINAPI StartSpoolPage(HPJOB);
int     WINAPI EndSpoolPage(HPJOB);
int     WINAPI WriteSpool(HPJOB, LPSTR, int);
int     WINAPI CloseJob(HPJOB);
int     WINAPI DeleteJob(HPJOB, int);
int     WINAPI WriteDialog(HPJOB, LPSTR, int);
int     WINAPI DeleteSpoolPage(HPJOB);

typedef struct tagBANDINFOSTRUCT
{
    BOOL    fGraphics;
    BOOL    fText;
    RECT    rcGraphics;
} BANDINFOSTRUCT, FAR* LPBI;

#define USA_COUNTRYCODE 1

/*
 *  Printer driver initialization using ExtDeviceMode()
 *  and DeviceCapabilities().
 *  This replaces Drivinit.h
 */

/* size of a device name string */
#define CCHDEVICENAME 32
#define CCHPAPERNAME  64
#define CCHFORMNAME   32

/* current version of specification */
#define DM_SPECVERSION 0x0400

/* field selection bits */
#define DM_ORIENTATION      0x00000001L
#define DM_PAPERSIZE        0x00000002L
#define DM_PAPERLENGTH      0x00000004L
#define DM_PAPERWIDTH       0x00000008L
#define DM_SCALE            0x00000010L
#define DM_COPIES           0x00000100L
#define DM_DEFAULTSOURCE    0x00000200L
#define DM_PRINTQUALITY     0x00000400L
#define DM_COLOR            0x00000800L
#define DM_DUPLEX           0x00001000L
#define DM_YRESOLUTION      0x00002000L
#define DM_TTOPTION         0x00004000L
#define DM_COLLATE          0x00008000L
#define DM_FORMNAME         0x00010000L
#define DM_UNUSED           0x00020000L
#define DM_BITSPERPEL       0x00040000L
#define DM_PELSWIDTH        0x00080000L
#define DM_PELSHEIGHT       0x00100000L
#define DM_DISPLAYFLAGS     0x00200000L
#define DM_DISPLAYFREQUENCT 0x00400000L
#define DM_ICMMETHOD        0x00800000L
#define DM_ICMINTENT        0x01000000L
#define DM_MEDIATYPE        0x02000000L
#define DM_DITHERTYPE       0x04000000L

/* orientation selections */
#define DMORIENT_PORTRAIT   1
#define DMORIENT_LANDSCAPE  2

/* paper selections */
#define DMPAPER_FIRST        DMPAPER_LETTER
#define DMPAPER_LETTER       1          /* Letter 8 1/2 x 11 in               */
#define DMPAPER_LETTERSMALL  2          /* Letter Small 8 1/2 x 11 in         */
#define DMPAPER_TABLOID      3          /* Tabloid 11 x 17 in                 */
#define DMPAPER_LEDGER       4          /* Ledger 17 x 11 in                  */
#define DMPAPER_LEGAL        5          /* Legal 8 1/2 x 14 in                */
#define DMPAPER_STATEMENT    6          /* Statement 5 1/2 x 8 1/2 in         */
#define DMPAPER_EXECUTIVE    7          /* Executive 7 1/4 x 10 1/2 in        */
#define DMPAPER_A3           8          /* A3 297 x 420 mm                    */
#define DMPAPER_A4           9          /* A4 210 x 297 mm                    */
#define DMPAPER_A4SMALL      10         /* A4 Small 210 x 297 mm              */
#define DMPAPER_A5           11         /* A5 148 x 210 mm                    */
#define DMPAPER_B4           12         /* B4 (ISO) 250 x 353 mm                       */
#define DMPAPER_B5           13         /* B5 182 x 257 mm                    */
#define DMPAPER_FOLIO        14         /* Folio 8 1/2 x 13 in                */
#define DMPAPER_QUARTO       15         /* Quarto 215 x 275 mm                */
#define DMPAPER_10X14        16         /* 10x14 in                           */
#define DMPAPER_11X17        17         /* 11x17 in                           */
#define DMPAPER_NOTE         18         /* Note 8 1/2 x 11 in                 */
#define DMPAPER_ENV_9        19         /* Envelope #9 3 7/8 x 8 7/8          */
#define DMPAPER_ENV_10       20         /* Envelope #10 4 1/8 x 9 1/2         */
#define DMPAPER_ENV_11       21         /* Envelope #11 4 1/2 x 10 3/8        */
#define DMPAPER_ENV_12       22         /* Envelope #12 4 \276 x 11           */
#define DMPAPER_ENV_14       23         /* Envelope #14 5 x 11 1/2            */
#define DMPAPER_CSHEET       24         /* C size sheet                       */
#define DMPAPER_DSHEET       25         /* D size sheet                       */
#define DMPAPER_ESHEET       26         /* E size sheet                       */
#define DMPAPER_ENV_DL       27         /* Envelope DL 110 x 220mm            */
#define DMPAPER_ENV_C5       28         /* Envelope C5 162 x 229 mm           */
#define DMPAPER_ENV_C3       29         /* Envelope C3  324 x 458 mm          */
#define DMPAPER_ENV_C4       30         /* Envelope C4  229 x 324 mm          */
#define DMPAPER_ENV_C6       31         /* Envelope C6  114 x 162 mm          */
#define DMPAPER_ENV_C65      32         /* Envelope C65 114 x 229 mm          */
#define DMPAPER_ENV_B4       33         /* Envelope B4  250 x 353 mm          */
#define DMPAPER_ENV_B5       34         /* Envelope B5  176 x 250 mm          */
#define DMPAPER_ENV_B6       35         /* Envelope B6  176 x 125 mm          */
#define DMPAPER_ENV_ITALY    36         /* Envelope 110 x 230 mm              */
#define DMPAPER_ENV_MONARCH  37         /* Envelope Monarch 3.875 x 7.5 in    */
#define DMPAPER_ENV_PERSONAL 38         /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
#define DMPAPER_FANFOLD_US   39         /* US Std Fanfold 14 7/8 x 11 in      */
#define DMPAPER_FANFOLD_STD_GERMAN  40  /* German Std Fanfold 8 1/2 x 12 in   */
#define DMPAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */
/*
** the following 5 sizes were added in Chicago per FE group's request.
*/
#define DMPAPER_JIS_B4              42  /* B4 257 x 364 mm                    */
#define DMPAPER_JAPANESE_POSTCARD   43  /* Japanese Postcard 100 x 148 mm     */
#define DMPAPER_9X11                44  /* 9 x 11 in                          */
#define DMPAPER_10X11               45  /* 10 x 11 in                         */
#define DMPAPER_15X11               46  /* 15 x 11 in                         */
/*
** the following 7 sizes were used in PostScript driver during Win3.1 WDL.
** Unfortunately, we cannot redefine those id's even though there is gap with
** the rest of standard id's.
*/
#define DMPAPER_LETTER_EXTRA	     50    /* Letter Extra 9 \275 x 12 in       */
#define DMPAPER_LEGAL_EXTRA 	     51    /* Legal Extra 9 \275 x 15 in        */
#define DMPAPER_TABLOID_EXTRA	     52    /* Tabloid Extra 11.69 x 18 in       */
#define DMPAPER_A4_EXTRA     	     53    /* A4 Extra 9.27 x 12.69 in          */
#define DMPAPER_LETTER_TRANSVERSE	 54    /* Letter Transverse 8 \275 x 11 in  */
#define DMPAPER_A4_TRANSVERSE		 55    /* Transverse 210 x 297 mm           */
#define DMPAPER_LETTER_EXTRA_TRANSVERSE  56  /* Letter Extra Transverse 9\275 x 12 in  */

#define DMPAPER_LAST        DMPAPER_LETTER_EXTRA_TRANSVERSE

#define DMPAPER_USER        256

/* bin selections */
#define DMBIN_FIRST         DMBIN_UPPER
#define DMBIN_UPPER         1
#define DMBIN_ONLYONE       1
#define DMBIN_LOWER         2
#define DMBIN_MIDDLE        3
#define DMBIN_MANUAL        4
#define DMBIN_ENVELOPE      5
#define DMBIN_ENVMANUAL     6
#define DMBIN_AUTO          7
#define DMBIN_TRACTOR       8
#define DMBIN_SMALLFMT      9
#define DMBIN_LARGEFMT      10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE      14
#define DMBIN_ROLL          15
#define DMBIN_LAST          DMBIN_ROLL

#define DMBIN_USER          256     /* device specific bins start here */

/* print qualities */
#define DMRES_DRAFT         (-1)
#define DMRES_LOW           (-2)
#define DMRES_MEDIUM        (-3)
#define DMRES_HIGH          (-4)

/* color enable/disable for color printers */
#define DMCOLOR_MONOCHROME  1
#define DMCOLOR_COLOR       2

/* duplex enable */
#define DMDUP_SIMPLEX    1
#define DMDUP_VERTICAL   2
#define DMDUP_HORIZONTAL 3
#define DMDUP_LAST       DMDUP_HORIZONTAL

/* TrueType options */
#define DMTT_BITMAP           1   /* print TT fonts as graphics */
#define DMTT_DOWNLOAD         2   /* download TT fonts as soft fonts */
#define DMTT_SUBDEV           3   /* substitute device fonts for TT fonts */
#define DMTT_DOWNLOAD_OUTLINE 4   /* download TT fonts as outline soft fonts */
#define DMTT_LAST             DMTT_DOWNLOAD_OUTLINE

/* Collation selections */
#define DMCOLLATE_TRUE      1   /* Collate multiple output pages */
#define DMCOLLATE_FALSE     0   /* Do not collate multiple output pages  */

/* DEVMODE dmDisplayFlags flags */

#define DM_GRAYSCALE        0x00000001L  /* Device is non-color */
#define DM_INTERLACED       0x00000002L  /* device is interlaced */

/* ICM methods */
#define DMICMMETHOD_SYSTEM  1   /* ICM handled by system */
#define DMICMMETHOD_NONE    2   /* ICM disabled */
#define DMICMMETHOD_DRIVER  3   /* ICM handled by driver */
#define DMICMMETHOD_DEVICE  4   /* ICM handled by device */
#define DMICMMETHOD_LAST    DMICMMETHOD_DEVICE

#define DMICMMETHOD_USER  256   /* Device-specific methods start here */

/* ICM Intents */
#define DMICM_SATURATE      1   /* Maximize color saturation */
#define DMICM_CONTRAST      2   /* Maximize color contrast */
#define DMICM_COLORMETRIC   3   /* Use specific color metric */
#define DMICM_LAST          DMICM_COLORMETRIC

#define DMICM_USER        256   /* Device-specific intents start here */

/* Media types */
#define DMMEDIA_STANDARD      1   /* Standard paper */
#define DMMEDIA_GLOSSY        2   /* Glossy paper */
#define DMMEDIA_TRANSPARENCY  3   /* Transparency */
#define DMMEDIA_LAST          DMMEDIA_TRANSPARENCY

#define DMMEDIA_USER        256   /* Device-specific media start here */

/* Dither types */
#define DMDITHER_NONE       1   /* No dithering */
#define DMDITHER_COARSE     2   /* Dither with a coarse brush */
#define DMDITHER_FINE       3   /* Dither with a fine brush */
#define DMDITHER_LINEART    4   /* LineArt dithering */
#define DMDITHER_GRAYSCALE  5   /* Device does grayscaling */
#define DMDITHER_LAST       DMDITHER_GRAYSCALE

#define DMDITHER_USER     256   /* Device-specific dithers start here */

typedef struct tagDEVMODE
{
    char  dmDeviceName[CCHDEVICENAME];
    UINT  dmSpecVersion;
    UINT  dmDriverVersion;
    UINT  dmSize;
    UINT  dmDriverExtra;
    DWORD dmFields;
    int   dmOrientation;
    int   dmPaperSize;
    int   dmPaperLength;
    int   dmPaperWidth;
    int   dmScale;
    int   dmCopies;
    int   dmDefaultSource;
    int   dmPrintQuality;
    int   dmColor;
    int   dmDuplex;
    int   dmYResolution;
    int   dmTTOption;
    int   dmCollate;
    char  dmFormName[CCHFORMNAME];
    WORD  dmUnusedPadding;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    DWORD dmDisplayFlags;
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;
} DEVMODE;

typedef DEVMODE* PDEVMODE, NEAR* NPDEVMODE, FAR* LPDEVMODE;

/* mode selections for the device mode function */
#define DM_UPDATE           1
#define DM_COPY             2
#define DM_PROMPT           4
#define DM_MODIFY           8

#define DM_IN_BUFFER        DM_MODIFY
#define DM_IN_PROMPT        DM_PROMPT
#define DM_OUT_BUFFER       DM_COPY
#define DM_OUT_DEFAULT      DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS           1
#define DC_PAPERS           2
#define DC_PAPERSIZE        3
#define DC_MINEXTENT        4
#define DC_MAXEXTENT        5
#define DC_BINS             6
#define DC_DUPLEX           7
#define DC_SIZE             8
#define DC_EXTRA            9
#define DC_VERSION          10
#define DC_DRIVER           11
#define DC_BINNAMES         12
#define DC_ENUMRESOLUTIONS  13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE         15
#define DC_PAPERNAMES       16
#define DC_ORIENTATION      17
#define DC_COPIES           18
#define DC_BINADJUST  19

/* bit fields of the return value (DWORD) for DC_TRUETYPE */
#define DCTT_BITMAP             0x0000001L
#define DCTT_DOWNLOAD           0x0000002L
#define DCTT_SUBDEV             0x0000004L
#define DCTT_DOWNLOAD_OUTLINE   0x0000008L

/* return values for DC_BINADJUST */
#define DCBA_FACEUPNONE       0x0000
#define DCBA_FACEUPCENTER     0x0001
#define DCBA_FACEUPLEFT       0x0002
#define DCBA_FACEUPRIGHT      0x0003
#define DCBA_FACEDOWNNONE     0x0100
#define DCBA_FACEDOWNCENTER   0x0101
#define DCBA_FACEDOWNLEFT     0x0102
#define DCBA_FACEDOWNRIGHT    0x0103

/* export ordinal definitions */
#define PROC_EXTDEVICEMODE      MAKEINTRESOURCE(90)
#define PROC_DEVICECAPABILITIES MAKEINTRESOURCE(91)
#define PROC_OLDDEVICEMODE      MAKEINTRESOURCE(13)

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions
 */


/* BUGBUG, many of these params are const  */

typedef UINT   (CALLBACK* LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE,
                          LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);

typedef DWORD  (CALLBACK* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);

#ifndef NOEXTDEVMODEPROPSHEET
#include <prsht.h>      /* for EXTDEVMODEPROPSHEET  */

/* these are the names of the exports from the printer drivers   */

#define PROCNAME_EXTDEVICEMODE		"EXTDEVICEMODE"
#define PROCNAME_EXTDEVMODEPROPSHEET	"EXTDEVICEMODEPROPSHEET"

/* this function is similar to ExtDeviceMode(), with the following
** changes:
**
** 1) No lpdmIn or lpdmOut. Changes are global
** 2) UI always displays, changes always saved (wMode is always
**    DM_PROMPT | DM_UPDATE)
** 3) Driver enumerates property pages back to the caller via
**    lpfnAddPage and lParam.
**    lpfnAddPage is called by the driver to enumerate each HPROPSHEETPAGE
**    lParam is passed back to lpfnAddPage.
*/

typedef int (WINAPI *LPFNEXTDEVICEMODEPROPSHEET)(
  HWND      hWnd,
	HINSTANCE hinstDriver,
	LPCSTR    lpszDevice, 
	LPCSTR    lpszPort,
  DWORD     dwReserved,
 LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

/* Ordinal for new entry point */
#define PROC_EXTDEVICEMODEPROPSHEET  MAKEINTRESOURCE(95)

#endif  /* NOEXTDEVMODEPROPSHEET  */



HDC     WINAPI ResetDC(HDC, const DEVMODE FAR*);

/* this structure is used by the GETSETSCREENPARAMS escape */
typedef struct tagSCREENPARAMS
{
   int angle;
   int frequency;
} SCREENPARAMS;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_PRINT */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\pwin16.h ===
/*****************************************************************************\
* PWIN16.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable windows code to its 16 bit form.
*
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.
*
\*****************************************************************************/

/*-----------------------------------USER------------------------------------*/
 
DWORD FAR PASCAL     MGetLastError(VOID);
DWORD FAR PASCAL     MSendMsgEM_GETSEL(HWND hDlg, INT FAR *piStart, INT FAR *piEnd);

/* HELPER MACROS */

#define MAPVALUE(v16, v32)              (v16)
#define MAPTYPE(v16, v32)               v16
#define MAKEMPOINT(l)                   (*((MPOINT FAR *)&(l)))
#define MPOINT2POINT(mpt, pt)           (pt = *(POINT FAR *)&(mpt))
#define POINT2MPOINT(pt, mpt)           (mpt = *(MPOINT FAR *)&(pt))
#define LONG2POINT(l, pt)               ((pt).x = (INT)LOWORD(l), (pt).y = (INT)HIWORD(l))

#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowWord(hwnd, index)
#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowWord(hwnd, index, (WORD)(ui))
#define SETCLASSUINT(hwnd, index, ui)   (UINT)SetClassWord(hwnd, index, (WORD)(ui))
#define GETCLASSUINT(hwnd, index)       (UINT)GetClassWord(hwnd, index)

#define GETCBCLSEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBCLSEXTRA)
#define SETCBCLSEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBCLSEXTRA, cb)
#define GETCBWNDEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBWNDEXTRA)     
#define SETCBWNDEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBWNDEXTRA, cb) 
#define GETCLASSBRBACKGROUND(hwnd)      (HBRUSH)GETCLASSUINT(hwnd, GCW_HBRBACKGROUND)
#define SETCLASSBRBACKGROUND(hwnd, h)   (HBRUSH)SETCLASSUINT(hwnd, GCW_HBRBACKGROUND, h)
#define GETCLASSCURSOR(hwnd)            (HCURSOR)GETCLASSUINT(hwnd, GCW_HCURSOR)
#define SETCLASSCURSOR(hwnd, h)         (HCURSOR)SETCLASSUINT(hwnd, GCW_HCURSOR, h)
#define GETCLASSHMODULE(hwnd)           (HMODULE)GETCLASSUINT(hwnd, GCW_HMODULE)            
#define SETCLASSHMODULE(hwnd, h)        (HMODULE)SETCLASSUINT(hwnd, GCW_HMODULE, h) 
#define GETCLASSICON(hwnd)              (HICON)GETCLASSUINT((hwnd), GCW_HICON)
#define SETCLASSICON(hwnd, h)           (HICON)SETCLASSUINT((hwnd), GCW_HICON, h)
#define GETCLASSSTYLE(hwnd)             GETCLASSUINT((hwnd), GCW_STYLE)            
#define SETCLASSSTYLE(hwnd, style)      SETCLASSUINT((hwnd), GCW_STYLE, style) 
#define GETHWNDINSTANCE(hwnd)           (HMODULE)GETWINDOWUINT((hwnd), GWW_HINSTANCE)
#define SETHWNDINSTANCE(hwnd, h)        (HMODULE)SETWINDOWUINT((hwnd), GWW_HINSTANCE, h)
#define GETHWNDPARENT(hwnd)             (HWND)GETWINDOWUINT((hwnd), GWW_HWNDPARENT)
#define SETHWNDPARENT(hwnd, h)          (HWND)SETWINDOWUINT((hwnd), GWW_HWNDPARENT, h)
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWW_ID)            
#define SETWINDOWID(hwnd, id)           SETWINDOWUINT((hwnd), GWW_ID, id) 

/* USER API */

#define MDlgDirSelect(hDlg, lpstr, nLength, nIDListBox) \
            DlgDirSelect(hDlg, lpstr, nIDListBox)
            
#define MDlgDirSelectCOMBOBOX(hDlg, lpstr, nLength, nIDComboBox) \
            DlgDirSelectComboBox(hDlg, lpstr, nIDComboBox)

#define MMain(hInst, hPrevInst, lpCmdLine, nCmdShow) \
   INT PASCAL WinMain(HANDLE hInst, HANDLE hPrevInst, LPSTR lpCmdLine, \
   INT nCmdShow) {  \
   INT _argc;       \
   CHAR **_argv;    

/* USER MESSAGES: */

#define GET_WPARAM(wp, lp)                      (wp)
#define GET_LPARAM(wp, lp)                      (lp)

#define WM_CTLCOLORMSGBOX       0x0132
#define WM_CTLCOLOREDIT         0x0133
#define WM_CTLCOLORLISTBOX      0x0134
#define WM_CTLCOLORBTN          0x0135
#define WM_CTLCOLORDLG          0x0136
#define WM_CTLCOLORSCROLLBAR    0x0137
#define WM_CTLCOLORSTATIC       0x0138

#define GET_WM_ACTIVATE_STATE(wp, lp)               (wp)
#define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)          (BOOL)HIWORD(lp)
#define GET_WM_ACTIVATE_HWND(wp, lp)                (HWND)LOWORD(lp)
#define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)   \
        (WPARAM)(s), MAKELONG(hwnd, fmin)
    
#define GET_WM_CHARTOITEM_CHAR(wp, lp)              (CHAR)(wp)
#define GET_WM_CHARTOITEM_POS(wp, lp)               HIWORD(lp)
#define GET_WM_CHARTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
#define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd) \
        (WPARAM)(ch), MAKELONG(hwnd, pos)
  
#define GET_WM_COMMAND_ID(wp, lp)                   (wp)
#define GET_WM_COMMAND_HWND(wp, lp)                 (HWND)LOWORD(lp)
#define GET_WM_COMMAND_CMD(wp, lp)                  HIWORD(lp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)(id), MAKELONG(hwnd, cmd)
     
#define GET_WM_CTLCOLOR_HDC(wp, lp, msg)            (HDC)(wp)
#define GET_WM_CTLCOLOR_HWND(wp, lp, msg)           (HWND)LOWORD(lp)
#define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)           HIWORD(lp)
#define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
        (WPARAM)(hdc), MAKELONG(hwnd, type)
     
#define GET_WM_MENUSELECT_CMD(wp, lp)               (wp)            
#define GET_WM_MENUSELECT_FLAGS(wp, lp)             LOWORD(lp)
#define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)HIWORD(lp)
#define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
        (WPARAM)(cmd), MAKELONG(f, hmenu)
  
// Note: the following are for interpreting MDIclient to MDI child messages.
#define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)         
#define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
#define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)
// Note: the following is for sending to the MDI client window.
#define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
        (WPARAM)(hwndA), 0
 
#define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW) 0, MAKELONG(hmenuF, hmenuW)
  
#define GET_WM_MENUCHAR_CHAR(wp, lp)                (CHAR)(wp)
#define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)LOWORD(lp)
#define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)HIWORD(lp)
#define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
        (WPARAM)(ch), MAKELONG(hmenu, f)
    
#define GET_WM_PARENTNOTIFY_MSG(wp, lp)             (wp)
#define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(lp)
#define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_X(wp, lp)               (INT)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_Y(wp, lp)               (INT)HIWORD(lp)
#define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
        (WPARAM)(msg), MAKELONG(hwnd, id)
#define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
        (WPARAM)(msg), MAKELONG(x, y)

#define GET_WM_VKEYTOITEM_CODE(wp, lp)              (wp)
#define GET_WM_VKEYTOITEM_ITEM(wp, lp)              (INT)HIWORD(lp)
#define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
#define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
        (WPARAM)(code), MAKELONG(hwnd, item)

#define GET_EM_SETSEL_START(wp, lp)                 LOWORD(lp)
#define GET_EM_SETSEL_END(wp, lp)                   HIWORD(lp)
#define GET_EM_SETSEL_MPS(iStart, iEnd) \
        0, MAKELONG(iStart, iEnd)
      
#define GET_EM_LINESCROLL_MPS(vert, horz)     \
        0, MAKELONG(vert, horz)
  
#define GET_WM_HSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_HSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)(code), MAKELONG(pos, hwnd)
     
#define GET_WM_VSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)(code), MAKELONG(pos, hwnd)
                                      
#define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)LOWORD(lp)
     
#define DDEFREE(msg, lp)

#define GET_WM_DDE_ACK_STATUS(wp, lp)               LOWORD(lp)
#define GET_WM_DDE_ACK_ITEM(wp, lp)                 (ATOM)HIWORD(lp)
#define MPostWM_DDE_ACK(hTo, hFrom, wStatus, aItem) \
        PostMessage(hTo, WM_DDE_ACK, (WPARAM)hFrom, MAKELONG(wStatus, aItem))

#define GET_WM_DDE_ADVISE_HOPTIONS(wp, lp)          (HANDLE)LOWORD(lp)
#define GET_WM_DDE_ADVISE_ITEM(wp, lp)              (ATOM)HIWORD(lp)
#define MPostWM_DDE_ADVISE(hTo, hFrom, hOptions, aItem) \
        PostMessage(hTo, WM_DDE_ADVISE, (WPARAM)hFrom, MAKELONG(hOptions, aItem))
  
#define GET_WM_DDE_DATA_HDATA(wp, lp)               (HANDLE)LOWORD(lp)
#define GET_WM_DDE_DATA_ITEM(wp, lp)                (ATOM)HIWORD(lp)
#define MPostWM_DDE_DATA(hTo, hFrom, hData, aItem) \
        PostMessage(hTo, WM_DDE_DATA, (WPARAM)hFrom, MAKELONG(hData, aItem))
  
#define GET_WM_DDE_EXECUTE_HDATA(wp, lp)            (HANDLE)HIWORD(lp)
#define MPostWM_DDE_EXECUTE(hTo, hFrom, hDataExec) \
        PostMessage(hTo, WM_DDE_EXECUTE, (WPARAM)hFrom, MAKELONG(0, hDataExec))
  
#define GET_WM_DDE_POKE_HDATA(wp, lp)               (HANDLE)LOWORD(lp)
#define GET_WM_DDE_POKE_ITEM(wp, lp)                (ATOM)HIWORD(lp)
#define MPostWM_DDE_POKE(hTo, hFrom, hData, aItem) \
        PostMessage(hTo, WM_DDE_POKE, (WPARAM)hFrom, MAKELONG(hData, aItem))
    
#define GET_WM_DDE_EXECACK_STATUS(wp, lp)           (WORD)LOWORD(lp)
#define GET_WM_DDE_EXECACK_HDATA(wp, lp)            (HANDLE)HIWORD(lp)
#define MPostWM_DDE_EXECACK(hTo, hFrom, hCommands, wStatus) \
        PostMessage(hTo, WM_DDE_ACK, (WPARAM)hFrom, MAKELONG(wStatus, hCommands))
    
#define GET_WM_DDE_REQUEST_FORMAT(wp, lp)           (ATOM)LOWORD(lp)
#define GET_WM_DDE_REQUEST_ITEM(wp, lp)             (ATOM)HIWORD(lp)
#define MPostWM_DDE_REQUEST(hTo, hFrom, fmt, aItem) \
        PostMessage(hTo, WM_DDE_REQUEST, (WPARAM)hFrom, MAKELONG(fmt, aItem))

#define GET_WM_DDE_UNADVISE_FORMAT(wp, lp)          (ATOM)LOWORD(lp)
#define GET_WM_DDE_UNADVISE_ITEM(wp, lp)            (ATOM)HIWORD(lp)
#define MPostWM_DDE_UNADVISE(hTo, hFrom, fmt, aItem) \
        PostMessage(hTo, WM_DDE_UNADVISE, (WPARAM)hFrom, MAKELONG(fmt, aItem))
        
#define MPostWM_DDE_TERMINATE(hTo, hFrom) \
        PostMessage(hTo, WM_DDE_TERMINATE, (WPARAM)hFrom, 0)

/*-----------------------------------GDI-------------------------------------*/

BOOL  FAR PASCAL     MGetAspectRatioFilter(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetBitmapDimension(HANDLE hBitmap, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetBrushOrg(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetCurrentPosition(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetTextExtent(HDC hdc, LPSTR lpstr, INT cnt, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetViewportExt(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetViewportOrg(HDC hdc, INT FAR * px, INT FAR * py);
BOOL  FAR PASCAL     MGetWindowExt(HDC hdc, INT FAR * pcx, INT FAR * pcy);
BOOL  FAR PASCAL     MGetWindowOrg(HDC hdc, INT FAR * px, INT FAR * py);

#define MCreateDiscardableBitmap CreateDiscardableBitmap
#define MMoveTo                  (VOID)MoveTo
#define MOffsetViewportOrg       (VOID)OffsetViewportOrg
#define MOffsetWindowOrg         (VOID)OffsetWindowOrg
#define MScaleViewportExt        (VOID)ScaleViewportExt
#define MScaleWindowExt          (VOID)ScaleWindowExt
#define MSetBitmapDimension      (VOID)SetBitmapDimension
#define MSetBrushOrg             (VOID)SetBrushOrg
#define MSetViewportExt          (VOID)SetViewportExt
#define MSetViewportOrg          (VOID)SetViewportOrg
#define MSetWindowExt            (VOID)SetWindowExt        
#define MSetWindowOrg            (VOID)SetWindowOrg
#define MUnrealizeObject         UnrealizeObject


/*-------------------------------------DEV-----------------------------------*/

DWORD FAR PASCAL     MDeviceCapabilities(LPSTR lpDriverName,
    LPSTR lpDeviceName, LPSTR lpPort, WORD2DWORD nIndex, LPSTR lpOutput,
    LPDEVMODE lpDevMode);
BOOL  FAR PASCAL     MDeviceMode(HWND hWnd, LPSTR lpDriverName,
    LPSTR lpDeviceName, LPSTR lpOutput);
WORD2DWORD FAR PASCAL    MExtDeviceMode(HWND hWnd,LPSTR lpDriverName,
    LPDEVMODE lpDevModeOutput, LPSTR lpDeviceName, LPSTR lpPort,
    LPDEVMODE lpDevModeInput, LPSTR lpProfile, WORD2DWORD flMode);
    
/*-----------------------------------KERNEL----------------------------------*/

HANDLE FAR PASCAL   MLoadLibrary(LPSTR lpszFilename);
BOOL FAR PASCAL MDeleteFile(LPSTR lpPathName);

#define DLLMEM_MOVEABLE         LMEM_MOVEABLE
#define DLLMEM_ZEROINIT         LMEM_ZEROINIT 
#define GETMAJORVERSION(x)      LOBYTE(x)
#define GETMINORVERSION(x)      HIBYTE(x)

#define MCATCHBUF               CATCHBUF
#define LPMCATCHBUF             LPCATCHBUF

/* FUNCTION MAPPINGS */

#define MLocalInit               LocalInit
#define MLockData(dummy)         LockData(dummy)
#define MUnlockData(dummy)       UnlockData(dummy)
#define MDllSharedAlloc          LocalAlloc
#define MDllSharedFlags          LocalFlags
#define MDllSharedFree           LocalFree
#define MDllSharedHandle         LocalHandle
#define MDllSharedLock           LocalLock 
#define MDllSharedRealloc        LocalReAlloc
#define MDllSharedSize           LocalSize
#define MDllSharedUnlock         LocalUnlock
#define MFreeDOSEnvironment(p)   TRUE
#define MGetCurrentTask          GetCurrentTask
#define MGetDOSEnvironment       GetDOSEnvironment
#define MGetDriveType            GetDriveType
#define MGetModuleUsage          GetModuleUsage
#define MGetTempDrive            GetTempDrive
#define MGetTempFileName         GetTempFileName
#define MGetWinFlags             GetWinFlags
#define MOpenComm                (HFILE)OpenComm
#define MSetCommState(fh, lpDCB) SetCommState(lpDCB)
#define MReadComm                ReadComm
#define MWriteComm               WriteComm
#define MCloseComm               CloseComm
#define MOpenFile                (HFILE)OpenFile
#define MThrow                   Throw
#define MCatch                   Catch
#define M_lclose                 _lclose
#define M_lcreat                 (HFILE)_lcreat
#define M_llseek                 _llseek
#define M_lopen                  (HFILE)_lopen
#define M_lread                  _lread
#define M_lwrite                 _lwrite
#define MGetMetaFileBits         GetMetaFileBits
#define MSetMetaFileBits         SetMetaFileBits
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\regapi.h ===
/* *********************************************************************
 * RegAPI.h Header file for registry base api function prototypes 
 *      for those who link to Real mode registry Library
 * Microsoft Corporation 
 * Copyright 1993
 * 
 * Author:  Nagarajan Subramaniyan 
 * Created: 11/5/92
 *  
 * Modification history:
 *      1/20/94     DONALDM     Wrapped LPSTR and others with ifndef
 *                              _INC_WINDOWS, since windows.h typedefs
 *                              these things.  WARNING YOU MUST INCLUDE
 *                              WINDOWS.H before REGAPI.H.
 *      1/25/94     DONALDM     Removed WINDOWS specific stuff since this
 *                              file should ONLY BE USED BY DOS APPS!!!
 * **********************************************************************
*/

//---------------------------------------------------------------------
#ifdef _INC_WINDOWS
    #pragma message( "WARNING RegAPI.H is a DOS ONLY header file" )

#else	//ifndef INC_WINDOWS

#ifndef HKEY
    #define HKEY        DWORD
    #define LPHKEY	HKEY FAR *
#endif

#ifndef FAR
    #define FAR         _far
#endif

#ifndef NEAR
    #define NEAR        _near
#endif

#ifndef PASCAL
    #define PASCAL      _pascal
#endif

#ifndef CDECL
    #define CDECL       _cdecl
#endif

#ifndef CONST
    #define CONST       const
#endif

typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;

typedef BYTE FAR*       LPBYTE;
typedef const BYTE FAR* LPCBYTE;

typedef void FAR*       LPVOID;

#ifdef STRICT
typedef signed long     LONG;
#else
#define LONG            long
#endif

#ifndef WINAPI
#define WINAPI      _far _pascal
#endif


#endif		// ifndef INC_WINDOWS

//--------------------------------------------------------------------------

		
/* allowed data types */
#ifndef REG_SZ
#define REG_SZ      0x0001
#endif

#ifndef REG_BINARY
#define REG_BINARY  0x0003
#endif	//ifndef REG_SZ

/* Pre-defined KEYS */

#ifndef HKEY_LOCAL_MACHINE

#define HKEY_CLASSES_ROOT       ((HKEY)  0x80000000)
#define HKEY_CURRENT_USER       ((HKEY)  0x80000001)
#define HKEY_LOCAL_MACHINE      ((HKEY)  0x80000002)
#define HKEY_USERS              ((HKEY)	 0x80000003)
#define HKEY_PERFORMANCE_DATA   ((HKEY)  0x80000004)
#define HKEY_CURRENT_CONFIG     ((HKEY)  0x80000005)
#define HKEY_DYN_DATA           ((HKEY)  0x80000006)

#endif	// ifndef HKEY_LOCAL_MACHINE

#ifndef REG_NONE
#define REG_NONE    0       // unknown data type 
#endif

/* note that these values are different from win 3.1; these are the same as
    the one used by Win 32 
*/

/* XLATOFF */

/* real mode Registry API entry points, if using direct entry points */ 

/* MODULE: RBAPI.c      */
/* Win 3.1 Compatible APIs */

LONG FAR _cdecl KRegOpenKey(HKEY, LPCSTR, LPHKEY);
LONG FAR _cdecl KRegCreateKey(HKEY, LPCSTR, LPHKEY);
LONG FAR _cdecl KRegCloseKey(HKEY);
LONG FAR _cdecl KRegDeleteKey(HKEY, LPCSTR);
 LONG FAR _cdecl KRegSetValue16(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
 LONG FAR _cdecl KRegQueryValue16(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG FAR _cdecl KRegEnumKey(HKEY, DWORD, LPSTR, DWORD);

/* New APIs from win 32 */
LONG FAR _cdecl KRegDeleteValue(HKEY, LPCSTR);
LONG FAR _cdecl KRegEnumValue(HKEY, DWORD, LPCSTR,
                      LONG FAR *, DWORD, LONG FAR *, LPBYTE,
                      LONG FAR *);
LONG FAR _cdecl KRegQueryValueEx(HKEY, LPCSTR, LONG FAR *, LONG FAR *,
 		    LPBYTE, LONG FAR *);
LONG FAR _cdecl KRegSetValueEx(HKEY, LPCSTR, DWORD, DWORD, LPBYTE, DWORD);
LONG FAR _cdecl KRegFlushKey(HKEY);
LONG FAR _cdecl KRegSaveKey(HKEY, LPCSTR,LPVOID);
LONG FAR _cdecl KRegLoadKey(HKEY, LPCSTR,LPCSTR);
LONG FAR _cdecl KRegUnLoadKey(HKEY, LPCSTR);


/* other APIs */
DWORD FAR _cdecl KRegInit(LPSTR lpszSystemFile,LPSTR lpszUserFile,DWORD dwFlags);
        // should be called before any other Reg APIs 
// If one of the file name ptrs is a NULL ptr, RegInit will ignore init
// for that file and all Predefined keys for that file.
//
// FLAG BITS for dwFlags:


#define REGINIT_CREATENEW   1   
        /* create new file if give file not found/cannot be opened */

#define REGINIT_RECOVER     2
        /* do init and if file is corrupt try to recover before 
            giving up 
        */

#define REGINIT_REPLACE_IFBAD   4       
        /* do init, recover if file is corrupt and if recover is
            is impossible, replace with an empty file
        */

VOID    FAR _cdecl CleanupRegistry();
        /* This procedure frees all memory allocated by Registry */
        /* if you call this, to use the registry again, you need */
        /* to call RegInit again */

DWORD FAR _cdecl KRegFlush(VOID);
        // flushes the registry files to disk
        // should be done before termination. No harm in calling
        // if registry is not dirty.

WORD FAR _cdecl KRegSetErrorCheckingLevel(WORD wErrLevel);
	// Set to 0 to disable checksum, 255 to enable checksum

#if 0
DWORD FAR _cdecl KRegFlushKey(HKEY);
#endif


/* Internal  APIs - do not use */
/* Modified from Win 3.1 */
DWORD FAR _cdecl KRegQueryValue (HKEY hKey,LPSTR lpszSubKey, LPSTR lpszValueName,DWORD FAR *lpdwType,LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD FAR _cdecl KRegSetValue(HKEY hKey,LPSTR lpszSubKey,LPSTR lpszValueName,DWORD dwType,LPBYTE lpszValue,DWORD dwValSize);


/* XLATON */
#ifndef SETUPX_INC
/* defines for changing registry API names for direct callers */
#define RegInit         KRegInit
#define RegFlush        KRegFlush
#define RegOpenKey      KRegOpenKey
#define RegCreateKey    KRegCreateKey
#define RegCloseKey     KRegCloseKey
#define RegDeleteKey    KRegDeleteKey
#define RegDeleteValue  KRegDeleteValue
#define RegEnumKey      KRegEnumKey
#define RegEnumValue    KRegEnumValue
#define RegQueryValue   KRegQueryValue16
#define RegQueryValueEx KRegQueryValueEx
#define RegSetValue     KRegSetValue16
#define RegSetValueEx   KRegSetValueEx
#define RegFlushKey     KRegFlushKey
#endif          /* #ifndef IS_SETUP */

// Equates for registry function for calling the single entry point
// Registry

#define OpenKey     0L
#define CreateKey   1L
#define CloseKey    2L
#define DeleteKey   3L
#define SetValue    4L
#define QueryValue  5L
#define EnumKey     6L
#define DeleteValue 7L
#define EnumValue   8L
#define QueryValueEx    9L
#define SetValueEx  10L
#define FlushKey    11L
#define Init        12L
#define Flush       13L

/* return codes from Chicago Registration functions */
#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L    
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY             1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY          14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER        87L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS       259L
#endif  


#ifndef  ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

#ifndef  ERROR_ACCESS_DENIED     
#define ERROR_ACCESS_DENIED     8L
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\scode.h ===
//+---------------------------------------------------------------------------
//
// File:        SCode.h
//
// Contents:    Defines standard status code services.
//
//
//----------------------------------------------------------------------------

#ifndef __SCODE_H__
#define __SCODE_H__

//
// SCODE
//

typedef long SCODE;
typedef SCODE *PSCODE;
typedef void FAR * HRESULT;
#define NOERROR 0

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+---------------------+-------+-------------------------------+
//  |S|       Context       | Facil |               Code            |
//  +-+---------------------+-------+-------------------------------+
//
//  where
//
//      S - is the severity code
//
//          0 - Success
//          1 - Error
//
//      Context - context info
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//

#define SEVERITY_SUCCESS    0
#define SEVERITY_ERROR      1



#define SUCCEEDED(Status) ((SCODE)(Status) >= 0)

#define FAILED(Status) ((SCODE)(Status)<0)


//
// Return the code
//

#define SCODE_CODE(sc)      ((sc) & 0xFFFF)

//
//  Return the facility
//

#define SCODE_FACILITY(sc)  (((sc) >> 16) & 0x1fff)

//
//  Return the severity
//

#define SCODE_SEVERITY(sc)  (((sc) >> 31) & 0x1)

//
// Create an SCODE value from component pieces
//

#define MAKE_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )



// --------------------- Functions ---------------------------------------

#define GetScode(hr)        ((SCODE)(hr) & 0x800FFFFF)
#define ResultFromScode(sc) ((HRESULT)((SCODE)(sc) & 0x800FFFFF))

STDAPI PropagateResult(HRESULT hrPrev, SCODE scNew);


// -------------------------- Facility definitions -------------------------

#define FACILITY_NULL       0x0000 // generally useful errors ([SE]_*)
#define FACILITY_RPC            0x0001 // remote procedure call errors (RPC_E_*)
#define FACILITY_DISPATCH   0x0002 // late binding dispatch errors
#define FACILITY_STORAGE   0x0003 // storage errors (STG_E_*)
#define FACILITY_ITF            0x0004 // interface-specific errors



#define S_OK                0L
#define S_FALSE             MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 1)



// --------------------- FACILITY_NULL errors ------------------------------

#define E_UNEXPECTED        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 0xffff)
                            // relatively catastrophic failure

#define E_NOTIMPL           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 1)
                            // not implemented

#define E_OUTOFMEMORY       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 2)
                            // ran out of memory

#define E_INVALIDARG        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 3)
                            // one or more arguments are invalid

#define E_NOINTERFACE       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 4)
                            // no such interface supported


#define E_POINTER           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 5)
                            // invalid pointer

#define E_HANDLE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 6)
                            // invalid handle

#define E_ABORT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 7)
                            // operation aborted

#define E_FAIL              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 8)
                            // unspecified error


#define E_ACCESSDENIED      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 9)
                            // general access denied error


// ----------------- FACILITY_ITF errors used by OLE ---------------------
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an OLE interface returns a FACILITY_ITF 
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//
// The ranges, their associated interfaces, and the header file that defines
// the actual scodes are given below.
// 

// Generic OLE errors that may be returned by many interfaces
#define OLE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0000)
#define OLE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x00FF)
#define OLE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0000)
#define OLE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x00FF)
// interfaces: all
// file: ole2.h


#define DRAGDROP_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0100)
#define DRAGDROP_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x010F)
#define DRAGDROP_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0100)
#define DRAGDROP_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x010F)
// interfaces: IDropSource, IDropTarget
// file: ole2.h

#define CLASSFACTORY_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0110)
#define CLASSFACTORY_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x011F)
#define CLASSFACTORY_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0110)
#define CLASSFACTORY_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x011F)
// interfaces: IClassFactory
// file:

#define MARSHAL_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0120)
#define MARSHAL_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x012F)
#define MARSHAL_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0120)
#define MARSHAL_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x012F)
// interfaces: IMarshal, IStdMarshalInfo, marshal APIs
// file:

#define DATA_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0130)
#define DATA_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x013F)
#define DATA_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0130)
#define DATA_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x013F)
// interfaces: IDataObject
// file: dvobj.h

#define VIEW_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0140)
#define VIEW_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x014F)
#define VIEW_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0140)
#define VIEW_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x014F)
// interfaces: IViewObject
// file: dvobj.h

#define REGDB_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0150)
#define REGDB_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x015F)
#define REGDB_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0150)
#define REGDB_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x015F)
// API: reg.dat manipulation
// file: 


// range 160 - 16F reserved

#define CACHE_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0170) 
#define CACHE_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x017F)
#define CACHE_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0170)
#define CACHE_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x017F)
// interfaces: IOleCache
// file:

#define OLEOBJ_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0180)
#define OLEOBJ_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x018F)
#define OLEOBJ_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0180)
#define OLEOBJ_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x018F)
// interfaces: IOleObject
// file:

#define CLIENTSITE_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0190) 
#define CLIENTSITE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x019F)
#define CLIENTSITE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0190)
#define CLIENTSITE_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x019F)
// interfaces: IOleClientSite
// file:

#define INPLACE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01A0)
#define INPLACE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01AF)
#define INPLACE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01A0)
#define INPLACE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01AF)
// interfaces: IOleWindow, IOleInPlaceObject, IOleInPlaceActiveObject,
//                 IOleInPlaceUIWindow, IOleInPlaceFrame, IOleInPlaceSite
// file:

#define ENUM_E_FIRST        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01B0)
#define ENUM_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01BF)
#define ENUM_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01B0)
#define ENUM_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01BF)
// interfaces: IEnum*
// file:

#define CONVERT10_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01C0)
#define CONVERT10_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01CF)
#define CONVERT10_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01C0)
#define CONVERT10_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01CF)
// API: OleConvertOLESTREAMToIStorage, OleConvertIStorageToOLESTREAM
// file:


#define CLIPBRD_E_FIRST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01D0)
#define CLIPBRD_E_LAST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01DF)
#define CLIPBRD_S_FIRST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01D0)
#define CLIPBRD_S_LAST      MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01DF)
// interfaces: OleSetClipboard, OleGetClipboard, OleFlushClipboard
// file: ole2.h

#define MK_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01E0)
#define MK_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01EF)
#define MK_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01E0)
#define MK_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01EF)
// interfaces: IMoniker, IBindCtx, IRunningObjectTable, IParseDisplayName,
//             IOleContainer, IOleItemContainer, IOleLink
// file: moniker.h


#define CO_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01F0)
#define CO_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01FF)
#define CO_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01F0)
#define CO_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01FF)
// all Co* API
// file: compobj.h


// range 200 - ffff for new error codes



#endif      // ifndef __SCODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\sdmerror.h ===
/***MD sdmerror.h - System Detection Manager Error Codes
 *
 *  This module contains System Detection Manager error codes.
 *
 *  Copyright (c) 1992,1993 Microsoft Corporation
 *  Author:	Michael Tsang (MikeTs)
 *  Created	03/14/94
 *
 *  MODIFICATION HISTORY
 */


#ifndef _INC_SDERROR
#define _INC_SDERROR


/*** System Detection Manager Errors (return values)
 */

#define IDSERR_NONE		0		//no error (success)
#define IDSERR_INVALID_PARAM	0x0001		//invalid service parameter
#define IDSERR_OUTOFMEM 	0x0002		//out of memory
#define IDSERR_REG_ACCESS	0x0003		//error accessing registry
#define IDSERR_SD_ALREADYOPEN	0x0004		//system detection already open
#define IDSERR_SD_NOTOPEN	0x0005		//system detection not yet open
#define IDSERR_HOOK_R0CODE	0x0006		//fail to hook Ring0 code
#define IDSERR_DUPINF		0x0007		//inf already registered
#define IDSERR_OPENINF		0x0008		//cannot open inf file
#define IDSERR_INF_LISTSECT	0x0009		//cannot find inflist section
#define IDSERR_INF_LISTLINE	0x000a		//invalid inflist line
#define IDSERR_INF_MODSECT	0x000b		//cannot find module section
#define IDSERR_INF_MODLINE	0x000c		//invalid module line
#define IDSERR_INF_MODNAME	0x000d		//module name too long
#define IDSERR_INF_FUNCSECT	0x000e		//cannot find function section
#define IDSERR_INF_FUNCLINE	0x000f		//invalid function line
#define IDSERR_LOADMOD		0x0010		//error loading module
#define IDSERR_INF_CLASSNAME	0x0011		//inf err in class name
#define IDSERR_INF_DANGERSECT	0x0012		//cannot find danger section
#define IDSERR_INF_DANGERLINE	0x0013		//invalid danger line
#define IDSERR_INF_DANGERFORMAT 0x0014		//invalid danger format
#define IDSERR_DANGER_INVALID	0x0015		//invalid danger regions
#define IDSERR_IOMEM_INVALID	0x0016		//invalid iomem regions
#define IDSERR_IOMEM_CONFLICT	0x0017		//iomem resource conflict
#define IDSERR_IRQDMA_INVALID	0x0018		//invalid irqdma resources
#define IDSERR_IRQDMA_CONFLICT	0x0019		//irqdma resource conflict
#define IDSERR_INF_BUSTYPE	0x001a		//invalid detection bus type
#define IDSERR_DETFUNC_DMSERR	0x001b		//DMS error in detection
#define IDSERR_DETFUNC_REGERR	0x001c		//reg error in detection code
#define IDSERR_DETFUNC_ERROR	0x001d		//detection function error
#define IDSERR_GENINSTALL	0x001e		//GenInstallEx error
#define IDSERR_NOSUCH_DEV	0x001f		//device not found
#define IDSERR_BUFF_TOOSMALL	0x0020		//buffer too small
#define IDSERR_DEV_ALREADYREG	0x0021		//device ID already registered
#define IDSERR_NOT_EISA 	0x0022		//not an EISA system
#define IDSERR_GETEISACONFIG	0x0023		//error getting EISA config
#define IDSERR_INF_CLASS	0x0024		//error in getting INF class
#define IDSERR_COPYLOGCONFIG	0x0025		//error in copying logconfig
#define IDSERR_DUPFUNC		0x0026		//function already registered
#define IDSERR_NOT_MCA		0x0027		//not a MCA system
#define IDSERR_ABORT		0x0028		//detection is aborted
#define IDSERR_GETFUNCADDR	0x0029		//fail to get function entry
#define IDSERR_HOOKINT86X	0x002a		//fail to hook Int86x worker
#define IDSERR_QUERYDOSDEV	0x002b		//fail to query dos dev info.
#define IDSERR_INF_RISKCAT	0x002c		//invalid risk category
#define IDSERR_NODOSDEV 	0x002d		//no such dos device
#define IDSERR_IOMEM_NOTFOUND	0x002e		//iomem block not found
#define IDSERR_IRQDMA_NOTFOUND	0x002f		//irqdma block not found
#define IDSERR_OPENCRASHLOG	0x0030		//failed to open detect log
#define IDSERR_NODOSTSR 	0x0031		//no such dos TSR
#define IDSERR_REGHW_DUP	0x0032		//duplicate hw registration
#define IDSERR_CALLRMPROC	0x0033		//call real mode proc error
#define IDSERR_NEEDREBOOT	0x0034		//need reboot after detection

#define SDMERR_NONE		IDSERR_NONE
#define SDMERR_INVALID_PARAM	(0x80000000 | IDSERR_INVALID_PARAM)
#define SDMERR_OUTOFMEM 	(0x80000000 | IDSERR_OUTOFMEM)
#define SDMERR_REG_ACCESS	(0x80000000 | IDSERR_REG_ACCESS)
#define SDMERR_SD_ALREADYOPEN	(0x80000000 | IDSERR_SD_ALREADYOPEN)
#define SDMERR_SD_NOTOPEN	(0x80000000 | IDSERR_SD_NOTOPEN)
#define SDMERR_HOOK_R0CODE	(0x80000000 | IDSERR_HOOK_R0CODE)
#define SDMERR_DUPINF		(0x80000000 | IDSERR_DUPINF)
#define SDMERR_OPENINF		(0x80000000 | IDSERR_OPENINF)
#define SDMERR_INF_LISTSECT	(0x80000000 | IDSERR_INF_LISTSECT)
#define SDMERR_INF_LISTLINE	(0x80000000 | IDSERR_INF_LISTLINE)
#define SDMERR_INF_MODSECT	(0x80000000 | IDSERR_INF_MODSECT)
#define SDMERR_INF_MODLINE	(0x80000000 | IDSERR_INF_MODLINE)
#define SDMERR_INF_MODNAME	(0x80000000 | IDSERR_INF_MODNAME)
#define SDMERR_INF_FUNCSECT	(0x80000000 | IDSERR_INF_FUNCSECT)
#define SDMERR_INF_FUNCLINE	(0x80000000 | IDSERR_INF_FUNCLINE)
#define SDMERR_LOADMOD		(0x80000000 | IDSERR_LOADMOD)
#define SDMERR_INF_CLASSNAME	(0x80000000 | IDSERR_INF_CLASSNAME)
#define SDMERR_INF_DANGERSECT	(0x80000000 | IDSERR_INF_DANGERSECT)
#define SDMERR_INF_DANGERLINE	(0x80000000 | IDSERR_INF_DANGERLINE)
#define SDMERR_INF_DANGERFORMAT (0x80000000 | IDSERR_INF_DANGERFORMAT)
#define SDMERR_DANGER_INVALID	(0x80000000 | IDSERR_DANGER_INVALID)
#define SDMERR_IOMEM_INVALID	(0x80000000 | IDSERR_IOMEM_INVALID)
#define SDMERR_IOMEM_CONFLICT	(0x80000000 | IDSERR_IOMEM_CONFLICT)
#define SDMERR_IRQDMA_INVALID	(0x80000000 | IDSERR_IRQDMA_INVALID)
#define SDMERR_IRQDMA_CONFLICT	(0x80000000 | IDSERR_IRQDMA_CONFLICT)
#define SDMERR_INF_BUSTYPE	(0x80000000 | IDSERR_INF_BUSTYPE)
#define SDMERR_DETFUNC_DMSERR	(0x80000000 | IDSERR_DETFUNC_DMSERR)
#define SDMERR_DETFUNC_REGERR	(0x80000000 | IDSERR_DETFUNC_REGERR)
#define SDMERR_DETFUNC_ERROR	(0x80000000 | IDSERR_DETFUNC_ERROR)
#define SDMERR_GENINSTALL	(0x80000000 | IDSERR_GENINSTALL)
#define SDMERR_NOSUCH_DEV	(0x80000000 | IDSERR_NOSUCH_DEV)
#define SDMERR_BUFF_TOOSMALL	(0x80000000 | IDSERR_BUFF_TOOSMALL)
#define SDMERR_DEV_ALREADYREG	(0x80000000 | IDSERR_DEV_ALREADYREG)
#define SDMERR_NOT_EISA 	(0x80000000 | IDSERR_NOT_EISA)
#define SDMERR_GETEISACONFIG	(0x80000000 | IDSERR_GETEISACONFIG)
#define SDMERR_INF_CLASS	(0x80000000 | IDSERR_INF_CLASS)
#define SDMERR_COPYLOGCONFIG	(0x80000000 | IDSERR_COPYLOGCONFIG)
#define SDMERR_DUPFUNC		(0x80000000 | IDSERR_DUPFUNC)
#define SDMERR_NOT_MCA		(0x80000000 | IDSERR_NOT_MCA)
#define SDMERR_ABORT		(0x80000000 | IDSERR_ABORT)
#define SDMERR_GETFUNCADDR	(0x80000000 | IDSERR_GETFUNCADDR)
#define SDMERR_HOOKINT86X	(0x80000000 | IDSERR_HOOKINT86X)
#define SDMERR_QUERYDOSDEV	(0x80000000 | IDSERR_QUERYDOSDEV)
#define SDMERR_INF_RISKCAT	(0x80000000 | IDSERR_INF_RISKCAT)
#define SDMERR_NODOSDEV 	(0x80000000 | IDSERR_NODOSDEV)
#define SDMERR_IOMEM_NOTFOUND	(0x80000000 | IDSERR_IOMEM_NOTFOUND)
#define SDMERR_IRQDMA_NOTFOUND	(0x80000000 | IDSERR_IRQDMA_NOTFOUND)
#define SDMERR_OPENCRASHLOG	(0x80000000 | IDSERR_OPENCRASHLOG)
#define SDMERR_NODOSTSR 	(0x80000000 | IDSERR_NODOSTSR)
#define SDMERR_REGHW_DUP	(0x80000000 | IDSERR_REGHW_DUP)
#define SDMERR_CALLRMPROC	(0x80000000 | IDSERR_CALLRMPROC)
#define SDMERR_NEEDREBOOT	(0x80000000 | IDSERR_NEEDREBOOT)

#endif	//_INC_SDERROR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\scrnsave.h ===
/*****************************************************************************\
*                                                                             *
* scrnsave.h    Windows 3.1 screensaver defines and definitions.
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SCRNSAVE
#define _INC_SCRNSAVE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* Icon resource ID.
 *
 * This should be the first icon used and must have this resource number.
 * This is needed as the first icon in the file will be grabbed
 */
#define ID_APP      100
#define DLG_CHANGEPASSWORD      2000
#define DLG_ENTERPASSWORD       2001
#define DLG_INVALIDPASSWORD     2002
#define DLG_SCRNSAVECONFIGURE   2003

#define idsIsPassword           1000
#define idsIniFile              1001
#define idsScreenSaver          1002
#define idsPassword             1003
#define idsDifferentPW          1004
#define idsChangePW             1005
#define idsBadOldPW             1006
#define idsAppName              1007
#define idsNoHelpMemory         1008
#define idsHelpFile             1009
#define idsDefKeyword           1010

/* This function is the Window Procedure for the screen saver.  It is
 * up to the programmer to handle any of the messages that wish to be
 * interpretted.  Any unused messages are then passed back to
 * DefScreenSaverProc if desired which will take default action on any
 * unprocessed message...
 */
LRESULT WINAPI ScreenSaverProc(HWND, unsigned, UINT, LPARAM);

/* This function performs default message processing.  Currently handles
 * the following messages:
 *
 * WM_SYSCOMMAND:   return FALSE if wParam is SC_SCREENSAVE or SC_CLOSE
 *
 * WM_DESTROY:      PostQuitMessage(0)
 *
 * WM_SETCURSOR:    By default, this will set the cursor to a null cursor,
 *                  thereby removing it from the screen.
 *
 * WM_LBUTTONDOWN:
 * WM_MBUTTONDOWN:
 * WM_RBUTTONDOWN:
 * WM_KEYDOWN:
 * WM_KEYUP:
 * WM_MOUSEMOVE:    By default, these will cause the program to terminate.
 *                  Unless the password option is enabled.  In that case
 *                  the DlgGetPassword() dialog box is brought up.
 *
 * WM_NCACTIVATE:
 * WM_ACTIVATEAPP:
 * WM_ACTIVATE:     By default, if the wParam parameter is FALSE (signifying
 *                  that transfer is being taken away from the application),
 *                  then the program will terminate.  Termination is
 *                  accomplished by generating a WM_CLOSE message.  This way,
 *                  if the user sets something up in the WM_CREATE, a
 *                  WM_DESTROY will be generated and it can be destroyed
 *                  properly.
 *                  This message is ignored, however is the password option
 *                  is enabled.
 */
LRESULT WINAPI DefScreenSaverProc(HWND, UINT, WPARAM, LPARAM);

/* A function is also needed for configuring the screen saver.  The function
 * should be exactly like it is below and must be exported such that the
 * program can use MAKEPROCINSTANCE on it and call up a dialog box. Further-
 * more, the template used for the dialog must be called
 * ScreenSaverConfigure to allow the main function to access it...
 */
BOOL    WINAPI ScreenSaverConfigureDialog(HWND, UINT, WPARAM, LPARAM);

/* This function is called from the ScreenSaveConfigureDialog() to change
 * the Screen Saver's password.  Note:  passwords are GLOBAL to all
 * screen savers using this model.  Whether or not the password is enabled
 * is LOCAL to a particular screen saver.
 */
BOOL    WINAPI DlgChangePassword(HWND, UINT, WPARAM, LPARAM);

/* To allow the programmer the ability to register child control windows, this
 * function is called prior to the creation of the dialog box.  Any
 * registering that is required should be done here, or return TRUE if none
 * is needed...
 */
BOOL    _cdecl RegisterDialogClasses(HINSTANCE);

/* The following three functions are called by DefScreenSaverProc and must
 * be exported by all screensavers using this model.
 */
BOOL    WINAPI DlgGetPassword(HWND, UINT, WPARAM, LPARAM);
BOOL    WINAPI DlgInvalidPassword(HWND, UINT, WPARAM, LPARAM);
DWORD   WINAPI HelpMessageFilterHookFunction(int, WORD, LPMSG);


//*****************************************************************************   // ;Internal
//***********************   R E B O O T   A P I   *****************************   // ;Internal
//*****************************************************************************   // ;Internal
                                                                                  // ;Internal
BOOL WINAPI DisableReboot( VOID );    // Disables Ctrl-Alt-Del                    // ;Internal
BOOL WINAPI EnableReboot( VOID );     // Enables Ctrl-Alt-Del                     // ;Internal
                                                                                  // ;Internal
                                                                                  // ;Internal
//*****************************************************************************
//***********************   QUICK TIMER   A P I   *****************************
//*****************************************************************************

BOOL PASCAL SetQuickTimer(HWND hWnd, WORD wTimer, WORD wQuickTime);
void PASCAL KillQuickTimer(void);

//*****************************************************************************
//*****************************************************************************

extern int WINAPI GetSystemMetricsX(int);
#define GetSystemMetrics  GetSystemMetricsX

//*****************************************************************************

/*
 * There are only three other points that should be of notice:
 * 1) The screen saver must have a string declared as 'szAppName' contaning the
 *     name of the screen saver, and it must be declared as a global.
 * 2) The screen saver EXE file should be renamed to a file with a SCR
 *     extension so that the screen saver dialog form the control panel can
 *     find it when is searches for screen savers.
 */
#define WS_GT   (WS_GROUP | WS_TABSTOP)
#define MAXFILELEN  13
#define TITLEBARNAMELEN 40
#define BUFFLEN    255

/* The following globals are defined in scrnsave.lib */
extern HINSTANCE _cdecl hMainInstance;
extern HWND _cdecl hMainWindow;
extern HWND _cdecl hParentWindow;
extern BOOL _cdecl fConfigure;
extern BOOL _cdecl fPreview;
extern BOOL _cdecl fInstall;
extern char _cdecl szName[TITLEBARNAMELEN];
extern char _cdecl szIsPassword[22];
extern char _cdecl szIniFile[MAXFILELEN];
extern char _cdecl szScreenSaver[22];
extern char _cdecl szPassword[16];
extern char _cdecl szDifferentPW[BUFFLEN];
extern char _cdecl szChangePW[30];
extern char _cdecl szBadOldPW[BUFFLEN];
extern char _cdecl szHelpFile[MAXFILELEN];
extern char _cdecl szNoHelpMemory[BUFFLEN];
extern HOOKPROC _cdecl fpMessageFilter;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_SCRNSAVE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*   Copyright (c) 1985-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the machine-dependent buffer used by
*   setjmp/longjmp to save and restore the program state, and
*   declarations for those routines.
*   [ANSI/System V]
*
****/

#ifndef _INC_SETJMP

#ifndef __cplusplus

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

/* define the buffer type for holding the state information */

#define _JBLEN  9  /* bp, di, si, sp, ret addr, ds */

#ifndef _JMP_BUF_DEFINED
typedef  int  jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif 

/* ANSI requires setjmp be a macro */

#define setjmp  _setjmp

/* function prototypes */

int  __cdecl _setjmp(jmp_buf);
int  __cdecl setjmp(jmp_buf); //JAH
void __cdecl longjmp(jmp_buf, int);

#endif 

#define _INC_SETJMP
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the file sharing modes for sopen().
*
****/

#ifndef _INC_SHARE

#define _SH_COMPAT  0x00    /* compatibility mode */
#define _SH_DENYRW  0x10    /* deny read/write mode */
#define _SH_DENYWR  0x20    /* deny write mode */
#define _SH_DENYRD  0x30    /* deny read mode */
#define _SH_DENYNO  0x40    /* deny none mode */

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define SH_COMPAT _SH_COMPAT
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif 

#define _INC_SHARE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the declarations and definitions for the
*   spawnxx, execxx, and various other process control routines.
*
****/

#ifndef _INC_PROCESS

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/* mode values for spawnxx routines
 * (only P_WAIT and P_OVERLAY are supported on MS-DOS)
 */

#ifndef _MT
extern int __near __cdecl _p_overlay;
#endif 

#define _P_WAIT     0
#define _P_NOWAIT   1
#ifdef _MT
#define _P_OVERLAY  2
#else 
#define _P_OVERLAY  _p_overlay
#endif 
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO  3
#define _P_DETACH   4


/* function prototypes */

#ifdef _MT
int __cdecl _beginthread(void(__cdecl *)(void *),
    void *, unsigned, void *);
void __cdecl _endthread(void);
#endif 
void __cdecl abort(void);
void __cdecl _cexit(void);
void __cdecl _c_exit(void);
#ifndef _WINDOWS
int __cdecl _execl(const char *, const char *, ...);
int __cdecl _execle(const char *, const char *, ...);
int __cdecl _execlp(const char *, const char *, ...);
int __cdecl _execlpe(const char *, const char *, ...);
int __cdecl _execv(const char *,
    const char * const *);
int __cdecl _execve(const char *,
    const char * const *, const char * const *);
int __cdecl _execvp(const char *,
    const char * const *);
int __cdecl _execvpe(const char *,
    const char * const *, const char * const *);
#endif 
#ifndef _WINDLL
void __cdecl exit(int);
void __cdecl _exit(int);
#endif 
int __cdecl _getpid(void);
#ifndef _WINDOWS
int __cdecl _spawnl(int, const char *, const char *,
    ...);
int __cdecl _spawnle(int, const char *, const char *,
    ...);
int __cdecl _spawnlp(int, const char *, const char *,
    ...);
int __cdecl _spawnlpe(int, const char *, const char *,
    ...);
int __cdecl _spawnv(int, const char *,
    const char * const *);
int __cdecl _spawnve(int, const char *,
    const char * const *, const char * const *);
int __cdecl _spawnvp(int, const char *,
    const char * const *);
int __cdecl _spawnvpe(int, const char *,
    const char * const *, const char * const *);
int __cdecl system(const char *);
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define P_WAIT      _P_WAIT
#define P_NOWAIT    _P_NOWAIT
#define P_OVERLAY   _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO   _P_NOWAITO
#define P_DETACH    _P_DETACH

#ifndef _WINDOWS
int __cdecl execl(const char *, const char *, ...);
int __cdecl execle(const char *, const char *, ...);
int __cdecl execlp(const char *, const char *, ...);
int __cdecl execlpe(const char *, const char *, ...);
int __cdecl execv(const char *,
    const char * const *);
int __cdecl execve(const char *,
    const char * const *, const char * const *);
int __cdecl execvp(const char *,
    const char * const *);
int __cdecl execvpe(const char *,
    const char * const *, const char * const *);
#endif 
int __cdecl getpid(void);
#ifndef _WINDOWS
int __cdecl spawnl(int, const char *, const char *,
    ...);
int __cdecl spawnle(int, const char *, const char *,
    ...);
int __cdecl spawnlp(int, const char *, const char *,
    ...);
int __cdecl spawnlpe(int, const char *, const char *,
    ...);
int __cdecl spawnv(int, const char *,
    const char * const *);
int __cdecl spawnve(int, const char *,
    const char * const *, const char * const *);
int __cdecl spawnvp(int, const char *,
    const char * const *);
int __cdecl spawnvpe(int, const char *,
    const char * const *, const char * const *);
#endif 

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_PROCESS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\setupx.h ===
//**********************************************************************
//
// SETUPX.H
//
//  Copyright (c) 1993 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Chicago Setup services.
//
// 12/1/93      DONALDM     Added LPCLASS_INFO, and function protos for
//                          exports in SETUP4.DLL
// 12/4/943     DONALDM     Moved SHELL.H include and Chicago specific
//                          helper functions to SETUP4.H
// 1/11/94      DONALDM     Added members to DEVICE_INFO to better handle
//                          ClassInstaller load/unload.
// 1/11/94      DONALDM     Added some new DIF_ messages for Net guys.
// 2/25/94      DONALDM     Fixed a bug with the DIREG_ flags
//**********************************************************************

#ifndef SETUPX_INC
#define SETUPX_INC   1                   // SETUPX.H signature

/***************************************************************************/
// setup PropertySheet support
// NOTE:  Always include PRST.H because it is needed later for Class Installer
// stuff, and optionally define the SU prop sheet stuff.
/***************************************************************************/
#include <prsht.h>
#ifndef NOPRSHT
HPROPSHEETPAGE  WINAPI SUCreatePropertySheetPage(LPCPROPSHEETPAGE lppsp);
BOOL            WINAPI SUDestroyPropertySheetPage(HPROPSHEETPAGE hPage);
int             WINAPI SUPropertySheet(LPCPROPSHEETHEADER lppsh);
#endif // NOPRSHT

typedef UINT RETERR;             // Return Error code type.

#define OK 0                     // success error code

#define IP_ERROR       (100)    // Inf parsing
#define TP_ERROR       (200)    // Text processing module
#define VCP_ERROR      (300)    // Virtual copy module
#define GEN_ERROR      (400)    // Generic Installer
#define DI_ERROR       (500)    // Device Installer

// err2ids mappings
enum ERR_MAPPINGS {
    E2I_VCPM,           // Maps VCPM to strings
    E2I_SETUPX,         // Maps setupx returns to strings
    E2I_SETUPX_MODULE,  // Maps setupx returns to appropriate module
    E2I_DOS_SOLUTION,   // Maps DOS Extended errors to solutions
    E2I_DOS_REASON,     // Maps DOS extended errors to strings.
    E2I_DOS_MEDIA,      // Maps DOS extended errors to media icon.
};

#ifndef NOVCP

/***************************************************************************/
//
// Logical Disk ID definitions
//
/***************************************************************************/

// DECLARE_HANDLE(VHSTR);           /* VHSTR = VirtCopy Handle to STRing */
typedef UINT VHSTR;         /* VirtCopy Handle to String */

VHSTR   WINAPI vsmStringAdd(LPCSTR lpszName);
int WINAPI vsmStringDelete(VHSTR vhstr);
VHSTR   WINAPI vsmStringFind(LPCSTR lpszName);
int WINAPI vsmGetStringName(VHSTR vhstr, LPSTR lpszBuffer, int cbBuffer);
int WINAPI vsmStringCompare(VHSTR vhstrA, VHSTR vhstrB);
LPCSTR  WINAPI vsmGetStringRawName(VHSTR vhstr);
void    WINAPI vsmStringCompact(void);

typedef UINT LOGDISKID;          /* ldid */

// Logical Disk Descriptor: Structure which describes the physical attributes
// of a logical disk. Every logical disk is assigned a logical disk
// identifier (LDID), and is described by a logical disk descriptor (LDD).
//
// The cbSize structure member must always be set to sizeof(LOGDISKDESC_S),
// but all other unused structure members should be NULL or 0. No validation
// is performed on the size of string arrays; all string pointers, if
// non-NULL and they are to receive a string, must point at string arrays
// whose sizes are as follows:
//      sizeof( szPath )    = MAX_PATH_LEN
//      sizeof( szVolLabel) = MAX_FILENAME_LEN
//      sizeof( szName )    = MAX_STRING_LEN
#define MAX_PATH_LEN        260     // Max. path length.
#define MAX_FILENAME_LEN    20      // Max. filename length. ( > sizeof( "x:\\12345678.123" )


typedef struct _LOGDISKDESC_S { /* ldd */
    WORD        cbSize;                 // Size of this structure (bytes)
    LOGDISKID   ldid;                   // Logical Disk ID.
    LPSTR       pszPath;                // Ptr. to associated Path string.
    LPSTR       pszVolLabel;            // Ptr. to Volume Label string.
    LPSTR       pszDiskName;            // Ptr. to Disk Name string.
    WORD        wVolTime;               // Volume label modification time.
    WORD        wVolDate;               // Volume label modification date.
    DWORD       dwSerNum;               // Disk serial number.
    WORD        wFlags;                 // Flags.
} LOGDISKDESC_S, FAR *LPLOGDISKDESC;


// Range for pre-defined LDIDs.
#define LDID_PREDEF_START   0x0001  // Start of range
#define LDID_PREDEF_END     0x7FFF  // End of range

// Range for dynamically assigned LDIDs.
#define LDID_ASSIGN_START   0x8000  // Start of range
#define LDID_ASSIGN_END     0xBFFF  // End of range

// Pre-defined Logical Disk Identifiers (LDID).
//
#define LDID_NULL       0               // Null (undefined) LDID.
#define LDID_ABSOLUTE   ((UINT)-1)      // Absolute path

// source path of windows install, this is typically A:\ or a net drive
#define LDID_SRCPATH    1   // source of instilation
// temporary setup directory used by setup, this is only valid durring
// regular install
#define LDID_SETUPTEMP  2   // temporary setup dir for install
// path to uninstall location, this is where we backup files that will
// be overwritten
#define LDID_UNINSTALL  3   // uninstall (backup) dir.
// backup path for the copy engine, this should not be used
#define LDID_BACKUP     4   // BUGBUG: backup dir for the copy engine, not used

// windows directory, this is the destinatio of the insallation
#define LDID_WIN        10  // destination Windows dir (just user files).
#define LDID_SYS        11  // destination Windows System dir.
#define LDID_IOS        12  // destination Windows Iosubsys dir.
#define LDID_CMD        13  // destination Windows Command (DOS) dir.
#define LDID_CPL        14  // destination Windows Control Panel dir.
#define LDID_PRINT      15  // destination Windows Printer dir.
#define LDID_MAIL       16  // destination Mail dir.
#define LDID_INF        17  // destination Windows *.INF dir.
#define LDID_HELP       18  // destination Windows Help dir.
#define LDID_WINADMIN   19  // admin stuff.

// Shared dirs for net install.
#define LDID_SHARED     25  // Bulk of windows files.
#define LDID_WINBOOT    26  // guarenteed boot device for windows.
#define LDID_MACHINE    27  // machine specific files.
#define LDID_HOST_WINBOOT   28

// boot and old win and dos dirs.
#define LDID_BOOT       30  // Root dir of boot drive
#define LDID_BOOT_HOST  31  // Root dir of boot drive host
#define LDID_OLD_WINBOOT    32  // Subdir off of Root (optional)
#define LDID_OLD_WIN    33  // old windows directory (if it exists)
#define LDID_OLD_DOS    34  // old dos directory (if it exists)


// Convert Ascii drive letter to Integer drive number ('A'=1, 'B'=2, ...).
#define DriveAtoI( chDrv )      ((int)(chDrv & 31))

// Convert Integer drive number to Ascii drive letter (1='A', 2='B', ...).
#define DriveItoA( iDrv )       ((char) (iDrv - 1 + 'A'))


// BUGBUG: change the names of these

RETERR WINAPI CtlSetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlGetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlFindLdd    ( LPLOGDISKDESC );
RETERR WINAPI CtlAddLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlDelLdd     ( LOGDISKID  );
RETERR WINAPI CtlGetLddPath ( LOGDISKID, LPSTR );


/***************************************************************************/
//
// Virtual File Copy definitions
//
/***************************************************************************/


typedef DWORD LPEXPANDVTBL;         /* BUGBUG -- clean this up */

enum _ERR_VCP
{
    ERR_VCP_IOFAIL = (VCP_ERROR + 1),       // File I/O failure
    ERR_VCP_STRINGTOOLONG,                  // String length limit exceeded
    ERR_VCP_NOMEM,                          // Insufficient memory to comply
    ERR_VCP_NOVHSTR,                        // No string handles available
    ERR_VCP_OVERFLOW,                       // Reference count would overflow
    ERR_VCP_BADARG,                         // Invalid argument to function
    ERR_VCP_UNINIT,                         // String library not initialized
    ERR_VCP_NOTFOUND ,                      // String not found in string table
    ERR_VCP_BUSY,                           // Can't do that now
    ERR_VCP_INTERRUPTED,                    // User interrupted operation
    ERR_VCP_BADDEST,                        // Invalid destination directory
    ERR_VCP_SKIPPED,                        // User skipped operation
    ERR_VCP_IO,                             // Hardware error encountered
    ERR_VCP_LOCKED,                         // List is locked
    ERR_VCP_WRONGDISK,                      // The wrong disk is in the drive
    ERR_VCP_CHANGEMODE,                     //
    ERR_VCP_LDDINVALID,                // Logical Disk ID Invalid.
    ERR_VCP_LDDFIND,                   // Logical Disk ID not found.
    ERR_VCP_LDDUNINIT,                 // Logical Disk Descriptor Uninitialized.
    ERR_VCP_LDDPATH_INVALID,
    ERR_VCP_NOEXPANSION,                // Failed to load expansion dll
    ERR_VCP_NOTOPEN,                    // Copy session not open
};


/*****************************************************************************
 *              Structures
 *****************************************************************************/

/*---------------------------------------------------------------------------*
 *                  VCPPROGRESS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPPROGRESS { /* prg */
    DWORD   dwSoFar;            /* Number of units copied so far */
    DWORD   dwTotal;            /* Number of units to copy */
} VCPPROGRESS, FAR *LPVCPPROGRESS;

/*---------------------------------------------------------------------------*
 *                  VCPDISKINFO
 *---------------------------------------------------------------------------*/


typedef struct tagVCPDISKINFO {
    WORD        cbSize;         /* Size of this structure in bytes */
    LOGDISKID   ldid;           /* Logical disk ID */
    VHSTR       vhstrRoot;      /* Location of root directory */
    VHSTR       vhstrVolumeLabel;/* Volume label */
    VHSTR       vhstrDiskName;  // Printed name on the disk.
    WORD        wVolumeTime;    /* Volume label modification time */
    WORD        wVolumeDate;    /* Volume label modification date */
    DWORD       dwSerialNumber; /* Disk serial number */
    WORD        fl;             /* Flags */
    LPARAM      lparamRef;      /* Reference data for client */

    VCPPROGRESS prgFileRead;    /* Progress info */
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

} VCPDISKINFO, FAR *LPVCPDISKINFO;

#define VDIFL_VALID     0x0001  /* Fields are valid from a prev. call */
#define VDIFL_EXISTS    0x0002  /* Disk exists; do not format */

RETERR WINAPI DiskInfoFromLdid(LOGDISKID ldid, LPVCPDISKINFO lpdi);


/*---------------------------------------------------------------------------*
 *                  VCPFILESPEC
 *---------------------------------------------------------------------------*/

typedef struct tagVCPFILESPEC { /* vfs */
    LOGDISKID   ldid;           /* Logical disk */
    VHSTR       vhstrDir;       /* Directory withing logical disk */
    VHSTR       vhstrFileName;  /* Filename within directory */
} VCPFILESPEC, FAR *LPVCPFILESPEC;

/*---------------------------------------------------------------------------*
 *              VCPFATTR
 *---------------------------------------------------------------------------*/

/*
 * BUGBUG -- explain diffce between llenIn and llenOut wrt compression.
 */
typedef struct tagVCPFATTR {
    UINT    uiMDate;            /* Modification date */
    UINT    uiMTime;            /* Modification time */
    UINT    uiADate;            /* Access date */
    UINT    uiATime;            /* Access time */
    UINT    uiAttr;             /* File attribute bits */
    DWORD   llenIn;             /* Original file length */
    DWORD   llenOut;            /* Final file length */
                                /* (after decompression) */
} VCPFATTR, FAR *LPVCPFATTR;

/*---------------------------------------------------------------------------*
 *                  VIRTNODEEX
 *---------------------------------------------------------------------------*/
typedef struct tagVIRTNODEEX
{    /* vnex */
    HFILE           hFileSrc;
    HFILE           hFileDst;
    VCPFATTR        fAttr;
    WORD            dosError;   // The first/last error encountered
    VHSTR           vhstrFileName;  // The original destination name.
    WPARAM          vcpm;   // The message that was being processed.
} VIRTNODEEX, FAR *LPCVIRTNODEEX, FAR *LPVIRTNODEEX ;


/*---------------------------------------------------------------------------*
 *                  VIRTNODE
 *---------------------------------------------------------------------------*/

typedef struct tagVIRTNODE {    /* vn */
    WORD            cbSize;
    VCPFILESPEC     vfsSrc;
    VCPFILESPEC     vfsDst;
    WORD            fl;
    LPARAM          lParam;
    LPEXPANDVTBL    lpExpandVtbl;
    LPVIRTNODEEX    lpvnex;
} VIRTNODE, FAR *LPCVIRTNODE, FAR *LPVIRTNODE ;


/*---------------------------------------------------------------------------*
 *              VCPDESTINFO
 *---------------------------------------------------------------------------*/

typedef struct tagVCPDESTINFO { /* destinfo */
    WORD    flDevAttr;          /* Device attributes */
    LONG    cbCapacity;         /* Disk capacity */
    WORD    cbCluster;          /* Bytes per cluster */
    WORD    cRootDir;           /* Size of root directory */
} VCPDESTINFO, FAR *LPVCPDESTINFO;

#define DIFL_FIXED      0x0001  /* Nonremoveable media */
#define DIFL_CHANGELINE 0x0002  /* Change line support */

// Now also used by the virtnode as we dont have copy nodes any more.
// #define CNFL_BACKUP             0x0001  /* This is a backup node */
#define CNFL_DELETEONFAILURE    0x0002  /* Dest should be deleted on failure */
#define CNFL_RENAMEONSUCCESS    0x0004  /* Dest needs to be renamed */
#define CNFL_CONTINUATION       0x0008  /* Dest is continued onto difft disk */
#define CNFL_SKIPPED            0x0010  /* User asked to skip file */
#define CNFL_IGNOREERRORS       0x0020  // An error has occured on this file already
#define CNFL_RETRYFILE          0x0040  // Retry the file (error ocurred)
#define CNFL_COPIED				0x0080  // Node has already been copied.

// BUGBUG: verify the use and usefullness of these flags
// #define VNFL_UNIQUE          0x0000  /* Default */
#define VNFL_MULTIPLEOK         0x0100  /* Do not search PATH for duplicates */
#define VNFL_DESTROYOLD         0x0200  /* Do not back up files */
// #define VNFL_NOW             0x0400  /* Use by vcp Flush */
// To deternime what kind of node it is.
#define VNFL_COPY			    0x0000  // A simple copy node.
#define VNFL_DELETE             0x0800  // A delete node
#define VNFL_RENAME             0x1000  // A rename node
#define VNFL_NODE_TYPE		    ( VNFL_RENAME|VNFL_DELETE|VNFL_COPY )
    /* Read-only flag bits */
#define VNFL_CREATED            0x2000  /* VCPM_NODECREATE has been sent */
#define VNFL_REJECTED           0x4000  /* Node has been rejected */

#define VNFL_DEVICEINSTALLER    0x8000     /* Node was added by the Device Installer */


/*---------------------------------------------------------------------------*
 *                  VCPSTATUS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPSTATUS {   /* vstat */
    WORD    cbSize;             /* Size of this structure */

    VCPPROGRESS prgDiskRead;
    VCPPROGRESS prgFileRead;
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgDiskWrite;
    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

    LPVCPDISKINFO lpvdiIn;      /* Current input disk */
    LPVCPDISKINFO lpvdiOut;     /* Current output disk */
    LPVIRTNODE    lpvn;            /* Current file */

} VCPSTATUS, FAR *LPVCPSTATUS;

/*---------------------------------------------------------------------------*
 *                  VCPVERCONFLICT
 *---------------------------------------------------------------------------*/

typedef struct tagVCPVERCONFLICT {

    LPCSTR  lpszOldFileName;
    LPCSTR  lpszNewFileName;
    DWORD   dwConflictType;     /* Same values as VerInstallFiles */
    LPVOID  lpvinfoOld;         /* Version information resources */
    LPVOID  lpvinfoNew;
    WORD    wAttribOld;         /* File attributes for original */
    LPARAM  lparamRef;          /* Reference data for callback */

} VCPVERCONFLICT, FAR *LPVCPVERCONFLICT;

/*****************************************************************************
 *              Callback functions
 *****************************************************************************/

typedef LRESULT (CALLBACK *VIFPROC)(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

LRESULT CALLBACK vcpDefCallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

// callback for default UI.
// lparamRef --> a VCPUIINFO structure
LRESULT CALLBACK vcpUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);


/*---------------------------------------------------------------------------*
 *                  VCPUIINFO
 *
 * This structure is passed in as the lparamRef of vcpUICallbackProc.
 *
 * on using vcpUICallbackProc:
 * - to use, have vcpUICallbackProc as the callback for vcpOpen with
 *   an appropriately filled in VCPUIINFO structure as the lparamRef.
 *
 * - based on flags, hwndProgress is created and maintained
 * - lpfnStatCallback is called with only status messages
 *     returning VCPM_ABORT indicates that the copy should be aborted
 * - if hwndProgress is non-NULL, the control with idProgress will
 *     receive progress gauge messages as appropriate
 *
 *---------------------------------------------------------------------------*/
#define VCPUI_CREATEPROGRESS 0x0001 // callback should create and manage progress gauge dialog
#define VCPUI_NOBROWSE       0x0002 // no browse button in InsertDisk
#define VCPUI_RENAMEREQUIRED 0x0004 // as a result of a file being in use at copy, reboot required

typedef struct {
    UINT flags;
    HWND hwndParent;            // window of parent
    HWND hwndProgress;          // window to get progress updates (nonzero ids)
    UINT idPGauge;              // id for progress gauge
    VIFPROC lpfnStatCallback;   // callback for status info (or NULL)
    LPARAM lUserData;           // caller definable data
    LOGDISKID ldidCurrent;      // reserved.  do not touch.
} VCPUIINFO, FAR *LPVCPUIINFO;

/******************************************************************************
 *          Callback notification codes
 *****************************************************************************/

    /* BUGBUG -- VCPN_ABORT should match VCPERROR_INTERRUPTED */

#define VCPN_OK         0       /* All is hunky-dory */
#define VCPN_PROCEED        0   /* The same as VCPN_OK */

#define VCPN_ABORT      (-1)    /* Cancel current operation */
#define VCPN_RETRY      (-2)    /* Retry current operation */
#define VCPN_IGNORE     (-3)    /* Ignore error and continue */
#define VCPN_SKIP       (-4)    /* Skip this file and continue */
#define VCPN_FORCE      (-5)    /* Force an action */
#define VCPN_DEFER      (-6)    /* Save the action for later */
#define VCPN_FAIL       (-7)    /* Return failure back to caller */
#define VCPN_RETRYFILE  (-8)    // An error ocurred during file copy, do it again.

/*****************************************************************************
 *          Callback message numbers
 *****************************************************************************/

#define VCPM_CLASSOF(uMsg)  HIBYTE(uMsg)
#define VCPM_TYPEOF(uMsg)   (0x00FF & (uMsg))   // LOBYTE(uMsg)

/*---------------------------------------------------------------------------*
 *          ERRORs
 *---------------------------------------------------------------------------*/

#define VCPM_ERRORCLASSDELTA    0x80
#define VCPM_ERRORDELTA         0x8000      /* Where the errors go */

/*---------------------------------------------------------------------------*
 *          Disk information callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_DISKCLASS      0x01
#define VCPM_DISKFIRST      0x0100
#define VCPM_DISKLAST       0x01FF

enum tagVCPM_DISK {

    VCPM_DISKCREATEINFO = VCPM_DISKFIRST,
    VCPM_DISKGETINFO,
    VCPM_DISKDESTROYINFO,
    VCPM_DISKPREPINFO,

    VCPM_DISKENSURE,
    VCPM_DISKPROMPT,

    VCPM_DISKFORMATBEGIN,
    VCPM_DISKFORMATTING,
    VCPM_DISKFORMATEND,

    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          File copy callbacks
 *---------------------------------------------------------------------------*/

// BUGBUG: this needs to be merged back with other internal errors
#define VCPERROR_IO         (VCP_ERROR - ERR_VCP_IO)            /* Hardware error encountered */

#define VCPM_FILEINCLASS    0x02
#define VCPM_FILEOUTCLASS   0x03
#define VCPM_FILEFIRSTIN    0x0200
#define VCPM_FILEFIRSTOUT   0x0300
#define VCPM_FILELAST       0x03FF

enum tagVCPM_FILE {
    VCPM_FILEOPENIN = VCPM_FILEFIRSTIN,
    VCPM_FILEGETFATTR,
    VCPM_FILECLOSEIN,
    VCPM_FILECOPY,
    VCPM_FILENEEDED,

    VCPM_FILEOPENOUT = VCPM_FILEFIRSTOUT,
    VCPM_FILESETFATTR,
    VCPM_FILECLOSEOUT,
    VCPM_FILEFINALIZE,
    VCPM_FILEDELETE,
    VCPM_FILERENAME,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VIRTNODE callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_NODECLASS  0x04
#define VCPM_NODEFIRST  0x0400
#define VCPM_NODELAST   0x04FF

enum tagVCPM_NODE {
    VCPM_NODECREATE = VCPM_NODEFIRST,
    VCPM_NODEACCEPT,
    VCPM_NODEREJECT,
    VCPM_NODEDESTROY,
    VCPM_NODECHANGEDESTDIR,
    VCPM_NODECOMPARE,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          TALLY callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_TALLYCLASS     0x05
#define VCPM_TALLYFIRST     0x0500
#define VCPM_TALLYLAST      0x05FF

enum tagVCPM_TALLY {
    VCPM_TALLYSTART = VCPM_TALLYFIRST,
    VCPM_TALLYEND,
    VCPM_TALLYFILE,
    VCPM_TALLYDISK,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VER callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VERCLASS       0x06
#define VCPM_VERFIRST       0x0600
#define VCPM_VERLAST        0x06FF

enum tagVCPM_VER {
    VCPM_VERCHECK = VCPM_VERFIRST,
    VCPM_VERCHECKDONE,
    VCPM_VERRESOLVECONFLICT,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VSTAT callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VSTATCLASS     0x07
#define VCPM_VSTATFIRST     0x0700
#define VCPM_VSTATLAST      0x07FF

enum tagVCPM_VSTAT {
    VCPM_VSTATSTART = VCPM_VSTATFIRST,
    VCPM_VSTATEND,
    VCPM_VSTATREAD,
    VCPM_VSTATWRITE,
    VCPM_VSTATNEWDISK,

    VCPM_VSTATCLOSESTART,       // Start of VCP close
    VCPM_VSTATCLOSEEND,         // upon leaving VCP close
    VCPM_VSTATBACKUPSTART,      // Backup is beginning
    VCPM_VSTATBACKUPEND,        // Backup is finished
    VCPM_VSTATRENAMESTART,      // Rename phase start/end
    VCPM_VSTATRENAMEEND,
    VCPM_VSTATCOPYSTART,        // Acutal copy phase
    VCPM_VSTATCOPYEND,
    VCPM_VSTATDELETESTART,      // Delete phase
    VCPM_VSTATDELETEEND,
    VCPM_VSTATPATHCHECKSTART,   // Check for valid paths
    VCPM_VSTATPATHCHECKEND,
    VCPM_VSTATUSERABORT,        // User wants to quit.
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          Destination info callbacks
 *---------------------------------------------------------------------------*/

/* BUGBUG -- find a reasonable message range for this */
#define VCPM_PATHCLASS      0x08
#define VCPM_PATHFIRST      0x0800
#define VCPM_PATHLAST       0x08FF

enum tagVCPM_PATH{
    VCPM_BUILDPATH = VCPM_PATHFIRST,
    VCPM_UNIQUEPATH,
    VCPM_CHECKPATH,
};

// #define VCPM_BUILDPATH      0x83

/*****************************************************************************/
void WINAPI VcpAddMRUPath( LPCSTR lpszPath );
#define SZ_INSTALL_LOCATIONS "InstallLocationsMRU"


RETERR WINAPI VcpOpen(VIFPROC vifproc, LPARAM lparamMsgRef);

RETERR WINAPI VcpClose(WORD fl, LPCSTR lpszBackupDest);

RETERR WINAPI VcpFlush(WORD fl, LPCSTR lpszBackupDest);

#define VCPFL_ABANDON           0x0000  /* Abandon all pending file copies */
#define VCPFL_BACKUP            0x0001  /* Perform backup */
#define VCPFL_COPY              0x0002  /* Copy files */
#define VCPFL_BACKUPANDCOPY     (VCPFL_BACKUP | VCPFL_COPY)
#define VCPFL_INSPECIFIEDORDER  0x0004  /* Do not sort before copying */
#define VCPFL_DELETE            0x0008
#define VCPFL_RENAME            0x0010
#define VCPFL_DIAMOND           0x0020

typedef int (CALLBACK *VCPENUMPROC)(LPVIRTNODE lpvn, LPARAM lparamRef);

int WINAPI vcpEnumFiles(VCPENUMPROC vep, LPARAM lparamRef);

enum tag_VCPM_EXPLAIN{
    VCPEX_SRC_DISK,
    VCPEX_SRC_CABINET,
    VCPEX_SRC_LOCN,
    VCPEX_DST_LOCN,
    VCPEX_SRC_FILE,
    VCPEX_DST_FILE,
    VCPEX_DOS_ERROR,
    VCPEX_MESSAGE,
    VCPEX_DOS_SOLUTION,
    VCPEX_SRC_FULL,
    VCPEX_DST_FULL,
};

LPCSTR WINAPI VcpExplain( LPVIRTNODE lpVn, DWORD dwWhat );

/* Flag bits that can be set via VcpQueueCopy */


// Various Lparams for files
#define VNLP_SYSCRITICAL    0x0001  // This file should not be skipped
#define VNLP_SETUPCRITICAL  0x0002  // This file cannot be skipped

// VcpEnumFiles Flags.

#define VEN_OP      0x00ff      /* Operation field */

#define VEN_NOP     0x0000      /* Do nothing */
#define VEN_DELETE  0x0001      /* Delete current item */
#define VEN_SET     0x0002      /* Change value of current item */

#define VEN_FL      0xff00      /* Flags field */

#define VEN_STOP    0x0100      /* Stop enumeration after this item */
#define VEN_ERROR   0x8000      /* Stop enumeration after this item
                                 * and ignore the OP field */



// BUGBUG: add the other VCP stuff necessary to use this

// BUGBUG: remove the lpsz*Dir fields, make overload the LDID with them

RETERR WINAPI VcpQueueCopy(LPCSTR lpszSrcFileName, LPCSTR lpszDstFileName,
                LPCSTR lpszSrcDir, LPCSTR lpszDstDir,
                LOGDISKID ldidSrc, LOGDISKID ldidDst,
                LPEXPANDVTBL lpExpandVtbl, WORD fl,
                LPARAM lParam);

RETERR WINAPI VcpQueueDelete( LPCSTR lpszDstFileName,
                              LPCSTR lpszDstDir,
                              LOGDISKID ldidDst,
                              LPARAM lParamRef );

RETERR WINAPI VcpQueueRename( LPCSTR      lpszSrcFileName,
                            LPCSTR      lpszDstFileName,
                            LPCSTR      lpszSrcDir,
                            LPCSTR      lpszDstDir,
                            LOGDISKID   ldidSrc,
                            LOGDISKID   ldidDst,
                            LPARAM      lParam );

#endif // NOVCP



#ifndef NOINF
/***************************************************************************/
//
// Inf Parser API declaration and definitions
//
/***************************************************************************/

enum _ERR_IP
{
    ERR_IP_INVALID_FILENAME = (IP_ERROR + 1),
    ERR_IP_ALLOC_ERR,
    ERR_IP_INVALID_SECT_NAME,
    ERR_IP_OUT_OF_HANDLES,
    ERR_IP_INF_NOT_FOUND,
    ERR_IP_INVALID_INFFILE,
    ERR_IP_INVALID_HINF,
    ERR_IP_INVALID_FIELD,
    ERR_IP_SECT_NOT_FOUND,
    ERR_IP_END_OF_SECTION,
    ERR_IP_PROFILE_NOT_FOUND,
    ERR_IP_LINE_NOT_FOUND,
    ERR_IP_FILEREAD,
    ERR_IP_TOOMANYINFFILES,
    ERR_IP_INVALID_SAVERESTORE,
    ERR_IP_INVALID_INFTYPE
};

#define INFTYPE_TEXT                0
#define INFTYPE_EXECUTABLE          1

#define MAX_SECT_NAME_LEN    32

typedef struct _INF NEAR * HINF;
typedef struct _INFLINE FAR * HINFLINE;            // tolken to inf line

RETERR  WINAPI IpOpen(LPCSTR pszFileSpec, HINF FAR * lphInf);
RETERR  WINAPI IpOpenEx(LPCSTR pszFileSpec, HINF FAR * lphInf, UINT InfType);
RETERR  WINAPI IpOpenAppend(LPCSTR pszFileSpec, HINF hInf);
RETERR  WINAPI IpOpenAppendEx(LPCSTR pszFileSpec, HINF hInf, UINT InfType);
RETERR  WINAPI IpSaveRestorePosition(HINF hInf, BOOL bSave);
RETERR  WINAPI IpClose(HINF hInf);
RETERR  WINAPI IpGetLineCount(HINF hInf, LPCSTR lpszSection, int FAR * lpCount);
RETERR  WINAPI IpFindFirstLine(HINF hInf, LPCSTR lpszSect, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextLine(HINF hInf, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextMatchLine(HINF hInf, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpGetProfileString(HINF hInf, LPCSTR lpszSec, LPCSTR lpszKey, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetFieldCount(HINF hInf, HINFLINE hInfLine, int FAR * lpCount);
RETERR  WINAPI IpGetFileName(HINF hInf, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetIntField(HINF hInf, HINFLINE hInfLine, int iField, int FAR * lpVal);
RETERR  WINAPI IpGetLongField(HINF hInf, HINFLINE hInfLine, int iField, long FAR * lpVal);
RETERR  WINAPI IpGetStringField(HINF hInf, HINFLINE hInfLine, int iField, LPSTR lpBuf, int iBufSize, int FAR * lpuCount);
RETERR  WINAPI IpGetVersionString(LPSTR lpszInfFile, LPSTR lpszValue, LPSTR lpszBuf, int cbBuf, LPSTR lpszDefaultValue);

#endif // NOINF



#ifndef NOTEXTPROC
/***************************************************************************/
//
// Text processing API declaration and definitions
//
/***************************************************************************/

/* Relative/absolute positioning */
#define SEC_SET 1       // Absolute positioning (relative to the start)
#define SEC_END 2       // Realtive to the end
#define SEC_CUR 3       // Relative to the current line.

#define SEC_OPENALWAYS          1   // Always open a section, no error if it does not exist
#define SEC_OPENEXISTING        2   // Open an existing section, an error given if it does not exist.
#define SEC_OPENNEWALWAYS       3   // Open a section (present or not) and discard its contents.
#define SEC_OPENNEWEXISTING     4   // Open an existing section (discarding its contents). Error if not existing

// Flags for TP_OpenFile().
//
  // Use autoexec/config.sys key delimiters
  //
#define TP_WS_KEEP      1

  // If TP code running under SETUP, the foll. flag specifies whether
  // to cache this file or not! Use this, if you want to read a whole
  // file in when doing the TpOpenSection()!
  //
#define TP_WS_DONTCACHE 2

// The following are simple errors
enum {
    ERR_TP_NOT_FOUND = (TP_ERROR + 1),  // line, section, file etc.
                    // not necessarily terminal
    ERR_TP_NO_MEM,      // couldn't perform request - generally terminal
    ERR_TP_READ,        // could not read the disc - terminal
    ERR_TP_WRITE,       // could not write the data - terminal.
    ERR_TP_INVALID_REQUEST, // Multitude of sins - not necessarily terminal.
    ERR_TP_INVALID_LINE         // Invalid line from DELETE_LINE etc.
};

/* Data handles */
DECLARE_HANDLE(HTP);
typedef HTP FAR * LPHTP;

/* File handles */
DECLARE_HANDLE(HFN);
typedef HFN FAR * LPHFN;

typedef UINT TFLAG;
typedef UINT LINENUM, FAR * LPLINENUM;

#define MAX_REGPATH     256     // Max Registry Path Length
#define LINE_LEN        256     // BUGBUG: max line length?
#define SECTION_LEN     32      // BUGBUG: max length of a section name?
#define MAX_STRING_LEN  512     // BUGBUG: review this

/* Function prototypes */
RETERR  WINAPI TpOpenFile(LPCSTR Filename, LPHFN phFile, TFLAG Flag);
RETERR  WINAPI TpCloseFile(HFN hFile);
RETERR  WINAPI TpOpenSection(HFN hfile, LPHTP phSection, LPCSTR Section, TFLAG flag);
RETERR  WINAPI TpCloseSection(HTP Section);
RETERR  WINAPI TpCommitSection(HFN hFile, HTP hSection, LPCSTR Section, TFLAG flag);
LINENUM WINAPI TpGetLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, LPLINENUM lpLineNum );
LINENUM WINAPI TpGetNextLine(HTP hSection, LPCSTR key, LPCSTR value, LPLINENUM lpLineNum );
RETERR  WINAPI TpInsertLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpReplaceLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpDeleteLine(HTP hSection, int rel, int orig,TFLAG flag);
RETERR  WINAPI TpMoveLine(HTP hSection, int src_rel, int src_orig, int dest_rel, int dest_orig, TFLAG flag);
RETERR  WINAPI TpGetLineContents(HTP hSection, LPSTR buffer, UINT bufsize, UINT FAR * lpActualSize,int rel, int orig, TFLAG flag);

// UINT    WINAPI TpGetWindowsDirectory(LPSTR lpDest, UINT size);
// UINT    WINAPI TpGetSystemDirectory(LPSTR lpDest, UINT size);

int  WINAPI TpGetPrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize, LPCSTR lpszFile);
int  WINAPI TpWritePrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszString, LPCSTR lpszFile);
int  WINAPI TpGetProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize);
BOOL WINAPI TpWriteProfileString(LPCSTR lpszSect , LPCSTR lpszKey , LPCSTR lpszString);

#endif // NOTEXTPROC



#ifndef NOGENINSTALL
/***************************************************************************/
//
// Generic Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_GENERIC
{
    ERR_GEN_LOW_MEM = GEN_ERROR+1,  // Insufficient memory.
    ERR_GEN_INVALID_FILE,           // Invalid INF file.
    ERR_GEN_LOGCONFIG,              // Can't process LogConfig=.
    ERR_GEN_CFGAUTO,                // Can't process CONFIG.SYS/AUTOEXEC.BAT
    ERR_GEN_UPDINI,                 // Can't process UpdateInis=.
    ERR_GEN_UPDINIFIELDS,           // Can't process UpdateIniFields=.
    ERR_GEN_ADDREG,                 // Can't process AddReg=.
    ERR_GEN_DELREG,                 // Can't process DelReg=.
    ERR_GEN_INI2REG,                // Can't process Ini2Reg=.
    ERR_GEN_FILE_COPY,              // Can't process CopyFiles=.
    ERR_GEN_FILE_DEL,               // Can't process DelFiles=.
    ERR_GEN_FILE_REN,               // Can't process RenFiles=.
    ERR_GEN_REG_API,                // Error returned by Reg API.
    ERR_GEN_DO_FILES,               // can't do Copy, Del or RenFiles.
};

// The cbSize field will always be set to sizeof(GENCALLBACKINFO_S).
// All unused fields (for the operation) will be not be initialized.
// For example, when the operation is GENO_DELFILE, the Src fields will
// not have any sensible values (Dst fields will be set correctly) as
// VcpQueueDelete only accepts Dst parameters.
//
/***************************************************************************
 * GenCallbackINFO structure passed to GenInstall CallBack functions.
 ***************************************************************************/
typedef struct _GENCALLBACKINFO_S { /* gen-callback struc */
    WORD         cbSize;                 // Size of this structure (bytes).
    WORD         wOperation;             // Operation being performed.
    LOGDISKID    ldidSrc;                // Logical Disk ID for Source.
    LPCSTR       pszSrcSubDir;           // Source sub-dir off of the LDID.
    LPCSTR       pszSrcFileName;         // Source file name (base name).
    LOGDISKID    ldidDst;                // Logical Disk ID for Dest.
    LPCSTR       pszDstSubDir;           // Dest. sub-dir off of the LDID.
    LPCSTR       pszDstFileName;         // Dest. file name (base name).
    LPEXPANDVTBL lpExpandVtbl;           // BUGBUG needed? NULL right now!
    WORD         wflags;                 // flags for VcpQueueCopy.
    LPARAM       lParam;                 // LPARAM to the Vcp API.
} GENCALLBACKINFO_S, FAR *LPGENCALLBACKINFO;

/***************************************************************************
 * GenCallback notification codes -- callback proc returns 1 of foll. values.
 ***************************************************************************/
#define GENN_OK         0       /* All is hunky-dory. Do the VCP operation */
#define GENN_PROCEED    0       /* The same as GENN_OK */

#define GENN_ABORT      (-1)    /* Cancel current GenInstall altogether */
#define GENN_SKIP       (-2)    /* Skip this file and continue */

/***************************************************************************
 * VCP Operation being performed by GenInstall() -- wOperation values in
 * GENCALLBACKINFO structure above.
 ***************************************************************************/
#define GENO_COPYFILE   1       /* VCP copyfile being done */
#define GENO_DELFILE    2       /* VCP delfile being done */
#define GENO_RENFILE    3       /* VCP renfile being done */


typedef LRESULT (CALLBACK *GENCALLBACKPROC)(LPGENCALLBACKINFO lpGenInfo,
                                                            LPARAM lparamRef);

RETERR WINAPI GenInstall( HINF hinfFile, LPCSTR szInstallSection, WORD wFlags );
RETERR WINAPI GenInstallEx( HINF hInf, LPCSTR szInstallSection, WORD wFlags,
                                HKEY hRegKey, GENCALLBACKPROC CallbackProc,
                                LPARAM lparam);
RETERR WINAPI GenWinInitRename(LPCSTR szNew, LPSTR szOld, LOGDISKID ldid);
RETERR WINAPI GenCopyLogConfig2Reg(HINF hInf, HKEY hRegKey,
                                                LPCSTR szLogConfigSection);
void   WINAPI GenFormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc,
                                                                HINF hInf ) ;

// A devnode is just a DWORD and this is easier than
// having to include configmg.h for everybody
RETERR WINAPI GenInfLCToDevNode(ATOM atInfFileName, LPSTR lpszSectionName,
                                BOOL bInstallSec, UINT InfType, 
                                DWORD dnDevNode);

// Bit fields for GenInstall() (for wFlags parameter) -- these can be OR-ed!
#define GENINSTALL_DO_FILES     1
#define GENINSTALL_DO_INI       2
#define GENINSTALL_DO_REG       4
#define GENINSTALL_DO_INI2REG   8
#define GENINSTALL_DO_CFGAUTO   16
#define GENINSTALL_DO_LOGCONFIG 32
#define GENINSTALL_DO_INIREG    (GENINSTALL_DO_INI | \
                                 GENINSTALL_DO_REG | \
                                 GENINSTALL_DO_INI2REG)
#define GENINSTALL_DO_ALL       (GENINSTALL_DO_FILES | \
                                    GENINSTALL_DO_INIREG | \
                                    GENINSTALL_DO_CFGAUTO | \
                                    GENINSTALL_DO_LOGCONFIG)

#endif // NOGENINSTALL



#ifndef NODEVICENSTALL
/***************************************************************************/
//
// Device Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_DEVICE_INSTALL
{
    ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    // Incorrectly formed device IDF
    ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  // Invalid compatible device list
    ERR_DI_REG_API,                         // Error returned by Reg API.
    ERR_DI_LOW_MEM,                         // Insufficient memory to complete
    ERR_DI_BAD_DEV_INFO,                    // Device Info struct invalid
    ERR_DI_INVALID_CLASS_INSTALLER,         // Registry entry / DLL invalid
    ERR_DI_DO_DEFAULT,                      // Take default action
    ERR_DI_USER_CANCEL,                     // the user cancelled the operation
    ERR_DI_NOFILECOPY,                      // No need to copy files (in install)
    ERR_DI_BAD_CLASS_INFO,                  // Class Info Struct invalid
    ERR_DI_BAD_INF,                         //  Bad INF file encountered
    ERR_DI_BAD_MOVEDEV_PARAMS,	            // Bad Move Device Params struct
    ERR_DI_NO_INF,		                    // No INF found on OEM disk
    ERR_DI_BAD_PROPCHANGE_PARAMS,           // Bad property change param struct
    ERR_DI_BAD_SELECTDEVICE_PARAMS,          // Bad Select Device Parameters
    ERR_DI_BAD_REMOVEDEVICE_PARAMS          // Bad Remove Device Parameters
};



typedef struct _DRIVER_NODE {
    struct _DRIVER_NODE FAR* lpNextDN;
    UINT    Rank;
    UINT    InfType;
    unsigned    InfDate;
    LPSTR   lpszDescription;        // Compatibility: Contains the Device Desc.
    LPSTR   lpszSectionName;
    ATOM    atInfFileName;
    ATOM    atMfgName;
    ATOM    atProviderName;
    DWORD   Flags;
    DWORD   dwPrivateData;
    LPSTR   lpszDrvDescription;     // New contains an driver description
    LPSTR   lpszHardwareID;
    LPSTR   lpszCompatIDs;
}   DRIVER_NODE, NEAR* PDRIVER_NODE, FAR* LPDRIVER_NODE, FAR* FAR* LPLPDRIVER_NODE;

#define DNF_DUPDESC    0x00000001   // Multiple providers have same desc
#define DNF_OLDDRIVER  0x00000002   // Driver node specifies old/current driver

// possible types of "INF" files
#define INFTYPE_WIN4        1
#define INFTYPE_WIN3        2
#define INFTYPE_COMBIDRV    3
#define INFTYPE_PPD         4
#define INFTYPE_WPD     5
#define INFTYPE_CLASS_SPEC1 6
#define INFTYPE_CLASS_SPEC2 7
#define INFTYPE_CLASS_SPEC3 8
#define INFTYPE_CLASS_SPEC4 9


#define MAX_CLASS_NAME_LEN   32
#define MAX_DRIVER_INST_LEN  10

// NOTE:  Keep this in sync with confimg.h in \DDK\INC
#define MAX_DEVNODE_ID_LEN  256

typedef struct _DEVICE_INFO
{
    UINT        cbSize;
    struct _DEVICE_INFO FAR* lpNextDi;
    char                szDescription[LINE_LEN];
    DWORD       dnDevnode;
    HKEY        hRegKey;
    char        szRegSubkey[MAX_DEVNODE_ID_LEN]; 
    char        szClassName[MAX_CLASS_NAME_LEN];
    DWORD       Flags;
    HWND        hwndParent;
    LPDRIVER_NODE   lpCompatDrvList;
    LPDRIVER_NODE   lpClassDrvList;
    LPDRIVER_NODE   lpSelectedDriver;
    ATOM    atDriverPath;
    ATOM    atTempInfFile;
    HINSTANCE   hinstClassInstaller;            // The Class Installer module
    HINSTANCE   hinstClassPropProvidor;         // The Class Property Providor
    HINSTANCE   hinstDevicePropProvidor;        // The Device Property Providor
    HINSTANCE   hinstBasicPropProvidor;         // The Basic Property Providor hinst
    FARPROC     fpClassInstaller;               // ClassInstall entry point
    FARPROC     fpClassEnumPropPages;           // Class EnumPropPages entry point
    FARPROC     fpDeviceEnumPropPages;          // Device EnumPropPages entry point
    FARPROC     fpEnumBasicProperties;          // Basic Property Page enum entry
    DWORD       dwSetupReserved;                // Reserved for SETUP's use
    DWORD       dwClassInstallReserved;         // Reserved for Class Installer use
    GENCALLBACKPROC gicpGenInstallCallBack;     // Set by Caller of DiInstallDevice if 
                                                // they want GenInstall callbacks
    LPARAM          gicplParam;                 // lParam for GenInstall Callback                                                
    UINT            InfType;                    // The type of INF file it ENUMSINGLEINF is
                                                // specified
    HINSTANCE   hinstPrivateProblemHandler;     // The Private Problem DLL for a Specific Device
    FARPROC     fpPrivateProblemHandler;        // The Private Problem Handler entry point
    LPARAM      lpClassInstallParams;           // Class Install functions specific Parameters
    struct _DEVICE_INFO FAR* lpdiChildList;     // Pointer to children Device Info list.
} DEVICE_INFO, FAR * LPDEVICE_INFO, FAR * FAR * LPLPDEVICE_INFO;

#define ASSERT_DI_STRUC(lpdi) if (lpdi->cbSize != sizeof(DEVICE_INFO)) return (ERR_DI_BAD_DEV_INFO)

typedef struct _CLASS_INFO
{
    UINT        cbSize;
    struct _CLASS_INFO FAR* lpNextCi;
    LPDEVICE_INFO   lpdi;
    char                szDescription[LINE_LEN];
    char        szClassName[MAX_CLASS_NAME_LEN];
} CLASS_INFO, FAR * LPCLASS_INFO, FAR * FAR * LPLPCLASS_INFO;
#define ASSERT_CI_STRUC(lpci) if (lpci->cbSize != sizeof(CLASS_INFO)) return (ERR_DI_BAD_CLASS_INFO)


// flags for device choosing (InFlags)
#define DI_SHOWOEM                  0x00000001L     // support Other... button
#define DI_SHOWCOMPAT               0x00000002L     // show compatibility list
#define DI_SHOWCLASS                0x00000004L     // show class list
#define DI_SHOWALL                  0x00000007L
#define DI_NOVCP                    0x00000008L     // Don't do vcpOpen/vcpClose.
#define DI_DIDCOMPAT                0x00000010L     // Searched for compatible devices
#define DI_DIDCLASS                 0x00000020L     // Searched for class devices
#define DI_AUTOASSIGNRES            0x00000040L    // No UI for resources if possible

// flags returned by DiInstallDevice to indicate need to reboot/restart
#define DI_NEEDRESTART              0x00000080L     // Restart required to take effect
#define DI_NEEDREBOOT               0x00000100L     // Reboot required to take effect

// flags for device installation
#define DI_NOBROWSE                 0x00000200L     // no Browse... in InsertDisk

// Flags set by DiBuildClassDrvList
#define DI_MULTMFGS                 0x00000400L     // Set if multiple manufacturers in
                                                    // class driver list
// Flag indicates that device is disabled
#define DI_DISABLED                 0x00000800L     // Set if device disabled

// Flags for Device/Class Properties
#define DI_GENERALPAGE_ADDED        0x00001000L
#define DI_RESOURCEPAGE_ADDED       0x00002000L

// Flag to indicate the setting properties for this Device (or class) caused a change
// so the Dev Mgr UI probably needs to be updatd.
#define DI_PROPERTIES_CHANGE        0x00004000L

// Flag to indicate that the sorting from the INF file should be used.
#define DI_INF_IS_SORTED            0x00008000L

#define DI_ENUMSINGLEINF            0x00010000L

// The following flags can be used to install a device disabled
// and to prevent CONFIGMG being called when a device is installed
#define DI_DONOTCALLCONFIGMG        0x00020000L
#define DI_INSTALLDISABLED          0x00040000L

// This flag is set of this LPDI is really just an LPCI, ie
// it only contains class info, NO DRIVER/DEVICE INFO
#define DI_CLASSONLY                0x00080000L

// This flag is set if the Class Install params are valid
#define DI_CLASSINSTALLPARAMS       0x00100000L

// This flag is set if the caller of DiCallClassInstaller does NOT
// want the internal default action performed if the Class installer
// return ERR_DI_DO_DEFAULT
#define DI_NODI_DEFAULTACTION       0x00200000L

// BUGBUG. This is a hack for M6 Net setup.  Net Setup does not work correctly
// if we process devnode syncronously.  This WILL be removed for M7 when
// Net setup is fixed to work with DiInstallDevice
#define DI_NOSYNCPROCESSING         0x00400000L

// flags for device installation
#define DI_QUIETINSTALL             0x00800000L     // don't confuse the user with
                                                    // questions or excess info
#define DI_NOFILECOPY               0x01000000L     // No file Copy necessary
#define DI_FORCECOPY                0x02000000L     // Force files to be copied from install path
#define DI_DRIVERPAGE_ADDED         0x04000000L     // Prop providor added Driver page.
#define DI_USECI_SELECTSTRINGS      0x08000000L     // Use Class Installer Provided strings in the Select Device Dlg
#define DI_OVERRIDE_INFFLAGS        0x10000000L     // Override INF flags
#define DI_PROPS_NOCHANGEUSAGE      0x20000000L     // No Enable/Disable in General Props

#define DI_NOSELECTICONS	    0x40000000L     // No small icons in select device dialogs

#define DI_NOWRITE_IDS		    0x80000000L     // Don't write HW & Compat IDs on install


// Defines for class installer functions
#define DIF_SELECTDEVICE            0x0001
#define DIF_INSTALLDEVICE           0x0002
#define DIF_ASSIGNRESOURCES         0x0003
#define DIF_PROPERTIES              0x0004
#define DIF_REMOVE                  0x0005
#define DIF_FIRSTTIMESETUP          0x0006
#define DIF_FOUNDDEVICE             0x0007
#define DIF_SELECTCLASSDRIVERS      0x0008
#define DIF_VALIDATECLASSDRIVERS    0x0009
#define DIF_INSTALLCLASSDRIVERS     0x000A
#define DIF_CALCDISKSPACE           0x000B
#define DIF_DESTROYPRIVATEDATA      0x000C
#define DIF_VALIDATEDRIVER          0x000D
#define DIF_MOVEDEVICE              0x000E
#define DIF_DETECT                  0x000F
#define DIF_INSTALLWIZARD           0x0010
#define DIF_DESTROYWIZARDDATA       0x0011
#define DIF_PROPERTYCHANGE          0x0012

typedef UINT        DI_FUNCTION;    // Function type for device installer

// DIF_MOVEDEVICE parameter struct.
typedef struct _MOVEDEV_PARAMS
{
    UINT            cbSize;
    LPDEVICE_INFO   lpdiOldDev;     // References the Device Begin Moved
} MOVEDEV_PARAMS, FAR * LPMOVEDEV_PARAMS;
#define ASSERT_MOVEDEVPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(MOVEDEV_PARAMS)) return (ERR_DI_BAD_MOVEDEV_PARAMS)

// DIF_PROPCHANGE parameter struct.
typedef struct _PROPCHANGE_PARAMS
{
    UINT            cbSize;
    DWORD           dwStateChange;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} PROPCHANGE_PARAMS, FAR * LPPROPCHANGE_PARAMS;
#define ASSERT_PROPCHANGEPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(PROPCHANGE_PARAMS)) return (ERR_DI_BAD_PROPCHANGE_PARAMS)

#define MAX_TITLE_LEN           30
#define MAX_INSTRUCTION_LEN     256
#define MAX_LABEL_LEN           30
// DIF_SELECTDEVICE parameter struct.
typedef struct _SELECTDEVICE_PARAMS
{
    UINT            cbSize;
    char            szTitle[MAX_TITLE_LEN];
    char            szInstructions[MAX_INSTRUCTION_LEN];
    char            szListLabel[MAX_LABEL_LEN];
} SELECTDEVICE_PARAMS, FAR * LPSELECTDEVICE_PARAMS;
#define ASSERT_SELECTDEVICEPARAMS_STRUC(p) if (p->cbSize != sizeof(SELECTDEVICE_PARAMS)) return (ERR_DI_BAD_SELECTDEVICE_PARAMS)

#define DI_REMOVEDEVICE_GLOBAL                  0x00000001
#define DI_REMOVEDEVICE_CONFIGSPECIFIC          0x00000002
typedef struct _REMOVEDEVICE_PARAMS
{
    UINT            cbSize;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} REMOVEDEVICE_PARAMS, FAR * LPREMOVEDEVICE_PARAMS;
#define ASSERT_REMOVEDPARAMS_STRUC(p) if (p->cbSize != sizeof(REMOVEDEVICE_PARAMS)) return (ERR_DI_BAD_REMOVEDEVICE_PARAMS)

// DIF_INSTALLWIZARD  Wizard Data
#define MAX_INSTALLWIZARD_DYNAPAGES             20

// Use this ID for the first page that the install wizard should dynamically jump to.
#define IDD_DYNAWIZ_FIRSTPAGE                   10000

// Use this ID for the page that the Select Device dialog should go back to
#define IDD_DYNAWIZ_SELECT_PREVPAGE             10001

// Use this ID for the page that the Select Device dialog should go to next
#define IDD_DYNAWIZ_SELECT_NEXTPAGE             10002
               
// Use this ID for the page that the Analyze dialog should go back to
// This will only be used in the event that there is a problem, and the user
// selects Back from the analyze proc.
#define IDD_DYNAWIZ_ANALYZE_PREVPAGE            10003

// Use this ID for the page that the Analyze dialog should go to if it continue from
// the analyze proc.  the wAnalyzeResult in the INSTALLDATA struct will
// contain the anaysis results.
#define IDD_DYNAWIZ_ANALYZE_NEXTPAGE            10004

// This dialog will be selected if the user chooses back from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE    10006

// This dialog will be selected if the user chooses Next from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE    10007

// This is the ID of the dialog to select if detection does not
// find any new devices
#define IDD_DYNAWIZ_INSTALLDETECTED_NODEVS      10008
   
// This is the ID of the Select Device Wizard page.
#define IDD_DYNAWIZ_SELECTDEV_PAGE              10009

// This is the ID of the Analyze Device Wizard page.
#define IDD_DYNAWIZ_ANALYZEDEV_PAGE             10010

// This is the ID of the Install Detected Devs Wizard page.
#define IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE    10011

// This is the ID of the Select Class Wizard page.
#define IDD_DYNAWIZ_SELECTCLASS_PAGE            10012

// This flag is set if a Class installer has added pages to the
// install wizard.
#define DYNAWIZ_FLAG_PAGESADDED             0x00000001

// The following flags will control the button states when displaying
// the InstallDetectedDevs dialog.  
#define DYNAWIZ_FLAG_INSTALLDET_NEXT        0x00000002
#define DYNAWIZ_FLAG_INSTALLDET_PREV        0x00000004

// Set this flag if you jump to the analyze page, and want it to
// handle conflicts for you.  NOTE.  You will not get control back 
// in the event of a conflict if you set this flag.
#define DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT 0x00000008

#define ANALYZE_FACTDEF_OK      1
#define ANALYZE_STDCFG_OK       2
#define ANALYZE_CONFLICT        3
#define ANALYZE_NORESOURCES     4
#define ANALYZE_ERROR           5
#define ANALYZE_PNP_DEV         6


typedef struct InstallWizardData_tag        
{
    UINT            cbSize;
    
    LPDEVICE_INFO   lpdiOriginal;
    LPDEVICE_INFO   lpdiSelected;
    DWORD           dwFlags;
    LPVOID          lpConfigData;
    WORD            wAnalyzeResult;
        
    // The following fields are used when a Class Installer Extends the Install Wizard
    HPROPSHEETPAGE  hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES];
    WORD            wNumDynaPages;
    DWORD           dwDynaWizFlags;
    DWORD           dwPrivateFlags;
    LPARAM          lpPrivateData;
    LPSTR           lpExtraRunDllParams;    
} INSTALLWIZDATA, * PINSTALLWIZDATA , FAR *LPINSTALLWIZDATA;

RETERR WINAPI DiCreateDeviceInfo(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszDescription,    // If non-null then description string
    DWORD       hDevnode,       // BUGBUG -- MAKE A DEVNODE
    HKEY        hkey,       // Registry hkey for dev info
    LPCSTR      lpszRegsubkey,  // If non-null then reg subkey string
    LPCSTR      lpszClassName,  // If non-null then class name string
    HWND        hwndParent);    // If non-null then hwnd of parent

RETERR WINAPI DiGetClassDevs(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options

RETERR WINAPI DiGetClassDevsEx(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    LPCSTR      lpszEnumerator, // Must be name of enumerator, or NULL
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options
    
#define DIGCF_DEFAULT           0x0001  // NOT IMPLEMENTED!
#define DIGCF_PRESENT           0x0002
#define DIGCF_ALLCLASSES        0x0004
#define DIGCF_PROFILE           0x0008

// API to return the Class name of an INF File
RETERR WINAPI DiGetINFClass(LPSTR lpszMWDPath, UINT InfType, LPSTR lpszClassName, DWORD dwcbClassName);

RETERR WINAPI PASCAL DiCreateDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    HINF        hinf,
    LPCSTR      lpszInfSection,
    int         iFlags);
    
RETERR WINAPI PASCAL DiDeleteDevRegKey(LPDEVICE_INFO lpdi, int  iFlags);


RETERR WINAPI PASCAL DiOpenDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    int         iFlags);

#define DIREG_DEV	0x0001		// Open/Create/Delete device key
#define DIREG_DRV	0x0002		// Open/Create/Delete driver key
#define DIREG_BOTH	0x0004		// Delete both driver and Device key

RETERR WINAPI DiReadRegLogConf
(
    LPDEVICE_INFO       lpdi,
    LPSTR               lpszConfigName,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize
);

RETERR WINAPI DiReadRegConf
(
    LPDEVICE_INFO       lpdi,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize,
    DWORD               dwFlags
);

#define DIREGLC_FORCEDCONFIG        0x00000001
#define DIREGLC_BOOTCONFIG          0x00000002

RETERR WINAPI DiCopyRegSubKeyValue
(
    HKEY    hkKey,
    LPSTR   lpszFromSubKey,
    LPSTR   lpszToSubKey,
    LPSTR   lpszValueToCopy
);

RETERR WINAPI DiDestroyClassInfoList(LPCLASS_INFO lpci);
RETERR WINAPI DiBuildClassInfoList(LPLPCLASS_INFO lplpci);

#define DIBCI_NOINSTALLCLASS        0x000000001
#define DIBCI_NODISPLAYCLASS        0x000000002

RETERR WINAPI DiBuildClassInfoListEx(LPLPCLASS_INFO lplpci, DWORD dwFlags);
RETERR WINAPI DiGetDeviceClassInfo(LPLPCLASS_INFO lplpci, LPDEVICE_INFO lpdi);

RETERR WINAPI DiDestroyDeviceInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiSelectDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiSelectOEMDrv(HWND hDlg, LPDEVICE_INFO lpdi);

// Callback for diInstallDevice vcpOpen.  Basically calls vcpUICallback for everthing
// except when DI_FORCECOPY is active, in which case copies get defaulted to
// VCPN_FORCE
LRESULT CALLBACK diInstallDeviceUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);
RETERR WINAPI DiInstallDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiInstallDriverFiles(LPDEVICE_INFO lpdi);

RETERR WINAPI DiRemoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAssignResources( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAskForOEMDisk(LPDEVICE_INFO lpdi);

RETERR WINAPI DiCallClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);

RETERR WINAPI DiBuildCompatDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvList(LPDEVICE_INFO lpdi);

typedef RETERR (CALLBACK *OLDINFPROC)(HINF hinf, LPCSTR lpszNewInf, LPARAM lParam);
RETERR WINAPI DiBuildClassDrvListFromOldInf(LPDEVICE_INFO lpdi, LPCSTR lpszSection, OLDINFPROC lpfnOldInfProc, LPARAM lParam);

RETERR WINAPI DiDestroyDriverNodeList(LPDRIVER_NODE lpdn);

RETERR  WINAPI  DiMoveDuplicateDevNode(LPDEVICE_INFO lpdiNewDev);

// The following export will load a dll and find the specified proc name
typedef RETERR (FAR PASCAL *DIINSTALLERPROPERTIES)(LPDEVICE_INFO);

RETERR WINAPI GetFctn(HKEY hk, LPSTR lpszRegVal, LPSTR lpszDefProcName,
                      HINSTANCE FAR * lphinst, FARPROC FAR *lplpfn);
                        
RETERR
WINAPI
DiCreateDriverNode(
    LPLPDRIVER_NODE lplpdn,
    UINT    Rank,
    UINT    InfType,
    unsigned    InfDate,
    LPCSTR  lpszDevDescription,
    LPCSTR  lpszDrvDescription,
    LPCSTR  lpszProviderName,
    LPCSTR  lpszMfgName,
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSectionName,
    DWORD   dwPrivateData);


RETERR WINAPI DiLoadClassIcon(
    LPCSTR  szClassName,
    HICON FAR *lphiLargeIcon,
    int FAR *lpiMiniIconIndex);


RETERR WINAPI DiInstallDrvSection(
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSection,
    LPCSTR  lpszClassName,
    LPCSTR  lpszDescription,
    DWORD   dwFlags);


RETERR WINAPI DiChangeState(LPDEVICE_INFO lpdi, DWORD dwStateChange, DWORD dwFlags, LPARAM lParam);

#define DICS_ENABLE                 0x00000001
#define DICS_DISABLE                0x00000002
#define DICS_PROPCHANGE             0x00000003

#define DICS_FLAG_GLOBAL            0x00000001
#define DICS_FLAG_CONFIGSPECIFIC    0x00000002

RETERR WINAPI DiInstallClass(LPCSTR lpszInfFileName, DWORD dwFlags);

RETERR WINAPI DiOpenClassRegKey(LPHKEY lphk, LPCSTR lpszClassName);

// support routine for dealing with class mini icons
int WINAPI PASCAL DiDrawMiniIcon(HDC hdc, RECT rcLine, int iMiniIcon, UINT flags);
BOOL WINAPI DiGetClassBitmapIndex(LPCSTR lpszClass, int FAR *lpiMiniIconIndex);

// internal calls for display class
#define DISPLAY_SETMODE_SUCCESS     0x0001
#define DISPLAY_SETMODE_DRVCHANGE   0x0002
#define DISPLAY_SETMODE_FONTCHANGE  0x0004

UINT WINAPI Display_SetMode(LPDEVICE_INFO lpdi, UINT uColorRes, int iXRes, int iYRes);
RETERR WINAPI Display_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
RETERR WINAPI Display_OpenFontSizeKey(LPHKEY lphkFontSize);
BOOL WINAPI Display_SetFontSize(LPCSTR lpszFontSize);

RETERR WINAPI DiIsThereNeedToCopy(HWND hwnd, DWORD dwFlags);

#define DINTC_NOCOPYDEFAULT	    0x00000001

// API for the mouse class installer
RETERR WINAPI Mouse_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
#endif // NODEVICEINSTALL

// API for determining if a Driver file is currently part of VMM32.VxD
BOOL WINAPI bIsFileInVMM32
(
    LPSTR   lpszFileName
);


/***************************************************************************/
//
// setup reg DB calls, use just like those in kernel
//
/***************************************************************************/

DWORD WINAPI SURegOpenKey(HKEY hKey, LPSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegCloseKey(HKEY hKey);
DWORD WINAPI SURegCreateKey(HKEY hKey, LPSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegDeleteKey(HKEY hKey, LPSTR lpszSubKey);
DWORD WINAPI SURegEnumKey(HKEY hKey, DWORD dwIdx, LPSTR lpszBuffer, DWORD dwBufSize);
DWORD WINAPI SURegQueryValue16(HKEY hKey, LPSTR lpszSubKey, LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValue16(HKEY hKey, LPSTR lpszSubKey, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegDeleteValue(HKEY hKey,LPSTR lpszValue);
DWORD WINAPI SURegEnumValue(HKEY hKey,DWORD dwIdx, LPSTR lpszValue, DWORD FAR *lpcbValue, DWORD FAR *lpdwReserved, DWORD FAR *lpdwType, LPBYTE lpbData, DWORD FAR *lpcbData);
DWORD WINAPI SURegQueryValueEx(HKEY hKey,LPSTR lpszValueName, DWORD FAR *lpdwReserved,DWORD FAR *lpdwType,LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValueEx(HKEY hKey,LPSTR lpszValueName, DWORD dwReserved, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegSaveKey(HKEY hKey, LPCSTR lpszFileName, LPVOID lpsa);
DWORD WINAPI SURegLoadKey(HKEY hKey, LPCSTR lpszSubKey, LPCSTR lpszFileName);
DWORD WINAPI SURegUnLoadKey(HKEY hKey, LPCSTR lpszSubKey);

DWORD WINAPI SURegFlush(VOID);
DWORD WINAPI SURegInit(VOID);    // should be called before any other Reg APIs


/***************************************************************************/
// setup FormatMessage support
/***************************************************************************/
#define MB_LOG  (UINT)-1

UINT FAR CDECL suFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    ...);
UINT WINAPI suvFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    LPVOID FAR * lpArgs);
int WINCAPI _loadds suFormatMessageBox(HINSTANCE hAppInst, HWND hwndParent, LPCSTR lpcText, LPCSTR lpcTitle,
    UINT uStyle, ...);

WORD WINAPI suErrorToIds( WORD Value, WORD Class );

/***************************************************************************/
// setup Version Conflict support
/***************************************************************************/

LPVOID WINAPI suVerConflictInit(BOOL fYesToLangMismatch);
void WINAPI suVerConflictTerm(LPVOID lpvData);
LRESULT WINAPI suVerConflict(HWND hwnd, LPVCPVERCONFLICT lpvc, LPVOID lpvData);


/***************************************************************************/
// setup Help support
/***************************************************************************/

BOOL WINAPI suHelp( HWND hwndApp, HWND hwndDlg );

//***************************************************************************/
// setup Emergency Boot Disk (EBD) creation fn.
//***************************************************************************/

RETERR WINAPI suCreateEBD( HWND hWnd, VIFPROC CopyCallbackProc, LPARAM lpuii );

//***************************************************************************
// Misc SETUPX.DLL support functions.
//***************************************************************************


RETERR WINAPI SUGetSetSetupFlags(LPDWORD lpdwFlags, BOOL bSet);

RETERR WINAPI CfgSetupMerge( int uFlags );


#ifndef LPLPSTR
    typedef LPSTR (FAR *LPLPSTR);
#endif





//***************************************************************************
//
// ENUMS for accessing config.sys/autoexec.bat line objects using the
// array returned by ParseConfigLine()..
//
//***************************************************************************

enum    CFGLINE_STRINGS                     // Config.sys/autoexec.bat objects
{
    CFG_KEYLEAD,                            // Keyword leading whitespaces
    CFG_KEYWORD,                            // Keyword
    CFG_KEYTRAIL,                           // Keyword trailing delimiters
    CFG_UMBINFO,                            // Load high info
    CFG_DRVLETTER,                          // Drive letter for cmd path
    CFG_PATH,                               // Command path
    CFG_COMMAND,                            // Command base name
    CFG_EXT,                                // Command extension including '.'
    CFG_ARGS,                               // Command arguments
    CFG_FREE,                               // Free area at end of buffer
    CFG_END
};

// DJM  This will be included soon
/*---------------------------------------------------------------------------*
 *                  SUB String Data 
 *---------------------------------------------------------------------------*/

typedef struct _SUBSTR_DATA {
    LPSTR lpFirstSubstr;
    LPSTR lpCurSubstr;
    LPSTR lpLastSubstr;
}   SUBSTR_DATA;


typedef SUBSTR_DATA*		PSUBSTR_DATA;
typedef SUBSTR_DATA NEAR*	NPSUBSTR_DATA;
typedef SUBSTR_DATA FAR*	LPSUBSTR_DATA;

BOOL WINAPI InitSubstrData(LPSUBSTR_DATA lpSubstrData, LPSTR lpStr);
BOOL WINAPI GetFirstSubstr(LPSUBSTR_DATA lpSubstrData);
BOOL WINAPI GetNextSubstr(LPSUBSTR_DATA lpSubStrData);

/*---------------------------------------------------------------------------*
 *                  Misc. Di functions
 *---------------------------------------------------------------------------*/
BOOL WINAPI DiBuildPotentialDuplicatesList
(
    LPDEVICE_INFO   lpdi, 
    LPSTR           lpDuplicateList, 
    DWORD           cbSize,
    LPDWORD         lpcbData,
    LPSTR           lpstrDupType
);

//***************************************************************************
#endif      // SETUPX_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\setup4.h ===
//**********************************************************************
//
// SETUPX.H
//
//  Copyright (c) 1993 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Chicago specific Setup and device management
// services.
//
// 12/4/93      DONALDM     Created this file to support new Chicago
//                          specific exports in SETUP4.DLL
//**********************************************************************

#ifndef SETUP4_INC
#define SETUP4_INC

#if (WINVER < 0x0400)
// Do a warning message here
#endif

#pragma warning(disable:4201)       // Non-standard extensions
#pragma warning(disable:4209)       // Non-standard extensions
#pragma warning(disable:4214)       // Non-standard extensions

#include <prsht.h>
#include <commctrl.h>              // Need this for the following functions.
RETERR WINAPI DiGetClassImageList(HIMAGELIST  FAR *lpMiniIconList);
RETERR WINAPI DiGetClassImageIndex(LPCSTR lpszClass, int FAR *lpiImageIndex);

RETERR WINAPI DiGetClassDevPropertySheets(LPDEVICE_INFO lpdi, LPPROPSHEETHEADER lppsh, WORD wFlags);

// Flags for the DiGetClassDevPropertySheets API
#define DIGCDP_FLAG_BASIC           0x0001
#define DIGCDP_FLAG_ADVANCED        0x0002

#endif  // SETUP4_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the declarations for the sorting and
*   searching routines.
*   [System V]
*
****/

#ifndef _INC_SEARCH

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 


/* function prototypes */

void * __cdecl bsearch(const void *, const void *,
    size_t, size_t, int (__cdecl *)(const void *,
    const void *));
void * __cdecl _lfind(const void *, const void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
void * __cdecl _lsearch(const void *, void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
    (const void *, const void *));

#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl lfind(const void *, const void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
void * __cdecl lsearch(const void *, void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_SEARCH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\shell.h ===
/*****************************************************************************\
*                                                                             *
* shell.h -  SHELL.DLL functions, types, and definitions		      *
*                                                                             *
* Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELL
#define _INC_SHELL

#include <commctrl.h>	// for ImageList_ and other this depends on
#include <shellapi.h>




#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//====== Ranges for WM_NOTIFY codes ==================================

// Note that these are defined to be unsigned to avoid compiler warnings
// since NMHDR.code is declared as UINT.

// NM_FIRST - NM_LAST defined in commctrl.h (0U-0U) - (OU-99U)

// LVN_FIRST - LVN_LAST defined in commctrl.h (0U-100U) - (OU-199U)

// PSN_FIRST - PSN_LAST defined in prsht.h (0U-200U) - (0U-299U)

// HDN_FIRST - HDN_LAST defined in commctrl.h (0U-300U) - (OU-399U)

// TVN_FIRST - TVN_LAST defined in commctrl.h (0U-400U) - (OU-499U)

#define RDN_FIRST       (0U-500U)
#define RDN_LAST        (0U-519U)

// TTN_FIRST - TTN_LAST defined in commctrl.h (0U-520U) - (OU-549U)

#define SEN_FIRST       (0U-550U)
#define SEN_LAST        (0U-559U)

#define EXN_FIRST       (0U-1000U)  // shell explorer/browser
#define EXN_LAST        (0U-1199U)

#define MAXPATHLEN      MAX_PATH


#ifndef FO_MOVE //these need to be kept in sync with the ones in shlobj.h

#define FO_MOVE           0x0001
#define FO_COPY           0x0002
#define FO_DELETE         0x0003
#define FO_RENAME         0x0004

#define FOF_CREATEPROGRESSDLG      1
#define FOF_CONFIRMMOUSE           2
#define FOF_SILENT                 4  // don't create progress/report
#define FOF_RENAMEONCOLLISION      8
#define FOF_NOCONFIRMATION        16  // Don't prompt the user.
#define FOF_WANTMAPPINGHANDLE     32  // Fill in SHFILEOPSTRUCT.hNameMappings
                                      // Must be freed using SHFreeNameMappings

typedef WORD FILEOP_FLAGS;

#endif // FO_MOVE

// implicit parameters are:
//      if pFrom or pTo are unqualified names the current directories are
//      taken from the global current drive/directory settings managed
//      by Get/SetCurrentDrive/Directory
//
//      the global confirmation settings
typedef struct _SHFILEOPSTRUCT
{
	HWND		hwnd;
	UINT		wFunc;
	LPCSTR		pFrom;
	LPCSTR		pTo;
	FILEOP_FLAGS	fFlags;
	BOOL		fAnyOperationsAborted;
	LPVOID		hNameMappings;
} SHFILEOPSTRUCT, FAR *LPSHFILEOPSTRUCT;

int WINAPI SHFileOperation(LPSHFILEOPSTRUCT lpFileOp);
void WINAPI SHFreeNameMappings(HANDLE hNameMappings);

typedef struct _SHNAMEMAPPING
{
    LPSTR pszOldPath;
    LPSTR pszNewPath;
    int   cchOldPath;
    int   cchNewPath;
} SHNAMEMAPPING, FAR *LPSHNAMEMAPPING;

#define SHGetNameMappingCount(_hnm) \
	DSA_GetItemCount(_hnm)
#define SHGetNameMappingPtr(_hnm, _iItem) \
	(LPSHNAMEMAPPING)DSA_GetItemPtr(_hnm, _iItem)

/* util.c */

#define Shell_Initialize()	(TRUE)
#define Shell_Terminate() 	(TRUE)

#define STRREG_SHEX             "shellex"
#ifdef WIN32
//===================================================================
// Hotkey management API's

// Set the pending hotkey for the given app,
// The next top level window to be created by the given app will be given
// this hotkey.
BOOL WINAPI SHSetPendingHotkey(LPCSTR lpszPath, WORD wHotkey);

// Check the list of pending hotkeys and change the first occurence
// of lpszFrom to lpszTo
BOOL WINAPI SHChangePendingHotkey(LPCSTR lpszFrom, LPCSTR lpszTo);

// Delete all pending hotkeys.
void WINAPI SHDeleteAllPendingHotkeys(void);

// Set the hotkey for the given instance of an app.
BOOL WINAPI SHSetHotkeyByInstance(HINSTANCE hinst, WORD wHotkey);

// Delete a pending instance.
BOOL WINAPI SHDeletePendingHotkey(LPCSTR lpszPath);

// Get a pending hotkey given a path.
WORD WINAPI SHGetPendingHotkey(LPCSTR lpszPath);
#endif




typedef struct _SHELLEXECUTEINFO
{
	DWORD cbSize;
	HWND hwnd;
	LPCSTR lpVerb;
	LPCSTR lpFile;
	LPCSTR lpParameters;
	LPCSTR lpDirectory;
	LPCSTR lpClass;
	int nShow;
	LPVOID lpReserved;
	HINSTANCE hInstApp;
} SHELLEXECUTEINFO, FAR *LPSHELLEXECUTEINFO;

BOOL WINAPI ShellExecuteEx(LPSHELLEXECUTEINFO lpExecInfo);
void WINAPI WinExecError(HWND hwnd, int error, LPCSTR lpstrFileName, LPCSTR lpstrTitle);

// Hint flags for ShellFileClass
#define SFC_UNKNOWN         0x0000
#define SFC_FILE            0x0001
#define SFC_DIRECTORY       0x0002
#define SFC_SYSTEM          0x0004
#define SFC_TYPEMASK        (SFC_FILE|SFC_DIRECTORY|SFC_SYSTEM)
#define SFC_EXIST           0x4000  // We already know that this one exists
#define SFC_FULLYQUALIFIED  0x8000  // lpFile is fully qualified path.

int WINAPI ShellFileClass(LPCSTR lpFile, UINT wFlags,
        LPSTR lpszClassName, UINT cbClassName);
#define EIRESID(x) (-1 * (int)(x))
UINT WINAPI ExtractIconEx(LPCSTR lpszFile, int nIconIndex,
        HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons);

// Tray notification definitions
typedef struct _NOTIFYICONDATA
{
	DWORD cbSize;
	HWND hWnd;
	UINT uID;

	UINT uFlags;
	UINT uCallbackMessage;
	HICON hIcon;
	char szTip[64];
} NOTIFYICONDATA, *PNOTIFYICONDATA;




#define NIM_ADD		0x00000000
#define NIM_MODIFY	0x00000001
#define NIM_DELETE	0x00000002

#define NIF_MESSAGE	0x00000001
#define NIF_ICON	0x00000002
#define NIF_TIP		0x00000004

BOOL WINAPI Shell_NotifyIcon(DWORD dwMessage, PNOTIFYICONDATA lpData);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  // !_INC_SHELL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\shellapi.h ===
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

DECLARE_HANDLE(HDROP);

#ifdef WIN32
#ifdef UNICODE
#define ShellExecute ShellExecuteW
#define FindExecutable FindExecutableW
#define ShellAbout ShellAboutW
#define ExtractAssociatedIcon ExtractAssociatedIconW
#define ExtractIcon ExtractIconW
#define DragQueryFile DragQueryFileW
#define InternalExtractIcon InternalExtractIconW
#define DoEnvironmentSubst DoEnvironmentSubstW
#define FindEnvironmentString FindEnvironmentStringW
#else
#define ShellExecute ShellExecuteA
#define FindExecutable FindExecutableA
#define ShellAbout ShellAboutA
#define ExtractAssociatedIcon ExtractAssociatedIconA
#define ExtractIcon ExtractIconA
#define DragQueryFile DragQueryFileA
#define InternalExtractIcon InternalExtractIconA
#define DoEnvironmentSubst DoEnvironmentSubstA
#define FindEnvironmentString FindEnvironmentStringA
#endif  // UNICODE
#endif  // WIN32

UINT  WINAPI DragQueryFile(HDROP, UINT, LPSTR, UINT);
BOOL  WINAPI DragQueryPoint(HDROP, POINT FAR*);
void  WINAPI DragFinish(HDROP);
void  WINAPI DragAcceptFiles(HWND, BOOL);

#ifdef WIN32

typedef struct _DRAGINFO {
    UINT  uSize;			/* init with sizeof(DRAGINFO) */
    POINT pt;
    BOOL  fNC;
    LPSTR lpFileList;
    DWORD grfKeyState;
} DRAGINFO, FAR* LPDRAGINFO;

BOOL WINAPI DragQueryInfo(HDROP, LPDRAGINFO);	/* get extra info about a drop */



// AppBar stuff
#define ABM_NEW           0x00000000
#define ABM_REMOVE        0x00000001
#define ABM_QUERYPOS      0x00000002
#define ABM_SETPOS        0x00000003
#define ABM_GETSTATE      0x00000004
#define ABM_GETTASKBARPOS 0x00000005

// these are put in the wparam of callback messages 
#define ABN_STATECHANGE    0x0000000
#define ABN_POSCHANGED     0x0000001
#define ABN_FULLSCREENAPP  0x0000002
#define ABN_WINDOWARRANGE  0x0000003 // lParam == TRUE means hide

// flags for get state
#define ABS_AUTOHIDE    0x0000001
#define ABS_ALWAYSONTOP 0x0000002

#define ABE_LEFT        0
#define ABE_TOP         1
#define ABE_RIGHT       2
#define ABE_BOTTOM      3

typedef struct _AppBarData
{
    DWORD cbSize;
    HWND hWnd;
    UINT uCallbackMessage;
    UINT uEdge;
    RECT rc;
} APPBARDATA, *PAPPBARDATA;

UINT WINAPI SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pData);
    

#endif


HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCSTR lpszFile, UINT nIconIndex);


/* ShellExecute() and ShellExecuteEx() error codes */

/* regular WinExec() codes */
#define SE_ERR_FNF              2	// file not found
#define SE_ERR_PNF              3	// path not found
#define SE_ERR_OOM              8	// out of memory

/* values beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE  27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31
#define SE_ERR_DLLNOTFOUND      32

HINSTANCE WINAPI FindExecutable(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);	
HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, int iShowCmd);

int     WINAPI ShellAbout(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon);
DWORD   WINAPI DoEnvironmentSubst(LPSTR szString, UINT cbString);                                  
LPSTR 	WINAPI FindEnvironmentString(LPSTR szEnvVar);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\shlguid.h ===
#include "..\inc\shlguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\skbapi.h ===
/*****************************************************************************\
*                                                                             *
* skbapi.h -    Screen Keyboard Public Header File
*                                                                             *
*               
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWS
#include <windows.h>    /* windows.h must be preincluded */
#endif /* _INC_WINDOWS */

#ifndef _INC_SKBAPI     /* prevent multiple includes */
#define _INC_SKBAPI

/****** Screen Keyboard *****************************************************/

#ifndef WM_SKB                 /* also defined in penwin.h */
#define WM_SKB                 (WM_PENWINFIRST+4)
#endif

/*	wCommand values */
#define SKB_QUERY              0x0000
#define SKB_SHOW               0x0001
#define SKB_HIDE               0x0002
#define SKB_CENTER             0x0010
#define SKB_MOVE               0x0020
#define SKB_MINIMIZE           0x0040

/* wPad values */
#define SKB_FULL               0x0100
#define SKB_BASIC              0x0200
#define SKB_NUMPAD             0x0400
#define SKB_ATMPAD             0x0800
#define SKB_DEFAULT            SKB_FULL
#define SKB_CURRENT            0x0000

/* return values */
#define SKB_OK                 0x0000
#define SKB_ERR                0xFFFF

/* notification values */
#define SKN_CHANGED            1

#define SKN_POSCHANGED         1
#define SKN_PADCHANGED         2
#define SKN_MINCHANGED         4
#define SKN_VISCHANGED         8
#define SKN_TERMINATED         0xffff

typedef struct tagSKBINFO
   {
   HWND hwnd;
   UINT nPad;
   BOOL fVisible;
   BOOL fMinimized;
   RECT rect;
   DWORD dwReserved;
   }
   SKBINFO, FAR *LPSKBINFO;


UINT WINAPI ScreenKeyboard(HWND, UINT, UINT, LPPOINT, LPSKBINFO);	/* skb.dll */

#endif /* _INC_SKBAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\signal.h ===
/***
*signal.h - defines signal values and routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the signal values and declares the signal functions.
*   [ANSI/System V]
*
****/

#ifndef _INC_SIGNAL

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif 

#define NSIG 23     /* maximum signal number + 1 */


/* signal types */

#ifndef _WINDOWS
#define SIGINT      2   /* Ctrl-C sequence */
#define SIGILL      4   /* illegal instruction - invalid function image */
#endif 
#define SIGFPE      8   /* floating point exception */
#ifndef _WINDOWS
#define SIGSEGV     11  /* segment violation */
#define SIGTERM     15  /* Software termination signal from kill */
#define SIGABRT     22  /* abnormal termination triggered by abort call */
#endif 


/* signal action codes */

/* default signal action */
#define SIG_DFL (void (__cdecl *)(int))0

/* ignore */
#define SIG_IGN (void (__cdecl *)(int))1

/* signal error value (returned by signal call on error) */
#define SIG_ERR (void (__cdecl *)(int))-1


/* function prototypes */

void (__cdecl * __cdecl signal(int,
    void (__cdecl *)(int)))(int);
#ifndef _MT
int __cdecl raise(int);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_SIGNAL
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\shlobj.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1994
//
// File: shlobj.h
//
//  Definitions of IShellUI interface. Eventually this file should be merged
// into COMMUI.H.
//
// History:
//  12-30-92 SatoNa     Created.
//  01-06-93 SatoNa     Added this comment block.
//  01-13-93 SatoNa     Added DragFilesOver & DropFiles
//  01-27-93 SatoNa     Created by combining shellui.h and handler.h
//  01-28-93 SatoNa     OLE 2.0 beta 2
//  03-12-93 SatoNa     Removed IFileDropTarget (we use IDropTarget)
//
//---------------------------------------------------------------------------

#ifndef _SHLOBJ_H_
#define _SHLOBJ_H_

#include <ole2.h>
#include <prsht.h>
#include <shell2.h>

#ifndef INITGUID
#include <shlguid.h>
#endif

typedef void const FAR*       LPCVOID;

//----------------------------------------------------------------------------
//
// Shell Extension API
//
//----------------------------------------------------------------------------

//
// Task allocator
//
//  All the shell extensions MUST use this allocator when they allocate
// or free memory objects that are passed across any shell interface
// boundary.
//
// REVIEW:
//  It would be really nice if we can guarantee that shell's task
// allocator and OLE's task allocator is always the same. it is,
// however, not so easy to do, because:
//
//  1. We don't want to load COMPOBJ unless a shell extension DLL
//    loads it. We need to be notified when COMPOBJ is loaded.
//  2. We need to register our task allocator to the COMPOBJ
//    if one of shell extension DLLs loads it into the shell
//    process.
//  3. We need to get the task allocator from the COMPOBJ, if
//    the shell dll is loaded by non-shell process that registers
//    the task allocator to the COMPOBJ.
//

LPVOID WINAPI SHAlloc(ULONG cb);
LPVOID WINAPI SHRealloc(LPVOID pv, ULONG cbNew);
ULONG  WINAPI SHGetSize(LPVOID pv);
void   WINAPI SHFree(LPVOID pv);

//
// Helper macro definitions
//
#define S_BOOL(f)   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, f)


//----------------------------------------------------------------------------
//
// Interface:   IContextMenu
//
// History:
//  02-24-93 SatoNa     Created.
//
//----------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   IContextMenu

#define CMF_DEFAULTONLY  0x00000001

DECLARE_INTERFACE_(IContextMenu, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags) PURE;

    STDMETHOD(InvokeCommand)(THIS_
                             HWND   hwndParent,
                             LPCSTR pszWorkingDir,
                             LPCSTR pszCmd,
                             LPCSTR pszParam,
                             int    iShowCmd) PURE;

    STDMETHOD(GetCommandString)(THIS_
                                UINT        idCmd,
                                UINT        wReserved,
                                UINT FAR *  pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) PURE;
};

typedef IContextMenu FAR*	LPCONTEXTMENU;

// GetIconLocation() input flags

#define GIL_OPENICON     0x0001      // allows containers to specify an "open" look
                                     // return FALSE to get the standard look

// GetIconLocation() return flags

#define GIL_SIMULATEDOC  0x0001      // simulate this document icon for this
#define GIL_PERINSTANCE  0x0002      // icons from this class are per instance (each file has its own)
#define GIL_PERCLASS     0x0004      // icons from this class per class (shared for all files of this type)

#include <fcext.h>      // Browser extension interfaces are defined in FCEXT.H


//==========================================================================
// Helper macro for C programmers

//#ifdef WIN32
#define LPTONP(p)       (p)
//#else
//#define LPTONP(p)       OFFSETOF(p)
//#endif // WIN32

#define _IOffset(class, itf)         ((UINT)&(((class *)0)->itf))
#define IToClass(class, itf, pitf)   ((class FAR *)(((LPSTR)pitf)-_IOffset(class, itf)))
#define IToClassN(class, itf, pitf)  ((class *)LPTONP(((LPSTR)pitf)-_IOffset(class, itf)))

//===========================================================================

HRESULT STDAPICALLTYPE Link_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID FAR* ppvOut);
//
// Helper functions for component object DLLs
//
//===========================================================================

typedef HRESULT (CALLBACK FAR * LPFNCREATEINSTANCE)(
                                                  LPUNKNOWN pUnkOuter,
                                                  REFIID riid,
                                                  LPVOID FAR* ppvObject);

STDAPI Shell_CreateDefClassObject(REFIID riid, LPVOID FAR* ppv,
			 LPFNCREATEINSTANCE lpfn, UINT FAR * pcRefDll,
			 REFIID riidInstance);

//===========================================================================
//
// Interface: IShellExtInit
//
//  This interface is used to initialize shell extension objects.
//
//===========================================================================
#undef  INTERFACE
#define INTERFACE   IShellExtInit

DECLARE_INTERFACE_(IShellExtInit, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellExtInit methods ***
    STDMETHOD(Initialize)(THIS_ LPCITEMIDLIST pidlFolder,
		          LPDATAOBJECT lpdobj, HKEY hkeyProgID) PURE;
};
									
typedef IShellExtInit FAR*	LPSHELLEXTINIT;

#undef  INTERFACE
#define INTERFACE   IShellPropSheetExt

DECLARE_INTERFACE_(IShellPropSheetExt, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellPropSheetExt methods ***
    STDMETHOD(AddPages)(THIS_ LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam) PURE;
};

typedef IShellPropSheetExt FAR* LPSHELLPROPSHEETEXT;


//===========================================================================
//
// IPersistFolder Interface
//
//  This interface is used by the Folder implementation of
// IMoniker::BindToObject when it is initializing a folder object.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IPersistFolder

DECLARE_INTERFACE_(IPersistFolder, IPersist)	// fld
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistFolder methods ***
    STDMETHOD(Initialize) (THIS_
			   LPCITEMIDLIST pidl) PURE;
};

typedef IPersistFolder FAR*	LPPERSISTFOLDER;


//
// IExtractIcon interface
//
#undef  INTERFACE
#define INTERFACE   IExtractIcon

DECLARE_INTERFACE_(IExtractIcon, IUnknown)	// exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPSTR  szIconFile,
                         UINT   cchMax,
                         int  FAR * piIndex,
                         UINT FAR * pwFlags) PURE;

    STDMETHOD(ExtractIcon)(THIS_
                           LPCSTR pszFile,
			   UINT	  nIconIndex,
			   HICON  FAR *phiconLarge,
			   HICON  FAR *phiconSmall,
			   UINT   nIcons) PURE;
};

typedef IExtractIcon FAR*	LPEXTRACTICON;



//===========================================================================
// Network resource array handle
//===========================================================================
typedef HANDLE HNRES;
typedef struct _NETRESOURCE FAR *LPNETRESOURCE;
UINT WINAPI SHGetNetResource(HNRES hnres, UINT iItem, LPNETRESOURCE pnres, UINT cbMax);


//
// IShellLink Interface
//

#undef  INTERFACE
#define INTERFACE   IShellLink

DECLARE_INTERFACE_(IShellLink, IUnknown)	// sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(IsLinkToFile)(THIS) PURE;

    STDMETHOD(GetSubject)(THIS_ LPSTR pszFile, int cchMaxPath, WIN32_FIND_DATA *pfd, UINT fFlags) PURE;
    STDMETHOD(SetSubject)(THIS_ LPCSTR pszFile, const WIN32_FIND_DATA *pfd) PURE;

    STDMETHOD(GetWorkingDirectory)(THIS_ LPSTR pszDir, int cchMaxPath) PURE;
    STDMETHOD(SetWorkingDirectory)(THIS_ LPCSTR pszDir) PURE;

    STDMETHOD(GetArguments)(THIS_ LPSTR pszArgs, int cchMaxPath) PURE;
    STDMETHOD(SetArguments)(THIS_ LPCSTR pszArgs) PURE;

    STDMETHOD(GetHotkey)(THIS_ WORD *pwHotkey) PURE;
    STDMETHOD(SetHotkey)(THIS_ WORD wHotkey) PURE;

    STDMETHOD(GetShowCmd)(THIS_ int *piShowCmd) PURE;
    STDMETHOD(SetShowCmd)(THIS_ int iShowCmd) PURE;

    STDMETHOD(GetIconLocation)(THIS_ LPSTR pszIconPath, int cchIconPath, int *piIcon) PURE;
    STDMETHOD(SetIconLocation)(THIS_ LPCSTR pszIconPath, int iIcon) PURE;

    STDMETHOD(Resolve)(THIS_ HWND hwnd, UINT fFlags) PURE;

    STDMETHOD(Update)(THIS_ UINT fFlags) PURE;
};



#endif // _SHELLUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\spstup.h ===
/*
 * SPSTUP.H - SwapFile interface for Setup. routines exported from cpwin386.cpl
 *
 * BUGBUG: this can go away once we do swapfiles right...
 */

/*
 * Structure used with SetupSwapFile API.
 */
typedef struct
{
    unsigned long StpResBytes;          /* The number of bytes that
                                         * Setup needs to reserve on the
                                         * indicated drive for further
                                         * Setup operations.
                                         */

    unsigned long PartFileSizeBytes;    /* The size set (output), or the size
                                         * to be set (input) for the paging
                                         * SwapFile.
                                         */

    unsigned int  PartFlags;            /* Paging file flags, see bit
                                         * definitions below.
                                         */

    unsigned int  Win300SpCopied;       /* This is a BOOL.  It controls the
                                         * user warning about the fact that
                                         * partition files are inherently
                                         * GLOBAL and that if the USER
                                         * has both a 3.00 and 3.10
                                         * installation he is going to stomp
                                         * the 3.00 installation unless he
                                         * behaves.
                                         *
                                         * NOTE that the display of this
                                         * warning is NOT controlled by the
                                         * Interact setting.
                                         *
                                         * NOTE that SetupSwapFile may change
                                         * this variable from TRUE -> FALSE
                                         * and that Setup should preserve
                                         * this change across subsequent
                                         * calls.
                                         *
                                         * Normally this is FALSE.  Setup
                                         * should set this to TRUE iff SETUP
                                         * has copied SPART.PAR from a 3.00
                                         * directory as part of the setup
                                         * process.  NOTE that this implies
                                         * several things:
                                         *
                                         *   SETUP found a 3.00 dir.
                                         *
                                         *   This is a new installation of
                                         *   3.10 into a directory DIFFERENT
                                         *   than the 3.00 directory.
                                         *
                                         *   Setup found an SPART.PAR in the
                                         *   3.00 directory to copy.
                                         *
                                         *   An SPART.PAR did not already
                                         *   exist in the 3.10 directory.
                                         */

    /*
     * The following two fields are UPPER-CASE DOS DRIVE LETTERS.
     */

    unsigned char StpResDrv;            /* DOS drive of StpResBytes. */

    unsigned char PartDrv;              /* DOS drive of PartFileSizeBytes. */
    LPCSTR szWinDir;                    /* NEW FOR CHICAGO: windows dir where we are installing too */
} SprtData;

/*
 * Structure used with SetupGetCurSetting API:
 */
typedef struct
{
    unsigned long PartCurSizeBytes;     /* The size of the current SwapFile
                                         * (output).
                                         */

    unsigned int  PartFlags;            /* Paging file flags (output), see
                                         * bit definitions below.
                                         */

    unsigned char PartDrv;              /* DOS drive of CurSizeBytes (output).
                                         */
} SprtSetData;

/*
 * Bit definitions for PartFlags bit field:
 *
 * For SetupSwapFile() API only
 *
 *      PART_IS_TEMP
 *      PART_IS_PERM
 *      PART_OFF
 *      PART_NO_SPACE
 *      PART_UCANCEL
 *
 * are valid.  For SetupGetCurSetting() API only
 *
 *      PART_IS_TEMP
 *      PART_IS_PERM
 *      PART_OFF
 *      PART_FAST
 *
 * are valid.
 */
#define PART_IS_TEMP    0x0001  /* Setting is temporary swapfile. */
#define PART_IS_PERM    0x0002  /* Setting is permanent swapfile. */
#define PART_OFF        0x0004  /* USER requested paging OFF. */
#define PART_FAST       0x0008  /* Only through SetupGetCurSetting API -
                                 *  if PART_IS_PERM means USING 32-BIT
                                 *  ACCESS.
                                 */
#define PART_NO_SPACE   0x0010  /* No setting, insufficient disk space. */
#define PART_UCANCEL    0x0020  /* USER CANCELED in interactive mode. */


typedef BOOL (FAR PASCAL *SWAPCURSETPROC)(SprtSetData FAR *SetData);
typedef BOOL (FAR PASCAL *SWAPFILEPROC)(HWND, BOOL bInteract, BOOL bCreate, SprtData FAR *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\spool.h ===
#ifndef WINAPI
#ifdef BUILDDLL                                 /* ;Internal */
#define WINAPI              _loadds far pascal  /* ;Internal */
#define CALLBACK	    _loadds far pascal	/* ;Internal */
#else						/* ;Internal */
#define WINAPI              far pascal
#define CALLBACK	    far pascal
#endif                                          /* ;Internal */
#endif

#define LWORD(x)        ((int)((x)&0xFFFF))


/* spooler error code */
#define SP_ERROR            (-1)    /* general error - mostly used when spooler isn't loaded */
#define SP_APPABORT         (-2)    /* app aborted the job through the driver */
#define SP_USERABORT        (-3)    /* user aborted the job through spooler's front end */
#define SP_OUTOFDISK        (-4)    /* simply no disk to spool */
#define SP_OUTOFMEMORY      (-5)
#define SP_RETRY            (-6)    /* retry sending to the port again  */
#define SP_NOTREPORTED      0x4000  /* set if GDI did not report error */

/* subfunctions of the Spooler support function, GetSpoolJob()
 *  CP_* are used by the control panel for modifying the printer setup/
 */
#define SP_PRINTERNAME      20
#define SP_REGISTER         21
#define SP_CONNECTEDPORTCNT 25
#define SP_QUERYDISKUSAGE   26
#define SP_DISKFREED        27
#define SP_INIT             28
#define SP_LISTEDPORTCNT    29
// #define CP_ISPORTFREE    30
#define SP_QUERYVALIDJOB    30
#define CP_REINIT	    31
#define SP_TXTIMEOUT	    32
#define SP_DNSTIMEOUT	    33
#define CP_CHECKSPOOLER     34
#define CP_SET_TT_ONLY      35
#define CP_SETSPOOLER       36
#define CP_SETDOSPRINT      37


#define SP_DISK_BUFFER      (20000) /* wait for about 20 K of disk space to free
                                       free up before attempting to write to disk */

/* messages posted or sent to the spooler window */
// change these to WM_SPOOLER_ messages
#define SP_NEWJOB           0x1001
#define SP_DELETEJOB        0x1002
#define SP_DISKNEEDED       0x1003
#define SP_QUERYDISKAVAIL   0x1004
#define SP_ISPORTFREE       0x1005
#define SP_CHANGEPORT       0x1006

/* in /windows/oem/printer.h */


// JCB.type status flag bits 

// job is done printing (no more pages will be spooled)
#define JB_ENDDOC           0x0001  

// spooler canceled the job (user deleted it) either while it
// is being spooled (spool routines care about this) or after
// it is done spooling (no one really cares about this).
#define JB_CANCELED_JOB     0x0002

// the spool data is a metafile (with the devmode stuck on the end)
#define JB_METAFILE	    0x0080

// don't spool, send data straight to the desired port (gdi
// does all comm IO, deals with timeouts etc).
#define JB_DIRECT_OUTPUT    0x8000

// printing to a file ("FILE:" or file name).  use dos
// writes when outputting data.  also used for non spooled net jobs
// (net data goes through dos)
#define JB_PRINT_TO_FILE    0x4000  

// this is a spooled job (going to be sent to printman eventually)
#define JB_SPOOLED_JOB      0x2000

// when the spooler is notified we mark the job with this, be careful
// because the user can close down printman after notification
#define JB_NOTIFIED_SPOOLER 0x1000

// we are in an out of disk condition and we are waiting for printman
// to finish outputting some spool data to get more disk space
#define JB_WAITFORDISK      0x0800

// tell printman to "print through dos" instead of using comm routines
#define JB_DOS_WRITES	    0x0200

// use WNetCloseJob() instead of _lclose(), this is a net job
#define JB_NET_JOB	    0x0100

// no deletion of file after spool (USED?)
// #define JB_DEL_FILE         0x0400  

#define NAME_LEN        32
#define BUF_SIZE        128
#define MAX_PROFILE     80
#define JCBBUF_LEN      256

/* comm driver buffer sizes (used by print manager and gdi when opening ports) */
#define COMM_INQUE          0x010
#define COMM_OUTQUE         0x400

#define COMM_ERR_BIT        0x8000
#define TXTIMEOUT           45000               /* milliseconds */
#define DNSTIMEOUT          15000               /* milliseconds */

#define BAUDRATE            0
#define PARITY              1
#define BYTESIZE            2
#define STOPBITS            3
#define REPEAT              4

#define MAXPORTLIST 	20  	/* max # ports listed in win.ini [ports] */
#define MAXPORT     	MAXPORTLIST
#define MAXSPOOL    	100	/* max # jobs spooled per port */
#define MAXMAP      	18
#define PORTINDENT   	2
#define JOBINDENT    	3
#define MAXPAGE		7	/* allow 7 pages at first */
#define INC_PAGE    	8     	/* increase by 8 pages at a time */

typedef struct {
    ATOM  aPortName;
    ATOM  aPrinterName;
    ATOM  aDriverName;
    long txtimeout;
    long dnstimeout;
} JCBQ;

typedef struct jcb {
    unsigned        type;
    int             pagecnt;
    int             maxpage;
    int             portnum;
    HDC             hDC;
    int             chBuf;
    long	    timeSpooled;
    char            buffer[JCBBUF_LEN];
    unsigned long   size;
    unsigned long   iLastPage;
    WORD	    psp;		// the PSP of the app that started printing
//    PORT	    pPort;		// use this instead of overloading page[1]
    char            jobName[NAME_LEN];
    int             page[MAXPAGE];
} JCB, FAR *LPJCB;


// DIALOGMARK.type values (NOT USED)
// #define SP_TEXT         0   /* text type                                */
// #define SP_NOTTEXT      1   /* not text type                            */
// #define SP_DIALOG       2   /* dialog type data                         */
// #define SP_CALLBACK     3   /* call back type function                  */

// the PAGE structure containes an array of these, one for every dialog 
typedef struct {
    int    size;       	// size of the dialog data
    long   data_offset;	// offset into the spool file of this data
} DIALOGMARK, FAR *LPDIALOGMARK;

// change these to 2 (these are rare things) and rename
#define SP_DLGINC       8	// this many dlg msgs per page (initially)
#define SP_DLGINIT      8	// grow DIALOGMARK.dialog array by this amount

typedef struct page {
    int      filenum;		// file handle
    int	     maxdlg;            // max number of dialog
    int      dlg_index;         // index into dialog[] of next dialog
    long     spoolsize;		// size of this page spool file
    OFSTRUCT fileBuf;		// OpenFile() buffer
    DIALOGMARK  dialog[SP_DLGINIT];
} PAGE, FAR *LPPAGE;

// #define SP_COMM_PORT    	0
// #define SP_FILE_PORT		1
// #define SP_REMOTE_QUEUE 	2


// GDI uses this (not printman)
typedef struct {
    int   type;
    int   fn;
    long  retry;            /* system timer on first error  */
} PORT;


/* exported routines */


// these should be in windows.h or printers.h, remove from here
int   WINAPI WriteDialog(HANDLE hJCB, LPSTR str, int n);
int   WINAPI WriteSpool(HANDLE hJCB, LPSTR str, int n);


LONG  WINAPI GetSpoolJob(int, long);	// printman and control panel call here

char  WINAPI GetSpoolTempDrive(void);	// no one should call this
BOOL  WINAPI QueryJob(HANDLE, int);	// no one should call this
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\sregapi.h ===
/* *********************************************************************
 *	SRegAPI.h Header file for registry base api function prototypes 
 *      for Chicago SETUP only
 *
 * Microsoft Corporation 
 * Copyright 1994
 * 
 * Author:  Nagarajan Subramaniyan 
 * Created: 2/18/94
 *  
 * Modification history:
 * **********************************************************************
*/

#undef HKEY_CLASSES_ROOT

#include <regapi.h>		// Include the real mode stuff

#ifndef _INC_WINDOWS
LONG    WINAPI RegOpenKey(HKEY, LPCSTR, LPHKEY);
LONG    WINAPI RegCreateKey(HKEY, LPCSTR, LPHKEY);
LONG    WINAPI RegCloseKey(HKEY);
LONG    WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG    WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG    WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG    WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);
#endif

#if !defined(_INC_WINDOWS ) || (WINVER < 0x0400)
LONG    WINAPI RegDeleteValue(HKEY, LPCSTR);
LONG    WINAPI RegEnumValue(HKEY, DWORD, LPCSTR,
                         LONG FAR *, DWORD, LONG FAR *, LPBYTE,
                         LONG FAR *);
LONG    WINAPI RegQueryValueEx(HKEY, LPCSTR, LONG FAR *, LONG FAR *,
			    LPBYTE, LONG FAR *);
LONG    WINAPI RegSetValueEx(HKEY, LPCSTR, DWORD, DWORD, LPBYTE, DWORD);
LONG    WINAPI RegFlushKey(HKEY);
LONG	WINAPI RegSaveKey(HKEY, LPCSTR,LPVOID);
LONG	WINAPI RegLoadKey(HKEY, LPCSTR,LPCSTR);
LONG	WINAPI RegUnLoadKey(HKEY, LPCSTR);
#endif  // #if !defined(_INC_WINDOWS ) || (WINVER < 0x4000)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines ANSI-style macros for accessing arguments
*   of functions which take a variable number of arguments.
*   [ANSI]
*
****/

#ifndef _INC_STDARG

#ifdef __cplusplus
extern "C" {
#endif 

#ifdef _WINDLL
#define _FARARG_ __far
#else 
#define _FARARG_
#endif 

#if (_MSC_VER <= 600)
#define __far       _far
#endif 

#ifndef _VA_LIST_DEFINED
typedef char _FARARG_ *va_list;
#define _VA_LIST_DEFINED
#endif 

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v) ap = (va_list)&v + _INTSIZEOF(v)
#define va_arg(ap,t) ( *(t _FARARG_ *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#ifdef __cplusplus
}
#endif 

#define _INC_STDARG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains definitions and declarations for some commonly
*   used constants, types, and variables.
*   [ANSI]
*
****/

#ifndef _INC_STDDEF

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/* define the NULL pointer value and the offsetof() macro */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* offset of field m in a struct s */

#define offsetof(s,m)   (size_t)( (char *)&(((s *)0)->m) - (char *)0 )


/* errno declaration */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
#define errno   (*_errno())
#else 
extern int __near __cdecl volatile errno;
#endif 


/* define the implementation dependent size types */

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 


#ifdef _MT
/* define pointer to thread id value */

extern int __far *_threadid;
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDDEF
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   used by the level 2 I/O ("standard I/O") routines.
*   [ANSI/System V]
*
****/

#ifndef _INC_STDIO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif 

/* buffered I/O macros */

#define BUFSIZ  512
#ifdef _MT
#define _NFILE  40
#else 
#define _NFILE  20
#endif 
#define EOF (-1)

#ifndef _FILE_DEFINED
#pragma pack(2)
struct _iobuf {
    char *_ptr;
    int   _cnt;
    char *_base;
    char  _flag;
    char  _file;
    };
typedef struct _iobuf FILE;
#pragma pack()
#define _FILE_DEFINED
#endif 


/* _P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of _P_tmpdir
 *  + 1 (in case _P_tmpdir does not end in "\\")
 *  + 6 (for the temp number string)
 *  + 1 (for the null terminator)
 */

#define  _P_tmpdir "\\"
#define  L_tmpnam sizeof(_P_tmpdir)+8


/* fseek constants */

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


/* minimum guaranteed filename length, open file count, and unique
 * tmpnam filenames.
 */

#define FILENAME_MAX 128
#define FOPEN_MAX 18
#define TMP_MAX 32767
#define _SYS_OPEN 20


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* declare _iob[] array */

#ifndef _STDIO_DEFINED
extern FILE __near __cdecl _iob[];
#endif 


/* define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif 


/* standard file pointers */

#ifndef _WINDLL
#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])
#endif 
#ifndef _WINDOWS
#define _stdaux (&_iob[3])
#define _stdprn (&_iob[4])
#endif 


#define _IOREAD     0x01
#define _IOWRT      0x02

#define _IOFBF      0x0
#define _IOLBF      0x40
#define _IONBF      0x04

#define _IOMYBUF    0x08
#define _IOEOF      0x10
#define _IOERR      0x20
#define _IOSTRG     0x40
#define _IORW       0x80


#ifdef _WINDOWS
#ifndef _WINDLL
#ifndef _WINFO_DEFINED
/* interface version number */
#define _QWINVER    0

/* max number of windows */
#define _WFILE      20

/* values for windows screen buffer size */
#define _WINBUFINF  0
#define _WINBUFDEF  -1

/* size/move settings */
#define _WINSIZEMIN 1
#define _WINSIZEMAX 2
#define _WINSIZERESTORE 3
#define _WINSIZECHAR    4

/* size/move query types */
#define _WINMAXREQ  100
#define _WINCURRREQ 101

/* values for closing window */
#define _WINPERSIST 1
#define _WINNOPERSIST   0

/* pseudo file handle for frame window */
#define _WINFRAMEHAND   -1

/* menu items */
#define _WINSTATBAR 1
#define _WINTILE    2
#define _WINCASCADE 3
#define _WINARRANGE 4

/* quickwin exit options */
#define _WINEXITPROMPT      1
#define _WINEXITNOPERSIST   2
#define _WINEXITPERSIST     3

/* open structure */
#pragma pack(2)
struct _wopeninfo {
    unsigned int _version;
    const char __far * _title;
    long _wbufsize;
    };
#pragma pack()

/* size/move structure */
struct _wsizeinfo {
    unsigned int _version;
    unsigned int _type;
    unsigned int _x;
    unsigned int _y;
    unsigned int _h;
    unsigned int _w;
    };
#define _WINFO_DEFINED
#endif 
#endif 
#endif 

/* function prototypes */

#ifndef _STDIO_DEFINED
int __cdecl _filbuf(FILE *);
int __cdecl _flsbuf(int, FILE *);
FILE * __cdecl _fsopen(const char *,
    const char *, int);
void __cdecl clearerr(FILE *);
int __cdecl fclose(FILE *);
int __cdecl _fcloseall(void);
FILE * __cdecl _fdopen(int, const char *);
int __cdecl feof(FILE *);
int __cdecl ferror(FILE *);
int __cdecl fflush(FILE *);
int __cdecl fgetc(FILE *);
#ifndef _WINDLL
int __cdecl _fgetchar(void);
#endif 
int __cdecl fgetpos(FILE *, fpos_t *);
char * __cdecl fgets(char *, int, FILE *);
int __cdecl _fileno(FILE *);
int __cdecl _flushall(void);
FILE * __cdecl fopen(const char *,
    const char *);
int __cdecl fprintf(FILE *, const char *, ...);
int __cdecl fputc(int, FILE *);
#ifndef _WINDLL
int __cdecl _fputchar(int);
#endif 
int __cdecl fputs(const char *, FILE *);
size_t __cdecl fread(void *, size_t, size_t, FILE *);
FILE * __cdecl freopen(const char *,
    const char *, FILE *);
#ifndef _WINDLL
int __cdecl fscanf(FILE *, const char *, ...);
#endif 
int __cdecl fsetpos(FILE *, const fpos_t *);
int __cdecl fseek(FILE *, long, int);
long __cdecl ftell(FILE *);
#ifdef _WINDOWS
#ifndef _WINDLL
FILE * __cdecl _fwopen(struct _wopeninfo *, struct _wsizeinfo *, const char *);
#endif 
#endif 
size_t __cdecl fwrite(const void *, size_t, size_t,
    FILE *);
int __cdecl getc(FILE *);
#ifndef _WINDLL
int __cdecl getchar(void);
char * __cdecl gets(char *);
#endif 
int __cdecl _getw(FILE *);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif 
#ifndef _WINDLL
int __cdecl printf(const char *, ...);
#endif 
int __cdecl putc(int, FILE *);
#ifndef _WINDLL
int __cdecl putchar(int);
int __cdecl puts(const char *);
#endif 
int __cdecl _putw(int, FILE *);
int __cdecl remove(const char *);
int __cdecl rename(const char *, const char *);
void __cdecl rewind(FILE *);
int __cdecl _rmtmp(void);
#ifndef _WINDLL
int __cdecl scanf(const char *, ...);
#endif 
void __cdecl setbuf(FILE *, char *);
int __cdecl setvbuf(FILE *, char *, int, size_t);
int __cdecl _snprintf(char *, size_t, const char *, ...);
int __cdecl sprintf(char *, const char *, ...);
#ifndef _WINDLL
int __cdecl sscanf(const char *, const char *, ...);
#endif 
char * __cdecl _tempnam(char *, char *);
FILE * __cdecl tmpfile(void);
char * __cdecl tmpnam(char *);
int __cdecl ungetc(int, FILE *);
int __cdecl _unlink(const char *);
int __cdecl vfprintf(FILE *, const char *, va_list);
#ifndef _WINDLL
int __cdecl vprintf(const char *, va_list);
#endif 
int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
int __cdecl vsprintf(char *, const char *, va_list);
#define _STDIO_DEFINED
#endif 

/* macro definitions */

#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((int)(unsigned char)(_stream)->_file)
#define getc(_stream)     (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ \
    : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
    ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#ifndef _WINDLL
#define getchar()     getc(stdin)
#define putchar(_c)   putc((_c),stdout)
#endif 

#ifdef _MT
#undef  getc
#undef  putc
#undef  getchar
#undef  putchar
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

#ifndef _WINDOWS
#define stdaux    _stdaux
#define stdprn    _stdprn
#endif 

int __cdecl fcloseall(void);
FILE * __cdecl fdopen(int, const char *);
#ifndef _WINDLL
int __cdecl fgetchar(void);
#endif 
int __cdecl fileno(FILE *);
int __cdecl flushall(void);
#ifndef _WINDLL
int __cdecl fputchar(int);
#endif 
int __cdecl getw(FILE *);
int __cdecl putw(int, FILE *);
int __cdecl rmtmp(void);
char * __cdecl tempnam(char *, char *);
int __cdecl unlink(const char *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDIO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\stdiostr.h ===
/***
*stdiostr.h - definitions/declarations for stdiobuf, stdiostream
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the stdiostream and stdiobuf classes.
*   [AT&T C++]
*
****/

#include <iostream.h>
#include <stdio.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifndef _INC_STDIOSTREAM
#define _INC_STDIOSTREAM
class stdiobuf : public streambuf  {
public:
    stdiobuf(FILE* f);
FILE *  stdiofile() { return _str; }

virtual int pbackfail(int c);
virtual int overflow(int c = EOF);
virtual int underflow();
virtual streampos seekoff( streamoff, ios::seek_dir, int =ios::in|ios::out);
virtual int sync();
    ~stdiobuf();
    int setrwbuf(int _rsize, int _wsize); // CONSIDER: move to ios::
// protected:
// virtual int doallocate();
private:
    FILE * _str;
};

// obsolescent
class stdiostream : public iostream {   // note: spec.'d as : public IOS...
public:
    stdiostream(FILE *);
    ~stdiostream();
    stdiobuf* rdbuf() const { return (stdiobuf*) ostream::rdbuf(); }

private:
};

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   commonly used library functions which either don't fit somewhere
*   else, or, like toupper/tolower, can't be declared in the normal
*   place for other reasons.
*   [ANSI]
*
****/

#ifndef _INC_STDLIB

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 

/* exit() arg values */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1

#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)();
typedef int (__far __cdecl * _fonexit_t)();
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef int (__cdecl * onexit_t)();
#endif 
#define _ONEXIT_T_DEFINED
#endif 


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t {
    long quot;
    long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif 

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

extern unsigned short __mb_cur_max; /* mb-len for curr. locale */
#define MB_CUR_MAX __mb_cur_max


/* min and max macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

/* external variable declarations */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
extern int __far * __cdecl __far __doserrno(void);
#define errno       (*_errno())
#define _doserrno   (*__doserrno())
#else 
extern int __near __cdecl volatile errno;   /* error value */
extern int __near __cdecl _doserrno;        /* OS system error value */
#endif 

extern char * __near __cdecl _sys_errlist[];    /* perror error message table */
extern int __near __cdecl _sys_nerr;        /* # of entries in sys_errlist table */
extern char ** __near __cdecl _environ;     /* pointer to environment table */
extern int __near __cdecl _fmode;       /* default file translation mode */
#ifndef _WINDOWS
extern int __near __cdecl _fileinfo;        /* open file info mode (for spawn) */
#endif 

extern unsigned int __near __cdecl _psp;    /* Program Segment Prefix */

extern char __far * __near __cdecl _pgmptr; /* Pointer to Program name */

/* DOS and Windows major/minor version numbers */

extern unsigned int __near __cdecl _osver;
extern unsigned char __near __cdecl _osmajor;
extern unsigned char __near __cdecl _osminor;
extern unsigned int __near __cdecl _winver;
extern unsigned char __near __cdecl _winmajor;
extern unsigned char __near __cdecl _winminor;

/* OS mode */

#define _DOS_MODE   0   /* DOS */
#define _OS2_MODE   1   /* OS/2 */
#define _WIN_MODE   2   /* Windows */

extern unsigned char __near __cdecl _osmode;

/* CPU mode */

#define _REAL_MODE  0   /* real mode */
#define _PROT_MODE  1   /* protect mode */

extern unsigned char __near __cdecl _cpumode;

/* function prototypes */

#ifdef _MT
double __pascal atof(const char *);
double __pascal strtod(const char *, char * *);
ldiv_t __pascal ldiv(long, long);
#else 
double __cdecl atof(const char *);
double __cdecl strtod(const char *, char * *);
ldiv_t __cdecl ldiv(long, long);
#endif 

void __cdecl abort(void);
int __cdecl abs(int);
int __cdecl atexit(void (__cdecl *)(void));
int __cdecl atoi(const char *);
long __cdecl atol(const char *);
long double __cdecl _atold(const char *);
void * __cdecl bsearch(const void *, const void *,
    size_t, size_t, int (__cdecl *)(const void *,
    const void *));
void * __cdecl calloc(size_t, size_t);
div_t __cdecl div(int, int);
char * __cdecl _ecvt(double, int, int *, int *);
#ifndef _WINDLL
void __cdecl exit(int);
void __cdecl _exit(int);
#endif 
int __far __cdecl _fatexit(void (__cdecl __far *)(void));
char * __cdecl _fcvt(double, int, int *, int *);
_fonexit_t __far __cdecl _fonexit(_fonexit_t);
void __cdecl free(void *);
char * __cdecl _fullpath(char *, const char *,
    size_t);
char * __cdecl _gcvt(double, int, char *);
char * __cdecl getenv(const char *);
char * __cdecl _itoa(int, char *, int);
long __cdecl labs(long);
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);
char * __cdecl _ltoa(long, char *, int);
void __cdecl _makepath(char *, const char *,
    const char *, const char *, const char *);
void * __cdecl malloc(size_t);
_onexit_t __cdecl _onexit(_onexit_t);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif 
int __cdecl _putenv(const char *);
void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
    (const void *, const void *));
unsigned int __cdecl _rotl(unsigned int, int);
unsigned int __cdecl _rotr(unsigned int, int);
int __cdecl rand(void);
void * __cdecl realloc(void *, size_t);
void __cdecl _searchenv(const char *, const char *,
    char *);
void __cdecl _splitpath(const char *, char *,
    char *, char *, char *);
void __cdecl srand(unsigned int);
long __cdecl strtol(const char *, char * *,
    int);
long double __cdecl _strtold(const char *,
    char * *);
unsigned long __cdecl strtoul(const char *,
    char * *, int);
void __cdecl _swab(char *, char *, int);
#ifndef _WINDOWS
int __cdecl system(const char *);
#endif 
char * __cdecl _ultoa(unsigned long, char *, int);

int __cdecl mblen(const char *, size_t);
int __cdecl mbtowc(wchar_t *, const char *, size_t);
int __cdecl wctomb(char *, wchar_t);
size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
size_t __cdecl wcstombs(char *, const wchar_t *, size_t);

/* model-independent function prototypes */

int __far __cdecl _fmblen(const char __far *, size_t);
int __far __cdecl _fmbtowc(wchar_t __far *, const char __far *,
    size_t);
int __far __cdecl _fwctomb(char __far *, wchar_t);
size_t __far __cdecl _fmbstowcs(wchar_t __far *, const char __far *,
    size_t);
size_t __far __cdecl _fwcstombs(char __far *, const wchar_t __far *,
    size_t);

#ifndef tolower
int __cdecl tolower(int);
#endif 

#ifndef toupper
int __cdecl toupper(int);
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif 

extern char * __near __cdecl sys_errlist[];
extern int __near __cdecl sys_nerr;
extern char ** __near __cdecl environ;

#define DOS_MODE    _DOS_MODE
#define OS2_MODE    _OS2_MODE

char * __cdecl ecvt(double, int, int *, int *);
char * __cdecl fcvt(double, int, int *, int *);
char * __cdecl gcvt(double, int, char *);
char * __cdecl itoa(int, char *, int);
char * __cdecl ltoa(long, char *, int);
onexit_t __cdecl onexit(onexit_t);
int __cdecl putenv(const char *);
void __cdecl swab(char *, char *, int);
char * __cdecl ultoa(unsigned long, char *, int);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDLIB
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\stress.h ===
/*****************************************************************************\
*                                                                             *
* stress.h -    Stress functions definitions                                  *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp. All rights reserved.		      *
*                                                                             *
*******************************************************************************/

#ifndef _INC_STRESS
#define _INC_STRESS

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****** Simple types & common helper macros *********************************/

#ifndef _INC_WINDOWS    /* If included with 3.0 headers... */
#define UINT        WORD
#define WINAPI      FAR PASCAL
#endif  /* _INC_WINDOWS */

/* stuff for AllocDiskSpace() */
#define  EDS_WIN     1
#define  EDS_CUR     2
#define  EDS_TEMP    3


/* function prototypes */
BOOL    WINAPI AllocMem(DWORD);
void    WINAPI FreeAllMem(void);
int     WINAPI AllocFileHandles(int);
void    WINAPI UnAllocFileHandles(void);
int     WINAPI GetFreeFileHandles(void);
int     WINAPI AllocDiskSpace(long,UINT);
void    WINAPI UnAllocDiskSpace(UINT);
BOOL    WINAPI AllocUserMem(UINT);
void    WINAPI FreeAllUserMem(void);
BOOL    WINAPI AllocGDIMem(UINT);
void    WINAPI FreeAllGDIMem(void);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_STRESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\storage.h ===
/*****************************************************************************\
*                                                                             *
* storage.h -	 Storage error codes, types, interfaces and API's             *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#if !defined( _STORAGE_H_ )
#define _STORAGE_H_


#include <compobj.h>


/****** Storage Error Codes *************************************************/

/* DOS-based error codes */
#define STG_E_INVALIDFUNCTION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x01)

#define STG_E_FILENOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x02)

#define STG_E_PATHNOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x03)

#define STG_E_TOOMANYOPENFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x04)

#define STG_E_ACCESSDENIED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x05)

#define STG_E_INVALIDHANDLE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x06)

#define STG_E_INSUFFICIENTMEMORY \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x08)

#define STG_E_INVALIDPOINTER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x09)

#define STG_E_NOMOREFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x12)

#define STG_E_DISKISWRITEPROTECTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x13)

#define STG_E_SEEKERROR \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x19)

#define STG_E_WRITEFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1d)

#define STG_E_READFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1e)

#define STG_E_LOCKVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x21)

#define STG_E_FILEALREADYEXISTS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x50)

#define STG_E_INVALIDPARAMETER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x57)

#define STG_E_MEDIUMFULL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x70)

#define STG_E_ABNORMALAPIEXIT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfa)

#define STG_E_INVALIDHEADER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfb)

#define STG_E_INVALIDNAME \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfc)

#define STG_E_UNKNOWN \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfd)

#define STG_E_UNIMPLEMENTEDFUNCTION\
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfe)

#define STG_E_INVALIDFLAG \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xff)

/* Standard storage error codes */
#define STG_E_INUSE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x100)

#define STG_E_NOTCURRENT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x101)

#define STG_E_REVERTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x102)

#define STG_E_CANTSAVE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x103)

#define STG_E_OLDFORMAT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x104)
    
#define STG_E_OLDDLL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x105)

#define STG_E_SHAREREQUIRED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x106)

/* Information returns */
#define STG_S_CONVERTED \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x200)

#define STG_S_BUFFEROVERFLOW \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x201)

#define STG_S_TRYOVERWRITE \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x202)


/****** Storage types *******************************************************/

#if defined(_M_I286)
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP _huge
#endif
#else
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP
#endif
#endif

#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT     0x00000000L
#define STGM_TRANSACTED     0x00010000L

#define STGM_READ       0x00000000L
#define STGM_WRITE      0x00000001L
#define STGM_READWRITE      0x00000002L

#define STGM_SHARE_DENY_NONE    0x00000040L
#define STGM_SHARE_DENY_READ    0x00000030L
#define STGM_SHARE_DENY_WRITE   0x00000020L
#define STGM_SHARE_EXCLUSIVE    0x00000010L

#define STGM_PRIORITY       0x00040000L
#define STGM_DELETEONRELEASE    0x04000000L

#define STGM_CREATE     0x00001000L
#define STGM_CONVERT        0x00020000L
#define STGM_FAILIFTHERE    0x00000000L

/* Storage commit types */
typedef enum tagSTGC
{
    STGC_DEFAULT = 0,
    STGC_OVERWRITE  = 1,
    STGC_ONLYIFCURRENT  = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4
} STGC;

/* Stream name block definitions */
typedef char FAR * FAR *SNB;


#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif


/* Storage stat buffer */

typedef struct FARSTRUCT tagSTATSTG
{
    char FAR* pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
} STATSTG;


/* Storage element types */
typedef enum tagSTGTY
{
    STGTY_STORAGE   = 1,
    STGTY_STREAM    = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY  = 4
} STGTY;

typedef enum tagSTREAM_SEEK
{
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2
} STREAM_SEEK;

typedef enum tagLOCKTYPE
{
    LOCK_WRITE      = 1,
    LOCK_EXCLUSIVE  = 2,
    LOCK_ONLYONCE   = 4
} LOCKTYPE;

typedef enum tagSTGMOVE
{
    STGMOVE_MOVE    = 0,
    STGMOVE_COPY    = 1
} STGMOVE;

typedef enum tagSTATFLAG
{
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1
} STATFLAG;


/****** Storage Enumerators *************************************************/

#define LPENUMSTATSTG        IEnumSTATSTG FAR*

#undef  INTERFACE
#define INTERFACE   IEnumSTATSTG

DECLARE_INTERFACE_(IEnumSTATSTG, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IENUMSTATSTG methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATSTG FAR * rgelt, ULONG FAR *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATSTG FAR *FAR *ppenm) PURE;
};


/****** ILockBytes Interface ************************************************/

#define LPLOCKBYTES     ILockBytes FAR*

#undef  INTERFACE
#define INTERFACE   ILockBytes

DECLARE_INTERFACE_(ILockBytes, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ILockBytes methods ***
    STDMETHOD(ReadAt) (THIS_ ULARGE_INTEGER ulOffset,
             VOID HUGEP *pv,
             ULONG cb,
             ULONG FAR *pcbRead) PURE;
    STDMETHOD(WriteAt) (THIS_ ULARGE_INTEGER ulOffset,
              VOID const HUGEP *pv,
              ULONG cb,
              ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Flush) (THIS) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER cb) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                   ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};


/****** IStream Interface ***************************************************/


#define LPSTREAM        IStream FAR*

#undef  INTERFACE
#define INTERFACE   IStream

DECLARE_INTERFACE_(IStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStream methods ***
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv,
             ULONG cb, ULONG FAR *pcbRead) PURE;
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,
            ULONG cb,
            ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,
               DWORD dwOrigin,
               ULARGE_INTEGER FAR *plibNewPosition) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize) PURE;
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,
             ULARGE_INTEGER cb,
             ULARGE_INTEGER FAR *pcbRead,
             ULARGE_INTEGER FAR *pcbWritten) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm) PURE;
};


/****** IStorage Interface **************************************************/

#define LPSTORAGE       IStorage FAR*

#undef  INTERFACE
#define INTERFACE   IStorage

DECLARE_INTERFACE_(IStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStorage methods ***
    STDMETHOD(CreateStream) (THIS_ const char FAR* pwcsName,
                   DWORD grfMode,
                   DWORD reserved1,
                   DWORD reserved2,
                   IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(OpenStream) (THIS_ const char FAR* pwcsName,
         void FAR *reserved1,
                 DWORD grfMode,
                 DWORD reserved2,
                 IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(CreateStorage) (THIS_ const char FAR* pwcsName,
                DWORD grfMode,
                DWORD reserved1,
                DWORD reserved2,
                IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(OpenStorage) (THIS_ const char FAR* pwcsName,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(CopyTo) (THIS_ DWORD ciidExclude,
               IID const FAR *rgiidExclude,
               SNB snbExclude,
               IStorage FAR *pstgDest) PURE;
    STDMETHOD(MoveElementTo) (THIS_ char const FAR* lpszName,
                      IStorage FAR *pstgDest,
                              char const FAR* lpszNewName,
                              DWORD grfFlags) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(EnumElements) (THIS_ DWORD reserved1,
                 void FAR *reserved2,
                 DWORD reserved3,
                 IEnumSTATSTG FAR *FAR *ppenm) PURE;
    STDMETHOD(DestroyElement) (THIS_ const char FAR* pwcsName) PURE;
    STDMETHOD(RenameElement) (THIS_ const char FAR* pwcsOldName,
                const char FAR* pwcsNewName) PURE;
    STDMETHOD(SetElementTimes) (THIS_ const char FAR *lpszName,
                        FILETIME const FAR *pctime,
                                FILETIME const FAR *patime,
                                FILETIME const FAR *pmtime) PURE;
    STDMETHOD(SetClass) (THIS_ REFCLSID clsid) PURE;
    STDMETHOD(SetStateBits) (THIS_ DWORD grfStateBits, DWORD grfMask) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};


/****** IRootStorage Interface **********************************************/

#define LPROOTSTORAGE       IRootStorage FAR*

#undef  INTERFACE
#define INTERFACE   IRootStorage

DECLARE_INTERFACE_(IRootStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRootStorage methods ***
    STDMETHOD(SwitchToFile) (THIS_ LPSTR lpstrFile) PURE;
};


/****** Storage API Prototypes ********************************************/

STDAPI StgCreateDocfile(const char FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);
STDAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorage(const char FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);
STDAPI StgIsStorageFile(const char FAR* pwcsName);
STDAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

STDAPI StgSetTimes(char const FAR* lpszName,
          FILETIME const FAR* pctime,
                  FILETIME const FAR* patime,
                  FILETIME const FAR* pmtime);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\inc.16\style.h ===
/*****************************************************************************\
*                                                                             *
* style.h -	 Common style ID's                                            *
*									      *
* Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

/* Window styles */
#define WS_TILED        0x00000000L
#define WS_ICONICPOPUP  0xc0000000L
#define WS_POPUP        0x80000000L
#define WS_CHILD        0x40000000L
#define WS_MINIMIZE     0x20000000L
#define WS_VISIBLE      0x10000000L
#define WS_DISABLED     0x08000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_MAXIMIZE     0x01000000L