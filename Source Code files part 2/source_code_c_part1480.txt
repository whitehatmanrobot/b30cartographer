                     IN CONST BYTE *pbData,
                         IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    BYTE            *pbTmp;
    CRYPT_DATA_BLOB *pBlob;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        if (dwParam == PP_CLIENT_HWND)
        {
            hWnd = *((HWND *) pbData);
            rt = CRYPT_SUCCEED;
            goto Ret;
        }
        else if (dwParam == PP_CONTEXT_INFO)
        {
            pBlob = (CRYPT_DATA_BLOB*)pbData;

            // allocate space for the new context info
            if (NULL == (pbTmp = (BYTE*)LocalAlloc(LMEM_ZEROINIT, pBlob->cbData)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
            memcpy(pbTmp, pBlob->pbData, pBlob->cbData);

            // free any previously allocated context info
            if (NULL != pbContextInfo)
            {
                LocalFree(pbContextInfo);
            }
            cbContextInfo = pBlob->cbData;
            pbContextInfo = pbTmp;

            rt = CRYPT_SUCCEED;
            goto Ret;
        }

        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement((LPLONG)&pVTable->Inuse))
        {
            InterlockedIncrement((LPLONG)&pVTable->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement((LPLONG)&pVTable->Inuse);

        rt = (BOOL)pVTable->FuncSetProvParam(pVTable->hProv, dwParam, pbData,
                                       dwFlags);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    return(rt);
}


/*
 -      CryptGetProvParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a proivder
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetProvParam(IN HCRYPTPROV hProv,
                         IN DWORD dwParam,
                         IN BYTE *pbData,
                         IN DWORD *pdwDataLen,
                         IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = (BOOL)pVTable->FuncGetProvParam(pVTable->hProv, dwParam, pbData,
                                       pdwDataLen, dwFlags);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}


/*
 -      CryptSetHashParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hHash   -  Handle to a hash
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetHashParam(IN HCRYPTHASH hHash,
                         IN DWORD dwParam,
                         IN CONST BYTE *pbData,
                         IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement((LPLONG)&pVHash->Inuse))
        {
            InterlockedIncrement((LPLONG)&pVHash->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement((LPLONG)&pVHash->Inuse);

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = (BOOL)pVHash->FuncSetHashParam(pVTable->hProv, pVHash->hHash,
                                      dwParam, pbData, dwFlags);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}


/*
 -      CryptGetHashParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hHash      -  Handle to a hash
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetHashParam(IN HCRYPTKEY hHash,
                         IN DWORD dwParam,
                         IN BYTE *pbData,
                         IN DWORD *pdwDataLen,
                         IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = (BOOL)pVHash->FuncGetHashParam(pVTable->hProv, pVHash->hHash,
                                      dwParam, pbData, pdwDataLen,
                                      dwFlags);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;

}

#ifndef WIN95
/*
 -      CryptSetProviderW
 -
 *      Purpose:
 *                Set a cryptography provider
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderW(IN LPCWSTR pszProvName,
                         IN DWORD dwProvType)

{
    ANSI_STRING         AnsiString;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    BOOL                rt = FALSE;

    __try
    {
        RtlInitUnicodeString(&UnicodeString, pszProvName);

        Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);

        if (!NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        rt = CryptSetProviderA((LPCSTR) AnsiString.Buffer,
                               dwProvType);

        RtlFreeAnsiString(&AnsiString);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    return(rt);
}
#else   // WIN95
WINADVAPI
BOOL
WINAPI CryptSetProviderW(IN LPCWSTR pszProvName,
                         IN DWORD dwProvType)

{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif   // WIN95

/*
 -      CryptSetProviderA
 -
 *      Purpose:
 *                Set a cryptography provider
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderA(IN LPCSTR pszProvName,
                         IN DWORD  dwProvType)
{
    HKEY        hCurrUser = 0;
    HKEY        hKey = 0;
    LONG        err;
    DWORD       dwIgn;
    DWORD       cbValue;
    CHAR        *pszValue = NULL;
    CHAR        typebuf[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    BOOL        fRet = CRYPT_FAILED;

    __try
    {
        if (dwProvType == 0 || dwProvType > 999 || pszProvName == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

            cbValue = strlen(pszProvName);

        if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                        strlen(szusertype) + 5 + 1)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        strcpy(pszValue, szusertype);
        __ltoa(dwProvType, typebuf);
        strcat(pszValue, &typebuf[5]);

#ifndef WIN95
        if (!NT_SUCCESS(RtlOpenCurrentUser(KEY_READ | KEY_WRITE, &hCurrUser)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if ((err = RegCreateKeyEx(hCurrUser,
                        (const char *) pszValue,
                        0L, "", REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwIgn)) != ERROR_SUCCESS)
        {
            NtClose(hCurrUser);
            SetLastError(err);
            goto Ret;
        }
        NtClose(hCurrUser);
#else

        if ((err = RegCreateKeyEx(HKEY_CURRENT_USER,
                        (const char *) pszValue,
                        0L, "", REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwIgn)) != ERROR_SUCCESS)
        {
            SetLastError(err);
            goto Ret;
        }
        RegClosKey(HKEY_CURRENT_USER);
#endif

        if ((err = RegSetValueEx(hKey, "Name", 0L, REG_SZ,
                        (const LPBYTE) pszProvName,
                        cbValue)) != ERROR_SUCCESS)
        {
            SetLastError(err);
            goto Ret;
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (pszValue)
        LocalFree(pszValue);
    if (hKey)
        RegCloseKey(hKey);

    return fRet;
}

#ifndef WIN95
/*
 -      CryptSetProviderExW
 -
 *      Purpose:
 *                Set the cryptographic provider as the default
 *                either for machine or for user.
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderExW(
                         IN LPCWSTR pszProvName,
                         IN DWORD dwProvType,
                         IN DWORD *pdwReserved,
                         IN DWORD dwFlags
                         )
{
    ANSI_STRING         AnsiString;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    BOOL                fRet = CRYPT_FAILED;

    __try
    {
        RtlInitUnicodeString(&UnicodeString, pszProvName);

        Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);

        if (!NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        fRet = CryptSetProviderExA((LPCSTR) AnsiString.Buffer,
                                 dwProvType,
                                 pdwReserved,
                                 dwFlags);

        RtlFreeAnsiString(&AnsiString);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

Ret:
    return fRet;
}
#else   // WIN95
WINADVAPI
BOOL
WINAPI CryptSetProviderExW(
                         IN LPCWSTR pszProvName,
                         IN DWORD dwProvType,
                         IN DWORD *pdwReserved,
                         IN DWORD dwFlags
                         )
{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif   // WIN95

/*
 -      CryptSetProviderExA
 -
 *      Purpose:
 *                Set the cryptographic provider as the default
 *                either for machine or for user.
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderExA(
                           IN LPCSTR pszProvName,
                           IN DWORD dwProvType,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags
                           )
{
    HKEY        hCurrUser = 0;
    HKEY        hRegKey = 0;
    LONG        err;
    DWORD       dwDisp;
    DWORD       cbValue;
    CHAR        *pszValue = NULL;
    CHAR        *pszFullName = NULL;
    DWORD       cbFullName;
    CHAR        typebuf[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    DWORD       dwKeyType;
    DWORD       dw;
    DWORD       cbProvType;
    BOOL        fRet = CRYPT_FAILED;

    __try
    {
        if ((dwProvType == 0) || (dwProvType > 999) ||
            (pszProvName == NULL) || (pdwReserved != NULL))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if ((dwFlags & ~(CRYPT_MACHINE_DEFAULT | CRYPT_USER_DEFAULT | CRYPT_DELETE_DEFAULT)) ||
            ((dwFlags & CRYPT_MACHINE_DEFAULT) && (dwFlags & CRYPT_USER_DEFAULT)))
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        cbValue = strlen(pszProvName);

        // check if the CSP has been installed
        cbFullName = cbValue + sizeof(szenumproviders) + sizeof(CHAR);

        if (NULL == (pszFullName = (CHAR *) LocalAlloc(LMEM_ZEROINIT, cbFullName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        strcpy(pszFullName, szenumproviders);
        pszFullName[sizeof(szenumproviders) - 1] = '\\';
        strcpy(pszFullName + sizeof(szenumproviders), pszProvName);

        if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        (const char *) pszFullName,
                        0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        cbProvType = sizeof(dw);
        if (ERROR_SUCCESS != (err = RegQueryValueEx(hRegKey,
                                                    (const char *) "Type",
                                                    NULL, &dwKeyType, (BYTE*)&dw,
                                                    &cbProvType)))
        {
            SetLastError(err);
            goto Ret;
        }
        if (dwProvType != dw)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegCloseKey(hRegKey)))
        {
            SetLastError(err);
            goto Ret;
        }
        hRegKey = NULL;

        if (dwFlags & CRYPT_MACHINE_DEFAULT)
        {
            if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                            strlen(szmachinetype) + 5 + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            strcpy(pszValue, szmachinetype);
            __ltoa(dwProvType, typebuf);
            strcat(pszValue, &typebuf[5]);

            if ((err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                            (const char *) pszValue,
                            0L, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hRegKey, &dwDisp)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }

            // check the delete flag
            if (dwFlags & CRYPT_DELETE_DEFAULT)
            {
                if (ERROR_SUCCESS != (err = RegDeleteValue(hRegKey, "Name")))
                {
                    SetLastError(err);
                    goto Ret;
                }
                fRet = CRYPT_SUCCEED;
                goto Ret;
            }
        }
        else if (dwFlags & CRYPT_USER_DEFAULT)
        {
            if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                            strlen(szusertype) + 5 + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            strcpy(pszValue, szusertype);
            __ltoa(dwProvType, typebuf);
            strcat(pszValue, &typebuf[5]);

#ifndef WIN95
            if (!NT_SUCCESS(RtlOpenCurrentUser(KEY_READ | KEY_WRITE, &hCurrUser)))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }

            if ((err = RegCreateKeyEx(hCurrUser,
                            (const char *) pszValue,
                            0L, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hRegKey, &dwDisp)) != ERROR_SUCCESS)
            {
                NtClose(hCurrUser);
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }

            // check the delete flag
            if (dwFlags & CRYPT_DELETE_DEFAULT)
            {
                if (ERROR_SUCCESS != (err = RegDeleteKey(hCurrUser, 
                                                         (const char *)pszValue)))
                {
                    NtClose(hCurrUser);
                    SetLastError(err);
                    goto Ret;
                }
                fRet = CRYPT_SUCCEED;
                NtClose(hCurrUser);
                goto Ret;
            }
            NtClose(hCurrUser);
#else
            if ((err = RegCreateKeyEx(HKEY_CURRENT_USER,
                            (const char *) pszValue,
                            0L, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hRegKey, &dwDisp)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }


            // check the delete flag
            if (dwFlags & CRYPT_DELETE_DEFAULT)
            {
                if (ERROR_SUCCESS != (err = RegDeleteKey(HKEY_CURRENT_USER,
                                                         (const char *)pszValue)))
                {
                    RegCloseKey(HKEY_CURRENT_USER);
                    SetLastError(err);
                    goto Ret;
                }
                fRet = CRYPT_SUCCEED;
                RegCloseKey(HKEY_CURRENT_USER);
                goto Ret;
            }
            RegCloseKey(HKEY_CURRENT_USER);
#endif
        }

        if (ERROR_SUCCESS != (err = RegSetValueEx(hRegKey, "Name", 0L, REG_SZ,
                                                  (const LPBYTE) pszProvName, cbValue)))
        {
            SetLastError(err);
            goto Ret;
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (pszFullName)
        LocalFree(pszFullName);
    if (pszValue)
        LocalFree(pszValue);
    if (hRegKey)
        RegCloseKey(hRegKey);
    return fRet;
}

#ifndef WIN95
/*
 -      CryptGetDefaultProviderW
 -
 *      Purpose:
 *                Get the default cryptographic provider of the specified
 *                type for either the machine or for the user.
 *
 *      Parameters:
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *                OUT pszProvName    - Name of the default provider
 *                IN OUT pcbProvName - Length in bytes of the provider name
 *
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptGetDefaultProviderW(
                                IN DWORD dwProvType,
                                IN DWORD *pdwReserved,
                                IN DWORD dwFlags,
                                OUT LPWSTR pszProvName,
                                IN OUT DWORD *pcbProvName
                                )
{
    ANSI_STRING         AnsiString;
    UNICODE_STRING      UnicodeString;
    LPSTR               pszName = NULL;
    DWORD               cbName;
    NTSTATUS            Status;
    BOOL                fRet = CRYPT_FAILED;

    memset(&UnicodeString, 0, sizeof(UnicodeString));

    __try
    {
        memset(&AnsiString, 0, sizeof(AnsiString));

        if (!CryptGetDefaultProviderA(dwProvType,
                                      pdwReserved,
                                      dwFlags,
                                      NULL,
                                      &cbName))
            goto Ret;

        if (NULL == (pszName = LocalAlloc(LMEM_ZEROINIT, cbName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (!CryptGetDefaultProviderA(dwProvType,
                                      pdwReserved,
                                      dwFlags,
                                      pszName,
                                      &cbName))
            goto Ret;

        RtlInitAnsiString(&AnsiString, pszName);

        Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
        if (!NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (NULL == pszProvName)
        {
            *pcbProvName = UnicodeString.Length + sizeof(WCHAR);
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }

        if (*pcbProvName < UnicodeString.Length + sizeof(WCHAR))
        {
            *pcbProvName = UnicodeString.Length + sizeof(WCHAR);
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }

        *pcbProvName = UnicodeString.Length + sizeof(WCHAR);
        memset(pszProvName, 0, *pcbProvName);
        memcpy(pszProvName, UnicodeString.Buffer, UnicodeString.Length);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (UnicodeString.Buffer)
        RtlFreeUnicodeString(&UnicodeString);
    if (pszName)
        LocalFree(pszName);
    return fRet;
}
#else   // WIN95
WINADVAPI
BOOL
WINAPI CryptGetDefaultProviderW(
                                IN DWORD dwProvType,
                                IN DWORD *pdwReserved,
                                IN DWORD dwFlags,
                                OUT LPWSTR pszProvName,
                                IN OUT DWORD *pcbProvName
                                )
{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif   // WIN95

/*
 -      CryptGetDefaultProviderA
 -
 *      Purpose:
 *                Get the default cryptographic provider of the specified
 *                type for either the machine or for the user.
 *
 *
 *      Parameters:
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *                OUT pszProvName    - Name of the default provider
 *                IN OUT pcbProvName - Length in bytes of the provider name
 *                                     including the NULL terminator
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINAPI CryptGetDefaultProviderA(
                                IN DWORD dwProvType,
                                IN DWORD *pdwReserved,
                                IN DWORD dwFlags,
                                OUT LPSTR pszProvName,
                                IN OUT DWORD *pcbProvName
                                )
{
    HKEY        hCurrUser = 0;
    HKEY        hRegKey = 0;
    LONG        err;
    CHAR        *pszValue = NULL;
    DWORD       dwValType;
    CHAR        typebuf[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    DWORD       cbProvName = 0;
    BOOL        fRet = CRYPT_FAILED;

    __try
    {
        if (dwProvType == 0 || dwProvType > 999 || pdwReserved != NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if ((dwFlags & ~(CRYPT_MACHINE_DEFAULT | CRYPT_USER_DEFAULT)) ||
            ((dwFlags & CRYPT_MACHINE_DEFAULT) && (dwFlags & CRYPT_USER_DEFAULT)))
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        if (dwFlags & CRYPT_USER_DEFAULT)
        {
            if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                            strlen(szusertype) + 5 + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            strcpy(pszValue, szusertype);
            __ltoa(dwProvType, typebuf);
            strcat(pszValue, &typebuf[5]);

#ifndef WIN95
            if (!NT_SUCCESS(RtlOpenCurrentUser(KEY_READ, &hCurrUser)))
            {
                LocalFree(pszValue);
                goto TryMachineSettings;
            }

            if ((err = RegOpenKeyEx(hCurrUser,
                            (const char *) pszValue,
                            0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
            {
                NtClose(hCurrUser);
                LocalFree(pszValue);
                goto TryMachineSettings;
            }
            NtClose(hCurrUser);
#else
            if ((err = RegOpenKeyEx(HKEY_CURRENT_USER,
                            (const char *) pszValue,
                            0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
            {
                LocalFree(pszValue);
                goto TryMachineSettings;
            }
            RegCloseKey(HKEY_CURRENT_USER);
#endif
        }

        if (dwFlags & CRYPT_MACHINE_DEFAULT)
        {
TryMachineSettings:
            if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                            strlen(szmachinetype) + 5 + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            strcpy(pszValue, szmachinetype);
            __ltoa(dwProvType, typebuf);
            strcat(pszValue, &typebuf[5]);

            if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            (const char *) pszValue,
                            0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
        }

        if ((err = RegQueryValueEx(hRegKey, "Name", 0L, &dwValType,
                        NULL,
                        &cbProvName)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pszProvName)
        {
            *pcbProvName = cbProvName;
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }

        if (cbProvName > *pcbProvName)
        {
            *pcbProvName = cbProvName;
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }

        if ((err = RegQueryValueEx(hRegKey, "Name", 0L, &dwValType,
                        (BYTE*)pszProvName,
                        &cbProvName)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        *pcbProvName = cbProvName;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;

Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (pszValue)
        LocalFree(pszValue);
    return fRet;
}

#ifndef WIN95
/*
 -      CryptEnumProviderTypesW
 -
 *      Purpose:
 *                Enumerate the provider types.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the provider types to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - Pointer to the provider type
 *                OUT pszTypeName    - Name of the enumerated provider type
 *                IN OUT pcbTypeName - Length of the enumerated provider type
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProviderTypesW(
                               IN DWORD dwIndex,
                               IN DWORD *pdwReserved,
                               IN DWORD dwFlags,
                               OUT DWORD *pdwProvType,
                               OUT LPWSTR pszTypeName,
                               IN OUT DWORD *pcbTypeName
                               )
{
    ANSI_STRING     AnsiString;
    UNICODE_STRING  UnicodeString;
    LPSTR           pszTmpTypeName = NULL;
    DWORD           cbTmpTypeName = 0;
    NTSTATUS        Status;
    BOOL            fRet = CRYPT_FAILED;

    memset(&UnicodeString, 0, sizeof(UnicodeString));

    __try
    {
        memset(&AnsiString, 0, sizeof(AnsiString));

        *pcbTypeName = 0;

        if (!CryptEnumProviderTypesA(dwIndex,
                                     pdwReserved,
                                     dwFlags,
                                     pdwProvType,
                                     NULL,
                                     &cbTmpTypeName))
            goto Ret;

        if (NULL == (pszTmpTypeName = LocalAlloc(LMEM_ZEROINIT, cbTmpTypeName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (!CryptEnumProviderTypesA(dwIndex,
                                     pdwReserved,
                                     dwFlags,
                                     pdwProvType,
                                     pszTmpTypeName,
                                     &cbTmpTypeName))
            goto Ret;

        if (0 != cbTmpTypeName)
        {
            RtlInitAnsiString(&AnsiString, pszTmpTypeName);

            Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
            if ( !NT_SUCCESS(Status))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            // check if caller is asking for length, in addition the name of the provider
            // may not be available, in this case a name length of 0 is returned
            if ((NULL == pszTypeName) || (0 == cbTmpTypeName))
            {
                *pcbTypeName = UnicodeString.Length + sizeof(WCHAR);
                fRet = CRYPT_SUCCEED;
                goto Ret;
            }

            *pcbTypeName = UnicodeString.Length + sizeof(WCHAR);
            if (*pcbTypeName < UnicodeString.Length + sizeof(WCHAR))
            {
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }

            memset(pszTypeName, 0, *pcbTypeName);
            memcpy(pszTypeName, UnicodeString.Buffer, UnicodeString.Length);
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (UnicodeString.Buffer)
        RtlFreeUnicodeString(&UnicodeString);
    if (pszTmpTypeName)
        LocalFree(pszTmpTypeName);
    return fRet;
}
#else   // WIN95
WINADVAPI
BOOL
WINAPI CryptEnumProviderTypesW(
                               IN DWORD dwIndex,
                               IN DWORD *pdwReserved,
                               IN DWORD dwFlags,
                               OUT DWORD *pdwProvType,
                               OUT LPWSTR pszTypeName,
                               IN OUT DWORD *pcbTypeName
                               )
{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif   // WIN95

/*
 -      CryptEnumProviderTypesA
 -
 *      Purpose:
 *                Enumerate the provider types.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the provider types to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - Pointer to the provider type
 *                OUT pszTypeName    - Name of the enumerated provider type
 *                IN OUT pcbTypeName - Length of the enumerated provider type
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProviderTypesA(
                               IN DWORD dwIndex,
                               IN DWORD *pdwReserved,
                               IN DWORD dwFlags,
                               OUT DWORD *pdwProvType,
                               OUT LPSTR pszTypeName,
                               IN OUT DWORD *pcbTypeName
                               )
{
    HKEY        hRegKey = 0;
    HKEY        hTypeKey = 0;
    LONG        err;
    CHAR        *pszRegKeyName = NULL;
    DWORD       cbClass;
    FILETIME    ft;
    CHAR        rgcType[] = {'T', 'y', 'p', 'e', ' '};
    LPSTR       pszValue;
    long        Type;
    DWORD       cSubKeys;
    DWORD       cbMaxKeyName;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       cbMaxValName;
    DWORD       cbMaxValData;
    DWORD       cbTmpTypeName = 0;
    DWORD       dwValType;
    BOOL        fRet = CRYPT_FAILED;

    __try
    {
        if (NULL != pdwReserved)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 != dwFlags)
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                 (const char *) szprovidertypes,
                                                 0L,
                                                 KEY_READ,
                                                 &hRegKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegQueryInfoKey(hRegKey,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    &cSubKeys,
                                                    &cbMaxKeyName,
                                                    &cbMaxClass,
                                                    &cValues,
                                                    &cbMaxValName,
                                                    &cbMaxValData,
                                                    NULL,
                                                    &ft)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        cbMaxKeyName += sizeof(CHAR);

        if (NULL == (pszRegKeyName = LocalAlloc(LMEM_ZEROINIT, cbMaxKeyName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegEnumKeyEx(hRegKey,
                                                 dwIndex, pszRegKeyName, &cbMaxKeyName, NULL,
                                                 NULL, &cbClass, &ft)))
        {
            if (ERROR_NO_MORE_ITEMS == err)
            {
                SetLastError((DWORD)err);
            }
            else
            {
                SetLastError((DWORD)NTE_FAIL);
            }
            goto Ret;
        }

        if (memcmp(pszRegKeyName, rgcType, sizeof(rgcType)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        pszValue = pszRegKeyName + sizeof(rgcType);
#ifdef WIN95
        if (0 == (Type = StrToL(pszValue)))
#else
        if (0 == (Type = atol(pszValue)))
#endif
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        *pdwProvType = (DWORD)Type;

        // check for the type name
        if (ERROR_SUCCESS != (err = RegOpenKeyEx(hRegKey,
                                                 (const char *)pszRegKeyName,
                                                 0L,
                                                 KEY_READ,
                                                 &hTypeKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        if ((err = RegQueryValueEx(hTypeKey, "TypeName", 0L, &dwValType,
                        NULL, &cbTmpTypeName)) != ERROR_SUCCESS)
        {
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }

        if (NULL == pszTypeName)
        {
            *pcbTypeName = cbTmpTypeName;
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }
        else if (*pcbTypeName < cbTmpTypeName)
        {
            *pcbTypeName = cbTmpTypeName;
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }

        if ((err = RegQueryValueEx(hTypeKey, "TypeName", 0L, &dwValType,
                        (BYTE*)pszTypeName, &cbTmpTypeName)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        *pcbTypeName = cbTmpTypeName;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (hTypeKey)
        RegCloseKey(hTypeKey);
    if (pszRegKeyName)
        LocalFree(pszRegKeyName);
    return fRet;
}

#ifndef WIN95
/*
 -      CryptEnumProvidersW
 -
 *      Purpose:
 *                Enumerate the providers.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the providers to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - The type of the provider
 *                OUT pszProvName    - Name of the enumerated provider
 *                IN OUT pcbProvName - Length of the enumerated provider
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProvidersW(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPWSTR pszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
    ANSI_STRING     AnsiString;
    UNICODE_STRING  UnicodeString;
    LPSTR           pszTmpProvName = NULL;
    DWORD           cbTmpProvName;
    NTSTATUS        Status;
    BOOL            fRet = CRYPT_FAILED;

    memset(&UnicodeString, 0, sizeof(UnicodeString));

    __try
    {
        memset(&AnsiString, 0, sizeof(AnsiString));

        if (!CryptEnumProvidersA(dwIndex,
                                 pdwReserved,
                                 dwFlags,
                                 pdwProvType,
                                 NULL,
                                 &cbTmpProvName))
            goto Ret;

        if (NULL == (pszTmpProvName = LocalAlloc(LMEM_ZEROINIT, cbTmpProvName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (!CryptEnumProvidersA(dwIndex,
                                 pdwReserved,
                                 dwFlags,
                                 pdwProvType,
                                 pszTmpProvName,
                                 &cbTmpProvName))
            goto Ret;

        RtlInitAnsiString(&AnsiString, pszTmpProvName);

        Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
        if ( !NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (NULL == pszProvName)
        {
            *pcbProvName = UnicodeString.Length + sizeof(WCHAR);
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }

        *pcbProvName = UnicodeString.Length + sizeof(WCHAR);
        if (*pcbProvName < UnicodeString.Length + sizeof(WCHAR))
        {
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }

        memset(pszProvName, 0, *pcbProvName);
        memcpy(pszProvName, UnicodeString.Buffer, UnicodeString.Length);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (UnicodeString.Buffer)
        RtlFreeUnicodeString(&UnicodeString);
    if (pszTmpProvName)
        LocalFree(pszTmpProvName);
    return fRet;
}
#else   // WIN95
WINADVAPI
BOOL
WINAPI CryptEnumProvidersW(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPWSTR pszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif   // WIN95

/*
 -      CryptEnumProvidersA
 -
 *      Purpose:
 *                Enumerate the providers.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the providers to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - The type of the provider
 *                OUT pszProvName    - Name of the enumerated provider
 *                IN OUT pcbProvName - Length of the enumerated provider
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProvidersA(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPSTR pszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
    HKEY        hRegKey = 0;
    HKEY        hProvRegKey = 0;
    LONG        err;
    DWORD       cbClass;
    FILETIME    ft;
    DWORD       dwKeyType;
    DWORD       cbProvType;
    DWORD       dw;
    DWORD       cSubKeys;
    DWORD       cbMaxKeyName;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       cbMaxValName;
    DWORD       cbMaxValData;
    LPSTR       pszTmpProvName = NULL;
    DWORD       cbTmpProvName;
    BOOL        fRet = CRYPT_FAILED;

    __try
    {
        if (NULL != pdwReserved)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 != dwFlags)
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                 (const char *) szenumproviders,
                                                 0L, KEY_READ, &hRegKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegQueryInfoKey(hRegKey,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    &cSubKeys,
                                                    &cbMaxKeyName,
                                                    &cbMaxClass,
                                                    &cValues,
                                                    &cbMaxValName,
                                                    &cbMaxValData,
                                                    NULL,
                                                    &ft)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        cbMaxKeyName += sizeof(CHAR);

        if (NULL == (pszTmpProvName = LocalAlloc(LMEM_ZEROINIT, cbMaxKeyName)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegEnumKeyEx(hRegKey, dwIndex, pszTmpProvName,
                                                 &cbMaxKeyName, NULL,
                                                 NULL, &cbClass, &ft)))
        {
            SetLastError((DWORD)err);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyEx(hRegKey,
                                                 (const char *) pszTmpProvName,
                                                 0L, KEY_READ, &hProvRegKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        cbProvType = sizeof(dw);
        if (ERROR_SUCCESS != (err = RegQueryValueEx(hProvRegKey,
                                                    (const char *) "Type",
                                                    NULL, &dwKeyType, (BYTE*)&dw,
                                                    &cbProvType)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        *pdwProvType = dw;

        cbTmpProvName = strlen(pszTmpProvName) + sizeof(CHAR);

        if (NULL != pszProvName)
        {
            if (*pcbProvName < cbTmpProvName)
            {
                *pcbProvName = cbTmpProvName;
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            strcpy(pszProvName, pszTmpProvName);
        }

        *pcbProvName = cbTmpProvName;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (pszTmpProvName)
        LocalFree(pszTmpProvName);
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (hProvRegKey)
        RegCloseKey(hProvRegKey);
    return fRet;
}

BOOL EnterProviderCritSec(IN PVTableStruc pVTable)
{
    __try
    {
        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement((LPLONG)&pVTable->Inuse);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);
Try_Error_Return:
    return(CRYPT_FAILED);
}


void LeaveProviderCritSec(IN PVTableStruc pVTable)
{
    InterlockedDecrement((LPLONG)&pVTable->Inuse);
}

BOOL EnterKeyCritSec(IN PVKeyStruc pVKey)
{

    __try
    {
        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement((LPLONG)&pVKey->Inuse);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);
Try_Error_Return:
    return(CRYPT_FAILED);

}


void LeaveKeyCritSec(IN PVKeyStruc pVKey)
{
    InterlockedDecrement((LPLONG)&pVKey->Inuse);
}

BOOL EnterHashCritSec(IN PVHashStruc pVHash)
{

    __try
    {
        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement((LPLONG)&pVHash->Inuse);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);

Try_Error_Return:
    return(CRYPT_FAILED);

}


void LeaveHashCritSec(IN PVHashStruc pVHash)
{
    InterlockedDecrement((LPLONG)&pVHash->Inuse);
}


BOOL BuildVKey(IN PVKeyStruc *ppVKey,
               IN PVTableStruc pVTable)
{
    DWORD           bufsize;
    PVKeyStruc pVKey;

    bufsize = sizeof(VKeyStruc);

    if ((pVKey = (PVKeyStruc) LocalAlloc(LMEM_ZEROINIT,
                                         (UINT) bufsize)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(CRYPT_FAILED);
    }

    pVKey->FuncGenKey = pVTable->FuncGenKey;
    pVKey->FuncDeriveKey = pVTable->FuncDeriveKey;
    pVKey->FuncDestroyKey = pVTable->FuncDestroyKey;
    pVKey->FuncSetKeyParam = pVTable->FuncSetKeyParam;
    pVKey->FuncGetKeyParam = pVTable->FuncGetKeyParam;
    pVKey->FuncExportKey = pVTable->FuncExportKey;
    pVKey->FuncImportKey = pVTable->FuncImportKey;
    pVKey->FuncEncrypt = pVTable->FuncEncrypt;
    pVKey->FuncDecrypt = pVTable->FuncDecrypt;

    pVKey->OptionalFuncDuplicateKey = pVTable->OptionalFuncDuplicateKey;

    pVKey->hProv = pVTable->hProv;

    *ppVKey = pVKey;

    return(CRYPT_SUCCEED);
}

BOOL BuildVHash(
                IN PVHashStruc *ppVHash,
                IN PVTableStruc pVTable
                )
{
    DWORD           bufsize;
    PVHashStruc     pVHash;


    bufsize = sizeof(VHashStruc);

    if ((pVHash = (PVHashStruc) LocalAlloc(LMEM_ZEROINIT, (UINT) bufsize)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(CRYPT_FAILED);
    }

    pVHash->FuncCreateHash = pVTable->FuncCreateHash;
    pVHash->FuncHashData = pVTable->FuncHashData;
    pVHash->FuncHashSessionKey = pVTable->FuncHashSessionKey;
    pVHash->FuncDestroyHash = pVTable->FuncDestroyHash;
    pVHash->FuncSignHash = pVTable->FuncSignHash;
    pVHash->FuncVerifySignature = pVTable->FuncVerifySignature;
    pVHash->FuncGetHashParam = pVTable->FuncGetHashParam;
    pVHash->FuncSetHashParam = pVTable->FuncSetHashParam;

    pVHash->OptionalFuncDuplicateHash = pVTable->OptionalFuncDuplicateHash;

    pVHash->hProv = (HCRYPTPROV)pVTable;

    *ppVHash = pVHash;

    return(CRYPT_SUCCEED);
}

#define RC4_KEYSIZE 5

void EncryptKey(BYTE *pdata, DWORD size, BYTE val)
{
    RC4_KEYSTRUCT key;
    BYTE          RealKey[RC4_KEYSIZE] = {0xa2, 0x17, 0x9c, 0x98, 0xca};
    DWORD         index;

    for (index = 0; index < RC4_KEYSIZE; index++)
    {
        RealKey[index] ^= val;
    }

    rc4_key(&key, RC4_KEYSIZE, RealKey);

    rc4(&key, size, pdata);

}

void MD5HashData(
                 BYTE *pb,
                 DWORD cb,
                 BYTE *pbHash
                 )
{
    MD5_CTX     HashState;

    MD5Init(&HashState);

    __try
    {
        MD5Update(&HashState, pb, cb);
    } __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        return;
    }

    // Finish the hash
    MD5Final(&HashState);

    memcpy(pbHash, HashState.digest, 16);
}

BOOL CheckSignature(
                    BYTE *pbKey,
                    DWORD cbKey,
                    BYTE *pbSig,
                    DWORD cbSig,
                    BYTE *pbHash,
                    BOOL fUnknownLen)
{
    BYTE                rgbResult[KEYSIZE1024];
    BYTE                rgbSig[KEYSIZE1024];
    BYTE                rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE                rgbKeyHash[16];
    BYTE                *pbSecondKey;
    DWORD               cbSecondKey;
    BYTE                *pbKeySig;
    PSECOND_TIER_SIG    pSecondTierSig;
    LPBSAFE_PUB_KEY     pTmp;
    BOOL                fRet = FALSE;

    memset(rgbResult, 0, KEYSIZE1024);
    memset(rgbSig, 0, KEYSIZE1024);

    // just check the straight signature if version is 1
    pTmp = (LPBSAFE_PUB_KEY)pbKey;

    // check if sig length is the same as the key length
    if (fUnknownLen || (cbSig == pTmp->keylen))
    {
        memcpy(rgbSig, pbSig, pTmp->keylen);
        BSafeEncPublic(pTmp, rgbSig, rgbResult);

        if (RtlEqualMemory(pbHash, rgbResult, 16) &&
            rgbResult[cbKey-1] == 0 &&
            rgbResult[cbKey-2] == 1 &&
            rgbResult[16] == 0 &&
            rgbResult[17] == 0xFF)
        {
            fRet = TRUE;
            goto Ret;
        }
    }

    // check the the second tier signature if the magic equals 2
    pSecondTierSig = (PSECOND_TIER_SIG)pbSig;
    if (0x00000002 != pSecondTierSig->dwMagic)
        goto Ret;

    if (0x31415352 != pSecondTierSig->Pub.magic)
        goto Ret;

    // assign the pointers
    cbSecondKey = sizeof(BSAFE_PUB_KEY) + pSecondTierSig->Pub.keylen;
    pbSecondKey = pbSig + (sizeof(SECOND_TIER_SIG) - sizeof(BSAFE_PUB_KEY));
    pbKeySig = pbSecondKey + cbSecondKey;

    // hash the second tier key
    MD5HashData(pbSecondKey, cbSecondKey, rgbKeyHash);

    // Decrypt the signature data on the second tier key
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));
    memcpy(rgbSig, pbKeySig, pSecondTierSig->cbSig);
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if ((FALSE == RtlEqualMemory(rgbKeyHash, rgbResult, 16)) ||
        rgbResult[cbKey-1] != 0 ||
        rgbResult[cbKey-2] != 1 ||
        rgbResult[16] != 0 ||
        rgbResult[17] != 0)
    {
        goto Ret;
    }

    // Decrypt the signature data on the CSP
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));
    memset(rgbKey, 0, sizeof(rgbKey));
    memcpy(rgbSig, pbKeySig + pSecondTierSig->cbSig, pSecondTierSig->cbSig);
    memcpy(rgbKey, pbSecondKey, cbSecondKey);
    pTmp = (LPBSAFE_PUB_KEY)rgbKey;
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if (RtlEqualMemory(pbHash, rgbResult, 16) &&
        rgbResult[pTmp->keylen-1] == 0 &&
        rgbResult[pTmp->keylen-2] == 1 &&
        rgbResult[16] == 0)
    {
        fRet = TRUE;
    }
Ret:
    return fRet;
}

// Given hInst, allocs and returns pointers to signature pulled from
// resource
BOOL GetCryptSigResourcePtr(
                            HMODULE hInst,
                            BYTE **ppbRsrcSig,
                            DWORD *pcbRsrcSig
                            )
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResource(hInst, OLD_CRYPT_SIG_RESOURCE_NUMBER,
                                      RT_RCDATA)))
        goto Ret;

    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcSig = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcSig = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

#define CSP_TO_BE_HASHED_CHUNK  4096

// Given hFile, reads the specified number of bytes (cbToBeHashed) from the file
// and hashes these bytes.  The function does this in chunks.
BOOL HashBytesOfFile(
                     IN HANDLE hFile,
                     IN DWORD cbToBeHashed,
                     IN OUT MD5_CTX *pMD5Hash
                     )
{
    BYTE    rgbChunk[CSP_TO_BE_HASHED_CHUNK];
    DWORD   cbRemaining = cbToBeHashed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;
    BOOL    fRet = FALSE;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_HASHED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_HASHED_CHUNK;

        if(!ReadFile(hFile, rgbChunk, cbToRead, &dwBytesRead, NULL))
            goto Ret;
        if (dwBytesRead != cbToRead)
            goto Ret;

        MD5Update(pMD5Hash, rgbChunk, dwBytesRead);
        cbRemaining -= cbToRead;
    }

    fRet = TRUE;
Ret:
    return fRet;
}

BOOL HashTheFile(
                 LPCWSTR pszImage,
                 DWORD cbImage,
                 BYTE **ppbSig,
                 DWORD *pcbSig,
                 BYTE *pbHash
                 )
{
    HMODULE                     hInst;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcSig;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart = NULL;
    BYTE                        *pbZeroSig = NULL;
    MD5_CTX                     MD5Hash;
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToSig;   // number of bytes from CRC to sig
    DWORD                       cbPostSig;    // size - (already hashed + signature size)
    BYTE                        *pbPostSig;
    DWORD                       *pdwSigInFileVer;
    DWORD                       *pdwCRCOffset;
    DWORD                       dwCRCOffset;
    DWORD                       dwZeroCRC = 0;
    HANDLE                      File = INVALID_HANDLE_VALUE ;
    HANDLE                      hMapping = NULL;
    BOOL                        fRet = FALSE;

    memset(&MD5Hash, 0, sizeof(MD5Hash));
    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file

    File = CreateFileW(
                pszImage,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL );

    if ( File == INVALID_HANDLE_VALUE )
    {
        goto Ret ;
    }

    hMapping = CreateFileMapping( File,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL);
    if(hMapping == NULL)
    {
        goto Ret;
    }

    pbStart = MapViewOfFile(hMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0);
    if(pbStart == NULL)
    {
        goto Ret;
    }

    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    hInst = (HMODULE)((ULONG_PTR)pbStart | 0x00000001);

    // the resources signature
    if (!GetCryptSigResourcePtr(hInst, &pbRsrcSig, &cbRsrcSig))
        goto Ret;

    if (cbRsrcSig < (sizeof(DWORD) * 2))
        goto Ret;

    // check the sig in file version and get the CRC offset
    pdwSigInFileVer = (DWORD*)pbRsrcSig;
    pdwCRCOffset = (DWORD*)(pbRsrcSig + sizeof(DWORD));
    dwCRCOffset = *pdwCRCOffset;
    if ((0x00000100 != *pdwSigInFileVer) || (dwCRCOffset > cbImage))
        goto Ret;

    // create a zero byte signature
    if (NULL == (pbZeroSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, cbRsrcSig)))
        goto Ret;
    memcpy(pbZeroSig, pbRsrcSig, sizeof(DWORD) * 2);

    pbPostCRC = pbStart + *pdwCRCOffset + sizeof(DWORD);
    cbCRCToSig = (DWORD)(pbRsrcSig - pbPostCRC);
    pbPostSig = pbRsrcSig + cbRsrcSig;
    cbPostSig = (cbImage - (DWORD)(pbPostSig - pbStart));

    // allocate the real signature and copy the resource sig into the real sig
    *pcbSig = cbRsrcSig - (sizeof(DWORD) * 2);
    if (NULL == (*ppbSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, *pcbSig)))
        goto Ret;

    memcpy(*ppbSig, pbRsrcSig + (sizeof(DWORD) * 2), *pcbSig);

    // hash over the relevant data
    MD5Init(&MD5Hash);

    // hash up to the CRC
    if (!HashBytesOfFile(File, dwCRCOffset, &MD5Hash))
        goto Ret;

    // pretend CRC is zeroed
    MD5Update(&MD5Hash, (BYTE*)&dwZeroCRC, sizeof(DWORD));
    if (!SetFilePointer(File, sizeof(DWORD), NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // hash from CRC to sig resource
    if (!HashBytesOfFile(File, cbCRCToSig, &MD5Hash))
        goto Ret;

    // pretend image has zeroed sig
    MD5Update(&MD5Hash, pbZeroSig, cbRsrcSig);
    if (!SetFilePointer(File, cbRsrcSig, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // hash after the sig resource
    if (!HashBytesOfFile(File, cbPostSig, &MD5Hash))
        goto Ret;

    // Finish the hash
    MD5Final(&MD5Hash);

    memcpy(pbHash, MD5Hash.digest, MD5DIGESTLEN);

    fRet = TRUE;
Ret:
    if (pbZeroSig)
        LocalFree(pbZeroSig);
    if(pbStart)
        UnmapViewOfFile(pbStart);
    if(hMapping)
        CloseHandle(hMapping);
    if ( File != INVALID_HANDLE_VALUE )
    {
        CloseHandle( File );
    }

    return fRet;
}


/*
 -      CheckAllSignatures
 -
 *      Purpose:
 *                Check signature against all keys
 *
 *
 *      Returns:
 *                BOOL
 */
BOOL CheckAllSignatures(
                        BYTE *pbSig,
                        DWORD cbSig,
                        BYTE *pbHash,
                        BOOL fUnknownLen
                        )
{
    BYTE        rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE        rgbKey2[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
#ifdef MS_INTERNAL_KEY
    BYTE        rgbMSKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
#endif
#ifdef TEST_BUILD_EXPONENT
    BYTE        rgbTestKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE512];
#endif
    BOOL        fRet = FALSE;

    // decrypt the keys once for each process
    memcpy(rgbKey, (BYTE*)&KEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 0);

#ifdef MS_INTERNAL_KEY
    memcpy(rgbMSKey, (BYTE*)&MSKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbMSKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 1);
#endif
    memcpy(rgbKey2, (BYTE*)&KEY2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 2);

#ifdef TEST_BUILD_EXPONENT
    memcpy(rgbTestKey, (BYTE*)&TESTKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE512);
    EncryptKey(rgbTestKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE512, 3);
#endif // TEST_BUILD_EXPONENT

    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbKey, 128, pbSig,
                                                cbSig, pbHash, fUnknownLen)))
    {
        fRet = TRUE;
        goto Ret;
    }

#ifdef MS_INTERNAL_KEY
    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbMSKey, 128, pbSig,
                                                cbSig, pbHash, fUnknownLen)))
    {
        fRet = TRUE;
        goto Ret;
    }
#endif

    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbKey2, 128, pbSig,
                                                cbSig, pbHash, fUnknownLen)))
    {
        fRet = TRUE;
        goto Ret;
    }

#ifdef TEST_BUILD_EXPONENT
    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbTestKey, 64, pbSig,
                                                cbSig, pbHash, fUnknownLen)))
    {
        fRet = TRUE;
        goto Ret;
    }
#endif // TEST_BUILD_EXPONENT

Ret:
    return fRet;
}

/*
 -      CheckSignatureInFile
 -
 *      Purpose:
 *                Check signature which is in the resource in the file
 *
 *
 *      Parameters:
 *                IN pszImage       - address of file
 *
 *      Returns:
 *                BOOL
 */
BOOL CheckSignatureInFile(
        LPCWSTR pszImage)
{
    DWORD       cbImage;
    BYTE        *pbSig = NULL;
    DWORD       cbSig;
    BYTE        rgbHash[MD5DIGESTLEN];
//  DWORD       cbHash;
    BOOL        fRet = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA FileData ;
    WCHAR       FullName[ MAX_PATH ];
    PWSTR       FilePart ;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo;

#ifdef PROMISCUOUS_ADVAPI
#pragma message("WARNING: building promiscuous advapai32.dll!")
    return TRUE;
#endif

    NtQuerySystemInformation(
        SystemKernelDebuggerInformation,
        &KdInfo,
        sizeof(KdInfo),
        NULL);

    // Allow any CSP to load if a Kd is attached 
    // and "responsive"
    if (    TRUE == KdInfo.KernelDebuggerEnabled && 
            FALSE == KdInfo.KernelDebuggerNotPresent)
        return TRUE;

    if ( !SearchPathW(NULL,
                      pszImage,
                      NULL,
                      MAX_PATH,
                      FullName,
                      &FilePart ) )
    {
        goto Ret ;
    }

    if ( !GetFileAttributesExW( FullName,
                               GetFileExInfoStandard,
                               &FileData ) )
    {
        goto Ret ;
    }

    if ( FileData.nFileSizeHigh )
    {
        goto Ret ;
    }

    cbImage = FileData.nFileSizeLow ;

    if (!HashTheFile(FullName, cbImage, &pbSig, &cbSig, rgbHash))
        goto Ret;

    // check signature against all public keys
    if (!CheckAllSignatures(pbSig, cbSig, rgbHash, FALSE))
        goto Ret;

    fRet = TRUE;
Ret:
    if (pbSig)
        LocalFree(pbSig);

    return fRet;
}

/*
 -      NewVerifyImage
 -
 *      Purpose:
 *                Check signature of file
 *
 *
 *      Parameters:
 *                IN lpszImage      - address of file
 *                IN pSigData       - address of signature data
 *                IN cbSig          - length of signature data
 *                IN fUnknownLen    - BOOL to tell if length is not passed in
 *
 *      Returns:
 *                BOOL
 */
BOOL NewVerifyImage(LPCSTR lpszImage,
                    BYTE *pSigData,
                    DWORD cbSig,
                    BOOL fUnknownLen)
{
    HFILE       hFileProv = HFILE_ERROR;
    DWORD       NumBytes;
    DWORD       lpdwFileSizeHigh;
    MD5_CTX     HashState;
    OFSTRUCT    ImageInfoBuf;
    BOOL        fRet = CRYPT_FAILED;

    memset(&HashState, 0, sizeof(HashState));

    if (HFILE_ERROR == (hFileProv = OpenFile(lpszImage, &ImageInfoBuf,
                                             OF_READ)))
    {
        SetLastError((DWORD) NTE_PROV_DLL_NOT_FOUND);
        goto Ret;
    }

    if (0xffffffff == (NumBytes = GetFileSize((HANDLE)IntToPtr(hFileProv),
                                              &lpdwFileSizeHigh)))
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        goto Ret;
    }

    MD5Init(&HashState);

    if (!HashBytesOfFile((HANDLE)IntToPtr(hFileProv), NumBytes, &HashState))
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        goto Ret;
    }
    MD5Final(&HashState);

    // check the signature against all keys
    if (!CheckAllSignatures(pSigData, cbSig, HashState.digest, fUnknownLen))
    {
        SetLastError((DWORD) NTE_BAD_SIGNATURE);
        goto Ret;
    }
    fRet = TRUE;
Ret:
    if (HFILE_ERROR != hFileProv)
        _lclose(hFileProv);

    return fRet;
}

/*
 -      CProvVerifyImage
 -
 *      Purpose:
 *                Check signature of file
 *
 *
 *      Parameters:
 *                IN lpszImage      - address of file
 *                IN lpSigData      - address of signature data
 *
 *      Returns:
 *                BOOL
 */
BOOL CProvVerifyImage(LPCSTR lpszImage,
                      BYTE *pSigData)
{
    UNICODE_STRING String ;
    BOOL Result ;

    if (NULL == pSigData)
    {
        if ( RtlCreateUnicodeStringFromAsciiz( &String, lpszImage ) )
        {
            Result = CheckSignatureInFile( String.Buffer );

            RtlFreeUnicodeString( &String );
        }
        else
        {
            Result = FALSE ;
        }
    }
    else
    {
        Result = NewVerifyImage(lpszImage, pSigData, 0, TRUE);
    }

    return Result;
}

/*
 -      CPReturnhWnd
 -
 *      Purpose:
 *                Return a window handle back to a CSP
 *
 *
 *      Parameters:
 *                OUT phWnd      - pointer to a hWnd to return
 *
 *      Returns:
 *                void
 */
void CPReturnhWnd(HWND *phWnd)
{
    __try
    {

        *phWnd = hWnd;

    } __except ( EXCEPTION_EXECUTE_HANDLER )
    { ; }

    return;
}

static void __ltoa(DWORD val, char *buf)
{
    char *p;            /* pointer to traverse string */
    char *firstdig;     /* pointer to first digit */
    char temp;          /* temp char */
    unsigned digval;    /* value of digit */
    int  i;

    p = buf;

    firstdig = p;       /* save pointer to first digit */

    for (i = 0; i < 8; i++) {
        digval = (unsigned) (val % 10);
        val /= 10;      /* get next digit */

        /* convert to ascii and store */
        *p++ = (char) (digval + '0');    /* a digit */
    }

    /* We now have the digit of the number in the buffer, but in reverse
       order.  Thus we reverse them now. */

    *p-- = '\0';                /* terminate string; p points to last digit */

    do {
        temp = *p;
        *p = *firstdig;
        *firstdig = temp;       /* swap *p and *firstdig */
        --p;
        ++firstdig;             /* advance to next two digits */
    } while (firstdig < p); /* repeat until halfway */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#ifdef __cplusplus
    extern "C" 
    {
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#define DBG_SS_CRYPT32                      0x00000001

#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000
#define DBG_SS_CATDBSVC                     0x00800000

#define DBG_SS_APP                          0x10000000

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                DBG_SS_CATDBSVC,    "CATDBSV",  \
                                NULL, NULL                      \
                            }

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG 

	void DbgPrintf( DWORD dwSubSysId, LPCSTR lpFmt, ...);


#   define DBG_TRACE_EX(argFmt) DbgPrintf argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_CRYPT32,argFmt))

#   define DBG_PRINTF(args)     DbgPrintf args

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#   define DBG_PRINTF(args)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define SET_DWRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    dwResult = (DWORD) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_CRYPT32,name)
#define SET_ERROR(name,err)             SET_ERROR_EX(DBG_SS_CRYPT32,name,err)
#define SET_ERROR_VAR(name,err)         SET_ERROR_VAR_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT(name,err)           SET_HRESULT_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT_VAR(name,err)       SET_HRESULT_VAR_EX(DBG_SS_CRYPT32,name,err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_CRYPT32,name)
#define SET_DWRESULT(name,err)          SET_DWRESULT_EX(DBG_SS_CRYPT32,name,err)


#define _JumpCondition(condition, label) \
    if (condition) \
    { \
	goto label; \
    } \
    else { } 

#define _JumpConditionWithExpr(condition, label, expr) \
    if (condition) \
    { \
        expr; \
	goto label; \
    } \
    else { } 

#ifdef __cplusplus
    }       // balance of extern "C"
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\efs.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efs.c

Abstract:

    EFS (Encrypting File System) API Interfaces

Author:

    Robert Reichel      (RobertRe)
    Robert Gu           (RobertG)

Environment:

Revision History:

--*/

#undef WIN32_LEAN_AND_MEAN

#include "advapi.h"
#include <windows.h>
#include <feclient.h>

#define FE_CLIENT_DLL      L"feclient.dll"


//
// Global Variables
//

LPFE_CLIENT_INFO    FeClientInfo   = NULL;
HMODULE             FeClientModule = NULL;
CRITICAL_SECTION    FeClientLoadCritical;


LPWSTR
GetFeClientDll(
    VOID
    )
/*++

Routine Description:

    This routine obtains the name of the currently installed client
    encryption dll (which is currently hardcoded).

Arguments:

    None.

Return Value:

    Returns the name of the current DLL, or NULL on error.

--*/

{
    return( FE_CLIENT_DLL );
}


BOOL
LoadAndInitFeClient(
    VOID
    )

/*++

Routine Description:

    This routine finds the name of the proper client dll (by some as of
    yet unspecified means) and proceeds to load it and initialize it.

Arguments:

    None.

Return Value:

    TRUE on success, FALSE on failure.  Callers may call GetLastError()
    for more error information.

--*/
{
    LPWSTR FeClientDllName;
    LPFEAPI_CLIENT_INITIALIZE ClientInitRoutine;
    BOOL Inited;

    //
    // GetFeClientDll returns a hard coded name.
    // If we get this name dynamically later, we will
    // need to free FeClientDllName.
    //


    FeClientDllName = GetFeClientDll();

    EnterCriticalSection(&FeClientLoadCritical);
    if (FeClientInfo) {
       LeaveCriticalSection(&FeClientLoadCritical);
       return( TRUE );
    }
    if (FeClientDllName) {
        FeClientModule = LoadLibraryW( FeClientDllName );
        if (FeClientModule == NULL) {
            DbgPrint("Unable to load client dll, error = %d\n",GetLastError());
            LeaveCriticalSection(&FeClientLoadCritical);
            return( FALSE );
        }
    }

    ClientInitRoutine = (LPFEAPI_CLIENT_INITIALIZE) GetProcAddress( FeClientModule, (LPCSTR)"FeClientInitialize");



    if (NULL == ClientInitRoutine) {
        FreeLibrary( FeClientModule );
        DbgPrint("Unable to locate init routine, error = %d\n",GetLastError());
        LeaveCriticalSection(&FeClientLoadCritical);
        return( FALSE );
    }

    Inited = (*ClientInitRoutine)( FE_REVISION_1_0, &FeClientInfo );

    LeaveCriticalSection(&FeClientLoadCritical);
    if (!Inited) {
        FreeLibrary( FeClientModule );
        return( FALSE );
    }

    return( TRUE );
}

BOOL
WINAPI
EncryptFileA (
    LPCSTR lpFileName
    )
/*++

Routine Description:

    ANSI Stub to EncryptFileW

Arguments:

    lpFileName - The name of the file to be encrypted.

Return Value:

    TRUE on success, FALSE on failure.  Callers may call GetLastError()
    for more information.

--*/
{
    UNICODE_STRING Unicode;
    WCHAR UnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode.Length = 0;
    Unicode.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof( WCHAR );
    Unicode.Buffer = UnicodeBuffer;

    RtlInitAnsiString(&AnsiString,lpFileName);
    Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return ( EncryptFileW( Unicode.Buffer ));

}


BOOL
WINAPI
EncryptFileW (
    LPCWSTR lpFileName
    )
/*++

Routine Description:

    Win32 EncryptFile API

Arguments:

    lpFileName - Supplies the name of the file to be encrypted.

Return Value:

    TRUE on success, FALSE on failure.  Callers may call GetLastError()
    for more information.

--*/
{
    BOOL rc;
    DWORD Result;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    Result = FeClientInfo->lpServices->EncryptFile( lpFileName );

    if (ERROR_SUCCESS != Result) {
        SetLastError( Result );
        return( FALSE );
    }

    return( TRUE );
}

BOOL
WINAPI
DecryptFileA (
    IN LPCSTR lpFileName,
    IN DWORD  dwRecovery
    )
/*++

Routine Description:

    ANSI Stub for the DecryptFileW API

Arguments:

    lpFileName - Supplies the name of the file to be decrypted.

    dwRecover - Supplies whether this is a recovery operation or a
        normal decryption operation.

Return Value:

    TRUE on success, FALSE on failure.  Callers may call GetLastError()
    for more information.

--*/
{
    UNICODE_STRING Unicode;
    WCHAR UnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode.Length = 0;
    Unicode.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof( WCHAR );
    Unicode.Buffer = UnicodeBuffer;

    RtlInitAnsiString(&AnsiString,lpFileName);
    Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return ( DecryptFileW( Unicode.Buffer, dwRecovery ));
}


BOOL
WINAPI
DecryptFileW (
    IN LPCWSTR lpFileName,
    IN DWORD   dwRecovery
    )
/*++

Routine Description:

    Win32 DecryptFile API

Arguments:

    lpFileName - Supplies the name of the file to be encrypted.

Return Value:

    TRUE on success, FALSE on failure.  Callers may call GetLastError()
    for more information.

--*/
{
    BOOL rc;
    DWORD Result;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    Result = FeClientInfo->lpServices->DecryptFile( lpFileName, dwRecovery );

    if (ERROR_SUCCESS != Result) {
        SetLastError( Result );
        return( FALSE );
    }

    return( TRUE );

}

BOOL
WINAPI
FileEncryptionStatusA (
    LPCSTR    lpFileName,
    LPDWORD   lpStatus
    )
/*++

Routine Description:

    ANSI Stub to FileEncryptionStatusW

Arguments:

    lpFileName - The name of the file to be checked.
    lpStatus - The status of the file.

Return Value:

    TRUE on success, FALSE on failure. Callers may call GetLastError() for more information.

--*/
{
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    UNICODE_STRING Unicode;
    WCHAR UnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];

    Unicode.Length = 0;
    Unicode.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof( WCHAR );
    Unicode.Buffer = UnicodeBuffer;

    RtlInitAnsiString(&AnsiString,lpFileName);
    Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return ( FileEncryptionStatusW( Unicode.Buffer, lpStatus ));

}

BOOL
WINAPI
FileEncryptionStatusW (
    LPCWSTR    lpFileName,
    LPDWORD    lpStatus
    )
/*++

Routine Description:

    Win32 FileEncryptionStatus API

Arguments:

    lpFileName - Supplies the name of the file to be encrypted.
    lpStatus - The status of the file.

Return Value:

    TRUE on success, FALSE on failure. Callers may call GetLastError()
    for more information.

--*/
{

    BOOL rc;
    DWORD Result;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    return (FeClientInfo->lpServices->FileEncryptionStatus( lpFileName, lpStatus ));

}

DWORD
WINAPI
OpenEncryptedFileRawA(
    LPCSTR          lpFileName,
    ULONG           Flags,
    PVOID *         Context
    )
{
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    UNICODE_STRING Unicode;
    WCHAR UnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];

    Unicode.Length = 0;
    Unicode.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof( WCHAR );
    Unicode.Buffer = UnicodeBuffer;

    RtlInitAnsiString(&AnsiString,lpFileName);
    Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return ( OpenEncryptedFileRawW( Unicode.Buffer, Flags, Context ));
}




DWORD
WINAPI
OpenEncryptedFileRawW(
    LPCWSTR         lpFileName,
    ULONG           Flags,
    PVOID *         Context
    )
{
    BOOL rc;
    DWORD Result;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(GetLastError());
        }
    }

    return (FeClientInfo->lpServices->OpenFileRaw( lpFileName, Flags, Context ));
}


DWORD
WINAPI
ReadEncryptedFileRaw(
    PFE_EXPORT_FUNC ExportCallback,
    PVOID           CallbackContext,
    PVOID           Context
    )
{
    //
    // It doesn't make sense to call this before calling OpenRaw, so don't
    // bother checking to see if the module is loaded or not.  We'll fault
    // in the user process if it isn't.
    //

    return (FeClientInfo->lpServices->ReadFileRaw( ExportCallback, CallbackContext, Context ));
}

DWORD
WINAPI
WriteEncryptedFileRaw(
    PFE_IMPORT_FUNC ImportCallback,
    PVOID           CallbackContext,
    PVOID           Context
    )
{
    //
    // It doesn't make sense to call this before calling OpenRaw, so don't
    // bother checking to see if the module is loaded or not.  We'll fault
    // in the user process if it isn't.
    //

    return (FeClientInfo->lpServices->WriteFileRaw( ImportCallback, CallbackContext, Context ));
}

VOID
WINAPI
CloseEncryptedFileRaw(
    PVOID           Context
    )
{
    FeClientInfo->lpServices->CloseFileRaw( Context );

    return;
}


DWORD
QueryUsersOnEncryptedFile(
    IN  LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    )
/*++

Routine Description:

    Win32 interface for adding users to an encrypted file.

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    pUsers - Returns a list of users on the file.  This parameter
        must be passed to FreeEncryptionCertificateHashList() when
        no longer needed.

Return Value:

    Win32 error.

--*/

{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if ((lpFileName != NULL) && (pUsers != NULL)) {
        return(FeClientInfo->lpServices->QueryUsers( lpFileName, pUsers ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}


VOID
FreeEncryptionCertificateHashList(
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pUsers
    )
/*++

Routine Description:

    Frees a certificate hash list as returned by QueryUsersOnEncryptedFile()
    and QueryRecoveryAgentsOnEncryptedFile().

Arguments:

    Supplies a list of users returned from QueryUsersOnEncryptedFile().

Return Value:

    Win32 error.

--*/
{

    //
    // It is probably safe to assume that feclient.dll is loaded,
    // since we wouldn't have one of these structures to free
    // if it weren't.
    //

    if (pUsers != NULL) {
        FeClientInfo->lpServices->FreeCertificateHashList( pUsers );
    } else {

        //
        // nothing to do
        //
    }

    return;
}


DWORD
QueryRecoveryAgentsOnEncryptedFile(
    IN  LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    )
/*++

Routine Description:

    This routine returns a list of recovery agents on an encrypted
    file.

Arguments:

    lpFileName - Supplies the name of the file to be examined.

    pRecoveryAgents - Returns a list of recovery agents, represented
        by certificate hashes on the file.  This list should be freed
        by calling FreeEncryptionCertificateHashList().

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if ((lpFileName != NULL) && (pRecoveryAgents != NULL)) {
        return(FeClientInfo->lpServices->QueryRecoveryAgents( lpFileName, pRecoveryAgents ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}


DWORD
RemoveUsersFromEncryptedFile(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    )
/*++

Routine Description:

    Takes a list of certificate hashes to be removed
    from the passed file.  Any that are found are removed,
    the rest are ignored with no error return.

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    pHashes - Supplies the list of hashes to be removed.

Return Value:

    Win32 Error

--*/
{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if ((lpFileName != NULL) && (pHashes != NULL)) {
        return(FeClientInfo->lpServices->RemoveUsers( lpFileName, pHashes ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}

DWORD
AddUsersToEncryptedFile(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    )
/*++

Routine Description:

    This routine adds user keys to the passed encrypted file.

Arguments:

    lpFileName - Supplies the name of the file to be encrypted.

    pEncryptionCertificates - Supplies the list of certificates for
        new users to be added to the file.

Return Value:

    Win32 Error

--*/
{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if ((lpFileName != NULL) && (pEncryptionCertificates != NULL)) {
        return(FeClientInfo->lpServices->AddUsers( lpFileName, pEncryptionCertificates ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}

DWORD
SetUserFileEncryptionKey(
    PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
/*++

Routine Description:

    This routine will set the user's current EFS key to the one
    contained in the passed certificate.  If no certificate is
    passed, a new key will be generated automatically.

Arguments:

    pEncryptionCertificate - Optionally supplies the certificate
        containing the new public key.

Return Value:

    Win32 error

--*/
{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    return(FeClientInfo->lpServices->SetKey( pEncryptionCertificate ));

    /*
    if (pEncryptionCertificate != NULL) {
        return(FeClientInfo->lpServices->SetKey( pEncryptionCertificate ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }*/
}

DWORD
DuplicateEncryptionInfoFile(
     IN LPCWSTR SrcFileName,
     IN LPCWSTR DstFileName, 
     IN DWORD dwCreationDistribution, 
     IN DWORD dwAttributes, 
     IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
     )
/*++

Routine Description:

    This routine duplicates the encryption information from the source file to the
    destination file. Destination file will be created if not existing.

    The destination file is overwritten.

Arguments:

    SrcFileName - Supplies the source of the encryption information.

    DstFileName - Supplies the target file, exclusive open is required on this file.
    
    dwCreationDistribution - Create options. 
                             If dwCreationDistribution != CREATE_NEW, dwCreationDistribution = CREATE_ALWAYS
                             
    dwAttributes - File attributes.
    
    lpSecurityAttributes - Security attributes.
    
    

Return Value:

    Win32 error on failure.

--*/

{
    DWORD rc;

    if (FeClientModule == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if (SrcFileName && DstFileName) {
        return(FeClientInfo->lpServices->DuplicateEncryptionInfo( SrcFileName, 
                                                                  DstFileName, 
                                                                  dwCreationDistribution,
                                                                  dwAttributes,
                                                                  lpSecurityAttributes
                                                                 ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}


BOOL
WINAPI
EncryptionDisable(
    IN LPCWSTR DirPath,
    IN BOOL Disable
    )

/*++

Routine Description:

    This routine disable and enable EFS in the directory DirPath.
        
Arguments:

    DirPath - Directory path.

    Disable - TRUE to disable
    

Return Value:

    TRUE for SUCCESS

--*/
{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    return(FeClientInfo->lpServices->DisableDir( DirPath, Disable ));

}


WINADVAPI
DWORD
WINAPI
EncryptedFileKeyInfo(
    IN  LPCWSTR lpFileName,
    IN  DWORD   InfoClass,
    OUT PEFS_RPC_BLOB * KeyInfo
    )
/*++

Routine Description:

    Win32 interface for adding users to an encrypted file.

Arguments:

    lpFileName - Supplies the name of the file to be modified.
    
    InfoClass  - Information requested. Only support 1 for now.

    KeyInfo - Returns Key info
    
Return Value:

    Win32 error.

--*/

{
    DWORD rc;

    //
    // See if the module has been loaded, and if not, load it into this
    // process.
    //

    if (FeClientInfo == NULL) {
        rc = LoadAndInitFeClient();
        if (!rc) {
            return(rc);
        }
    }

    if ((lpFileName != NULL) && (KeyInfo != NULL)) {
        return(FeClientInfo->lpServices->GetKeyInfo( lpFileName, InfoClass, KeyInfo ));
    } else {
        return( ERROR_INVALID_PARAMETER );
    }
}



WINADVAPI
VOID
WINAPI
FreeEncryptedFileKeyInfo(
    IN PEFS_RPC_BLOB pKeyInfo
    )
/*++

Routine Description:

    Frees a KeyInfo as returned by EncryptedFileKeyInfo();
    
Arguments:

    pKeyInfo - Supplies a KeyInfo returned from EncryptedFileKeyInfo().

Return Value:

    No.

--*/
{

    //
    // It is probably safe to assume that feclient.dll is loaded,
    // since we wouldn't have one of these structures to free
    // if it weren't.
    //

    if (pKeyInfo != NULL) {
        FeClientInfo->lpServices->FreeKeyInfo( pKeyInfo );
    } else {

        //
        // nothing to do
        //
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\group16.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    group16.c

Abstract:

    This module contains routines for reading 16-bit Windows 3.1
    group files.

Author:

    Steve Wood (stevewo) 22-Feb-1993

Revision History:

--*/

#include "advapi.h"
#include <stdio.h>

#include <winbasep.h>
#include "win31io.h"

#define ROUND_UP( X, A ) (((ULONG_PTR)(X) + (A) - 1) & ~((A) - 1))
#define PAGE_SIZE 4096
#define PAGE_NUMBER( A ) ((DWORD)(A) / PAGE_SIZE)

PGROUP_DEF16
LoadGroup16(
    PWSTR GroupFileName
    )
{
    HANDLE File, Mapping;
    LPVOID Base;

    File = CreateFileW( GroupFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                      );

    if (File == INVALID_HANDLE_VALUE) {
        return NULL;
        }


    Mapping = CreateFileMapping( File,
                                 NULL,
                                 PAGE_WRITECOPY,
                                 0,
                                 0,
                                 NULL
                               );
    CloseHandle( File );
    if (Mapping == NULL) {
        return NULL;
        }


    Base = MapViewOfFile( Mapping,
                          FILE_MAP_COPY,
                          0,
                          0,
                          0
                        );
    CloseHandle( Mapping );
    return (PGROUP_DEF16)Base;
}


BOOL
UnloadGroup16(
    PGROUP_DEF16 Group
    )
{
    return UnmapViewOfFile( (LPVOID)Group );
}


BOOL
ExtendGroup16(
    PGROUP_DEF16 Group,
    BOOL AppendToGroup,
    DWORD cb
    )
{
    PBYTE Start, Commit, End;

    if (((DWORD)Group->wReserved + cb) > 0xFFFF) {
        return FALSE;
        }

    Start = (PBYTE)Group + Group->cbGroup;
    End = Start + cb;

    if (PAGE_NUMBER( Group->wReserved ) != PAGE_NUMBER( Group->wReserved + cb )) {
        Commit = (PBYTE)ROUND_UP( (PBYTE)Group + Group->wReserved, PAGE_SIZE );
        if (!VirtualAlloc( Commit, ROUND_UP( cb, PAGE_SIZE ), MEM_COMMIT, PAGE_READWRITE )) {
            return FALSE;
            }
        }

    if (!AppendToGroup) {
        memmove( End, Start, Group->wReserved - Group->cbGroup );
        }

    Group->wReserved += (WORD)cb;
    return TRUE;
}

WORD
AddDataToGroup16(
    PGROUP_DEF16 Group,
    PBYTE Data,
    DWORD cb
    )
{
    WORD Offset;

    if (cb == 0) {
        cb = strlen( Data ) + 1;
        }
    cb = (DWORD)ROUND_UP( cb, sizeof( WORD ) );

    if (!ExtendGroup16( Group, FALSE, cb )) {
        return 0;
        }

    if (((DWORD)Group->cbGroup + cb) > 0xFFFF) {
        return 0;
        }

    Offset = Group->cbGroup;
    Group->cbGroup += (WORD)cb;

    if (Data != NULL) {
        memmove( (PBYTE)Group + Offset, Data, cb );
        }
    else {
        memset( (PBYTE)Group + Offset, 0, cb );
        }

    return Offset;
}

BOOL
AddTagToGroup16(
    PGROUP_DEF16 Group,
    WORD wID,
    WORD wItem,
    WORD cb,
    PBYTE rgb
    )
{
    WORD Offset;
    PTAG_DEF16 Tag;

    cb = (WORD)(ROUND_UP( cb, sizeof( WORD ) ));

    Offset = Group->wReserved;
    if (!ExtendGroup16( Group, TRUE, FIELD_OFFSET( TAG_DEF16, rgb[ 0 ] ) + cb )) {
        return FALSE;
        }

    Tag = (PTAG_DEF16)PTR( Group, Offset );
    Tag->wID = wID;
    Tag->wItem = (int)wItem;
    if (cb) {
        Tag->cb = (WORD)(cb + FIELD_OFFSET( TAG_DEF16, rgb[ 0 ] ));
        memmove( &Tag->rgb[ 0 ], rgb, cb );
        }
    else {
        Tag->cb = (WORD)(FIELD_OFFSET( TAG_DEF16, rgb[ 0 ] ));
        }
    return TRUE;
}


#if DBG
BOOL
DumpGroup16(
    PWSTR GroupFileName,
    PGROUP_DEF16 Group
    )
{
    PICON_HEADER16 Icon;
    PITEM_DEF16 Item;
    PTAG_DEF16 Tag;
    UINT i;
    PULONG p;
    int cb;

    DbgPrint( "%ws - Group at %08x\n", GroupFileName, Group );
    DbgPrint( "     dwMagic:     %08x\n", Group->dwMagic );
    DbgPrint( "     wCheckSum:       %04x\n", Group->wCheckSum );
    DbgPrint( "     cbGroup:         %04x\n", Group->cbGroup );
    DbgPrint( "     nCmdShow:        %04x\n", Group->nCmdShow );
    DbgPrint( "     rcNormal:       [%04x,%04x,%04x,%04x]\n",
                      Group->rcNormal.Left,
                      Group->rcNormal.Top,
                      Group->rcNormal.Right,
                      Group->rcNormal.Bottom
            );
    DbgPrint( "     ptMin:          [%04x,%04x]\n",
                      Group->ptMin.x,
                      Group->ptMin.y
            );
    DbgPrint( "     pName:          [%04x] %s\n",
                      Group->pName,
                      (PSZ)PTR( Group, Group->pName )
            );
    DbgPrint( "     cxIcon:          %04x\n", Group->cxIcon );
    DbgPrint( "     cyIcon:          %04x\n", Group->cyIcon );
    DbgPrint( "     wIconFormat:     %04x\n", Group->wIconFormat );
    DbgPrint( "     cItems:          %04x\n", Group->cItems );

    for (i=0; i<Group->cItems; i++) {
        DbgPrint( "     Item[ %02x ] at %04x\n", i, Group->rgiItems[ i ] );
        if (Group->rgiItems[ i ] != 0) {
            Item = ITEM16( Group, i );
            DbgPrint( "         pt:      [%04x, %04x]\n",
                               Item->pt.x,
                               Item->pt.y
                    );
            DbgPrint( "         iIcon:    %04x\n", Item->iIcon );
            DbgPrint( "         cbHeader: %04x\n", Item->cbHeader );
            DbgPrint( "         cbANDPln: %04x\n", Item->cbANDPlane );
            DbgPrint( "         cbXORPln: %04x\n", Item->cbXORPlane );
            DbgPrint( "         pHeader:  %04x\n", Item->pHeader );
            Icon = (PICON_HEADER16)PTR( Group, Item->pHeader );
            DbgPrint( "             xHot: %04x\n", Icon->xHotSpot );
            DbgPrint( "             yHot: %04x\n", Icon->yHotSpot );
            DbgPrint( "             cx:   %04x\n", Icon->cx );
            DbgPrint( "             cy:   %04x\n", Icon->cy );
            DbgPrint( "             cbWid:%04x\n", Icon->cbWidth );
            DbgPrint( "             Plane:%04x\n", Icon->Planes );
            DbgPrint( "             BPP:  %04x\n", Icon->BitsPixel );
            DbgPrint( "         pANDPln:  %04x\n", Item->pANDPlane );
            DbgPrint( "         pXORPln:  %04x\n", Item->pXORPlane );
            DbgPrint( "         pName:   [%04x] %s\n", Item->pName, PTR( Group, Item->pName ) );
            DbgPrint( "         pCommand:[%04x] %s\n", Item->pCommand, PTR( Group, Item->pCommand ) );
            DbgPrint( "         pIconPth:[%04x] %s\n", Item->pIconPath, PTR( Group, Item->pIconPath ) );

            DbgPrint( "         AND bits:\n" );
            p = (PULONG)PTR( Group, Item->pANDPlane );
            cb = Item->cbANDPlane;
            while (cb > 0) {
                DbgPrint( "             %08x", *p++ );
                cb -= sizeof( *p );
                if (cb >= sizeof( *p )) {
                    cb -= sizeof( *p );
                    DbgPrint( " %08x", *p++ );
                    if (cb >= sizeof( *p )) {
                        cb -= sizeof( *p );
                        DbgPrint( " %08x", *p++ );
                        if (cb >= sizeof( *p )) {
                            cb -= sizeof( *p );
                            DbgPrint( " %08x", *p++ );
                            }
                        }
                    }

                DbgPrint( "\n" );
                }

            DbgPrint( "         XOR bits:\n" );
            p = (PULONG)PTR( Group, Item->pXORPlane );
            cb = Item->cbXORPlane;
            while (cb > 0) {
                DbgPrint( "             %08x", *p++ );
                cb -= sizeof( *p );
                if (cb >= sizeof( *p )) {
                    cb -= sizeof( *p );
                    DbgPrint( " %08x", *p++ );
                    if (cb >= sizeof( *p )) {
                        cb -= sizeof( *p );
                        DbgPrint( " %08x", *p++ );
                        if (cb >= sizeof( *p )) {
                            cb -= sizeof( *p );
                            DbgPrint( " %08x", *p++ );
                            }
                        }
                    }

                DbgPrint( "\n" );
                }
            }
        }

    Tag = (PTAG_DEF16)((PBYTE)Group + Group->cbGroup);
    if (Tag->wID == ID_MAGIC && Tag->wItem == ID_LASTTAG &&
        *(UNALIGNED DWORD *)&Tag->rgb == PMTAG_MAGIC
       ) {
        while (Tag->wID != ID_LASTTAG) {
            DbgPrint( "     Tag at %04x\n", (PBYTE)Tag - (PBYTE)Group );
            DbgPrint( "         wID:      %04x\n", Tag->wID );
            DbgPrint( "         wItem:    %04x\n", Tag->wItem );
            DbgPrint( "         cb:       %04x\n", Tag->cb );


            switch( Tag->wID ) {
                case ID_MAGIC:
                    DbgPrint( "         rgb:      ID_MAGIC( %.4s )\n", Tag->rgb );
                    break;

                case ID_WRITERVERSION:
                    DbgPrint( "         rgb:      ID_WRITERVERSION( %s )\n", Tag->rgb );
                    break;

                case ID_APPLICATIONDIR:
                    DbgPrint( "         rgb:      ID_APPLICATIONDIR( %s )\n", Tag->rgb );
                    break;

                case ID_HOTKEY:
                    DbgPrint( "         rgb:      ID_HOTKEY( %04x )\n", *(LPWORD)Tag->rgb );
                    break;

                case ID_MINIMIZE:
                    DbgPrint( "         rgb:      ID_MINIMIZE()\n" );
                    break;

                case ID_LASTTAG:
                    DbgPrint( "         rgb:      ID_LASTTAG()\n" );
                    break;

                default:
                    DbgPrint( "         rgb:      unknown data format for this ID\n" );
                    break;
                }


            Tag = (PTAG_DEF16)((PBYTE)Tag + Tag->cb);
            }
        }

    return TRUE;
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\group32.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    group32.c

Abstract:

    This module contains routines for reading/writing 32-bit Windows/NT
    groups that are stored in the registry.

Author:

    Steve Wood (stevewo) 22-Feb-1993

Revision History:

--*/

#include "advapi.h"
#include <stdio.h>

#include <winbasep.h>
#include "win31io.h"

#define BMR_ICON    1
#define BMR_DEVDEP  0

#define ROUND_UP( X, A ) (((ULONG_PTR)(X) + (A) - 1) & ~((A) - 1))
#define PAGE_SIZE 4096
#define PAGE_NUMBER( A ) ((DWORD)(A) / PAGE_SIZE)

typedef int (WINAPI *PGETSYSTEMMETRICS)(
    int nIndex
    );
PGETSYSTEMMETRICS lpGetSystemMetrics;

ULONG
QueryNumberOfPersonalGroupNames(
    HANDLE CurrentUser,
    PHANDLE GroupNamesKey,
    PHANDLE SettingsKey
    )
{
    NTSTATUS Status;
    UNICODE_STRING KeyName, ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR ValueNameBuffer[ 16 ];
    KEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength, NumberOfPersonalGroups;

    RtlInitUnicodeString( &KeyName, L"SoftWare\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager\\UNICODE Groups" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                CurrentUser,
                                NULL
                              );
    Status = NtOpenKey( GroupNamesKey,
                        STANDARD_RIGHTS_WRITE |
                            KEY_QUERY_VALUE |
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_SET_VALUE |
                            KEY_CREATE_SUB_KEY,
                        &ObjectAttributes
                      );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return 0;
        }

    RtlInitUnicodeString( &KeyName, L"SoftWare\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager\\Settings" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                CurrentUser,
                                NULL
                              );
    Status = NtOpenKey( SettingsKey,
                        STANDARD_RIGHTS_WRITE |
                            KEY_QUERY_VALUE |
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_SET_VALUE |
                            KEY_CREATE_SUB_KEY,
                        &ObjectAttributes
                      );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        NtClose( *GroupNamesKey );
        return 0;
        }

    for (NumberOfPersonalGroups=1; ; NumberOfPersonalGroups++) {
        swprintf( ValueNameBuffer, L"Group%d", NumberOfPersonalGroups );
        RtlInitUnicodeString( &ValueName, ValueNameBuffer );
        Status = NtQueryValueKey( *GroupNamesKey,
                                  &ValueName,
                                  KeyValuePartialInformation,
                                  (PVOID)&KeyValueInformation,
                                  sizeof( KeyValueInformation ),
                                  &ResultLength
                                );
        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_SUCCESS;
            }

        if (!NT_SUCCESS( Status ) ||
            KeyValueInformation.Type != REG_SZ
           ) {
            break;
            }
        }

    return NumberOfPersonalGroups - 1;
}

BOOL
NewPersonalGroupName(
    HANDLE GroupNamesKey,
    PWSTR GroupName,
    ULONG GroupNumber
    )
{
    NTSTATUS Status;
    UNICODE_STRING ValueName;
    WCHAR ValueNameBuffer[ 16 ];

    if (GroupNumber >= CGROUPSMAX) {
        SetLastError( ERROR_TOO_MANY_NAMES );
        return FALSE;
        }

    swprintf( ValueNameBuffer, L"Group%d", GroupNumber );
    RtlInitUnicodeString( &ValueName, ValueNameBuffer );
    Status = NtSetValueKey( GroupNamesKey,
                            &ValueName,
                            0,
                            REG_SZ,
                            GroupName,
                            (wcslen( GroupName ) + 1) * sizeof( WCHAR )
                          );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
        }
    else {
        return TRUE;
        }
}

BOOL
DoesExistGroup(
    HANDLE GroupsKey,
    PWSTR GroupName
    )
{
    NTSTATUS Status;
    UNICODE_STRING KeyName, ValueName;
    HANDLE Key;
    OBJECT_ATTRIBUTES ObjectAttributes;
    KEY_VALUE_FULL_INFORMATION KeyValueInformation;
    ULONG ResultLength;

    RtlInitUnicodeString( &KeyName, GroupName );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                GroupsKey,
                                NULL
                              );
    Status = NtOpenKey( &Key,
                        GENERIC_READ,
                        &ObjectAttributes
                      );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
        }

    RtlInitUnicodeString( &ValueName, L"" );
    Status = NtQueryValueKey( Key,
                              &ValueName,
                              KeyValueFullInformation,
                              &KeyValueInformation,
                              sizeof( KeyValueInformation ),
                              &ResultLength
                            );
    NtClose( Key );
    if (!NT_SUCCESS( Status ) && Status != STATUS_BUFFER_OVERFLOW) {
        BaseSetLastNTError( Status );
        return FALSE;
        }
    else
    if (KeyValueInformation.Type != REG_BINARY ||
        KeyValueInformation.DataLength > 0xFFFF
       ) {
        return FALSE;
        }
    else {
        return TRUE;
        }
}

PGROUP_DEF
LoadGroup(
    HANDLE GroupsKey,
    PWSTR GroupName
    )
{
    PGROUP_DEF Group;
    NTSTATUS Status;
    UNICODE_STRING KeyName, ValueName;
    HANDLE Key;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PVOID Base;
    KEY_VALUE_FULL_INFORMATION KeyValueInformation;
    ULONG ResultLength;

    RtlInitUnicodeString( &KeyName, GroupName );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                GroupsKey,
                                NULL
                              );
    Status = NtOpenKey( &Key,
                        GENERIC_READ,
                        &ObjectAttributes
                      );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return NULL;
        }

    RtlInitUnicodeString( &ValueName, L"" );
    Status = NtQueryValueKey( Key,
                              &ValueName,
                              KeyValueFullInformation,
                              &KeyValueInformation,
                              sizeof( KeyValueInformation ),
                              &ResultLength
                            );
    if (!NT_SUCCESS( Status )) {
        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_SUCCESS;
            }
        else {
            NtClose( Key );
            BaseSetLastNTError( Status );
            return NULL;
            }
        }

    if (KeyValueInformation.Type != REG_BINARY ||
        KeyValueInformation.DataLength > 0xFFFF
       ) {
        NtClose( Key );
        return NULL;
        }

    Base = VirtualAlloc( NULL, 0xFFFF, MEM_RESERVE, PAGE_READWRITE );
    if (Base == NULL ||
        !VirtualAlloc( Base, KeyValueInformation.DataLength, MEM_COMMIT, PAGE_READWRITE )
       ) {
        if (Base != NULL) {
            VirtualFree( Base, 0, MEM_RELEASE );
            }

        NtClose( Key );
        return NULL;
        }

    Status = NtQueryValueKey( Key,
                              &ValueName,
                              KeyValueFullInformation,
                              &KeyValueInformation,
                              KeyValueInformation.DataLength,
                              &ResultLength
                            );
    NtClose( Key );
    if (!NT_SUCCESS( Status )) {
        VirtualFree( Base, 0, MEM_RELEASE );
        return NULL;
        }
    else {
        Group = (PGROUP_DEF)((PCHAR)Base + KeyValueInformation.DataOffset);

        //
        // Set total size of group
        //
        Group->wReserved = (WORD)(ResultLength - KeyValueInformation.DataOffset);
        RtlMoveMemory( Base, Group, Group->wReserved );
        return (PGROUP_DEF)Base;
        }
}


BOOL
SaveGroup(
    HANDLE GroupsKey,
    PWSTR GroupName,
    PGROUP_DEF Group
    )
{
    NTSTATUS Status;
    UNICODE_STRING KeyName, ValueName;
    HANDLE Key;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG CreateDisposition;
    LONG ValueLength;


    RtlInitUnicodeString( &KeyName, GroupName );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                GroupsKey,
                                NULL
                              );
    Status = NtCreateKey( &Key,
                          STANDARD_RIGHTS_WRITE |
                            KEY_QUERY_VALUE |
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_SET_VALUE |
                            KEY_CREATE_SUB_KEY,
                          &ObjectAttributes,
                          0,
                          NULL,
                          0,
                          &CreateDisposition
                        );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
        }

    ValueLength = (LONG)((ULONG)Group->wReserved);
    Group->wReserved = 0;
    Group->wCheckSum = (WORD)-ValueLength;

    RtlInitUnicodeString( &ValueName, L"" );
    Status = NtSetValueKey( Key,
                            &ValueName,
                            0,
                            REG_BINARY,
                            Group,
                            ValueLength
                          );

    Group->wReserved = (WORD)ValueLength;
    Group->wCheckSum = 0;
    NtClose( Key );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    else {
        return TRUE;
        }
}



BOOL
DeleteGroup(
    HANDLE GroupsKey,
    PWSTR GroupName
    )
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    HANDLE Key;
    OBJECT_ATTRIBUTES ObjectAttributes;


    RtlInitUnicodeString( &KeyName, GroupName );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                GroupsKey,
                                NULL
                              );
    Status = NtOpenKey( &Key,
                        STANDARD_RIGHTS_WRITE |
                          DELETE |
                          KEY_QUERY_VALUE |
                          KEY_ENUMERATE_SUB_KEYS |
                          KEY_SET_VALUE |
                          KEY_CREATE_SUB_KEY,
                        &ObjectAttributes
                      );
    if (!NT_SUCCESS( Status )) {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            return TRUE;
            }
        else {
            BaseSetLastNTError( Status );
            return FALSE;
            }
        }

    Status = NtDeleteKey( Key );
    NtClose( Key );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    else {
        return TRUE;
        }
}


BOOL
UnloadGroup(
    PGROUP_DEF Group
    )
{
    return VirtualFree( Group, 0, MEM_RELEASE );
}


BOOL
ExtendGroup(
    PGROUP_DEF Group,
    BOOL AppendToGroup,
    DWORD cb
    )
{
    PBYTE Start, Commit, End;

    if (((DWORD)Group->wReserved + cb) > 0xFFFF) {
        return FALSE;
        }

    Start = (PBYTE)Group + Group->cbGroup;
    End = Start + cb;

    if (PAGE_NUMBER( Group->wReserved ) != PAGE_NUMBER( Group->wReserved + cb )) {
        Commit = (PBYTE)ROUND_UP( (PBYTE)Group + Group->wReserved, PAGE_SIZE );
        if (!VirtualAlloc( Commit, ROUND_UP( cb, PAGE_SIZE ), MEM_COMMIT, PAGE_READWRITE )) {
            return FALSE;
            }
        }

    if (!AppendToGroup) {
        memmove( End, Start, Group->wReserved - Group->cbGroup );
        }

    Group->wReserved += (WORD)cb;
    return TRUE;
}

WORD
AddDataToGroup(
    PGROUP_DEF Group,
    PBYTE Data,
    DWORD cb
    )
{
    WORD Offset;

    if (cb == 0) {
        cb = strlen( Data ) + 1;
        }
    cb = (DWORD)ROUND_UP( cb, sizeof( DWORD ) );

    if (!ExtendGroup( Group, FALSE, cb )) {
        return 0;
        }

    if (((DWORD)Group->cbGroup + cb) > 0xFFFF) {
        return 0;
        }

    Offset = Group->cbGroup;
    Group->cbGroup += (WORD)cb;

    if (Data != NULL) {
        memmove( (PBYTE)Group + Offset, Data, cb );
        }
    else {
        memset( (PBYTE)Group + Offset, 0, cb );
        }

    return Offset;
}

BOOL
AddTagToGroup(
    PGROUP_DEF Group,
    WORD wID,
    WORD wItem,
    WORD cb,
    PBYTE rgb
    )
{
    WORD Offset;
    PTAG_DEF Tag;

    cb = (WORD)(ROUND_UP( cb, sizeof( DWORD ) ));

    Offset = Group->wReserved;
    if (!ExtendGroup( Group, TRUE, FIELD_OFFSET( TAG_DEF, rgb[ 0 ] ) + cb )) {
        return FALSE;
        }

    Tag = (PTAG_DEF)PTR( Group, Offset );
    Tag->wID = wID;
    Tag->dummy1 = 0;
    Tag->wItem = (int)wItem;
    Tag->dummy2 = 0;
    if (cb != 0 || rgb != NULL) {
        Tag->cb = (WORD)(cb + FIELD_OFFSET( TAG_DEF, rgb[ 0 ] ));
        memmove( &Tag->rgb[ 0 ], rgb, cb );
        }
    else {
        Tag->cb = 0;
        }

    return TRUE;
}


ULONG MonoChromePalette[] = {
    0x00000000, 0x00ffffff
};

BITMAPINFOHEADER DefaultQuestionIconBIH = {
    0x00000028,
    0x00000020,
    0x00000040,
    0x0001,
    0x0004,
    0x00000000,
    0x00000280,
    0x00000000,
    0x00000000,
    0xFFFFFFFF,
    0x00000000
};

ULONG DefaultQuestionIconBits[] = {
     0x00000000, 0x00000000, 0x00000000, 0x00000000
   , 0x00000000, 0x33000000, 0x00000030, 0x00000000
   , 0x00000000, 0xbb080000, 0x00000083, 0x00000000
   , 0x00000000, 0xff0b0000, 0x000000b3, 0x00000000
   , 0x00000000, 0xff0b0000, 0x000000b3, 0x00000000
   , 0x00000000, 0xbb000000, 0x00000080, 0x00000000
   , 0x00000000, 0x00000000, 0x00000000, 0x00000000
   , 0x00000000, 0x00000000, 0x00000000, 0x00000000
   , 0x00000000, 0x00000000, 0x00000000, 0x00000000
   , 0x00000000, 0x33000000, 0x00000030, 0x00000000
   , 0x00000000, 0xbb080000, 0x00000083, 0x00000000
   , 0x00000000, 0xbb0b0000, 0x000000b3, 0x00000000
   , 0x00000000, 0xff0b0000, 0x000000b3, 0x00000000
   , 0x00000000, 0xff0b0000, 0x000030b8, 0x00000000
   , 0x00000000, 0xbf000000, 0x000083bb, 0x00000000
   , 0x00000000, 0xbf000000, 0x0033b8fb, 0x00000000
   , 0x00000000, 0x0b000000, 0x33b8bbbf, 0x00000000
   , 0x00000000, 0x00000000, 0xb3bbfbbb, 0x00000030
   , 0x00000000, 0x00000000, 0xbbbbbb00, 0x00000030
   , 0x00000000, 0x00000000, 0xbbbb0000, 0x00000083
   , 0x00000000, 0x00000000, 0xbb0b0000, 0x000000b3
   , 0x00000000, 0x00003033, 0xbb0b0000, 0x000000b3
   , 0x08000000, 0x000083bb, 0xbb0b0000, 0x000000b3
   , 0x0b000000, 0x0000b3bb, 0xbb0b0000, 0x000000b3
   , 0x0b000000, 0x0030b8ff, 0xbb3b0000, 0x000000b3
   , 0x0b000000, 0x0083bbff, 0xbb8b0300, 0x000000b3
   , 0x00000000, 0x33b8fbbf, 0xbbbb3833, 0x00000080
   , 0x00000000, 0xbbbbffbb, 0xb8bbbbbb, 0x00000030
   , 0x00000000, 0xbbffbf0b, 0x83bbbbbb, 0x00000000
   , 0x00000000, 0xffbf0b00, 0x00b8bbff, 0x00000000
   , 0x00000000, 0xbb0b0000, 0x0000b8bb, 0x00000000
   , 0x00000000, 0x00000000, 0x00000000, 0x00000000
   , 0xff7ffcff, 0xff3ff8ff, 0xff1ff0ff, 0xff1ff0ff
   , 0xff1ff0ff, 0xff3ff8ff, 0xff7ffcff, 0xffffffff
   , 0xff7ffcff, 0xff3ff8ff, 0xff1ff0ff, 0xff1ff0ff
   , 0xff1ff0ff, 0xff0ff0ff, 0xff03f8ff, 0xff00f8ff
   , 0x7f00fcff, 0x3f00feff, 0x3f00ffff, 0x1fc0ffff
   , 0x1ff01fff, 0x1ff00ffe, 0x1ff007fc, 0x1ff007fc
   , 0x1fe003fc, 0x1f0000fc, 0x3f0000fe, 0x3f0000fe
   , 0x7f0000ff, 0xff0080ff, 0xff03e0ff, 0xff0ff8ff
};


BOOL
ConvertIconBits(
    PCURSORSHAPE_16 pIconHeader
    );

BOOL
ConvertIconBits(
    PCURSORSHAPE_16 pIconHeader
    )
{
    PBYTE Src;
    UINT cbScanLine;
    UINT nScanLine;
    UINT i, j, k;
    PBYTE Plane0;
    PBYTE Plane1;
    PBYTE Plane2;
    PBYTE Plane3;
    PBYTE p;
    BYTE Color0, Color1, Color2, Color3, FourColor, FourColorPlane[ 32 * 4 * 4 ];

    Src = (PBYTE)(pIconHeader + 1) + (pIconHeader->cbWidth * pIconHeader->cy);
    cbScanLine = (((pIconHeader->cx * pIconHeader->BitsPixel + 31) & ~31) / 8);
    nScanLine = pIconHeader->cy;

    if (pIconHeader->Planes != 4) {
        return FALSE;
        }
    else
    if (pIconHeader->BitsPixel != 1) {
        return FALSE;
        }
    else
    if (pIconHeader->cx != pIconHeader->cy) {
        return FALSE;
        }
    else
    if (nScanLine != 32) {
        return FALSE;
        }
    else
    if (cbScanLine != 4) {
        return FALSE;
        }

    Plane0 = (PBYTE)Src;
    Plane1 = Plane0 + cbScanLine;
    Plane2 = Plane1 + cbScanLine;
    Plane3 = Plane2 + cbScanLine;
    p = &FourColorPlane[ 0 ];
    j = nScanLine;
    while (j--) {
        k = cbScanLine;
        while (k--) {
            Color0 = *Plane0++;
            Color1 = *Plane1++;
            Color2 = *Plane2++;
            Color3 = *Plane3++;
            i = 4;
            while (i--) {
                FourColor = 0;
                if (Color0 & 0x80) {
                    FourColor |= 0x10;
                    }
                if (Color1 & 0x80) {
                    FourColor |= 0x20;
                    }
                if (Color2 & 0x80) {
                    FourColor |= 0x40;
                    }
                if (Color3 & 0x80) {
                    FourColor |= 0x80;
                    }
                if (Color0 & 0x40) {
                    FourColor |= 0x01;
                    }
                if (Color1 & 0x40) {
                    FourColor |= 0x02;
                    }
                if (Color2 & 0x40) {
                    FourColor |= 0x04;
                    }
                if (Color3 & 0x40) {
                    FourColor |= 0x08;
                    }

                Color0 <<= 2;
                Color1 <<= 2;
                Color2 <<= 2;
                Color3 <<= 2;

                *p++ = FourColor;
                }
            }

        Plane0 += 3 * cbScanLine;
        Plane1 += 3 * cbScanLine;
        Plane2 += 3 * cbScanLine;
        Plane3 += 3 * cbScanLine;
        }

    memmove( Src, &FourColorPlane[ 0 ], sizeof( FourColorPlane ) );
    pIconHeader->BitsPixel = 4;
    pIconHeader->Planes = 1;
    pIconHeader->cbWidth = cbScanLine * 4;
    return TRUE;
}


VOID
CopyIconBits(
    PBYTE Dst,
    PBYTE Src,
    UINT cbScanLine,
    UINT nScanLine
    );

VOID
CopyIconBits(
    PBYTE Dst,
    PBYTE Src,
    UINT cbScanLine,
    UINT nScanLine
    )
{
    Src += (cbScanLine * nScanLine);
    while (nScanLine--) {
        Src -= cbScanLine;
        memcpy( Dst, Src, cbScanLine );
        Dst += cbScanLine;
        }
}

typedef struct _WIN31_GROUP_ITEM_DESC {
    LPSTR GroupName;
    LPSTR ItemName;
} WIN31_GROUP_ITEM_DESC, *PWIN31_GROUP_ITEM_DESC;

WIN31_GROUP_ITEM_DESC GroupItemsToIgnore[] = {
    {"Main", "File Manager"},
    {NULL, "Control Panel"},
    {NULL, "Print Manager"},
    {NULL, "ClipBook Viewer"},
    {NULL, "MS-DOS Prompt"},
    {NULL, "Windows Setup"},
    {NULL, "Read Me"},
    {"Accessories", "Paintbrush"},
    {NULL, "Write"},
    {NULL, "Terminal"},
    {NULL, "Notepad"},
    {NULL, "Recorder"},
    {NULL, "Clock"},
    {NULL, "Object Packager"},
    {NULL, "Media Player"},
    {NULL, "Sound Recorder"},
    {"Network", NULL},
    {NULL, NULL}
};

PGROUP_DEF
CreateGroupFromGroup16(
    LPSTR GroupName,
    PGROUP_DEF16 Group16
    )
{
    PWIN31_GROUP_ITEM_DESC p1, ItemsToIgnore;
    PGROUP_DEF Group;
    PITEM_DEF Item;
    PITEM_DEF16 Item16;
    PTAG_DEF16 Tag16;
    DWORD cb;
    PBYTE p;
    LPSTR s;
    UINT i;
    PCURSORSHAPE_16 pIconHeader;
    PBITMAPINFOHEADER pbmi;
    BOOL bUserDefaultIcon, bItemConvertedOkay;
    int imagesize, colorsize, masksize, bmisize;

    ItemsToIgnore = NULL;
    p1 = GroupItemsToIgnore;
    while (p1->GroupName || p1->ItemName) {
        if (p1->GroupName &&
            !_stricmp( p1->GroupName, GroupName )
           ) {
            if (p1->ItemName == NULL) {
                return (PGROUP_DEF)-1;
                }

            ItemsToIgnore = p1;
            break;
            }

        p1 += 1;
        }

    Group = VirtualAlloc( NULL, 0xFFFF, MEM_RESERVE, PAGE_READWRITE );
    if (Group == NULL) {
        return NULL;
        }

    if (!VirtualAlloc( Group,
                       cb = FIELD_OFFSET( GROUP_DEF, rgiItems[ 0 ] ),
                       MEM_COMMIT,
                       PAGE_READWRITE
                     )
       ) {
        VirtualFree( Group, 0, MEM_RELEASE );
        return NULL;
        }
    cb = (DWORD)ROUND_UP( cb, sizeof( DWORD ) );
    Group->wReserved = (WORD)cb;
    Group->cbGroup = (WORD)cb;
    Group->cItems = (Group16->cItems + NSLOTS - 1) & ~(NSLOTS-1);
    AddDataToGroup( Group, NULL, (Group->cItems * sizeof( Group->rgiItems[ 0 ] )) );
    Group->pName = AddDataToGroup( Group,
                                   GroupName,
                                   0
                                 );
    Group->dwMagic = GROUP_MAGIC;
    Group->wCheckSum = 0;           /* adjusted later... */
    Group->nCmdShow = SW_SHOWMINIMIZED;     // Group16->nCmdShow;
    Group->wIconFormat = Group16->wIconFormat;

    if (lpGetSystemMetrics == NULL) {
        lpGetSystemMetrics = (PGETSYSTEMMETRICS)GetProcAddress( LoadLibrary( "user32.dll" ),
                                                                "GetSystemMetrics"
                                                              );
        if (lpGetSystemMetrics == NULL) {
            lpGetSystemMetrics = (PGETSYSTEMMETRICS)-1;
            }
        }

    if (lpGetSystemMetrics != (PGETSYSTEMMETRICS)-1) {
        Group->cxIcon = (WORD)(*lpGetSystemMetrics)(SM_CXICON);
        Group->cyIcon = (WORD)(*lpGetSystemMetrics)(SM_CYICON);
        }

    Group->ptMin.x = (LONG)Group16->ptMin.x;
    Group->ptMin.y = (LONG)Group16->ptMin.y;

    Group->rcNormal.left = (int)Group16->rcNormal.Left;
    Group->rcNormal.top = (int)Group16->rcNormal.Top;
    Group->rcNormal.right = (int)Group16->rcNormal.Right;
    Group->rcNormal.bottom = (int)Group16->rcNormal.Bottom;


    for (i=0; i<Group16->cItems; i++) {
        if (Group16->rgiItems[ i ] == 0) {
            continue;
            }

        Item16 = ITEM16( Group16, i );
        if (p1 = ItemsToIgnore) {
            s = PTR( Group16, Item16->pName );
            do {
                if (!_stricmp( p1->ItemName, s )) {
                    s = NULL;
                    break;
                    }
                p1 += 1;
                }
            while (p1->GroupName == NULL && p1->ItemName != NULL);

            if (s == NULL) {
                continue;
                }
            }

        Group->rgiItems[ i ] = AddDataToGroup( Group, NULL, sizeof( ITEM_DEF ) );
        if (Group->rgiItems[ i ] == 0) {
            break;
            }

        Item = ITEM( Group, i );
        Item->pt.x = (LONG)Item16->pt.x;
        Item->pt.y = (LONG)Item16->pt.y;
        Item->idIcon = Item16->iIcon;
        Item->indexIcon = Item16->iIcon;
        Item->wIconVer = 3;

        bUserDefaultIcon = FALSE;
        pIconHeader = (PCURSORSHAPE_16)PTR( Group16, Item16->pHeader );
        if (pIconHeader->Planes != 1) {
            if (!ConvertIconBits( pIconHeader )) {
                KdPrint(("WIN31IO: Invalid 16-bit item icon at %08x\n", pIconHeader ));
                bUserDefaultIcon = TRUE;
                }
            }
        else
        if (pIconHeader->BitsPixel != 1 &&
            pIconHeader->BitsPixel != 4 &&
            pIconHeader->BitsPixel != 8
           ) {
            bUserDefaultIcon = TRUE;
            }

        if (!bUserDefaultIcon) {
            bmisize = sizeof( BITMAPINFOHEADER );
            imagesize = Item16->cbXORPlane;
            masksize = Item16->cbANDPlane;

            if (pIconHeader->BitsPixel == 1) {
                colorsize = sizeof( MonoChromePalette );
                }
            else {
                colorsize = 0;
                }

            Item->cbIconRes = (WORD)(bmisize +
                                     colorsize +
                                     imagesize +
                                     masksize
                                    );

            Item->cbIconRes = (WORD)ROUND_UP( Item->cbIconRes, sizeof( DWORD ) );
            Item->pIconRes = AddDataToGroup( Group, NULL, Item->cbIconRes );
            if (Item->pIconRes != 0) {
                p = PTR( Group, Item->pIconRes );
                pbmi = (PBITMAPINFOHEADER)p;

                pbmi->biSize = bmisize;
                pbmi->biWidth = pIconHeader->cx;
                pbmi->biHeight = pIconHeader->cy * 2;
                pbmi->biPlanes = pIconHeader->Planes;
                pbmi->biBitCount = pIconHeader->BitsPixel;
                pbmi->biCompression = BI_RGB;
                pbmi->biSizeImage = imagesize;
                pbmi->biXPelsPerMeter = 0;
                pbmi->biYPelsPerMeter = 0;
                pbmi->biClrImportant = 0;

                if (colorsize != 0) {
                    memcpy( p + bmisize, MonoChromePalette, colorsize );
                    pbmi->biClrUsed = 0;
                    }
                else {
                    pbmi->biClrUsed = (DWORD)-1;
                    }

                CopyIconBits( p + bmisize + colorsize,
                              (PBYTE)PTR( Group16, Item16->pXORPlane ),
                              (((pIconHeader->cx * pIconHeader->BitsPixel + 31) & ~31) / 8),
                              pIconHeader->cy
                            );

                CopyIconBits( p + bmisize + colorsize + imagesize,
                              (PBYTE)PTR( Group16, Item16->pANDPlane ),
                              (((pIconHeader->cx + 31) & ~31) / 8),
                              pIconHeader->cy
                            );
                }
            }
        else {
            bmisize = sizeof( DefaultQuestionIconBIH );
            imagesize = sizeof( DefaultQuestionIconBits );
            Item->cbIconRes = bmisize + imagesize;
            Item->cbIconRes = (WORD)ROUND_UP( Item->cbIconRes, sizeof( DWORD ) );
            Item->pIconRes = AddDataToGroup( Group, NULL, Item->cbIconRes );
            if (Item->pIconRes != 0) {
                p = PTR( Group, Item->pIconRes );
                memcpy( p, &DefaultQuestionIconBIH, bmisize );
                memcpy( p + bmisize, &DefaultQuestionIconBits, imagesize );
                }
            }

        bItemConvertedOkay = FALSE;
        if (Item->pIconRes != 0) {
            Item->pName = AddDataToGroup( Group,
                                          PTR( Group16, Item16->pName ),
                                          0
                                        );
            if (Item->pName != 0) {
                Item->pCommand = AddDataToGroup( Group,
                                                 PTR( Group16, Item16->pCommand ),
                                                 0
                                               );
                if (Item->pCommand != 0) {
                    Item->pIconPath = AddDataToGroup( Group,
                                                      PTR( Group16, Item16->pIconPath ),
                                                      0
                                                    );
                    if (Item->pIconPath != 0) {
                        bItemConvertedOkay = TRUE;
                        }
                    }
                }
            }

        if (!bItemConvertedOkay) {
            break;
            }
        }

    Tag16 = (PTAG_DEF16)((PBYTE)Group16 + Group16->cbGroup);
    if (bItemConvertedOkay &&
        Tag16->wID == ID_MAGIC && Tag16->wItem == ID_LASTTAG &&
        *(UNALIGNED DWORD *)&Tag16->rgb[ 0 ] == PMTAG_MAGIC
       ) {
        while (Tag16->wID != ID_LASTTAG) {
            if (!AddTagToGroup( Group,
                                Tag16->wID,
                                Tag16->wItem,
                                (WORD)(Tag16->cb - FIELD_OFFSET( TAG_DEF16, rgb[ 0 ] )),
                                &Tag16->rgb[ 0 ]
                              )
               ) {
                bItemConvertedOkay = FALSE;
                break;
                }

            Tag16 = (PTAG_DEF16)((PBYTE)Tag16 + Tag16->cb);
            }

        if (bItemConvertedOkay) {
            if (!AddTagToGroup( Group,
                                ID_LASTTAG,
                                0xFFFF,
                                0,
                                NULL
                              )
               ) {
                bItemConvertedOkay = FALSE;
                }
            }
        }

    if (!bItemConvertedOkay) {
        UnloadGroup( Group );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
        }
    else {
        return Group;
        }
}


#if DBG

BOOL
DumpGroup(
    PWSTR GroupName,
    PGROUP_DEF Group
    )
{
    PBITMAPINFOHEADER Icon;
    PICON_HEADER16 Icon16;
    PITEM_DEF Item;
    PTAG_DEF Tag;
    PULONG p;
    int cb;
    UINT i;

    DbgPrint( "%ws - Group at %08x\n", GroupName, Group );
    DbgPrint( "     dwMagic:     %08x\n", Group->dwMagic );
    DbgPrint( "     wCheckSum:       %04x\n", Group->wCheckSum );
    DbgPrint( "     cbGroup:         %04x\n", Group->cbGroup );
    DbgPrint( "     nCmdShow:        %04x\n", Group->nCmdShow );
    DbgPrint( "     rcNormal:       [%08x,%08x,%08x,%08x]\n",
                      Group->rcNormal.left,
                      Group->rcNormal.top,
                      Group->rcNormal.right,
                      Group->rcNormal.bottom
            );
    DbgPrint( "     ptMin:          [%08x,%08x]\n", Group->ptMin.x, Group->ptMin.y );
    DbgPrint( "     pName:          [%04x] %s\n", Group->pName, Group->pName ? (PSZ)PTR( Group, Group->pName ) : "(null)" );
    DbgPrint( "     cxIcon:          %04x\n", Group->cxIcon );
    DbgPrint( "     cyIcon:          %04x\n", Group->cyIcon );
    DbgPrint( "     wIconFormat:     %04x\n", Group->wIconFormat );
    DbgPrint( "     wReserved:       %04x\n", Group->wReserved );
    DbgPrint( "     cItems:          %04x\n", Group->cItems );

    for (i=0; i<Group->cItems; i++) {
        DbgPrint( "     Item[ %02x ] at %04x\n", i, Group->rgiItems[ i ] );
        if (Group->rgiItems[ i ] != 0) {
            Item = ITEM( Group, i );
            DbgPrint( "         pt:      [%08x, %08x]\n",
                               Item->pt.x,
                               Item->pt.y
                    );
            DbgPrint( "         idIcon:   %04x\n", Item->idIcon );
            DbgPrint( "         wIconVer: %04x\n", Item->wIconVer );
            DbgPrint( "         cbIconRes:%04x\n", Item->cbIconRes );
            DbgPrint( "         indexIcon:%04x\n", Item->indexIcon );
            DbgPrint( "         dummy2:   %04x\n", Item->dummy2 );
            DbgPrint( "         pIconRes: %04x\n", Item->pIconRes );
            if (Item->wIconVer == 2) {
                Icon16 = (PICON_HEADER16)PTR( Group, Item->pIconRes );
                DbgPrint( "             xHot: %04x\n", Icon16->xHotSpot );
                DbgPrint( "             yHot: %04x\n", Icon16->yHotSpot );
                DbgPrint( "             cx:   %04x\n", Icon16->cx );
                DbgPrint( "             cy:   %04x\n", Icon16->cy );
                DbgPrint( "             cbWid:%04x\n", Icon16->cbWidth );
                DbgPrint( "             Plane:%04x\n", Icon16->Planes );
                DbgPrint( "             BPP:  %04x\n", Icon16->BitsPixel );
                p = (PULONG)(Icon16+1);
                cb = Item->cbIconRes - sizeof( *Icon16 );
                }
            else {
                Icon = (PBITMAPINFOHEADER)PTR( Group, Item->pIconRes );
                DbgPrint( "             biSize         :      %08x\n", Icon->biSize          );
                DbgPrint( "             biWidth        :      %08x\n", Icon->biWidth         );
                DbgPrint( "             biHeight       :      %08x\n", Icon->biHeight        );
                DbgPrint( "             biPlanes       :      %04x\n", Icon->biPlanes        );
                DbgPrint( "             biBitCount     :      %04x\n", Icon->biBitCount      );
                DbgPrint( "             biCompression  :      %08x\n", Icon->biCompression   );
                DbgPrint( "             biSizeImage    :      %08x\n", Icon->biSizeImage     );
                DbgPrint( "             biXPelsPerMeter:      %08x\n", Icon->biXPelsPerMeter );
                DbgPrint( "             biYPelsPerMeter:      %08x\n", Icon->biYPelsPerMeter );
                DbgPrint( "             biClrUsed      :      %08x\n", Icon->biClrUsed       );
                DbgPrint( "             biClrImportant :      %08x\n", Icon->biClrImportant  );
                p = (PULONG)(Icon+1);
                cb = Item->cbIconRes - sizeof( *Icon );
                }

            DbgPrint( "         dummy3:   %04x\n", Item->dummy3 );
            DbgPrint( "         pName:   [%04x] %s\n", Item->pName, PTR( Group, Item->pName ) );
            DbgPrint( "         pCommand:[%04x] %s\n", Item->pCommand, PTR( Group, Item->pCommand ) );
            DbgPrint( "         pIconPth:[%04x] %s\n", Item->pIconPath, PTR( Group, Item->pIconPath ) );
            DbgPrint( "         IconData: %04x bytes\n", cb );
            while (cb > 0) {
                DbgPrint( "             %08x", *p++ );
                cb -= sizeof( *p );
                if (cb >= sizeof( *p )) {
                    cb -= sizeof( *p );
                    DbgPrint( " %08x", *p++ );
                    if (cb >= sizeof( *p )) {
                        cb -= sizeof( *p );
                        DbgPrint( " %08x", *p++ );
                        if (cb >= sizeof( *p )) {
                            cb -= sizeof( *p );
                            DbgPrint( " %08x", *p++ );
                            }
                        }
                    }

                DbgPrint( "\n" );
                }
            }
        }

    Tag = (PTAG_DEF)((PBYTE)Group + Group->cbGroup);
    if (Tag->wID == ID_MAGIC && Tag->wItem == ID_LASTTAG &&
        *(LPDWORD)&Tag->rgb == PMTAG_MAGIC
       ) {
        while (Tag->wID != ID_LASTTAG) {
            DbgPrint( "     Tag at %04x\n", (PBYTE)Tag - (PBYTE)Group );
            DbgPrint( "         wID:      %04x\n", Tag->wID );
            DbgPrint( "         dummy1:   %04x\n", Tag->dummy1 );
            DbgPrint( "         wItem:    %08x\n", Tag->wItem );
            DbgPrint( "         cb:       %04x\n", Tag->cb );
            DbgPrint( "         dummy2:   %04x\n", Tag->dummy2 );
            switch( Tag->wID ) {
                case ID_MAGIC:
                    DbgPrint( "         rgb:      ID_MAGIC( %.4s )\n", Tag->rgb );
                    break;

                case ID_WRITERVERSION:
                    DbgPrint( "         rgb:      ID_WRITERVERSION( %s )\n", Tag->rgb );
                    break;

                case ID_APPLICATIONDIR:
                    DbgPrint( "         rgb:      ID_APPLICATIONDIR( %s )\n", Tag->rgb );
                    break;

                case ID_HOTKEY:
                    DbgPrint( "         rgb:      ID_HOTKEY( %04x )\n", *(LPWORD)Tag->rgb );
                    break;

                case ID_MINIMIZE:
                    DbgPrint( "         rgb:      ID_MINIMIZE()\n" );
                    break;

                case ID_LASTTAG:
                    DbgPrint( "         rgb:      ID_LASTTAG()\n" );
                    break;

                default:
                    DbgPrint( "         rgb:      unknown data format for this ID\n" );
                    break;
                }


            Tag = (PTAG_DEF)((PBYTE)Tag + Tag->cb);
            }
        }

    return TRUE;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\cseclogn.cxx ===
/*+
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1997 - 1998.
 *
 *  Name : cseclogn.cxx
 *  Author:Jeffrey Richter (v-jeffrr)
 *
 * Abstract:
 * This is the client side for Secondary Logon Service
 * implemented as CreateProcessWithLogon API
 * in advapi32.dll
 *
 * Revision History:
 * PraeritG    10/8/97  To integrate this in to services.exe
 *
-*/

#define UNICODE

#define SECURITY_WIN32

#include <Windows.h>
#include <wincred.h>
#include <rpc.h>
#include "seclogon.h"
#include "security.h"
#include "dbgdef.h"

//
// must move to winbase.h soon!
#define LOGON_WITH_PROFILE              0x00000001
#define LOGON_NETCREDENTIALS_ONLY       0x00000002

//
// Global function pointers to user32 functions
// This is to dynamically load user32 when CreateProcessWithLogon
// is called.
//

HMODULE hModule1 = NULL;

typedef HDESK (*OPENDESKTOP) (
    LPWSTR lpszDesktop,
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);

OPENDESKTOP myOpenDesktop = NULL;

typedef HDESK (*GETTHREADDESKTOP)(
    DWORD dwThreadId);

GETTHREADDESKTOP    myGetThreadDesktop = NULL;

typedef BOOL (*CLOSEDESKTOP)(
    HDESK hDesktop);

CLOSEDESKTOP    myCloseDesktop = NULL;

typedef HWINSTA (*OPENWINDOWSTATION)(
    LPWSTR lpszWinSta,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);

OPENWINDOWSTATION   myOpenWindowStation = NULL;

typedef HWINSTA (*GETPROCESSWINDOWSTATION)(
    VOID);

GETPROCESSWINDOWSTATION myGetProcessWindowStation = NULL;


typedef BOOL (*SETPROCESSWINDOWSTATION)(HWINSTA hWinSta); 
                                      
SETPROCESSWINDOWSTATION mySetProcessWindowStation; 


typedef BOOL (*CLOSEWINDOWSTATION)(
    HWINSTA hWinSta);

CLOSEWINDOWSTATION  myCloseWindowStation = NULL;

typedef BOOL (*SETUSEROBJECTSECURITY)(
    HANDLE hObj,
    PSECURITY_INFORMATION pSIRequested,
    PSECURITY_DESCRIPTOR pSID);

SETUSEROBJECTSECURITY   mySetUserObjectSecurity = NULL;

typedef BOOL (*GETUSEROBJECTSECURITY)(
    HANDLE hObj,
    PSECURITY_INFORMATION pSIRequested,
    PSECURITY_DESCRIPTOR pSID,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);

GETUSEROBJECTSECURITY  myGetUserObjectSecurity = NULL;

typedef BOOL (*GETUSEROBJECTINFORMATION)(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);

GETUSEROBJECTINFORMATION    myGetUserObjectInformation = NULL;

////////////////////////////////////////////////////////////////////////
//
// Function prototypes:
//
////////////////////////////////////////////////////////////////////////

DWORD c_SeclCreateProcessWithLogonW(IN   SECL_SLI   *psli,
                                    OUT  SECL_SLRI  *pslri);

DWORD To_SECL_BLOB_A(IN   LPVOID      lpEnvironment,
                     OUT  SECL_BLOB  *psb);

DWORD To_SECL_BLOB_W(IN   LPVOID      lpEnvironment,
                     OUT  SECL_BLOB  *psb);


/////////////////////////////////////////////////////////////////////////
//
// Useful macros:
//
/////////////////////////////////////////////////////////////////////////

#define ARRAYSIZE(array) ((sizeof(array)) / (sizeof(array[0])))

#define ASSIGN_SECL_STRING(ss, wsz) \
    { \
        ss.pwsz = wsz; \
        if (NULL != wsz) {\
            ss.ccLength = ss.ccSize = (wcslen(wsz) + 1); \
         } \
        else { \
            ss.ccLength = ss.ccSize = 0; \
        } \
    }

////////////////////////////////////////////////////////////////////////
//
// Module implementation:
//
//////////////////////////////////////////////////////////////////////////


extern "C" void *__cdecl _alloca(size_t);

BOOL
WINAPI
CreateProcessWithLogonW(
      LPCWSTR lpUsername,
      LPCWSTR lpDomain,
      LPCWSTR lpPassword,
      DWORD dwLogonFlags,
      LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCWSTR lpCurrentDirectory,
      LPSTARTUPINFOW lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation)

/*++

Routine Description:

Arguments:

Return Value:

--*/
{

   BOOL                             AccessWasAllowed           = FALSE;
   BOOL                             fOk                        = FALSE;
   BOOL                             fRevertWinsta              = FALSE; 
   DWORD                            LastError                  = ERROR_SUCCESS;
   HANDLE                           hheap                      = GetProcessHeap();
   HDESK                            hDesk                      = NULL; 
   HWINSTA                          hWinsta                    = NULL; 
   HWINSTA                          hWinstaSave                = NULL; 
   LPWSTR                           pszApplName                = NULL;
   LPWSTR                           pszCmdLine                 = NULL;
   LPWSTR                           pwszEmptyString            = L"";
   SECL_SLI                         sli;
   SECL_SLRI                        slri;
   WCHAR                            wszDesktopName[2*MAX_PATH + 1];

   ZeroMemory(&sli,             sizeof(sli));
   ZeroMemory(&slri,            sizeof(slri));
   ZeroMemory(&wszDesktopName,  sizeof(wszDesktopName));

   //
   // dynamically load user32.dll and resolve the functions.
   //
   // note: last error is left as returned by loadlib or getprocaddress

   if(hModule1 == NULL)
   {
       hModule1 = LoadLibrary(L"user32.dll");
       if(hModule1)
       {
            myOpenDesktop = (OPENDESKTOP) GetProcAddress(hModule1,
                                                         "OpenDesktopW");
            if(!myOpenDesktop) return FALSE;


            myGetThreadDesktop = (GETTHREADDESKTOP)
                                        GetProcAddress( hModule1,
                                                        "GetThreadDesktop");
            if(!myGetThreadDesktop) return FALSE;


            myCloseDesktop = (CLOSEDESKTOP) GetProcAddress(hModule1,
                                                           "CloseDesktop");
            if(!myCloseDesktop) return FALSE;


            myOpenWindowStation = (OPENWINDOWSTATION)
                                        GetProcAddress(hModule1,
                                                       "OpenWindowStationW");
            if(!myOpenWindowStation) return FALSE;


            myGetProcessWindowStation = (GETPROCESSWINDOWSTATION)
                                        GetProcAddress(hModule1,
                                                    "GetProcessWindowStation");
            if(!myGetProcessWindowStation) return FALSE;

            mySetProcessWindowStation = (SETPROCESSWINDOWSTATION)GetProcAddress(hModule1, "SetProcessWindowStation"); 
            if (!mySetProcessWindowStation) return FALSE; 

            myCloseWindowStation = (CLOSEWINDOWSTATION) GetProcAddress(hModule1,
                                                "CloseWindowStation");

            if(!myCloseWindowStation) return FALSE;


            myGetUserObjectSecurity = (GETUSEROBJECTSECURITY)
                                                GetProcAddress(hModule1,
                                                "GetUserObjectSecurity");
            if(!myGetUserObjectSecurity) return FALSE;

            mySetUserObjectSecurity = (SETUSEROBJECTSECURITY)
                                                GetProcAddress(hModule1,
                                                "SetUserObjectSecurity");
            if(!mySetUserObjectSecurity) return FALSE;


            myGetUserObjectInformation = (GETUSEROBJECTINFORMATION)
                                                GetProcAddress(hModule1,
                                                "GetUserObjectInformationW");
            if(!mySetUserObjectSecurity) return FALSE;
       }
       else
       {
            return FALSE;
       }
   }

   __try {


      //
      // JMR: Do these flags work: CREATE_SEPARATE_WOW_VDM,
      //       CREATE_SHARED_WOW_VDM
      // Valid flags: CREATE_SUSPENDED, CREATE_UNICODE_ENVIRONMENT,
      //              *_PRIORITY_CLASS
      //
      // The following flags are illegal. Fail the call if any are specified.
      //
      if ((dwCreationFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS
                              | DETACHED_PROCESS)) != 0) {
         LastError = ERROR_INVALID_PARAMETER;
         __leave;
      }

      if(dwLogonFlags & ~(LOGON_WITH_PROFILE | LOGON_NETCREDENTIALS_ONLY))
      {
         LastError = ERROR_INVALID_PARAMETER;
         __leave;
      }

      //
      // Turn on the flags that MUST be turned on
      //
      // We are overloading CREATE_NEW_CONSOLE to
      // CREATE_WITH_NETWORK_LOGON
      //
      dwCreationFlags |= CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_CONSOLE
                           | CREATE_NEW_PROCESS_GROUP;

      //
      // If no priority class explicitly specified and this process is IDLE, force IDLE (See CreateProcess documentation)
      //
      if ((dwCreationFlags & (NORMAL_PRIORITY_CLASS | IDLE_PRIORITY_CLASS
                              | HIGH_PRIORITY_CLASS
                              | REALTIME_PRIORITY_CLASS)) == 0) {

         if (GetPriorityClass(GetCurrentProcess()) == IDLE_PRIORITY_CLASS)
                  dwCreationFlags |= IDLE_PRIORITY_CLASS;
      }

      pszApplName = (LPWSTR) HeapAlloc(hheap, 0, sizeof(WCHAR) * (MAX_PATH));
      //
      // Lookup the fullpathname of the specified executable
      //
      pszCmdLine = (LPWSTR) HeapAlloc(hheap, 0, sizeof(WCHAR) *
                                             (MAX_PATH + lstrlenW(lpCommandLine)));

      if(pszApplName == NULL || pszCmdLine == NULL)
      {
        LastError = ERROR_INVALID_PARAMETER;
        __leave;
      }


      if(lpApplicationName == NULL)
      {
         if(lpCommandLine != NULL)
         {
            //
            // Commandline contains the name, we should parse it out and get
            // the full path so that correct executable is invoked.
            //

            DWORD   Length;
            DWORD   fileattr;
            WCHAR   TempChar = L'\0';
            LPWSTR  TempApplName = NULL;
            LPWSTR  TempRemainderString = NULL;
            LPWSTR  WhiteScan = NULL;
            BOOL    SearchRetry = TRUE;
            LPWSTR  ApplName = (LPWSTR) HeapAlloc(
                                                hheap, 0,
                                                sizeof(WCHAR) * (lstrlenW(lpCommandLine)+1));

            LPWSTR  NameBuffer = (LPWSTR) HeapAlloc(
                                                hheap, 0,
                                                sizeof(WCHAR) * (MAX_PATH+1));

	    if (ApplName == NULL || NameBuffer == NULL)
	    {
	        LastError = ERROR_NOT_ENOUGH_MEMORY;
		__leave;
	    }

            lstrcpy(ApplName, lpCommandLine);
            WhiteScan = ApplName;

            //
            // if there is a leading quote
            //
            if(*WhiteScan == L'\"')
            {
                // we will NOT retry search, as app name is quoted.

                SearchRetry = FALSE;
                WhiteScan++;
                TempApplName = WhiteScan;
                while(*WhiteScan) {
                    if( *WhiteScan == L'\"')
                    {
                        TempChar = *WhiteScan;
                        *WhiteScan = L'\0';
                        TempRemainderString = WhiteScan;
                        break;
                    }
                    WhiteScan++;
                }
            }
            else
            {
                // skip to the first non-white char
                while(*WhiteScan) {
                    if( *WhiteScan == L' ' || *WhiteScan == L'\t')
                    {
                        WhiteScan++;
                    }
                    else
                        break;
                }
                TempApplName = WhiteScan;

                while(*WhiteScan) {
                    if( *WhiteScan == L' ' || *WhiteScan == L'\t')
                    {
                        TempChar = *WhiteScan;
                        *WhiteScan = L'\0';
                        TempRemainderString = WhiteScan;
                        break;
                    }
                    WhiteScan++;
                }

            }

RetrySearch:
            Length = SearchPathW(
                            NULL,
                            TempApplName,
                            (PWSTR)L".exe",
                            MAX_PATH,
                            NameBuffer,
                            NULL
                            );

            if(!Length || Length > MAX_PATH)
            {
                if(LastError)
                    SetLastError(LastError);
                else
                    LastError = GetLastError();

CoverForDirectoryCase:
                    //
                    // If we still have command line left, then keep going
                    // the point is to march through the command line looking
                    // for whitespace so we can try to find an image name
                    // launches of things like:
                    // c:\word 95\winword.exe /embedding -automation
                    // require this. Our first iteration will
                    // stop at c:\word, our next
                    // will stop at c:\word 95\winword.exe
                    //
                    if(TempRemainderString)
                    {
                        *TempRemainderString = TempChar;
                        WhiteScan++;
                    }
                    if(*WhiteScan & SearchRetry)
                    {
                        // again skip to the first non-white char
                        while(*WhiteScan) {
                            if( *WhiteScan == L' ' || *WhiteScan == L'\t')
                            {
                                WhiteScan++;
                            }
                            else
                                break;
                        }
                        while(*WhiteScan) {
                            if( *WhiteScan == L' ' || *WhiteScan == L'\t')
                            {
                                TempChar = *WhiteScan;
                                *WhiteScan = L'\0';
                                TempRemainderString = WhiteScan;
                                break;
                            }
                            WhiteScan++;
                        }
                        // we'll do one last try of the whole string.
                        if(!WhiteScan) SearchRetry = FALSE;
                        goto RetrySearch;
                    }

                    //
                    // otherwise we have failed.
                    //
                    if(NameBuffer) HeapFree(hheap, 0, NameBuffer);
                    if(ApplName) HeapFree(hheap, 0, ApplName);

                    // we should let CreateProcess do its job.
                    if (pszApplName)
                    {
                        HeapFree(hheap, 0, pszApplName);
                        pszApplName = NULL;
                    }
                    lstrcpy(pszCmdLine, lpCommandLine);
            }
            else
            {
                // searchpath succeeded.
                // but it can find a directory!
                fileattr = GetFileAttributesW(NameBuffer);
                if ( fileattr != 0xffffffff &&
                        (fileattr & FILE_ATTRIBUTE_DIRECTORY) ) {
                        Length = 0;
                        goto CoverForDirectoryCase;
                }

                //
                // so it is not a directory.. it must be the real thing!
                //
                lstrcpy(pszApplName, NameBuffer);
                lstrcpy(pszCmdLine, lpCommandLine);

                HeapFree(hheap, 0, ApplName);
                HeapFree(hheap, 0, NameBuffer);
            }

         }
         else
         {

            LastError = ERROR_INVALID_PARAMETER;
            __leave;
         }

      }
      else
      {

         //
         // If ApplicationName is not null, we need to handle
         // one case here -- the application name is present in
         // current directory.  All other cases will be handled by
         // CreateProcess in the server side anyway.
         //

         //
         // let us get a FullPath relative to current directory
         // and try to open it.  If it succeeds, then the full path
         // is what we'll give as app name.. otherwise will just
         // pass what we got from caller and let CreateProcess deal with it.

         LPWSTR lpFilePart;

         DWORD  cchFullPath = GetFullPathName(
                                            lpApplicationName,
                                            MAX_PATH,
                                            pszApplName,
                                            &lpFilePart
                                            );

         if(cchFullPath)
         {
             HANDLE hFile;
             //
             // let us try to open it.
             // if it works, pszApplName is already setup correctly.
             // just close the handle.

             hFile = CreateFile(lpApplicationName, GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL
                                );

             if(hFile == INVALID_HANDLE_VALUE)
             {
                // otherwise, keep what the caller gave us.
                lstrcpy(pszApplName,lpApplicationName);
             }
             else
                CloseHandle(hFile);

         }
         else
            // lets keep what the caller gave us.
            lstrcpyn(pszApplName, lpApplicationName, MAX_PATH);

         //
         // Commandline should be kept as is.
         //
         if(lpCommandLine != NULL)
                 lstrcpy(pszCmdLine, lpCommandLine);
         else
         {
            HeapFree(hheap, 0, pszCmdLine);
            pszCmdLine = NULL;
         }
      }

#if 0
      if(lpApplicationName != NULL) lstrcpy(pszApplName,lpApplicationName);
      else {
            HeapFree(hheap, 0, pszApplName);
            pszApplName = NULL;
      }
      if(lpCommandLine != NULL) lstrcpy(pszCmdLine, lpCommandLine);
      else {
            HeapFree(hheap, 0, pszCmdLine);
            pszCmdLine = NULL;
      }
#endif

      // Construct a memory block will all the info that needs to go to the server

      sli.lLogonIdHighPart   = 0;
      sli.ulLogonIdLowPart   = 0;
      sli.ulLogonFlags       = dwLogonFlags;
      sli.ulProcessId        = GetCurrentProcessId();
      sli.ulCreationFlags    = dwCreationFlags;

      ASSIGN_SECL_STRING(sli.ssUsername,          (LPWSTR) lpUsername);
      ASSIGN_SECL_STRING(sli.ssDomain,            (LPWSTR) lpDomain);
      ASSIGN_SECL_STRING(sli.ssPassword,          (LPWSTR)lpPassword);
      ASSIGN_SECL_STRING(sli.ssApplicationName,   pszApplName);
      ASSIGN_SECL_STRING(sli.ssCommandLine,       pszCmdLine);
      ASSIGN_SECL_STRING(sli.ssCurrentDirectory,  (LPWSTR)lpCurrentDirectory);
      ASSIGN_SECL_STRING(sli.ssDesktop,           lpStartupInfo->lpDesktop);
      ASSIGN_SECL_STRING(sli.ssTitle,             lpStartupInfo->lpTitle);

      if (0 != (sli.ulCreationFlags & CREATE_UNICODE_ENVIRONMENT)) {
          LastError = To_SECL_BLOB_W(lpEnvironment, &(sli.sbEnvironment));
      }
      else {
          LastError = To_SECL_BLOB_A(lpEnvironment, &(sli.sbEnvironment));
      }
      if (ERROR_SUCCESS != LastError) { __leave; }

      // If the caller hasn't specified their own desktop, we'll do it for 
      // them  (the seclogon service will take care of granting access
      // to the desktop). 
      if (sli.ssDesktop.pwsz == NULL || sli.ssDesktop.pwsz[0] == L'\0')
      {
          DWORD    Length;
          HWINSTA  Winsta  = myGetProcessWindowStation();
          HDESK    Desk    = myGetThreadDesktop(GetCurrentThreadId());
          
          // Send seclogon handles to the current windowstation and desktop: 
          if (0 == (dwLogonFlags & LOGON_NETCREDENTIALS_ONLY)) 
          {
              sli.hWinsta = (unsigned __int64)Winsta; 
              sli.hDesk   = (unsigned __int64)Desk; 
          } 
          else 
          {
              // In the /netonly case, we don't need to grant access to the desktop:
              sli.hWinsta = 0; 
              sli.hDesk = 0; 
          }

          // Send seclogon the name of the current windowstation and desktop. 
          // Default to empty string if we can't get the name: 
          ASSIGN_SECL_STRING(sli.ssDesktop, pwszEmptyString);
          
          if (myGetUserObjectInformation(Winsta, UOI_NAME, wszDesktopName, (MAX_PATH*sizeof(WCHAR)), &Length))
          {
              Length = wcslen(wszDesktopName); 
              wszDesktopName[Length++] = L'\\'; 
              
              if(myGetUserObjectInformation(Desk, UOI_NAME, &wszDesktopName[Length], (MAX_PATH*sizeof(WCHAR)), &Length))
              {
                  // sli.ssDesktop now contains "windowstation\desktop"
                  ASSIGN_SECL_STRING(sli.ssDesktop, wszDesktopName);
              }
          }
      } 
      else
      {
          LPWSTR pwszDeskName; 

          // The caller specified their own desktop
          sli.ulSeclogonFlags |= SECLOGON_CALLER_SPECIFIED_DESKTOP; 

          // Open a handle to the specified windowstation and desktop: 
          wcscpy(wszDesktopName, sli.ssDesktop.pwsz); 
          pwszDeskName = wcschr(wszDesktopName, L'\\'); 
          if (NULL == pwszDeskName)
          {
              SetLastError(ERROR_INVALID_PARAMETER); 
              __leave; 
          }
          *pwszDeskName++ = L'\0'; 
          
          hWinsta = myOpenWindowStation(wszDesktopName, TRUE, MAXIMUM_ALLOWED); 
          if (NULL == hWinsta)
              __leave; 

          hWinstaSave = myGetProcessWindowStation(); 
          if (NULL == hWinstaSave)
              __leave; 

          if (!mySetProcessWindowStation(hWinsta))
              __leave; 
          fRevertWinsta = TRUE; 

          hDesk = myOpenDesktop(pwszDeskName, 0, TRUE, MAXIMUM_ALLOWED); 
          if (NULL == hDesk)
              __leave; 

          // Pass the windowstation and desktop handles to seclogon: 
          sli.hWinsta  = (unsigned __int64)hWinsta; 
          sli.hDesk    = (unsigned __int64)hDesk; 
      }

      // Perform the RPC call to the seclogon service:
      LastError = c_SeclCreateProcessWithLogonW(&sli, &slri);
      if (ERROR_SUCCESS != LastError) __leave;

      fOk = (slri.ulErrorCode == NO_ERROR);  // This function succeeds if the server's function succeeds

      if (!fOk) {
          //
          // If the server function failed, set the server's
          // returned eror code as this thread's error code
          //
          LastError = slri.ulErrorCode;
          SetLastError(slri.ulErrorCode);
      } else {
          //
          // The server function succeeded, return the
          // PROCESS_INFORMATION info
          //
          lpProcessInformation->hProcess     = (HANDLE)slri.hProcess;
          lpProcessInformation->hThread      = (HANDLE)slri.hThread;
          lpProcessInformation->dwProcessId  = slri.ulProcessId;
          lpProcessInformation->dwThreadId   = slri.ulThreadId;
          LastError = ERROR_SUCCESS;
      }
   }
   __finally {
      if (NULL != pszCmdLine)   HeapFree(hheap, 0, pszCmdLine);
      if (NULL != pszApplName)  HeapFree(hheap, 0, pszApplName);
      if (fRevertWinsta)        mySetProcessWindowStation(hWinstaSave); 
      if (NULL != hWinsta)      myCloseWindowStation(hWinsta); 
      if (NULL != hDesk)        myCloseDesktop(hDesk); 
      SetLastError(LastError);
   }

   return(fOk);
}

////////////////////////////////////////////////////////////////////////
//
// RPC Utility methods:
//
////////////////////////////////////////////////////////////////////////

DWORD To_SECL_BLOB_W(IN   LPVOID      lpEnvironment,
                     OUT  SECL_BLOB  *psb) {
    DWORD    cb        = 0;
    DWORD    dwResult  = NULL;
    HANDLE   hHeap     = NULL;
    LPBYTE   pb        = NULL;
    LPWSTR   pwsz      = NULL;

    hHeap = GetProcessHeap();
    _JumpCondition(NULL == hHeap, GetProcessHeapError);

    if (NULL != lpEnvironment) {
        for (pwsz = (LPWSTR)lpEnvironment; pwsz[0] != L'\0'; pwsz += wcslen(pwsz) + 1);

        cb = sizeof(WCHAR) * (DWORD)(((1 + (pwsz - (LPWSTR)lpEnvironment))) & 0xFFFFFFFF);
        pb = (LPBYTE)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cb);
        _JumpCondition(NULL == pb, MemoryError);

        CopyMemory(pb, (LPBYTE)lpEnvironment, cb);
    }

    psb->cb  = cb;
    psb->pb  = pb;
    dwResult = ERROR_SUCCESS;
 CommonReturn:
    return dwResult;

 ErrorReturn:
    if (NULL != pb) { HeapFree(hHeap, 0, pb); }
    goto CommonReturn;

SET_DWRESULT(GetProcessHeapError, GetLastError());
SET_DWRESULT(MemoryError,         ERROR_NOT_ENOUGH_MEMORY);
}

DWORD To_SECL_BLOB_A(IN   LPVOID      lpEnvironment,
                     OUT  SECL_BLOB  *psb) {
    DWORD    cb        = 0;
    DWORD    dwResult;
    HANDLE   hHeap     = NULL;
    LPBYTE   pb        = NULL;
    LPSTR    psz       = NULL;

    hHeap = GetProcessHeap();
    _JumpCondition(NULL == hHeap, GetProcessHeapError);

    if (NULL != lpEnvironment) {
        for (psz = (LPSTR)lpEnvironment; psz[0] != '\0'; psz += strlen(psz) + 1);

        cb = (DWORD)((1 + (psz - (LPSTR)lpEnvironment) & 0xFFFFFFFF));
        pb = (LPBYTE)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cb);
        _JumpCondition(NULL == pb, MemoryError);

        CopyMemory(pb, (LPBYTE)lpEnvironment, cb);
    }

    psb->cb  = cb;
    psb->pb  = pb;
    dwResult = ERROR_SUCCESS;
 CommonReturn:
    return dwResult;

 ErrorReturn:
    if (NULL != pb) { HeapFree(hHeap, 0, pb); }
    goto CommonReturn;

SET_DWRESULT(GetProcessHeapError, GetLastError());
SET_DWRESULT(MemoryError,         ERROR_NOT_ENOUGH_MEMORY);
}


DWORD StartSeclogonService() {
    BOOL            fResult;
    DWORD           dwInitialCount;
    DWORD           dwResult;
    SC_HANDLE       hSCM;
    SC_HANDLE       hService;
    SERVICE_STATUS  sSvcStatus;

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    _JumpCondition(hSCM == NULL, OpenSCManagerError);

    hService = OpenService(hSCM, wszSvcName, SERVICE_START | SERVICE_QUERY_STATUS);
    _JumpCondition(NULL == hService, OpenServiceError);

    fResult = StartService(hService, NULL, NULL);
    _JumpCondition(FALSE == fResult, StartServiceError);

    // Wait until the service has actually started.
    // Set timeout to 20 seconds.
    dwInitialCount = GetTickCount();

    // Keep polling to see if the service has started ...
    while (TRUE)
    {
        fResult = QueryServiceStatus(hService, &sSvcStatus);
        _JumpCondition(FALSE == fResult, QueryServiceStatusError);

        // The service is running.  We can stop waiting for it.
        if (sSvcStatus.dwCurrentState == SERVICE_RUNNING)
            break;

        // Check to see if we've timed out.  If GetTickCount() rolls over,
        // then at worst we time out early.
        _JumpCondition((GetTickCount() - dwInitialCount) > 20000, ServiceTimeoutError);

        // Don't hose the service.
        SleepEx(100, FALSE);
    }

    // Ok, the service has successfully started.
    dwResult = ERROR_SUCCESS;
 CommonReturn:
    if (NULL != hSCM)     { CloseServiceHandle(hSCM); }
    if (NULL != hService) { CloseServiceHandle(hService); }
    return dwResult;

 ErrorReturn:
    goto CommonReturn;

SET_DWRESULT(OpenSCManagerError,       GetLastError());
SET_DWRESULT(OpenServiceError,         GetLastError());
SET_DWRESULT(QueryServiceStatusError,  GetLastError());
SET_DWRESULT(StartServiceError,        GetLastError());
SET_DWRESULT(ServiceTimeoutError,      ERROR_SERVICE_REQUEST_TIMEOUT);
}

DWORD c_SeclCreateProcessWithLogonW
(IN   SECL_SLI  *psli,
 OUT  SECL_SLRI *pslri)
{
    BOOL                 fResult;
    DWORD                dwResult;
    LPWSTR               pwszBinding  = NULL;
    RPC_BINDING_HANDLE   hRPCBinding  = NULL;

    dwResult = RpcStringBindingCompose
          (NULL,
           (USHORT *)L"ncacn_np",
           NULL,
           (USHORT *)L"\\PIPE\\" wszSeclogonSharedProcEndpointName,
           (USHORT *)L"Security=impersonation static false",
           (USHORT **)&pwszBinding);
    _JumpCondition(RPC_S_OK != dwResult, RpcStringBindingComposeError);

    dwResult = RpcBindingFromStringBinding((USHORT *)pwszBinding, &hRPCBinding);
    _JumpCondition(0 != dwResult, RpcBindingFromStringBindingError);

    // Perform the RPC call to the seclogon service.  If the call fails because the
    // service was not started, try again.  If the call still fails, give up.
    for (BOOL fFirstTry = TRUE; TRUE; fFirstTry = FALSE) {
        __try {
            SeclCreateProcessWithLogonW(hRPCBinding, psli, pslri);
            break;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
              dwResult = RpcExceptionCode();
              if ((RPC_S_SERVER_UNAVAILABLE == dwResult || RPC_S_UNKNOWN_IF == dwResult) && 
                  (TRUE == fFirstTry)) { 
                  // Ok, the seclogon service is probably just not started.
                  // Attempt to start it up and try again.
                  dwResult = StartSeclogonService();
                  _JumpCondition(ERROR_SUCCESS != dwResult, SeclCreateProcessWithLogonWError);
              }
              else {
                  goto SeclCreateProcessWithLogonWError;
              }
        }
    }

    dwResult = ERROR_SUCCESS;
 CommonReturn:
    if (NULL != pwszBinding) { RpcStringFree((USHORT **)&pwszBinding); }
    if (NULL != hRPCBinding) { RpcBindingFree(&hRPCBinding); }
    return dwResult;

 ErrorReturn:
    goto CommonReturn;

SET_DWRESULT(RpcBindingFromStringBindingError,  dwResult);
SET_DWRESULT(RpcStringBindingComposeError,      dwResult);
SET_DWRESULT(SeclCreateProcessWithLogonWError,  dwResult);
}

void DbgPrintf( DWORD dwSubSysId, LPCSTR pszFormat , ...)
{
}

//////////////////////////////// End Of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.c

Abstract:

    AdvApi32.dll initialization

Author:

    Robert Reichel (RobertRe) 8-12-92

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <marta.h>
#include <winsvcp.h>
#include "advapi.h"
#include "tsappcmp.h"


extern CRITICAL_SECTION    FeClientLoadCritical;
extern CRITICAL_SECTION    SddlSidLookupCritical;
extern CRITICAL_SECTION    MSChapChangePassword;

extern BOOL gbDllHasThreadState;

//
// Local prototypes for functions that seem to have no prototypes.
//

BOOLEAN
RegInitialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    );

BOOLEAN
Sys003Initialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    );

BOOLEAN
AppmgmtInitialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    );

BOOLEAN
WmiDllInitialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    );

BOOLEAN
CodeAuthzInitialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    );

BOOLEAN AdvApi_InitializeTermsrvFpns( BOOLEAN *pIsInRelaxedSecurityMode ,  DWORD *pdwCompatFlags  );  // app server has two modes for app compat


#define ADVAPI_PROCESS_ATTACH   ( 1 << DLL_PROCESS_ATTACH )
#define ADVAPI_PROCESS_DETACH   ( 1 << DLL_PROCESS_DETACH )
#define ADVAPI_THREAD_ATTACH    ( 1 << DLL_THREAD_ATTACH )
#define ADVAPI_THREAD_DETACH    ( 1 << DLL_THREAD_DETACH )

typedef struct _ADVAPI_INIT_ROUTINE {
    PDLL_INIT_ROUTINE InitRoutine ;
    ULONG Flags ;
} ADVAPI_INIT_ROUTINE, * PADVAPI_INIT_ROUTINE ;


//
// Place all ADVAPI32 initialization hooks in this
// table.
//

ADVAPI_INIT_ROUTINE AdvapiInitRoutines[] = {

    { (PDLL_INIT_ROUTINE) RegInitialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH |
            ADVAPI_THREAD_DETACH },

    { (PDLL_INIT_ROUTINE) Sys003Initialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH },

    { (PDLL_INIT_ROUTINE) MartaDllInitialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH },

    { (PDLL_INIT_ROUTINE) AppmgmtInitialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH },

    { (PDLL_INIT_ROUTINE) WmiDllInitialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH },

    { (PDLL_INIT_ROUTINE) CodeAuthzInitialize,
            ADVAPI_PROCESS_ATTACH |
            ADVAPI_PROCESS_DETACH }

};



//
// Place all critical sections used in advapi32 here:
//

PRTL_CRITICAL_SECTION AdvapiCriticalSections[] = {
        &FeClientLoadCritical,
        &SddlSidLookupCritical,
        &Logon32Lock,
        &MSChapChangePassword
};


BOOLEAN
DllInitialize(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context
    )
{
    BOOLEAN Result = TRUE;
    int i ;
    NTSTATUS Status ;
    ULONG ReasonMask ;

    //
    // First, handle all the critical sections
    //


    if ( Reason == DLL_PROCESS_ATTACH ) {

        //
        // Note -- we no longer call DisableThreadLibraryCalls
        // because we need these so win32 local registry
        // can clean up its state
        //

        Result = TRUE ;

        for ( i = 0 ;
              i < sizeof( AdvapiCriticalSections ) / sizeof ( PRTL_CRITICAL_SECTION ) ;
              i++ )
        {
            Status = RtlInitializeCriticalSection( AdvapiCriticalSections[ i ] );

            if ( !NT_SUCCESS( Status ) )
            {
#if DBG
                DbgPrint("ADVAPI:  Failed to initialize critical section %p\n",
                            AdvapiCriticalSections[ i ] );
#endif

                Result = FALSE ;
                break;
            }
        }

        if ( !Result )
        {
            i-- ;

            while ( i )
            {
                RtlDeleteCriticalSection( AdvapiCriticalSections[ i ] );
                i-- ;

            }
            return FALSE ;
        }

        if (IsTerminalServer()) {

            BOOLEAN isInRelaxedSecurityMode = FALSE ;       // app server is in standard or relaxed security mode
            DWORD   dwCompatFlags=0;

            if( AdvApi_InitializeTermsrvFpns( & isInRelaxedSecurityMode , &dwCompatFlags) )
            {
                if ( isInRelaxedSecurityMode )
                {
                    // If TS reg key redirection is enabled, then get our special reg key extention flag for this app
                    // called "gdwRegistryExtensionFlags" which is used in screg\winreg\server\ files.
                    // This flag control HKCR per user virtualization and HKLM\SW\Classes per user virtualization and
                    // also modification to access mask.
                    //
                    // Basically, only non-system, non-ts-aware apps on the app server will have this enabled.
                    // Also, we only provide this feature in the relaxed security mode.
                    //
                    // Future work, add DISABLE mask support on per app basis, so that we can turn off this
                    // reg extenion feature on per app basis (just in case).
                    //
                    GetRegistryExtensionFlags( dwCompatFlags );
                }
            }
        }

    }

    //
    // Now, run the subcomponents initialization routines
    //

    ReasonMask = 1 << Reason ;

    for ( i = 0 ;
          i < sizeof( AdvapiInitRoutines ) / sizeof( ADVAPI_INIT_ROUTINE ) ;
          i++ )
    {
        if ( ( AdvapiInitRoutines[i].Flags & ReasonMask ) != 0 )
        {
            Result = AdvapiInitRoutines[i].InitRoutine( hmod, Reason, Context );

            if ( !Result )
            {
#if DBG
                DbgPrint( "ADVAPI:  sub init routine %p failed\n",
                            AdvapiInitRoutines[ i ].InitRoutine );
#endif
                break;
            }
        }
    }

    if ( !Result )
    {
        if ( Reason == DLL_PROCESS_ATTACH )
        {
            i-- ;

            while ( i )
            {
                RtlDeleteCriticalSection( AdvapiCriticalSections[ i ] );
                i-- ;

            }
        }
        return Result ;
    }


    //
    // If this is the process detach, clean up all the critical sections
    // after the hooks are run.
    //

    if ( Reason == DLL_PROCESS_DETACH )
    {
        for ( i = 0 ;
              i < sizeof( AdvapiCriticalSections ) / sizeof ( PRTL_CRITICAL_SECTION ) ;
              i++ )
        {
            Status = RtlDeleteCriticalSection( AdvapiCriticalSections[ i ] );

            if ( !NT_SUCCESS( Status ) )
            {
                Result = FALSE ;
                break;
            }
        }
    }

#if DBG
        SccInit(Reason);
#endif // DBG

    return( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\eventapi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    EVENTAPI.C

Abstract:

    This module contains the client ends of the EventLog APIs.

Author:

    Rajen Shah  (rajens)    24-Aug-1991


Revision History:


--*/

#include "advapi.h"

static WCHAR wszDosDevices[] = L"\\DosDevices\\";

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


BOOL
InitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

    This is RtlInitAnsiString with a return status that rejects strings
    that are greater than 64K bytes.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length = 0;
    DestinationString->Length = 0;
    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            Length++;
        }

        //
        // Make sure the length won't overflow a USHORT when converted to
        // UNICODE characters
        //

        if (Length * sizeof(WCHAR) > 0xFFFF) {
            return(FALSE);
        }

        DestinationString->Length = (USHORT) Length;
        DestinationString->MaximumLength = (USHORT) (Length + 1);

    }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
    }

    return(TRUE);
}


BOOL
InitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The InitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

    This is RtlInitUnicodeString with a return status that rejects strings
    that are greater than 64K bytes.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length = 0;
    DestinationString->Length = 0;
    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            Length += sizeof(*SourceString);
        }

        //
        // Make sure the length won't overflow a USHORT
        //

        if (Length > 0xFFFF) {
            return(FALSE);
        }

        DestinationString->Length = (USHORT) Length;
        DestinationString->MaximumLength =
            (USHORT) Length + (USHORT) sizeof(UNICODE_NULL);
    }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
    }

    return(TRUE);
}

//
// Single version API's (no strings)
//

BOOL
CloseEventLog (
    HANDLE hEventLog
    )

/*++

Routine Description:

  This is the client DLL entry point for the WinCloseEventLog API.
  It closes the RPC binding, and frees any memory allocated for the
  handle.

  NOTE that there is no equivalent call for ANSI.

Arguments:

    LogHandle       - Handle returned from a previous "Open" call.


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{
    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfCloseEventLog (hEventLog);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}



BOOL
DeregisterEventSource (
    HANDLE hEventLog
    )

/*++

Routine Description:

  This is the client DLL entry point for the DeregisterEventSource API.
  It closes the RPC binding, and frees any memory allocated for the
  handle.

  NOTE that there is no equivalent call for ANSI.

Arguments:

    LogHandle       - Handle returned from a previous "Open" call.


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{
    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfDeregisterEventSource (hEventLog);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}

BOOL
NotifyChangeEventLog(
    HANDLE  hEventLog,
    HANDLE  hEvent
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS Status;

    Status = ElfChangeNotify(hEventLog,hEvent);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return(FALSE);
    } else {
        return(TRUE);
    }
}

BOOL
GetNumberOfEventLogRecords (
    HANDLE hEventLog,
    PDWORD NumberOfRecords
    )

/*++

Routine Description:

  This is the client DLL entry point that returns the number of records in
  the eventlog specified by hEventLog.

  NOTE that there is no equivalent call for ANSI.

Arguments:

    LogHandle       - Handle returned from a previous "Open" call.
    NumberOfRecords - Pointer to a DWORD to place the number of records.


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{
    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfNumberOfRecords (hEventLog, NumberOfRecords);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}



BOOL
GetOldestEventLogRecord (
    HANDLE hEventLog,
    PDWORD OldestRecord
    )

/*++

Routine Description:

  This is the client DLL entry point that returns the record number of the
  oldest record in the eventlog specified by hEventLog.

  NOTE that there is no equivalent call for ANSI.

Arguments:

    LogHandle       - Handle returned from a previous "Open" call.
    OldestRecord    - Pointer to a DWORD to place the record number of the
                      oldest record in the eventlog specified by hEventLog


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{
    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfOldestRecord (hEventLog, OldestRecord);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}


BOOL
GetEventLogInformation (
    HANDLE    hEventLog,
    DWORD     dwInfoLevel,
    PVOID     lpBuffer,
    DWORD     cbBufSize,
    LPDWORD   pcbBytesNeeded
    )

/*++

Routine Description:

  This is the client DLL entry point that returns information about
  the eventlog specified by hEventLog.

Arguments:

    LogHandle       - Handle returned from a previous "Open" call.
    dwInfoLevel     - Which information to return
    lpBuffer        - Pointer to buffer to hold information
    cbBufSize       - Size of buffer, in bytes
    pcbBytesNeeded  - Number of bytes needed

Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{
    NTSTATUS ntStatus;

    ntStatus = ElfGetLogInformation(hEventLog,
                                    dwInfoLevel,
                                    lpBuffer,
                                    cbBufSize,
                                    pcbBytesNeeded);

    if (!NT_SUCCESS(ntStatus)) {
        BaseSetLastNTError(ntStatus);
        return FALSE;
    }

    return TRUE;
}


//
// UNICODE APIs
//

BOOL
ClearEventLogW (
    HANDLE hEventLog,
    LPCWSTR BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the ClearEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.
                      NULL implies not to back up the file.


Return Value:

    TRUE if success, FALSE otherwise.


--*/
{

    UNICODE_STRING Unicode;
    UNICODE_STRING DLUnicode;   // Downlevel NT filename.
    NTSTATUS Status;
    BOOL ReturnValue;

    //
    // Turn the Dos filename into an NT filename
    //

    if (BackupFileName) {
        ReturnValue = RtlDosPathNameToNtPathName_U(BackupFileName, &Unicode, NULL, NULL);
        if (!BackupFileName || !ReturnValue) {
           SetLastError(ERROR_INVALID_PARAMETER);
           return(FALSE);
        }
    }
    else {
        Unicode.Length = 0;
        Unicode.MaximumLength = 0;
        Unicode.Buffer = NULL;
    }

    Status = ElfClearEventLogFileW (hEventLog, &Unicode);

    //
    // With NT 4.0, NT filenames are preceeded with \?? vs. \DosDevices
    // in 3.51. This retry logic exists for 3.51 machines which don't
    // recognize NT 4.0 filenames. The API should have passed Windows
    // filenames vs NT.
    //

    if (Status == STATUS_OBJECT_PATH_NOT_FOUND && BackupFileName != NULL) {
        DLUnicode.MaximumLength = (wcslen(BackupFileName) * sizeof(WCHAR)) +
                                            sizeof(wszDosDevices);

        DLUnicode.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                DLUnicode.MaximumLength);

        if (DLUnicode.Buffer != NULL) {
            wcscpy(DLUnicode.Buffer, wszDosDevices);
            wcscat(DLUnicode.Buffer, BackupFileName);
            DLUnicode.Length = DLUnicode.MaximumLength - sizeof(UNICODE_NULL);

            Status = ElfClearEventLogFileW (hEventLog, &DLUnicode);
            RtlFreeHeap(RtlProcessHeap(), 0, DLUnicode.Buffer);
        }
        else {
            Status = STATUS_NO_MEMORY;
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }

    if (Unicode.MaximumLength) {
        RtlFreeHeap(RtlProcessHeap(), 0, Unicode.Buffer);
    }
    return ReturnValue;

}



BOOL
BackupEventLogW (
    HANDLE hEventLog,
    LPCWSTR BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the BackupEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.


Return Value:

    TRUE if success, FALSE otherwise.


--*/
{

    UNICODE_STRING Unicode;
    UNICODE_STRING DLUnicode;   // Downlevel NT filename.
    NTSTATUS Status;
    BOOL ReturnValue = TRUE;

    //
    // Turn the Dos filename into an NT filename
    //

    if (BackupFileName) {
        ReturnValue = RtlDosPathNameToNtPathName_U(BackupFileName, &Unicode,
            NULL, NULL);
    }

    if (!BackupFileName || !ReturnValue) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    Status = ElfBackupEventLogFileW (hEventLog, &Unicode);

    //
    // With NT 4.0, NT filenames are preceeded with \?? vs. \DosDevices
    // in 3.51. This retry logic exists for 3.51 machines which don't
    // recognize NT 4.0 filenames. The API should have passed Windows
    // filenames vs NT.
    //

    if (Status == STATUS_OBJECT_PATH_NOT_FOUND && BackupFileName != NULL) {
        DLUnicode.MaximumLength = (wcslen(BackupFileName) * sizeof(WCHAR)) +
                                            sizeof(wszDosDevices);

        DLUnicode.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                DLUnicode.MaximumLength);

        if (DLUnicode.Buffer != NULL) {
            wcscpy(DLUnicode.Buffer, wszDosDevices);
            wcscat(DLUnicode.Buffer, BackupFileName);
            DLUnicode.Length = DLUnicode.MaximumLength - sizeof(UNICODE_NULL);

            Status = ElfBackupEventLogFileW (hEventLog, &DLUnicode);
            RtlFreeHeap(RtlProcessHeap(), 0, DLUnicode.Buffer);
        }
        else {
            Status = STATUS_NO_MEMORY;
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }

    if (Unicode.MaximumLength) {
        RtlFreeHeap(RtlProcessHeap(), 0, Unicode.Buffer);
    }
    return ReturnValue;

}


HANDLE
OpenEventLogW (
    LPCWSTR  UNCServerName,
    LPCWSTR  ModuleName
    )

/*++

Routine Description:

    This is the client DLL entry point for the WinOpenEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName     - Server with which to bind for subsequent operations.

    ModuleName        - Supplies the name of the module to associate with
                        this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    UNICODE_STRING Unicode;
    UNICODE_STRING UnicodeModuleName;
    HANDLE LogHandle;
    NTSTATUS Status;
    HANDLE ReturnHandle;

    RtlInitUnicodeString(&UnicodeModuleName,ModuleName);
    RtlInitUnicodeString(&Unicode, UNCServerName);

    Status = ElfOpenEventLogW (
                        &Unicode,
                        &UnicodeModuleName,
                        &LogHandle
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnHandle = (HANDLE)NULL;
    } else {
        ReturnHandle = (HANDLE)LogHandle;
    }

    return ReturnHandle;
}


HANDLE
RegisterEventSourceW (
    LPCWSTR  UNCServerName,
    LPCWSTR  ModuleName
    )

/*++

Routine Description:

    This is the client DLL entry point for the RegisterEventSource API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName     - Server with which to bind for subsequent operations.

    ModuleName        - Supplies the name of the module to associate with
                        this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    UNICODE_STRING Unicode;
    UNICODE_STRING UnicodeModuleName;
    HANDLE LogHandle;
    NTSTATUS Status;
    HANDLE ReturnHandle;

    RtlInitUnicodeString(&UnicodeModuleName,ModuleName);
    RtlInitUnicodeString(&Unicode, UNCServerName);

    Status = ElfRegisterEventSourceW (
                        &Unicode,
                        &UnicodeModuleName,
                        &LogHandle
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnHandle = (HANDLE)NULL;
    } else {
        ReturnHandle = (HANDLE)LogHandle;
    }

    return ReturnHandle;
}


HANDLE
OpenBackupEventLogW (
    LPCWSTR  UNCServerName,
    LPCWSTR  FileName
    )

/*++

Routine Description:

    This is the client DLL entry point for the OpenBackupEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName   - Server with which to bind for subsequent operations.

    FileName        - Supplies the filename of the logfile to associate with
                      this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    UNICODE_STRING Unicode;
    UNICODE_STRING UnicodeFileName;
    UNICODE_STRING DLUnicode;   // Downlevel NT filename.
    HANDLE LogHandle;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE ReturnHandle;

    RtlInitUnicodeString(&Unicode, UNCServerName);
    RtlInitUnicodeString(&UnicodeFileName, NULL);

    //
    // Turn the Dos filename into an NT filename if it was given
    //
    if (FileName)
    {
        if (!RtlDosPathNameToNtPathName_U(FileName, &UnicodeFileName, NULL, NULL))
        {
            Status = STATUS_OBJECT_NAME_INVALID;
        }
    }

    if (NT_SUCCESS(Status))
    {
        Status = ElfOpenBackupEventLogW (
                            &Unicode,
                            &UnicodeFileName,
                            &LogHandle
                            );

        //
        // With NT 4.0, NT filenames are preceeded with \?? vs. \DosDevices
        // in 3.51. This retry logic exists for 3.51 machines which don't
        // recognize NT 4.0 filenames. The API should have passed Windows
        // filenames vs NT.
        //

        if (Status == STATUS_OBJECT_PATH_NOT_FOUND && FileName != NULL)
        {
            DLUnicode.MaximumLength = (wcslen(FileName) * sizeof(WCHAR)) +
                                                sizeof(wszDosDevices);

            DLUnicode.Buffer = RtlAllocateHeap(
                                    RtlProcessHeap(), 0,
                                    DLUnicode.MaximumLength);

            if (DLUnicode.Buffer != NULL)
            {
                wcscpy(DLUnicode.Buffer, wszDosDevices);
                wcscat(DLUnicode.Buffer, FileName);
                DLUnicode.Length = DLUnicode.MaximumLength - sizeof(UNICODE_NULL);

                Status = ElfOpenBackupEventLogW (
                                    &Unicode,
                                    &DLUnicode,
                                    &LogHandle
                                );
                RtlFreeHeap(RtlProcessHeap(), 0, DLUnicode.Buffer);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
            }
        }
    }

    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        ReturnHandle = NULL;
    }
    else
    {
        ReturnHandle = LogHandle;
    }

    if (UnicodeFileName.MaximumLength)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeFileName.Buffer);
    }

    return ReturnHandle;
}





BOOL
ReadEventLogW (
    HANDLE      hEventLog,
    DWORD       dwReadFlags,
    DWORD       dwRecordOffset,
    LPVOID      lpBuffer,
    DWORD       nNumberOfBytesToRead,
    DWORD       *pnBytesRead,
    DWORD       *pnMinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the client DLL entry point for the WinreadEventLog API.

Arguments:



Return Value:

    Returns count of bytes read. Zero of none read.


--*/
{

    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfReadEventLogW (
                        hEventLog,
                        dwReadFlags,
                        dwRecordOffset,
                        lpBuffer,
                        nNumberOfBytesToRead,
                        pnBytesRead,
                        pnMinNumberOfBytesNeeded
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}



BOOL
ReportEventW (
    HANDLE      hEventLog,
    WORD        wType,
    WORD        wCategory       OPTIONAL,
    DWORD       dwEventID,
    PSID        lpUserSid       OPTIONAL,
    WORD        wNumStrings,
    DWORD       dwDataSize,
    LPCWSTR     *lpStrings      OPTIONAL,
    LPVOID      lpRawData       OPTIONAL
    )

/*++

Routine Description:

  This is the client DLL entry point for the ReportEvent API.

Arguments:


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL ReturnValue;
    PUNICODE_STRING  *pUStrings;
    ULONG   i;
    ULONG AllocatedStrings;

    //
    // Convert the array of strings to an array of PUNICODE_STRINGs
    // before calling ElfReportEventW.
    //
    pUStrings = RtlAllocateHeap(
                            RtlProcessHeap(), 0,
                            wNumStrings * sizeof(PUNICODE_STRING)
                            );

    if (pUStrings) {

        //
        // Guard the memory allocation above while we peruse the user's
        // buffer. If not, we'd leak it on an exception.
        //

        try {
            //
            // For each string passed in, allocate a UNICODE_STRING structure
            // and set it to the matching string.
            //
            for (AllocatedStrings = 0; AllocatedStrings < wNumStrings;
              AllocatedStrings++) {
                pUStrings[AllocatedStrings] = RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                sizeof(UNICODE_STRING)
                                );

                if (pUStrings[AllocatedStrings]) {

                    if (!InitUnicodeString(
                                pUStrings[AllocatedStrings],
                                lpStrings[AllocatedStrings]
                                )) {
                        //
                        // This string was invalid (> 64K bytes) give up
                        // and make sure we only free the ones we've already
                        // allocated (including this last one)
                        //

                        AllocatedStrings++;
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }
                }
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_INVALID_PARAMETER;
        }

        if (Status == STATUS_SUCCESS) {
            Status = ElfReportEventW (
                            hEventLog,
                            wType,
                            wCategory,
                            dwEventID,
                            lpUserSid,
                            wNumStrings,
                            dwDataSize,
                            pUStrings,
                            lpRawData,
                            0,            // Flags        -  Paired event
                            NULL,         // RecordNumber  | support.  Not
                            NULL          // TimeWritten  -  in P1
                            );
        }

        //
        // Free the space allocated for the UNICODE strings
        // and then free the space for the array.
        //
        for (i = 0; i < AllocatedStrings; i++) {
            if (pUStrings[i])
                RtlFreeHeap (RtlProcessHeap(), 0, pUStrings[i]);
        }
        RtlFreeHeap (RtlProcessHeap(), 0, pUStrings);

    } else {
        Status = STATUS_NO_MEMORY;
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }

    return ReturnValue;

}


//
// ANSI APIs
//

BOOL
ClearEventLogA (
    HANDLE  hEventLog,
    LPCSTR  BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the ClearEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.
                      NULL implies not to back up the file.


Return Value:

    TRUE if success, FALSE otherwise.


--*/
{

    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    BOOL ReturnValue;

    //
    // Turn the backup filename into UNICODE
    //

    if (BackupFileName) {
        RtlInitAnsiString(&AnsiString, BackupFileName);
        Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString,
            TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return(FALSE);
        }
    }
    else {
        RtlInitUnicodeString(&UnicodeString, NULL);
    }

    ReturnValue = ClearEventLogW (hEventLog, (LPCWSTR)UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    return(ReturnValue);
}



BOOL
BackupEventLogA (
    HANDLE  hEventLog,
    LPCSTR  BackupFileName
    )

/*++

Routine Description:

  This is the client DLL entry point for the BackupEventLogFile API.
  The call is passed to the eventlog service on the appropriate server
  identified by LogHandle.


Arguments:

    LogHandle       - Handle returned from a previous "Open" call. This is
                      used to identify the module and the server.

    BackupFileName  - Name of the file to back up the current log file.


Return Value:

    TRUE if success, FALSE otherwise.


--*/
{

    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    BOOL ReturnValue;

    //
    // Turn the backup filename into UNICODE
    //

    if (BackupFileName) {
        RtlInitAnsiString(&AnsiString, BackupFileName);
        Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString,
            TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return(FALSE);
        }
    }
    else {
        RtlInitUnicodeString(&UnicodeString, NULL);
    }

    ReturnValue = BackupEventLogW (hEventLog, (LPCWSTR)UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    return(ReturnValue);

}


HANDLE
OpenEventLogA (
    LPCSTR   UNCServerName,
    LPCSTR   ModuleName
    )

/*++

Routine Description:

    This is the client DLL entry point for the WinOpenEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName     - Server with which to bind for subsequent operations.

    ModuleName        - Supplies the name of the module to associate with
                        this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    ANSI_STRING AnsiString;
    ANSI_STRING AnsiModuleName;
    NTSTATUS Status;
    HANDLE LogHandle;
    HANDLE ReturnHandle;

    RtlInitAnsiString(&AnsiModuleName,ModuleName);
    RtlInitAnsiString(&AnsiString, UNCServerName);

    Status = ElfOpenEventLogA (
                        &AnsiString,
                        &AnsiModuleName,
                        &LogHandle
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnHandle = (HANDLE)NULL;
    } else {
        ReturnHandle = (HANDLE)LogHandle;
    }

    return ReturnHandle;
}


HANDLE
RegisterEventSourceA (
    LPCSTR   UNCServerName,
    LPCSTR   ModuleName
    )

/*++

Routine Description:

    This is the client DLL entry point for the RegisterEventSource API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName     - Server with which to bind for subsequent operations.

    ModuleName        - Supplies the name of the module to associate with
                        this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    ANSI_STRING AnsiString;
    ANSI_STRING AnsiModuleName;
    NTSTATUS Status;
    HANDLE LogHandle;
    HANDLE ReturnHandle;

    RtlInitAnsiString(&AnsiModuleName,ModuleName);
    RtlInitAnsiString(&AnsiString, UNCServerName);

    Status = ElfRegisterEventSourceA (
                        &AnsiString,
                        &AnsiModuleName,
                        &LogHandle
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnHandle = (HANDLE)NULL;
    } else {
        ReturnHandle = (HANDLE)LogHandle;
    }

    return ReturnHandle;
}


HANDLE
OpenBackupEventLogA (
    LPCSTR   UNCServerName,
    LPCSTR   FileName
    )

/*++

Routine Description:

    This is the client DLL entry point for the OpenBackupEventLog API.

    It creates an RPC binding for the server specified, and stores that
    and additional data away. It returns a handle to the caller that can
    be used to later on access the handle-specific information.

Arguments:

    UNCServerName   - Server with which to bind for subsequent operations.

    FileName        - Supplies the filename of the logfile to associate with
                      this handle.


Return Value:

    Returns a handle that can be used for subsequent Win API calls. If
    the handle is NULL, then an error occurred.


--*/
{

    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeServerName;
    UNICODE_STRING UnicodeFileName;
    NTSTATUS Status;
    HANDLE ReturnHandle;

    //
    // Turn the servername into UNICODE
    //

    if (UNCServerName) {
        RtlInitAnsiString(&AnsiString, UNCServerName);
        Status = RtlAnsiStringToUnicodeString(&UnicodeServerName, &AnsiString,
            TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return(NULL);
        }
    }
    else {
        RtlInitUnicodeString(&UnicodeServerName, NULL);
    }

    //
    // Turn the filename into UNICODE
    //

    if (FileName) {
        RtlInitAnsiString(&AnsiString, FileName);
        Status = RtlAnsiStringToUnicodeString(&UnicodeFileName, &AnsiString,
            TRUE);
        if ( !NT_SUCCESS(Status) ) {
            RtlFreeUnicodeString(&UnicodeServerName);
            BaseSetLastNTError(Status);
            return(NULL);
        }
    }
    else {
        RtlInitUnicodeString(&UnicodeFileName, NULL);
    }

    ReturnHandle = OpenBackupEventLogW ((LPCWSTR)UnicodeServerName.Buffer,
        (LPCWSTR)UnicodeFileName.Buffer);
    RtlFreeUnicodeString(&UnicodeServerName);
    RtlFreeUnicodeString(&UnicodeFileName);
    return(ReturnHandle);

}





BOOL
ReadEventLogA (
    HANDLE      hEventLog,
    DWORD       dwReadFlags,
    DWORD       dwRecordOffset,
    LPVOID      lpBuffer,
    DWORD       nNumberOfBytesToRead,
    DWORD       *pnBytesRead,
    DWORD       *pnMinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the client DLL entry point for the WinreadEventLog API.

Arguments:



Return Value:

    Returns count of bytes read. Zero of none read.


--*/
{

    NTSTATUS Status;
    BOOL ReturnValue;

    Status = ElfReadEventLogA (
                        hEventLog,
                        dwReadFlags,
                        dwRecordOffset,
                        lpBuffer,
                        nNumberOfBytesToRead,
                        pnBytesRead,
                        pnMinNumberOfBytesNeeded
                        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }
    return ReturnValue;

}



BOOL
ReportEventA (
    HANDLE      hEventLog,
    WORD        wType,
    WORD        wCategory       OPTIONAL,
    DWORD       dwEventID,
    PSID        lpUserSid       OPTIONAL,
    WORD        wNumStrings,
    DWORD       dwDataSize,
    LPCSTR      *lpStrings      OPTIONAL,
    LPVOID      lpRawData       OPTIONAL
    )

/*++

Routine Description:

  This is the client DLL entry point for the ReportEvent API.

Arguments:


Return Value:

    Returns TRUE if success, FALSE otherwise.


--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL ReturnValue;
    PANSI_STRING *pAStrings;
    ULONG       i;
    ULONG AllocatedStrings;

    //
    // Convert the array of strings to an array of PANSI_STRINGs
    // before calling ElfReportEventW.
    //
    pAStrings = RtlAllocateHeap(
                            RtlProcessHeap(), 0,
                            wNumStrings * sizeof(PANSI_STRING)
                            );

    if (pAStrings) {

        //
        // Guard the memory allocation above while we peruse the user's
        // buffer. If not, we'd leak it on an exception.
        //

        try {
            //
            // For each string passed in, allocate an ANSI_STRING structure
            // and fill it in with the string.
            //
            for (AllocatedStrings = 0; AllocatedStrings < wNumStrings;
              AllocatedStrings++) {
                pAStrings[AllocatedStrings] = RtlAllocateHeap(
                                        RtlProcessHeap(), 0,
                                        sizeof(ANSI_STRING)
                                        );

                if (pAStrings[AllocatedStrings]) {

                    if (!InitAnsiString(
                                pAStrings[AllocatedStrings],
                                lpStrings[AllocatedStrings]
                                )) {
                        //
                        // This string was invalid (> 32K chars) give up
                        // and make sure we only free the ones we've already
                        // allocated (including this last one)
                        //

                        AllocatedStrings++;
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }
                }
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_INVALID_PARAMETER;
        }

        if (Status == STATUS_SUCCESS) {
            Status = ElfReportEventA (
                            hEventLog,
                            wType,
                            wCategory,
                            dwEventID,
                            lpUserSid,
                            wNumStrings,
                            dwDataSize,
                            pAStrings,
                            lpRawData,
                            0,            // Flags        -  Paired event
                            NULL,         // RecordNumber  | support.  Not
                            NULL          // TimeWritten  -  in P1
                            );
        }

        //
        // Free all the memory that was allocated
        //
        for (i = 0; i < AllocatedStrings; i++) {
            if (pAStrings[i])
                RtlFreeHeap (RtlProcessHeap(), 0, pAStrings[i]);
        }
        RtlFreeHeap (RtlProcessHeap(), 0, pAStrings);

    } else {
        Status = STATUS_NO_MEMORY;
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
    } else {
        ReturnValue = TRUE;
    }

    return ReturnValue;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\makefile.inc ===
PRIVLIB= $(O)\advapip.lib
$(O)\advapi32.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\advapip.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\advapip.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\advapip.def: advapi32.def
    $(C_PREPROCESSOR) $** -DPRIVATE= > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\isuni.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    isuni.c

Abstract:

    Covering routine for RtlIsUnicode string, since this is declare a BOOL
    API and Rtl is BOOLEAN

Author:

    Steve Wood (stevewo) 16-Dec-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

BOOL
WINAPI
IsTextUnicode(
    CONST VOID* lpv,
    int iSize,
    LPINT lpiResult
    )
{
    if (RtlIsTextUnicode( lpv, iSize, lpiResult )) {
        return TRUE;
        }
    else {
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\logon32.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       logon32.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-30-94   RichardW   Created
//
//----------------------------------------------------------------------------


#include "advapi.h"
#include <crypt.h>
#include <mpr.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <wchar.h>
#include <stdlib.h>
#include <lmcons.h>

#define SECURITY_WIN32
#include <security.h>

#include <windows.h>

#include <winbase.h>
#include <winbasep.h>
#include <execsrv.h>


//
// We dynamically load mpr.dll (no big surprise there), in order to call
// WNetLogonNotify, as defined in private\inc\mpr.h.  This prototype matches
// it -- consult the header file for all the parameters.
//
typedef (* LOGONNOTIFYFN)(LPCWSTR, PLUID, LPCWSTR, LPVOID,
                            LPCWSTR, LPVOID, LPWSTR, LPVOID, LPWSTR *);

//
// The QuotaLimits are global, because the defaults
// are always used for accounts, based on server/wksta, and no one ever
// calls lsasetaccountquota
//

HANDLE      Logon32LsaHandle = NULL;
ULONG       Logon32MsvHandle = 0xFFFFFFFF;
ULONG       Logon32NegoHandle = 0xFFFFFFFF;
WCHAR       Logon32DomainName[DNLEN+1] = L"";

QUOTA_LIMITS    Logon32QuotaLimits;
HINSTANCE       Logon32MprHandle = NULL;
LOGONNOTIFYFN   Logon32LogonNotify = NULL;


RTL_CRITICAL_SECTION    Logon32Lock;

#define LockLogon()     RtlEnterCriticalSection( &Logon32Lock )
#define UnlockLogon()   RtlLeaveCriticalSection( &Logon32Lock )


SID_IDENTIFIER_AUTHORITY L32SystemSidAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY L32LocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;



#define COMMON_CREATE_SUSPENDED 0x00000001  // Suspended, do not Resume()
#define COMMON_CREATE_PROCESSSD 0x00000002  // Whack the process SD
#define COMMON_CREATE_THREADSD  0x00000004  // Whack the thread SD


BOOL
WINAPI
LogonUserCommonA(
    LPSTR          lpszUsername,
    LPSTR          lpszDomain,
    LPSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    BOOL           fExVersion,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    );


BOOL
WINAPI
LogonUserCommonW(
    PWSTR          lpszUsername,
    PWSTR          lpszDomain,
    PWSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    BOOL           fExVersion,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    );


//+---------------------------------------------------------------------------
//
//  Function:   Logon32Initialize
//
//  Synopsis:   Initializes the critical section
//
//  Arguments:  [hMod]    --
//              [Reason]  --
//              [Context] --
//
//----------------------------------------------------------------------------
BOOL
Logon32Initialize(
    IN PVOID    hMod,
    IN ULONG    Reason,
    IN PCONTEXT Context)
{
    NTSTATUS    Status;

    if (Reason == DLL_PROCESS_ATTACH)
    {
        Status = RtlInitializeCriticalSection( &Logon32Lock );
        return( Status == STATUS_SUCCESS );
    }

    return( TRUE );
}


/***************************************************************************\
* FindLogonSid
*
* Finds logon sid for a new logon from the access token.
*
\***************************************************************************/
PSID
L32FindLogonSid(
    IN  HANDLE  hToken
    )
{
    PTOKEN_GROUPS   pGroups = NULL;
    DWORD           cbGroups;
    BYTE            FastBuffer[ 512 ];
    PTOKEN_GROUPS   pSlowBuffer = NULL;
    UINT            i;
    PSID            Sid = NULL;


    pGroups = (PTOKEN_GROUPS)FastBuffer;
    cbGroups = sizeof(FastBuffer);

    if(!GetTokenInformation(
                hToken,
                TokenGroups,
                pGroups,
                cbGroups,
                &cbGroups
                ))
    {
        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
            return NULL;
        }

        pSlowBuffer = (PTOKEN_GROUPS)LocalAlloc(LMEM_FIXED, cbGroups);

        if( pSlowBuffer == NULL ) {
            return NULL;
        }

        pGroups = pSlowBuffer;


        if(!GetTokenInformation(
                    hToken,
                    TokenGroups,
                    pGroups,
                    cbGroups,
                    &cbGroups
                    )) {
            goto Cleanup;
        }
    }


    //
    // Get the logon Sid by looping through the Sids in the token
    //

    for(i = 0 ; i < pGroups->GroupCount ; i++) {
        if(pGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID) {
            DWORD dwSidLength;

            //
            // insure we are dealing with a valid Sid
            //

            if(!IsValidSid(pGroups->Groups[i].Sid)) {
                goto Cleanup;
            }

            //
            // get required allocation size to copy the Sid
            //

            dwSidLength = GetLengthSid(pGroups->Groups[i].Sid);

            Sid = (PSID)LocalAlloc( LMEM_FIXED, dwSidLength );
            if( Sid == NULL ) {
                goto Cleanup;
            }

            CopySid(dwSidLength, Sid, pGroups->Groups[i].Sid);

            break;
        }
    }

Cleanup:

    if( pSlowBuffer )
    {
        LocalFree( pSlowBuffer );
    }

    return Sid;
}


/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    TRUE if successful, FALSE if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.
        RichardW    10-Jan-95   Liberated from sockets and stuck in base

********************************************************************/
BOOL
L32GetDefaultDomainName(
    PUNICODE_STRING     pDomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    DWORD                       err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;
    PUNICODE_STRING             pDomain;

    if (Logon32DomainName[0] != L'\0')
    {
        RtlInitUnicodeString(pDomainName, Logon32DomainName);
        return(TRUE);
    }
    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        BaseSetLastNTError(NtStatus);
        return(FALSE);
    }

    //
    //  Query the domain information from the policy object.
    //
    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *) &DomainInfo );

    if (!NT_SUCCESS(NtStatus))
    {
        BaseSetLastNTError(NtStatus);
        LsaClose(LsaPolicyHandle);
        return(FALSE);
    }


    (void) LsaClose(LsaPolicyHandle);

    //
    // Copy the domain name into our cache, and
    //

    CopyMemory( Logon32DomainName,
                DomainInfo->DomainName.Buffer,
                DomainInfo->DomainName.Length );

    //
    // Null terminate it appropriately
    //

    Logon32DomainName[DomainInfo->DomainName.Length / sizeof(WCHAR)] = L'\0';

    //
    // Clean up
    //
    LsaFreeMemory( (PVOID)DomainInfo );

    //
    // And init the string
    //
    RtlInitUnicodeString(pDomainName, Logon32DomainName);

    return TRUE;

}   // GetDefaultDomainName

//+---------------------------------------------------------------------------
//
//  Function:   L32pInitLsa
//
//  Synopsis:   Initialize connection with LSA
//
//  Arguments:  (none)
//
//  History:    4-21-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32pInitLsa(void)
{
    STRING  PackageName;

    ULONG MsvHandle;
    ULONG NegoHandle;

    NTSTATUS Status;

    //
    // Hookup to the LSA and locate our authentication package.
    //

    Status = LsaConnectUntrusted(
                 &Logon32LsaHandle
                 );

    if (!NT_SUCCESS(Status)) {
        Logon32LsaHandle = NULL;
        goto Cleanup;
    }


    //
    // Connect with the MSV1_0 authentication package
    //
    RtlInitString(&PackageName, "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
    Status = LsaLookupAuthenticationPackage (
                Logon32LsaHandle,
                &PackageName,
                &MsvHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Connect with the Negotiate authentication package
    //
    RtlInitString(&PackageName, NEGOSSP_NAME_A);
    Status = LsaLookupAuthenticationPackage (
                Logon32LsaHandle,
                &PackageName,
                &NegoHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Wait until successful to update the 2 globals.
    //

    Logon32NegoHandle = NegoHandle;
    Logon32MsvHandle = MsvHandle;

Cleanup:


    if( !NT_SUCCESS(Status) ) {

        if( Logon32LsaHandle ) {
            (VOID) LsaDeregisterLogonProcess( Logon32LsaHandle );
            Logon32LsaHandle = NULL;
        }

        BaseSetLastNTError( Status );
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   L32pNotifyMpr
//
//  Synopsis:   Loads the MPR DLL and notifies the network providers (like
//              csnw) so they know about this logon session and the credentials
//
//  Arguments:  [NewLogon] -- New logon information
//              [LogonId]  -- Logon ID
//
//  History:    4-24-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32pNotifyMpr(
    PMSV1_0_INTERACTIVE_LOGON   NewLogon,
    PLUID                       LogonId
    )
{
    MSV1_0_INTERACTIVE_LOGON    OldLogon;
    LPWSTR                      LogonScripts;
    DWORD                       status;
    LUID                        LocalServiceLuid   = LOCALSERVICE_LUID;
    LUID                        NetworkServiceLuid = NETWORKSERVICE_LUID;

    if (RtlEqualLuid(LogonId, &LocalServiceLuid)
         ||
        RtlEqualLuid(LogonId, &NetworkServiceLuid))
    {
        //
        // Don't notify providers for LocalService/NetworkService logons
        //

        return( TRUE );
    }

    if ( Logon32MprHandle == NULL )
    {
        LockLogon();

        if ( Logon32MprHandle == NULL)
        {
            Logon32MprHandle =  LoadLibrary("mpr.dll");
            if (Logon32MprHandle != NULL) {

                Logon32LogonNotify = (LOGONNOTIFYFN) GetProcAddress(
                                        Logon32MprHandle,
                                        "WNetLogonNotify");

            }
        }

        UnlockLogon();
    }

    if ( Logon32LogonNotify != NULL )
    {


        CopyMemory(&OldLogon, NewLogon, sizeof(OldLogon));

        status = Logon32LogonNotify(
                        L"Windows NT Network Provider",
                        LogonId,
                        L"MSV1_0:Interactive",
                        (LPVOID)NewLogon,
                        L"MSV1_0:Interactive",
                        (LPVOID)&OldLogon,
                        L"SvcCtl",          // StationName
                        NULL,               // StationHandle
                        &LogonScripts);     // LogonScripts

        if (status == NO_ERROR) {
            if (LogonScripts != NULL ) {
                (void) LocalFree(LogonScripts);
            }
        }

        return( TRUE );
    }

    return( FALSE );
}


//+---------------------------------------------------------------------------
//
//  Function:   L32pLogonUser
//
//  Synopsis:   Wraps up the call to LsaLogonUser
//
//  Arguments:  [LsaHandle]             --
//              [AuthenticationPackage] --
//              [LogonType]             --
//              [UserName]              --
//              [Domain]                --
//              [Password]              --
//              [LogonId]               --
//              [LogonToken]            --
//              [Quotas]                --
//              [pProfileBuffer]        --
//              [pProfileBufferLength]  --
//              [pSubStatus]            --
//
//  History:    4-24-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
L32pLogonUser(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN PUNICODE_STRING Password,
    OUT PLUID LogonId,
    OUT PHANDLE LogonToken,
    OUT PQUOTA_LIMITS Quotas,
    OUT PVOID *pProfileBuffer,
    OUT PULONG pProfileBufferLength,
    OUT PNTSTATUS pSubStatus
    )
{
    NTSTATUS Status;
    STRING OriginName;
    TOKEN_SOURCE SourceContext;
    PMSV1_0_INTERACTIVE_LOGON MsvAuthInfo;
    PMSV1_0_LM20_LOGON MsvNetAuthInfo;
    PVOID AuthInfoBuf;
    ULONG AuthInfoSize;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD ComputerNameLength;

    //
    // Initialize source context structure
    //

    strncpy(SourceContext.SourceName, "Advapi  ", sizeof(SourceContext.SourceName)); // LATER from res file

    Status = NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Set logon origin
    //

    RtlInitString(&OriginName, "LogonUser API");

    //
    // For network logons, do the magic.
    //

    if ( ( LogonType == Network ) )
    {
        ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;

        if (!GetComputerNameW( ComputerName, &ComputerNameLength ) )
        {
            return(STATUS_INVALID_PARAMETER);
        }

        AuthInfoSize = sizeof( MSV1_0_LM20_LOGON ) +
                         UserName->Length +
                         Domain->Length +
                         sizeof(WCHAR) * (ComputerNameLength + 1) +
                         Password->Length;

        MsvNetAuthInfo = AuthInfoBuf = RtlAllocateHeap( RtlProcessHeap(),
                                                        HEAP_ZERO_MEMORY,
                                                        AuthInfoSize );

        if ( !MsvNetAuthInfo )
        {
            return( STATUS_NO_MEMORY );
        }

        //
        // Start packing in the string
        //

        MsvNetAuthInfo->MessageType = MsV1_0NetworkLogon;

        //
        // Copy the user name into the authentication buffer
        //

        MsvNetAuthInfo->UserName.Length =
                    UserName->Length;
        MsvNetAuthInfo->UserName.MaximumLength =
                    MsvNetAuthInfo->UserName.Length;

        MsvNetAuthInfo->UserName.Buffer = (PWSTR)(MsvNetAuthInfo+1);
        RtlCopyMemory(
            MsvNetAuthInfo->UserName.Buffer,
            UserName->Buffer,
            UserName->Length
            );


        //
        // Copy the domain name into the authentication buffer
        //

        MsvNetAuthInfo->LogonDomainName.Length = Domain->Length;
        MsvNetAuthInfo->LogonDomainName.MaximumLength = Domain->Length ;

        MsvNetAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                     ((PBYTE)(MsvNetAuthInfo->UserName.Buffer) +
                                     MsvNetAuthInfo->UserName.MaximumLength);

        RtlCopyMemory(
            MsvNetAuthInfo->LogonDomainName.Buffer,
            Domain->Buffer,
            Domain->Length);

        //
        // Copy the workstation name into the buffer
        //

        MsvNetAuthInfo->Workstation.Length = (USHORT)
                            (sizeof(WCHAR) * ComputerNameLength);

        MsvNetAuthInfo->Workstation.MaximumLength =
                            MsvNetAuthInfo->Workstation.Length + sizeof(WCHAR);

        MsvNetAuthInfo->Workstation.Buffer = (PWSTR)
                            ((PBYTE) (MsvNetAuthInfo->LogonDomainName.Buffer) +
                            MsvNetAuthInfo->LogonDomainName.MaximumLength );

        wcscpy( MsvNetAuthInfo->Workstation.Buffer, ComputerName );

        //
        // Set up space for Password (Unicode)
        //

        MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer = (PUCHAR)
                    ((PBYTE) (MsvNetAuthInfo->Workstation.Buffer) +
                    MsvNetAuthInfo->Workstation.MaximumLength );

        MsvNetAuthInfo->CaseSensitiveChallengeResponse.Length =
        MsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength =
                            Password->Length;

        RtlCopyMemory(
            MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer,
            Password->Buffer,
            Password->Length);

        //
        // Zero out the ascii password
        //
        RtlZeroMemory( &MsvNetAuthInfo->CaseInsensitiveChallengeResponse,
            sizeof(MsvNetAuthInfo->CaseInsensitiveChallengeResponse));

        //
        // to be consistent with Negotiate/Kerberos for _WINNT50 cases,
        // allow machine accounts to be logged on.
        //

        MsvNetAuthInfo->ParameterControl =  MSV1_0_CLEARTEXT_PASSWORD_ALLOWED |
                                            MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT |
                                            MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT;

    }
    else
    {
        //
        // Build logon structure for non-network logons - service,
        // batch, interactive, unlock, new credentials, networkcleartext
        //

        AuthInfoSize = sizeof(MSV1_0_INTERACTIVE_LOGON) +
                        UserName->Length +
                        Domain->Length +
                        Password->Length;

        MsvAuthInfo = AuthInfoBuf = RtlAllocateHeap(RtlProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    AuthInfoSize);

        if (MsvAuthInfo == NULL) {
            return(STATUS_NO_MEMORY);
        }

        //
        // This authentication buffer will be used for a logon attempt
        //

        MsvAuthInfo->MessageType = MsV1_0InteractiveLogon;


        //
        // Copy the user name into the authentication buffer
        //

        MsvAuthInfo->UserName.Length = UserName->Length;
        MsvAuthInfo->UserName.MaximumLength =
                    MsvAuthInfo->UserName.Length;

        MsvAuthInfo->UserName.Buffer = (PWSTR)(MsvAuthInfo+1);
        RtlCopyMemory(
            MsvAuthInfo->UserName.Buffer,
            UserName->Buffer,
            UserName->Length
            );


        //
        // Copy the domain name into the authentication buffer
        //

        MsvAuthInfo->LogonDomainName.Length = Domain->Length;
        MsvAuthInfo->LogonDomainName.MaximumLength =
                     MsvAuthInfo->LogonDomainName.Length;

        MsvAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                     ((PBYTE)(MsvAuthInfo->UserName.Buffer) +
                                     MsvAuthInfo->UserName.MaximumLength);

        RtlCopyMemory(
            MsvAuthInfo->LogonDomainName.Buffer,
            Domain->Buffer,
            Domain->Length
            );

        //
        // Copy the password into the authentication buffer
        // Hide it once we have copied it.  Use the same seed value
        // that we used for the original password in pGlobals.
        //


        MsvAuthInfo->Password.Length = Password->Length;
        MsvAuthInfo->Password.MaximumLength =
                     MsvAuthInfo->Password.Length;

        MsvAuthInfo->Password.Buffer = (PWSTR)
                                     ((PBYTE)(MsvAuthInfo->LogonDomainName.Buffer) +
                                     MsvAuthInfo->LogonDomainName.MaximumLength);

        RtlCopyMemory(
            MsvAuthInfo->Password.Buffer,
            Password->Buffer,
            Password->Length
            );

    }

    //
    // Now try to log this sucker on
    //

    Status = LsaLogonUser (
                LsaHandle,
                &OriginName,
                LogonType,
                AuthenticationPackage,
                AuthInfoBuf,
                AuthInfoSize,
                NULL,
                &SourceContext,
                pProfileBuffer,
                pProfileBufferLength,
                LogonId,
                LogonToken,
                Quotas,
                pSubStatus
                );

    //
    // Notify all the network providers, if this is a NON network logon
    //

    if ( NT_SUCCESS( Status ) &&
         (LogonType != Network) )
    {
        L32pNotifyMpr(AuthInfoBuf, LogonId);
    }

    //
    // Discard authentication buffer
    //

    RtlFreeHeap(RtlProcessHeap(), 0, AuthInfoBuf);

    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserCommonA
//
//  Synopsis:   ANSI wrapper for LogonUserCommonW.  See description below
//
//  Arguments:  [lpszUsername]     --
//              [lpszDomain]       --
//              [lpszPassword]     --
//              [dwLogonType]      --
//              [dwLogonProvider]  --
//              [fExVersion]       --
//              [phToken]          --
//              [ppLogonSid]       --
//              [ppProfileBuffer]  --
//              [pdwProfileLength] --
//              [pQuotaLimits]     --
//
//  History:    2-15-2000   JSchwart   Created from RichardW's LogonUserA
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserCommonA(
    LPSTR          lpszUsername,
    LPSTR          lpszDomain,
    LPSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    BOOL           fExVersion,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    )
{
    UNICODE_STRING Username;
    UNICODE_STRING Domain;
    UNICODE_STRING Password;
    ANSI_STRING Temp ;
    NTSTATUS Status;
    BOOL    bRet;


    Username.Buffer = NULL;
    Domain.Buffer = NULL;
    Password.Buffer = NULL;

    RtlInitAnsiString( &Temp, lpszUsername );
    Status = RtlAnsiStringToUnicodeString( &Username, &Temp, TRUE );
    if (!NT_SUCCESS( Status ) )
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    RtlInitAnsiString( &Temp, lpszDomain );
    Status = RtlAnsiStringToUnicodeString(&Domain, &Temp, TRUE );
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    RtlInitAnsiString( &Temp, lpszPassword );
    Status = RtlAnsiStringToUnicodeString( &Password, &Temp, TRUE );
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    bRet = LogonUserCommonW( Username.Buffer,
                             Domain.Buffer,
                             Password.Buffer,
                             dwLogonType,
                             dwLogonProvider,
                             fExVersion,
                             phToken,
                             ppLogonSid,
                             ppProfileBuffer,
                             pdwProfileLength,
                             pQuotaLimits );

Cleanup:

    if (Username.Buffer)
    {
        RtlFreeUnicodeString(&Username);
    }

    if (Domain.Buffer)
    {
        RtlFreeUnicodeString(&Domain);
    }

    if (Password.Buffer)
    {
        RtlZeroMemory(Password.Buffer, Password.Length);
        RtlFreeUnicodeString(&Password);
    }

    return(bRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserA
//
//  Synopsis:   ANSI wrapper for LogonUserW.  See description below
//
//  Arguments:  [lpszUsername]    --
//              [lpszDomain]      --
//              [lpszPassword]    --
//              [dwLogonType]     --
//              [dwLogonProvider] --
//              [phToken]         --
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserA(
    LPSTR       lpszUsername,
    LPSTR       lpszDomain,
    LPSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    )
{
    return LogonUserCommonA(lpszUsername,
                            lpszDomain,
                            lpszPassword,
                            dwLogonType,
                            dwLogonProvider,
                            FALSE,            // LogonUserA
                            phToken,
                            NULL,             // ppLogonSid
                            NULL,             // ppProfileBuffer
                            NULL,             // pdwProfileLength
                            NULL);            // pQuotaLimits
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserExA
//
//  Synopsis:   ANSI wrapper for LogonUserExW.  See description below
//
//  Arguments:  [lpszUsername]     --
//              [lpszDomain]       --
//              [lpszPassword]     --
//              [dwLogonType]      --
//              [dwLogonProvider]  --
//              [phToken]          --
//              [ppLogonSid]       --
//              [ppProfileBuffer]  --
//              [pdwProfileLength] --
//              [pQuotaLimits]     --
//
//  History:    2-15-2000   JSchwart   Created from RichardW's LogonUserW
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserExA(
    LPSTR          lpszUsername,
    LPSTR          lpszDomain,
    LPSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    )
{
    return LogonUserCommonA(lpszUsername,
                            lpszDomain,
                            lpszPassword,
                            dwLogonType,
                            dwLogonProvider,
                            TRUE,             // LogonUserExA
                            phToken,
                            ppLogonSid,
                            ppProfileBuffer,
                            pdwProfileLength,
                            pQuotaLimits);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserCommonW
//
//  Synopsis:   Common code for LogonUserW and LogonUserExW.  Logs a user on
//              via plaintext password, username and domain name via the LSA.
//
//  Arguments:  [lpszUsername]     -- User name
//              [lpszDomain]       -- Domain name
//              [lpszPassword]     -- Password
//              [dwLogonType]      -- Logon type
//              [dwLogonProvider]  -- Provider
//              [fExVersion]       -- LogonUserExW or LogonUserW
//              [phToken]          -- Returned handle to primary token
//              [ppLogonSid]       -- Returned logon sid
//              [ppProfileBuffer]  -- Returned user profile buffer
//              [pdwProfileLength] -- Returned profile length
//
//  History:    2-15-2000   JSchwart   Created from RichardW's LogonUserW
//
//  Notes:      Requires SeTcbPrivilege, and will enable it if not already
//              present.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserCommonW(
    PWSTR          lpszUsername,
    PWSTR          lpszDomain,
    PWSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    BOOL           fExVersion,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    )
{
    NTSTATUS    Status;
    ULONG       PackageId;
    UNICODE_STRING  Username;
    UNICODE_STRING  Domain;
    UNICODE_STRING  Password;
    HANDLE      hTempToken;
    HANDLE    * phTempToken;
    LUID        LogonId;
    PVOID       Profile;
    ULONG       ProfileLength;
    NTSTATUS    SubStatus = STATUS_SUCCESS;
    SECURITY_LOGON_TYPE LogonType;


    //
    // Validate the provider
    //
    if (dwLogonProvider == LOGON32_PROVIDER_DEFAULT)
    {
        dwLogonProvider = LOGON32_PROVIDER_WINNT50;

        //
        // if domain was not supplied, and username is not a UPN, use
        // _WINNT40 to be compatible.
        //

        if((lpszUsername != NULL) &&
           (lpszDomain == NULL || lpszDomain[ 0 ] == L'\0'))
        {
            if( wcschr( lpszUsername, '@' ) == NULL )
            {
                dwLogonProvider = LOGON32_PROVIDER_WINNT40;
            }
        }
    }

    if (dwLogonProvider > LOGON32_PROVIDER_WINNT50)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (dwLogonType)
    {
        case LOGON32_LOGON_INTERACTIVE:
            LogonType = Interactive;
            break;

        case LOGON32_LOGON_BATCH:
            LogonType = Batch;
            break;

        case LOGON32_LOGON_SERVICE:
            LogonType = Service;
            break;

        case LOGON32_LOGON_NETWORK:
            LogonType = Network;
            break;

        case LOGON32_LOGON_UNLOCK:
            LogonType = Unlock ;
            break;

        case LOGON32_LOGON_NETWORK_CLEARTEXT:
            LogonType = NetworkCleartext ;
            break;

        case LOGON32_LOGON_NEW_CREDENTIALS:
            LogonType = NewCredentials;
            break;

        default:
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return(FALSE);
            break;
    }

    //
    // If the MSV handle is -1, grab the lock, and try again:
    //

    if (Logon32MsvHandle == 0xFFFFFFFF || Logon32NegoHandle == 0xFFFFFFFF)
    {
        LockLogon();

        //
        // If the MSV handle is still -1, init our connection to lsa.  We
        // have the lock, so no other threads can't be trying this right now.
        //
        if (Logon32MsvHandle == 0xFFFFFFFF || Logon32NegoHandle == 0xFFFFFFFF)
        {
            if (!L32pInitLsa())
            {
                UnlockLogon();

                return( FALSE );
            }
        }

        UnlockLogon();
    }

    //
    // Validate the parameters.  NULL or empty domain or NULL or empty
    // user name is invalid.
    //

    RtlInitUnicodeString(&Username, lpszUsername);
    if (Username.Length == 0)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Initialize/check parameters based on which API we're servicing.
    //
    if (!fExVersion)
    {
        //
        // LogonUserW -- phToken is required.  Initialize the token handle,
        // if the pointer is invalid, then catch the exception now.
        //

        *phToken    = NULL;
        phTempToken = phToken;
    }
    else
    {
        //
        // LogonUserExW -- phToken, ppLogonSid, ppProfileBuffer, and
        // pdwProfileLength are optional.  Initialize as appropriate.
        //

        if (ARGUMENT_PRESENT(phToken))
        {
            *phToken    = NULL;
            phTempToken = phToken;
        }
        else
        {
            //
            // Dummy token handle to use in the LsaLogonUser call
            //
            phTempToken = &hTempToken;
        }

        if (ARGUMENT_PRESENT(ppLogonSid))
        {
            *ppLogonSid = NULL;
        }

        if (!!ppProfileBuffer ^ !!pdwProfileLength)
        {
            //
            // Can't have one without the other...
            //
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return(FALSE);
        }

        if (ARGUMENT_PRESENT(ppProfileBuffer))
        {
            *ppProfileBuffer  = NULL;
            *pdwProfileLength = 0;
        }

        if (ARGUMENT_PRESENT(pQuotaLimits))
        {
            RtlZeroMemory(pQuotaLimits, sizeof(QUOTA_LIMITS));
        }
    }

    //
    // Parse that domain.  Note, if the special token . is passed in for
    // domain, we will use the right value from the LSA, meaning AccountDomain.
    // If the domain is null, the lsa will talk to the local domain, the
    // primary domain, and then on from there...
    //
    if (lpszDomain && *lpszDomain)
    {
        if ((lpszDomain[0] == L'.') &&
            (lpszDomain[1] == L'\0') )
        {
            if (!L32GetDefaultDomainName(&Domain))
            {
                return(FALSE);
            }
        }
        else
        {
            RtlInitUnicodeString(&Domain, lpszDomain);
        }
    }
    else
    {
        RtlInitUnicodeString(&Domain, lpszDomain);
    }

    //
    // Finally, init the password
    //
    RtlInitUnicodeString(&Password, lpszPassword);



    //
    // Attempt the logon
    //

    Status = L32pLogonUser(
                    Logon32LsaHandle,
                    (dwLogonProvider == LOGON32_PROVIDER_WINNT50) ?
                        Logon32NegoHandle : Logon32MsvHandle,
                    LogonType,
                    &Username,
                    &Domain,
                    &Password,
                    &LogonId,
                    phTempToken,
                    pQuotaLimits ? pQuotaLimits : &Logon32QuotaLimits,
                    &Profile,
                    &ProfileLength,
                    &SubStatus);

    //
    // Set output parameters based on which API we're servicing
    //


    // TODO: review cleanup code if something fails mid-stream.
    //

    if (!fExVersion)
    {

        if (!NT_SUCCESS(Status))
        {
            if (Status == STATUS_ACCOUNT_RESTRICTION)
            {
                BaseSetLastNTError(SubStatus);
            }
            else
            {
                BaseSetLastNTError(Status);
            }

            return(FALSE);
        }

        if (Profile != NULL)
        {
            LsaFreeReturnBuffer(Profile);
        }
    }
    else
    {
        //
        // We may need the allocated buffers if all went well, so
        // check the return status first.
        //

        if (!NT_SUCCESS(Status))
        {

            if (Status == STATUS_ACCOUNT_RESTRICTION)
            {
                BaseSetLastNTError(SubStatus);
            }
            else
            {
                BaseSetLastNTError(Status);
            }

            return(FALSE);
        }

        //
        // The logon succeeded -- fill in the requested output parameters.
        //

        if (ARGUMENT_PRESENT(ppProfileBuffer))
        {
            if (Profile != NULL)
            {
                ASSERT(ProfileLength != 0);

                *ppProfileBuffer = Profile;
                *pdwProfileLength = ProfileLength;
            }
        }
        else
        {
            if (Profile != NULL)
            {
                LsaFreeReturnBuffer(Profile);
            }
        }

        if (ARGUMENT_PRESENT(ppLogonSid))
        {
            *ppLogonSid = L32FindLogonSid( *phTempToken );
        }

        if (!ARGUMENT_PRESENT(phToken))
        {
            //
            // Close the dummy token handle
            //
            CloseHandle(*phTempToken);
        }
    }

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserW
//
//  Synopsis:   Logs a user on via plaintext password, username and domain
//              name via the LSA.
//
//  Arguments:  [lpszUsername]    -- User name
//              [lpszDomain]      -- Domain name
//              [lpszPassword]    -- Password
//              [dwLogonType]     -- Logon type
//              [dwLogonProvider] -- Provider
//              [phToken]         -- Returned handle to primary token
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:      Requires SeTcbPrivilege, and will enable it if not already
//              present.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserW(
    PWSTR       lpszUsername,
    PWSTR       lpszDomain,
    PWSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    )
{
    return LogonUserCommonW(lpszUsername,
                            lpszDomain,
                            lpszPassword,
                            dwLogonType,
                            dwLogonProvider,
                            FALSE,            // LogonUserW
                            phToken,
                            NULL,             // ppLogonSid
                            NULL,             // ppProfileBuffer
                            NULL,             // pdwProfileLength
                            NULL);            // pQuotaLimits
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserExW
//
//  Synopsis:   Logs a user on via plaintext password, username and domain
//              name via the LSA.
//
//  Arguments:  [lpszUsername]     -- User name
//              [lpszDomain]       -- Domain name
//              [lpszPassword]     -- Password
//              [dwLogonType]      -- Logon type
//              [dwLogonProvider]  -- Provider
//              [phToken]          -- Returned handle to primary token
//              [ppLogonSid]       -- Returned logon sid
//              [ppProfileBuffer]  -- Returned user profile buffer
//              [pdwProfileLength] -- Returned profile length
//              [pQuotaLimits]     -- Returned quota limits
//
//  History:    2-15-2000   JSchwart   Created from RichardW's LogonUserW
//
//  Notes:      Requires SeTcbPrivilege, and will enable it if not already
//              present.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
LogonUserExW(
    PWSTR          lpszUsername,
    PWSTR          lpszDomain,
    PWSTR          lpszPassword,
    DWORD          dwLogonType,
    DWORD          dwLogonProvider,
    HANDLE *       phToken,
    PSID   *       ppLogonSid,
    PVOID  *       ppProfileBuffer,
    DWORD  *       pdwProfileLength,
    PQUOTA_LIMITS  pQuotaLimits
    )
{
    return LogonUserCommonW(lpszUsername,
                            lpszDomain,
                            lpszPassword,
                            dwLogonType,
                            dwLogonProvider,
                            TRUE,             // LogonUserExW
                            phToken,
                            ppLogonSid,
                            ppProfileBuffer,
                            pdwProfileLength,
                            pQuotaLimits);
}


//+---------------------------------------------------------------------------
//
//  Function:   ImpersonateLoggedOnUser
//
//  Synopsis:   Duplicates the token passed in if it is primary, and assigns
//              it to the thread that called.
//
//  Arguments:  [hToken] --
//
//  History:    1-10-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
ImpersonateLoggedOnUser(
    HANDLE  hToken
    )
{
    TOKEN_TYPE                  Type;
    ULONG                       cbType;
    HANDLE                      hImpToken;
    NTSTATUS                    Status;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    BOOL                        fCloseImp;

    Status = NtQueryInformationToken(
                hToken,
                TokenType,
                &Type,
                sizeof(TOKEN_TYPE),
                &cbType);

    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    if (Type == TokenPrimary)
    {
        InitializeObjectAttributes(
                            &ObjectAttributes,
                            NULL,
                            0L,
                            NULL,
                            NULL);

        SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


        Status = NtDuplicateToken( hToken,
                                   TOKEN_IMPERSONATE | TOKEN_QUERY,
                                   &ObjectAttributes,
                                   FALSE,
                                   TokenImpersonation,
                                   &hImpToken
                                 );

        if (!NT_SUCCESS(Status))
        {
            BaseSetLastNTError(Status);
            return(FALSE);
        }

        fCloseImp = TRUE;

    }

    else

    {
        hImpToken = hToken;
        fCloseImp = FALSE;
    }

    Status = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &hImpToken,
                sizeof(hImpToken)
                );

    if (fCloseImp)
    {
        (void) NtClose(hImpToken);
    }

    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    return(TRUE);

}




//+---------------------------------------------------------------------------
//
//  Function:   L32SetProcessToken
//
//  Synopsis:   Sets the primary token for the new process.
//
//  Arguments:  [psd]      --
//              [hProcess] --
//              [hThread]  --
//              [hToken]   --
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32SetProcessToken(
    PSECURITY_DESCRIPTOR    psd,
    HANDLE                  hProcess,
    HANDLE                  hThread,
    HANDLE                  hToken,
    BOOL                    AlreadyImpersonating
    )
{
    NTSTATUS Status, AdjustStatus;
    PROCESS_ACCESS_TOKEN PrimaryTokenInfo;
    HANDLE TokenToAssign;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN WasEnabled;
    HANDLE NullHandle;


    //
    // Check for a NULL token. (No need to do anything)
    // The process will run in the parent process's context and inherit
    // the default ACL from the parent process's token.
    //
    if (hToken == NULL)
    {
        return(TRUE);
    }


    //
    // A primary token can only be assigned to one process.
    // Duplicate the logon token so we can assign one to the new
    // process.
    //

    InitializeObjectAttributes(
                 &ObjectAttributes,
                 NULL,
                 0,
                 NULL,
                 psd
                 );

    Status = NtDuplicateToken(
                 hToken, // Duplicate this token
                 0,                 // Same desired access
                 &ObjectAttributes,
                 FALSE,             // EffectiveOnly
                 TokenPrimary,      // TokenType
                 &TokenToAssign     // Duplicate token handle stored here
                 );


    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // Set the process's primary token.  This is actually much more complex
    // to implement in a single API, but we'll live with it.  This MUST be
    // called when we are not impersonating!  The client generally does *not*
    // have the SeAssignPrimary privilege
    //


    //
    // Enable the required privilege
    //

    if ( !AlreadyImpersonating )
    {
        Status = RtlImpersonateSelf( SecurityImpersonation );
    }
    else
    {
        Status = STATUS_SUCCESS ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        //
        // We now allow restricted tokens to passed in, so we don't
        // fail if the privilege isn't held.  Let the kernel deal with
        // the possibilities.
        //

        Status = RtlAdjustPrivilege(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE, TRUE,
                                    TRUE, &WasEnabled);

        if ( !NT_SUCCESS( Status ) )
        {
            WasEnabled = TRUE ;     // Don't try to restore it.
        }

        PrimaryTokenInfo.Token  = TokenToAssign;
        PrimaryTokenInfo.Thread = hThread;

        Status = NtSetInformationProcess(
                    hProcess,
                    ProcessAccessToken,
                    (PVOID)&PrimaryTokenInfo,
                    (ULONG)sizeof(PROCESS_ACCESS_TOKEN)
                    );
        //
        // Restore the privilege to its previous state
        //

        if (!WasEnabled)
        {
            AdjustStatus = RtlAdjustPrivilege(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE,
                                          WasEnabled, TRUE, &WasEnabled);
            if (NT_SUCCESS(Status)) {
                Status = AdjustStatus;
            }
        }


        //
        // Revert back to process.
        //

        if ( !AlreadyImpersonating )
        {
            NullHandle = NULL;

            AdjustStatus = NtSetInformationThread(
                                NtCurrentThread(),
                                ThreadImpersonationToken,
                                (PVOID) &NullHandle,
                                sizeof( HANDLE ) );

            if ( NT_SUCCESS( Status ) )
            {
                Status = AdjustStatus;
            }
        }



    } else {

        NOTHING;
    }

    //
    // We're finished with the token handle
    //

    NtClose(TokenToAssign);


    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
    }

    return (NT_SUCCESS(Status));

}


//+---------------------------------------------------------------------------
//
//  Function:   L32SetProcessQuotas
//
//  Synopsis:   Updates the quotas for the process
//
//  Arguments:  [hProcess] --
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32SetProcessQuotas(
    HANDLE  hProcess,
    BOOL    AlreadyImpersonating )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS AdjustStatus = STATUS_SUCCESS;
    QUOTA_LIMITS RequestedLimits;
    BOOLEAN WasEnabled;
    HANDLE NullHandle;

    RequestedLimits = Logon32QuotaLimits;
    RequestedLimits.MinimumWorkingSetSize = 0;
    RequestedLimits.MaximumWorkingSetSize = 0;

    //
    // Set the process's quota.   This MUST be
    // called when we are not impersonating!  The client generally does *not*
    // have the SeIncreaseQuota privilege.
    //

    if ( !AlreadyImpersonating )
    {
        Status = RtlImpersonateSelf( SecurityImpersonation );
    }

    if ( NT_SUCCESS( Status ) )
    {

        if (RequestedLimits.PagedPoolLimit != 0) {

            Status = RtlAdjustPrivilege(SE_INCREASE_QUOTA_PRIVILEGE, TRUE,
                                        TRUE, &WasEnabled);

            if ( NT_SUCCESS( Status ) )
            {

                Status = NtSetInformationProcess(
                            hProcess,
                            ProcessQuotaLimits,
                            (PVOID)&RequestedLimits,
                            (ULONG)sizeof(QUOTA_LIMITS)
                            );

                if (!WasEnabled)
                {
                    AdjustStatus = RtlAdjustPrivilege(SE_INCREASE_QUOTA_PRIVILEGE,
                                                  WasEnabled, FALSE, &WasEnabled);
                    if (NT_SUCCESS(Status)) {
                        Status = AdjustStatus;
                    }
                }
            }

        }

        if ( !AlreadyImpersonating )
        {
            NullHandle = NULL;

            AdjustStatus = NtSetInformationThread(
                                NtCurrentThread(),
                                ThreadImpersonationToken,
                                (PVOID) &NullHandle,
                                sizeof( HANDLE ) );

            if ( NT_SUCCESS( Status ) )
            {
                Status = AdjustStatus;
            }
        }

    }

    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   L32CommonCreate
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [CreateFlags]     -- Flags (see top of file)
//              [hToken]          -- Primary token to use
//              [lpProcessInfo]   -- Process Info
//
//  History:    1-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32CommonCreate(
    DWORD   CreateFlags,
    HANDLE  hToken,
    LPPROCESS_INFORMATION   lpProcessInfo
    )
{
    PTOKEN_DEFAULT_DACL     pDefDacl;
    DWORD                   cDefDacl = 0;
    NTSTATUS                Status;
    PSECURITY_DESCRIPTOR    psd;
    unsigned char           buf[SECURITY_DESCRIPTOR_MIN_LENGTH];
    BOOL                    Success = TRUE;
    TOKEN_TYPE              Type;
    DWORD                   dummy;
    HANDLE                  hThreadToken;
    HANDLE                  hNull;
    BOOL                    UsingImpToken = FALSE ;

#ifdef ALLOW_IMPERSONATION_TOKENS
    HANDLE                  hTempToken;
#endif


    //
    // Determine type of token, since a non primary token will not work
    // on a process.  Now, we could duplicate it into a primary token,
    // and whack it into the process, but that leaves the process possibly
    // without credentials.
    //
    Status = NtQueryInformationToken(hToken, TokenType,
                                    (PUCHAR) &Type, sizeof(Type), &dummy);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        NtTerminateProcess(lpProcessInfo->hProcess, ERROR_ACCESS_DENIED);
        NtClose(lpProcessInfo->hProcess);
        NtClose(lpProcessInfo->hThread);
        RtlZeroMemory( lpProcessInfo, sizeof( PROCESS_INFORMATION ) );
        return(FALSE);
    }
    if (Type != TokenPrimary)
    {
#ifdef ALLOW_IMPERSONATION_TOKENS
        OBJECT_ATTRIBUTES   ObjectAttributes;

        InitializeObjectAttributes(
                            &ObjectAttributes,
                            NULL,
                            0L,
                            NULL,
                            NULL);

        SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


        Status = NtDuplicateToken( hToken,
                                   TOKEN_IMPERSONATE | TOKEN_QUERY,
                                   &ObjectAttributes,
                                   FALSE,
                                   TokenPrimary,
                                   &hTempToken
                                 );

        if (!NT_SUCCESS(Status))
        {
            BaseSetLastNTError(Status);
            NtTerminateProcess(lpProcessInfo->hProcess, ERROR_ACCESS_DENIED);
            NtClose(lpProcessInfo->hProcess);
            NtClose(lpProcessInfo->hThread);
            RtlZeroMemory( lpProcessInfo, sizeof( PROCESS_INFORMATION ) );
            return(FALSE);
        }

        hToken = hTempToken;

#else   // !ALLOW_IMPERSONATION_TOKENS

        BaseSetLastNTError(STATUS_BAD_TOKEN_TYPE);
        NtTerminateProcess(lpProcessInfo->hProcess, ERROR_ACCESS_DENIED);
        NtClose(lpProcessInfo->hProcess);
        NtClose(lpProcessInfo->hThread);
        RtlZeroMemory( lpProcessInfo, sizeof( PROCESS_INFORMATION ) );
        return(FALSE);

#endif

    }

#ifdef ALLOW_IMPERSONATION_TOKENS
    else
    {
        hTempToken = NULL;
    }
#endif

    //
    // Okay, get the default DACL from the token.  This DACL will be
    // applied to the process.  Note that the creator of this process may
    // not be able to open it again after the DACL is applied.  However,
    // since the caller already has a valid handle (in ProcessInfo), they
    // can keep doing things.
    //

    pDefDacl = NULL;
    Status = NtQueryInformationToken(hToken,
                                    TokenDefaultDacl,
                                    NULL, 0, &cDefDacl);

    if (NT_SUCCESS(Status) || (Status == STATUS_BUFFER_TOO_SMALL))
    {
        pDefDacl = RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, cDefDacl);
        if (pDefDacl)
        {
            Status = NtQueryInformationToken(   hToken,
                                                TokenDefaultDacl,
                                                pDefDacl, cDefDacl,
                                                &cDefDacl);

        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        if (pDefDacl)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, pDefDacl);
        }

        //
        // Our failure mantra:  Set the last error, kill the process (since it
        // is suspended, and hasn't actually started yet, we can do this safely)
        // close the handles, and return false.
        //
#ifdef ALLOW_IMPERSONATION_TOKENS
        if (hTempToken)
        {
            NtClose( hTempToken );
        }
#endif

        BaseSetLastNTError(Status);
        NtTerminateProcess(lpProcessInfo->hProcess, ERROR_ACCESS_DENIED);
        NtClose(lpProcessInfo->hProcess);
        NtClose(lpProcessInfo->hThread);
        RtlZeroMemory( lpProcessInfo, sizeof( PROCESS_INFORMATION ) );
        return(FALSE);
    }

    psd = (PSECURITY_DESCRIPTOR) buf;
    InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(psd, TRUE, pDefDacl->DefaultDacl, FALSE);

    if (CreateFlags & (COMMON_CREATE_PROCESSSD | COMMON_CREATE_THREADSD))
    {

        //
        // Now, based on what we're told:
        //

        if (CreateFlags & COMMON_CREATE_PROCESSSD)
        {
            Success = SetKernelObjectSecurity(  lpProcessInfo->hProcess,
                                                DACL_SECURITY_INFORMATION,
                                                psd);
        }

        //
        // Ah, WOW apps created through here don't have thread handles,
        // so check:
        //

        if ((Success) &&
            (CreateFlags & COMMON_CREATE_THREADSD))
        {
            if ( lpProcessInfo->hThread )
            {
                Success = SetKernelObjectSecurity(  lpProcessInfo->hThread,
                                                    DACL_SECURITY_INFORMATION,
                                                    psd);
            }
        }


    }
    else
    {
        Success = TRUE;
    }


    if (Success)
    {
        //
        // Unfortunately, this is usually called when we are impersonating,
        // because one does not want to start a process for a user that he
        // does not actually have access to.  However, this user also does
        // not have (usually) AssignPrimary and IncreaseQuota privileges.
        // So, if we are impersonating, we open the thread token, then
        // stop impersonating, saving the token away to restore later.
        //

        Status = NtOpenThreadToken( NtCurrentThread(),
                                    TOKEN_IMPERSONATE,
                                    TRUE,
                                    &hThreadToken);

        if (NT_SUCCESS(Status))
        {
            //
            // Okay, stop impersonating:
            //

            hNull = NULL;

            Status = NtSetInformationThread(
                            NtCurrentThread(),
                            ThreadImpersonationToken,
                            (PVOID) &hNull,
                            sizeof(hNull)
                            );


        }
        else
        {
            hThreadToken = NULL;
        }

        //
        // Okay, we've set the process security descriptor.  Now, set the
        // process primary token to the right thing
        //

        Success = L32SetProcessToken(   psd,
                                        lpProcessInfo->hProcess,
                                        lpProcessInfo->hThread,
                                        hToken,
                                        FALSE );

        if ( !Success && hThreadToken )
        {
            Status = NtSetInformationThread(
                            NtCurrentThread(),
                            ThreadImpersonationToken,
                            (PVOID) &hThreadToken,
                            sizeof(hThreadToken)
                            );

            UsingImpToken = TRUE ;

            Success = L32SetProcessToken(
                                psd,
                                lpProcessInfo->hProcess,
                                lpProcessInfo->hThread,
                                hToken,
                                TRUE );
        }

        if ( Success )
        {
#ifdef ALLOW_IMPERSONATION_TOKENS
            if (hTempToken)
            {
                NtClose(hTempToken);
            }
#endif
            //
            // That worked.  Now adjust the quota to be something reasonable
            //

            Success = L32SetProcessQuotas(
                            lpProcessInfo->hProcess,
                            UsingImpToken );

            if ( (!Success) &&
                 (hThreadToken != NULL) &&
                 (UsingImpToken == FALSE ) )
            {
                Status = NtSetInformationThread(
                                NtCurrentThread(),
                                ThreadImpersonationToken,
                                (PVOID) &hThreadToken,
                                sizeof(hThreadToken)
                                );

                UsingImpToken = TRUE ;

                Success = L32SetProcessQuotas(
                            lpProcessInfo->hProcess,
                            TRUE );

            }
            if ( Success )
            {
                //
                // If we're not supposed to leave it suspended, resume the
                // thread and let it run...
                //
                if ((CreateFlags & COMMON_CREATE_SUSPENDED) == 0)
                {
                    ResumeThread(lpProcessInfo->hThread);
                }

                RtlFreeHeap(RtlProcessHeap(), 0, pDefDacl);

                if (hThreadToken)
                {
                    Status = NtSetInformationThread(
                                    NtCurrentThread(),
                                    ThreadImpersonationToken,
                                    (PVOID) &hThreadToken,
                                    sizeof(hThreadToken)
                                    );

                    NtClose(hThreadToken);
                }

                return(TRUE);
            }

        }

        //
        // If we were impersonating before, resume impersonating here
        //

        if (hThreadToken)
        {
            Status = NtSetInformationThread(
                            NtCurrentThread(),
                            ThreadImpersonationToken,
                            (PVOID) &hThreadToken,
                            sizeof(hThreadToken)
                            );

            //
            // Done with this now.
            //

            NtClose(hThreadToken);
        }


    }

    //
    // Failure mantra again...
    //
    if (pDefDacl)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pDefDacl);
    }

    NtTerminateProcess(lpProcessInfo->hProcess, ERROR_ACCESS_DENIED);
    NtClose(lpProcessInfo->hProcess);
    NtClose(lpProcessInfo->hThread);
    RtlZeroMemory( lpProcessInfo, sizeof( PROCESS_INFORMATION ) );
    return(FALSE);

}


//+---------------------------------------------------------------------------
//
//  Function:   SaferiReplaceProcessThreadTokens
//
//  Synopsis:
//      Provides a privately exported function to replace the access token
//      of a process and its primary thread of a new process before its
//      execution has begun.  The process is left in a suspended state
//      after the token modification has been performed.
//
//  Effects:
//
//  Arguments:  [NewTokenHandle]  -- Primary token to use
//              [ProcessHandle]   -- Process handle
//              [ThreadHandle]    -- Handle of process's primary Thread
//
//  History:    8-25-2000   JLawson   Created
//
//  Notes:
//      This is merely a wrapper function that calls L32CommonCreate.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
SaferiReplaceProcessThreadTokens(
        IN HANDLE       NewTokenHandle,
        IN HANDLE       ProcessHandle,
        IN HANDLE       ThreadHandle
        )
{
    PROCESS_INFORMATION TempProcessInfo;

    RtlZeroMemory( &TempProcessInfo, sizeof( PROCESS_INFORMATION ) );
    TempProcessInfo.hProcess = ProcessHandle;
    TempProcessInfo.hThread = ThreadHandle;
    return (L32CommonCreate(
            COMMON_CREATE_PROCESSSD | COMMON_CREATE_THREADSD |
                    COMMON_CREATE_SUSPENDED,
            NewTokenHandle,
            &TempProcessInfo));
}


//+---------------------------------------------------------------------------
//
//   MarshallString
//
//    Marshall in a UNICODE_NULL terminated WCHAR string
//
//  ENTRY:
//    pSource (input)
//      Pointer to source string
//
//    pBase (input)
//      Base buffer pointer for normalizing the string pointer
//
//    MaxSize (input)
//      Maximum buffer size available
//
//    ppPtr (input/output)
//      Pointer to the current context pointer in the marshall buffer.
//      This is updated as data is marshalled into the buffer
//
//    pCount (input/output)
//      Current count of data in the marshall buffer.
//      This is updated as data is marshalled into the buffer
//
//  EXIT:
//    NULL - Error
//    !=NULL "normalized" pointer to the string in reference to pBase
//
//+---------------------------------------------------------------------------
PWCHAR
MarshallString(
    PCWSTR pSource,
    PCHAR  pBase,
    ULONG  MaxSize,
    PCHAR  *ppPtr,
    PULONG pCount
    )
{
    ULONG Len;
    PCHAR ptr;

    Len = wcslen( pSource );
    Len++; // include the NULL;

    Len *= sizeof(WCHAR); // convert to bytes
    if( (*pCount + Len) > MaxSize ) {
        return( NULL );
    }

    RtlMoveMemory( *ppPtr, pSource, Len );

    //
    // the normalized ptr is the current count
    //
        // Sundown note: ptr is a zero-extension of *pCount.
    ptr = (PCHAR)ULongToPtr(*pCount);

    *ppPtr += Len;
    *pCount += Len;

    return((PWCHAR)ptr);
}

#if DBG

void DumpOutLastErrorString()
{
    LPVOID  lpMsgBuf;

    FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            GetLastError(),
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL
        );
        //
        // Process any inserts in lpMsgBuf.
        // ...
        // Display the string.
        //
        KdPrint(("%s\n", (LPCTSTR)lpMsgBuf ));

        //
        // Free the buffer.
        //
        LocalFree( lpMsgBuf );
}
#endif

#ifdef DBG
#define    DBG_DumpOutLastError    DumpOutLastErrorString();
#else
#define    DBG_DumpOutLastError
#endif


//+---------------------------------------------------------------------------
//
// This function was originally defined in  \nt\private\ole32\dcomss\olescm\execclt.cxx
//
// CreateRemoteSessionProcessW()
//
//  Create a process on the given Terminal Server Session. This is in UNICODE
//
// ENTRY:
//  SessionId (input)
//    SessionId of Session to create process on
//
//  Param1 (input/output)
//    Comments
//
// Comments
//  The security attribs are not used by the session, they are set to NULL
//  We may consider to extend this feature in the future, assuming there is a
//  need for it.
//
// EXIT:
//  STATUS_SUCCESS - no error
//+---------------------------------------------------------------------------
BOOL
CreateRemoteSessionProcessW(
    ULONG  SessionId,
    BOOL   System,
    HANDLE hToken,
    PCWSTR lpszImageName,
    PCWSTR lpszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,    // these are ignored on the session side, set to NULL
    PSECURITY_ATTRIBUTES psaThread,     // these are ignored on the session side, set to NULL
    BOOL   fInheritHandles,
    DWORD  fdwCreate,
    LPVOID lpvEnvionment,
    LPCWSTR lpszCurDir,
    LPSTARTUPINFOW pStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    )
{
    BOOL            Result = TRUE;
    HANDLE          hPipe = NULL;
    WCHAR           szPipeName[MAX_PATH];
    PCHAR           ptr;
    ULONG           Count, AmountWrote, AmountRead;
    DWORD           MyProcId;
    PEXECSRV_REQUEST pReq;
    EXECSRV_REPLY   Rep;
    CHAR            Buf[EXECSRV_BUFFER_SIZE];
    ULONG           MaxSize = EXECSRV_BUFFER_SIZE;
    DWORD           rc;
    LPVOID          lpMsgBuf;
    ULONG           envSize=0;  // size of the lpEnvironemt, if any
    PWCHAR           lpEnv;

#if DBG
    if( lpszImageName )
        KdPrint(("logon32.c: CreateRemoteSessionProcessW: lpszImageName %ws\n",lpszImageName));

    if( lpszCommandLine )
        KdPrint(("logon32.c: CreateRemoteSessionProcessW: lpszCommandLine %ws\n",lpszCommandLine));
#endif

    //
    // Winlogon handles all now. System flag tells it what to do
    //
    swprintf(szPipeName, EXECSRV_SYSTEM_PIPE_NAME, SessionId);


    while ( TRUE )
    {
        hPipe = CreateFileW(
                    szPipeName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,    // File share mode
                    NULL, // default security
                    OPEN_EXISTING,
                    0,    // Attrs and flags
                    NULL  // template file handle
                    );

        if( hPipe == INVALID_HANDLE_VALUE )
        {
            if (GetLastError() == ERROR_PIPE_BUSY)
            {
                if (!WaitNamedPipeW( szPipeName, 30000 ))
                { // 30 sec
                    KdPrint(("logon32.c: Waited too long for pipe name %ws\n", szPipeName));
                    return(FALSE);
                }
            }
            else
            {
                DBG_DumpOutLastError;
                KdPrint(("logon32.c: Could not create pipe name %ws\n", szPipeName));
                return(FALSE);
            }
        }
        else
        {
            break;
        }
    }


    //
    // Get the handle to the current process
    //
    MyProcId = GetCurrentProcessId();

    //
    // setup the marshalling
    //
    ptr = Buf;
    Count = 0;

    pReq = (PEXECSRV_REQUEST)ptr;
    ptr   += sizeof(EXECSRV_REQUEST);
    Count += sizeof(EXECSRV_REQUEST);

    //
    // set the basic parameters
    //
    pReq->System = System;
    pReq->hToken = hToken;
    pReq->RequestingProcessId = MyProcId;
    pReq->fInheritHandles = fInheritHandles;
    pReq->fdwCreate = fdwCreate;

    //
    // marshall the ImageName string
    //
    if( lpszImageName ) {
        pReq->lpszImageName = MarshallString( lpszImageName, Buf, MaxSize, &ptr, &Count );
        if (! pReq->lpszImageName)
        {
            Result = FALSE;
            goto Cleanup;
        }
    }
    else {
        pReq->lpszImageName = NULL;
    }

    //
    // marshall in the CommandLine string
    //
    if( lpszCommandLine ) {
        pReq->lpszCommandLine = MarshallString( lpszCommandLine, Buf, MaxSize, &ptr, &Count );
        if ( ! pReq->lpszCommandLine )
        {
            Result = FALSE;
            goto Cleanup;
        }
    }
    else {
        pReq->lpszCommandLine = NULL;
    }

    //
    // marshall in the CurDir string
    //
    if( lpszCurDir ) {
        pReq->lpszCurDir = MarshallString( lpszCurDir, Buf, MaxSize, &ptr, &Count );
        if ( ! pReq->lpszCurDir  )
        {
            Result = FALSE;
            goto Cleanup;
        }
    }
    else {
        pReq->lpszCurDir = NULL;
    }

    //
    // marshall in the StartupInfo structure
    //
    RtlMoveMemory( &pReq->StartInfo, pStartInfo, sizeof(STARTUPINFO) );

    //
    // Now marshall the strings in STARTUPINFO
    //
    if( pStartInfo->lpDesktop ) {
        pReq->StartInfo.lpDesktop = MarshallString( pStartInfo->lpDesktop, Buf, MaxSize, &ptr, &Count );
        if (! pReq->StartInfo.lpDesktop )
        {
            Result = FALSE;
            goto Cleanup;
        }
    }
    else {
        pReq->StartInfo.lpDesktop = NULL;
    }

    if( pStartInfo->lpTitle ) {
        pReq->StartInfo.lpTitle = MarshallString( pStartInfo->lpTitle, Buf, MaxSize, &ptr, &Count );
        if ( !pReq->StartInfo.lpTitle  )
        {
            Result = FALSE;
            goto Cleanup;
        }
    }
    else {
        pReq->StartInfo.lpTitle = NULL;
    }

    //
    // WARNING: This version does not pass the following:
    //
    //  Also saProcess and saThread are ignored right now and use
    //  the users default security on the remote WinStation
    //
    // Set things that are always NULL
    //
    pReq->StartInfo.lpReserved = NULL;  // always NULL


    if ( lpvEnvionment)
    {
        for ( lpEnv = (PWCHAR) lpvEnvionment;
            (*lpEnv ) && (envSize + Count < MaxSize ) ;  lpEnv++)
        {
            while( *lpEnv )
            {
                lpEnv++;
                envSize += 2;   // we are dealing with wide chars
                if ( envSize+Count >= MaxSize )
                {
                    // we have too many
                    // vars in the user's profile.
                    KdPrint(("\tEnv length too big = %d \n", envSize));
                    break;
                }
            }
            // this is the null which marked the end of the last env var.
            envSize +=2;

        }
        envSize += 2;    // this is the final NULL


        if ( Count + envSize < MaxSize )
        {
            RtlMoveMemory( (PCHAR)&Buf[Count] ,lpvEnvionment, envSize );
                        // SUNDOWN: Count is zero-extended and store in lpvEnvironment.
            //          This zero-extension is valid. The consuming code [see tsext\notify\execsrv.c]
            //          considers lpvEnvironment as an offset (<2GB).
            pReq->lpvEnvironment = (PCHAR)ULongToPtr(Count);
            ptr += envSize;         // for the next guy
            Count += envSize;       // the count used so far
        }
        else    // no room left to make a complete copy
        {
            pReq->lpvEnvironment = NULL;
        }

    }
    else
    {
        pReq->lpvEnvironment = NULL;
    }

    //
    // now fill in the total count
    //
    pReq->Size = Count;

#if DBG
    KdPrint(("pReq->Size = %d, envSize = %d \n", pReq->Size , envSize ));
#endif

    //
    // Now send the buffer out to the server
    //
    Result = WriteFile(
                 hPipe,
                 Buf,
                 Count,
                 &AmountWrote,
                 NULL
                 );

    if( !Result ) {
        KdPrint(("logon32.c: Error %d sending request\n",GetLastError() ));
        goto Cleanup;
    }

    //
    // Now read the reply
    //
    Result = ReadFile(
                 hPipe,
                 &Rep,
                 sizeof(Rep),
                 &AmountRead,
                 NULL
                 );

    if( !Result ) {
        KdPrint(("logon32.c: Error %d reading reply\n",GetLastError()));
        goto Cleanup;
    }

    //
    // Check the result
    //
    if( !Rep.Result ) {
        KdPrint(("logon32.c: Error %d in reply\n",Rep.LastError));
        //
        // set the error in the current thread to the returned error
        //
        Result = Rep.Result;
        SetLastError( Rep.LastError );
        goto Cleanup;
    }

    //
    // We copy the PROCESS_INFO structure from the reply
    // to the caller.
    //
    // The remote site has duplicated the handles into our
    // process space for hProcess and hThread so that they will
    // behave like CreateProcessW()
    //

     RtlMoveMemory( pProcInfo, &Rep.ProcInfo, sizeof( PROCESS_INFORMATION ) );

Cleanup:
    CloseHandle(hPipe);

   KdPrint(("logon32.c:: Result 0x%x\n", Result));

    return(Result);
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateProcessAsUserW
//
//  Synopsis:   Creates a process running as the user in hToken.
//
//  Arguments:  [hToken]               -- Handle to a Primary Token to use
//              [lpApplicationName]    -- as CreateProcess() q.v.
//              [lpCommandLine]        --
//              [lpProcessAttributes]  --
//              [lpThreadAttributes]   --
//              [bInheritHandles]      --
//              [dwCreationFlags]      --
//              [lpEnvironment]        --
//              [lpCurrentDirectory]   --
//              [lpStartupInfo]        --
//              [lpProcessInformation] --
//
//  Return Values
//          If the function succeeds, the return value is nonzero.
//          If the function fails, the return value is zero. To get extended error information, call GetLastError.
//
//  History:    4-25-95   RichardW   Created
//              1-14-98     AraBern     add changes for Hydra
//  Notes:
//
//
//----------------------------------------------------------------------------
BOOL
WINAPI
CreateProcessAsUserW(
    HANDLE  hToken,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    DWORD    CreateFlags;
    DWORD    clientSessionID=0;
    DWORD    currentSessionID=0;
    DWORD    resultLength;
    HANDLE   hTmpToken;
    DWORD    curProcId ;
    NTSTATUS Status ;

    CreateFlags = (dwCreationFlags & CREATE_SUSPENDED ? COMMON_CREATE_SUSPENDED : 0);

    //
    // get the sessionID (if zero then it means that we are on the console).
    //
    currentSessionID = NtCurrentPeb()->SessionId;

    if ( !GetTokenInformation ( hToken, TokenSessionId , &clientSessionID,sizeof( DWORD), &resultLength ) )
    {
    //
    // get the access token for the client of this call
    // get token instead of process since the client might have only
    // impersonated the thread, not the process
    //
        DBG_DumpOutLastError;
        ASSERT( FALSE );
        currentSessionID = 0;

        //
        // We should probably return FALSE here, but at this time we don't want to alter the
        // non-Hydra code-execution-flow at all.
        //
    }

    // KdPrint(("logon32.c: CreateProcessAsUserW(): clientSessionID = %d, currentSessionID = %d \n",
    //    clientSessionID, currentSessionID ));

    if (  clientSessionID != currentSessionID )
    {
        //
        // If the client session ID is not the same as the current session ID, then, we are attempting
        // to create a process on a remote session from the current session.
        // This block of code is used to accomplish such process creation, it is Terminal-Server specific
        //

        BOOL        bHaveImpersonated;
        HANDLE      hCurrentThread;
        HANDLE      hPrevToken = NULL;
        DWORD       rc;
        TOKEN_TYPE  tokenType;

        //
        // We must send the request to the remote session
        // of the requestor
        //
        // NOTE: The current WinStationCreateProcessW() does not use
        //       the supplied security descriptor, but creates the
        //       process under the account of the logged on user.
        //

        //
        // Stop impersonating before doing the WinStationCreateProcess.
        // The remote winstation exec thread will launch the app under
        // the users context. We must not be impersonating because this
        // call only lets SYSTEM request the remote execute.
        //

        //
        // Handle Inheritance is not allowed for cross session process creation
        //
        if (bInheritHandles) {

          SetLastError(ERROR_INVALID_PARAMETER);

          return FALSE;
        }

        hCurrentThread = GetCurrentThread();

        //
        // Init bHaveImpersonated to the FALSE state
        //
        bHaveImpersonated = FALSE;

        //
        // Since the caller of this function (runas-> SecLogon service ) has already
        // impersonated the new (target) user, we do the OpenThreadToken with
        // OpenAsSelf = TRUE
        //
        if ( OpenThreadToken( hCurrentThread, TOKEN_QUERY, TRUE, &hPrevToken ) )
        {

            bHaveImpersonated = TRUE;

            if ( !RevertToSelf() )
            {
                return FALSE;
            }
        }


       //
       // else, we are not impersonating, as reflected by the init value of bHaveImpersonated
       //

        rc = CreateRemoteSessionProcessW(
                clientSessionID,
                FALSE,     // not creating a process for System
                hToken,
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags |  CREATE_SEPARATE_WOW_VDM,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation) ;

        //
        // Undo the effect of RevertToSelf() if we had impersoanted
        //
        if ( bHaveImpersonated )
        {
            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        &hPrevToken,
                        sizeof( hPrevToken ) );

            NtClose( hPrevToken );
        }

        if ( rc )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }

    }
    else
    //
    // this is the standard non-Hydra related call block
    //
    {
        HANDLE hRestrictedToken = NULL;
        BOOL b = FALSE;

        if (!CreateProcessInternalW(hToken,
                                    lpApplicationName,
                                    lpCommandLine,
                                    lpProcessAttributes,
                                    lpThreadAttributes,
                                    bInheritHandles,
                                    (dwCreationFlags | CREATE_SUSPENDED |
                                        CREATE_SEPARATE_WOW_VDM),
                                    lpEnvironment,
                                    lpCurrentDirectory,
                                    lpStartupInfo,
                                    lpProcessInformation,
                                    &hRestrictedToken))
        {
            //
            // The internal routine might return a token even in the failure case
            // since it uses try-finally. Free the token if needed.
            //

            if (hRestrictedToken != NULL)
            {
                NtClose(hRestrictedToken); 
            } 
            return(FALSE);
        }

        CreateFlags |= (lpProcessAttributes ? 0 : COMMON_CREATE_PROCESSSD);
        CreateFlags |= (lpThreadAttributes ? 0 : COMMON_CREATE_THREADSD);

        //
        // If a restricted token was returned, set it on the process.
        // Else use the token provided by the caller.
        //

        if (hRestrictedToken == NULL) 
        {
            b = (L32CommonCreate(CreateFlags, hToken, lpProcessInformation));
        }
        else
        {
            b = (L32CommonCreate(CreateFlags, hRestrictedToken, lpProcessInformation));
            NtClose(hRestrictedToken);
        }

        return b;
    }
}


/***************************************************************************\
* OemToCharW
*
* OemToCharW(pSrc, pDst) - Translates the OEM string at pSrc into
* the Unicode string at pDst.  pSrc == pDst is not legal.
*
* History:
*   This function was copied from NT\windows\Core\ntuser\client\oemxlate.c
*
\***************************************************************************/
BOOL WINAPI ConvertOemToCharW(
    LPCSTR pSrc,
    LPWSTR pDst)
{
    int cch;
    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    } else if (pSrc == (LPCSTR)pDst) {
        /*
         * MultiByteToWideChar() requires pSrc != pDst: fail this call.
         * LATER: Is this really true?
         */
        return FALSE;
    }

    cch = strlen(pSrc) + 1;

    MultiByteToWideChar(
            CP_OEMCP,                          // Unicode -> OEM
            MB_PRECOMPOSED | MB_USEGLYPHCHARS, // visual map to precomposed
            (LPSTR)pSrc, cch,                  // source & length
            pDst,                              // destination
            cch);                              // max poss. precomposed length

    return TRUE;
}


//----------------------------------------------------------------------------
//
// Function:    OemToCharW_WithAllocation()
//
// Synopsis:    This func will allocated memory for the string ppDst which
//              must be then deallocatd thru a call to LocalFree().
//              If the passed in ansi string is NULL, then no memory
//              is allocated, and a NULL is returned
//
// Arguments:
//              LPCSTR  [in]    ansi string for which we want the wide version
//              *LPWSTR [out]   the wide version of ansi string
// Return:
//      BOOL : TRUE if no errors.
//      BOOL : FALSE if unable to allocated memory.
//
//----------------------------------------------------------------------------
BOOL WINAPI OemToCharW_WithAllocation(  LPCSTR pSrc,
    LPWSTR *ppDst)
{
    DWORD size;

    if (pSrc)
    {
        size = strlen( pSrc );

        *ppDst = ( WCHAR *) LocalAlloc(LMEM_FIXED, ( size + 1 ) * sizeof( WCHAR ) );

        if ( ppDst )
        {
            ConvertOemToCharW( pSrc, *ppDst );
            return TRUE;
        }
        else
            return FALSE;
    }
    else
    {
        *ppDst = NULL;
        return TRUE;
    }

}


//  ANSI wrapper for CreateRemoteSessionProcessW()
//
BOOL
CreateRemoteSessionProcessA(
    ULONG  SessionId,
    BOOL   System,
    HANDLE  hToken,
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
)
{
    NTSTATUS                st;
    BOOL                    rc,rc2;
    STARTUPINFOW            WCHAR_StartupInfo;
    PWCHAR                  pWCHAR_AppName, pWCHAR_CommandLine, pWCHAR_CurDir, pWCHAR_Title, pWCHAR_Desktop;

    pWCHAR_AppName = pWCHAR_CommandLine =  pWCHAR_CurDir = pWCHAR_Title =  pWCHAR_Desktop = NULL;

    // in case there is a premature return from this function.
    rc2 = FALSE;

    if ( !( rc = OemToCharW_WithAllocation( lpApplicationName , &pWCHAR_AppName ) ))
    {
        goto Cleanup;
    }

    if ( !( rc = OemToCharW_WithAllocation( lpCommandLine , &pWCHAR_CommandLine ) ))
    {
        goto Cleanup;
    }

    if ( !( rc = OemToCharW_WithAllocation( lpCurrentDirectory , &pWCHAR_CurDir ) ))
    {
        goto Cleanup;
    }

    if ( !( rc = OemToCharW_WithAllocation( lpStartupInfo->lpTitle , &pWCHAR_Title ) ))
    {
        goto Cleanup;
    }

    if ( !( rc = OemToCharW_WithAllocation( lpStartupInfo->lpDesktop , &pWCHAR_Desktop ) ))
    {
        goto Cleanup;
    }

    WCHAR_StartupInfo.cb               = lpStartupInfo->cb ;
    WCHAR_StartupInfo.cbReserved2      = lpStartupInfo->cbReserved2;
    WCHAR_StartupInfo.dwFillAttribute  = lpStartupInfo->dwFillAttribute;
    WCHAR_StartupInfo.dwFlags          = lpStartupInfo->dwFlags;
    WCHAR_StartupInfo.dwX              = lpStartupInfo->dwX;
    WCHAR_StartupInfo.dwXCountChars    = lpStartupInfo->dwXCountChars;
    WCHAR_StartupInfo.dwXSize          = lpStartupInfo->dwXSize;
    WCHAR_StartupInfo.dwY              = lpStartupInfo->dwY;
    WCHAR_StartupInfo.dwYCountChars    = lpStartupInfo->dwYCountChars;
    WCHAR_StartupInfo.dwYSize          = lpStartupInfo->dwYSize;
    WCHAR_StartupInfo.hStdError        = lpStartupInfo->hStdError;
    WCHAR_StartupInfo.hStdInput        = lpStartupInfo->hStdInput;
    WCHAR_StartupInfo.hStdOutput       = lpStartupInfo->hStdOutput;
    WCHAR_StartupInfo.lpReserved2      = lpStartupInfo->lpReserved2;
    WCHAR_StartupInfo.wShowWindow      = lpStartupInfo->wShowWindow;
    WCHAR_StartupInfo.lpDesktop        = pWCHAR_Desktop;
    WCHAR_StartupInfo.lpReserved       = NULL;
    WCHAR_StartupInfo.lpTitle          = pWCHAR_Title;

    rc2 =     CreateRemoteSessionProcessW(
        SessionId,
        System,
        hToken,
        pWCHAR_AppName ,
        pWCHAR_CommandLine,
        lpProcessAttributes,
        lpThreadAttributes ,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        pWCHAR_CurDir,
        &WCHAR_StartupInfo,
        lpProcessInformation
    );

Cleanup:

    if ( !rc )  // rc is set to FALSE if an attempted memory allocation has failed.
    {
        BaseSetLastNTError(STATUS_NO_MEMORY);
    }

    if (pWCHAR_AppName)
    {
        LocalFree( pWCHAR_AppName );
    }

    if (pWCHAR_CommandLine)
    {
        LocalFree( pWCHAR_CommandLine );
    }

    if (pWCHAR_CurDir)
    {
        LocalFree( pWCHAR_CurDir );
    }

    if (pWCHAR_Title)
    {
        LocalFree( pWCHAR_Title );
    }

    if (pWCHAR_Desktop)
    {
        LocalFree( pWCHAR_Desktop );
    }

    return rc2;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateProcessAsUserA
//
//  Synopsis:   ANSI wrapper for CreateProcessAsUserW
//
//  Arguments:  [hToken]               --
//              [lpApplicationName]    --
//              [lpCommandLine]        --
//              [lpProcessAttributes]  --
//              [lpThreadAttributes]   --
//              [bInheritHandles]      --
//              [dwCreationFlags]      --
//              [lpEnvironment]        --
//              [lpCurrentDirectory]   --
//              [lpStartupInfo]        --
//              [lpProcessInformation] --
//
//  Return Values
//          If the function succeeds, the return value is nonzero.
//          If the function fails, the return value is zero. To get extended error information, call GetLastError.
//
//  History:    4-25-95   RichardW   Created
//              1-14-98  AraBern     add changes for Hydra
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
CreateProcessAsUserA(
    HANDLE  hToken,
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    DWORD   CreateFlags;
    DWORD   clientSessionID=0;
    DWORD   currentSessionID=0;
    DWORD   resultLength;
    HANDLE  hTmpToken;
    DWORD   curProcId ;
    NTSTATUS Status ;

    CreateFlags = (dwCreationFlags & CREATE_SUSPENDED ? COMMON_CREATE_SUSPENDED : 0);

    //
    // get the session if (zero means console).
    //
    currentSessionID = NtCurrentPeb()->SessionId;

    if ( !GetTokenInformation ( hToken, TokenSessionId , &clientSessionID,sizeof( DWORD), &resultLength ) )
    {
    //
    // get the access token for the client of this call
    // use get token instead of process since the client might have only
    // impersonated the thread, not the process
    //
        DBG_DumpOutLastError;
        ASSERT( FALSE );
        currentSessionID = 0;

        //
        // We should probably return FALSE here, but at this time we don't want to alter the
        // non-Hydra code-execution-flow at all.
        //
    }

    KdPrint(("logon32.c: CreateProcessAsUserA(): clientSessionID = %d, currentSessionID = %d \n",
            clientSessionID, currentSessionID ));

    if ( ( clientSessionID != currentSessionID ))
    {
       //
       // If the client session ID is not the same as the current session ID, then, we are attempting
       // to create a process on a remote session from the current session.
       // This block of code is used to accomplish such process creation, it is Terminal-Server specific
       //

       BOOL        bHaveImpersonated;
       HANDLE      hCurrentThread;
       HANDLE      hPrevToken = NULL;
       DWORD       rc;
       TOKEN_TYPE  tokenType;

       //
       // We must send the request to the remote WinStation
       // of the requestor
       //
       // NOTE: The current WinStationCreateProcessW() does not use
       //       the supplied security descriptor, but creates the
       //       process under the account of the logged on user.
       //

       //
       // Stop impersonating before doing the WinStationCreateProcess.
       // The remote winstation exec thread will launch the app under
       // the users context. We must not be impersonating because this
       // call only lets SYSTEM request the remote execute.
       //
       hCurrentThread = GetCurrentThread();

       //
       // Init bHaveImpersonated to the FALSE state
       //
       bHaveImpersonated = FALSE;


        //
        // Since the caller of this function (runas-> SecLogon service ) has already
        // impersonated the new (target) user, we do the OpenThreadToken with
        // OpenAsSelf = TRUE
        //
        if ( OpenThreadToken( hCurrentThread, TOKEN_QUERY, TRUE, &hPrevToken ) )
        {

            bHaveImpersonated = TRUE;

            if ( !RevertToSelf() )
            {
                return FALSE;
            }
        }

       //
       // else, we are not impersonating, as reflected by the init value of bHaveImpersonated
       //

        rc = CreateRemoteSessionProcessA(
                clientSessionID,
                FALSE,     // not creating a process for System
                hToken,
                lpApplicationName,
                lpCommandLine,
                lpProcessAttributes,
                lpThreadAttributes,
                bInheritHandles,
                dwCreationFlags |  CREATE_SEPARATE_WOW_VDM,
                lpEnvironment,
                lpCurrentDirectory,
                lpStartupInfo,
                lpProcessInformation) ;

        //
        // Undo the effect of RevertToSelf() if we had impersoanted
        //
        if ( bHaveImpersonated )
        {
            Status = NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &hPrevToken,
            sizeof( hPrevToken ) );

            NtClose( hPrevToken );
        }

        if ( rc )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }

    }
    else
    //
    // this is the standard non-Hydra related call block
    //
    {
        HANDLE hRestrictedToken = NULL;
        BOOL b = FALSE;

        if (!CreateProcessInternalA(hToken,
                                    lpApplicationName,
                                    lpCommandLine,
                                    lpProcessAttributes,
                                    lpThreadAttributes,
                                    bInheritHandles,
                                    (dwCreationFlags | CREATE_SUSPENDED |
                                     CREATE_SEPARATE_WOW_VDM),
                                    lpEnvironment,
                                    lpCurrentDirectory,
                                    lpStartupInfo,
                                    lpProcessInformation,
                                    &hRestrictedToken))
        {
            //
            // The internal routine might return a token even in the failure case
            // since it uses try-finally. Free the token if needed.
            //

            if (hRestrictedToken != NULL)
            {
                NtClose(hRestrictedToken); 
            } 
            return(FALSE);
        }

        CreateFlags |= (lpProcessAttributes ? 0 : COMMON_CREATE_PROCESSSD);
        CreateFlags |= (lpThreadAttributes ? 0 : COMMON_CREATE_THREADSD);

        //
        // If a restricted token was returned, set it on the process.
        // Else use the token provided by the caller.
        //

        if (hRestrictedToken == NULL) 
        {
            b = (L32CommonCreate(CreateFlags, hToken, lpProcessInformation));
        }
        else
        {
            b = (L32CommonCreate(CreateFlags, hRestrictedToken, lpProcessInformation));
            NtClose(hRestrictedToken);
        }

        return b;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\sddl.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    sddl.c

Abstract:

    This module implements the Security Descriptor Definition Language support functions

Author:

    Mac McLain          (MacM)       Nov 07, 1997

Environment:

    User Mode

Revision History:

    Jin Huang           (JinHuang)  3/4/98   Fix validity flags (GetAceFlagsInTable)
    Jin Huang           (JinHuang)  3/10/98  Add SD controls (GetSDControlForString)
                                             Set SidsInitialized flag
                                             Skip any possible spaces in string
    Jin Huang           (JinHuang)  5/1/98   Fix memory leek, error checking
                                             improve performance
    Alaa Abdelhalim     (Alaa)      7/20/99  Initialize sbz2 field to 0 in LocalGetAclForString
                                             function.
    Vishnu Patankar     (VishnuP)   7/5/00   Added new API ConvertStringSDToSDDomain(A/W)

--*/
#include "advapi.h"
#include <windef.h>
#include <stdio.h>
#include <wchar.h>
#include <sddl.h>
#include <ntseapi.h>
#include <seopaque.h>
#include <accctrl.h>
#include <rpcdce.h>
#include <ntlsa.h>
#include "sddlp.h"


//
// include and defines for ldap calls
//
#include <winldap.h>
#include <ntldap.h>

typedef LDAP * (LDAPAPI *PFN_LDAP_OPEN)( PCHAR, ULONG );
typedef ULONG (LDAPAPI *PFN_LDAP_UNBIND)( LDAP * );
typedef ULONG (LDAPAPI *PFN_LDAP_SEARCH)(LDAP *, PCHAR, ULONG, PCHAR, PCHAR *, ULONG,PLDAPControlA *, PLDAPControlA *, struct l_timeval *, ULONG, LDAPMessage **);
typedef LDAPMessage * (LDAPAPI *PFN_LDAP_FIRST_ENTRY)( LDAP *, LDAPMessage * );
typedef PCHAR * (LDAPAPI *PFN_LDAP_GET_VALUE)(LDAP *, LDAPMessage *, PCHAR );
typedef ULONG (LDAPAPI *PFN_LDAP_MSGFREE)( LDAPMessage * );
typedef ULONG (LDAPAPI *PFN_LDAP_VALUE_FREE)( PCHAR * );
typedef ULONG (LDAPAPI *PFN_LDAP_MAP_ERROR)( ULONG );

// 64K-1
#define SDDL_MAX_ACL_SIZE      0xFFFF


//
// To allow the defines to be used as Wide strings, redefine the TEXT macro
//
#ifdef TEXT
#undef TEXT
#endif
#define TEXT(quote) L##quote

//
// Local macros
//
#define STRING_GUID_LEN 36
#define STRING_GUID_SIZE  ( STRING_GUID_LEN * sizeof( WCHAR ) )
#define SDDL_LEN_TAG( tagdef )  ( sizeof( tagdef ) / sizeof( WCHAR ) - 1 )
#define SDDL_SIZE_TAG( tagdef )  ( wcslen( tagdef ) * sizeof( WCHAR ) )
#define SDDL_SIZE_SEP( sep ) (sizeof( WCHAR ) )

#define SDDL_VALID_DACL  0x00000001
#define SDDL_VALID_SACL  0x00000002

//
// This structure is used to do some lookups for mapping ACES
//
typedef struct _STRSD_KEY_LOOKUP {

    PWSTR Key;
    ULONG KeyLen;
    ULONG Value;
    ULONG ValidityFlags;

} STRSD_KEY_LOOKUP, *PSTRSD_KEY_LOOKUP;

typedef enum _STRSD_SID_TYPE {
    ST_DOMAIN_RELATIVE = 0,
    ST_WORLD,
    ST_LOCALSY,
    ST_LOCAL,
    ST_CREATOR,
    ST_NTAUTH,
    ST_BUILTIN,
    ST_ROOT_DOMAIN_RELATIVE
} STRSD_SID_TYPE;

//
// This structure is used to map account monikers to sids
//
typedef struct _STRSD_SID_LOOKUP {

    BOOLEAN Valid;
    WCHAR Key[SDDL_ALIAS_SIZE+2];
    ULONG KeyLen;
    PSID Sid;
    ULONG Rid;
    STRSD_SID_TYPE SidType;
    DWORD SidBuff[ sizeof( SID ) / sizeof( DWORD ) + 5];
} STRSD_SID_LOOKUP, *PSTRSD_SID_LOOKUP;

//
// Globally defined sids
//
/* JINHUANG: not used anywhere
DWORD PersonalSelfBuiltSid[sizeof(SID)/sizeof(DWORD) + 2];
DWORD AuthUserBuiltSid[sizeof(SID)/sizeof(DWORD) + 2];
DWORD CreatorOwnerBuiltSid[sizeof(SID)/sizeof(DWORD) + 2];
DWORD CreatorGroupBuiltSid[sizeof(SID)/sizeof(DWORD) + 2];
PSID  PersonalSelfSid = (PSID)PersonalSelfBuiltSid;
PSID  AuthUserSid = (PSID)AuthUserBuiltSid;
PSID  CreatorOwnerSid = (PSID)CreatorOwnerBuiltSid;
PSID  CreatorGroupSid = (PSID)CreatorGroupBuiltSid;
*/

CRITICAL_SECTION SddlSidLookupCritical;
static DWORD SidTableReinitializeInstance=0;

//    JINHUANG 3/26 BVT break for dcpromo
//
//    Some of the Valid fields were preset to TRUE with NULL Sid field. The SidLookup
//    table initialization is stopped if Status is not SUCCESS. So if error occurs,
//    for example, no domain info as in dcpromo, other SIDs will not be initialized
//    but the Valid fields are set to TRUE (with NULL SIDs).
//
//    changes: 1) preset Valid field to FALSE all all lookups and set the Valid to TRUE if
//                the SID is really initialized
//             2) do not stop the initialization process if an error occurs
//                if the Valid field is already TRUE (already initialized), skip the row
//
static STRSD_SID_LOOKUP  SidLookup[] = {
        { FALSE, SDDL_DOMAIN_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_DOMAIN_ADMINISTRATORS ),
            NULL, DOMAIN_GROUP_RID_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_GUESTS, SDDL_LEN_TAG( SDDL_DOMAIN_GUESTS ),
            NULL, DOMAIN_GROUP_RID_GUESTS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_USERS, SDDL_LEN_TAG( SDDL_DOMAIN_USERS ),
              NULL, DOMAIN_GROUP_RID_USERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_DOMAIN_CONTROLLERS, SDDL_LEN_TAG( SDDL_DOMAIN_DOMAIN_CONTROLLERS ),
              NULL, DOMAIN_GROUP_RID_CONTROLLERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_COMPUTERS, SDDL_LEN_TAG( SDDL_DOMAIN_COMPUTERS ),
              NULL, DOMAIN_GROUP_RID_COMPUTERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_SCHEMA_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_SCHEMA_ADMINISTRATORS ),
              NULL, DOMAIN_GROUP_RID_SCHEMA_ADMINS, ST_ROOT_DOMAIN_RELATIVE, 0 },  // should be root domain only ST_DOMAIN_RELATIVE,
        { FALSE, SDDL_ENTERPRISE_ADMINS, SDDL_LEN_TAG( SDDL_ENTERPRISE_ADMINS ),
              NULL, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS, ST_ROOT_DOMAIN_RELATIVE, 0 }, // root domain only
        { FALSE, SDDL_CERT_SERV_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_CERT_SERV_ADMINISTRATORS ),
              NULL, DOMAIN_GROUP_RID_CERT_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_ACCOUNT_OPERATORS, SDDL_LEN_TAG( SDDL_ACCOUNT_OPERATORS ),
              NULL, DOMAIN_ALIAS_RID_ACCOUNT_OPS, ST_BUILTIN, 0 },
        { FALSE, SDDL_BACKUP_OPERATORS, SDDL_LEN_TAG( SDDL_BACKUP_OPERATORS ),
              NULL, DOMAIN_ALIAS_RID_BACKUP_OPS, ST_BUILTIN, 0 },
        { FALSE, SDDL_PRINTER_OPERATORS, SDDL_LEN_TAG( SDDL_PRINTER_OPERATORS ),
              NULL, DOMAIN_ALIAS_RID_PRINT_OPS, ST_BUILTIN, 0 },
        { FALSE, SDDL_SERVER_OPERATORS, SDDL_LEN_TAG( SDDL_SERVER_OPERATORS ),
              NULL, DOMAIN_ALIAS_RID_SYSTEM_OPS, ST_BUILTIN, 0 },
        { FALSE, SDDL_REPLICATOR, SDDL_LEN_TAG( SDDL_REPLICATOR ),
              NULL, DOMAIN_ALIAS_RID_REPLICATOR, ST_BUILTIN, 0 },
        { FALSE, SDDL_RAS_SERVERS, SDDL_LEN_TAG( SDDL_RAS_SERVERS ),
              NULL, DOMAIN_ALIAS_RID_RAS_SERVERS, ST_DOMAIN_RELATIVE, 0 },  // ST_LOCAL
        { FALSE, SDDL_AUTHENTICATED_USERS, SDDL_LEN_TAG( SDDL_AUTHENTICATED_USERS ),
              NULL, SECURITY_AUTHENTICATED_USER_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_PERSONAL_SELF, SDDL_LEN_TAG( SDDL_PERSONAL_SELF ),
              NULL, SECURITY_PRINCIPAL_SELF_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_CREATOR_OWNER, SDDL_LEN_TAG( SDDL_CREATOR_OWNER ),
              NULL, SECURITY_CREATOR_OWNER_RID, ST_CREATOR, 0 },
        { FALSE, SDDL_CREATOR_GROUP, SDDL_LEN_TAG( SDDL_CREATOR_GROUP ),
              NULL, SECURITY_CREATOR_GROUP_RID, ST_CREATOR, 0 },
        { FALSE, SDDL_LOCAL_SYSTEM, SDDL_LEN_TAG( SDDL_LOCAL_SYSTEM ),
              NULL, SECURITY_LOCAL_SYSTEM_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_INTERACTIVE, SDDL_LEN_TAG( SDDL_INTERACTIVE ),
              NULL, SECURITY_INTERACTIVE_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_NETWORK, SDDL_LEN_TAG( SDDL_NETWORK ),
              NULL, SECURITY_NETWORK_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_SERVICE, SDDL_LEN_TAG( SDDL_SERVICE ),
              NULL, SECURITY_SERVICE_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_ENTERPRISE_DOMAIN_CONTROLLERS, SDDL_LEN_TAG( SDDL_ENTERPRISE_DOMAIN_CONTROLLERS ),
              NULL, SECURITY_SERVER_LOGON_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_RESTRICTED_CODE, SDDL_LEN_TAG( SDDL_RESTRICTED_CODE ),
              NULL, SECURITY_RESTRICTED_CODE_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_ANONYMOUS, SDDL_LEN_TAG( SDDL_ANONYMOUS ),
              NULL, SECURITY_ANONYMOUS_LOGON_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_LOCAL_ADMIN, SDDL_LEN_TAG( SDDL_LOCAL_ADMIN ),
              NULL, DOMAIN_USER_RID_ADMIN, ST_LOCAL, 0 },
        { FALSE, SDDL_LOCAL_GUEST, SDDL_LEN_TAG( SDDL_LOCAL_GUEST ),
              NULL, DOMAIN_USER_RID_GUEST, ST_LOCAL, 0 },
        { FALSE, SDDL_BUILTIN_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_BUILTIN_ADMINISTRATORS ),
              NULL, DOMAIN_ALIAS_RID_ADMINS, ST_BUILTIN, 0 },
        { FALSE, SDDL_BUILTIN_GUESTS, SDDL_LEN_TAG( SDDL_BUILTIN_GUESTS ),
              NULL, DOMAIN_ALIAS_RID_GUESTS, ST_BUILTIN, 0 },
        { FALSE, SDDL_BUILTIN_USERS, SDDL_LEN_TAG( SDDL_BUILTIN_USERS ),
              NULL, DOMAIN_ALIAS_RID_USERS, ST_BUILTIN, 0 },
        { FALSE, SDDL_POWER_USERS, SDDL_LEN_TAG( SDDL_POWER_USERS ),
              NULL, DOMAIN_ALIAS_RID_POWER_USERS, ST_BUILTIN, 0 },
        { FALSE, SDDL_EVERYONE, SDDL_LEN_TAG( SDDL_EVERYONE ),
              NULL, SECURITY_WORLD_RID, ST_WORLD, 0 },
        { FALSE, SDDL_GROUP_POLICY_ADMINS, SDDL_LEN_TAG( SDDL_GROUP_POLICY_ADMINS ),
              NULL, DOMAIN_GROUP_RID_POLICY_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_ALIAS_PREW2KCOMPACC, SDDL_LEN_TAG( SDDL_ALIAS_PREW2KCOMPACC ),
              NULL, DOMAIN_ALIAS_RID_PREW2KCOMPACCESS, ST_BUILTIN, 0 },
        { FALSE, SDDL_LOCAL_SERVICE, SDDL_LEN_TAG( SDDL_LOCAL_SERVICE ),
              NULL, SECURITY_LOCAL_SERVICE_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_NETWORK_SERVICE, SDDL_LEN_TAG( SDDL_NETWORK_SERVICE ),
              NULL, SECURITY_NETWORK_SERVICE_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_REMOTE_DESKTOP, SDDL_LEN_TAG( SDDL_REMOTE_DESKTOP ),
              NULL, DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, ST_BUILTIN, 0 },
        { FALSE, SDDL_NETWORK_CONFIGURATION_OPS, SDDL_LEN_TAG( SDDL_NETWORK_CONFIGURATION_OPS ),
              NULL, DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS, ST_BUILTIN, 0 }
    };



STRSD_SID_LOOKUP  SidLookupDomOrRootDomRelative[] = {
        { FALSE, SDDL_DOMAIN_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_DOMAIN_ADMINISTRATORS ),
            NULL, DOMAIN_GROUP_RID_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_GUESTS, SDDL_LEN_TAG( SDDL_DOMAIN_GUESTS ),
            NULL, DOMAIN_GROUP_RID_GUESTS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_USERS, SDDL_LEN_TAG( SDDL_DOMAIN_USERS ),
              NULL, DOMAIN_GROUP_RID_USERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_DOMAIN_CONTROLLERS, SDDL_LEN_TAG( SDDL_DOMAIN_DOMAIN_CONTROLLERS ),
              NULL, DOMAIN_GROUP_RID_CONTROLLERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_COMPUTERS, SDDL_LEN_TAG( SDDL_DOMAIN_COMPUTERS ),
              NULL, DOMAIN_GROUP_RID_COMPUTERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_CERT_SERV_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_CERT_SERV_ADMINISTRATORS ),
              NULL, DOMAIN_GROUP_RID_CERT_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_RAS_SERVERS, SDDL_LEN_TAG( SDDL_RAS_SERVERS ),
              NULL, DOMAIN_ALIAS_RID_RAS_SERVERS, ST_DOMAIN_RELATIVE, 0 },  // ST_LOCAL
        { FALSE, SDDL_GROUP_POLICY_ADMINS, SDDL_LEN_TAG( SDDL_GROUP_POLICY_ADMINS ),
              NULL, DOMAIN_GROUP_RID_POLICY_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_SCHEMA_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_SCHEMA_ADMINISTRATORS ),
            NULL, DOMAIN_GROUP_RID_SCHEMA_ADMINS, ST_ROOT_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_ENTERPRISE_ADMINS, SDDL_LEN_TAG( SDDL_ENTERPRISE_ADMINS ),
            NULL, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS, ST_ROOT_DOMAIN_RELATIVE, 0 }
    };




static DWORD RootDomSidBuf[sizeof(SID)/sizeof(DWORD)+5];
static BOOL RootDomInited=FALSE;

#define STRSD_REINITIALIZE_ENTER              1
#define STRSD_REINITIALIZE_LEAVE              2

BOOLEAN
InitializeSidLookupTable(
    IN BYTE InitFlag
    );

//
// Control Lookup table
//
static STRSD_KEY_LOOKUP ControlLookup[] = {
    { SDDL_PROTECTED, SDDL_LEN_TAG( SDDL_PROTECTED ), SE_DACL_PROTECTED, SDDL_VALID_DACL },
    { SDDL_AUTO_INHERIT_REQ, SDDL_LEN_TAG( SDDL_AUTO_INHERIT_REQ ), SE_DACL_AUTO_INHERIT_REQ, SDDL_VALID_DACL },
    { SDDL_AUTO_INHERITED, SDDL_LEN_TAG( SDDL_AUTO_INHERITED ), SE_DACL_AUTO_INHERITED, SDDL_VALID_DACL },
    { SDDL_PROTECTED, SDDL_LEN_TAG( SDDL_PROTECTED ), SE_SACL_PROTECTED, SDDL_VALID_SACL },
    { SDDL_AUTO_INHERIT_REQ, SDDL_LEN_TAG( SDDL_AUTO_INHERIT_REQ ), SE_SACL_AUTO_INHERIT_REQ, SDDL_VALID_SACL },
    { SDDL_AUTO_INHERITED, SDDL_LEN_TAG( SDDL_AUTO_INHERITED ), SE_SACL_AUTO_INHERITED, SDDL_VALID_SACL }
    };

//
// Local prototypes
//
BOOL
LocalConvertStringSidToSid(
    IN  PWSTR String,
    OUT PSID *SID,
    OUT PWSTR *End
    );

PSTRSD_SID_LOOKUP
LookupSidInTable(
    IN PWSTR String, OPTIONAL
    IN PSID Sid OPTIONAL,
    IN PSID RootDomainSid OPTIONAL,
    IN PSID DomainSid OPTIONAL,
    IN PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN BOOLEAN DefaultToDomain,
    OUT PVOID *pSASid
    );

DWORD
LocalGetSidForString(
    IN  PWSTR String,
    OUT PSID *SID,
    OUT PWSTR *End,
    OUT PBOOLEAN FreeSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN  BOOLEAN DefaultToDomain
    );

PSTRSD_KEY_LOOKUP
LookupAccessMaskInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AccessMask, OPTIONAL
    IN ULONG LookupFlags
    );


PSTRSD_KEY_LOOKUP
LookupAceTypeInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AceType, OPTIONAL
    IN ULONG LookupFlags
    );

PSTRSD_KEY_LOOKUP
LookupAceFlagsInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AceFlags OPTIONAL,
    IN ULONG LookupFlags
    );

DWORD
LocalGetStringForSid(
    IN  PSID Sid,
    OUT PWSTR *String,
    IN  PSID RootDomainSid OPTIONAL
    );

DWORD
LocalGetStringForControl(
    IN SECURITY_DESCRIPTOR_CONTROL ControlCode,
    IN ULONG LookupFlags,
    OUT PWSTR *ControlString
    );

DWORD
LocalGetSDControlForString (
    IN  PWSTR AclString,
    IN ULONG LookupFlags,
    OUT SECURITY_DESCRIPTOR_CONTROL *pControl,
    OUT PWSTR *End
    );

DWORD
LocalGetAclForString (
    IN  PWSTR AclString,
    IN  BOOLEAN ConvertAsDacl,
    OUT PACL *Acl,
    OUT PWSTR *End,
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN  BOOLEAN DefaultToDomain
    );

DWORD
LocalConvertAclToString(
    IN PACL Acl,
    IN BOOLEAN AclPresent,
    IN BOOLEAN ConvertAsDacl,
    OUT PWSTR *AclString,
    OUT PDWORD AclStringSize,
    IN PSID RootDomainSid OPTIONAL
    );

DWORD
LocalConvertSDToStringSD_Rev1(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  SECURITY_INFORMATION  SecurityInformation,
    OUT LPWSTR  *StringSecurityDescriptor,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    );

DWORD
LocalConvertStringSDToSD_Rev1(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  BOOLEAN DefaultToDomain,
    IN  LPCWSTR StringSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );

BOOL
SddlpGetRootDomainSid(void);

//
// Exported functions
//

BOOL
APIENTRY
ConvertSidToStringSidA(
    IN  PSID     Sid,
    OUT LPSTR  *StringSid
    )
/*++

Routine Description:

    ANSI thunk to ConvertSidToStringSidW

--*/
{
    LPWSTR StringSidW = NULL;
    ULONG AnsiLen, WideLen;
    BOOL ReturnValue;

    if ( NULL == StringSid ) {
        //
        // invalid parameter
        //
        SetLastError( ERROR_INVALID_PARAMETER );
        return(FALSE);
    }

    ReturnValue = ConvertSidToStringSidW( Sid, &StringSidW );

    if ( ReturnValue ) {

        WideLen = wcslen( StringSidW ) + 1;

        AnsiLen = WideCharToMultiByte( CP_ACP,
                                       0,
                                       StringSidW,
                                       WideLen,
                                       *StringSid,
                                       0,
                                       NULL,
                                       NULL );

        if ( AnsiLen != 0 ) {

            *StringSid = LocalAlloc( LMEM_FIXED, AnsiLen );

            if ( *StringSid == NULL ) {

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                ReturnValue = FALSE;

            } else {

                AnsiLen = WideCharToMultiByte( CP_ACP,
                                               0,
                                               StringSidW,
                                               WideLen,
                                               *StringSid,
                                               AnsiLen,
                                               NULL,
                                               NULL );
                ASSERT( AnsiLen != 0 );

                if ( AnsiLen == 0 ) {

                    ReturnValue = FALSE;
                    //
                    // jinhuang: failed, free the buffer
                    //
                    LocalFree(*StringSid);
                    *StringSid = NULL;
                }
            }

        } else {

            ReturnValue = FALSE;
        }

    }

    //
    // jinhuang: free the wide buffer
    //
    if ( StringSidW ) {
        LocalFree(StringSidW);
    }

    if ( ReturnValue ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( ReturnValue );

}


BOOL
APIENTRY
ConvertSidToStringSidW(
    IN  PSID     Sid,
    OUT LPWSTR  *StringSid
    )
/*++

Routine Description:

    This routine converts a SID into a string representation of a SID, suitable for framing or
    display

Arguments:

    Sid - SID to be converted.

    StringSid - Where the converted SID is returned.  Allocated via LocalAlloc and needs to
        be freed via LocalFree.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeStringSid;

    if ( NULL == Sid || NULL == StringSid ) {
        //
        // invalid parameter
        //
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    //
    // Convert using the Rtl functions
    //
    Status = RtlConvertSidToUnicodeString( &UnicodeStringSid, Sid, TRUE );

    if ( !NT_SUCCESS( Status ) ) {

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    //
    // Convert it to the proper allocator
    //
    *StringSid = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                             UnicodeStringSid.Length + sizeof( WCHAR ) );

    if ( *StringSid == NULL ) {

        RtlFreeUnicodeString( &UnicodeStringSid );

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( FALSE );

    }

    RtlCopyMemory( *StringSid, UnicodeStringSid.Buffer, UnicodeStringSid.Length );
    RtlFreeUnicodeString( &UnicodeStringSid );

    SetLastError(ERROR_SUCCESS);
    return( TRUE );
}


BOOL
APIENTRY
ConvertStringSidToSidA(
    IN LPCSTR  StringSid,
    OUT PSID   *Sid
    )
/*++

Routine Description:

    ANSI thunk to ConvertStringSidToSidW

--*/
{
    UNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL Result;

    if ( NULL == StringSid || NULL == Sid ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return(FALSE);
    }

    RtlInitAnsiString( &AnsiString, StringSid );

    Status = SddlpAnsiStringToUnicodeString(&Unicode,
                                            &AnsiString);

    if ( !NT_SUCCESS( Status ) ) {

        BaseSetLastNTError( Status );

        return FALSE;

    }


    Result = ConvertStringSidToSidW( ( LPCWSTR )Unicode.Buffer, Sid );

    LocalFree( Unicode.Buffer );

    if ( Result ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( Result );
}


BOOL
APIENTRY
ConvertStringSidToSidW(
    IN LPCWSTR  StringSid,
    OUT PSID   *Sid
    )
/*++

Routine Description:

    This routine converts a stringized SID into a valid, functional SID

Arguments:

    StringSid - SID to be converted.

    Sid - Where the converted SID is returned.  Buffer is allocated via LocalAlloc and should
        be free via LocalFree.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL name was given

        ERROR_INVALID_SID - The format of the given sid was incorrect

--*/
{
    PWSTR End = NULL;
    BOOL ReturnValue = FALSE;
    PSTRSD_SID_LOOKUP MatchedEntry=NULL;
    PSID pSASid=NULL;
    ULONG Len=0;
    DWORD SaveCode=0;
    DWORD Err=0;

    if ( StringSid == NULL || Sid == NULL ) {

        SetLastError( ERROR_INVALID_PARAMETER );

    } else {

        ReturnValue = LocalConvertStringSidToSid( ( PWSTR )StringSid, Sid, &End );


        if ( ReturnValue == TRUE ) {

            if ( ( ULONG )( End - StringSid ) != wcslen( StringSid ) ) {

                SetLastError( ERROR_INVALID_SID );
                LocalFree( *Sid );
                *Sid = FALSE;
                ReturnValue = FALSE;

            } else {
                SetLastError(ERROR_SUCCESS);
            }

        } else {

            SaveCode = GetLastError();

            //
            // lookup in the SidLookup table to see if it's pre-defined
            //

            MatchedEntry = LookupSidInTable( (PWSTR)StringSid,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             FALSE,
                                             (PVOID *)&pSASid);

            if ( MatchedEntry && MatchedEntry->Sid ) {

                //
                // find it in the table, check if the input string is valid
                //
                if ( wcslen( (PWSTR)StringSid ) != MatchedEntry->KeyLen ) {

                    //
                    // the total string length doesn't match the table define
                    //
                    SetLastError(ERROR_INVALID_SID);

                } else {

                    //
                    // matched! now copy it to the output buffer
                    //
                    Len = RtlLengthSid ( MatchedEntry->Sid );

                    *Sid = ( PSID )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Len );

                    if ( *Sid == NULL ) {

                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

                    } else {

                        Err = RtlNtStatusToDosError(RtlCopySid ( Len, *Sid, MatchedEntry->Sid ) );

                        if ( ERROR_SUCCESS == Err ) {

                            ReturnValue = TRUE;

                        } else {

                            LocalFree(*Sid);
                            *Sid = NULL;
                        }

                        SetLastError(Err);

                    }
                }

            } else if ( pSASid && wcslen((PWSTR)StringSid) == SDDL_LEN_TAG( SDDL_SCHEMA_ADMINISTRATORS ) ) {
                //
                // this is schema admin SID
                //
                *Sid = pSASid;
                pSASid = NULL;

                ReturnValue = TRUE;

                SetLastError(ERROR_SUCCESS);

            } else {
                //
                // reset last error
                //
                SetLastError(SaveCode);
            }
        }

        if ( pSASid ) {
            LocalFree(pSASid);
        }
    }

    return( ReturnValue );

}


BOOL
APIENTRY
ConvertStringSecurityDescriptorToSecurityDescriptorA(
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
/*++

Routine Description:

    ANSI thunk to ConvertStringSecurityDescriptorToSecurityDescriptorW

--*/
{
    UNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL Result;

    if ( NULL == StringSecurityDescriptor ||
         NULL == SecurityDescriptor ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitAnsiString( &AnsiString, StringSecurityDescriptor );

    Status = SddlpAnsiStringToUnicodeString(&Unicode,                                                             
                                            &AnsiString);

    if ( !NT_SUCCESS( Status ) ) {

        BaseSetLastNTError( Status );

        return FALSE;

    }

    Result = ConvertStringSecurityDescriptorToSecurityDescriptorW( ( LPCWSTR )Unicode.Buffer,
                                                                   StringSDRevision,
                                                                   SecurityDescriptor,
                                                                   SecurityDescriptorSize);

    LocalFree( Unicode.Buffer );

    if ( Result ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( Result );
}



BOOL
APIENTRY
ConvertStringSecurityDescriptorToSecurityDescriptorW(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
/*++

Routine Description:

    This routine converts a stringized Security descriptor into a valid, functional security
    descriptor

    Ex:
    SD:[O:xyz][G:xyz][D: (Ace1)(Ace2)][S: (Ace3)(Ace4)]
          where some Ace is (OA;CIIO; DS_READ; OT: abc; IOT: abc; SID: xyz)

    So a possible Security descriptor may be (as all one long string):

    L"O:AOG:DAD:(A;IO;RPRWXRCWDWO;;;S-1-0-0)(OA;CI;RWX;af110080-1b13-11d0-af10-0020afd3606c;"
    L"a153d9e0-1b13-11d0-af10-0020afd3606c;AUS)(A;SAFA;0x7800003F;;;DA)(OA;FA;X;"
    L"954378e0-1b13-11d0-af10-0020afd3606c;880b12a0-1b13-11d0-af10-0020afd3606c;PO)"

    would build a security descriptor:

    Revision: 0x1
    Sbz1: 0x0
    Control: 0x8014
    Owner: S-1-5-32-548

    Group:S-1-5-32-544

    Dacl: Revision: 4
    AceCount: 2
    InUse: 84
    Free: 52
    Flags: 0
            Ace  0:
                Type: 0
                Flags: 0x1
                Size: 0x14
                Mask: 0xe00e0010
                S-1-0-0

            Ace  1:
                Type: 5
                Flags: 0x2
                Size: 0x38
                Mask: 0xe0000000
                af110080-1b13-11d0-af100020afd3606c
                a153d9e0-1b13-11d0-af100020afd3606c
                S-1-5-11


    sacl: Revision: 4
    AceCount: 2
    InUse: 92
    Free: 44
    Flags: 0
            Ace  0:
                Type: 2
                Flags: 0xc0
                Size: 0x18
                Mask: 0xe0000000
                S-1-5-32-544

            Ace  1:
                Type: 7
                Flags: 0x80
                Size: 0x3c
                Mask: 0x20000000
                954378e0-1b13-11d0-af100020afd3606c
                880b12a0-1b13-11d0-af100020afd3606c
                S-1-5-32-550
Arguments:

    StringSecurityDescriptor - Stringized security descriptor to be converted.

    StringSDRevision - String revision of the input string SD

    SecurityDescriptor - Where the converted SD is returned.  Buffer is allocated via
        LocalAlloc and should be free via LocalFree.  The returned security descriptor
        is always self relative

    SecurityDescriptorSize - OPTIONAL.  If non-NULL, the size of the converted security
        descriptor is returned here.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL input or output parameter was given

        ERROR_UNKNOWN_REVISION - An unsupported revision was given

--*/
{
    DWORD Err = ERROR_SUCCESS;

    //
    // Little elementary parameter checking...
    //
    if ( StringSecurityDescriptor == NULL || SecurityDescriptor == NULL ) {

        Err = ERROR_INVALID_PARAMETER;

    } else {

        switch ( StringSDRevision ) {
        case SDDL_REVISION_1:

            Err = LocalConvertStringSDToSD_Rev1( NULL,  // no root domain sid is provided
                                                 NULL,  // no domain sid is provided for this API
                                                 FALSE, //TRUE, do not default to domain for EA/SA
                                                 StringSecurityDescriptor,
                                                 SecurityDescriptor,
                                                 SecurityDescriptorSize);
            break;

        default:

            Err = ERROR_UNKNOWN_REVISION;
            break;
        }

    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}


BOOL
APIENTRY
ConvertSecurityDescriptorToStringSecurityDescriptorA(
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPSTR  *StringSecurityDescriptor,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    )
/*++

Routine Description:

    ANSI thunk to ConvertSecurityDescriptorToStringSecurityDescriptorW

--*/
{
    LPWSTR StringSecurityDescriptorW = NULL;
    ULONG AnsiLen, WideLen = 0;
    BOOL ReturnValue ;

    if ( StringSecurityDescriptor == NULL ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    ReturnValue = ConvertSecurityDescriptorToStringSecurityDescriptorW(
                      SecurityDescriptor,
                      RequestedStringSDRevision,
                      SecurityInformation,
                      &StringSecurityDescriptorW,
                      &WideLen );

    if ( ReturnValue ) {


        //  jinhuang: WindeLen is returned from previous call
        //        WideLen = wcslen( StringSecurityDescriptorW ) + 1;


        AnsiLen = WideCharToMultiByte( CP_ACP,
                                       0,
                                       StringSecurityDescriptorW,
                                       WideLen + 1,
                                       *StringSecurityDescriptor,
                                       0,
                                       NULL,
                                       NULL );

        if ( AnsiLen != 0 ) {

            *StringSecurityDescriptor = LocalAlloc( LMEM_FIXED, AnsiLen );

            if ( *StringSecurityDescriptor == NULL ) {

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                ReturnValue = FALSE;

            } else {

                AnsiLen = WideCharToMultiByte( CP_ACP,
                                               0,
                                               StringSecurityDescriptorW,
                                               WideLen + 1,
                                               *StringSecurityDescriptor,
                                               AnsiLen,
                                               NULL,
                                               NULL );
                ASSERT( AnsiLen != 0 );

                if ( AnsiLen == 0 ) {

                    LocalFree(*StringSecurityDescriptor);
                    *StringSecurityDescriptor = NULL;

                    ReturnValue = FALSE;
                }

                //
                // jinhuang
                // output the length (optional)
                //
                if ( StringSecurityDescriptorLen ) {
                    *StringSecurityDescriptorLen = AnsiLen;
                }

            }

        } else {

            ReturnValue = FALSE;
        }

        //
        // jinhuang
        // StringSecurityDescriptorW should be freed
        //

        LocalFree(StringSecurityDescriptorW);

    }

    if ( ReturnValue ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( ReturnValue );
}


BOOL
APIENTRY
ConvertSecurityDescriptorToStringSecurityDescriptorW(
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPWSTR  *StringSecurityDescriptor,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    )
/*++

Routine Description:

    This routine converts a security descriptor into a string version persuant to SDDL definition

Arguments:

    SecurityDescriptor - Security Descriptor to be converted.

    RequestedStringSDRevision - Requested revision of the output string security descriptor

    SecurityInformation - security information of which to be converted

    StringSecurityDescriptor - Where the converted SD is returned.  Buffer is allocated via
        LocalAlloc and should be free via LocalFree.

    StringSecurityDescriptorLen - the optional length of the converted SD

Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL input or output parameter was given

        ERROR_UNKNOWN_REVISION - An unsupported revision was given

--*/
{
    DWORD Err = ERROR_SUCCESS;

    //
    // A little parameter checking...
    //

    if  ( (SecurityDescriptor == NULL || SecurityInformation == 0) && 
          StringSecurityDescriptor ) {
        
        *StringSecurityDescriptor = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof( WCHAR ) );

        if (*StringSecurityDescriptor) {
            
            (*StringSecurityDescriptor)[0] = L'\0';

            if (StringSecurityDescriptorLen) {

                *StringSecurityDescriptorLen = 0;
            
            }

        }

        else {
            
            Err = ERROR_NOT_ENOUGH_MEMORY;

        }

        SetLastError( Err );

        return( Err == ERROR_SUCCESS );

    }
    
    if ( SecurityDescriptor == NULL || StringSecurityDescriptor == NULL ||
         SecurityInformation == 0 ) {

        Err =  ERROR_INVALID_PARAMETER;

    } else {

        switch ( RequestedStringSDRevision ) {
        case SDDL_REVISION_1:

            Err = LocalConvertSDToStringSD_Rev1( NULL,  // root domain sid is not privided
                                                 SecurityDescriptor,
                                                 SecurityInformation,
                                                 StringSecurityDescriptor,
                                                 StringSecurityDescriptorLen );
            break;

        default:
            Err = ERROR_UNKNOWN_REVISION;
            break;
        }

    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS);
}



//
// Private functions
//
BOOL
LocalConvertStringSidToSid (
    IN  PWSTR       StringSid,
    OUT PSID       *Sid,
    OUT PWSTR      *End
    )
/*++

Routine Description:

    This routine will convert a string representation of a SID back into
    a sid.  The expected format of the string is:
                "S-1-5-32-549"
    If a string in a different format or an incorrect or incomplete string
    is given, the operation is failed.

    The returned sid must be free via a call to LocalFree


Arguments:

    StringSid - The string to be converted

    Sid - Where the created SID is to be returned

    End - Where in the string we stopped processing


Return Value:

    TRUE - Success.

    FALSE - Failure.  Additional information returned from GetLastError().  Errors set are:

            ERROR_SUCCESS indicates success

            ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput sid
                                    failed
            ERROR_INVALID_SID indicates that the given string did not represent a sid

--*/
{
    DWORD Err = ERROR_SUCCESS;
    UCHAR Revision, Subs;
    SID_IDENTIFIER_AUTHORITY IDAuth;
    PULONG SubAuth = NULL;
    PWSTR CurrEnd, Curr, Next;
    WCHAR Stub, *StubPtr = NULL;
    ULONG Index;
    INT gBase=10;
    INT lBase=10;
    ULONG Auto;

    if ( NULL == StringSid || NULL == Sid || NULL == End ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );

    }

//    if ( wcslen( StringSid ) < 2 || ( *StringSid != L'S' && *( StringSid + 1 ) != L'-' ) ) {

    //
    // no need to check length because StringSid is NULL
    // and if the first char is NULL, it won't access the second char
    //
    if ( (*StringSid != L'S' && *StringSid != L's') ||
         *( StringSid + 1 ) != L'-' ) {
        //
        // string sid should always start with S-
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }


    Curr = StringSid + 2;

    if ( (*Curr == L'0') &&
         ( *(Curr+1) == L'x' ||
           *(Curr+1) == L'X' ) ) {

        gBase = 16;
    }

    Revision = ( UCHAR )wcstol( Curr, &CurrEnd, gBase );

    if ( CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
        //
        // no revision is provided, or invalid delimeter
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }

    Curr = CurrEnd + 1;

    //
    // Count the number of characters in the indentifer authority...
    //
    Next = wcschr( Curr, L'-' );
/*
    Length = 6 doesn't mean each digit is a id authority value, could be 0x...

    if ( Next != NULL && (Next - Curr == 6) ) {

        for ( Index = 0; Index < 6; Index++ ) {

//            IDAuth.Value[Index] = (UCHAR)Next[Index];  what is this ???
            IDAuth.Value[Index] = (BYTE) (Curr[Index]-L'0');
        }

        Curr +=6;

    } else {
*/
        if ( (*Curr == L'0') &&
             ( *(Curr+1) == L'x' ||
               *(Curr+1) == L'X' ) ) {

            lBase = 16;
        } else {
            lBase = gBase;
        }

        Auto = wcstoul( Curr, &CurrEnd, lBase );

         if ( CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
             //
             // no revision is provided, or invalid delimeter
             //
             SetLastError( ERROR_INVALID_SID );
             return( FALSE );
         }

         IDAuth.Value[0] = IDAuth.Value[1] = 0;
         IDAuth.Value[5] = ( UCHAR )Auto & 0xFF;
         IDAuth.Value[4] = ( UCHAR )(( Auto >> 8 ) & 0xFF );
         IDAuth.Value[3] = ( UCHAR )(( Auto >> 16 ) & 0xFF );
         IDAuth.Value[2] = ( UCHAR )(( Auto >> 24 ) & 0xFF );
         Curr = CurrEnd;
//    }

    //
    // Now, count the number of sub auths, at least one sub auth is required
    //
    Subs = 0;
    Next = Curr;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //

    while ( Next ) {

        if ( *Next == L'-' && *(Next-1) != L'-') {

            //
            // do not allow two continuous '-'s
            // We've found one!
            //
            Subs++;

            if ( (*(Next+1) == L'0') &&
                 ( *(Next+2) == L'x' ||
                   *(Next+2) == L'X' ) ) {
                //
                // this is hex indicator
                //
                Next += 2;

            }

        } else if ( *Next == SDDL_SEPERATORC || *Next  == L'\0' ||
                    *Next == SDDL_ACE_ENDC || *Next == L' ' ||
                    ( *(Next+1) == SDDL_DELIMINATORC &&
                      (*Next == L'G' || *Next == L'O' || *Next == L'S')) ) {
            //
            // space is a terminator too
            //
            if ( *( Next - 1 ) == L'-' ) {
                //
                // shouldn't allow a SID terminated with '-'
                //
                Err = ERROR_INVALID_SID;
                Next--;

            } else {
                Subs++;
            }

            *End = Next;
            break;

        } else if ( !iswxdigit( *Next ) ) {

            Err = ERROR_INVALID_SID;
            *End = Next;
//            Subs++;
            break;

        } else {

            //
            // Note: SID is also used as a owner or group
            //
            // Some of the tags (namely 'D' for Dacl) fall under the category of iswxdigit, so
            // if the current character is a character we care about and the next one is a
            // delminiator, we'll quit
            //
            if ( *Next == L'D' && *( Next + 1 ) == SDDL_DELIMINATORC ) {

                //
                // We'll also need to temporarily truncate the string to this length so
                // we don't accidentally include the character in one of the conversions
                //
                Stub = *Next;
                StubPtr = Next;
                *StubPtr = UNICODE_NULL;
                *End = Next;
                Subs++;
                break;
            }

        }

        Next++;

    }

    if ( Err == ERROR_SUCCESS ) {

        if ( Subs != 0 ) Subs--;

        if ( Subs != 0 ) {

            Curr++;

            SubAuth = ( PULONG )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Subs * sizeof( ULONG ) );

            if ( SubAuth == NULL ) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                for ( Index = 0; Index < Subs; Index++ ) {

                    if ( (*Curr == L'0') &&
                         ( *(Curr+1) == L'x' ||
                           *(Curr+1) == L'X' ) ) {

                        lBase = 16;
                    } else {
                        lBase = gBase;
                    }

                    SubAuth[Index] = wcstoul( Curr, &CurrEnd, lBase );
                    Curr = CurrEnd + 1;
                }
            }

        } else {

            Err = ERROR_INVALID_SID;
        }
    }

    //
    // Now, create the SID
    //
    if ( Err == ERROR_SUCCESS ) {

        *Sid = ( PSID )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                   sizeof( SID ) + Subs * sizeof( ULONG ) );

        if ( *Sid == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            PISID ISid = ( PISID )*Sid;
            ISid->Revision = Revision;
            ISid->SubAuthorityCount = Subs;
            RtlCopyMemory( &( ISid->IdentifierAuthority ), &IDAuth,
                           sizeof( SID_IDENTIFIER_AUTHORITY ) );
            RtlCopyMemory( ISid->SubAuthority, SubAuth, Subs * sizeof( ULONG ) );
        }
    }

    LocalFree( SubAuth );

    //
    // Restore any character we may have stubbed out
    //
    if ( StubPtr ) {

        *StubPtr = Stub;
    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}


PSTRSD_SID_LOOKUP
LookupSidInTable(
    IN PWSTR String OPTIONAL,
    IN PSID Sid OPTIONAL,
    IN PSID RootDomainSid OPTIONAL,
    IN PSID DomainSid OPTIONAL,
    IN PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN BOOLEAN DefaultToDomain,
    IN PVOID *pSASid
    )
/*++

Routine Description:

    This routine will determine if the given sid or string sid exists in the lookup table.

    A pointer to the matching static lookup entry is returned.


Arguments:

    String - The string to be looked up

    Sid - The sid to be looked up.

Return Value:

    Lookup table entry if found

    NULL if not found

--*/
{
    BOOLEAN LookupSid = FALSE;
    DWORD i, SidCount = sizeof( SidLookup ) / sizeof( STRSD_SID_LOOKUP );
    PSTRSD_SID_LOOKUP MatchedEntry = NULL;
    DWORD DomainAdminIndex;

    BOOL  InitRootDomain;
    ULONG Rid;
    BOOL bIsSA = FALSE;


    if ( String == NULL && Sid == NULL ) {
        //
        // JINHUANG: if both string and sid are NULL
        // just return NULL
        //
        return((PSTRSD_SID_LOOKUP)NULL);
    }

    *pSASid = NULL;

    InitRootDomain = FALSE;
    DomainAdminIndex = SidCount;

    if ( String == NULL ) {
        //
        // lookup on the Sid
        //
        LookupSid = TRUE;

        //
        // check if the RID is for Enterprise Admins
        //
        Rid = *( RtlSubAuthoritySid( Sid,
                                     *( RtlSubAuthorityCountSid(Sid) ) - 1 ) );

        if ( DOMAIN_GROUP_RID_ENTERPRISE_ADMINS == Rid ||
             DOMAIN_GROUP_RID_SCHEMA_ADMINS == Rid ) {

            InitRootDomain = TRUE;
            if ( DOMAIN_GROUP_RID_SCHEMA_ADMINS == Rid ) {
                bIsSA = TRUE;
            }
        }

    } else {

        if ( _wcsnicmp( String, SDDL_ENTERPRISE_ADMINS, SDDL_LEN_TAG( SDDL_ENTERPRISE_ADMINS ) ) == 0 ) {
            //
            // Enterprise admins string is requested
            //
            InitRootDomain = TRUE;
        } else if ( _wcsnicmp( String, SDDL_SCHEMA_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_SCHEMA_ADMINISTRATORS ) ) == 0 ) {
            //
            // schema admin is requested
            //
            InitRootDomain = TRUE;
            bIsSA = TRUE;
        }
    }

    //
    // the new API is the caller iff DomainSid != NULL
    // on demand, initialize domain relative dynamic table for new API ()
    //

    if ( DomainSid ) {

        //
        // in this search, we will deal with the per thread table and not the global table
        // in actuality, this per thread table is a proper subset of the global table
        //

        for ( i = 0; i < sizeof(SidLookupDomOrRootDomRelative)/sizeof(STRSD_SID_LOOKUP); i++ ) {

            //
            // for performance, only compute SID etc. if names match.
            // in case the table is sparse, this heuristic comes in handy
            // this doesn't preclude future lookup calls from leveraging useful work done here
            //

            if ( _wcsnicmp( String,
                            tSidLookupDomOrRootDomRelativeTable[ i ].Key,
                            tSidLookupDomOrRootDomRelativeTable[ i ].KeyLen ) == 0 ) {


                if (tSidLookupDomOrRootDomRelativeTable[ i ].Valid == FALSE ||
                    tSidLookupDomOrRootDomRelativeTable[ i ].Sid == NULL) {

                    PSID RootDomainSidOrDomainSid = NULL;

                    if ( tSidLookupDomOrRootDomRelativeTable[ i ].SidType == ST_DOMAIN_RELATIVE )
                        RootDomainSidOrDomainSid = DomainSid;
                    else if ( tSidLookupDomOrRootDomRelativeTable[ i ].SidType == ST_ROOT_DOMAIN_RELATIVE &&
                              RootDomainSid )
                        RootDomainSidOrDomainSid = RootDomainSid;
                    else {
                        
                        //
                        // this will happen when the RootDomainSid is not provided when using the 
                        // new API and so ST_ROOT_DOMAIN_RELATIVE type SIDs will get resolved wrt
                        // the local m/c's root domain - so we will allow the lookup to continue
                        // in the normal way
                        //
                        
                        break;
                    }

                    //
                    // do this for legacy-code reasons
                    //

                    tSidLookupDomOrRootDomRelativeTable[ i ].Sid =
                        ( PSID )tSidLookupDomOrRootDomRelativeTable[ i ].SidBuff;


                    RtlCopyMemory( tSidLookupDomOrRootDomRelativeTable[ i ].Sid, RootDomainSidOrDomainSid,
                                   RtlLengthSid( RootDomainSidOrDomainSid ) );
                    ( ( PISID )( tSidLookupDomOrRootDomRelativeTable[ i ].Sid ) )->SubAuthorityCount++;
                    *( RtlSubAuthoritySid( tSidLookupDomOrRootDomRelativeTable[ i ].Sid,
                                           *( RtlSubAuthorityCountSid( RootDomainSidOrDomainSid ) ) ) ) =
                        tSidLookupDomOrRootDomRelativeTable[ i ].Rid;

                    tSidLookupDomOrRootDomRelativeTable[ i ].Valid = TRUE;

                }

                if (tSidLookupDomOrRootDomRelativeTable[ i ].Valid == TRUE)
                    MatchedEntry = &tSidLookupDomOrRootDomRelativeTable[ i ];

                //
                // if we get here, we have to return MatchedEntry since we know that:
                //
                //      (a) the new API is the caller (DomainSid != NULL) and
                //      (b) we are dealing with ST_DOMAIN_RELATIVE or 
                //          ST_ROOT_DOMAIN_RELATIVE type trustees (with RootDomainSid provided)
                //      (c) there is a match with the trustee name such as "DA" or "EA"
                //

                return (MatchedEntry);

            }

        }

    }

    InitializeSidLookupTable(STRSD_REINITIALIZE_ENTER);

    if ( InitRootDomain &&
         RootDomainSid == NULL &&
         DefaultToDomain == FALSE &&
         ( RootDomInited == FALSE ||
           !RtlValidSid( (PSID)RootDomSidBuf ) ) ) {

        //
        // get the root domain sid (using ldap calls)
        //

        SddlpGetRootDomainSid();

    }



    for ( i = 0; i < SidCount; i++ ) {

        //
        // if new API and domain relative trustee, skip the entry
        // since the global table won't be used in this scenario.
        // matches for such entries are taken care of, in the per-thread table above
        //
        // cannot skip if InitRootDomain == TRUE since SDDL_DOMAIN_ADMINISTRATORS in
        // SidLookup[] is potentially matched against, shortly
        //

        if ( InitRootDomain == FALSE &&
             DomainSid &&
             SidLookup[ i ].SidType == ST_DOMAIN_RELATIVE )
            continue;

        //
        // if this is an entry that has been initialized, skip it
        //

        if ( SidLookup[ i ].Valid == FALSE ||
             SidLookup[ i ].Sid == NULL ) {


            if ( SidLookup[ i ].SidType == ST_ROOT_DOMAIN_RELATIVE &&
                 InitRootDomain ) {

                if ( RootDomainSid != NULL ) {

                    EnterCriticalSection(&SddlSidLookupCritical);

                    RtlCopyMemory( SidLookup[ i ].Sid, RootDomainSid,
                                   RtlLengthSid( RootDomainSid ) );
                    ( ( PISID )( SidLookup[ i ].Sid ) )->SubAuthorityCount++;
                    *( RtlSubAuthoritySid( SidLookup[ i ].Sid,
                                           *( RtlSubAuthorityCountSid( RootDomainSid ) ) ) ) =
                                           SidLookup[ i ].Rid;
                    SidLookup[ i ].Valid = TRUE;

                    LeaveCriticalSection(&SddlSidLookupCritical);

                } else if ( DefaultToDomain ) {
                    //
                    // should default EA to DA and SA to domain relative
                    //
                } else {

                    if ( RootDomInited && RtlValidSid( (PSID)RootDomSidBuf ) &&
                         ( ( SidLookup[ i ].Valid == FALSE ) ||
                           ( SidLookup[ i ].Sid == NULL ) ) ) {

                        EnterCriticalSection(&SddlSidLookupCritical);

                        RtlCopyMemory( SidLookup[ i ].Sid, (PSID)RootDomSidBuf,
                                       RtlLengthSid( (PSID)RootDomSidBuf ) );
                        ( ( PISID )( SidLookup[ i ].Sid ) )->SubAuthorityCount++;
                        *( RtlSubAuthoritySid( SidLookup[ i ].Sid,
                                               *( RtlSubAuthorityCountSid( (PSID)RootDomSidBuf ) ) ) ) =
                                               SidLookup[ i ].Rid;
                        SidLookup[ i ].Valid = TRUE;

                        LeaveCriticalSection(&SddlSidLookupCritical);
                    }

                }

            }


            if ( SidLookup[ i ].Valid == FALSE ||
                 SidLookup[ i ].Sid == NULL ) {
                continue;
            }
        }

        if ( LookupSid ) {

            if ( RtlEqualSid( Sid, SidLookup[ i ].Sid ) ) {

                break;
            }

        } else {

            //
            // check for the current key first
            //
            if ( _wcsnicmp( String, SidLookup[i].Key, SidLookup[i].KeyLen ) == 0 ) {

                break;

            } else if ( InitRootDomain && DefaultToDomain &&
                        (RootDomainSid == NULL) ) {

                //
                // looking for EA/SA, not found them,
                // EA needs to default to DA, SA needs to default to domain relative
                //
                if ( _wcsnicmp( SDDL_DOMAIN_ADMINISTRATORS, SidLookup[i].Key, SidLookup[i].KeyLen ) == 0 ) {
                    DomainAdminIndex = i;
//                    break;
                }

            }
        }
    }


    if ( i < SidCount ) {

        MatchedEntry = &SidLookup[ i ];

    } else if ( InitRootDomain && DefaultToDomain &&
                (RootDomainSid == NULL) &&
                ( DomainAdminIndex < SidCount ) ) {

        if ( bIsSA ) {
            //
            // default to domain relative sid
            //

            if ( LookupSid ) {
                *pSASid = (PVOID)Sid;

            } else if ( SidLookup[ DomainAdminIndex ].Sid ) {
                //
                // allocate buffer for domain relative SA sid
                // which means it's only valid on the root domain
                //

                i = RtlLengthSid( SidLookup[ DomainAdminIndex ].Sid );

                *pSASid = (PVOID)LocalAlloc( LMEM_FIXED, i+1 );

                if ( *pSASid != NULL ) {

                    RtlCopyMemory( (PSID)(*pSASid), SidLookup[ DomainAdminIndex ].Sid, i );

                    // replace the DA rid with SA rid
                    *( RtlSubAuthoritySid( (PSID)(*pSASid),
                                           *( RtlSubAuthorityCountSid( SidLookup[ DomainAdminIndex ].Sid )) - 1) ) =
                                           DOMAIN_GROUP_RID_SCHEMA_ADMINS;
                }
            }

        } else {

            //
            // default to the domain admin account
            //

            MatchedEntry = &SidLookup[ DomainAdminIndex ];
        }
    }

    InitializeSidLookupTable(STRSD_REINITIALIZE_LEAVE);

    return( MatchedEntry );
}


DWORD
LocalGetSidForString(
    IN  PWSTR String,
    OUT PSID *SID,
    OUT PWSTR *End,
    OUT PBOOLEAN FreeSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN  BOOLEAN DefaultToDomain
    )
/*++

Routine Description:

    This routine will determine which sid is an appropriate match for the
    given string, either as a sid moniker or as a string representation of a
    sid (ie: "DA or "S-1-0-0" )

    The returned sid must be free via a call to LocalFree if the *pFreeSid
    output parameter is TRUE.  If it's FALSE, no additional action needs to
    be taken


Arguments:

    String - The string to be converted

    Sid - Where the created SID is to be returned

    End - Where in the string we stopped processing

    FreeSid - Determines whether the returned SID needs to be freed via a
        call to LocalFree or not


Return Value:

    ERROR_SUCCESS - success

    ERROR_NON_MAPPED - An invalid format of the SID was given

--*/
{
    DWORD Err = ERROR_SUCCESS;
    PSTRSD_SID_LOOKUP MatchedEntry;
    PSID pSidSA=NULL;

    if ( String == NULL || SID == NULL || End == NULL || FreeSid == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Assume we'll return a well known sid
    //
    *FreeSid = FALSE;

//    if ( wcslen( String ) < 2 ) {
//  no need to do wcslen (expensive) because we know that String is not NULL
//  so just check for the first and second char
    if ( *String == L'\0' || *( String +1 ) == L'\0' ) {

        return( ERROR_NONE_MAPPED );
    }

    //
    // Set our end of string pointer
    //
    *End = String + 2;

    MatchedEntry = LookupSidInTable( String,
                                     NULL,
                                     RootDomainSid,
                                     DomainSid,
                                     tSidLookupDomOrRootDomRelativeTable,
                                     DefaultToDomain,
                                     (PVOID *)&pSidSA);

    //
    // If we didn't find a match, try it as a sid string
    //
    if ( MatchedEntry == NULL ) {

        if ( pSidSA ) {
            //
            // this is schema admin lookup
            //
            *SID = pSidSA;
            *FreeSid = TRUE;

        } else {

            //
            // We assumed a known moniker, so we'll have to unset our end of string pointer.
            // Also, if it's a not a SID, the Convert routine will return the appropriate error.
            //
            *End -= 2;
            if ( LocalConvertStringSidToSid( String, SID, End) == FALSE ) {

                Err = GetLastError();
            }

            if ( Err == ERROR_SUCCESS && *SID != NULL ) {

                *FreeSid = TRUE;
            }
        }

    } else {

        //
        // If the entry that's been selected hasn't been initialized yet, do it now
        //
        *SID = MatchedEntry->Sid;
    }


    return(Err);
}


DWORD
LocalGetStringForSid(
    IN  PSID Sid,
    OUT PWSTR *String,
    IN  PSID RootDomainSid OPTIONAL
    )
/*++

Routine Description:

    This routine will determine which string represents a sid, either as a sid moniker or
    as a string representation of a sid (ie: "DA or "S-1-0-0" )

    The returned string must be free via a call to LocalFree


Arguments:

    Sid - Sid to be converted

    String - Where the mapped Sid is to be returned

Return Value:

    ERROR_SUCCESS - success

    ERROR_NON_MAPPED - An invalid format of the SID was given

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Err = ERROR_SUCCESS;
    PSTRSD_SID_LOOKUP MatchedEntry;
    PSID pSidSA=NULL;
    DWORD Len;

    if ( Sid == NULL || String == NULL ) {

        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Try to find a match in the lookup table
    //
    MatchedEntry = LookupSidInTable( NULL,
                                     Sid,
                                     RootDomainSid,
                                     NULL,
                                     NULL,
                                     FALSE,
                                     (PVOID *)&pSidSA );

    //
    // If a match was found, return it
    //
    if ( MatchedEntry || pSidSA ) {

        if ( MatchedEntry ) {
            Len = MatchedEntry->KeyLen;
        } else {
            Len = wcslen(SDDL_SCHEMA_ADMINISTRATORS);
        }

        *String = LocalAlloc( LMEM_FIXED, ( Len * sizeof( WCHAR ) ) + sizeof( WCHAR ) );
        if ( *String == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            if ( MatchedEntry ) {
                wcscpy( *String, MatchedEntry->Key );
            } else {
                wcscpy( *String, SDDL_SCHEMA_ADMINISTRATORS);
            }
        }

    } else {

        if ( ConvertSidToStringSidW( Sid, String ) == FALSE ) {

            Err = GetLastError();
        }

    }

    return(Err);
}

DWORD
LocalGetStringForControl(
    IN SECURITY_DESCRIPTOR_CONTROL ControlCode,
    IN ULONG LookupFlags,
    OUT PWSTR *ControlString
    )
{
    DWORD   i, ControlCount = sizeof( ControlLookup ) / sizeof( STRSD_KEY_LOOKUP );
    WCHAR Buffer[256];
    DWORD nOffset=0;


    if ( !ControlString ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *ControlString = NULL;

    for ( i = 0; i < ControlCount; i++ ) {

        //
        // If it doesn't match our lookup type, skip it.
        //
        if ( ( LookupFlags & ControlLookup[ i ].ValidityFlags ) != LookupFlags ) {

            continue;
        }

        if ( ControlCode & ControlLookup[ i ].Value ) {

            wcsncpy(Buffer+nOffset,
                    ControlLookup[ i ].Key,
                    ControlLookup[ i ].KeyLen );

            nOffset += ControlLookup[ i ].KeyLen;

        }
    }

    Buffer[nOffset] = L'\0';

    if ( nOffset ) {
        *ControlString = (PWSTR)LocalAlloc(0, (nOffset+1)*sizeof(WCHAR));

        if ( *ControlString ) {

            wcscpy(*ControlString, Buffer);

        } else {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return( ERROR_SUCCESS );
}


PSTRSD_KEY_LOOKUP
LookupAccessMaskInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AccessMask, OPTIONAL
    IN ULONG LookupFlags
    )
/*++

Routine Description:

    This routine will determine if the given access mask or string right exists in the lookup
    table.

    A pointer to the matching static lookup entry is returned.


Arguments:

    String - The string to be looked up

    AccessMask - The accessMask to be looked up.

    LookupFlags - Flags to use for lookup (Dacl or Sacl)

Return Value:

    Lookup table entry if found

    NULL if not found

--*/
{
    //
    // This is how the access mask is looked up.  Always have the multi-char
    // rights before the single char ones
    //
    static STRSD_KEY_LOOKUP  RightsLookup[] = {
        { SDDL_READ_PROPERTY, SDDL_LEN_TAG( SDDL_READ_PROPERTY ), ACTRL_DS_READ_PROP, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_WRITE_PROPERTY, SDDL_LEN_TAG( SDDL_WRITE_PROPERTY ), ACTRL_DS_WRITE_PROP, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_CREATE_CHILD, SDDL_LEN_TAG( SDDL_CREATE_CHILD ), ACTRL_DS_CREATE_CHILD, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_DELETE_CHILD, SDDL_LEN_TAG( SDDL_DELETE_CHILD ), ACTRL_DS_DELETE_CHILD, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_LIST_CHILDREN, SDDL_LEN_TAG( SDDL_LIST_CHILDREN ), ACTRL_DS_LIST, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_SELF_WRITE, SDDL_LEN_TAG( SDDL_SELF_WRITE ), ACTRL_DS_SELF, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_LIST_OBJECT, SDDL_LEN_TAG( SDDL_LIST_OBJECT ), ACTRL_DS_LIST_OBJECT, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_DELETE_TREE, SDDL_LEN_TAG( SDDL_DELETE_TREE ), ACTRL_DS_DELETE_TREE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_CONTROL_ACCESS, SDDL_LEN_TAG( SDDL_CONTROL_ACCESS ), ACTRL_DS_CONTROL_ACCESS, SDDL_VALID_DACL | SDDL_VALID_SACL },

        { SDDL_READ_CONTROL, SDDL_LEN_TAG( SDDL_READ_CONTROL ), READ_CONTROL, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_WRITE_DAC, SDDL_LEN_TAG( SDDL_WRITE_DAC ), WRITE_DAC, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_WRITE_OWNER, SDDL_LEN_TAG( SDDL_WRITE_OWNER ), WRITE_OWNER, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_STANDARD_DELETE, SDDL_LEN_TAG( SDDL_STANDARD_DELETE ), DELETE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_GENERIC_ALL, SDDL_LEN_TAG( SDDL_GENERIC_ALL ), GENERIC_ALL, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_GENERIC_READ, SDDL_LEN_TAG( SDDL_GENERIC_READ ), GENERIC_READ, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_GENERIC_WRITE, SDDL_LEN_TAG( SDDL_GENERIC_WRITE ), GENERIC_WRITE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_GENERIC_EXECUTE, SDDL_LEN_TAG( SDDL_GENERIC_EXECUTE ), GENERIC_EXECUTE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_FILE_ALL, SDDL_LEN_TAG( SDDL_FILE_ALL ), FILE_ALL_ACCESS, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_FILE_READ, SDDL_LEN_TAG( SDDL_FILE_READ ), FILE_GENERIC_READ, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_FILE_WRITE, SDDL_LEN_TAG( SDDL_FILE_WRITE ), FILE_GENERIC_WRITE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_FILE_EXECUTE, SDDL_LEN_TAG( SDDL_FILE_EXECUTE ), FILE_GENERIC_EXECUTE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_KEY_ALL, SDDL_LEN_TAG( SDDL_KEY_ALL ), KEY_ALL_ACCESS, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_KEY_READ, SDDL_LEN_TAG( SDDL_KEY_READ ), KEY_READ, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_KEY_WRITE, SDDL_LEN_TAG( SDDL_KEY_WRITE ), KEY_WRITE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_KEY_EXECUTE, SDDL_LEN_TAG( SDDL_KEY_EXECUTE ), KEY_EXECUTE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        };
    DWORD   i, RightsCount = sizeof(RightsLookup) / sizeof(STRSD_KEY_LOOKUP);
    PSTRSD_KEY_LOOKUP MatchedEntry = NULL;
    BOOLEAN LookupString = FALSE;

    if ( String ) {

        LookupString = TRUE;
    }

    for ( i = 0; i < RightsCount; i++ ) {

        //
        // If it doesn't match our lookup type, skip it.
        //
        if ( ( LookupFlags & RightsLookup[ i ].ValidityFlags ) != LookupFlags ) {

            continue;
        }

        if ( LookupString ) {

            if ( _wcsnicmp( String, RightsLookup[ i ].Key, RightsLookup[ i ].KeyLen ) == 0 ) {

                break;
            }

        } else {

            if ( AccessMask == RightsLookup[ i ].Value ) {

                break;
            }

        }

    }

    //
    // If a match was found, return it
    //
    if ( i < RightsCount ) {

        MatchedEntry = &RightsLookup[ i ];
    }


    return( MatchedEntry );

}


PSTRSD_KEY_LOOKUP
LookupAceTypeInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AceType, OPTIONAL
    IN ULONG LookupFlags
    )
/*++

Routine Description:

    This routine will determine if the given ace type or string type exists in the lookup
    table.

    A pointer to the matching static lookup entry is returned.


Arguments:

    String - The string to be looked up

    AceType - The ace type to be looked up.

    LookupFlags - Flags to use for lookup (Dacl or Sacl)

Return Value:

    Lookup table entry if found

    NULL if not found

--*/
{
    //
    // Lookup table
    //
    static STRSD_KEY_LOOKUP TypeLookup[] = {
        { SDDL_ACCESS_ALLOWED, SDDL_LEN_TAG( SDDL_ACCESS_ALLOWED ), ACCESS_ALLOWED_ACE_TYPE, SDDL_VALID_DACL },
        { SDDL_ACCESS_DENIED, SDDL_LEN_TAG( SDDL_ACCESS_DENIED ), ACCESS_DENIED_ACE_TYPE, SDDL_VALID_DACL },
        { SDDL_OBJECT_ACCESS_ALLOWED, SDDL_LEN_TAG( SDDL_OBJECT_ACCESS_ALLOWED ),
                                                                ACCESS_ALLOWED_OBJECT_ACE_TYPE, SDDL_VALID_DACL },
        { SDDL_OBJECT_ACCESS_DENIED, SDDL_LEN_TAG( SDDL_OBJECT_ACCESS_DENIED ),
                                                                ACCESS_DENIED_OBJECT_ACE_TYPE, SDDL_VALID_DACL },
        { SDDL_AUDIT, SDDL_LEN_TAG( SDDL_AUDIT ), SYSTEM_AUDIT_ACE_TYPE, SDDL_VALID_SACL },
        { SDDL_ALARM, SDDL_LEN_TAG( SDDL_ALARM ), SYSTEM_ALARM_ACE_TYPE, SDDL_VALID_SACL },
        { SDDL_OBJECT_AUDIT, SDDL_LEN_TAG( SDDL_OBJECT_AUDIT ), SYSTEM_AUDIT_OBJECT_ACE_TYPE, SDDL_VALID_SACL },
        { SDDL_OBJECT_ALARM, SDDL_LEN_TAG( SDDL_OBJECT_ALARM ), SYSTEM_ALARM_OBJECT_ACE_TYPE, SDDL_VALID_SACL }
        };
    DWORD   i, TypeCount = sizeof( TypeLookup ) / sizeof( STRSD_KEY_LOOKUP );
    PSTRSD_KEY_LOOKUP MatchedEntry = NULL;
    BOOLEAN LookupString = FALSE;

    if ( String ) {

        LookupString = TRUE;
    }

    for ( i = 0; i < TypeCount; i++ ) {

        //
        // If it doesn't match our lookup type, skip it.
        //
        if ( ( LookupFlags & TypeLookup[ i ].ValidityFlags ) != LookupFlags ) {

            continue;
        }

        if ( LookupString ) {

            if ( _wcsnicmp( String, TypeLookup[ i ].Key, TypeLookup[ i ].KeyLen ) == 0 ) {

                break;
            }

        } else {

            if ( AceType == TypeLookup[ i ].Value ) {

                break;
            }

        }

    }

    //
    // If a match was found, return it
    //
    if ( i < TypeCount ) {

        MatchedEntry = &TypeLookup[ i ];
    }


    return( MatchedEntry );
}



PSTRSD_KEY_LOOKUP
LookupAceFlagsInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AceFlags, OPTIONAL
    IN ULONG LookupFlags
    )
/*++

Routine Description:

    This routine will determine if the given ace flags or string flags exists in the lookup
    table.

    A pointer to the matching static lookup entry is returned.


Arguments:

    String - The string to be looked up

    AceFlags - The ace flags to be looked up.

    LookupFlags - Flags to use for lookup (Dacl or Sacl)

Return Value:

    Lookup table entry if found

    NULL if not found

--*/
{
    //
    // Lookup tables
    //
    static STRSD_KEY_LOOKUP  FlagLookup[] = {
        { SDDL_CONTAINER_INHERIT, SDDL_LEN_TAG( SDDL_CONTAINER_INHERIT ), CONTAINER_INHERIT_ACE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_OBJECT_INHERIT, SDDL_LEN_TAG( SDDL_OBJECT_INHERIT ), OBJECT_INHERIT_ACE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_NO_PROPAGATE, SDDL_LEN_TAG( SDDL_NO_PROPAGATE  ), NO_PROPAGATE_INHERIT_ACE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_INHERIT_ONLY, SDDL_LEN_TAG( SDDL_INHERIT_ONLY  ), INHERIT_ONLY_ACE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_INHERITED, SDDL_LEN_TAG( SDDL_INHERITED  ), INHERITED_ACE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_AUDIT_SUCCESS, SDDL_LEN_TAG( SDDL_AUDIT_SUCCESS ), SUCCESSFUL_ACCESS_ACE_FLAG, SDDL_VALID_SACL },
        { SDDL_AUDIT_FAILURE, SDDL_LEN_TAG( SDDL_AUDIT_FAILURE ), FAILED_ACCESS_ACE_FLAG, SDDL_VALID_SACL }
        };
    DWORD   i, FlagCount = sizeof( FlagLookup ) / sizeof( STRSD_KEY_LOOKUP );
    PSTRSD_KEY_LOOKUP MatchedEntry = NULL;
    BOOLEAN LookupString = FALSE;

    if ( String ) {

        LookupString = TRUE;
    }


    for ( i = 0; i < FlagCount; i++ ) {

        //
        // If it doesn't match our lookup type, skip it.
        //
        if ( ( LookupFlags & FlagLookup[ i ].ValidityFlags ) != LookupFlags ) {

            continue;
        }

        if ( LookupString ) {

            if ( _wcsnicmp( String, FlagLookup[ i ].Key, FlagLookup[ i ].KeyLen ) == 0 ) {

                break;
            }

        } else {

            if ( AceFlags == FlagLookup[ i ].Value ) {

                break;
            }

        }

    }

    //
    // If a match was found, return it
    //
    if ( i < FlagCount ) {

        MatchedEntry = &FlagLookup[ i ];
    }


    return( MatchedEntry );
}


DWORD
LocalGetSDControlForString (
    IN  PWSTR ControlString,
    IN ULONG LookupFlags,
    OUT SECURITY_DESCRIPTOR_CONTROL *pControl,
    OUT PWSTR *End
    )
{

    DWORD   i, ControlCount = sizeof( ControlLookup ) / sizeof( STRSD_KEY_LOOKUP );
    PWSTR pCursor=ControlString;
    BOOL bFound;

    if ( !ControlString || !pControl || !End ) {

        return(ERROR_INVALID_PARAMETER);
    }

    *pControl = 0;

    while ( pCursor && *pCursor == L' ' ) {
        //
        // skip any blanks
        //
        pCursor++;
    }


    do {

        bFound = FALSE;

        for ( i = 0; i < ControlCount; i++ ) {

            //
            // If it doesn't match our lookup type, skip it.
            //
            if ( ( LookupFlags & ControlLookup[ i ].ValidityFlags ) != LookupFlags ) {

                continue;
            }

            if ( _wcsnicmp( pCursor,
                            ControlLookup[ i ].Key,
                            ControlLookup[ i ].KeyLen ) == 0 ) {

                *pControl |= ControlLookup[ i ].Value;

                pCursor += ControlLookup[ i ].KeyLen;

                while ( pCursor && *pCursor == L' ' ) {
                    //
                    // skip any blanks
                    //
                    pCursor++;
                }

                bFound = TRUE;

                break;  // break the for loop
            }
        }

    } while ( bFound );


    *End = pCursor;


    return( ERROR_SUCCESS );

}

DWORD
LocalGetAclForString(
    IN  PWSTR       AclString,
    IN  BOOLEAN     ConvertAsDacl,
    OUT PACL       *Acl,
    OUT PWSTR      *End,
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN  BOOLEAN DefaultToDomain
    )
/*++

Routine Description:

    This routine convert a string into an ACL.  The format of the aces is:

    Ace := ( Type; Flags; Rights; ObjGuid; IObjGuid; Sid;
    Type : = A | D | OA | OD        {Access, Deny, ObjectAccess, ObjectDeny}
    Flags := Flags Flag
    Flag : = CI | IO | NP | SA | FA {Container Inherit,Inherit Only, NoProp,
                                     SuccessAudit, FailAdit }
    Rights := Rights Right
    Right := DS_READ_PROPERTY |  blah blah
    Guid := String representation of a GUID (via RPC UuidToString)
    Sid := DA | PS | AO | PO | AU | S-* (Domain Admins, PersonalSelf, Acct Ops,
                                         PrinterOps, AuthenticatedUsers, or
                                         the string representation of a sid)
    The seperator is a ';'.

    The returned ACL must be free via a call to LocalFree


Arguments:

    AclString - The string to be converted

    ConvertAsDacl - Treat the input string as a dacl string

    ppSid - Where the created SID is to be returned

    End - Where in the string we stopped processing


Return Value:

    ERROR_SUCCESS indicates success
    ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput acl
                            failed
    ERROR_INVALID_PARAMETER The string does not represent an ACL


--*/
{
    DWORD Err = ERROR_SUCCESS;
    DWORD AclSize = 0, AclUsed = 0;
    ULONG Acls = 0, i, j;
    PWSTR Curr, MaskEnd;
    WCHAR ConvertGuidString[ STRING_GUID_LEN + 1];
    BOOLEAN FreeSid = FALSE;
    BOOL OpRes;
    PSTRSD_KEY_LOOKUP MatchedEntry;
    ULONG LookupFlags;
    PSID  SidPtr = NULL;


    if ( NULL == AclString || NULL == Acl || NULL == End ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( ConvertAsDacl ) {

        LookupFlags = SDDL_VALID_DACL;

    } else {

        LookupFlags = SDDL_VALID_SACL;
    }

    //
    // First, we'll have to go through and count the number of entries that
    // we have.  We'll do the by computing the length of this ACL (which is
    // delimited by either the end of the list or a ':' that seperates a key
    // from a value
    //
    *End = wcschr( AclString, SDDL_DELIMINATORC );

    if ( *End == AclString ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( *End == NULL ) {

        *End = AclString + wcslen( AclString );

    } else {

        ( *End )--;
    }

    //
    // Now, do the count
    //
    Curr = AclString;

    OpRes = 0;
//    while ( Curr != *End ) {
    while ( Curr < *End ) {

        if ( *Curr == SDDL_SEPERATORC ) {

            Acls++;

        } else if ( *Curr != L' ' ) {
            OpRes = 1;
        }

        Curr++;
    }

    //
    // Now, we've counted the total number of seperators.  Make sure we
    // have the right number.  (There is 5 seperators per ace)
    //
    if ( Acls % 5 == 0 ) {

        if ( Acls == 0 && OpRes ) {
            //
            // gabbage chars in between
            //
            Err = ERROR_INVALID_PARAMETER;

        } else {
            Acls = Acls / 5;
        }

    } else {

        Err = ERROR_INVALID_PARAMETER;
    }

    if (  Err == ERROR_SUCCESS && Acls == 0 ) {

        *Acl = LocalAlloc( LMEM_FIXED, sizeof( ACL ) );

        if ( *Acl == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            ( *Acl )->AclRevision = ACL_REVISION;
            ( *Acl )->Sbz1 = ( BYTE )0;
            ( *Acl )->AclSize = ( USHORT )sizeof( ACL ) ;
            ( *Acl )->AceCount = 0;
            ( *Acl )->Sbz2 = ( USHORT )0;

        }

        return( Err );
    }

    //
    // Ok now do the allocation.  We'll do a sort of worst case initial
    // allocation.  This saves us from having to process everything twice
    // (once to size, once to build).  If we determine later that we have
    // an acl that is not big enough, we allocate additional space.  The only
    // time that this reallocation should happen is if the input string
    // contains a lot of explicit SIDs.  Otherwise, the chosen buffer size
    // should be pretty close to the proper size
    //
    if ( Err == ERROR_SUCCESS ) {

        AclSize = sizeof( ACL ) + ( Acls * ( sizeof( ACCESS_ALLOWED_OBJECT_ACE ) +
                                            sizeof( SID ) + ( 6 * sizeof( ULONG ) ) ) );
        if ( AclSize > SDDL_MAX_ACL_SIZE ) {
            AclSize = SDDL_MAX_ACL_SIZE;
        }

        *Acl = ( PACL )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, AclSize );

        if ( *Acl == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            AclUsed = sizeof( ACL );

            //
            // We'll start initializing it...
            //
            ( *Acl )->AclRevision = ACL_REVISION;
            ( *Acl )->Sbz1        = ( BYTE )0;
            ( *Acl )->AclSize     = ( USHORT )AclSize;
            ( *Acl )->AceCount    = 0;
            ( *Acl )->Sbz2 = ( USHORT )0;

            //
            // Ok, now we'll go through and start building them all
            //
            Curr = AclString;

            for( i = 0; i < Acls; i++ ) {

                //
                // First, get the type..
                //
                UCHAR Type;
                UCHAR Flags = 0;
                USHORT Size;
                ACCESS_MASK Mask = 0;
                GUID *ObjId = NULL, ObjGuid;
                GUID *IObjId = NULL, IObjGuid;
                PWSTR  Next;
                DWORD AceSize = 0;

                //
                // skip any space before (
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }
                 //
                 // Skip any parens that may exist in the ace list
                 //
                if ( *Curr == SDDL_ACE_BEGINC ) {

                    Curr++;
                }
                 //
                 // skip any space after (
                 //
                 while(*Curr == L' ' ) {
                     Curr++;
                 }

                MatchedEntry = LookupAceTypeInTable( Curr, 0, LookupFlags );

                if ( MatchedEntry ) {

                    Type = ( UCHAR )MatchedEntry->Value;
                    Curr += MatchedEntry->KeyLen + 1;

                } else {

                    //
                    // Found an invalid type
                    //
                    Err = ERROR_INVALID_DATATYPE;
                    break;
                }

                //
                // If we have any object aces, set the acl revision to REVISION_DS
                //
                if ( Type >= ACCESS_MIN_MS_OBJECT_ACE_TYPE && Type <= ACCESS_MAX_MS_OBJECT_ACE_TYPE ) {

                    ( *Acl )->AclRevision = ACL_REVISION_DS;
                }

                //
                // skip any space before ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Next, get the flags...
                //
                while ( Curr != *End ) {

                    if ( *Curr == SDDL_SEPERATORC ) {

                        Curr++;
                        break;
                    }

                    //
                    // Skip any blanks
                    //
                    while ( *Curr == L' ' ) {

                        Curr++;
                    }

                    MatchedEntry = LookupAceFlagsInTable( Curr, 0, LookupFlags );

                    if ( MatchedEntry ) {

                        Flags |= ( UCHAR )MatchedEntry->Value;
                        Curr += MatchedEntry->KeyLen;

                    } else {
                        //
                        // Found an invalid flag
                        //
                        Err = ERROR_INVALID_FLAGS;
                        break;
                    }
                }

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                //
                // skip any space after ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Now, get the access mask
                //
                while( TRUE ) {

                    if ( *Curr == SDDL_SEPERATORC ) {

                        Curr++;
                        break;
                    }

                    //
                    // Skip any blanks
                    //
                    while ( *Curr == L' ' ) {

                        Curr++;
                    }

                    MatchedEntry = LookupAccessMaskInTable( Curr, 0, LookupFlags );

                    if ( MatchedEntry ) {

                        Mask |= MatchedEntry->Value;
                        Curr += MatchedEntry->KeyLen;

                    } else {

                        //
                        // If the rights couldn't be looked up, see if it's a converted mask
                        //

                        Mask = wcstoul( Curr, &MaskEnd, 0 );

                        if ( MaskEnd != Curr ) {

                            Curr = MaskEnd;

                        } else {
                            //
                            // Found an invalid right
                            //
                            Err = ERROR_INVALID_ACL;
                            break;
                        }
                    }
                }

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                //
                // If that worked, we'll get the ids
                //
                for ( j = 0; j < 2; j++ ) {

                    //
                    // skip any space before ;
                    //
                    while(*Curr == L' ' ) {
                        Curr++;
                    }

                    if ( *Curr != SDDL_SEPERATORC ) {

                        wcsncpy( ConvertGuidString, Curr, STRING_GUID_LEN );
                        ConvertGuidString[ STRING_GUID_LEN ] = UNICODE_NULL;

                        if ( j == 0 ) {


                            if ( UuidFromStringW( ConvertGuidString, &ObjGuid ) == RPC_S_OK ) {

                                ObjId = &ObjGuid;

                            } else {

                                Err = RPC_S_INVALID_STRING_UUID;
                                break;
                            }

                        } else {

                            if ( UuidFromStringW( ConvertGuidString, &IObjGuid ) == RPC_S_OK ) {

                                IObjId = &IObjGuid;

                            } else {

                                Err = RPC_S_INVALID_STRING_UUID;
                                break;
                            }
                        }

                        // success
                        Curr += STRING_GUID_LEN;
                        if ( *Curr != SDDL_SEPERATORC &&
                             *Curr != L' ' ) {

                            Err = RPC_S_INVALID_STRING_UUID;
                            break;
                        }

                    }

                    Curr++;
                }

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                //
                // skip any space before ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Finally, the SID
                //
                if ( ERROR_SUCCESS == Err ) {

                    PWSTR   End;
                    Err = LocalGetSidForString( Curr,
                                                &SidPtr,
                                                &End,
                                                &FreeSid,
                                                RootDomainSid,
                                                DomainSid,
                                                tSidLookupDomOrRootDomRelativeTable,
                                                DefaultToDomain );

                    if ( Err == ERROR_SUCCESS ) {

                        if ( End == NULL ) {
                            Err = ERROR_INVALID_ACL;
                        } else {

                            while(*End == L' ' ) {
                                End++;
                            }
                            //
                            // a ace must be terminated by ')'
                            //
                            if ( *End != SDDL_ACE_ENDC ) {
                                Err = ERROR_INVALID_ACL;

                            } else {

                                Curr = End + 1;

                                if ( !SidPtr ) {
                                    Err = ERROR_INVALID_ACL;
                                }
                            }
                        }

                    }
                }

                //
                // Quit on an error
                //
                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                //
                // Now, we'll create the ace, and add it...
                //

                //
                // First, make sure we have the room for it
                //
                switch ( Type ) {
                case ACCESS_ALLOWED_ACE_TYPE:
                case ACCESS_DENIED_ACE_TYPE:
                case SYSTEM_AUDIT_ACE_TYPE:
                case SYSTEM_ALARM_ACE_TYPE:

                    AceSize = sizeof( ACCESS_ALLOWED_ACE );
                    break;

                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                case ACCESS_DENIED_OBJECT_ACE_TYPE:
                case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                case SYSTEM_ALARM_OBJECT_ACE_TYPE:
                    AceSize = sizeof( KNOWN_OBJECT_ACE );

                    if ( ObjId ) {

                        AceSize += sizeof ( GUID );
                    }

                    if ( IObjId ) {

                        AceSize += sizeof ( GUID );
                    }
                    break;

                default:
                    Err = ERROR_INVALID_ACL;
                    break;

                }

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                AceSize += RtlLengthSid( SidPtr )  - sizeof( ULONG );

                if (AceSize + AclUsed > AclSize)
                {
                    //
                    // We'll have to reallocate, since our buffer isn't
                    // big enough...
                    //
                    PACL  NewAcl;
                    DWORD NewSize = AclSize + ( ( Acls - i ) * AceSize );

                    NewAcl = ( PACL )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                 NewSize );
                    if ( NewAcl == NULL ) {

                        LocalFree( *Acl );
                        *Acl = NULL;

                        if ( FreeSid == TRUE ) {

                            LocalFree( SidPtr );
                            SidPtr = NULL;

                            FreeSid = FALSE;
                        }

                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        break;

                    } else {

                        memcpy( NewAcl, *Acl, AclSize );
                        NewAcl->AclSize = ( USHORT )NewSize;

                        LocalFree( *Acl );
                        *Acl = NewAcl;

                        AclSize = NewSize;
                    }

                }

                AclUsed += AceSize;

                SetLastError( ERROR_SUCCESS );

                switch (Type)
                {
                case SYSTEM_AUDIT_ACE_TYPE:
                    OpRes = AddAuditAccessAceEx( *Acl,
                                                 ACL_REVISION,
                                                 Flags &
                                                     ~(SUCCESSFUL_ACCESS_ACE_FLAG |
                                                       FAILED_ACCESS_ACE_FLAG),
                                                 Mask,
                                                 SidPtr,
                                                 Flags & SUCCESSFUL_ACCESS_ACE_FLAG,
                                                 Flags & FAILED_ACCESS_ACE_FLAG );
                    break;

                case ACCESS_ALLOWED_ACE_TYPE:
                    OpRes = AddAccessAllowedAceEx( *Acl,
                                                   ACL_REVISION,
                                                   Flags,
                                                   Mask,
                                                   SidPtr );

                    break;

                case ACCESS_DENIED_ACE_TYPE:
                    OpRes = AddAccessDeniedAceEx( *Acl,
                                                  ACL_REVISION,
                                                   Flags,
                                                  Mask,
                                                  SidPtr );

                    break;

                case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                    OpRes = AddAuditAccessObjectAce( *Acl,
                                                     ACL_REVISION_DS,
                                                     Flags,
                                                     Mask,
                                                     ObjId,
                                                     IObjId,
                                                     SidPtr,
                                                     Flags & SUCCESSFUL_ACCESS_ACE_FLAG,
                                                     Flags & FAILED_ACCESS_ACE_FLAG );
                    break;

                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                    OpRes = AddAccessAllowedObjectAce( *Acl,
                                                       ACL_REVISION_DS,
                                                       Flags,
                                                       Mask,
                                                       ObjId,
                                                       IObjId,
                                                        SidPtr );
                    break;

                case ACCESS_DENIED_OBJECT_ACE_TYPE:
                    OpRes = AddAccessDeniedObjectAce( *Acl,
                                                      ACL_REVISION_DS,
                                                      Flags,
                                                      Mask,
                                                      ObjId,
                                                      IObjId,
                                                      SidPtr );

                    break;

                default:
                    SetLastError( ERROR_INVALID_DATATYPE );
                    OpRes = FALSE;
                    break;

                }

                if ( OpRes == FALSE ) {

                    Err = GetLastError();
                    break;
                }

                //
                // Clean up whatever memory we have to
                //
                if ( FreeSid == TRUE ) {

                    LocalFree( SidPtr );
                }

                SidPtr = NULL;

                if ( *Curr == SDDL_ACE_BEGINC ) {

                    Curr++;
                }

            }

            //
            // If something didn't work, clean up
            //
            if ( Err != ERROR_SUCCESS ) {

                LocalFree( *Acl );
                *Acl = NULL;

            } else {

                //
                // Set a more realistic acl size
                //
                ( *Acl )->AclSize = ( USHORT )AclUsed;
            }

            //
            // free any SIDs buffer used
            //
            if ( FreeSid && SidPtr ) {
                LocalFree(SidPtr);
                SidPtr = NULL;
            }

            FreeSid = FALSE;
        }
    }

    return(Err);
}


DWORD
LocalConvertAclToString(
    IN PACL Acl,
    IN BOOLEAN AclPresent,
    IN BOOLEAN ConvertAsDacl,
    OUT PWSTR *AclString,
    OUT PDWORD AclStringSize,
    IN PSID RootDomainSid OPTIONAL
    )
/*++

Routine Description:

    This routine convert an acl into a string.  The format of the aces is:

    Ace := ( Type; Flags; Rights; ObjGuid; IObjGuid; Sid;
    Type : = A | D | OA | OD        {Access, Deny, ObjectAccess, ObjectDeny}
    Flags := Flags Flag
    Flag : = CI | IO | NP | SA | FA {Container Inherit,Inherit Only, NoProp,
                                     SuccessAudit, FailAdit }
    Rights := Rights Right
    Right := DS_READ_PROPERTY |  blah blah
    Guid := String representation of a GUID (via RPC UuidToString)
    Sid := DA | PS | AO | PO | AU | S-* (Domain Admins, PersonalSelf, Acct Ops,
                                         PrinterOps, AuthenticatedUsers, or
                                         the string representation of a sid)
    The seperator is a ';'.

    The returned string must be free via a call to LocalFree


Arguments:

    Acl - The acl to be converted

    AclPresent - if TRUE, the acl is present, even if NULL

    AclString - Where the created acl string is to be returned

    ConvertAsDacl - Convert the given acl as the DACL, not the SACL

    AclStringLen - The size of the allocated string is returned here


Return Value:

    ERROR_SUCCESS - success

    ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput acl
                            failed

    ERROR_INVALID_PARAMETER The string does not represent an ACL

    ERROR_INVALID_ACL - An unexpected access mask was encountered or a NULL acl was encountered

--*/
{
    DWORD   Err = ERROR_SUCCESS;
    DWORD   AclSize = 0, MaskSize;
    PACE_HEADER AceHeader;
    ULONG i, j;
    PWSTR *SidStrings = NULL, Curr, Guid;
    BOOLEAN *SidFrees = NULL;
    UINT *pMaskAsString = NULL;
    PSTRSD_KEY_LOOKUP MatchedEntry;
    PSTRSD_SID_LOOKUP MatchedSidEntry;
    PKNOWN_ACE KnownAce;
    PKNOWN_OBJECT_ACE KnownObjectAce;
    ACCESS_MASK AccessMask;
    PSID Sid, pSidSA=NULL;
    GUID *Obj, *Inherit;
    ULONG LookupFlags;
    ULONG AceFlags[ ] = {
        OBJECT_INHERIT_ACE,
        CONTAINER_INHERIT_ACE,
        NO_PROPAGATE_INHERIT_ACE,
        INHERIT_ONLY_ACE,
        INHERITED_ACE,
        SUCCESSFUL_ACCESS_ACE_FLAG,
        FAILED_ACCESS_ACE_FLAG
        };


    if ( AclString == NULL || AclStringSize == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // treat the case when (AclPresent == TRUE and Acl == NULL) 
    // same as the case when AclPresent == FALSE. 
    // This fix is to be compatible with IsValidSecurityDescriptor() 
    // when ACL_PRESENT bit is set and Acl == NULL
    //

    if ( !AclPresent || 
         (AclPresent &&  (Acl == NULL) ) ) {

        *AclString = NULL;
        *AclStringSize = 0;
        return( ERROR_SUCCESS );

    }

    //
    // If the ace count is 0, then it's an empty acl, and we don't handle those...
    //
    if ( Acl->AceCount == 0 ) {

        *AclString = NULL;
        *AclStringSize = 0;
        return( ERROR_SUCCESS );

    }

    if ( ConvertAsDacl ) {

        LookupFlags = SDDL_VALID_DACL;

    } else {

        LookupFlags = SDDL_VALID_SACL;
    }

    //
    // Allocate buffers to hold sids that are looked up
    //
    SidStrings = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Acl->AceCount * sizeof( PWSTR ) );

    if ( SidStrings == NULL ) {

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    SidFrees = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Acl->AceCount * sizeof( BOOLEAN ) );

    if ( SidFrees == NULL ) {

        LocalFree( SidStrings );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    pMaskAsString = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Acl->AceCount * sizeof( UINT ) );

    if ( pMaskAsString == NULL ) {

        LocalFree( SidStrings );
        LocalFree( SidFrees );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    AceHeader = ( PACE_HEADER )FirstAce( Acl );

    //
    // Size the acl, so we know how big a buffer to allocate
    //
    for(i = 0; i < Acl->AceCount && Err == ERROR_SUCCESS;
        i++, AceHeader = ( PACE_HEADER )NextAce( AceHeader ) ) {

        AclSize += sizeof( WCHAR );
        //
        // First, the type
        //
        MatchedEntry = LookupAceTypeInTable( NULL, ( ULONG )AceHeader->AceType, LookupFlags );

        if ( MatchedEntry ) {

            AclSize += SDDL_SIZE_TAG( MatchedEntry->Key ) + SDDL_SIZE_SEP( SDDL_SEPERATORC );

        } else {

            //
            // Found an invalid type
            //
            Err = ERROR_INVALID_ACL;
            break;
        }

        //
        // Next, process the ace flags
        //
        for ( j = 0; j < sizeof( AceFlags ) / sizeof( ULONG ); j++ ) {

            if ( ( ULONG )AceHeader->AceFlags & ( AceFlags[ j ] ) ) {

                MatchedEntry = LookupAceFlagsInTable( 0, AceFlags[ j ], LookupFlags );
                if ( MatchedEntry ) {

                    AclSize += SDDL_SIZE_TAG( MatchedEntry->Key );
                }
            }
        }

        if ( Err != ERROR_SUCCESS ) {

            break;

        } else {

            AclSize += SDDL_SIZE_SEP( SDDL_SEPERATORC );
        }

        //
        // Next, the rights and optionally the guids.  This gets done on a per ace type basis
        //
        switch ( AceHeader->AceType ) {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
            KnownAce = ( PKNOWN_ACE )AceHeader;
            AccessMask = KnownAce->Mask;
            Sid = ( PSID )&KnownAce->SidStart;

            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            KnownObjectAce = ( PKNOWN_OBJECT_ACE )AceHeader;
            AccessMask = KnownObjectAce->Mask;
            Sid = RtlObjectAceSid( AceHeader );

            //
            // Deal with potential guids
            //
            if ( RtlObjectAceObjectType( AceHeader ) ) {

                AclSize += STRING_GUID_SIZE;
            }

            if ( RtlObjectAceInheritedObjectType( AceHeader ) ) {

                AclSize += STRING_GUID_SIZE;
            }

            break;

        default:
            Err = ERROR_INVALID_ACL;
            break;

        }

        //
        // Size the rights
        //
        if ( Err == ERROR_SUCCESS ) {

            MaskSize = 0;
            pMaskAsString[i] = 0;

            //
            // lookup for the exact value first
            //
            MatchedEntry = LookupAccessMaskInTable( 0, AccessMask, LookupFlags );

            if ( MatchedEntry ) {

                pMaskAsString[i] = 1;
                MaskSize += SDDL_SIZE_TAG( MatchedEntry->Key );

            } else {
                //
                // look for each bit
                //
                for ( j = 0; j < 32; j++ ) {

                    if ( AccessMask & ( 1 << j ) ) {

                        MatchedEntry = LookupAccessMaskInTable( 0, AccessMask & ( 1 << j ), LookupFlags );

                        if ( MatchedEntry ) {

                            MaskSize += SDDL_SIZE_TAG( MatchedEntry->Key );

                        } else {

                            //
                            // Found an invalid type.  We'll convert the whole thing to a string
                            //
                            pMaskAsString[i] = 2;
                            MaskSize = 10 * sizeof( WCHAR );
                            break;
                        }
                    }
                }
            }

            if ( Err != ERROR_SUCCESS ) {

                break;

            } else {

                AclSize += MaskSize;
                AclSize += SDDL_SIZE_SEP( SDDL_SEPERATORC );
            }
        }

        if ( Err != ERROR_SUCCESS ) {

            break;
        }

        //
        // Add in space for the guid seperators
        //
        AclSize += 2 * SDDL_SIZE_SEP( SDDL_SEPERATORC );

        //
        // Finally, lookup the sids
        //
        MatchedSidEntry = LookupSidInTable( NULL,
                                            Sid,
                                            RootDomainSid,
                                            NULL,
                                            NULL,
                                            FALSE,
                                            &pSidSA );

        //
        // If we didn't find a match, try it as a sid string
        //
        if ( MatchedSidEntry == NULL ) {

            if ( pSidSA ) {
                //
                // when sid lookup finds the sid of SA, pSidSA is assigned to Sid
                // so it doesn't need to be freed.
                //

                SidStrings[ i ] = LocalAlloc( LMEM_FIXED, (wcslen(SDDL_SCHEMA_ADMINISTRATORS)+1)*sizeof(TCHAR) );

                if ( SidStrings[ i ] == NULL ) {

                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    break;

                } else {
                    wcscpy( SidStrings[ i ], SDDL_SCHEMA_ADMINISTRATORS );

                    SidFrees[ i ] = TRUE;
                }

            } else {

                if ( ConvertSidToStringSidW( Sid, &SidStrings[ i ] ) == FALSE ) {

                    Err = GetLastError();
                    break;

                } else {

                    SidFrees[ i ] = TRUE;
                }
            }

        } else {

            //
            // If the entry that's been selected hasn't been initialized yet, do it now
            //
            SidStrings[ i ] = MatchedSidEntry->Key;
        }
        AclSize += SDDL_SIZE_TAG( SidStrings[ i ] );


        AclSize += sizeof( WCHAR );  // Closing paren
        AclSize += sizeof( WCHAR );  // Trailing NULL
    }

    //
    // If all of that worked, allocate the return buffer, and build the acl string
    //
    if ( AclSize == 0 ) {
        Err = ERROR_INVALID_ACL;
    }

    if ( Err == ERROR_SUCCESS ) {

        if ( AclSize % 2 != 0 ) {
            AclSize++;
        }

        *AclString = LocalAlloc( LMEM_FIXED, AclSize );

        if ( *AclString == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Build the acl
    //
    if ( Err == ERROR_SUCCESS ) {

        Curr = *AclString;

        AceHeader = ( PACE_HEADER )FirstAce( Acl );

        //
        // Size the acl, so we know how big a buffer to allocate
        //
        for(i = 0; i < Acl->AceCount && Err == ERROR_SUCCESS;
            i++, AceHeader = ( PACE_HEADER )NextAce( AceHeader ) ) {

            //
            // "("
            //
            *Curr = SDDL_ACE_BEGINC;
            Curr++;

            //
            // By the time we get down here, we've ensured that we can lookup all the values,
            // so there is no need to check for failure
            //

            //
            // First, the type, must find it
            // "T;"
            //
            MatchedEntry = LookupAceTypeInTable( NULL, ( ULONG )AceHeader->AceType, LookupFlags );
            if ( MatchedEntry ) {
                wcscpy( Curr, MatchedEntry->Key );
                Curr += MatchedEntry->KeyLen;
            }
            *Curr = SDDL_SEPERATORC;
            Curr++;

            //
            // Next, process the ace flags
            // "CIIO;"
            //
            for ( j = 0; j < sizeof( AceFlags ) / sizeof( ULONG ); j++ ) {

                if ( ( ULONG )AceHeader->AceFlags & ( AceFlags[ j ] ) ) {

                    MatchedEntry = LookupAceFlagsInTable( 0, AceFlags[ j ], LookupFlags );

                    if ( MatchedEntry ) {

                        wcscpy( Curr, MatchedEntry->Key );
                        Curr+= MatchedEntry->KeyLen;

                    }

                }
            }
            *Curr = SDDL_SEPERATORC;
            Curr++;

            //
            // Next, the rights and optionally the guids.  This gets done on a per ace type basis
            //
            Obj = NULL;
            Inherit = NULL;

            switch ( AceHeader->AceType ) {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
            case SYSTEM_ALARM_ACE_TYPE:
                KnownAce = ( PKNOWN_ACE )AceHeader;
                AccessMask = KnownAce->Mask;
                Sid = ( PSID )&KnownAce->SidStart;

                break;

            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            case SYSTEM_ALARM_OBJECT_ACE_TYPE:
                KnownObjectAce = ( PKNOWN_OBJECT_ACE )AceHeader;
                AccessMask = KnownObjectAce->Mask;
                Sid = RtlObjectAceSid( AceHeader );

                //
                // Deal with potential guids
                //
                Inherit = RtlObjectAceInheritedObjectType( AceHeader );
                Obj = RtlObjectAceObjectType( AceHeader );
                break;
            }

            //
            // Add the rights
            //
            if ( pMaskAsString[i] == 2 ) {

                wcscpy( Curr, L"0x");
                Curr += 2;
                _ultow( AccessMask, Curr, 16 );
                Curr += wcslen( Curr );

            } else if ( pMaskAsString[i] == 1 ) {

                //
                // lookup for the entire value first
                //
                MatchedEntry = LookupAccessMaskInTable( 0, AccessMask, LookupFlags );

                if ( MatchedEntry ) {

                    wcscpy( Curr, MatchedEntry->Key );
                    Curr += MatchedEntry->KeyLen;
                }

            } else { // 0

                for ( j = 0; j < 32; j++ ) {

                    if ( AccessMask & (1 << j) ) {

                        MatchedEntry = LookupAccessMaskInTable( 0, AccessMask & ( 1 << j ), LookupFlags );

                        if ( MatchedEntry ) {

                            wcscpy( Curr, MatchedEntry->Key );
                            Curr += MatchedEntry->KeyLen;

                        } // else shouldn't happen but if it happens
                          // it is too late to convert it into 0x format
                          // because the buffer is already allocated with smaller size.

                    }
                }
            }

            *Curr = SDDL_SEPERATORC;
            Curr++;


            //
            // Optional object guid
            //
            if ( Obj ) {

                Err = UuidToStringW( Obj, &Guid );

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                wcscpy( Curr, Guid );
                Curr += wcslen( Guid );
                RpcStringFreeW( &Guid );

            }
            *Curr = SDDL_SEPERATORC;
            Curr++;

            if ( Inherit ) {

                Err = UuidToStringW( Inherit, &Guid );

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                wcscpy( Curr, Guid );
                Curr += wcslen( Guid );
                RpcStringFreeW( &Guid );

            }
            *Curr = SDDL_SEPERATORC;
            Curr++;

            //
            // Finally, the sids
            //
            wcscpy( Curr, SidStrings[ i ] );
            Curr += wcslen( SidStrings[ i ] );

            *Curr = SDDL_ACE_ENDC;
            Curr++;
            *Curr = UNICODE_NULL;

        }
    }

    //
    // Free any allocated memory
    // jinhuang: should always free the allocated buffer
    //

//    if ( Err != ERROR_SUCCESS && SidStrings ) {

        for ( j = 0; j < Acl->AceCount; j++ ) {

            if ( SidFrees[ j ] ) {

                LocalFree( SidStrings[ j ] );
            }
        }
//    }

    LocalFree( SidStrings );
    LocalFree( SidFrees );
    LocalFree( pMaskAsString );

    if ( Err != ERROR_SUCCESS ) {

        LocalFree(*AclString);
        *AclString = NULL;
        *AclStringSize = 0;

    } else {

        *AclStringSize = AclSize;

    }

    return( Err );
}


DWORD
LocalConvertSDToStringSD_Rev1(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  SECURITY_INFORMATION  SecurityInformation,
    OUT LPWSTR  *StringSecurityDescriptor,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    )
/*++

Routine Description:

    This routine converts a security descriptor into a string version persuant to SDDL definition

Arguments:

    SecurityDescriptor - Security Descriptor to be converted.

    SecurityInformation - the security information of which component to be converted

    StringSecurityDescriptor - Where the converted SD is returned.  Buffer is allocated via
        LocalAlloc and should be free via LocalFree.

    StringSecurityDescriptorLen - optional length of the converted SD buffer.

Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

--*/
{
    DWORD Err = ERROR_SUCCESS;
    NTSTATUS Status=STATUS_SUCCESS;
    DWORD ReturnBufferSize = 0, AclSize;
    PSID Owner = NULL, Group = NULL;
    PACL Dacl = NULL, Sacl = NULL;
    BOOLEAN Defaulted, SaclPresent=FALSE, DaclPresent=FALSE;
    PWSTR OwnerString = NULL, GroupString = NULL, SaclString = NULL, DaclString = NULL;
    SECURITY_DESCRIPTOR_CONTROL ControlCode;
    ULONG Revision;
    PWSTR DaclControl=NULL, SaclControl=NULL;

    if ( SecurityDescriptor == NULL || StringSecurityDescriptor == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Get the relevant security descriptor parts
    // based on the SecurityInforamtion input parameter
    //
    if ( SecurityInformation & OWNER_SECURITY_INFORMATION ) {

        Status = RtlGetOwnerSecurityDescriptor( SecurityDescriptor, &Owner, &Defaulted );
    }

    if ( NT_SUCCESS( Status ) &&
         SecurityInformation & GROUP_SECURITY_INFORMATION ) {

        Status = RtlGetGroupSecurityDescriptor( SecurityDescriptor, &Group, &Defaulted );

    }

    if ( NT_SUCCESS( Status ) &&
         SecurityInformation & DACL_SECURITY_INFORMATION ) {

        Status = RtlGetDaclSecurityDescriptor( SecurityDescriptor, &DaclPresent, &Dacl, &Defaulted );
    }

    if ( NT_SUCCESS( Status ) &&
         SecurityInformation & SACL_SECURITY_INFORMATION ) {

        Status = RtlGetSaclSecurityDescriptor( SecurityDescriptor, &SaclPresent, &Sacl, &Defaulted );
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = RtlGetControlSecurityDescriptor ( SecurityDescriptor, &ControlCode, &Revision);
    }

    if ( !NT_SUCCESS( Status ) ) {

        Err = RtlNtStatusToDosError( Status );
        return( Err );
    }

    //
    // make sure the SidLookup table is reinitialized
    //
    InitializeSidLookupTable(STRSD_REINITIALIZE_ENTER);

    //
    // Convert the owner and group, if they exist
    //
    if ( Owner ) {

        Err = LocalGetStringForSid( Owner,
                                    &OwnerString,
                                    RootDomainSid
                                  );

    }

    if ( Err == ERROR_SUCCESS && Group ) {

        Err = LocalGetStringForSid( Group,
                                    &GroupString,
                                    RootDomainSid );
    }

    //
    // JINHUANG 3/10/98
    // get DACL control string
    //
    if ( Err == ERROR_SUCCESS && ControlCode ) {

        Err = LocalGetStringForControl(ControlCode, SDDL_VALID_DACL, &DaclControl);
    }

    //
    // get SACL control string
    //
    if ( Err == ERROR_SUCCESS && ControlCode ) {

        Err = LocalGetStringForControl(ControlCode, SDDL_VALID_SACL, &SaclControl);
    }

    //
    // SACL first because the size of DACL is needed later
    //
    if ( Err == ERROR_SUCCESS && SaclPresent ) {


        Err = LocalConvertAclToString( Sacl,
                                       SaclPresent,
                                       FALSE,
                                       &SaclString,
                                       &AclSize,
                                       RootDomainSid );
        if ( Err == ERROR_SUCCESS ) {

            ReturnBufferSize += AclSize;
        }
    }

    //
    // Then, the DACL
    //
    if ( Err == ERROR_SUCCESS && DaclPresent ) {

        Err = LocalConvertAclToString( Dacl,
                                       DaclPresent,
                                       TRUE,
                                       &DaclString,
                                       &AclSize,
                                       RootDomainSid );

        if ( Err == ERROR_SUCCESS ) {

            ReturnBufferSize += AclSize;
        }
    }

    //
    // Now, if all of that worked, allocate and build the return string
    //
    if ( Err == ERROR_SUCCESS ) {

        if ( OwnerString ) {

            ReturnBufferSize += ( wcslen( OwnerString ) * sizeof( WCHAR ) ) +
                                SDDL_SIZE_TAG( SDDL_OWNER )  +
                                SDDL_SIZE_SEP( SDDL_DELIMINATORC );
        }

        if ( GroupString ) {

            ReturnBufferSize += ( wcslen( GroupString ) * sizeof( WCHAR ) ) +
                                SDDL_SIZE_TAG( SDDL_GROUP )  +
                                SDDL_SIZE_SEP( SDDL_DELIMINATORC );
        }

        if ( DaclPresent ) {

            ReturnBufferSize += SDDL_SIZE_TAG( SDDL_DACL )  +
                                SDDL_SIZE_SEP( SDDL_DELIMINATORC );

            if ( DaclControl ) {
                ReturnBufferSize += (wcslen( DaclControl ) * sizeof(WCHAR)) ;
            }
        }

        if ( SaclPresent ) {

            ReturnBufferSize += SDDL_SIZE_TAG( SDDL_SACL )  +
                                SDDL_SIZE_SEP( SDDL_DELIMINATORC );

            if ( SaclControl ) {
                ReturnBufferSize += (wcslen( SaclControl ) * sizeof(WCHAR)) ;
            }
        }


        *StringSecurityDescriptor = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                ReturnBufferSize + sizeof( WCHAR ) );

        if ( *StringSecurityDescriptor == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // Build the string from the previously determined components.  Note that
            // if a component is not present, it is skipped.
            //
            DWORD dwOffset=0;

            if ( OwnerString ) {

                swprintf( *StringSecurityDescriptor, L"%ws%wc%ws",
                          SDDL_OWNER, SDDL_DELIMINATORC, OwnerString );

                dwOffset = wcslen(*StringSecurityDescriptor);
            }

            if ( GroupString ) {

                swprintf( *StringSecurityDescriptor + dwOffset,
                          L"%ws%wc%ws", SDDL_GROUP, SDDL_DELIMINATORC, GroupString );

                Revision = wcslen( *StringSecurityDescriptor + dwOffset ); // temp use
                dwOffset += Revision;

            }

            if ( DaclPresent ) {

                if ( DaclControl ) {
                    swprintf( *StringSecurityDescriptor + dwOffset,
                          L"%ws%wc%ws", SDDL_DACL, SDDL_DELIMINATORC, DaclControl );
                } else {
                    swprintf( *StringSecurityDescriptor + dwOffset,
                          L"%ws%wc", SDDL_DACL, SDDL_DELIMINATORC );
                }

                Revision = wcslen( *StringSecurityDescriptor + dwOffset );
                dwOffset += Revision;

                if ( DaclString ) {

                    wcscpy( *StringSecurityDescriptor + dwOffset, DaclString );

                    Revision = wcslen( *StringSecurityDescriptor + dwOffset ); // temp use
                    dwOffset += Revision;  // (AclSize/sizeof(WCHAR));
                }

            }

            if ( SaclPresent ) {

                if ( SaclControl ) {

                    swprintf( *StringSecurityDescriptor + dwOffset,
                              L"%ws%wc%ws", SDDL_SACL, SDDL_DELIMINATORC, SaclControl );
                } else {
                    swprintf( *StringSecurityDescriptor + dwOffset,
                              L"%ws%wc", SDDL_SACL, SDDL_DELIMINATORC );
                }

                Revision = wcslen( *StringSecurityDescriptor + dwOffset );
                dwOffset += Revision;

                if ( SaclString ) {

                    wcscpy( *StringSecurityDescriptor + dwOffset, SaclString);
                }

            }

            //
            // jinhuang
            // output the buffer size
            //

            if ( StringSecurityDescriptorLen ) {
                *StringSecurityDescriptorLen = ReturnBufferSize/sizeof(WCHAR);
            }
        }
    }


    //
    // Free any buffers that were allocated
    //
    LocalFree( OwnerString );
    LocalFree( GroupString );
    LocalFree( SaclString );
    LocalFree( DaclString );

    //
    // JINHUANG 3/10/98
    // it's ok to free them even if they are NULL
    //
    LocalFree( SaclControl );
    LocalFree( DaclControl );

    //
    // decrement the SidLookup instance
    //
    InitializeSidLookupTable(STRSD_REINITIALIZE_LEAVE);

    return( Err );
}




DWORD
LocalConvertStringSDToSD_Rev1(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  BOOLEAN DefaultToDomain,
    IN  LPCWSTR StringSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
/*++

Routine Description:

    This routine converts a revision 1 stringized Security descriptor into a valid, functional
    security descriptor

Arguments:

    StringSecurityDescriptor - Stringized security descriptor to be converted.

    SecurityDescriptor - Where the converted SD is returned.  Buffer is allocated via
        LocalAlloc and should be free via LocalFree.  The returned security descriptor
        is always self relative

    SecurityDescriptorSize - OPTIONAL.  If non-NULL, the size of the converted security
        descriptor is returned here.

    SecurityInformation - OPTIONAL. If non-NULL, the security information of the converted
        security descriptor is returned here.

Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL input or output parameter was given

        ERROR_UNKNOWN_REVISION - An unsupported revision was given

--*/
{
    DWORD Err = ERROR_SUCCESS;
    PSID Owner = NULL, Group = NULL;
    PACL Dacl  = NULL, Sacl  = NULL;
    SECURITY_INFORMATION SeInfo = 0;
    SECURITY_DESCRIPTOR SD;
    PWSTR Curr, End;
    NTSTATUS Status;
    BOOLEAN FreeOwner = FALSE, FreeGroup = FALSE;
    SID_IDENTIFIER_AUTHORITY UaspBuiltinAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY UaspCreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    ULONG SDSize = 0;
    BOOLEAN DaclPresent = FALSE, SaclPresent = FALSE;
    SECURITY_DESCRIPTOR_CONTROL DaclControl=0, SaclControl=0;
    PSTRSD_SID_LOOKUP    tSidLookupDomOrRootDomRelativeTable = NULL;


    if ( StringSecurityDescriptor == NULL || SecurityDescriptor == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( SecurityDescriptorSize ) {

        *SecurityDescriptorSize = 0;
    }

    //
    // make sure the SidLookup table is reinitialized
    //
    InitializeSidLookupTable(STRSD_REINITIALIZE_ENTER);

    //
    // for the API ConvertStringSDToSDDomain, if DomainSid != NULL, we need a table on
    // the heap, for this thread to stash lookups for ST_DOMAIN_RELATIVE type trustees
    // this table will be freed when all lookups have been done for this thread
    //



    if (DomainSid) {

        tSidLookupDomOrRootDomRelativeTable =
            (PSTRSD_SID_LOOKUP) LocalAlloc(LMEM_ZEROINIT, sizeof(SidLookupDomOrRootDomRelative));

        //
        // table copy/init from the template-table
        //

        if (tSidLookupDomOrRootDomRelativeTable)

            memcpy(tSidLookupDomOrRootDomRelativeTable,
                   SidLookupDomOrRootDomRelative,
                   sizeof(SidLookupDomOrRootDomRelative));

        else

            Err = ERROR_NOT_ENOUGH_MEMORY;

    }

    //
    // Now, we'll just start parsing and building
    //
    Curr = ( PWSTR )StringSecurityDescriptor;

    while ( Err == ERROR_SUCCESS && Curr ) {

        switch( *Curr ) {

        //
        // Get the Owner sid
        //
        case L'O':

            Err = ERROR_INVALID_PARAMETER;

            if ( *(Curr+1) == SDDL_DELIMINATORC ) {

                Curr += 2;

                if ( Owner == NULL )  {

                    Err = LocalGetSidForString( Curr,
                                                &Owner,
                                                &End,
                                                &FreeOwner,
                                                RootDomainSid,
                                                DomainSid,
                                                tSidLookupDomOrRootDomRelativeTable,
                                                DefaultToDomain );

                    if ( Err == ERROR_SUCCESS ) {

                        Curr = End;
                        SeInfo |= OWNER_SECURITY_INFORMATION;
                    }
                }
            }
            break;

        //
        // Get the Group sid
        //
        case L'G':

            Err = ERROR_INVALID_PARAMETER;

            if ( *(Curr+1) == SDDL_DELIMINATORC ) {

                Curr += 2;

                if ( Group == NULL ) {

                    Err = LocalGetSidForString( Curr,
                                                &Group,
                                                &End,
                                                &FreeGroup,
                                                RootDomainSid,
                                                DomainSid,
                                                tSidLookupDomOrRootDomRelativeTable,
                                                DefaultToDomain );

                    if ( Err == ERROR_SUCCESS ) {

                        Curr = End;
                        SeInfo |= GROUP_SECURITY_INFORMATION;
                    }
                }
            }
            break;

        //
        // Next, the DAcl
        //
        case L'D':

            if ( *(Curr+1) == SDDL_DELIMINATORC ) {

                Curr += 2;

                if ( Dacl == NULL ) {

                    //
                    // JINHUANG: 3/10/98
                    // look for any security descriptor controls
                    //
                    if ( *Curr != SDDL_ACE_BEGINC ) {

                        Err = LocalGetSDControlForString( Curr,
                                                          SDDL_VALID_DACL,
                                                          &DaclControl,
                                                          &End );
                        if ( Err == ERROR_SUCCESS ) {
                            Curr = End;
                        }
                    }

                    if ( Err == ERROR_SUCCESS ) {

                        Err = LocalGetAclForString( Curr,
                                                    TRUE,
                                                    &Dacl,
                                                    &End,
                                                    RootDomainSid,
                                                    DomainSid,
                                                    tSidLookupDomOrRootDomRelativeTable,
                                                    DefaultToDomain );

                        if ( Err == ERROR_SUCCESS ) {

                            Curr = End;
                            SeInfo |= DACL_SECURITY_INFORMATION;
                            DaclPresent = TRUE;
                        }
                    }

                } else {

                    Err = ERROR_INVALID_PARAMETER;
                }

            } else {

                Err = ERROR_INVALID_PARAMETER;
            }
            break;

        //
        // Finally, the SAcl
        //
        case L'S':

            if ( *(Curr+1) == SDDL_DELIMINATORC ) {

                Curr += 2;

                if ( Sacl == NULL ) {

                    //
                    // JINHUANG: 3/10/98
                    // look for any security descriptor controls
                    //
                    if ( *Curr != SDDL_ACE_BEGINC ) {

                        Err = LocalGetSDControlForString( Curr,
                                                          SDDL_VALID_SACL,
                                                          &SaclControl,
                                                          &End );
                        if ( Err == ERROR_SUCCESS ) {
                            Curr = End;
                        }
                    }

                    if ( Err == ERROR_SUCCESS ) {

                        Err = LocalGetAclForString( Curr,
                                                    FALSE,
                                                    &Sacl,
                                                    &End,
                                                    RootDomainSid,
                                                    DomainSid,
                                                    tSidLookupDomOrRootDomRelativeTable,
                                                    DefaultToDomain );

                        if ( Err == ERROR_SUCCESS ) {

                            Curr = End;
                            SeInfo |= SACL_SECURITY_INFORMATION;
                            SaclPresent = TRUE;
                        }
                    }

                } else {

                    Err = ERROR_INVALID_PARAMETER;
                }

            } else {

                Err = ERROR_INVALID_PARAMETER;
            }
            break;

        //
        // It's a space, so ignore it
        //
        case L' ':
            Curr++;
            break;

        //
        // End of the string, so quit
        //
        case L'\0':
            Curr = NULL;
            break;

        //
        // Don't know what it is, so consider it an error
        //
        default:
            Err = ERROR_INVALID_PARAMETER;
            break;
        }
    }


    //
    // Ok, if we have the information we need, we'll create the security
    // descriptor
    //
    if ( Err == ERROR_SUCCESS ) {

        if ( InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION ) == FALSE ) {

            Err = GetLastError();
        }

        //
        // JINHUANG 3/10/98
        // set the security descriptor control
        //

        SD.Control |= (DaclControl | SaclControl);

        //
        // Now, add the owner and group
        //
        if ( Err == ERROR_SUCCESS && Owner != NULL ) {

            if ( SetSecurityDescriptorOwner(&SD, Owner, FALSE ) == FALSE ) {

                Err = GetLastError();
            }
        }

        if ( Err == ERROR_SUCCESS && Group != NULL ) {

            if ( SetSecurityDescriptorGroup( &SD, Group, FALSE ) == FALSE ) {

                Err = GetLastError();
            }
        }

        //
        // Then the DACL and SACL
        //
        if ( Err == ERROR_SUCCESS && DaclPresent ) {

            if ( SetSecurityDescriptorDacl( &SD, DaclPresent, Dacl, FALSE ) == FALSE ) {

                Err = GetLastError();
            }
        }

        if ( Err == ERROR_SUCCESS && SaclPresent ) {

            if ( SetSecurityDescriptorSacl( &SD, SaclPresent, Sacl, FALSE ) == FALSE ) {

                Err = GetLastError();
            }
        }

    }

    //
    // Finally, we'll allocate our buffer and return
    //
    if ( Err == ERROR_SUCCESS ) {

        MakeSelfRelativeSD( &SD, *SecurityDescriptor, &SDSize );

        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {

            *SecurityDescriptor = (PSECURITY_DESCRIPTOR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                                     SDSize );

            if ( *SecurityDescriptor == NULL ) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                if ( MakeSelfRelativeSD( &SD, *SecurityDescriptor, &SDSize ) == FALSE ) {

                    Err = GetLastError();
                    LocalFree( *SecurityDescriptor );
                    *SecurityDescriptor = NULL;

                }
            }

        } else {

            //
            // This should never happen
            //
            if ( GetLastError() == ERROR_SUCCESS ) {

                Err = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    }

    //
    // Return the security descriptor size, if requested
    //
    if ( Err == ERROR_SUCCESS && SecurityDescriptorSize ) {

        *SecurityDescriptorSize = SDSize;
    }

    //
    // Finally, free any memory we may have allocated...
    //
    if ( FreeOwner == TRUE ) {

        LocalFree( Owner );

    }

    if ( FreeGroup == TRUE ) {

        LocalFree( Group );

    }

    LocalFree( Dacl );
    LocalFree( Sacl );

    if (tSidLookupDomOrRootDomRelativeTable)

        LocalFree(tSidLookupDomOrRootDomRelativeTable);

    //
    // make sure the SidLookup table is reinitialized
    //
    InitializeSidLookupTable(STRSD_REINITIALIZE_LEAVE);

    return( Err );
}

BOOLEAN
InitializeSidLookupTable(
    IN BYTE InitFlag
    )
{
    SID_IDENTIFIER_AUTHORITY UaspWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY UaspLocalAuthority = SECURITY_LOCAL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY UaspCreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY UaspNtAuthority = SECURITY_NT_AUTHORITY;
    DWORD i;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status=STATUS_SUCCESS;
    LSA_HANDLE LsaPolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;


    EnterCriticalSection(&SddlSidLookupCritical);

    switch ( InitFlag ) {
    case STRSD_REINITIALIZE_ENTER:

        SidTableReinitializeInstance++;

        if ( SidTableReinitializeInstance > 1 ) {
            //
            // there is another thread going, no need to reinitialize the table again
            //
            LeaveCriticalSection(&SddlSidLookupCritical);

            return TRUE;
        }
        break;

    case STRSD_REINITIALIZE_LEAVE:

        if ( SidTableReinitializeInstance > 1 ) {
            SidTableReinitializeInstance--;
        } else {
            SidTableReinitializeInstance = 0;
        }

        LeaveCriticalSection(&SddlSidLookupCritical);

        return TRUE;
        break;
    }

    //
    // open LSA to query domain and DNS information at once
    // because some domain/local relative SIDs will be initialized
    // if for some reason that the domain/DNS information can't be
    // queried, the relative SIDs will be invalid for this moment.
    //
    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );

    Status = LsaOpenPolicy( NULL, &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaPolicyHandle );

    if ( NT_SUCCESS(Status) ) {

        Status = LsaQueryInformationPolicy( LsaPolicyHandle,
                                            PolicyDnsDomainInformation,
                                            ( PVOID * )&DnsDomainInfo );

        Status = LsaQueryInformationPolicy( LsaPolicyHandle,
                                            PolicyAccountDomainInformation,
                                            ( PVOID * )&DomainInfo );

        LsaClose( LsaPolicyHandle );
    }

    //
    // If the list of sids hasn't been built, do it now
    //
    // JINHUANG 3/26 BVT break,
    // see comments above always try to initialization table
    // but skip the ones already initialized for performance
    //
    for ( i = 0;
          i < sizeof( SidLookup ) / sizeof( STRSD_SID_LOOKUP ); i++ ) {

        if ( STRSD_REINITIALIZE_ENTER == InitFlag ) {
            SidLookup[ i ].Valid = FALSE;
        }

        if ( SidLookup[ i ].Valid == TRUE &&
             SidLookup[ i ].Sid != NULL ) {
            //
            // this one is already initialized
            //
            continue;
        }

        SidLookup[ i ].Sid = ( PSID )SidLookup[ i ].SidBuff;
        Status = STATUS_SUCCESS;

        switch ( SidLookup[ i ].SidType ) {
        case ST_DOMAIN_RELATIVE:

            if ( DnsDomainInfo != NULL && DnsDomainInfo->Sid != NULL ) {

                RtlCopyMemory( SidLookup[ i ].Sid, DnsDomainInfo->Sid,
                               RtlLengthSid( DnsDomainInfo->Sid ) );
                ( ( PISID )( SidLookup[ i ].Sid ) )->SubAuthorityCount++;
                *( RtlSubAuthoritySid( SidLookup[ i ].Sid,
                                       *( RtlSubAuthorityCountSid( DnsDomainInfo->Sid ) ) ) ) =
                                       SidLookup[ i ].Rid;
                SidLookup[ i ].Valid = TRUE;

            }

            break;

        case ST_ROOT_DOMAIN_RELATIVE:
            //
            // will be initialized on demand
            //
            break;

        case ST_WORLD:
            RtlInitializeSid( SidLookup[ i ].Sid, &UaspWorldAuthority, 1 );
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 0 ) ) = SidLookup[ i ].Rid;
            SidLookup[ i ].Valid = TRUE;
            break;

        case ST_LOCALSY:
            RtlInitializeSid( SidLookup[ i ].Sid, &UaspLocalAuthority, 1 );
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 0 ) ) = SidLookup[ i ].Rid;
            SidLookup[ i ].Valid = TRUE;
            break;

        case ST_LOCAL:
            if ( DomainInfo != NULL && DomainInfo->DomainSid ) {

                RtlCopyMemory( SidLookup[ i ].Sid, DomainInfo->DomainSid,
                               RtlLengthSid( DomainInfo->DomainSid ) );

                ( ( PISID )( SidLookup[ i ].Sid ) )->SubAuthorityCount++;
                *( RtlSubAuthoritySid( SidLookup[ i ].Sid,
                                       *( RtlSubAuthorityCountSid( DomainInfo->DomainSid ) ) ) ) =
                                       SidLookup[ i ].Rid;
                SidLookup[ i ].Valid = TRUE;
            }
            break;

        case ST_CREATOR:
            RtlInitializeSid( SidLookup[ i ].Sid, &UaspCreatorAuthority, 1 );
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 0 ) ) = SidLookup[ i ].Rid;
            SidLookup[ i ].Valid = TRUE;
            break;

        case ST_NTAUTH:
            RtlInitializeSid( SidLookup[ i ].Sid, &UaspNtAuthority, 1 );
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 0 ) ) = SidLookup[ i ].Rid;
            SidLookup[ i ].Valid = TRUE;
            break;

        case ST_BUILTIN:
            RtlInitializeSid( SidLookup[ i ].Sid, &UaspNtAuthority, 2 );
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 0 ) ) = SECURITY_BUILTIN_DOMAIN_RID;
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 1 ) ) = SidLookup[ i ].Rid;
            SidLookup[ i ].Valid = TRUE;
            break;

        }
    }

    LsaFreeMemory( DomainInfo );
    LsaFreeMemory( DnsDomainInfo );

    LeaveCriticalSection(&SddlSidLookupCritical);

    return TRUE;
}


BOOL
APIENTRY
ConvertStringSDToSDRootDomainA(
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
{
    UNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL Result;

    if ( NULL == StringSecurityDescriptor ||
         NULL == SecurityDescriptor ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitAnsiString( &AnsiString, StringSecurityDescriptor );

    Status = SddlpAnsiStringToUnicodeString(&Unicode,                                                                                                            
                                            &AnsiString);

    if ( !NT_SUCCESS( Status ) ) {

        BaseSetLastNTError( Status );

        return FALSE;

    }

    Result = ConvertStringSDToSDRootDomainW( RootDomainSid,
                                           ( LPCWSTR )Unicode.Buffer,
                                           StringSDRevision,
                                           SecurityDescriptor,
                                           SecurityDescriptorSize);

    LocalFree( Unicode.Buffer );

    if ( Result ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( Result );

}

BOOL
APIENTRY
ConvertStringSDToSDRootDomainW(
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
{

    DWORD Err = ERROR_SUCCESS;

    //
    // Little elementary parameter checking...
    //
    if ( StringSecurityDescriptor == NULL || SecurityDescriptor == NULL ) {

        Err = ERROR_INVALID_PARAMETER;

    } else {

        switch ( StringSDRevision ) {
        case SDDL_REVISION_1:

            Err = LocalConvertStringSDToSD_Rev1( RootDomainSid,  // root domain sid
                                                 NULL,  // no domain sid is provided for this API
                                                 TRUE, // default to domain for EA/SA if root domain sid is not provided
                                                 StringSecurityDescriptor,
                                                 SecurityDescriptor,
                                                 SecurityDescriptorSize);
            break;

        default:

            Err = ERROR_UNKNOWN_REVISION;
            break;
        }

    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}

BOOL
APIENTRY
ConvertSDToStringSDRootDomainA(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPSTR  *StringSecurityDescriptor OPTIONAL,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    )
{
    LPWSTR StringSecurityDescriptorW = NULL;
    ULONG AnsiLen, WideLen = 0;
    BOOL ReturnValue ;

    if ( StringSecurityDescriptor == NULL ||
         0 == SecurityInformation ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    ReturnValue = ConvertSDToStringSDRootDomainW(
                      RootDomainSid,
                      SecurityDescriptor,
                      RequestedStringSDRevision,
                      SecurityInformation,
                      &StringSecurityDescriptorW,
                      &WideLen );

    if ( ReturnValue ) {


        AnsiLen = WideCharToMultiByte( CP_ACP,
                                       0,
                                       StringSecurityDescriptorW,
                                       WideLen + 1,
                                       *StringSecurityDescriptor,
                                       0,
                                       NULL,
                                       NULL );

        if ( AnsiLen != 0 ) {

            *StringSecurityDescriptor = LocalAlloc( LMEM_FIXED, AnsiLen );

            if ( *StringSecurityDescriptor == NULL ) {

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                ReturnValue = FALSE;

            } else {

                AnsiLen = WideCharToMultiByte( CP_ACP,
                                               0,
                                               StringSecurityDescriptorW,
                                               WideLen + 1,
                                               *StringSecurityDescriptor,
                                               AnsiLen,
                                               NULL,
                                               NULL );
                ASSERT( AnsiLen != 0 );

                if ( AnsiLen == 0 ) {

                    LocalFree(*StringSecurityDescriptor);
                    *StringSecurityDescriptor = NULL;

                    ReturnValue = FALSE;
                }

                //
                // jinhuang
                // output the length (optional)
                //
                if ( StringSecurityDescriptorLen ) {
                    *StringSecurityDescriptorLen = AnsiLen;
                }

            }

        } else {

            ReturnValue = FALSE;
        }

        LocalFree(StringSecurityDescriptorW);

    }

    if ( ReturnValue ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( ReturnValue );

}

BOOL
APIENTRY
ConvertSDToStringSDRootDomainW(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPWSTR  *StringSecurityDescriptor OPTIONAL,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    )
{

    DWORD Err = ERROR_SUCCESS;

    //
    // A little parameter checking...
    //
    if ( SecurityDescriptor == NULL || StringSecurityDescriptor == NULL ||
         SecurityInformation == 0 ) {

        Err =  ERROR_INVALID_PARAMETER;

    } else {

        switch ( RequestedStringSDRevision ) {
        case SDDL_REVISION_1:

            Err = LocalConvertSDToStringSD_Rev1( RootDomainSid,  // root domain sid
                                                 SecurityDescriptor,
                                                 SecurityInformation,
                                                 StringSecurityDescriptor,
                                                 StringSecurityDescriptorLen );
            break;

        default:
            Err = ERROR_UNKNOWN_REVISION;
            break;
        }

    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS);

}

BOOL
SddlpGetRootDomainSid(void)
{
    //
    // get root domain sid, save it in RootDomSidBuf (global)
    // this function is called within the critical section
    //
    // 1) ldap_open to the DC of interest.
    // 2) you do not need to ldap_connect - the following step works anonymously
    // 3) read the operational attribute rootDomainNamingContext and provide the
    //    operational control LDAP_SERVER_EXTENDED_DN_OID as defined in sdk\inc\ntldap.h.


    DWORD               Win32rc=NO_ERROR;
    BOOL                bRetValue=FALSE;

    HINSTANCE                   hLdapDll=NULL;
    PFN_LDAP_OPEN               pfnLdapOpen=NULL;
    PFN_LDAP_UNBIND             pfnLdapUnbind=NULL;
    PFN_LDAP_SEARCH             pfnLdapSearch=NULL;
    PFN_LDAP_FIRST_ENTRY        pfnLdapFirstEntry=NULL;
    PFN_LDAP_GET_VALUE          pfnLdapGetValue=NULL;
    PFN_LDAP_MSGFREE            pfnLdapMsgFree=NULL;
    PFN_LDAP_VALUE_FREE         pfnLdapValueFree=NULL;
    PFN_LDAP_MAP_ERROR          pfnLdapMapError=NULL;

    PLDAP                       phLdap=NULL;

    LDAPControlA    serverControls = { LDAP_SERVER_EXTENDED_DN_OID,
                                       { 0, (PCHAR) NULL },
                                       TRUE
                                     };
    LPSTR           Attribs[] = { LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT, NULL };

    PLDAPControlA   rServerControls[] = { &serverControls, NULL };
    PLDAPMessage    pMessage = NULL;
    LDAPMessage     *pEntry = NULL;
    PCHAR           *ppszValues=NULL;

    LPSTR           pSidStart, pSidEnd, pParse;
    BYTE            *pDest;
    BYTE            OneByte;

    hLdapDll = LoadLibraryA("wldap32.dll");

    if ( hLdapDll) {
        pfnLdapOpen = (PFN_LDAP_OPEN)GetProcAddress(hLdapDll,
                                                    "ldap_openA");
        pfnLdapUnbind = (PFN_LDAP_UNBIND)GetProcAddress(hLdapDll,
                                                      "ldap_unbind");
        pfnLdapSearch = (PFN_LDAP_SEARCH)GetProcAddress(hLdapDll,
                                                    "ldap_search_ext_sA");
        pfnLdapFirstEntry = (PFN_LDAP_FIRST_ENTRY)GetProcAddress(hLdapDll,
                                                      "ldap_first_entry");
        pfnLdapGetValue = (PFN_LDAP_GET_VALUE)GetProcAddress(hLdapDll,
                                                    "ldap_get_valuesA");
        pfnLdapMsgFree = (PFN_LDAP_MSGFREE)GetProcAddress(hLdapDll,
                                                      "ldap_msgfree");
        pfnLdapValueFree = (PFN_LDAP_VALUE_FREE)GetProcAddress(hLdapDll,
                                                    "ldap_value_freeA");
        pfnLdapMapError = (PFN_LDAP_MAP_ERROR)GetProcAddress(hLdapDll,
                                                      "LdapMapErrorToWin32");
    }

    if ( pfnLdapOpen == NULL ||
         pfnLdapUnbind == NULL ||
         pfnLdapSearch == NULL ||
         pfnLdapFirstEntry == NULL ||
         pfnLdapGetValue == NULL ||
         pfnLdapMsgFree == NULL ||
         pfnLdapValueFree == NULL ||
         pfnLdapMapError == NULL ) {

        Win32rc = ERROR_PROC_NOT_FOUND;

    } else {

        //
        // bind to ldap
        //
        phLdap = (*pfnLdapOpen)(NULL, LDAP_PORT);

        if ( phLdap == NULL ) {

            Win32rc = ERROR_FILE_NOT_FOUND;

        }
    }

    if ( NO_ERROR == Win32rc ) {
        //
        // now get the ldap handle,
        //

        Win32rc = (*pfnLdapSearch)(
                        phLdap,
                        "",
                        LDAP_SCOPE_BASE,
                        "(objectClass=*)",
                        Attribs,
                        0,
                        (PLDAPControlA *)&rServerControls,
                        NULL,
                        NULL,
                        10000,
                        &pMessage);

        if( Win32rc == NO_ERROR && pMessage ) {

            Win32rc = ERROR_SUCCESS;

            pEntry = (*pfnLdapFirstEntry)(phLdap, pMessage);

            if(pEntry == NULL) {

                Win32rc = (*pfnLdapMapError)( phLdap->ld_errno );

            } else {
                //
                // Now, we'll have to get the values
                //
                ppszValues = (*pfnLdapGetValue)(phLdap,
                                              pEntry,
                                              Attribs[0]);

                if( ppszValues == NULL) {

                    Win32rc = (*pfnLdapMapError)( phLdap->ld_errno );

                } else if ( ppszValues[0] && ppszValues[0][0] != '\0' ) {

                    //
                    // ppszValues[0] is the value to parse.
                    // The data will be returned as something like:

                    // <GUID=278676f8d753d211a61ad7e2dfa25f11>;<SID=010400000000000515000000828ba6289b0bc11e67c2ef7f>;DC=colinbrdom1,DC=nttest,DC=microsoft,DC=com

                    // Parse through this to find the <SID=xxxxxx> part.  Note that it may be missing, but the GUID= and trailer should not be.
                    // The xxxxx represents the hex nibbles of the SID.  Translate to the binary form and case to a SID.


                    pSidStart = strstr(ppszValues[0], "<SID=");

                    if ( pSidStart ) {
                        //
                        // find the end of this SID
                        //
                        pSidEnd = strchr(pSidStart, '>');

                        if ( pSidEnd ) {

                            EnterCriticalSection(&SddlSidLookupCritical);

                            pParse = pSidStart + 5;
                            pDest = (BYTE *)RootDomSidBuf;

                            while ( pParse < pSidEnd-1 ) {

                                if ( *pParse >= '0' && *pParse <= '9' ) {
                                    OneByte = (BYTE) ((*pParse - '0') * 16);
                                } else {
                                    OneByte = (BYTE) ( (tolower(*pParse) - 'a' + 10) * 16 );
                                }

                                if ( *(pParse+1) >= '0' && *(pParse+1) <= '9' ) {
                                    OneByte += (BYTE) ( *(pParse+1) - '0' ) ;
                                } else {
                                    OneByte += (BYTE) ( tolower(*(pParse+1)) - 'a' + 10 ) ;
                                }

                                *pDest = OneByte;
                                pDest++;
                                pParse += 2;
                            }

                            RootDomInited = TRUE;

                            LeaveCriticalSection(&SddlSidLookupCritical);

                            bRetValue = TRUE;

                        } else {
                            Win32rc = ERROR_OBJECT_NOT_FOUND;
                        }
                    } else {
                        Win32rc = ERROR_OBJECT_NOT_FOUND;
                    }

                    (*pfnLdapValueFree)(ppszValues);

                } else {
                    Win32rc = ERROR_OBJECT_NOT_FOUND;
                }
            }

            (*pfnLdapMsgFree)(pMessage);
        }

    }

    //
    // even though it's not binded, use unbind to close
    //
    if ( phLdap != NULL && pfnLdapUnbind )
        (*pfnLdapUnbind)(phLdap);

    if ( hLdapDll ) {
        FreeLibrary(hLdapDll);
    }

    SetLastError(Win32rc);

    return bRetValue;
}

BOOL
APIENTRY
ConvertStringSDToSDDomainA(
    IN  PSID DomainSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
/*
Routine Description:

    This API is exported from advapi32.dll.
    This is the ANSI version of ConvertStringSDToSDDomainW and it calls the latter API.
    See description for ConvertStringSDToSDDomainW.

*/
{
    UNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL Result;

    if ( NULL == StringSecurityDescriptor ||
         NULL == SecurityDescriptor ||
         NULL == DomainSid ||
         !RtlValidSid(DomainSid) || 
         (RootDomainSid && !RtlValidSid(RootDomainSid)) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitAnsiString( &AnsiString, StringSecurityDescriptor );

    Status = SddlpAnsiStringToUnicodeString(&Unicode,                                                                                                        
                                            &AnsiString);

    if ( !NT_SUCCESS( Status ) ) {

        BaseSetLastNTError( Status );

        return FALSE;

    }

    Result = ConvertStringSDToSDDomainW( DomainSid,
                                         RootDomainSid,                                           
                                         ( LPCWSTR )Unicode.Buffer,                                           
                                         StringSDRevision,                                           
                                         SecurityDescriptor,                                           
                                         SecurityDescriptorSize);

    LocalFree( Unicode.Buffer );

    if ( Result ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( Result );

}

BOOL
APIENTRY
ConvertStringSDToSDDomainW(
    IN  PSID DomainSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
/*
Routine Description:

    This API is exported from advapi32.dll. It is similar to ConvertSDToStringSDRootDomainW
    except that it takes in a required DomainSid parameter. Domain relative trustees will be
    resolved w.r.t. DomainSid.


Arguments:

    IN      PSID DomainSid                            - pointer to the domain sid w.r.t. which
                                                        ST_DOMAIN_RELATIVE type trustees are resolved against
    IN      PSID RootDomainSid OPTIONAL               - pointer to root domain sid w.r.t. which  
                                                        ST_ROOT_DOMAIN_RELATIVE type trustees are resolved against
                                                        if this is NULL, the local m/c's root domain is used
    IN      LPCWSTR StringSecurityDescriptor          - the input SDDL string
    IN      DWORD StringSDRevision                    - SDDL revision, only SDDL_REVISION_1 is supported
    OUT     PSECURITY_DESCRIPTOR  *SecurityDescriptor - pointer to the constructed security descriptor
    OUT     PULONG  SecurityDescriptorSize OPTIONAL   - size of the constructed security descriptor


Return Value:

    TRUE if succeeded else FALSE. Caller can use GetLastError() to retrieve the error code.
*/
{

    DWORD Err = ERROR_SUCCESS;

    //
    // Little elementary parameter checking...
    //
    if ( StringSecurityDescriptor == NULL ||
         SecurityDescriptor == NULL ||
         DomainSid == NULL ||
         !RtlValidSid(DomainSid) ||
        (RootDomainSid && !RtlValidSid(RootDomainSid)) ) {

        Err = ERROR_INVALID_PARAMETER;

    } else {

        switch ( StringSDRevision ) {
        case SDDL_REVISION_1:

            Err = LocalConvertStringSDToSD_Rev1( RootDomainSid, // no root domain sid maybe provided for this API
                                                 DomainSid, // domain sid
                                                 FALSE,     // domain sid is required
                                                 StringSecurityDescriptor,
                                                 SecurityDescriptor,
                                                 SecurityDescriptorSize);
            break;

        default:

            Err = ERROR_UNKNOWN_REVISION;
            break;
        }

    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}


NTSTATUS
SddlpAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString
    )

/*++

Routine Description:

    See RtlAnsiStringToUnicodeString - only difference is that Unicode Length
    is immaterial here. When using this API, never depend on a well formed 
    UNICODE_STRING - only rely on the Buffer field.
    
    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the ansi source string. Should be freed outside using LocalFree()

    SourceString - Supplies the ansi source string that is to be
        converted to unicode.

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index;
    NTSTATUS st;

    UnicodeLength = RtlAnsiStringToUnicodeSize(SourceString);

    DestinationString->Buffer = (PWSTR) LocalAlloc(LMEM_ZEROINIT, UnicodeLength);
        
    if ( !DestinationString->Buffer ) {
        return STATUS_NO_MEMORY;
    }

    st = RtlMultiByteToUnicodeN(
             DestinationString->Buffer,
             UnicodeLength - sizeof(UNICODE_NULL),
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
            
        LocalFree(DestinationString->Buffer);

        DestinationString->Buffer = NULL;
        
        return st;
    }

    DestinationString->Buffer[Index / sizeof(WCHAR)] = UNICODE_NULL;

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\regdat16.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regdat16.c

Abstract:

    This module contains code for reading the Windows 3.1 registry
    file (REG.DAT)

Author:

    Steve Wood (stevewo) 22-Feb-1993

Revision History:

--*/

#include "advapi.h"
#include <stdio.h>

#include <winbasep.h>
#include "win31io.h"

// #define SHOW_TREE_MIGRATION

#define MAX_LEVELS 64

PREG_HEADER16
LoadRegistry16(
    PWSTR RegistryFileName
    )
{
    HANDLE File, Mapping;
    LPVOID Base;

    File = CreateFileW( RegistryFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                      );

    if (File == INVALID_HANDLE_VALUE) {
        return NULL;
        }


    Mapping = CreateFileMapping( File,
                                 NULL,
                                 PAGE_WRITECOPY,
                                 0,
                                 0,
                                 NULL
                               );
    CloseHandle( File );
    if (Mapping == NULL) {
        return NULL;
        }


    Base = MapViewOfFile( Mapping,
                          FILE_MAP_COPY,
                          0,
                          0,
                          0
                        );
    CloseHandle( Mapping );
    return (PREG_HEADER16)Base;
}


BOOL
UnloadRegistry16(
    PREG_HEADER16 Registry
    )
{
    return UnmapViewOfFile( (LPVOID)Registry );
}


typedef struct _REG16_PATH_SUBST {
    ULONG cbOldValue;
    LPSTR OldValue;
    LPSTR NewValue;
} REG16_PATH_SUBST, *PREG16_PATH_SUBST;

REG16_PATH_SUBST Reg16PathSubstitutes[] = {
    {10, "mciole.dll",   "mciole16.dll"},
    {11, "mplayer.exe",  "mplay32.exe" },
    {12, "packager.exe", "packgr32.exe"},
    {12, "soundrec.exe", "sndrec32.exe"},
    {0, NULL, NULL}
};

typedef struct _REG16_WALK_STATE {
    HANDLE KeyHandle;
    WORD NodeIndex;
    WORD Reserved;
} REG16_WALK_STATE, *PREG16_WALK_STATE;

char *szBlanks = "                                                                                 ";

BOOL
CreateRegistryClassesFromRegistry16(
    HANDLE SoftwareRoot,
    PREG_HEADER16 Registry
    )
{
    PREG_KEY16 KeyNode;
    PREG_STRING16 KeyNameString, KeyValueString;
    PREG_NODE16 NodeTable;
    PCH StringTable;
    int i;
    DWORD Level;
    REG16_WALK_STATE State[ MAX_LEVELS ];
    ANSI_STRING AnsiString;
    UNICODE_STRING KeyName;
    UNICODE_STRING KeyValue;
    UNICODE_STRING ValueName;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG CreateDisposition;
    PREG16_PATH_SUBST PathSubst;

    RtlInitUnicodeString( &ValueName, NULL );

    NodeTable = (PREG_NODE16)((PBYTE)Registry + Registry->dwNodeTable);
    StringTable = (PCH)Registry + Registry->dwStringValue;

    i = NodeTable[ 0 ].key.iChild;
    Level = 0;
    while (i != 0) {
        KeyNode = &NodeTable[ i ].key;
        KeyNameString = &NodeTable[ KeyNode->iKey ].str;
        AnsiString.Length = KeyNameString->cb;
        AnsiString.MaximumLength = AnsiString.Length;
        AnsiString.Buffer = StringTable + KeyNameString->irgb;
        if (Level == 0 && *AnsiString.Buffer == '.') {
            AnsiString.Buffer += 1;
            AnsiString.Length -= 1;
            }
        RtlAnsiStringToUnicodeString( &KeyName, &AnsiString, TRUE );

#ifdef SHOW_TREE_MIGRATION
        DbgPrint( "%.*s%wZ", Level * 4, szBlanks, &KeyName );
#endif

        InitializeObjectAttributes( &ObjectAttributes,
                                    &KeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    Level == 0 ? SoftwareRoot : State[ Level-1 ].KeyHandle,
                                    NULL
                                  );
        Status = NtCreateKey( &State[ Level ].KeyHandle,
                              STANDARD_RIGHTS_WRITE |
                                KEY_QUERY_VALUE |
                                KEY_ENUMERATE_SUB_KEYS |
                                KEY_SET_VALUE |
                                KEY_CREATE_SUB_KEY,
                              &ObjectAttributes,
                              0,
                              NULL,
                              0,
                              &CreateDisposition
                            );

        RtlFreeUnicodeString( &KeyName );
        if (!NT_SUCCESS( Status )) {
#ifdef SHOW_TREE_MIGRATION
            DbgPrint( " *** CreateKey failed with Status == %x\n", Status );
#endif
            BaseSetLastNTError( Status );
            break;
            }
#ifdef SHOW_TREE_MIGRATION
        DbgPrint( "%s\n", CreateDisposition == REG_CREATED_NEW_KEY ? " *** NEW ***" : "" );
#endif

        if (KeyNode->iValue != 0) {
            ULONG cb;
            LPSTR s, Src, Dst;

            KeyValueString = &NodeTable[ KeyNode->iValue ].str;
            cb = KeyValueString->cb;
            Src = StringTable + KeyValueString->irgb;
            Dst = RtlAllocateHeap( RtlProcessHeap(), 0, 2*(cb+1) );
            if (Dst != NULL) {
                AnsiString.Length = 0;
                AnsiString.Buffer = Dst;
                while (cb) {
                    PathSubst = &Reg16PathSubstitutes[ 0 ];
                    while (PathSubst->OldValue) {
                        if (cb >= PathSubst->cbOldValue &&
                            !_strnicmp( Src, PathSubst->OldValue, PathSubst->cbOldValue )
                           ) {
                            *Dst = '\0';
                            while (Dst > AnsiString.Buffer) {
                                if (Dst[ -1 ] <= ' ') {
                                    break;
                                    }
                                else {
                                    Dst -= 1;
                                    }
                                }

                            s = PathSubst->NewValue;
#ifdef SHOW_TREE_MIGRATION
                            DbgPrint( " Found '%s%s' changed to '%s' ", Dst, PathSubst->OldValue, PathSubst->NewValue );
#else
                            KdPrint(( "ADVAPI: Found '%s%s' changed to '%s'\n", Dst, PathSubst->OldValue, PathSubst->NewValue ));
#endif
                            Src += PathSubst->cbOldValue;
                            cb -= PathSubst->cbOldValue;
                            while (*Dst = *s++) {
                                Dst += 1;
                                }

                            break;
                            }
                        else {
                            PathSubst += 1;
                            }
                        }

                    if (PathSubst->OldValue == NULL) {
                        *Dst++ = *Src++;
                        cb -= 1;
                        }
                    }
                *Dst = '\0';

                AnsiString.Length = (USHORT)(Dst - AnsiString.Buffer);
                AnsiString.MaximumLength = (USHORT)(AnsiString.Length + 1);
                RtlAnsiStringToUnicodeString( &KeyValue, &AnsiString, TRUE );
                RtlFreeHeap( RtlProcessHeap(), 0, AnsiString.Buffer );

#ifdef SHOW_TREE_MIGRATION
                DbgPrint( "%.*s= (%u, %u) %wZ", (Level+1) * 4, szBlanks, KeyValueString->cb, cb, &KeyValue );
#endif

                Status = NtSetValueKey( State[ Level ].KeyHandle,
                                        &ValueName,
                                        0,
                                        REG_SZ,
                                        KeyValue.Buffer,
                                        KeyValue.Length + sizeof( UNICODE_NULL )
                                      );
                RtlFreeUnicodeString( &KeyValue );

                if (!NT_SUCCESS( Status )) {
#ifdef SHOW_TREE_MIGRATION
                    DbgPrint( " *** SetValueKey failed with Status == %x\n", Status );
#endif
                    BaseSetLastNTError( Status );
                    break;
                    }
#ifdef SHOW_TREE_MIGRATION
                DbgPrint( "\n" );
#endif
                }
            }

        if (KeyNode->iChild != 0) {
            State[ Level++ ].NodeIndex = KeyNode->iNext;
            State[ Level ].KeyHandle = NULL;
            i = KeyNode->iChild;
            }
        else {
            NtClose( State[ Level ].KeyHandle );
            if (KeyNode->iNext != 0) {
                i = KeyNode->iNext;
                }
            else {
                while (Level != 0) {
                    Level -= 1;
                    NtClose( State[ Level ].KeyHandle );

                    if (i = State[ Level ].NodeIndex) {
                        break;
                        }
                    }
                }
            }
        }

    if (Level == 0) {
        return TRUE;
        }


    while (Level != 0 && (i = State[ --Level ].NodeIndex) == 0) {
        NtClose( State[ Level ].KeyHandle );
        }

    return FALSE;
}


#if DBG
char *Blanks = "                                                                                 ";

BOOL
DumpRegistry16(
    PREG_HEADER16 Registry
    )
{
    PREG_KEY16 KeyNode;
    PREG_STRING16 StringNode, KeyNameString, KeyValueString;
    PREG_NODE16 NodeTable;
    PCH StringTable, String, KeyName, KeyValue;
    int i, j;
    DWORD Level;
    WORD LevelNode[ MAX_LEVELS ];

    NodeTable = (PREG_NODE16)((PBYTE)Registry + Registry->dwNodeTable);
    StringTable = (PCH)Registry + Registry->dwStringValue;

    DbgPrint( "Windows 3.1 Registry data at %08x\n", Registry );
    DbgPrint( "    dwMagic:       %08x\n", Registry->dwMagic );
    DbgPrint( "    dwVersion:     %08x\n", Registry->dwVersion );
    DbgPrint( "    dwHdrSize:     %08x\n", Registry->dwHdrSize );
    DbgPrint( "    dwNodeTable:   %08x\n", Registry->dwNodeTable );
    DbgPrint( "    dwNTSize:      %08x\n", Registry->dwNTSize );
    DbgPrint( "    dwStringValue: %08x\n", Registry->dwStringValue );
    DbgPrint( "    dwSVSize:      %08x\n", Registry->dwSVSize );
    DbgPrint( "    nHash:         %04x\n", Registry->nHash );
    DbgPrint( "    iFirstFree:    %04x\n", Registry->iFirstFree );

    i = NodeTable[ 0 ].key.iChild;
    Level = 0;
    while (i != 0) {
        KeyNode = &NodeTable[ i ].key;
        KeyNameString = &NodeTable[ KeyNode->iKey ].str;
        KeyName = StringTable + KeyNameString->irgb;
        DbgPrint( "%.*s%.*s\n",
                  Level * 4,
                  Blanks,
                  KeyNameString->cb,
                  KeyName
                );
        if (KeyNode->iValue != 0) {
            KeyValueString = &NodeTable[ KeyNode->iValue ].str;
            KeyValue = StringTable + KeyValueString->irgb;
            DbgPrint( "%.*s= %.*s\n",
                      (Level+1) * 4,
                      Blanks,
                      KeyValueString->cb,
                      KeyValue
                    );
            }

        if (KeyNode->iChild != 0) {
            LevelNode[ Level++ ] = KeyNode->iNext;
            i = KeyNode->iChild;
            }
        else
        if (KeyNode->iNext != 0) {
            i = KeyNode->iNext;
            }
        else {
            while (Level != 0 && (i = LevelNode[ --Level ]) == 0) {
                ;
                }
            }
        }

    return TRUE;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\pnpapi.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    pnpapi.c

Abstract:

    This module contains the user-mode plug-and-play API stubs.

Author:

    Paula Tomlinson (paulat) 9-18-1995

Environment:

    User-mode only.

Revision History:

    18-Sept-1995     paulat

        Creation and initial implementation.

--*/

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#define MAX_PROFILEID_LEN     5
#define MAX_UUID_LEN          39


//
// includes
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>
#include <stdlib.h>
#include <stdio.h>
#include <wtypes.h>


//
// private prototypes
//
PSTR
UnicodeToMultiByte(
    IN PCWSTR UnicodeString,
    IN UINT   Codepage
    );

PWSTR
MultiByteToUnicode(
    IN PCSTR String,
    IN UINT  Codepage
    );

RPC_STATUS
GuidToString(
   UUID   *Uuid,
   LPTSTR StringGuid
   );


//
// global data
//
WCHAR pszRegIDConfigDB[] = L"System\\CurrentControlSet\\Control\\IDConfigDB";

WCHAR pszRegKnownDockingStates[] =  L"Hardware Profiles";
WCHAR pszRegCurrentConfig[] =       L"CurrentConfig";
WCHAR pszRegDefaultFriendlyName[] = L"Noname Hardware Profile";
WCHAR pszRegHwProfileGuid[] =       L"HwProfileGuid";
WCHAR pszRegFriendlyName[] =        L"FriendlyName";
WCHAR pszRegDockState[] =           L"DockState";
WCHAR pszRegDockingState[] =        L"DockingState";
WCHAR pszCurrentDockInfo[] =        L"CurrentDockInfo";


BOOL
GetCurrentHwProfileW (
    OUT LPHW_PROFILE_INFOW  lpHwProfileInfo
    )

/*++

Routine Description:


Arguments:

    lpHwProfileInfo  Points to a HW_PROFILE_INFO structure that will receive
                     the information for the current hardware profile.

Return Value:

    If the function succeeds, the return value is TRUE.  If the function
    fails, the return value is FALSE.  To get extended error information,
    call GetLastError.

--*/

{
   BOOL     Status = TRUE;
   WCHAR    RegStr[MAX_PATH];
   HKEY     hKey = NULL, hCfgKey = NULL;
   HKEY     hCurrentDockInfoKey = NULL;
   ULONG    ulCurrentConfig = 1, ulSize = 0;
   UUID     NewGuid;


   try {
      //
      // validate parameter
      //
      if (lpHwProfileInfo == NULL) {
         SetLastError(ERROR_INVALID_PARAMETER);
         Status = FALSE;
         goto Clean0;
      }
      

      //
      // open the IDConfigDB key
      //
      if (RegOpenKeyEx(
               HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
               KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
	
         SetLastError(ERROR_REGISTRY_CORRUPT);
         Status = FALSE;
         goto Clean0;
      }
      
      //
      // retrieve the current config id
      //
      ulSize = sizeof(ULONG);
      if (RegQueryValueEx(hKey, pszRegCurrentConfig, NULL, NULL,
                          (LPBYTE)&ulCurrentConfig, &ulSize) != ERROR_SUCCESS) {          
          SetLastError(ERROR_REGISTRY_CORRUPT);
          Status = FALSE;
          goto Clean0;
      }

      //
      // open the profile key for the current configuration
      //
      _snwprintf(RegStr, MAX_PATH, L"%s\\%04u",
                 pszRegKnownDockingStates,
                 ulCurrentConfig);
      
      if (RegOpenKeyEx(hKey, RegStr, 0, KEY_QUERY_VALUE,
                       &hCfgKey) != ERROR_SUCCESS) {
          SetLastError(ERROR_REGISTRY_CORRUPT);
          Status = FALSE;
          goto Clean0;
      }
      
      //
      // retrieve the dock state for the current profile
      //      
      if (RegOpenKeyEx(hKey, pszCurrentDockInfo, 0,  KEY_QUERY_VALUE,
                       &hCurrentDockInfoKey) != ERROR_SUCCESS) {
          //
          // No CurrentDockInfo Key, something's wrong.
          //
          SetLastError(ERROR_REGISTRY_CORRUPT);
          Status = FALSE;
          goto Clean0;
      }      
      
      //
      // Look in CurrentDockInfo for
      // a hardware determined DockingState value.
      //
      ulSize = sizeof(ULONG);                  
      if ((RegQueryValueEx(hCurrentDockInfoKey,
                           pszRegDockingState, 
                           NULL, 
                           NULL,
                           (LPBYTE)&lpHwProfileInfo->dwDockInfo,
                           &ulSize) != ERROR_SUCCESS)
          || (!lpHwProfileInfo->dwDockInfo) 
          || ((lpHwProfileInfo->dwDockInfo & DOCKINFO_UNDOCKED) && 
              (lpHwProfileInfo->dwDockInfo & DOCKINFO_DOCKED))) {          

          //
          // If there's no such value, or the value was set to 0 (unspported),
          // or if the value is "unknown", resort to user supplied docking info.
          // Look under the IDConfigDB profile for a user set DockState value.
          //                    
          if ((RegQueryValueEx(hCfgKey, pszRegDockState, NULL, NULL,
                               (LPBYTE)&lpHwProfileInfo->dwDockInfo,
                               &ulSize) != ERROR_SUCCESS)
              || (!lpHwProfileInfo->dwDockInfo)) {
              
              //
              // If there's no such value, or the value was set to 0,
              // there is no user specified docking state to resort to;
              // return the "user-supplied unknown" docking state.
              //
              lpHwProfileInfo->dwDockInfo =
                  DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED | DOCKINFO_UNDOCKED;
          }
      }
      
      //
      // retrieve the profile guid.  if we can't get one, set it to NULL
      //
      ulSize = HW_PROFILE_GUIDLEN * sizeof(WCHAR);
      if (RegQueryValueEx(hCfgKey, pszRegHwProfileGuid, NULL, NULL,
                          (LPBYTE)&lpHwProfileInfo->szHwProfileGuid,
                          &ulSize) != ERROR_SUCCESS) {
          lpHwProfileInfo->szHwProfileGuid[0] = '\0';
      }
      
      //
      // retrieve the friendly name.  if we can't get one, set it to NULL
      //
      ulSize = MAX_PROFILE_LEN * sizeof(WCHAR);
      if (RegQueryValueEx(hCfgKey, pszRegFriendlyName, NULL, NULL,
                          (LPBYTE)&lpHwProfileInfo->szHwProfileName,
                          &ulSize) != ERROR_SUCCESS) {
          lpHwProfileInfo->szHwProfileName[0] = '\0';
      }
      
      
   Clean0:
      ;
      
   } except(EXCEPTION_EXECUTE_HANDLER) {
       
       SetLastError(ERROR_INVALID_PARAMETER);
       Status = FALSE;
   }
   
   if (hKey != NULL) RegCloseKey(hKey);
   if (hCfgKey != NULL) RegCloseKey(hCfgKey);
   if (hCurrentDockInfoKey != NULL) RegCloseKey(hCurrentDockInfoKey);
   
   return Status;
   
} // GetCurrentHwProfileW





BOOL
GetCurrentHwProfileA (
    OUT LPHW_PROFILE_INFOA  lpHwProfileInfo
    )

/*++

Routine Description:


Arguments:

    lpHwProfileInfo  Points to a HW_PROFILE_INFO structure that will receive
                     the information for the current hardware profile.

Return Value:

    If the function succeeds, the return value is TRUE.  If the function
    fails, the return value is FALSE.  To get extended error information,
    call GetLastError.

--*/

{
   BOOL              Status = TRUE;
   HW_PROFILE_INFOW  HwProfileInfoW;
   LPSTR             pAnsiString;


   try {
      //
      // validate parameter
      //
      if (lpHwProfileInfo == NULL) {
         SetLastError(ERROR_INVALID_PARAMETER);
         Status = FALSE;
         goto Clean0;
      }

      //
      // call the Unicode version
      //
      if (!GetCurrentHwProfileW(&HwProfileInfoW)) {
         Status = FALSE;
         goto Clean0;
      }

      //
      // on successful return, convert unicode form of struct
      // to ANSI and copy struct members to callers struct
      //
      lpHwProfileInfo->dwDockInfo = HwProfileInfoW.dwDockInfo;

      pAnsiString = UnicodeToMultiByte(
               HwProfileInfoW.szHwProfileGuid, CP_ACP);
      if (!pAnsiString) {
          Status = FALSE;
          goto Clean0;
      }

      lstrcpyA(lpHwProfileInfo->szHwProfileGuid, pAnsiString);
      LocalFree(pAnsiString);

      pAnsiString = UnicodeToMultiByte(
               HwProfileInfoW.szHwProfileName, CP_ACP);
      if (!pAnsiString) {
          Status = FALSE;
          goto Clean0;
      }

      lstrcpyA(lpHwProfileInfo->szHwProfileName, pAnsiString);
      LocalFree(pAnsiString);


      Clean0:
         ;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      SetLastError(ERROR_INTERNAL_ERROR);
      Status = FALSE;
   }

   return Status;

} // GetCurrentHwProfileA





PSTR
UnicodeToMultiByte(
    IN PCWSTR UnicodeString,
    IN UINT   Codepage
    )

/*++

Routine Description:

    Convert a string from unicode to ansi.

Arguments:

    UnicodeString - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if out of memory or invalid codepage.
    Caller can free buffer with MyFree().

--*/

{
    UINT WideCharCount;
    PSTR String;
    UINT StringBufferSize;
    UINT BytesInString;
    PSTR p;

    WideCharCount = lstrlenW(UnicodeString) + 1;

    //
    // Allocate maximally sized buffer.
    // If every unicode character is a double-byte
    // character, then the buffer needs to be the same size
    // as the unicode string. Otherwise it might be smaller,
    // as some unicode characters will translate to
    // single-byte characters.
    //
    StringBufferSize = WideCharCount * sizeof(WCHAR);
    String = (PSTR)LocalAlloc(LPTR, StringBufferSize);
    if(String == NULL) {
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    BytesInString = WideCharToMultiByte(
                        Codepage,
                        0,                      // default composite char behavior
                        UnicodeString,
                        WideCharCount,
                        String,
                        StringBufferSize,
                        NULL,
                        NULL
                        );

    if(BytesInString == 0) {
        LocalFree(String);
        return(NULL);
    }

    //
    // Resize the string's buffer to its correct size.
    // If the realloc fails for some reason the original
    // buffer is not freed.
    //
    if(p = LocalReAlloc(String,BytesInString, LMEM_ZEROINIT | LMEM_MOVEABLE)) {
        String = p;
    }

    return(String);

} // UnicodeToMultiByte




PWSTR
MultiByteToUnicode(
    IN PCSTR String,
    IN UINT  Codepage
    )

/*++

Routine Description:

    Convert a string to unicode.

Arguments:

    String - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if string could not be converted (out of memory or invalid cp)
    Caller can free buffer with MyFree().

--*/

{
    UINT BytesIn8BitString;
    UINT CharsInUnicodeString;
    PWSTR UnicodeString;
    PWSTR p;

    BytesIn8BitString = lstrlenA(String) + 1;

    //
    // Allocate maximally sized buffer.
    // If every character is a single-byte character,
    // then the buffer needs to be twice the size
    // as the 8bit string. Otherwise it might be smaller,
    // as some characters are 2 bytes in their unicode and
    // 8bit representations.
    //
    UnicodeString = (PWSTR)LocalAlloc(LPTR, BytesIn8BitString * sizeof(WCHAR));
    if(UnicodeString == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    CharsInUnicodeString = MultiByteToWideChar(
                                Codepage,
                                MB_PRECOMPOSED,
                                String,
                                BytesIn8BitString,
                                UnicodeString,
                                BytesIn8BitString
                                );

    if(CharsInUnicodeString == 0) {
        LocalFree(UnicodeString);
        return(NULL);
    }

    //
    // Resize the unicode string's buffer to its correct size.
    // If the realloc fails for some reason the original
    // buffer is not freed.
    //
    if(p = (PWSTR)LocalReAlloc(UnicodeString,CharsInUnicodeString*sizeof(WCHAR),
            LMEM_ZEROINIT | LMEM_MOVEABLE)) {

        UnicodeString = p;
    }

    return(UnicodeString);

} // MultiByteToUnicode




RPC_STATUS
GuidToString(
   UUID   *Uuid,
   LPTSTR StringGuid
   )
{
   RPC_STATUS  Status;
   LPTSTR      pTempStringGuid;
   UNICODE_STRING UnicodeStringGuid;

   Status = UuidToString(Uuid, &pTempStringGuid);

   if (Status == RPC_S_OK) {
      //
      // the form we want is all uppercase and with curly brackets around,
      // like what OLE does
      //
      lstrcpy(StringGuid, TEXT("{"));
      lstrcat(StringGuid, pTempStringGuid);
      lstrcat(StringGuid, TEXT("}"));
      RtlInitUnicodeString(&UnicodeStringGuid, StringGuid);
      RtlUpcaseUnicodeString(&UnicodeStringGuid, &UnicodeStringGuid, FALSE);

      RpcStringFree(&pTempStringGuid);
   }

   return Status;

} // GuidToString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\mschapp.c ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    mschapp - MS-CHAP Password Change API

Abstract:

    These APIs correspond to the MS-CHAP RFC -2433 sections 9 and 10. In order
    to develop an MS-CHAP RAS server that works with an NT domain, these APIs
    are required.

    The MS-CHAP change password APIs are exposed through a DLL that is obtained
    from PSS. This DLL is not distributed with NT4.0 or Win2000. It is up to
    the ISV to install this with their product. The DLL name is MSCHAPP.DLL.

    Only wide (Unicode) versions of these apis will be available. These are the
    2 callable APIs:

    *   MSChapSrvChangePassword
    *   MsChapSrvChangePassword2

--*/

#define UNICODE
#define _UNICODE
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <mschapp.h>


//////////////////////////////////////////////////////////////
//                                                          //  
//                                                          //
//         Exported MSChap change password Functions        //
//                                                          //
//                                                          //
//////////////////////////////////////////////////////////////

//critical section for MSChap change password functions                 
CRITICAL_SECTION MSChapChangePassword;

//function pointers for MSChap Functions
HINSTANCE         hSamlib = NULL;

typedef NTSTATUS(* FNSAMCONNECT)(PUNICODE_STRING,
                                   PSAM_HANDLE,
                                   ACCESS_MASK,
                                   POBJECT_ATTRIBUTES);
typedef NTSTATUS(* FNSAMOPENDOMAIN)(SAM_HANDLE,
                                      ACCESS_MASK,
                                      PSID,
                                      PSAM_HANDLE);
typedef NTSTATUS(* FNSAMLOOKUPNAMESINDOMAIN)(SAM_HANDLE,ULONG,PUNICODE_STRING,
                                             PULONG*,PSID_NAME_USE *);
typedef NTSTATUS(* FNSAMOPENUSER)(SAM_HANDLE,ACCESS_MASK,ULONG,PSAM_HANDLE);
typedef NTSTATUS(* FNSAMICHANGEPASSWORDUSER)(SAM_HANDLE,BOOLEAN,PLM_OWF_PASSWORD,PLM_OWF_PASSWORD,
                                             BOOLEAN,PNT_OWF_PASSWORD,PNT_OWF_PASSWORD);
typedef NTSTATUS(* FNSAMICHANGEPASSWORDUSER2)(PUNICODE_STRING,
                                                PUNICODE_STRING,
                                                PSAMPR_ENCRYPTED_USER_PASSWORD,
                                                PENCRYPTED_NT_OWF_PASSWORD,
                                                BOOLEAN,PSAMPR_ENCRYPTED_USER_PASSWORD,
                                                PENCRYPTED_LM_OWF_PASSWORD);
typedef NTSTATUS(* FNSAMCLOSEHANDLE)(SAM_HANDLE);
typedef NTSTATUS(* FNSAMFREEMEMORY)(PVOID);

FNSAMCONNECT              FnSamConnect              = NULL;
FNSAMOPENDOMAIN           FnSamOpenDomain           = NULL;
FNSAMLOOKUPNAMESINDOMAIN  FnSamLookupNamesInDomain  = NULL;
FNSAMOPENUSER             FnSamOpenUser             = NULL;
FNSAMICHANGEPASSWORDUSER  FnSamiChangePasswordUser  = NULL;
FNSAMICHANGEPASSWORDUSER2 FnSamiChangePasswordUser2 = NULL;
FNSAMCLOSEHANDLE          FnSamCloseHandle          = NULL;
FNSAMFREEMEMORY           FnSamFreeMemory           = NULL; 


/*++

MSChapSrvChangePassword:

    Changes the password of a user account.  Password will be set to
    NewPassword only if OldPassword matches the current user password for this
    user and there are no restrictions on using the new password.  This call
    allows users to change their own password if they have access
    USER_CHANGE_PASSWORD.  Password update restrictions apply.

Arguments:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    LMOldPresent - TRUE if the LmOldOwfPassword is valid.  This should only be
        FALSE if the old password is too long to be represented by a LM
        password (Complex NT password).  Note the LMNewOwfPassword must always
        be valid.  If the new password is complex, the LMNewOwfPassword should
        be the well-known LM OWF of a NULL password.

    LmOldOwfPassword - One-way-function of the current LM password for the
        user.  Ignored if LmOldPresent == FALSE

    LmNewOwfPassword - One-way-function of the new LM password for the user.

    NtOldOwfPassword - One-way-function of the current NT password for the
        user.

    NtNewOwfPassword - One-way-function of the new NT password for the user.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access to
        complete the operation.

    STATUS_INVALID_HANDLE - The supplied server or username was not valid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed, e.g.
        contains characters that can't be entered from the keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password from
        being changed.  This may be for a number of reasons, including time
        restrictions on how often a password may be changed or length
        restrictions on the provided password.  This error might also be
        returned if the new password matched a password in the recent history
        log for the account.  Security administrators indicate how many of the
        most recently used passwords may not be re-used.  These are kept in
        the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's current
        password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the correct
        state (disabled or enabled) to perform the requested operation.  The
        domain server must be enabled for this operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the incorrect
        role (primary or backup) to perform the requested operation.

    STATUS_INVALID_PARAMETER_MIX - LmOldPresent or NtPresent or both must be
        TRUE.

--*/     
WINADVAPI DWORD WINAPI
MSChapSrvChangePassword(
   IN LPWSTR ServerName,
   IN LPWSTR UserName,
   IN BOOLEAN LmOldPresent,
   IN PLM_OWF_PASSWORD LmOldOwfPassword,
   IN PLM_OWF_PASSWORD LmNewOwfPassword,
   IN PNT_OWF_PASSWORD NtOldOwfPassword,
   IN PNT_OWF_PASSWORD NtNewOwfPassword)
{
    NTSTATUS Status=STATUS_SUCCESS;
    DWORD    WinErr=ERROR_SUCCESS;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING UnicodeName;
    SAM_HANDLE SamHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE UserHandle = NULL;
    LSA_HANDLE LsaHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;
    PULONG RelativeIds = NULL;
    PSID_NAME_USE Use = NULL;

    if (NULL == UserName || NULL == LmOldOwfPassword || NULL == LmNewOwfPassword ||
        NULL == NtOldOwfPassword || NULL == NtNewOwfPassword) {
        WinErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Initialization.
    //

    if ( hSamlib == NULL )
    {
        RtlEnterCriticalSection( &MSChapChangePassword );
    
        if ( hSamlib == NULL )
        {
            hSamlib = LoadLibrary(L"samlib.dll");
            WinErr  = GetLastError();
            if (ERROR_SUCCESS != WinErr) {
                goto Cleanup;
            }
            if (hSamlib != NULL) {
    
                FnSamConnect             = (FNSAMCONNECT)             GetProcAddress(hSamlib,
                                                                         "SamConnect");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamOpenDomain          = (FNSAMOPENDOMAIN)          GetProcAddress(hSamlib,
                                                                         "SamOpenDomain");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamLookupNamesInDomain = (FNSAMLOOKUPNAMESINDOMAIN) GetProcAddress(hSamlib,
                                                                         "SamLookupNamesInDomain");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamOpenUser            = (FNSAMOPENUSER)            GetProcAddress(hSamlib,
                                                                         "SamOpenUser");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamCloseHandle         = (FNSAMCLOSEHANDLE)         GetProcAddress(hSamlib,
                                                                         "SamCloseHandle");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamFreeMemory          = (FNSAMFREEMEMORY)          GetProcAddress(hSamlib,
                                                                         "SamFreeMemory");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamiChangePasswordUser = (FNSAMICHANGEPASSWORDUSER) GetProcAddress(hSamlib,
                                                                         "SamiChangePasswordUser");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamiChangePasswordUser2 = (FNSAMICHANGEPASSWORDUSER2) GetProcAddress(hSamlib,
                                                                         "SamiChangePasswordUser2");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
            }
        }
    
        RtlLeaveCriticalSection( &MSChapChangePassword );
    
    }

    RtlInitUnicodeString(&UnicodeName, ServerName);
    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);


    //
    // Connect to the LSA on the server
    //

    Status = LsaOpenPolicy(
                &UnicodeName,
                &oa,
                POLICY_VIEW_LOCAL_INFORMATION,
                &LsaHandle);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsaQueryInformationPolicy(
                LsaHandle,
                PolicyAccountDomainInformation,
                (PVOID *)&DomainInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = FnSamConnect(
                &UnicodeName,
                &SamHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                &oa);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = FnSamOpenDomain(
                SamHandle,
                DOMAIN_LOOKUP | DOMAIN_READ_PASSWORD_PARAMETERS | DOMAIN_READ_PASSWORD_PARAMETERS,
                DomainInfo->DomainSid,
                &DomainHandle);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &UnicodeName,
        UserName);

    Status = FnSamLookupNamesInDomain(
                DomainHandle,
                1,
                &UnicodeName,
                &RelativeIds,
                &Use);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (Use[0] != SidTypeUser)
    {
        WinErr = ERROR_INVALID_SID;
        goto Cleanup;
    }

    Status = FnSamOpenUser(
                DomainHandle,
                USER_CHANGE_PASSWORD,
                RelativeIds[0],
                &UserHandle);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = FnSamiChangePasswordUser(
                UserHandle,
                LmOldPresent, // Only false if Old password too complex
                LmOldOwfPassword,
                LmNewOwfPassword,
                TRUE, // NT password present
                NtOldOwfPassword,
                NtNewOwfPassword);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:
    if (LsaHandle != NULL)
    {
        LsaClose(LsaHandle);
    }
    if (UserHandle != NULL)
    {
        FnSamCloseHandle(UserHandle);
    }
    if (DomainHandle != NULL)
    {
        FnSamCloseHandle(DomainHandle);
    }
    if (SamHandle != NULL)
    {
        FnSamCloseHandle(SamHandle);
    }
    if (DomainInfo != NULL)
    {
        LsaFreeMemory(DomainInfo);
    }
    if (RelativeIds != NULL)
    {
        FnSamFreeMemory(RelativeIds);
    }
    if (Use != NULL)
    {
        FnSamFreeMemory(Use);
    }

    if (ERROR_SUCCESS != WinErr) {
        return WinErr;
    }

    return RtlNtStatusToDosError(Status);
}


/*++

MSChapSrvChangePassword2:

    Changes the password of a user account.  Password will be set to
    NewPassword only if OldPassword matches the current user password for this
    user and there are no restrictions on using the new password.  This call
    allows users to change their own password if they have access
    USER_CHANGE_PASSWORD.  Password update restrictions apply.

Arguments:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    NewPasswordEncryptedWithOldNt - The new cleartext password encrypted with
        the old NT OWF password.

    OldNtOwfPasswordEncryptedWithNewNt - The old NT OWF password encrypted
        with the new NT OWF password.

    LmPresent - If TRUE, indicates that the following two last parameter was
        encrypted with the LM OWF password not the NT OWF password.

    NewPasswordEncryptedWithOldLm - The new cleartext password encrypted with
        the old LM OWF password.

    OldLmOwfPasswordEncryptedWithNewLmOrNt - The old LM OWF password encrypted
        with the new LM OWF password.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access to
        complete the operation.

    STATUS_INVALID_HANDLE - The supplied server or username was not valid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed, e.g.
        contains characters that can't be entered from the keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password from
        being changed.  This may be for a number of reasons, including time
        restrictions on how often a password may be changed or length
        restrictions on the provided password.  This error might also be
        returned if the new password matched a password in the recent history
        log for the account.  Security administrators indicate how many of the
        most recently used passwords may not be re-used.  These are kept in
        the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's current
        password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the correct
        state (disabled or enabled) to perform the requested operation.  The
        domain server must be enabled for this operation.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the incorrect
        role (primary or backup) to perform the requested operation.

--*/  
WINADVAPI DWORD WINAPI
MSChapSrvChangePassword2(
    IN LPWSTR ServerName,
    IN LPWSTR UserName,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt)
{
    UNICODE_STRING UnicodeServer;
    UNICODE_STRING UnicodeUser;
    DWORD WinErr = ERROR_SUCCESS;

    if (NULL == UserName || NULL == NewPasswordEncryptedWithOldNt ||
        NULL == NewPasswordEncryptedWithOldLm || NULL ==OldNtOwfPasswordEncryptedWithNewNt ||
        NULL == OldLmOwfPasswordEncryptedWithNewLmOrNt) {
        WinErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Initialization.
    //

    if ( hSamlib == NULL )
    {
        RtlEnterCriticalSection( &MSChapChangePassword );
    
        if ( hSamlib == NULL )
        {
            hSamlib = LoadLibrary(L"samlib.dll");
            WinErr  = GetLastError();
            if (ERROR_SUCCESS != WinErr) {
                goto Cleanup;
            }
            if (hSamlib != NULL) {
    
                FnSamConnect             = (FNSAMCONNECT)             GetProcAddress(hSamlib,
                                                                         "SamConnect");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamOpenDomain          = (FNSAMOPENDOMAIN)          GetProcAddress(hSamlib,
                                                                         "SamOpenDomain");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamLookupNamesInDomain = (FNSAMLOOKUPNAMESINDOMAIN) GetProcAddress(hSamlib,
                                                                         "SamLookupNamesInDomain");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamOpenUser            = (FNSAMOPENUSER)            GetProcAddress(hSamlib,
                                                                         "SamOpenUser");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamCloseHandle         = (FNSAMCLOSEHANDLE)         GetProcAddress(hSamlib,
                                                                         "SamCloseHandle");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamFreeMemory          = (FNSAMFREEMEMORY)          GetProcAddress(hSamlib,
                                                                         "SamFreeMemory");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamiChangePasswordUser = (FNSAMICHANGEPASSWORDUSER) GetProcAddress(hSamlib,
                                                                         "SamiChangePasswordUser");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
                FnSamiChangePasswordUser2 = (FNSAMICHANGEPASSWORDUSER2) GetProcAddress(hSamlib,
                                                                         "SamiChangePasswordUser2");
                WinErr  = GetLastError();
                if (ERROR_SUCCESS != WinErr) {
                    goto Cleanup;
                }
            }
        }
    
    
        RtlLeaveCriticalSection( &MSChapChangePassword );
    
    }                                                                                               


    RtlInitUnicodeString(&UnicodeServer, ServerName);
    RtlInitUnicodeString(&UnicodeUser,   UserName);

    return RtlNtStatusToDosError(FnSamiChangePasswordUser2(&UnicodeServer,
                                                           &UnicodeUser,
                                                           NewPasswordEncryptedWithOldNt,
                                                           OldNtOwfPasswordEncryptedWithNewNt,
                                                           LmPresent,
                                                           NewPasswordEncryptedWithOldLm,
                                                           OldLmOwfPasswordEncryptedWithNewLmOrNt));

    Cleanup:
    return WinErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\sitesids.cxx ===
#include "advapi.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <aclapi.h>
#include <windows.h>
#include <wincrypt.h>
#include <sitesids.h>
#include <malloc.h>
#include <urlmon.h>

RTL_CRITICAL_SECTION SiteSidCacheLock;

// internal function declarations
HRESULT MakeSidFromHash(PSID *ppSid, BYTE *pbBuffer, DWORD cbBuffer);
void UpdateSiteSidUsage(
            HKEY    hCacheKey,
            LPCWSTR lpwszSiteSid,
            LPWSTR  lpwszSite,
            UINT    cbSiteBuffer);
void Base32Encode(LPVOID pvData, UINT cbData, LPWSTR pchData);

typedef HRESULT (STDAPICALLTYPE CREATESECURITYMANAGER) (
                                                        IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved);

CREATESECURITYMANAGER *pfnCoInternetCreateSecurityManager = CoInternetCreateSecurityManager;
HMODULE hUrlMon = 0;



PSID
APIENTRY
GetSiteSidFromToken(
                    IN HANDLE TokenHandle
                    )
{
    PTOKEN_GROUPS RestrictedSids = NULL;
    ULONG ReturnLength;
    NTSTATUS Status;
    PSID psSiteSid = NULL;


    Status = NtQueryInformationToken(
        TokenHandle,
        TokenRestrictedSids,
        NULL,
        0,
        &ReturnLength
        );
    if (Status != STATUS_BUFFER_TOO_SMALL)
    {
        BaseSetLastNTError(Status);
        return NULL;
    }

    RestrictedSids = (PTOKEN_GROUPS) RtlAllocateHeap(RtlProcessHeap(), 0, ReturnLength);
    if (RestrictedSids == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return NULL;
    }

    Status = NtQueryInformationToken(
        TokenHandle,
        TokenRestrictedSids,
        RestrictedSids,
        ReturnLength,
        &ReturnLength
        );
    if (NT_SUCCESS(Status))
    {
        UINT i;
        SID_IDENTIFIER_AUTHORITY InternetSiteAuthority = SECURITY_INTERNETSITE_AUTHORITY;

        for (i = 0; i < RestrictedSids->GroupCount; i++) {

            if (RtlCompareMemory((PVOID) &((SID *) RestrictedSids->Groups[i].Sid)->IdentifierAuthority,
                (PVOID) &InternetSiteAuthority,
                sizeof(SID_IDENTIFIER_AUTHORITY)) == sizeof(SID_IDENTIFIER_AUTHORITY))
            {
                psSiteSid = RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthSid((RestrictedSids->Groups[i]).Sid));
                if (psSiteSid == NULL) {
                    SetLastError(ERROR_OUTOFMEMORY);
                }
                else {
                    RtlCopySid(RtlLengthSid((RestrictedSids->Groups[i]).Sid), psSiteSid, (RestrictedSids->Groups[i]).Sid);
                }

                break;
            }

        }
    }
    else
    {
        BaseSetLastNTError(Status);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, RestrictedSids);
    return psSiteSid;
}


HRESULT GetRestrictedSids(
                          LPCWSTR pszSite,
                          SID_AND_ATTRIBUTES *pSidToRestrict,
                          ULONG *pCount)
{
    HRESULT hr = S_OK;
    ULONG   i = 0;
    long error;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    *pCount = 0;

    pSidToRestrict[0].Attributes = SE_GROUP_MANDATORY | SE_GROUP_ENABLED;
    pSidToRestrict[1].Attributes = SE_GROUP_MANDATORY | SE_GROUP_ENABLED;
    pSidToRestrict[2].Attributes = SE_GROUP_MANDATORY | SE_GROUP_ENABLED;


    //Get the site SID.
    pSidToRestrict[0].Sid = GetSiteSidFromUrl(pszSite);
    if(!pSidToRestrict[0].Sid)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    i++;

    //BUGBUG: Get the zone SID.

    //Get the restricted SID.
    error = RtlAllocateAndInitializeSid(&NtAuthority,
        1,
        SECURITY_RESTRICTED_CODE_RID,
        0, 0, 0, 0, 0, 0, 0,
        &pSidToRestrict[i].Sid);
    if(!error)
    {
        i++;
    }
    else
    {
        hr =  HRESULT_FROM_WIN32( GetLastError() );
    }

    if(FAILED(hr))
    {
        return hr;
    }


    *pCount = i;
    return hr;
}


HRESULT
APIENTRY
GetSiteNameFromSid(PSID pSid, LPWSTR *pwsSite)
{
    HRESULT         hr = S_OK;
    WCHAR           wsValueNameBuffer[MAX_MANGLED_SITE];
    LPWSTR          wsValueName = wsValueNameBuffer;
    HKEY            hCacheKey;
    DWORD           dwDisposition;
    WCHAR          *wszValue;
    ULONG           ulValueSize;
    DWORD           error;

    *pwsSite = NULL;

    error = RegCreateKeyExW(HKEY_LOCAL_MACHINE, SITE_SID_CACHE_REG_KEY,
                            0, NULL, 0, KEY_ALL_ACCESS,
                            NULL, &hCacheKey, &dwDisposition);

    if (ERROR_SUCCESS != error)
    {
        // Can't write, try read-only.  We won't be able to update the cache,
        // but we might be able to return the site name

        error = RegCreateKeyExW(HKEY_LOCAL_MACHINE, SITE_SID_CACHE_REG_KEY,
                                0, NULL, 0, KEY_QUERY_VALUE,
                                NULL, &hCacheKey, &dwDisposition);

        if (ERROR_SUCCESS != error) {
            return HRESULT_FROM_WIN32(error);
        }
    }

    GetMangledSiteSid(pSid, MAX_MANGLED_SITE, &wsValueName);
    ASSERT(wsValueName == wsValueNameBuffer);

    //Get the size and allocate memory for the site name.
    error = RegQueryValueExW(
                    hCacheKey,
                    wsValueName,
                    NULL,
                    NULL,
                    NULL,
                    &ulValueSize);

    if (ERROR_SUCCESS != error) {
        RegCloseKey(hCacheKey);
        return HRESULT_FROM_WIN32(error);
    }

    wszValue = (WCHAR *) LocalAlloc(0, ulValueSize);

    if (wszValue != NULL)
    {
        error = RegQueryValueExW(
                        hCacheKey,
                        wsValueName,
                        NULL,
                        NULL,
                        (BYTE *) wszValue,
                        &ulValueSize);

        if (ERROR_SUCCESS == error)
        {
            *pwsSite = wszValue;

            UpdateSiteSidUsage(hCacheKey, wsValueName, wszValue, ulValueSize);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(error);
            LocalFree(wszValue);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    RegCloseKey(hCacheKey);

    return hr;
}

PSID APIENTRY
GetSiteSidFromUrl(LPCWSTR wsUrl)
{
    HRESULT hr;
    PSID pSid = NULL;
    IInternetSecurityManager *pIScManager;
    DWORD cbSecurityId = lstrlenW(wsUrl) * sizeof(WCHAR) + sizeof(DWORD);
    BYTE *pbSecurityId = (BYTE *) alloca(cbSecurityId);

    HCRYPTPROV hProv;
    HCRYPTHASH hHash;

    DWORD dwCount;
    DWORD dwHashLen;

    BYTE *pbBuffer;

    HKEY hCacheKey;
    DWORD dwDisposition;

    WCHAR wsValueNameBuffer[MAX_MANGLED_SITE];
    LPWSTR wsValueName = wsValueNameBuffer;

    ULONG ulValueSize = (lstrlenW(wsUrl) + 1) * sizeof(WCHAR);
    WCHAR *wsValue;
    NTSTATUS Status;
    DWORD    error;

    //Crack the URL to get the site name.
    hr = (*pfnCoInternetCreateSecurityManager)(NULL, &pIScManager, 0);
    if(SUCCEEDED(hr))
    {
        hr = pIScManager->GetSecurityId(wsUrl, pbSecurityId, &cbSecurityId, 0);

        if(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
        {
            pbSecurityId = (BYTE *) alloca(cbSecurityId);
            hr = pIScManager->GetSecurityId(wsUrl, pbSecurityId, &cbSecurityId, 0);
        }

        //Remove the dwZone from the end of the pbSecurityId.
        cbSecurityId -=  sizeof(DWORD);

        pIScManager->Release();
    }

    if(FAILED(hr))
    {
        SetLastError(hr);
        return NULL;
    }

    // acquire security context - if this is unsuccessful,
    // the hashing functions cannot be called
    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        return NULL;

    if (!CryptCreateHash(hProv, SITE_SID_HASH_ALGORITHM, 0, 0, &hHash))
    {
        CryptReleaseContext(hProv, 0);
        return NULL;
    }

    // hash the site name
    if (!CryptHashData(hHash, pbSecurityId, cbSecurityId, 0))
    {
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return NULL;
    }
    // TODO: salt? - with local machine name?

    // get size of the hash value - for memory allocation
    dwCount = sizeof(DWORD);
    if (!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE *) &dwHashLen, &dwCount, 0))
    {
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return NULL;
    }

    pbBuffer = (BYTE *) LocalAlloc(0, dwHashLen);
    if (pbBuffer == NULL)
    {
        //out of memory
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        SetLastError(ERROR_OUTOFMEMORY);
        return NULL;
    }
    if (!CryptGetHashParam(hHash, HP_HASHVAL, pbBuffer, &dwHashLen, 0))
    {
        LocalFree(pbBuffer);
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return NULL;
    }

    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);

    // make SID from the hash value in pbBuffer
    hr = MakeSidFromHash(&pSid, pbBuffer, dwHashLen);
    if (FAILED(hr))
    {
        LocalFree(pbBuffer);
        SetLastError(hr);
        return NULL;
    }

    // check if the SID is already in the SID cache
    // if it is, update the time of last use
    // if not, insert it into the cache, deleting the LRU
    // item if the cache is already full

    // whatever happens here, we already have the mapping
    // from URL to SID that we wanted, so we always return
    // success

    //
    // Convert the cracked site name to Unicode
    //

    __try
    {
        wsUrl = (WCHAR *) alloca(ulValueSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return pSid;        // alloca failed
    }

    Status = RtlMultiByteToUnicodeN((WCHAR *) wsUrl, ulValueSize, &dwCount, (char *) pbSecurityId, cbSecurityId);
    if (!(NT_SUCCESS(Status)))
    {
        return pSid;
    }
    ((WCHAR *)wsUrl)[dwCount / sizeof(WCHAR)] = L'\0';

    hCacheKey = NULL;
    if (RegCreateKeyExW(HKEY_LOCAL_MACHINE, SITE_SID_CACHE_REG_KEY, 0, NULL, 0,
        KEY_ALL_ACCESS, NULL, &hCacheKey, &dwDisposition) != ERROR_SUCCESS)
    {
        // cannot open/create the cache registry key
        return pSid;
    }

    GetMangledSiteSid(pSid, MAX_MANGLED_SITE, &wsValueName);
    ASSERT(wsValueName == wsValueNameBuffer);

    __try
    {
        wsValue = (WCHAR *) alloca(ulValueSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        RegCloseKey(hCacheKey); // alloca failed
        return pSid;
    }

    error = RegQueryValueExW(
                    hCacheKey,
                    wsValueName,
                    NULL,
                    NULL,
                    (BYTE *) wsValue,
                    &ulValueSize);

    if (ERROR_SUCCESS == error) {
        // this SID is already there in the cache
        // check for collision

        // if wsValue is "", we already know of a collision
        if (wsValue[0] != L'\0') {
            if (wcscmp(wsUrl, wsValue) != 0) {
                // COLLISION !!!

                // we handle collision by retaining the SID in
                // the cache and setting the site name to ""
                // so the wrong site name cannot be returned

                DbgPrint("Site SID Collision:\n\t%ws\n\t%ws\n", wsUrl,wsValue);

                WCHAR wcNull = L'\0';
                RegSetValueExW(hCacheKey, wsValueName, 0, REG_BINARY,
                    (CONST BYTE *) &wcNull, sizeof(WCHAR));
            }
            else {
                UpdateSiteSidUsage(
                        hCacheKey,
                        wsValueName,
                        wsValue,
                        ulValueSize);
            }
        }
    }
    else if (ERROR_FILE_NOT_FOUND == error) {
        UpdateSiteSidUsage(hCacheKey, wsValueName, (WCHAR *) wsUrl, 0);
   }

   RegCloseKey(hCacheKey);

   return pSid;
}

void UpdateSiteSidUsage(
            HKEY    hCacheKey,
            LPCWSTR lpwszSiteSid,
            LPWSTR  lpwszSite,
            UINT    cbSiteBuffer)
{
    UINT    cbSite           = wcslen(lpwszSite)*sizeof(WCHAR) + sizeof(L'\0');
    UINT    cbRequiredBuffer = cbSite + sizeof(LARGE_INTEGER);
    BOOL    bCheckOverflow   = (0 == cbSiteBuffer);

    LARGE_INTEGER Now;

    if (cbSiteBuffer < cbRequiredBuffer)
    {
        // Either this is a new cache entry or somebody mucked with the
        // cache data
        LPWSTR lpwsz;

        __try
        {
            lpwsz = (LPWSTR) alloca(cbRequiredBuffer);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            return;     // alloca failed
        }

        wcscpy(lpwsz, lpwszSite);
        cbSiteBuffer = cbRequiredBuffer;
        lpwszSite = lpwsz;
    }

    // Tack the current time after the end of the string and write it out

    NtQuerySystemTime(&Now);
    * (UNALIGNED LARGE_INTEGER *) (((BYTE *) lpwszSite) + cbSite) = Now;

    RegSetValueExW(
            hCacheKey,
            lpwszSiteSid,
            NULL,
            REG_BINARY,
            (BYTE *) lpwszSite,
            cbSiteBuffer);

    if (!bCheckOverflow)
        return;

    // Check for cache overflow

#define _PTIME(i)  ((__int64 *) (pEntryInfo + i * cbEntryInfo))
#define _PVALUE(i) ((WCHAR *) (_PTIME(i) + 1))

    static volatile LONG lFlushing = 0;

    DWORD   error;
    DWORD   cEntries;
    DWORD   cTotalEntries;
    DWORD   cbEntryValue;
    DWORD   cbMaxEntryValue;
    BYTE   *pEntryValue;
    DWORD   cbMaxEntryName;
    DWORD   cbEntryInfo;
    BYTE   *pEntryInfo;
    UINT    iFreeEntry;
    UINT    iNewestEntry;
    UINT    i;
    DWORD   cb;

    error = RegQueryInfoKeyW(hCacheKey, NULL, NULL, NULL, NULL, NULL, NULL,
                             &cEntries, &cbMaxEntryName, &cbMaxEntryValue,
                             NULL, NULL);

    if (ERROR_SUCCESS != error
        || cEntries < SITE_SID_CACHE_SIZE_HIGH
        || 1 == InterlockedExchange((LONG *) &lFlushing, 1))
    {
        return;     // Cache is under limit or we are already flushing
    }

    cbMaxEntryName = (cbMaxEntryName + 1) * sizeof(WCHAR);
    cTotalEntries = cEntries - SITE_SID_CACHE_SIZE_LOW + 1;
    cbEntryInfo = sizeof(LARGE_INTEGER) + cbMaxEntryName;

    // Allocate space for the largest value size

    __try
    {
        pEntryValue = (BYTE *) alloca(cbMaxEntryValue);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return;
    }

    // Allocate space to hold the cache entries to delete (+1)

    do
    {
        pEntryInfo = (BYTE *) LocalAlloc(0, cbEntryInfo * cTotalEntries);

        if (NULL == pEntryInfo)
        {
            cTotalEntries = cTotalEntries / 2;

            if (cTotalEntries < 2)
            {
                lFlushing = 0;
                return;
            }
        }
    }
    while (NULL == pEntryInfo);

    iFreeEntry = 0;
    iNewestEntry = 0;
    i = 0;
    cb = cbEntryInfo - sizeof(LARGE_INTEGER);
    cEntries = 1;
    BOOL bNewNewest = FALSE;
    cbEntryValue = cbMaxEntryValue;

    while (ERROR_SUCCESS == RegEnumValueW(
                                hCacheKey,
                                i,
                                _PVALUE(iFreeEntry),
                                &cb,
                                NULL,
                                NULL,
                                pEntryValue,
                                &cbEntryValue))
    {
        ++i;
        cb = cbEntryInfo - sizeof(LARGE_INTEGER);
        cbEntryValue = cbMaxEntryValue;

        * _PTIME(iFreeEntry) = * (__int64 *) (wcschr((WCHAR *) pEntryValue, L'\0') + 1);

        if (cEntries < cTotalEntries)
        {
            ++cEntries;
            ++iFreeEntry;
            if (cEntries == cTotalEntries)
                bNewNewest = TRUE;
        }
        else if (*_PTIME(iFreeEntry) < *_PTIME(iNewestEntry))
        {
            UINT t = iNewestEntry;
            iNewestEntry = iFreeEntry;
            iFreeEntry = t;
            bNewNewest = TRUE;
        }

        if (bNewNewest)
        {
            bNewNewest = FALSE;

            for (DWORD j = 0; j < cEntries; j++)
            {
                if (j != iFreeEntry)
                    if (*_PTIME(j) > *_PTIME(iNewestEntry))
                        iNewestEntry = j;
            }
        }
    }

    if (i >= SITE_SID_CACHE_SIZE_HIGH)
    {
        for (DWORD j = 0; j < cEntries; j++)
        {
            if (j != iFreeEntry)
                RegDeleteValueW(hCacheKey, _PVALUE(j));
        }
    }

    LocalFree(pEntryInfo);

    lFlushing = 0;

#undef _PVALUE
#undef _PTIME
}



HRESULT MakeSidFromHash(PSID *ppSid, BYTE *pbBuffer, DWORD cbBuffer)
{
    HRESULT hr = S_OK;
    long error;
    DWORD aSubAuthorities[8];
    SID_IDENTIFIER_AUTHORITY siaAuthority = SITE_SID_CACHE_AUTHORITY;

    *ppSid = NULL;

    if(cbBuffer > sizeof(aSubAuthorities))
    {
        return E_INVALIDARG;
    }

    memset(aSubAuthorities, 0, sizeof(aSubAuthorities));
    memcpy(aSubAuthorities, pbBuffer, cbBuffer);

    error = RtlAllocateAndInitializeSid(&siaAuthority,
        (BYTE) ((cbBuffer + 3) / sizeof(DWORD)),
        aSubAuthorities[0],
        aSubAuthorities[1],
        aSubAuthorities[2],
        aSubAuthorities[3],
        aSubAuthorities[4],
        aSubAuthorities[5],
        aSubAuthorities[6],
        aSubAuthorities[7],
        ppSid);
    if(error)
    {
        hr = HRESULT_FROM_WIN32(error);
    }
    return hr;
}

HRESULT
APIENTRY
GetMangledSiteSid(PSID pSid, ULONG cchMangledSite, LPWSTR *ppwszMangledSite)
{
    SID_IDENTIFIER_AUTHORITY InternetSiteAuthority = SECURITY_INTERNETSITE_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY *InAuthority;

    InAuthority = RtlIdentifierAuthoritySid(pSid);

    if (NULL == InAuthority)
        return HRESULT_FROM_WIN32(ERROR_INVALID_SID);

    if (0 != memcmp(
                InAuthority,
                &InternetSiteAuthority,
                sizeof(InternetSiteAuthority)))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SID);
    }

    if (cchMangledSite < MAX_MANGLED_SITE)
    {
        *ppwszMangledSite = (WCHAR *) LocalAlloc(
                                            0,
                                            MAX_MANGLED_SITE * sizeof(WCHAR));
        if (NULL == *ppwszMangledSite)
            return E_OUTOFMEMORY;
    }

    // The value of MAX_MANGLED_SITE assumes 4 dwords
    ASSERT(4 == *RtlSubAuthorityCountSid(pSid));

    Base32Encode(
            RtlSubAuthoritySid(pSid, 0),
            *RtlSubAuthorityCountSid(pSid) * sizeof(DWORD),
            *ppwszMangledSite);

    // The output string should always be MAX_MANGLED_SITE - 1 chars long
    ASSERT(MAX_MANGLED_SITE - 1 == lstrlenW(*ppwszMangledSite));

    return S_OK;
}


ULONG
APIENTRY
GetSiteDirectoryA(
                  HANDLE hToken,
                  LPSTR lpBuffer,
                  ULONG nBufferLength
                  )

/*++

Routine Description:

ANSI thunk to GetSiteDirectoryW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    DWORD ReturnValue;
#if defined (FE_SB) // GetSiteDirectoryA(); local variable
    ULONG cbAnsiString;
#endif // FE_SB

    if ( nBufferLength > MAXUSHORT ) {
        nBufferLength = MAXUSHORT-2;
    }

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    Unicode->Length = (USHORT)GetSiteDirectoryW(
        hToken,
        Unicode->Buffer,
        Unicode->MaximumLength
        );

#if defined (FE_SB) // GetSiteDirectoryA(): bug fix
    //
    // Unicode->Length contains the byte count of unicode string.
    // Original code does "UnicodeLength / sizeof(WCHAR)" to
    // get the size of corresponding ansi string.
    // This is correct in SBCS environment. However in DBCS
    // environment, it's definitely WRONG.
    //
    Status = RtlUnicodeToMultiByteSize( &cbAnsiString, Unicode->Buffer, Unicode->Length );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = 0;
    }
    else {
        if ( nBufferLength > (DWORD)(cbAnsiString ) ) {
            AnsiString.Buffer = lpBuffer;
            AnsiString.MaximumLength = (USHORT)(nBufferLength+1);
            Status = BasepUnicodeStringTo8BitString(&AnsiString,Unicode,FALSE);

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnValue = 0;
            }
            else {
                ReturnValue = AnsiString.Length;
            }
        }
        else {
            //
            // current spec says the length doesn't
            // include null terminate character.
            // this may be a bug but I would like
            // to make this same as US (see US original code).
            //
            ReturnValue = cbAnsiString + 1;
        }
    }
#else
    if ( nBufferLength > (DWORD)(Unicode->Length>>1) ) {
        AnsiString.Buffer = lpBuffer;
        AnsiString.MaximumLength = (USHORT)(nBufferLength+1);
        Status = RtlUnicodeStringToAnsiString(&AnsiString,Unicode,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            ReturnValue = 0;
        }
        else {
            ReturnValue = AnsiString.Length;
        }
    }
    else {
        ReturnValue = ((Unicode->Length)>>1)+1;
    }
#endif // FE_SB
    return ReturnValue;
}

/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
  PTOKEN_USER pUser;
  PSID pSid;
  DWORD BytesRequired = 200;
  NTSTATUS status;


  //
  // Allocate space for the user info
  //

  pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


  if (pUser == NULL) {
      //        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
      //                  BytesRequired));
      return NULL;
  }


  //
  // Read in the UserInfo
  //

  status = NtQueryInformationToken(
      UserToken,                 // Handle
      TokenUser,                 // TokenInformationClass
      pUser,                     // TokenInformation
      BytesRequired,             // TokenInformationLength
      &BytesRequired             // ReturnLength
      );

  if (status == STATUS_BUFFER_TOO_SMALL) {

      //
      // Allocate a bigger buffer and try again.
      //

      HLOCAL realloc = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
      if (NULL == realloc) {
          //            DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
          //                      BytesRequired));
          LocalFree(pUser);
          return NULL;
      }
      pUser = (PTOKEN_USER) realloc;

      status = NtQueryInformationToken(
          UserToken,             // Handle
          TokenUser,             // TokenInformationClass
          pUser,                 // TokenInformation
          BytesRequired,         // TokenInformationLength
          &BytesRequired         // ReturnLength
          );

  }

  if (!NT_SUCCESS(status)) {
      //        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to query user info from user token, status = 0x%x"),
      //                  status));
      LocalFree(pUser);
      return NULL;
  }


  BytesRequired = RtlLengthSid(pUser->User.Sid);
  pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
  if (pSid == NULL) {
      //        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
      //                  BytesRequired));
      LocalFree(pUser);
      return NULL;
  }


  status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

  LocalFree(pUser);

  if (!NT_SUCCESS(status)) {
      //        DebugMsg((DM_WARNING, TEXT("GetUserSid: RtlCopySid Failed. status = %d"),
      //                  status));
      LocalFree(pSid);
      pSid = NULL;
  }


  return pSid;
}

BOOL
  CreateSiteDirectory(
  LPCWSTR pszSiteDirectory,
  PSID psidUser,
  PSID psidSite)
{
  BOOL bRetVal = FALSE;
  SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
  PACL pAcl = NULL;
  PSID psidSystem = NULL;
  PSID psidAdmin = NULL;
  DWORD cbAcl, AceIndex, dwDisp;
  ACE_HEADER * lpAceHeader;
  SECURITY_DESCRIPTOR sd;
  SECURITY_ATTRIBUTES saSite;


  //
  // Get the system sid
  //

  if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
      0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
      goto Exit;
  }


  //
  // Get the admin sid
  //

  if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
      DOMAIN_ALIAS_RID_ADMINS, 0, 0,
      0, 0, 0, 0, &psidAdmin)) {
      goto Exit;
  }

  //
  // Allocate space for the ACL
  //

  cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
      (2 * GetLengthSid (psidAdmin)) + (2 * GetLengthSid (psidSite)) +
      sizeof(ACL) +
      (8 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


  pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
  if (!pAcl) {
      goto Exit;
  }

  if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
      goto Exit;
  }


  //
  // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
  //

  AceIndex = 0;
  if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidUser)) {
      goto Exit;
  }


  AceIndex++;
  if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
      goto Exit;
  }

  AceIndex++;
  if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
      goto Exit;
  }

  AceIndex++;
  if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSite)) {
      goto Exit;
  }



  //
  // Now the inheritable ACEs
  //

  AceIndex++;
  if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser)) {
      goto Exit;
  }

  if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
      goto Exit;
  }

  lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


  AceIndex++;
  if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
      goto Exit;
  }

  if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
      goto Exit;
  }

  lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


  AceIndex++;
  if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
      goto Exit;
  }

  if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
      goto Exit;
  }

  lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

  AceIndex++;
  if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSite)) {
      goto Exit;
  }

  if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
      goto Exit;
  }

  lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


  //
  // Put together the security descriptor
  //

  if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
      goto Exit;
  }


  if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
      goto Exit;
  }


  //
  // Add the security descriptor to the sa structure
  //

  saSite.nLength = sizeof(SECURITY_ATTRIBUTES);
  saSite.lpSecurityDescriptor = &sd;
  saSite.bInheritHandle = FALSE;

  //
  // Attempt to create the directory
  //

  bRetVal = CreateDirectoryW(pszSiteDirectory, &saSite);

Exit:

  //
  // Free the sids and acl
  //

  if (psidSystem) {
      FreeSid(psidSystem);
  }

  if (psidAdmin) {
      FreeSid(psidAdmin);
  }

  if (pAcl) {
      GlobalFree (pAcl);
  }
  return bRetVal;
}

ULONG
APIENTRY
GetSiteDirectoryW(
                  HANDLE hToken,
                  LPWSTR pszSiteDirectory,
                  ULONG  uSize)
{
    ULONG  cb = 0;
    PSID   psidUser = 0;
    PSID   psidSite = 0;
    WCHAR  szProfile[MAX_PATH + 1];
    LPWSTR pszProfile = szProfile;
    HANDLE hProcessToken = 0;
    long   error = 0;

    //Get the process token.
    if(!hToken)
    {
        if(OpenProcessToken(GetCurrentProcess(),
            TOKEN_QUERY,
            &hProcessToken))
        {
            hToken = hProcessToken;
        }
        else
        {
            return 0;
        }
    }

    //Get the path to the user profile directory.
    psidUser = GetUserSid(hToken);
    if(psidUser != NULL)
    {
        UNICODE_STRING          wstrUserSid = {0, 0, 0};

        error = RtlConvertSidToUnicodeString(&wstrUserSid,
            psidUser,
            TRUE);
        if(!error)
        {
            HKEY hkUserProfile;

            //Read the registry key.
            lstrcpyW(szProfile, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\");
            lstrcatW(szProfile, wstrUserSid.Buffer);

            error = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                szProfile,
                0,
                KEY_READ,
                &hkUserProfile);
            if(!error)
            {
                DWORD dwType;
                DWORD dwSize = sizeof(szProfile);

                error = RegQueryValueExW(hkUserProfile,
                    L"ProfileImagePath",
                    NULL,
                    &dwType,
                    (BYTE*)szProfile,
                    &dwSize );
                if(!error)
                {
                    if ( dwType == REG_EXPAND_SZ )
                    {
                        pszProfile = (LPWSTR) alloca((MAX_PATH + 1) * sizeof(WCHAR));
                        ExpandEnvironmentStringsW(szProfile,
                            pszProfile,
                            MAX_PATH);
                    }
                }

                RegCloseKey(hkUserProfile);
            }

            RtlFreeUnicodeString(&wstrUserSid);
        }
    }
    else
    {
        error = GetLastError();
    }


    //Get the path to the site directory.
    if(!error)
    {
        psidSite = GetSiteSidFromToken(hToken);

        if(psidSite != NULL)
        {
            WCHAR wszSiteNameBuffer[MAX_MANGLED_SITE];
            LPWSTR wszSiteName = wszSiteNameBuffer;

            GetMangledSiteSid(psidSite, MAX_MANGLED_SITE, &wszSiteName);
            ASSERT(wszSiteName == wszSiteNameBuffer);

            cb = sizeof(WCHAR) * (lstrlenW(pszProfile)
                                  + sizeof('\\')
                                  + lstrlenW(wszSiteName)
                                  + sizeof('\0'));

            if(uSize * 2 < cb)
            {
                return cb/2;
            }
            else
            {
                lstrcpyW(pszSiteDirectory, pszProfile);
                lstrcatW(pszSiteDirectory, L"\\");
                lstrcatW(pszSiteDirectory, wszSiteName);

                //Check if the directory already exists.
                if(GetFileAttributesW(pszSiteDirectory) == -1)
                {
                    CreateSiteDirectory(pszSiteDirectory, psidUser, psidSite);
                }
            }
            RtlFreeSid(psidSite);
        }
        else
        {
            error = GetLastError();
        }
    }

    if(error)
    {
        SetLastError(error);
    }

    if(hProcessToken)
    {
        CloseHandle(hProcessToken);
    }

    if(psidUser)
    {
        RtlFreeSid(psidUser);
    }

    return cb;
}


BOOL APIENTRY
IsProcessRestricted(void)

/*++

Routine Description:

    Checks if the current process is a restricted process.

Arguments:

    None.

Return Value:

    TRUE if the current process is a restricted process.
    FALSE if it isn't, or if the handle of the current process
    cannot be obtained

Notes:

--*/

{
    static long fIsRestricted = -1;

    if(-1 == fIsRestricted)
    {
        HANDLE hToken;
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
        {
            fIsRestricted = IsTokenRestricted(hToken);
            CloseHandle(hToken);
        }
        else
        {
            fIsRestricted = 0;
        }
    }
    return fIsRestricted;
}

WINADVAPI
BOOL
WINAPI IsInSandbox(VOID)
{
    return IsProcessRestricted();

}

//+-------------------------------------------------------------------
//
//  Function:   CoInternetCreateSecurityManager
//
//  Synopsis:   Loads urlmon.dll and calls CoInternetCreateSecurityManager.
//
//  Returns:    S_OK, ERROR_MOD_NOT_FOUND
//
//--------------------------------------------------------------------
STDAPI CoInternetCreateSecurityManager(
                                       IN  IServiceProvider *pSP,
                                       OUT IInternetSecurityManager **ppSM,
                                       IN DWORD dwReserved)
{
    HRESULT hr = E_FAIL;

    if(!hUrlMon)
    {
        hUrlMon = LoadLibraryA("urlmon.dll");
    }

    if(hUrlMon != 0)
    {
        void *pfn = GetProcAddress(hUrlMon, "CoInternetCreateSecurityManager");
        if(pfn != NULL)
        {
            pfnCoInternetCreateSecurityManager = (CREATESECURITYMANAGER *) pfn;
            hr = (*pfnCoInternetCreateSecurityManager)(pSP, ppSM, dwReserved);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   Base32Encode
//
//  Synopsis:   Convert the given data to base32
//
//  Notes:      Adapted from Mim64Encode in the mshtml project.
//
//              For 128 bit input (4 DWORDs) the output string will be
//              27 chars long (including the null terminator)
//
//-----------------------------------------------------------------------------

void Base32Encode(LPVOID pvData, UINT cbData, LPWSTR pchData)
{
    static const WCHAR alphabet[32] =
        { L'a', L'b', L'c', L'd', L'e', L'f', L'g', L'h',
          L'i', L'j', L'k', L'l', L'm', L'n', L'o', L'p',
          L'q', L'r', L's', L't', L'u', L'v', L'w', L'x',
          L'y', L'z', L'0', L'1', L'2', L'3', L'4', L'5' };

    int   shift = 0;    // The # of unprocessed bits in accum
    ULONG accum = 0;    // The unprocessed bits
    ULONG value;
    BYTE *pData = (BYTE *) pvData;

    // For each byte...

    while (cbData)
    {
        // Move the byte into the low bits of the accumulator

        accum = (accum << 8) | *pData++;
        shift += 8;
        --cbData;

        // Lop off the high 5 or 10 bits and write them out

        while ( shift >= 5 )
        {
            shift -= 5;
            value = (accum >> shift) & 0x1Fl;

            *pchData++ = alphabet[value];
        }
    }

    // If there are any remaining bits, push out one more char padded with 0's

    if (shift)
    {
        value = (accum << (5 - shift)) & 0x1Fl;

        *pchData++ = alphabet[value];
    }

    *pchData = L'\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\security.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This module implements Object Security APIs for Win32

Author:

    Jim Anderson (JimA) 01-Jul-1991
    Robert Reichel (RobertRe) 01-Jan-92

Revision History:

--*/

#include "advapi.h"
#include <ntlsa.h>
#include <rpc.h>
#include <rpcndr.h>
#include <stdio.h>

#define LSADEFINED


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//               Private Routine Prototypes                                //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


VOID
SepFormatAccountSid(
    PSID iSid,
    LPWSTR OutputBuffer
    );



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//               Exported Routines                                         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOL
APIENTRY
DuplicateToken(
    HANDLE ExistingTokenHandle,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    PHANDLE DuplicateTokenHandle
    )

/*++

Routine Description:

    Create a new token that is a duplicate of an existing token.  The
    new token will be an impersonation token of the supplied level.

Arguments:

    ExistingTokenHandle - Is a handle to a token already open for
        TOKEN_DUPLICATE access.

    ImpersonationLevel - Supplies the impersonation level of the new
        token.

    DuplicateTokenHandle - Returns the handle to the new token.  The
        handle will have TOKEN_IMPERSONATE and TOKEN_QUERY access to
        the new token.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/

{
    return( DuplicateTokenEx( ExistingTokenHandle,
                              TOKEN_IMPERSONATE | TOKEN_QUERY,
                              NULL,
                              ImpersonationLevel,
                              TokenImpersonation,
                              DuplicateTokenHandle
                              ) );

}

BOOL
APIENTRY
DuplicateTokenEx(
    HANDLE hExistingToken,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpTokenAttributes,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    TOKEN_TYPE TokenType,
    PHANDLE phNewToken)
/*++

    Routine Description:

    Create a new token that is a duplicate of an existing token.  This API
    more fully exposes NtDuplicateToken .

    Arguments:

        hExistingToken - Is a handle to a token already open for
                                        TOKEN_DUPLICATE access.

        dwDesiredAccess - desired access rights to the new token, e.g.
                                       TOKEN_DUPLICATE, TOKEN_IMPERSONATE, etc.

        lpTokenAttributes - Desired security attributes for the new token.

        ImpersonationLevel - Supplies the impersonation level of the new token.

        TokenType - One of TokenImpersonation or TokenPrimary.

        phNewToken  - Returns the handle to the new token.

    Return Value:

        Returns TRUE for success, FALSE for failure.  Extended error status
        is available using GetLastError.

--*/


{

    OBJECT_ATTRIBUTES ObjA;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    NTSTATUS Status;
    ULONG Attributes;

    SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE  );
    SecurityQualityOfService.ImpersonationLevel = ImpersonationLevel;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    if (lpTokenAttributes)
    {
        SecurityDescriptor = lpTokenAttributes->lpSecurityDescriptor;
        if (lpTokenAttributes->bInheritHandle)
        {
            Attributes = OBJ_INHERIT;
        }
        else
        {
            Attributes = 0;
        }
    }
    else
    {
        SecurityDescriptor = NULL;
        Attributes = 0;
    }

    InitializeObjectAttributes(
        &ObjA,
        NULL,
        Attributes,
        NULL,
        SecurityDescriptor
        );

    ObjA.SecurityQualityOfService = &SecurityQualityOfService;

    Status = NtDuplicateToken(
                 hExistingToken,
                 dwDesiredAccess,
                 &ObjA,
                 FALSE,
                 TokenType,
                 phNewToken
                 );

    if ( !NT_SUCCESS( Status ) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return( TRUE );

}





BOOL
APIENTRY
AllocateLocallyUniqueId(
    PLUID Luid
    )
/*++

Routine Description:

    Allocates a locally unique ID (LUID).

Arguments:

    Luid - Supplies a pointer used to return the LUID.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{   NTSTATUS Status;

    Status = NtAllocateLocallyUniqueId( Luid );
    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }

    return( TRUE );
}




BOOL
APIENTRY
AccessCheck (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    input token and indicates by its return value if access is granted
    or denied.  If access is granted then the desired access mask
    becomes the granted access mask for the object.

    The semantics of the access check routine is described in the DSA
    Security Architecture workbook.  Note that during an access check
    only the discretionary ACL is examined.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealStatus;

    Status = NtAccessCheck (
                pSecurityDescriptor,
                ClientToken,
                DesiredAccess,
                GenericMapping,
                PrivilegeSet,
                PrivilegeSetLength,
                GrantedAccess,
                &RealStatus
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if ( !NT_SUCCESS( RealStatus ) ) {
        BaseSetLastNTError( RealStatus );
        *AccessStatus = FALSE;
        return( TRUE );
    }

    *AccessStatus = TRUE;
    return TRUE;
}




BOOL
APIENTRY
AccessCheckByType (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID PrincipalSelfSid,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    input token and indicates by its return value if access is granted
    or denied.  If access is granted then the desired access mask
    becomes the granted access mask for the object.

    The semantics of the access check routine is described in the DSA
    Security Architecture workbook.  Note that during an access check
    only the discretionary ACL is examined.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccess - Returns an access mask describing the granted access.

    AccessStatus - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealStatus;

    Status = NtAccessCheckByType (
                pSecurityDescriptor,
                PrincipalSelfSid,
                ClientToken,
                DesiredAccess,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                PrivilegeSet,
                PrivilegeSetLength,
                GrantedAccess,
                &RealStatus
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if ( !NT_SUCCESS( RealStatus ) ) {
        BaseSetLastNTError( RealStatus );
        *AccessStatus = FALSE;
        return( TRUE );
    }

    *AccessStatus = TRUE;
    return TRUE;
}




BOOL
APIENTRY
AccessCheckByTypeResultList (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID PrincipalSelfSid,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccessList,
    LPDWORD AccessStatusList
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    input token and indicates by its return value if access is granted
    or denied.  If access is granted then the desired access mask
    becomes the granted access mask for the object.

    The semantics of the access check routine is described in the DSA
    Security Architecture workbook.  Note that during an access check
    only the discretionary ACL is examined.

Arguments:

    SecurityDescriptor - Supplies the security descriptor protecting the object
        being accessed

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    ClientToken - Supplies the handle of the user's token.

    DesiredAccess - Supplies the desired access mask.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    PrivilegeSet - A pointer to a buffer that upon return will contain
        any privileges that were used to perform the access validation.
        If no privileges were used, the buffer will contain a privilege
        set consisting of zero privileges.

    PrivilegeSetLength - The size of the PrivilegeSet buffer in bytes.

    GrantedAccessList - Returns an access mask describing the granted access.

    AccessStatusList - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealStatus;
    ULONG i;

    ASSERT (sizeof(NTSTATUS) == sizeof(DWORD) );

    Status = NtAccessCheckByTypeResultList (
                pSecurityDescriptor,
                PrincipalSelfSid,
                ClientToken,
                DesiredAccess,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                PrivilegeSet,
                PrivilegeSetLength,
                GrantedAccessList,
                (PNTSTATUS)AccessStatusList
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Loop converting the array of NT status codes to WIN status codes.
    //

    for ( i=0; i<ObjectTypeListLength; i++ ) {
        if ( AccessStatusList[i] == STATUS_SUCCESS ) {
            AccessStatusList[i] = NO_ERROR;
        } else {
            AccessStatusList[i] = RtlNtStatusToDosError( AccessStatusList[i] );
        }
    }

    return TRUE;
}




BOOL
APIENTRY
OpenProcessToken (
    HANDLE ProcessHandle,
    DWORD DesiredAccess,
    PHANDLE TokenHandle
    )
/*++

Routine Description:

    Open a token object associated with a process and return a handle
    that may be used to access that token.

Arguments:

    ProcessHandle - Specifies the process whose token is to be
        opened.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the token.  These access types are reconciled
        with the Discretionary Access Control list of the token to
        determine whether the accesses will be granted or denied.

    TokenHandle - Receives the handle of the newly opened token.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtOpenProcessToken (
        ProcessHandle,
        DesiredAccess,
        TokenHandle
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
OpenThreadToken (
    HANDLE ThreadHandle,
    DWORD DesiredAccess,
    BOOL OpenAsSelf,
    PHANDLE TokenHandle
    )
/*++


Routine Description:

Open a token object associated with a thread and return a handle that
may be used to access that token.

Arguments:

    ThreadHandle - Specifies the thread whose token is to be opened.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the token.  These access types are reconciled
        with the Discretionary Access Control list of the token to
        determine whether the accesses will be granted or denied.

    OpenAsSelf - Is a boolean value indicating whether the access should
        be made using the calling thread's current security context, which
        may be that of a client if impersonating, or using the caller's
        process-level security context.  A value of FALSE indicates the
        caller's current context should be used un-modified.  A value of
        TRUE indicates the request should be fulfilled using the process
        level security context.

        This parameter is necessary to allow a server process to open
        a client's token when the client specified IDENTIFICATION level
        impersonation.  In this case, the caller would not be able to
        open the client's token using the client's context (because you
        can't create executive level objects using IDENTIFICATION level
        impersonation).

    TokenHandle - Receives the handle of the newly opened token.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtOpenThreadToken (
        ThreadHandle,
        DesiredAccess,
        (BOOLEAN)OpenAsSelf,
        TokenHandle
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
GetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength
    )
/*++


Routine Description:

    Retrieve information about a specified token.

Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    TokenInformationClass - The token information class about which
        to retrieve information.

    TokenInformation - The buffer to receive the requested class of
        information.  The buffer must be aligned on at least a
        longword boundary.  The actual structures returned are
        dependent upon the information class requested, as defined in
        the TokenInformationClass parameter description.

        TokenInformation Format By Information Class:

           TokenUser => TOKEN_USER data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenGroups => TOKEN_GROUPS data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenPrivileges => TOKEN_PRIVILEGES data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenOwner => TOKEN_OWNER data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenPrimaryGroup => TOKEN_PRIMARY_GROUP data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenDefaultDacl => TOKEN_DEFAULT_DACL data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenSource => TOKEN_SOURCE data structure.
           TOKEN_QUERY_SOURCE access is needed to retrieve this
           information about a token.

           TokenType => TOKEN_TYPE data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenStatistics => TOKEN_STATISTICS data structure.
           TOKEN_QUERY access is needed to retrieve this
           information about a token.

    TokenInformationLength - Indicates the length, in bytes, of the
        TokenInformation buffer.

    ReturnLength - This parameter receives the actual length of the
        requested information.  If this value is larger than that
        provided by the TokenInformationLength parameter, then the
        buffer provided to receive the requested information is not
        large enough to hold that data and no data is returned.

        If the queried class is TokenDefaultDacl and there is no
        default Dacl established for the token, then the return
        length will be returned as zero, and no data will be returned.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtQueryInformationToken (
        TokenHandle,
        TokenInformationClass,
        TokenInformation,
        TokenInformationLength,
        ReturnLength
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
SetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID TokenInformation,
    DWORD TokenInformationLength
    )
/*++


Routine Description:

    Modify information in a specified token.

Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    TokenInformationClass - The token information class being set.

    TokenInformation - The buffer containing the new values for the
        specified class of information.  The buffer must be aligned
        on at least a longword boundary.  The actual structures
        provided are dependent upon the information class specified,
        as defined in the TokenInformationClass parameter
        description.

        TokenInformation Format By Information Class:

           TokenUser => This value is not a valid value for this API.
           The User ID may not be replaced.

           TokenGroups => This value is not a valid value for this
           API.  The Group IDs may not be replaced.  However, groups
           may be enabled and disabled using NtAdjustGroupsToken().

           TokenPrivileges => This value is not a valid value for
           this API.  Privilege information may not be replaced.
           However, privileges may be explicitly enabled and disabled
           using the NtAdjustPrivilegesToken API.

           TokenOwner => TOKEN_OWNER data structure.
           TOKEN_ADJUST_DEFAULT access is needed to replace this
           information in a token.  The owner values that may be
           specified are restricted to the user and group IDs with an
           attribute indicating they may be assigned as the owner of
           objects.

           TokenPrimaryGroup => TOKEN_PRIMARY_GROUP data structure.
           TOKEN_ADJUST_DEFAULT access is needed to replace this
           information in a token.  The primary group values that may
           be specified are restricted to be one of the group IDs
           already in the token.

           TokenDefaultDacl => TOKEN_DEFAULT_DACL data structure.
           TOKEN_ADJUST_DEFAULT access is needed to replace this
           information in a token.  The ACL provided as a new default
           discretionary ACL is not validated for structural
           correctness or consistency.

           TokenSource => This value is not a valid value for this
           API.  The source name and context handle  may not be
           replaced.

           TokenStatistics => This value is not a valid value for this
           API.  The statistics of a token are read-only.

    TokenInformationLength - Indicates the length, in bytes, of the
        TokenInformation buffer.  This is only the length of the primary
        buffer.  All extensions of the primary buffer are self describing.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtSetInformationToken (
        TokenHandle,
        TokenInformationClass,
        TokenInformation,
        TokenInformationLength
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
AdjustTokenPrivileges (
    HANDLE TokenHandle,
    BOOL DisableAllPrivileges,
    PTOKEN_PRIVILEGES NewState,
    DWORD BufferLength,
    PTOKEN_PRIVILEGES PreviousState,
    PDWORD ReturnLength
    )
/*++


Routine Description:

    This routine is used to disable or enable privileges in the
    specified token.  The absence of some of the privileges listed to
    be changed won't effect the successful modification of the
    privileges that are in the token.  The previous enabled/disabled
    state of changed privileges may optionally be capture (for
    resetting later).

    TOKEN_ADJUST_PRIVILEGES access is required to enable or disable
    privileges in a token.


Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    DisableAllPrivileges - This boolean parameter may be
        used to disable all privileges assigned to the token.  If
        this parameter is specified as TRUE, then the NewState parameter is
        ignored.

    NewState - This (optional) parameter points to a TOKEN_PRIVILEGES
        data structure containing the privileges whose states are to
        be adjusted (disabled or enabled).  Only the Enabled flag of
        the attributes associated with each privilege is used.  It
        provides the new value that is to be assigned to the privilege
        in the token.

    BufferLength - This optional parameter indicates the length (in
        bytes) of the PreviousState buffer.  This value must be
        provided if the PreviousState parameter is provided.

    PreviousState - This (optional) parameter points to a buffer to
        receive the state of any privileges actually changed by this
        request.  This information is formated as a TOKEN_PRIVILEGES
        data structure which may be passed as the NewState parameter
        in a subsequent call to this routine to restore the original
        state of those privilges.  TOKEN_QUERY access is needed to use
        this parameter.

        If this buffer does not contain enough space to receive the
        complete list of modified privileges, then no privilege
        states are changed and STATUS_BUFFER_TOO_SMALL is returned.
        In this case, the ReturnLength OUT parameter will
        contain the actual number of bytes needed to hold the
        information.

    ReturnLength - Indicates the actual number of bytes needed to
        contain the previous privilege state information.  This
        parameter is ignored if the PreviousState argument is not
        passed.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtAdjustPrivilegesToken (
        TokenHandle,
        (BOOLEAN)DisableAllPrivileges,
        NewState,
        BufferLength,
        PreviousState,
        ReturnLength
        );

    //
    // We need to set last error even for success because that
    // is the only way to tell if the api successfully assigned
    // all privileges.  That is, STATUS_NOT_ALL_ASSIGNED is a
    // Success severity level.
    //

    BaseSetLastNTError(Status);


    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
AdjustTokenGroups (
    HANDLE TokenHandle,
    BOOL ResetToDefault,
    PTOKEN_GROUPS NewState,
    DWORD BufferLength,
    PTOKEN_GROUPS PreviousState,
    PDWORD ReturnLength
    )
/*++


Routine Description:

    This routine is used to disable or enable groups in the specified
    token.  The absence of some of the groups listed to be changed
    won't effect the successful modification of the groups that are in
    the token.  The previous enabled/disabled state of changed groups
    may optionally be capture (for resetting later).

    TOKEN_ADJUST_GROUPS access is required to enable or disable groups
    in a token

    Note that mandatory groups can not be disabled.  An attempt
    disable any mandatory groups will cause the call to fail, leaving
    the state of all groups unchanged.


Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    ResetToDefault - The parameter indicates whether all the groups
        in the token are to be reset to their default enabled/disabled
        state.

    NewState - This parameter points to a TOKEN_GROUPS data structure
        containing the groups whose states are to be adjusted
        (disabled or enabled).  Only the Enabled flag of the
        attributes associated with each group is used.  It provides
        the new value that is to be assigned to the group in the
        token.  If the ResetToDefault argument is specified as TRUE,
        then this argument is ignored.  Otherwise, it must be passed.

    BufferLength - This optional parameter indicates the length (in
        bytes) of the PreviousState buffer.  This value must be
        provided if the PreviousState parameter is provided.

    PreviousState - This (optional) parameter points to a buffer to
        receive the state of any groups actually changed by this
        request.  This information is formated as a TOKEN_GROUPS data
        structure which may be passed as the NewState parameter in a
        subsequent call to NtAdjustGroups to restore the original state
        of those groups.  TOKEN_QUERY access is needed to use this
        parameter.

        If this buffer does not contain enough space to receive the
        complete list of modified groups, then no group states are
        changed and STATUS_BUFFER_TOO_SMALL is returned.  In this
        case, the ReturnLength return parameter will contain the
        actual number of bytes needed to hold the information.

    ReturnLength - Indicates the actual number of bytes needed to
        contain the previous group state information.
        This parameter is ignored if the PreviousState argument is not
        passed.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtAdjustGroupsToken (
        TokenHandle,
        (BOOLEAN)ResetToDefault,
        NewState,
        BufferLength,
        PreviousState,
        ReturnLength
        );

    //
    // We need to set last error even for success because that
    // is the only way to tell if the api successfully assigned
    // all groups.  That is, STATUS_NOT_ALL_ASSIGNED is a
    // Success severity level.
    //

    BaseSetLastNTError(Status);


    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
    }

    return TRUE;

}





BOOL
APIENTRY
PrivilegeCheck (
    HANDLE ClientToken,
    PPRIVILEGE_SET RequiredPrivileges,
    LPBOOL pfResult
    )
/*++

Routine Description:

    This routine tests the caller's client's security context to see if it
    contains the specified privileges.

    This API requires the caller have SeSecurityPrivilege privilege.
    The test for this privilege is always against the primary token of
    the calling process, not the impersonation token of the thread.


Arguments:

    ClientToken - A handle to a token object representing a client
        attempting access.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    RequiredPrivileges - Points to a set of privileges.  The client's
        security context is to be checked to see which of the specified
        privileges are present.  The results will be indicated in the
        attributes associated with each privilege.  Note that
        flags in this parameter indicate whether all the privileges listed
        are needed, or any of the privileges.

    pfResult - Receives a boolean flag indicating whether the client
        has all the specified privileges or not.  A value of TRUE
        indicates the client has all the specified privileges.
        Otherwise a value of FALSE is returned.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    BOOLEAN Result;

    Status = NtPrivilegeCheck (
                ClientToken,
                RequiredPrivileges,
                &Result
                );

    *pfResult = Result;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
AccessCheckAndAuditAlarmW(
    LPCWSTR SubsystemName,
    PVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    caller's impersonation token and indicates if access is granted or
    denied.  If access is granted then the desired access mask becomes
    the granted access mask for the object.  The semantics of the
    access check routine is described in the DSA Security Architecture
    workbook.

    This routine will also generate any necessary audit messages as a
    result of the access attempt.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value that will be used to represent the client's
        handle to the object.  This value is ignored (and may be re-used)
        if the access is denied.

    ObjectTypeName - Supplies the name of the type of the object being
        created or accessed.

    ObjectName - Supplies the name of the object being created or accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - The desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    ObjectCreation - A boolean flag indicated whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    GrantedAccess - Receives a masking indicating which accesses have been
        granted (only valid on success).

    AccessStatus - Receives an indication of the success or failure of the
        access check.  If access is granted, STATUS_SUCCESS is returned.
        If access is denied, a value appropriate for return to the client
        is returned.  This will be STATUS_ACCESS_DENIED or, when mandatory
        access controls are implemented, STATUS_OBJECT_NOT_FOUND.

    pfGenerateOnClose - Points to a boolean that is set by the audity
        generation routine and must be passed to ObjectCloseAuditAlarm
        when the object handle is closed.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealAccessStatus;
    BOOLEAN GenerateOnClose = FALSE;
    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;


    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    RtlInitUnicodeString(
        &ObjectType,
        ObjectTypeName
        );

    RtlInitUnicodeString(
        &Object,
        ObjectName
        );

    Status = NtAccessCheckAndAuditAlarm (
                &Subsystem,
                HandleId,
                &ObjectType,
                &Object,
                SecurityDescriptor,
                DesiredAccess,
                GenericMapping,
                (BOOLEAN)ObjectCreation,
                GrantedAccess,
                &RealAccessStatus,
                &GenerateOnClose
                );


    *pfGenerateOnClose = (BOOL)GenerateOnClose;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if ( !NT_SUCCESS( RealAccessStatus )) {
        *AccessStatus = FALSE;
        BaseSetLastNTError( RealAccessStatus );
        return( TRUE );
    }

    *AccessStatus = TRUE;
    return TRUE;
}

BOOL
APIENTRY
AccessCheckByTypeAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    caller's impersonation token and indicates if access is granted or
    denied.  If access is granted then the desired access mask becomes
    the granted access mask for the object.  The semantics of the
    access check routine is described in the DSA Security Architecture
    workbook.

    This routine will also generate any necessary audit messages as a
    result of the access attempt.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value that will be used to represent the client's
        handle to the object.  This value is ignored (and may be re-used)
        if the access is denied.

    ObjectTypeName - Supplies the name of the type of the object being
        created or accessed.

    ObjectName - Supplies the name of the object being created or accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    DesiredAccess - The desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    AuditType - Specifies the type of audit to be generated.  Valid values
        are: AuditEventObjectAccess and AuditEventDirectoryServiceAccess.

    Flags - Flags modifying the execution of the API:

        AUDIT_ALLOW_NO_PRIVILEGE - If the caller does not have AuditPrivilege,
            the call will silently continue to check access and will
            generate no audit.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    ObjectCreation - A boolean flag indicated whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    GrantedAccess - Receives a masking indicating which accesses have been
        granted (only valid on success).

    AccessStatus - Receives an indication of the success or failure of the
        access check.  If access is granted, STATUS_SUCCESS is returned.
        If access is denied, a value appropriate for return to the client
        is returned.  This will be STATUS_ACCESS_DENIED or, when mandatory
        access controls are implemented, STATUS_OBJECT_NOT_FOUND.

    pfGenerateOnClose - Points to a boolean that is set by the audity
        generation routine and must be passed to ObjectCloseAuditAlarm
        when the object handle is closed.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealAccessStatus;
    BOOLEAN GenerateOnClose = FALSE;
    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;

    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    RtlInitUnicodeString(
        &ObjectType,
        ObjectTypeName
        );

    RtlInitUnicodeString(
        &Object,
        ObjectName
        );

    Status = NtAccessCheckByTypeAndAuditAlarm (
                &Subsystem,
                HandleId,
                &ObjectType,
                &Object,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                (BOOLEAN)ObjectCreation,
                GrantedAccess,
                &RealAccessStatus,
                &GenerateOnClose
                );


    *pfGenerateOnClose = (BOOL)GenerateOnClose;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if ( !NT_SUCCESS( RealAccessStatus )) {
        *AccessStatus = FALSE;
        BaseSetLastNTError( RealAccessStatus );
        return( TRUE );
    }

    *AccessStatus = TRUE;
    return TRUE;
}


BOOL
APIENTRY
AccessCheckByTypeResultListAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccessList,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    caller's impersonation token and indicates if access is granted or
    denied.  If access is granted then the desired access mask becomes
    the granted access mask for the object.  The semantics of the
    access check routine is described in the DSA Security Architecture
    workbook.

    This routine will also generate any necessary audit messages as a
    result of the access attempt.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value that will be used to represent the client's
        handle to the object.  This value is ignored (and may be re-used)
        if the access is denied.

    ObjectTypeName - Supplies the name of the type of the object being
        created or accessed.

    ObjectName - Supplies the name of the object being created or accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    DesiredAccess - The desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    AuditType - Specifies the type of audit to be generated.  Valid values
        are: AuditEventObjectAccess and AuditEventDirectoryServiceAccess.

    Flags - Flags modifying the execution of the API:

        AUDIT_ALLOW_NO_PRIVILEGE - If the called does not have AuditPrivilege,
            the call will silently continue to check access and will
            generate no audit.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    ObjectCreation - A boolean flag indicated whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    GrantedAccessList - Returns an access mask describing the granted access.

    AccessStatusList - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

    pfGenerateOnClose - Points to a boolean that is set by the audity
        generation routine and must be passed to ObjectCloseAuditAlarm
        when the object handle is closed.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealAccessStatus;
    BOOLEAN GenerateOnClose = FALSE;
    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;
    ULONG i;


    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    RtlInitUnicodeString(
        &ObjectType,
        ObjectTypeName
        );

    RtlInitUnicodeString(
        &Object,
        ObjectName
        );

    Status = NtAccessCheckByTypeResultListAndAuditAlarm (
                &Subsystem,
                HandleId,
                &ObjectType,
                &Object,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                (BOOLEAN)ObjectCreation,
                GrantedAccessList,
                AccessStatusList,
                &GenerateOnClose
                );


    *pfGenerateOnClose = (BOOL)GenerateOnClose;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Loop converting the array of NT status codes to WIN status codes.
    //

    for ( i=0; i<ObjectTypeListLength; i++ ) {
        if ( AccessStatusList[i] == STATUS_SUCCESS ) {
            AccessStatusList[i] = NO_ERROR;
        } else {
            AccessStatusList[i] = RtlNtStatusToDosError( AccessStatusList[i] );
        }
    }

    return TRUE;
}


BOOL
APIENTRY
AccessCheckByTypeResultListAndAuditAlarmByHandleW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccessList,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    caller's impersonation token and indicates if access is granted or
    denied.  If access is granted then the desired access mask becomes
    the granted access mask for the object.  The semantics of the
    access check routine is described in the DSA Security Architecture
    workbook.

    This routine will also generate any necessary audit messages as a
    result of the access attempt.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value that will be used to represent the client's
        handle to the object.  This value is ignored (and may be re-used)
        if the access is denied.

    ClientToken - A handle to a token object representing the client that
        requested the operation.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    ObjectTypeName - Supplies the name of the type of the object being
        created or accessed.

    ObjectName - Supplies the name of the object being created or accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    DesiredAccess - The desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    AuditType - Specifies the type of audit to be generated.  Valid values
        are: AuditEventObjectAccess and AuditEventDirectoryServiceAccess.

    Flags - Flags modifying the execution of the API:

        AUDIT_ALLOW_NO_PRIVILEGE - If the called does not have AuditPrivilege,
            the call will silently continue to check access and will
            generate no audit.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    ObjectCreation - A boolean flag indicated whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    GrantedAccessList - Returns an access mask describing the granted access.

    AccessStatusList - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

    pfGenerateOnClose - Points to a boolean that is set by the audity
        generation routine and must be passed to ObjectCloseAuditAlarm
        when the object handle is closed.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealAccessStatus;
    BOOLEAN GenerateOnClose = FALSE;
    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;
    ULONG i;


    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    RtlInitUnicodeString(
        &ObjectType,
        ObjectTypeName
        );

    RtlInitUnicodeString(
        &Object,
        ObjectName
        );

    Status = NtAccessCheckByTypeResultListAndAuditAlarmByHandle (
                &Subsystem,
                HandleId,
                ClientToken,
                &ObjectType,
                &Object,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                (BOOLEAN)ObjectCreation,
                GrantedAccessList,
                AccessStatusList,
                &GenerateOnClose
                );


    *pfGenerateOnClose = (BOOL)GenerateOnClose;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Loop converting the array of NT status codes to WIN status codes.
    //

    for ( i=0; i<ObjectTypeListLength; i++ ) {
        if ( AccessStatusList[i] == STATUS_SUCCESS ) {
            AccessStatusList[i] = NO_ERROR;
        } else {
            AccessStatusList[i] = RtlNtStatusToDosError( AccessStatusList[i] );
        }
    }

    return TRUE;
}


BOOL
APIENTRY
AccessCheckAndAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to AccessCheckAndAuditAlarmW

--*/
{
    PUNICODE_STRING ObjectNameW;
    ANSI_STRING AnsiString;
    UNICODE_STRING SubsystemNameW;
    UNICODE_STRING ObjectTypeNameW;
    NTSTATUS Status;
    BOOL RVal;


    ObjectNameW = &NtCurrentTeb()->StaticUnicodeString;


    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }



    RtlInitAnsiString(&AnsiString,ObjectTypeName);
    Status = RtlAnsiStringToUnicodeString(&ObjectTypeNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ObjectName);
    Status = RtlAnsiStringToUnicodeString(ObjectNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );
        RtlFreeUnicodeString( &ObjectTypeNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    RVal =  AccessCheckAndAuditAlarmW (
                (LPCWSTR)SubsystemNameW.Buffer,
                HandleId,
                ObjectTypeNameW.Buffer,
                ObjectNameW->Buffer,
                SecurityDescriptor,
                DesiredAccess,
                GenericMapping,
                ObjectCreation,
                GrantedAccess,
                AccessStatus,
                pfGenerateOnClose
                );


    RtlFreeUnicodeString( &SubsystemNameW );
    RtlFreeUnicodeString( &ObjectTypeNameW );

    return( RVal );
}

BOOL
APIENTRY
AccessCheckByTypeAndAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to AccessCheckByTypeAndAuditAlarmW

--*/
{
    PUNICODE_STRING ObjectNameW;
    ANSI_STRING AnsiString;
    UNICODE_STRING SubsystemNameW;
    UNICODE_STRING ObjectTypeNameW;
    NTSTATUS Status;

    BOOL RVal;


    ObjectNameW = &NtCurrentTeb()->StaticUnicodeString;


    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }



    RtlInitAnsiString(&AnsiString,ObjectTypeName);
    Status = RtlAnsiStringToUnicodeString(&ObjectTypeNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ObjectName);
    Status = RtlAnsiStringToUnicodeString(ObjectNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );
        RtlFreeUnicodeString( &ObjectTypeNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    RVal =  AccessCheckByTypeAndAuditAlarmW (
                (LPCWSTR)SubsystemNameW.Buffer,
                HandleId,
                ObjectTypeNameW.Buffer,
                ObjectNameW->Buffer,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                ObjectCreation,
                GrantedAccess,
                AccessStatus,
                pfGenerateOnClose
                );


    RtlFreeUnicodeString( &SubsystemNameW );
    RtlFreeUnicodeString( &ObjectTypeNameW );

    return( RVal );
}

WINADVAPI
BOOL
WINAPI
AccessCheckByTypeResultListAndAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to AccessCheckByTypeResultListAndAuditAlarmW

--*/
{
    PUNICODE_STRING ObjectNameW;
    ANSI_STRING AnsiString;
    UNICODE_STRING SubsystemNameW;
    UNICODE_STRING ObjectTypeNameW;
    NTSTATUS Status;

    BOOL RVal;


    ObjectNameW = &NtCurrentTeb()->StaticUnicodeString;


    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }



    RtlInitAnsiString(&AnsiString,ObjectTypeName);
    Status = RtlAnsiStringToUnicodeString(&ObjectTypeNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ObjectName);
    Status = RtlAnsiStringToUnicodeString(ObjectNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );
        RtlFreeUnicodeString( &ObjectTypeNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    RVal =  AccessCheckByTypeResultListAndAuditAlarmW (
                (LPCWSTR)SubsystemNameW.Buffer,
                HandleId,
                ObjectTypeNameW.Buffer,
                ObjectNameW->Buffer,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                ObjectCreation,
                GrantedAccess,
                AccessStatusList,
                pfGenerateOnClose
                );

    RtlFreeUnicodeString( &SubsystemNameW );
    RtlFreeUnicodeString( &ObjectTypeNameW );

    return( RVal );
}


WINADVAPI
BOOL
WINAPI
AccessCheckByTypeResultListAndAuditAlarmByHandleA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to AccessCheckByTypeResultListAndAuditAlarmW

--*/
{
    PUNICODE_STRING ObjectNameW;
    ANSI_STRING AnsiString;
    UNICODE_STRING SubsystemNameW;
    UNICODE_STRING ObjectTypeNameW;
    NTSTATUS Status;

    BOOL RVal;


    ObjectNameW = &NtCurrentTeb()->StaticUnicodeString;


    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }



    RtlInitAnsiString(&AnsiString,ObjectTypeName);
    Status = RtlAnsiStringToUnicodeString(&ObjectTypeNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ObjectName);
    Status = RtlAnsiStringToUnicodeString(ObjectNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );
        RtlFreeUnicodeString( &ObjectTypeNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    RVal =  AccessCheckByTypeResultListAndAuditAlarmByHandleW (
                (LPCWSTR)SubsystemNameW.Buffer,
                HandleId,
                ClientToken,
                ObjectTypeNameW.Buffer,
                ObjectNameW->Buffer,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                ObjectCreation,
                GrantedAccess,
                AccessStatusList,
                pfGenerateOnClose
                );

    RtlFreeUnicodeString( &SubsystemNameW );
    RtlFreeUnicodeString( &ObjectTypeNameW );

    return( RVal );
}

BOOL
APIENTRY
ObjectOpenAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges OPTIONAL,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to ObjectOpenAuditAlarmW

--*/
{
    PUNICODE_STRING ObjectNameW;
    ANSI_STRING AnsiString;
    UNICODE_STRING SubsystemNameW;
    UNICODE_STRING ObjectTypeNameW;
    NTSTATUS Status;
    BOOL RVal;


    ObjectNameW = &NtCurrentTeb()->StaticUnicodeString;


    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }



    RtlInitAnsiString(&AnsiString,ObjectTypeName);
    Status = RtlAnsiStringToUnicodeString(&ObjectTypeNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ObjectName);
    Status = RtlAnsiStringToUnicodeString(ObjectNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );
        RtlFreeUnicodeString( &ObjectTypeNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }

    RVal = ObjectOpenAuditAlarmW (
               (LPCWSTR)SubsystemNameW.Buffer,
               HandleId,
               ObjectTypeNameW.Buffer,
               ObjectNameW->Buffer,
               pSecurityDescriptor,
               ClientToken,
               DesiredAccess,
               GrantedAccess,
               Privileges,
               ObjectCreation,
               AccessGranted,
               GenerateOnClose
               );

    RtlFreeUnicodeString( &SubsystemNameW );
    RtlFreeUnicodeString( &ObjectTypeNameW );

    return( RVal );

}



BOOL
APIENTRY
ObjectOpenAuditAlarmW (
    LPCWSTR SubsystemName,
    PVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges OPTIONAL,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    )
/*++

    Routine Description:

    This routine is used to generate audit and alarm messages when an
    attempt is made to access an existing protected subsystem object or
    create a new one.  This routine may result in several messages being
    generated and sent to Port objects.  This may result in a significant
    latency before returning.  Design of routines that must call this
    routine must take this potential latency into account.  This may have
    an impact on the approach taken for data structure mutex locking, for
    example.

    This routine may not be able to generate a complete audit record
    due to memory restrictions.

    This API requires the caller have SeSecurityPrivilege privilege.
    The test for this privilege is always against the primary token of
    the calling process, not the impersonation token of the thread.

Arguments:

    SubsystemName - Supplies a name string identifying the
        subsystem calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.  If the access attempt was not successful (AccessGranted is
        FALSE), then this parameter is ignored.

    ObjectTypeName - Supplies the name of the type of object being
        accessed.

    ObjectName - Supplies the name of the object the client
        accessed or attempted to access.

    pSecurityDescriptor - An optional pointer to the security
        descriptor of the object being accessed.

    ClientToken - A handle to a token object representing the client that
        requested the operation.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    DesiredAccess - The desired access mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GrantedAccess - The mask of accesses that were actually granted.

    Privileges - Optionally points to a set of privileges that were
        required for the access attempt.  Those privileges that were held
        by the subject are marked using the UsedForAccess flag of the
        attributes associated with each privilege.

    ObjectCreation - A boolean flag indicating whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.

    GenerateOnClose - Points to a boolean that is set by the audit
        generation routine and must be passed to NtCloseObjectAuditAlarm()
        when the object handle is closed.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;


    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    RtlInitUnicodeString(
        &ObjectType,
        ObjectTypeName
        );

    RtlInitUnicodeString(
        &Object,
        ObjectName
        );

    Status = NtOpenObjectAuditAlarm (
                &Subsystem,
                &HandleId,
                &ObjectType,
                &Object,
                pSecurityDescriptor,
                ClientToken,
                DesiredAccess,
                GrantedAccess,
                Privileges,
                (BOOLEAN)ObjectCreation,
                (BOOLEAN)AccessGranted,
                (PBOOLEAN)GenerateOnClose
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
ObjectPrivilegeAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    )
/*++

Routine Description:

    ANSI Thunk to ObjectPrivilegeAuditAlarmW

--*/
{
    PUNICODE_STRING SubsystemNameW;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL RVal;

    SubsystemNameW = &NtCurrentTeb()->StaticUnicodeString;

    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(SubsystemNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }

    RVal = ObjectPrivilegeAuditAlarmW (
                (LPCWSTR)SubsystemNameW->Buffer,
                HandleId,
                ClientToken,
                DesiredAccess,
                Privileges,
                AccessGranted
                );

    return( RVal );
}




BOOL
APIENTRY
ObjectPrivilegeAuditAlarmW (
    LPCWSTR SubsystemName,
    PVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    )
/*++

Routine Description:

    This routine is used to generate audit and alarm messages when an
    attempt is made to perform privileged operations on a protected
    subsystem object after the object is already opened.  This routine
    may result in several messages being generated and sent to Port
    objects.  This may result in a significant latency before
    returning.  Design of routines that must call this routine must
    take this potential latency into account.  This may have an impact
    on the approach taken for data structure mutex locking, for
    example.

    This API requires the caller have SeSecurityPrivilege privilege.
    The test for this privilege is always against the primary token of
    the calling process, allowing the caller to be impersonating a
    client during the call with no ill effects.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    ClientToken - A handle to a token object representing the client that
        requested the operation.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    DesiredAccess - The desired access mask.  This mask must have been
        previously mapped to contain no generic accesses.

    Privileges - The set of privileges required for the requested
        operation.  Those privileges that were held by the subject are
        marked using the UsedForAccess flag of the attributes
        associated with each privilege.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.

Return value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING Subsystem;

    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    Status = NtPrivilegeObjectAuditAlarm (
        &Subsystem,
        HandleId,
        ClientToken,
        DesiredAccess,
        Privileges,
        (BOOLEAN)AccessGranted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
ObjectCloseAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    BOOL GenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to ObjectCloseAuditAlarmW

--*/
{
    PUNICODE_STRING SubsystemNameW;
    NTSTATUS Status;
    ANSI_STRING AnsiString;

    SubsystemNameW = &NtCurrentTeb()->StaticUnicodeString;

    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(SubsystemNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }

    return ObjectCloseAuditAlarmW (
               (LPCWSTR)SubsystemNameW->Buffer,
               HandleId,
               GenerateOnClose
               );


}

BOOL
APIENTRY
ObjectCloseAuditAlarmW (
    LPCWSTR SubsystemName,
    PVOID HandleId,
    BOOL GenerateOnClose
    )
/*++

Routine Description:

    This routine is used to generate audit and alarm messages when a handle
    to a protected subsystem object is deleted.  This routine may result in
    several messages being generated and sent to Port objects.  This may
    result in a significant latency before returning.  Design of routines
    that must call this routine must take this potential latency into
    account.  This may have an impact on the approach taken for data
    structure mutex locking, for example.

    This API requires the caller have SeSecurityPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, allowing the caller to be impersonating a client during the
    call with no ill effects.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    GenerateOnClose - Is a boolean value returned from a corresponding
        AccessCheckAndAuditAlarm() call or ObjectOpenAuditAlarm() call
        when the object handle was created.

Return value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;
    UNICODE_STRING Subsystem;

    RtlInitUnicodeString( &Subsystem, SubsystemName );

    Status = NtCloseObjectAuditAlarm (
        &Subsystem,
        HandleId,
        (BOOLEAN)GenerateOnClose
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
ObjectDeleteAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    BOOL GenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to ObjectDeleteAuditAlarmW

--*/
{
    PUNICODE_STRING SubsystemNameW;
    NTSTATUS Status;
    ANSI_STRING AnsiString;

    SubsystemNameW = &NtCurrentTeb()->StaticUnicodeString;

    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(SubsystemNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }

    return ObjectDeleteAuditAlarmW (
               (LPCWSTR)SubsystemNameW->Buffer,
               HandleId,
               GenerateOnClose
               );


}

BOOL
APIENTRY
ObjectDeleteAuditAlarmW (
    LPCWSTR SubsystemName,
    PVOID HandleId,
    BOOL GenerateOnClose
    )
/*++

Routine Description:

    This routine is used to generate audit and alarm messages when an object
    in a protected subsystem is deleted.  This routine may result in
    several messages being generated and sent to Port objects.  This may
    result in a significant latency before returning.  Design of routines
    that must call this routine must take this potential latency into
    account.  This may have an impact on the approach taken for data
    structure mutex locking, for example.

    This API requires the caller have SeSecurityPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, allowing the caller to be impersonating a client during the
    call with no ill effects.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    GenerateOnClose - Is a boolean value returned from a corresponding
        AccessCheckAndAuditAlarm() call or ObjectOpenAuditAlarm() call
        when the object handle was created.

Return value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;
    UNICODE_STRING Subsystem;

    RtlInitUnicodeString( &Subsystem, SubsystemName );

    Status = NtDeleteObjectAuditAlarm (
        &Subsystem,
        HandleId,
        (BOOLEAN)GenerateOnClose
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
PrivilegedServiceAuditAlarmA (
    LPCSTR SubsystemName,
    LPCSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    )
/*++

Routine Description:

    ANSI Thunk to PrivilegedServiceAuditAlarmW

--*/
{
    PUNICODE_STRING ServiceNameW;
    UNICODE_STRING SubsystemNameW;
    ANSI_STRING  AnsiString;
    NTSTATUS Status;
    BOOL RVal;

    ServiceNameW = &NtCurrentTeb()->StaticUnicodeString;

    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ServiceName);
    Status = RtlAnsiStringToUnicodeString(ServiceNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }

    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }

    RVal =  PrivilegedServiceAuditAlarmW (
                (LPCWSTR)SubsystemNameW.Buffer,
                (LPCWSTR)ServiceNameW->Buffer,
                ClientToken,
                Privileges,
                AccessGranted
                );

    RtlFreeUnicodeString( &SubsystemNameW );

    return( RVal );

}

BOOL
APIENTRY
PrivilegedServiceAuditAlarmW (
    LPCWSTR SubsystemName,
    LPCWSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    )
/*++

Routine Description:

    This routine is used to generate audit and alarm messages when an
    attempt is made to perform privileged system service operations.  This
    routine may result in several messages being generated and sent to Port
    objects.  This may result in a significant latency before returning.
    Design of routines that must call this routine must take this potential
    latency into account.  This may have an impact on the approach taken
    for data structure mutex locking, for example.

    This API requires the caller have SeSecurityPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, allowing the caller to be impersonating a client during the
    call with no ill effects

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    ServiceName - Supplies a name of the privileged subsystem service.  For
        example, "RESET RUNTIME LOCAL SECURITY POLICY" might be specified
        by a Local Security Authority service used to update the local
        security policy database.

    ClientToken - A handle to a token object representing the client that
        requested the operation.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    Privileges - Points to a set of privileges required to perform the
        privileged operation.  Those privileges that were held by the
        subject are marked using the UsedForAccess flag of the
        attributes associated with each privilege.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.


Return value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;
    UNICODE_STRING Subsystem;
    UNICODE_STRING Service;

    RtlInitUnicodeString( &Subsystem, SubsystemName );

    RtlInitUnicodeString( &Service, ServiceName );

    Status = NtPrivilegedServiceAuditAlarm (
        &Subsystem,
        &Service,
        ClientToken,
        Privileges,
        (BOOLEAN)AccessGranted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
IsValidSid (
    PSID pSid
    )
/*++

Routine Description:

    This procedure validates an SID's structure.

Arguments:

    pSid - Pointer to the SID structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of pSid is valid.

--*/
{
    if ( !RtlValidSid ( pSid ) ) {
        SetLastError(ERROR_INVALID_SID);
        return FALSE;
    }

    return TRUE;


}




BOOL
APIENTRY
EqualSid (
    PSID pSid1,
    PSID pSid2
    )
/*++

Routine Description:

    This procedure tests two SID values for equality.

Arguments:

    pSid1, pSid2 - Supply pointers to the two SID values to compare.
        The SID structures are assumed to be valid.

Return Value:

    BOOLEAN - TRUE if the value of pSid1 is equal to pSid2, and FALSE
        otherwise.

--*/
{
    SetLastError(0);
    return (BOOL) RtlEqualSid (
                    pSid1,
                    pSid2
                    );
}




BOOL
APIENTRY
EqualPrefixSid (
    PSID pSid1,
    PSID pSid2
    )
/*++

Routine Description:

    This procedure tests two SID prefix values for equality.

    An SID prefix is the entire SID except for the last sub-authority
    value.

Arguments:

    pSid1, pSid2 - Supply pointers to the two SID values to compare.
        The SID structures are assumed to be valid.

Return Value:

    BOOLEAN - TRUE if the prefix value of pSid1 is equal to pSid2, and
        FALSE otherwise.

--*/
{
    SetLastError(0);
    return (BOOL) RtlEqualPrefixSid (
                    pSid1,
                    pSid2
                    );
}




DWORD
APIENTRY
GetSidLengthRequired (
    UCHAR nSubAuthorityCount
    )
/*++

Routine Description:

    This routine returns the length, in bytes, required to store an SID
    with the specified number of Sub-Authorities.

Arguments:

    nSubAuthorityCount - The number of sub-authorities to be stored in
        the SID.

Return Value:

    DWORD - The length, in bytes, required to store the SID.

--*/
{
    return RtlLengthRequiredSid (
                nSubAuthorityCount
                );
}



BOOL
APIENTRY
InitializeSid (
    PSID Sid,
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount
    )

/*++

Routine Description:

    This function initializes an SID data structure.  It does not,
    however, set the sub-authority values.  This must be done
    separately.

Arguments:

    Sid - Pointer to the SID data structure to initialize.

    pIdentifierAuthority - Pointer to the Identifier Authority value
        to set in the SID.

    nSubAuthorityCount - The number of sub-authorities that will be
        placed in the SID (a separate action).

Return Value:

    None

--*/
{
    NTSTATUS Status;

    Status = RtlInitializeSid (
                Sid,
                pIdentifierAuthority,
                nSubAuthorityCount
                );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }

    return( TRUE );
}



PVOID
APIENTRY
FreeSid(
    PSID pSid
    )

/*++

Routine Description:

    This function is used to free a SID previously allocated using
    AllocateAndInitializeSid().


Arguments:

    Sid - Pointer to the SID to free.

Return Value:

    None.


--*/
{
    return(RtlFreeSid( pSid ));
}



BOOL
APIENTRY
AllocateAndInitializeSid (
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount,
    DWORD nSubAuthority0,
    DWORD nSubAuthority1,
    DWORD nSubAuthority2,
    DWORD nSubAuthority3,
    DWORD nSubAuthority4,
    DWORD nSubAuthority5,
    DWORD nSubAuthority6,
    DWORD nSubAuthority7,
    PSID *pSid
    )

/*++

Routine Description:

    This function allocates and initializes a sid with the specified
    number of sub-authorities (up to 8).  A sid allocated with this
    routine must be freed using FreeSid().


Arguments:

    pIdentifierAuthority - Pointer to the Identifier Authority value to
        set in the SID.

    nSubAuthorityCount - The number of sub-authorities to place in the SID.
        This also identifies how many of the SubAuthorityN parameters
        have meaningful values.  This must contain a value from 0 through
        8.

    nSubAuthority0-7 - Provides the corresponding sub-authority value to
        place in the SID.  For example, a SubAuthorityCount value of 3
        indicates that SubAuthority0, SubAuthority1, and SubAuthority0
        have meaningful values and the rest are to be ignored.

    Sid - Receives a pointer to the allocated and initialized SID data
        structure.

Return Value:


    ERROR_NO_MEMORY - The attempt to allocate memory for the SID
        failed.

    ERROR_INVALID_SID - The number of sub-authorities specified did
        not fall in the valid range for this api (0 through 8).

--*/
{
    NTSTATUS Status;

    Status = RtlAllocateAndInitializeSid (
                 pIdentifierAuthority,
                 (UCHAR)nSubAuthorityCount,
                 (ULONG)nSubAuthority0,
                 (ULONG)nSubAuthority1,
                 (ULONG)nSubAuthority2,
                 (ULONG)nSubAuthority3,
                 (ULONG)nSubAuthority4,
                 (ULONG)nSubAuthority5,
                 (ULONG)nSubAuthority6,
                 (ULONG)nSubAuthority7,
                 pSid
                 );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }

    return( TRUE );
}




PSID_IDENTIFIER_AUTHORITY
GetSidIdentifierAuthority (
    PSID pSid
    )
/*++

Routine Description:

    This function returns the address of an SID's IdentifierAuthority field.

Arguments:

    Sid - Pointer to the SID data structure.

Return Value:

    Address of an SID's Identifier Authority field.

--*/
{
    SetLastError(0);
    return RtlIdentifierAuthoritySid (
               pSid
               );
}




PDWORD
GetSidSubAuthority (
    PSID pSid,
    DWORD nSubAuthority
    )
/*++

Routine Description:

    This function returns the address of a sub-authority array element of
    an SID.

Arguments:

    pSid - Pointer to the SID data structure.

    nSubAuthority - An index indicating which sub-authority is being
        specified.  This value is not compared against the number of
        sub-authorities in the SID for validity.

Return Value:

    Address of a relative ID within the SID.

--*/
{
    SetLastError(0);
    return RtlSubAuthoritySid (
               pSid,
               nSubAuthority
               );
}

PUCHAR
GetSidSubAuthorityCount (
    PSID pSid
    )
/*++

Routine Description:

    This function returns the address of the sub-authority count field of
    an SID.

Arguments:

    pSid - Pointer to the SID data structure.

Return Value:

    Address of the sub-authority count field of an SID.


--*/
{
    SetLastError(0);
    return RtlSubAuthorityCountSid (
               pSid
               );
}



DWORD
APIENTRY
GetLengthSid (
    PSID pSid
    )
/*++

Routine Description:

    This routine returns the length, in bytes, of a structurally valid SID.

Arguments:

    pSid - Points to the SID whose length is to be returned.  The
        SID's structure is assumed to be valid.

Return Value:

    DWORD - The length, in bytes, of the SID.

--*/
{
    SetLastError(0);
    return RtlLengthSid (
                pSid
                );
}



BOOL
APIENTRY
CopySid (
    DWORD nDestinationSidLength,
    PSID pDestinationSid,
    PSID pSourceSid
    )
/*++

Routine Description:

    This routine copies the value of the source SID to the destination
    SID.

Arguments:

    nDestinationSidLength - Indicates the length, in bytes, of the
        destination SID buffer.

    pDestinationSid - Pointer to a buffer to receive a copy of the
        source Sid value.

    pSourceSid - Supplies the Sid value to be copied.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlCopySid (
                nDestinationSidLength,
                pDestinationSid,
                pSourceSid
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
AreAllAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    )
/*++

Routine Description:

    This routine is used to check a desired access mask against a
    granted access mask.

Arguments:

        GrantedAccess - Specifies the granted access mask.

        DesiredAccess - Specifies the desired access mask.

Return Value:

    BOOL - TRUE if the GrantedAccess mask has all the bits set that
        the DesiredAccess mask has set.  That is, TRUE is returned if
        all of the desired accesses have been granted.

--*/
{
    return (BOOL) RtlAreAllAccessesGranted (
        GrantedAccess,
        DesiredAccess
        );
}




BOOL
APIENTRY
AreAnyAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    )
/*++

Routine Description:

    This routine is used to test whether any of a set of desired
    accesses are granted by a granted access mask.

Arguments:

        GrantedAccess - Specifies the granted access mask.

        DesiredAccess - Specifies the desired access mask.

Return Value:

    BOOL - TRUE if the GrantedAccess mask contains any of the bits
        specified in the DesiredAccess mask.  That is, if any of the
        desired accesses have been granted, TRUE is returned.


--*/
{
    return (BOOL) RtlAreAnyAccessesGranted (
        GrantedAccess,
        DesiredAccess
        );
}




VOID
APIENTRY
MapGenericMask (
    PDWORD AccessMask,
    PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This routine maps all generic accesses in the provided access mask
    to specific and standard accesses according to the provided
    GenericMapping.  The resulting mask will not have any of the
    generic bits set (GenericRead, GenericWrite, GenericExecute, or
    GenericAll) or any undefined bits set, but may have any other bit
    set.  If bits other than the generic bits are provided on input,
    they will not be cleared bt the mapping.

Arguments:

    AccessMask - Points to the access mask to be mapped.

    GenericMapping - The mapping of generic to specific and standard
        access types.

Return Value:

    None.

--*/
{
    RtlMapGenericMask (
        AccessMask,
        GenericMapping
        );
}



BOOL
APIENTRY
IsValidAcl (
    PACL pAcl
    )
/*++

Routine Description:

    This procedure validates an ACL.

    This involves validating the revision level of the ACL and ensuring
    that the number of ACEs specified in the AceCount fit in the space
    specified by the AclSize field of the ACL header.

Arguments:

    pAcl - Pointer to the ACL structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of Acl is valid.


--*/
{
    if ( !RtlValidAcl( pAcl ) ) {
        SetLastError(ERROR_INVALID_ACL);
        return FALSE;
    }
    return TRUE;
}




BOOL
APIENTRY
InitializeAcl (
    PACL pAcl,
    DWORD nAclLength,
    DWORD dwAclRevision
    )
/*++

Routine Description:

    InitializeAcl creates a new ACL in the caller supplied memory
    buffer.  The ACL contains zero ACEs; therefore, it is an empty ACL
    as opposed to a nonexistent ACL.  That is, if the ACL is now set
    to an object it will implicitly deny access to everyone.

Arguments:

    pAcl - Supplies the buffer containing the ACL being initialized

    nAclLength - Supplies the length of the ace buffer in bytes

    dwAclRevision - Supplies the revision for this Acl

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlCreateAcl (
                pAcl,
                nAclLength,
                dwAclRevision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
GetAclInformation (
    PACL pAcl,
    PVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    )
/*++

Routine Description:

    This routine returns to the caller information about an ACL.  The requested
    information can be AclRevisionInformation, or AclSizeInformation.

Arguments:

    pAcl - Supplies the Acl being examined

    pAclInformation - Supplies the buffer to receive the information
        being requested

    nAclInformationLength - Supplies the length of the AclInformation
        buffer in bytes

    dwAclInformationClass - Supplies the type of information being
        requested

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlQueryInformationAcl (
                pAcl,
                pAclInformation,
                nAclInformationLength,
                dwAclInformationClass
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
SetAclInformation (
    PACL pAcl,
    PVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    )
/*++

Routine Description:

    This routine sets the state of an ACL.  For now only the revision
    level can be set and for now only a revision level of 1 is accepted
    so this procedure is rather simple

Arguments:

    pAcl - Supplies the Acl being altered

    pAclInformation - Supplies the buffer containing the information
        being set

    nAclInformationLength - Supplies the length of the Acl information
        buffer

    dwAclInformationClass - Supplies the type of information begin set

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetInformationAcl (
                pAcl,
                pAclInformation,
                nAclInformationLength,
                dwAclInformationClass
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwStartingAceIndex,
    PVOID pAceList,
    DWORD nAceListLength
    )
/*++

Routine Description:

    This routine adds a string of ACEs to an ACL.

Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being
        added

    dwStartingAceIndex - Supplies the ACE index which will be the
        index of the first ace inserted in the acl.  0 for the
        beginning of the list and MAXULONG for the end of the list.

    pAceList - Supplies the list of Aces to be added to the Acl

    nAceListLength - Supplies the size, in bytes, of the AceList
        buffer

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;

    Status = RtlAddAce (
        pAcl,
        dwAceRevision,
        dwStartingAceIndex,
        pAceList,
        nAceListLength
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
DeleteAce (
    PACL pAcl,
    DWORD dwAceIndex
    )
/*++

Routine Description:

    This routine deletes one ACE from an ACL.

Arguments:

    pAcl - Supplies the Acl being modified

    dwAceIndex - Supplies the index of the Ace to delete.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlDeleteAce (
                pAcl,
                dwAceIndex
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
GetAce (
    PACL pAcl,
    DWORD dwAceIndex,
    PVOID *pAce
    )
/*++

Routine Description:

    This routine returns a pointer to an ACE in an ACl referenced by
    ACE index

Arguments:

    pAcl - Supplies the ACL being queried

    dwAceIndex - Supplies the Ace index to locate

    pAce - Receives the address of the ACE within the ACL

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlGetAce (
                pAcl,
                dwAceIndex,
                pAce
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAccessAllowedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.

Arguments:

    PAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be granted to the specified SID.

    pSid - Pointer to the SID being granted access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessAllowedAce (
                pAcl,
                dwAceRevision,
                AccessMask,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAccessAllowedAceEx (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  The AceFlags and
    inheritance are specified by the AceFlags parameter.

Arguments:

    PAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    pSid - Pointer to the SID being granted access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessAllowedAceEx (
                pAcl,
                dwAceRevision,
                AceFlags,
                AccessMask,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
AddAccessDeniedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.


Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be denied to the specified SID.

    pSid - Pointer to the SID being denied access.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessDeniedAce (
                pAcl,
                dwAceRevision,
                AccessMask,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
AddAccessDeniedAceEx (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  The AceFlags and
    inheritance are specified by the AceFlags parameter.


Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be denied to the specified SID.

    pSid - Pointer to the SID being denied access.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessDeniedAceEx (
                pAcl,
                dwAceRevision,
                AceFlags,
                AccessMask,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
AddAuditAccessAce(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwAccessMask,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    )
/*++

Routine Description:

    This routine adds a SYSTEM_AUDIT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance.

    Parameters are used to indicate whether auditing is to be performed
    on success, failure, or both.


Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    dwAccessMask - The mask of accesses to be denied to the specified SID.

    pSid - Pointer to the SID to be audited.

    bAuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    bAuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    NTSTATUS Status;

    Status =  RtlAddAuditAccessAce (
                pAcl,
                dwAceRevision,
                dwAccessMask,
                pSid,
                (BOOLEAN)bAuditSuccess,
                (BOOLEAN)bAuditFailure
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAuditAccessAceEx(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD dwAccessMask,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    )
/*++

Routine Description:

    This routine adds a SYSTEM_AUDIT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  The AceFlags and
    inheritance are specified by the AceFlags parameter.

    Parameters are used to indicate whether auditing is to be performed
    on success, failure, or both.


Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    dwAccessMask - The mask of accesses to be denied to the specified SID.

    pSid - Pointer to the SID to be audited.

    bAuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    bAuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    NTSTATUS Status;

    Status =  RtlAddAuditAccessAceEx (
                pAcl,
                dwAceRevision,
                AceFlags,
                dwAccessMask,
                pSid,
                (BOOLEAN)bAuditSuccess,
                (BOOLEAN)bAuditFailure
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
AddAccessAllowedObjectAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED_OBJECT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.

Arguments:

    PAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    pSid - Pointer to the SID being granted access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessAllowedObjectAce (
                pAcl,
                dwAceRevision,
                AceFlags,
                AccessMask,
                ObjectTypeGuid,
                InheritedObjectTypeGuid,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAccessDeniedObjectAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_DENIED_OBJECT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.

Arguments:

    PAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    pSid - Pointer to the SID being denied access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessDeniedObjectAce (
                pAcl,
                dwAceRevision,
                AceFlags,
                AccessMask,
                ObjectTypeGuid,
                InheritedObjectTypeGuid,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAuditAccessObjectAce(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD dwAccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    )
/*++

Routine Description:

    This routine adds a SYSTEM_AUDIT_OBJECT_ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  The AceFlags and
    inheritance are specified by the AceFlags parameter.

    Parameters are used to indicate whether auditing is to be performed
    on success, failure, or both.


Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    dwAccessMask - The mask of accesses to be denied to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    pSid - Pointer to the SID to be audited.

    bAuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    bAuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    NTSTATUS Status;

    Status =  RtlAddAuditAccessObjectAce (
                pAcl,
                dwAceRevision,
                AceFlags,
                dwAccessMask,
                ObjectTypeGuid,
                InheritedObjectTypeGuid,
                pSid,
                (BOOLEAN)bAuditSuccess,
                (BOOLEAN)bAuditFailure
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
FindFirstFreeAce (
    PACL pAcl,
    PVOID *pAce
    )
/*++

Routine Description:

    This routine returns a pointer to the first free byte in an Acl
    or NULL if the acl is ill-formed.  If the Acl is full then the
    return pointer is to the byte immediately following the acl, and
    TRUE will be returned.

Arguments:

    pAcl - Supplies a pointer to the Acl to examine

    pAce - Receives a pointer to the first free position in the Acl

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    if ( !RtlFirstFreeAce( pAcl, pAce ) ) {
        SetLastError(ERROR_INVALID_ACL);
        return FALSE;
    }
    return TRUE;
}

BOOL
APIENTRY
InitializeSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwRevision
    )
/*++

Routine Description:

    This procedure initializes a new "absolute format" security descriptor.
    After the procedure call the security descriptor is initialized with no
    system ACL, no discretionary ACL, no owner, no primary group and
    all control flags set to false (null).

Arguments:


    pSecurityDescriptor - Supplies the security descriptor to
        initialize.

    dwRevision - Provides the revision level to assign to the security
        descriptor.  This should be one (1) for this release.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlCreateSecurityDescriptor (
                pSecurityDescriptor,
                dwRevision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
IsValidSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:

    This procedure validates a SecurityDescriptor's structure.  This
    involves validating the revision levels of each component of the
    security descriptor.

Arguments:

    pSecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure
        to validate.

Return Value:

    BOOL - TRUE if the structure of SecurityDescriptor is valid.


--*/
{
    if (!RtlValidSecurityDescriptor ( pSecurityDescriptor )) {
        BaseSetLastNTError( STATUS_INVALID_SECURITY_DESCR );
        return( FALSE );
    }

    return( TRUE );
}




DWORD
APIENTRY
GetSecurityDescriptorLength (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:

    This routine returns the length, in bytes, necessary to capture a
    structurally valid SECURITY_DESCRIPTOR.  The length includes the length
    of all associated data structures (like SIDs and ACLs).  The length also
    takes into account the alignment requirements of each component.

    The minimum length of a security descriptor (one which has no associated
    SIDs or ACLs) is SECURITY_DESCRIPTOR_MIN_LENGTH.


Arguments:

    pSecurityDescriptor - Points to the SECURITY_DESCRIPTOR whose
        length is to be returned.  The SECURITY_DESCRIPTOR's structure
        is assumed to be valid.

Return Value:

    DWORD - The length, in bytes, of the SECURITY_DESCRIPTOR.


--*/
{
    return RtlLengthSecurityDescriptor (
        pSecurityDescriptor
        );
}





BOOL
APIENTRY
GetSecurityDescriptorControl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSECURITY_DESCRIPTOR_CONTROL pControl,
    LPDWORD lpdwRevision
    )
/*++

Routine Description:

    This procedure retrieves the control information from a security descriptor.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    pControl - Receives the control information.

    lpdwRevision - Receives the revision of the security descriptor.
        This value will always be returned, even if an error is
        returned by this routine.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlGetControlSecurityDescriptor (
                pSecurityDescriptor,
                pControl,
                lpdwRevision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
SetSecurityDescriptorControl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    )
/*++

Routine Description:

    This procedure sets the control information in a security descriptor.


    For instance,

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      SE_DACL_PROTECTED );

    marks the DACL on the security descriptor as protected. And

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      0 );


    marks the DACL as not protected.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    ControlBitsOfInterest - A mask of the control bits being changed, set,
        or reset by this call.  The mask is the logical OR of one or more of
        the following flags:

            SE_DACL_UNTRUSTED
            SE_SERVER_SECURITY
            SE_DACL_AUTO_INHERIT_REQ
            SE_SACL_AUTO_INHERIT_REQ
            SE_DACL_AUTO_INHERITED
            SE_SACL_AUTO_INHERITED
            SE_DACL_PROTECTED
            SE_SACL_PROTECTED

    ControlBitsToSet - A mask indicating what the bits specified by ControlBitsOfInterest
        should be set to.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetControlSecurityDescriptor (
                pSecurityDescriptor,
                ControlBitsOfInterest,
                ControlBitsToSet );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
SetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bDaclPresent,
    PACL pDacl OPTIONAL,
    BOOL bDaclDefaulted OPTIONAL
    )
/*++

Routine Description:

    This procedure sets the discretionary ACL information of an absolute
    format security descriptor.  If there is already a discretionary ACL
    present in the security descriptor, it is superseded.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor to be which
        the discretionary ACL is to be added.

    bDaclPresent - If FALSE, indicates the DaclPresent flag in the
        security descriptor should be set to FALSE.  In this case, the
        remaining optional parameters are ignored.  Otherwise, the
        DaclPresent control flag in the security descriptor is set to
        TRUE and the remaining optional parameters are not ignored.

    pDacl - Supplies the discretionary ACL for the security
        descriptor.  If this optional parameter is not passed, then a
        null ACL is assigned to the security descriptor.  A null
        discretionary ACL unconditionally grants access.  The ACL is
        referenced by, not copied into, by the security descriptor.

    bDaclDefaulted - When set, indicates the discretionary ACL was
        picked up from some default mechanism (rather than explicitly
        specified by a user).  This value is set in the DaclDefaulted
        control flag in the security descriptor.  If this optional
        parameter is not passed, then the DaclDefaulted flag will be
        cleared.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetDaclSecurityDescriptor (
        pSecurityDescriptor,
        (BOOLEAN)bDaclPresent,
        pDacl,
        (BOOLEAN)bDaclDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
GetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbDaclPresent,
    PACL *pDacl,
    LPBOOL lpbDaclDefaulted
    )
/*++

Routine Description:

    This procedure retrieves the discretionary ACL information of a
    security descriptor.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    lpbDaclPresent - If TRUE, indicates that the security descriptor
        does contain a discretionary ACL.  In this case, the
        remaining OUT parameters will receive valid values.
        Otherwise, the security descriptor does not contain a
        discretionary ACL and the remaining OUT parameters will not
        receive valid values.

    pDacl - This value is returned only if the value returned for the
        DaclPresent flag is TRUE.  In this case, the Dacl parameter
        receives the address of the security descriptor's
        discretionary ACL.  If this value is returned as null, then
        the security descriptor has a null discretionary ACL.

    lpbDaclDefaulted - This value is returned only if the value
        returned for the DaclPresent flag is TRUE.  In this case, the
        DaclDefaulted parameter receives the value of the security
        descriptor's DaclDefaulted control flag.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    BOOLEAN DaclPresent, DaclDefaulted;

    Status = RtlGetDaclSecurityDescriptor (
        pSecurityDescriptor,
        &DaclPresent,
        pDacl,
        &DaclDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        *lpbDaclPresent = (BOOL)DaclPresent;
        *lpbDaclDefaulted = (BOOL)DaclDefaulted;
    }

    return TRUE;
}




BOOL
APIENTRY
SetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bSaclPresent,
    PACL pSacl OPTIONAL,
    BOOL bSaclDefaulted
    )
/*++

Routine Description:

    This procedure sets the system ACL information of an absolute security
    descriptor.  If there is already a system ACL present in the
    security descriptor, it is superseded.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor to be which
        the system ACL is to be added.

    bSaclPresent - If FALSE, indicates the SaclPresent flag in the
        security descriptor should be set to FALSE.  In this case,
        the remaining optional parameters are ignored.  Otherwise,
        the SaclPresent control flag in the security descriptor is
        set to TRUE and the remaining optional parameters are not
        ignored.

    pSacl - Supplies the system ACL for the security descriptor.  If
        this optional parameter is not passed, then a null ACL is
        assigned to the security descriptor.  The ACL is referenced
        by, not copied into, by the security descriptor.

    bSaclDefaulted - When set, indicates the system ACL was picked up
        from some default mechanism (rather than explicitly specified
        by a user).  This value is set in the SaclDefaulted control
        flag in the security descriptor.  If this optional parameter
        is not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetSaclSecurityDescriptor (
                pSecurityDescriptor,
                (BOOLEAN)bSaclPresent,
                pSacl,
                (BOOLEAN)bSaclDefaulted
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
GetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbSaclPresent,
    PACL *pSacl,
    LPBOOL lpbSaclDefaulted
    )
/*++

Routine Description:

    This procedure retrieves the system ACL information of a security
    descriptor.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    lpbSaclPresent - If TRUE, indicates that the security descriptor
        does contain a system ACL.  In this case, the remaining OUT
        parameters will receive valid values.  Otherwise, the
        security descriptor does not contain a system ACL and the
        remaining OUT parameters will not receive valid values.

    pSacl - This value is returned only if the value returned for the
        SaclPresent flag is TRUE.  In this case, the Sacl parameter
        receives the address of the security descriptor's system ACL.
        If this value is returned as null, then the security
        descriptor has a null system ACL.

    lpbSaclDefaulted - This value is returned only if the value
        returned for the SaclPresent flag is TRUE.  In this case, the
        SaclDefaulted parameter receives the value of the security
        descriptor's SaclDefaulted control flag.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    BOOLEAN SaclPresent, SaclDefaulted;

    Status = RtlGetSaclSecurityDescriptor (
        pSecurityDescriptor,
        &SaclPresent,
        pSacl,
        &SaclDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        *lpbSaclPresent = (BOOL)SaclPresent;
        *lpbSaclDefaulted = (BOOL)SaclDefaulted;
    }

    return TRUE;
}




BOOL
APIENTRY
SetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pOwner OPTIONAL,
    BOOL bOwnerDefaulted OPTIONAL
    )
/*++

Routine Description:

    This procedure sets the owner information of an absolute security
    descriptor.  If there is already an owner present in the security
    descriptor, it is superseded.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor in which
        the owner is to be set.  If the security descriptor already
        includes an owner, it will be superseded by the new owner.

    pOwner - Supplies the owner SID for the security descriptor.  If
        this optional parameter is not passed, then the owner is
        cleared (indicating the security descriptor has no owner).
        The SID is referenced by, not copied into, the security
        descriptor.

    bOwnerDefaulted - When set, indicates the owner was picked up from
        some default mechanism (rather than explicitly specified by a
        user).  This value is set in the OwnerDefaulted control flag
        in the security descriptor.  If this optional parameter is
        not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;

    Status = RtlSetOwnerSecurityDescriptor (
        pSecurityDescriptor,
        pOwner,
        (BOOLEAN)bOwnerDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
GetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pOwner,
    LPBOOL lpbOwnerDefaulted
    )
/*++

Routine Description:

    This procedure retrieves the owner information of a security
    descriptor.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    pOwner - Receives a pointer to the owner SID.  If the security
        descriptor does not currently contain an owner, then this
        value will be returned as null.  In this case, the remaining
        OUT parameters are not given valid return values.  Otherwise,
        this parameter points to an SID and the remaining OUT
        parameters are provided valid return values.

    lpbOwnerDefaulted - This value is returned only if the value
        returned for the Owner parameter is not null.  In this case,
        the OwnerDefaulted parameter receives the value of the
        security descriptor's OwnerDefaulted control flag.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    BOOLEAN OwnerDefaulted;

    Status = RtlGetOwnerSecurityDescriptor (
        pSecurityDescriptor,
        pOwner,
        &OwnerDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        *lpbOwnerDefaulted = (BOOL)OwnerDefaulted;
    }

    return TRUE;
}




BOOL
APIENTRY
SetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pGroup OPTIONAL,
    BOOL bGroupDefaulted OPTIONAL
    )
/*++

Routine Description:

    This procedure sets the primary group information of an absolute security
    descriptor.  If there is already an primary group present in the
    security descriptor, it is superseded.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor in which
        the primary group is to be set.  If the security descriptor
        already includes a primary group, it will be superseded by
        the new group.

    pGroup - Supplies the primary group SID for the security
        descriptor.  If this optional parameter is not passed, then
        the primary group is cleared (indicating the security
        descriptor has no primary group).  The SID is referenced by,
        not copied into, the security descriptor.

    bGroupDefaulted - When set, indicates the owner was picked up from
        some default mechanism (rather than explicitly specified by a
        user).  This value is set in the OwnerDefaulted control flag
        in the security descriptor.  If this optional parameter is
        not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetGroupSecurityDescriptor (
        pSecurityDescriptor,
        pGroup,
        (BOOLEAN)bGroupDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
GetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pGroup,
    LPBOOL lpbGroupDefaulted
    )
/*++

Routine Description:

    This procedure retrieves the primary group information of a
    security descriptor.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    pGroup - Receives a pointer to the primary group SID.  If the
        security descriptor does not currently contain a primary
        group, then this value will be returned as null.  In this
        case, the remaining OUT parameters are not given valid return
        values.  Otherwise, this parameter points to an SID and the
        remaining OUT parameters are provided valid return values.

    lpbGroupDefaulted - This value is returned only if the value
        returned for the Group parameter is not null.  In this case,
        the GroupDefaulted parameter receives the value of the
        security descriptor's GroupDefaulted control flag.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    BOOLEAN GroupDefaulted;

    Status = RtlGetGroupSecurityDescriptor (
        pSecurityDescriptor,
        pGroup,
        &GroupDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        *lpbGroupDefaulted = GroupDefaulted;
    }

    return TRUE;
}




BOOL
APIENTRY
CreatePrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    BOOL IsDirectoryObject,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    The procedure is used to allocpate and initialize a self-relative
    Security Descriptor for a new protected server's object.  It is called
    when a new protected server object is being created.  The generated
    security descriptor will be in self-relative form.

    This procedure, called only from user mode, is used to establish a
    security descriptor for a new protected server's object.  When no
    longer needed, this descriptor must be freed using
    DestroyPrivateObjectSecurity().

Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a new object is being created.  If there is
        no parent directory, then this argument is specified as NULL.

    CreatorDescriptor - (Optionally) Points to a security descriptor
        presented by the creator of the object.  If the creator of the
        object did not explicitly pass security information for the new
        object, then a null pointer should be passed.

    NewDescriptor - Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor.

    IsDirectoryObject - Specifies if the new object is going to be a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    Token - Supplies the token for the client on whose behalf the
        object is being created.  If it is an impersonation token,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

        A client token is used to retrieve default security
        information for the new object, such as default owner, primary
        group, and discretionary access control.  The token must be
        open for TOKEN_QUERY access.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlNewSecurityObject (
        ParentDescriptor,
        CreatorDescriptor,
        NewDescriptor,
        (BOOLEAN)IsDirectoryObject,
        Token,
        GenericMapping
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
ConvertToAutoInheritPrivateObjectSecurity(
    PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    GUID *ObjectType,
    BOOLEAN IsDirectoryObject,
    PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This is a converts a security descriptor whose ACLs are not marked
    as AutoInherit to a security descriptor whose ACLs are marked as
    AutoInherit.

    The resultant security descriptor has appropriate ACEs marked as
    INHERITED_ACE if the ACE was apparently inherited from the ParentDescriptor.
    If the ACL is apparently not inherited from the ParentDescriptor, the
    ACL in the resultant security descriptor is marked as SE_xACL_PROTECTED.

    This routine takes into account the various mechanisms for creating an
    inherited ACL:

    1) It was inherited via NT 3.x or 4.x ACL inheritance when the
    object was created.

    2) The subsequent parent or child ACL was re-written by the ACL editor
    (which perversely modifies the ACL to a semantically equivalent but
    different form).

    3) It was inherited by asking the ACL editor (File Manager/Explorer) to
    "Replace permissions on existing files/directories".

    4) It was inherited via cacls.exe.

    If the ACLs in the resultant security descriptor are not marked as protected, the
    resultant ACL is composed of two sets of ACEs: the non-inherited ACEs followed by the
    inherited ACEs.  The inherited ACEs are computed by called CreatePrivateObjectSecurityEx
    using the ParentDescriptor.  The non-inherited ACEs are those ACEs (or parts of ACEs)
    from the original CurrentSecurityDescriptor that were not inherited from the parent.

    When building the resultant NewSecurityDescriptor, care is taken to not change the
    semantics of the security descriptor.  As such, allow and deny ACEs are never moved
    in relation to one another.  If such movement is needed (for instance to place all
    non-inherited ACEs at the front of an ACL), the ACL is marked as protected to prevent
    the semantic change.

    ACEs in the original CurrentSecurityDescriptor are matched with ACEs in a computed
    inherited security descriptor to determine which ACEs were inherited.  During the
    comparision there is no requirement of a one to one match.  For instance, one ACL
    might use separate ACEs to grant a user read and write access while the other ACL
    might use only one ACE to grant the same access.  Or one ACL might grant the user
    the same access twice and the other might grant the user that access only once.  Or
    one ACL might combine the container inherit and object inherit ACE into a single ACE.
    In all these case, equivalent ACE combinations are deemed equivalent.

    No security checks are made in this routine.  The resultant security descriptor
    is equivalent to the new security descriptor, so the caller needs no permission to
    update the security descriptor to the new form.

    The Owner and Group field of the CurrentSecurityDescriptor is maintained.

    This routine support revision 2 and revision 4 ACLs.  It does not support compound
    ACEs.

Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a object exists.  If there is
        no parent directory, then this argument is specified as NULL.

    CurrentSecurityDescriptor - Supplies a pointer to the objects security descriptor
        that is going to be altered by this procedure.

    NewSecurityDescriptor Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor. When no
        longer needed, this descriptor must be freed using
        DestroyPrivateObjectSecurity().

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsDirectoryObject - Specifies if the object is a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlConvertToAutoInheritSecurityObject(
                ParentDescriptor,
                CurrentSecurityDescriptor,
                NewSecurityDescriptor,
                ObjectType,
                IsDirectoryObject,
                GenericMapping ) ;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
CreatePrivateObjectSecurityEx (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    GUID *ObjectType,
    BOOL IsContainerObject,
    ULONG AutoInheritFlags,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    The procedure is used to allocate and initialize a self-relative
    Security Descriptor for a new protected server's object.  It is called
    when a new protected server object is being created. The generated
    security descriptor will be in self-relative form.

    This procedure, called only from user mode, is used to establish a
    security descriptor for a new protected server's object.
Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a new object is being created.  If there is
        no parent directory, then this argument is specified as NULL.

    CreatorDescriptor - (Optionally) Points to a security descriptor
        presented by the creator of the object.  If the creator of the
        object did not explicitly pass security information for the new
        object, then a null pointer should be passed.

    NewDescriptor - Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor. When no
        longer needed, this descriptor must be freed using
        DestroyPrivateObjectSecurity().

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsContainerObject - Specifies if the new object is going to be a
        container object.  A value of TRUE indicates the object is a
        container of other objects.

    AutoInheritFlags - Controls automatic inheritance of ACES from the Parent
        Descriptor.  Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherit ACEs from the
            DACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_SACL_AUTO_INHERIT - If set, inherit ACEs from the
            SACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT - If set, the CreatorDescriptor
            is the default descriptor for ObjectType.  As such, the
            CreatorDescriptor will be ignored if any ObjectType specific
            ACEs are inherited from the parent.  If not such ACEs are inherited,
            the CreatorDescriptor is handled as though this flag were not
            specified.

        SEF_AVOID_PRIVILEGE_CHECK - If set, no privilege checking is done by this
            routine.  This flag is useful while implementing automatic inheritance
            to avoid checking privileges on each child updated.

        SEF_AVOID_OWNER_CHECK - If set, no owner checking is done by this routine.

        SEF_DEFAULT_OWNER_FROM_PARENT - If set, the owner of NewDescriptor will
            default to the owner from ParentDescriptor.  If not set, the owner
            of NewDescriptor will default to the user specified in Token.

            In either case, the owner of NewDescriptor is set to the owner from
            the CreatorDescriptor if that field is specified.

        SEF_DEFAULT_GROUP_FROM_PARENT - If set, the group of NewDescriptor will
            default to the group from ParentDescriptor.  If not set, the group
            of NewDescriptor will default to the group specified in Token.

            In either case, the group of NewDescriptor is set to the group from
            the CreatorDescriptor if that field is specified.


    Token - Supplies the token for the client on whose behalf the
        object is being created.  If it is an impersonation token,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

        A client token is used to retrieve default security
        information for the new object, such as default owner, primary
        group, and discretionary access control.  The token must be
        open for TOKEN_QUERY access.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlNewSecurityObjectEx (
        ParentDescriptor,
        CreatorDescriptor,
        NewDescriptor,
        ObjectType,
        (BOOLEAN)IsContainerObject,
        AutoInheritFlags,
        Token,
        GenericMapping
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
CreatePrivateObjectSecurityWithMultipleInheritance (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    GUID **ObjectTypes,
    ULONG GuidCount,
    BOOL IsContainerObject,
    ULONG AutoInheritFlags,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    The procedure is used to allocate and initialize a self-relative
    Security Descriptor for a new protected server's object.  It is called
    when a new protected server object is being created. The generated
    security descriptor will be in self-relative form.

    This procedure, called only from user mode, is used to establish a
    security descriptor for a new protected server's object.
Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a new object is being created.  If there is
        no parent directory, then this argument is specified as NULL.

    CreatorDescriptor - (Optionally) Points to a security descriptor
        presented by the creator of the object.  If the creator of the
        object did not explicitly pass security information for the new
        object, then a null pointer should be passed.

    NewDescriptor - Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor. When no
        longer needed, this descriptor must be freed using
        DestroyPrivateObjectSecurity().

    ObjectTypes - List of GUIDs of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    GuidCount - Number of guids present in the list.

    IsContainerObject - Specifies if the new object is going to be a
        container object.  A value of TRUE indicates the object is a
        container of other objects.

    AutoInheritFlags - Controls automatic inheritance of ACES from the Parent
        Descriptor.  Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherit ACEs from the
            DACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_SACL_AUTO_INHERIT - If set, inherit ACEs from the
            SACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT - If set, the CreatorDescriptor
            is the default descriptor for ObjectType.  As such, the
            CreatorDescriptor will be ignored if any ObjectType specific
            ACEs are inherited from the parent.  If not such ACEs are inherited,
            the CreatorDescriptor is handled as though this flag were not
            specified.

        SEF_AVOID_PRIVILEGE_CHECK - If set, no privilege checking is done by this
            routine.  This flag is useful while implementing automatic inheritance
            to avoid checking privileges on each child updated.

        SEF_AVOID_OWNER_CHECK - If set, no owner checking is done by this routine.

        SEF_DEFAULT_OWNER_FROM_PARENT - If set, the owner of NewDescriptor will
            default to the owner from ParentDescriptor.  If not set, the owner
            of NewDescriptor will default to the user specified in Token.

            In either case, the owner of NewDescriptor is set to the owner from
            the CreatorDescriptor if that field is specified.

        SEF_DEFAULT_GROUP_FROM_PARENT - If set, the group of NewDescriptor will
            default to the group from ParentDescriptor.  If not set, the group
            of NewDescriptor will default to the group specified in Token.

            In either case, the group of NewDescriptor is set to the group from
            the CreatorDescriptor if that field is specified.


    Token - Supplies the token for the client on whose behalf the
        object is being created.  If it is an impersonation token,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

        A client token is used to retrieve default security
        information for the new object, such as default owner, primary
        group, and discretionary access control.  The token must be
        open for TOKEN_QUERY access.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlNewSecurityObjectWithMultipleInheritance (
        ParentDescriptor,
        CreatorDescriptor,
        NewDescriptor,
        ObjectTypes,
        GuidCount,
        (BOOLEAN)IsContainerObject,
        AutoInheritFlags,
        Token,
        GenericMapping
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
SetPrivateObjectSecurity (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token OPTIONAL
    )
/*++

Routine Description:

    Modify an object's existing self-relative form security descriptor.

    This procedure, called only from user mode, is used to update a
    security descriptor on an existing protected server's object.  It
    applies changes requested by a new security descriptor to the existing
    security descriptor.  If necessary, this routine will allocate
    additional memory to produce a larger security descriptor.  All access
    checking is expected to be done before calling this routine.  This
    includes checking for WRITE_OWNER, WRITE_DAC, and privilege to assign a
    system ACL as appropriate.

    The caller of this routine must not be impersonating a client.

Arguments:

    SecurityInformation - Indicates which security information is
        to be applied to the object.  The value(s) to be assigned are
        passed in the ModificationDescriptor parameter.

    ModificationDescriptor - Supplies the input security descriptor to be
        applied to the object.  The caller of this routine is expected
        to probe and capture the passed security descriptor before calling
        and release it after calling.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor that is going to be altered by
        this procedure.  This security descriptor must be in self-
        relative form or an error will be returned.

    GenericMapping - This argument provides the mapping of generic to
        specific/standard access types for the object being accessed.
        This mapping structure is expected to be safe to access
        (i.e., captured if necessary) prior to be passed to this routine.

    Token - (optionally) Supplies the token for the client on whose
        behalf the security is being modified.  This parameter is only
        required to ensure that the client has provided a legitimate
        value for a new owner SID.  The token must be open for
        TOKEN_QUERY access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetSecurityObject (
        SecurityInformation,
        ModificationDescriptor,
        ObjectsSecurityDescriptor,
        GenericMapping,
        Token
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
SetPrivateObjectSecurityEx (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    ULONG AutoInheritFlags,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token OPTIONAL
    )
/*++

Routine Description:

    Modify an object's existing self-relative form security descriptor.

    This procedure, called only from user mode, is used to update a
    security descriptor on an existing protected server's object.  It
    applies changes requested by a new security descriptor to the existing
    security descriptor.  If necessary, this routine will allocate
    additional memory to produce a larger security descriptor.  All access
    checking is expected to be done before calling this routine.  This
    includes checking for WRITE_OWNER, WRITE_DAC, and privilege to assign a
    system ACL as appropriate.

    The caller of this routine must not be impersonating a client.

Arguments:

    SecurityInformation - Indicates which security information is
        to be applied to the object.  The value(s) to be assigned are
        passed in the ModificationDescriptor parameter.

    ModificationDescriptor - Supplies the input security descriptor to be
        applied to the object.  The caller of this routine is expected
        to probe and capture the passed security descriptor before calling
        and release it after calling.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor that is going to be altered by
        this procedure.  This security descriptor must be in self-
        relative form or an error will be returned.

    AutoInheritFlags - Controls automatic inheritance of ACES.
        Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherited ACEs from the
            DACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from
            the ModificationDescriptor are ignored. Inherited ACEs are not supposed
            to be modified; so preserving them across this call is appropriate.
            If a protected server does not itself implement auto inheritance, it should
            not set this bit.  The caller of the protected server may implement
            auto inheritance and my indeed be modifying inherited ACEs.

        SEF_SACL_AUTO_INHERIT - If set, inherited ACEs from the
            SACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from
            the ModificationDescriptor are ignored. Inherited ACEs are not supposed
            to be modified; so preserving them across this call is appropriate.
            If a protected server does not itself implement auto inheritance, it should
            not set this bit.  The caller of the protected server may implement
            auto inheritance and my indeed be modifying inherited ACEs.

    GenericMapping - This argument provides the mapping of generic to
        specific/standard access types for the object being accessed.
        This mapping structure is expected to be safe to access
        (i.e., captured if necessary) prior to be passed to this routine.

    Token - (optionally) Supplies the token for the client on whose
        behalf the security is being modified.  This parameter is only
        required to ensure that the client has provided a legitimate
        value for a new owner SID.  The token must be open for
        TOKEN_QUERY access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetSecurityObjectEx (
        SecurityInformation,
        ModificationDescriptor,
        ObjectsSecurityDescriptor,
        AutoInheritFlags,
        GenericMapping,
        Token
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
GetPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ObjectDescriptor,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ResultantDescriptor,
    DWORD DescriptorLength,
    PDWORD ReturnLength
    )
/*++

Routine Description:

    Query information from a protected server object's existing security
    descriptor.

    This procedure, called only from user mode, is used to retrieve
    information from a security descriptor on an existing protected
    server's object.  All access checking is expected to be done before
    calling this routine.  This includes checking for READ_CONTROL, and
    privilege to read a system ACL as appropriate.

Arguments:

    ObjectDescriptor - Points to a pointer to a security descriptor to be
        queried.

    SecurityInformation - Identifies the security information being
        requested.

    ResultantDescriptor - Points to buffer to receive the resultant
        security descriptor.  The resultant security descriptor will
        contain all information requested by the SecurityInformation
        parameter.

    DescriptorLength - Is an unsigned integer which indicates the length,
        in bytes, of the buffer provided to receive the resultant
        descriptor.

    ReturnLength - Receives an unsigned integer indicating the actual
        number of bytes needed in the ResultantDescriptor to store the
        requested information.  If the value returned is greater than the
        value passed via the DescriptorLength parameter, then
        STATUS_BUFFER_TOO_SMALL is returned and no information is returned.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlQuerySecurityObject (
         ObjectDescriptor,
         SecurityInformation,
         ResultantDescriptor,
         DescriptorLength,
         ReturnLength
         );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
DestroyPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR * ObjectDescriptor
    )
/*++

Routine Description:

    Delete a protected server object's security descriptor.

    This procedure, called only from user mode, is used to delete a
    security descriptor associated with a protected server's object.  This
    routine will normally be called by a protected server during object
    deletion.  The input descriptor is expected to be one created via
    a call to CreatePrivateObjectSecurity.

Arguments:

    ObjectDescriptor - Points to a pointer to a security descriptor to be
        deleted.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlDeleteSecurityObject (
        ObjectDescriptor
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
MakeSelfRelativeSD (
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    LPDWORD lpdwBufferLength
    )
/*++

Routine Description:

    Converts a security descriptor in absolute form to one in self-relative
    form.

Arguments:

    pAbsoluteSecurityDescriptor - Pointer to an absolute format
        security descriptor.  This descriptor will not be modified.

    pSelfRelativeSecurityDescriptor - Pointer to a buffer that will
        contain the returned self-relative security descriptor.

    lpdwBufferLength - Supplies the length of the buffer.  If the
        supplied buffer is not large enough to hold the self-relative
        security descriptor, an error will be returned, and this field
        will return the minimum size required.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAbsoluteToSelfRelativeSD (
                pAbsoluteSecurityDescriptor,
                pSelfRelativeSecurityDescriptor,
                lpdwBufferLength
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
MakeAbsoluteSD (
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    LPDWORD lpdwAbsoluteSecurityDescriptorSize,
    PACL pDacl,
    LPDWORD lpdwDaclSize,
    PACL pSacl,
    LPDWORD lpdwSaclSize,
    PSID pOwner,
    LPDWORD lpdwOwnerSize,
    PSID pPrimaryGroup,
    LPDWORD lpdwPrimaryGroupSize
    )
/*++

Routine Description:

    Converts a security descriptor from self-relative format to absolute
    format

Arguments:

    pSecurityDescriptor - Supplies a pointer to a security descriptor
        in Self-Relative format

    pAbsoluteSecurityDescriptor - A pointer to a buffer in which will
        be placed the main body of the Absolute format security
        descriptor.

    lpdwAbsoluteSecurityDescriptorSize - The size in bytes of the
        buffer pointed to by pAbsoluteSecurityDescriptor.

    pDacl - Supplies a pointer to a buffer that will contain the Dacl
        of the output descriptor.  This pointer will be referenced by,
        not copied into, the output descriptor.

    lpdwDaclSize - Supplies the size of the buffer pointed to by Dacl.
        In case of error, it will return the minimum size necessary to
        contain the Dacl.

    pSacl - Supplies a pointer to a buffer that will contain the Sacl
        of the output descriptor.  This pointer will be referenced by,
        not copied into, the output descriptor.

    lpdwSaclSize - Supplies the size of the buffer pointed to by Sacl.
        In case of error, it will return the minimum size necessary to
        contain the Sacl.

    pOwner - Supplies a pointer to a buffer that will contain the
        Owner of the output descriptor.  This pointer will be
        referenced by, not copied into, the output descriptor.

    lpdwOwnerSize - Supplies the size of the buffer pointed to by
        Owner.  In case of error, it will return the minimum size
        necessary to contain the Owner.

    pPrimaryGroup - Supplies a pointer to a buffer that will contain
        the PrimaryGroup of the output descriptor.  This pointer will
        be referenced by, not copied into, the output descriptor.

    lpdwPrimaryGroupSize - Supplies the size of the buffer pointed to
        by PrimaryGroup.  In case of error, it will return the minimum
        size necessary to contain the PrimaryGroup.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSelfRelativeToAbsoluteSD (
                pSelfRelativeSecurityDescriptor,
                pAbsoluteSecurityDescriptor,
                lpdwAbsoluteSecurityDescriptorSize,
                pDacl,
                lpdwDaclSize,
                pSacl,
                lpdwSaclSize,
                pOwner,
                lpdwOwnerSize,
                pPrimaryGroup,
                lpdwPrimaryGroupSize
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}


VOID
SetSecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT LPDWORD DesiredAccess
    )

/*++

Routine Description:

    This routine builds an access mask representing the accesses necessary
    to set the object security information specified in the SecurityInformation
    parameter.  While it is not difficult to determine this information,
    the use of a single routine to generate it will ensure minimal impact
    when the security information associated with an object is extended in
    the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        modified.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to modify the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/

{

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION)   ) {
        (*DesiredAccess) |= WRITE_OWNER;
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= WRITE_DAC;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;

}


VOID
QuerySecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT LPDWORD DesiredAccess
    )

/*++

Routine Description:

    This routine builds an access mask representing the accesses necessary
    to query the object security information specified in the
    SecurityInformation parameter.  While it is not difficult to determine
    this information, the use of a single routine to generate it will ensure
    minimal impact when the security information associated with an object is
    extended in the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        queried.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to query the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/

{

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION) ||
        (SecurityInformation & DACL_SECURITY_INFORMATION)) {
        (*DesiredAccess) |= READ_CONTROL;
    }

    if ((SecurityInformation & SACL_SECURITY_INFORMATION)) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;

}

BOOL
APIENTRY
SetFileSecurityW(
    LPCWSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine Description:

    This API can be used to set the security of a file or directory
    (process, file, event, etc.).  This call is only successful if the
    following conditions are met:

    o If the object's owner or group is to be set, the caller must
      have WRITE_OWNER permission or have SeTakeOwnershipPrivilege.

    o If the object's DACL is to be set, the caller must have
      WRITE_DAC permission or be the object's owner.

    o If the object's SACL is to be set, the caller must have
      SeSecurityPrivilege.

Arguments:

    lpFileName - Supplies the file name of the file to open.  Depending on
        the value of the FailIfExists parameter, this name may or may
        not already exist.

    SecurityInformation - A pointer to information describing the
        contents of the Security Descriptor.

    pSecurityDescriptor - A pointer to a well formed Security
        Descriptor.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    HANDLE FileHandle;
    ACCESS_MASK DesiredAccess;

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID FreeBuffer;


    SetSecurityAccessMask(
        SecurityInformation,
        &DesiredAccess
        );

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior. Thus, the
    // security will always be set, as before, in the file denoted by the name.
    //

    Status = NtOpenFile(
                 &FileHandle,
                 DesiredAccess,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN_REPARSE_POINT
                 );

    //
    // Back-level file systems may not support the FILE_OPEN_REPARSE_POINT
    // flag. We treat this case explicitly.
    //

    if ( Status == STATUS_INVALID_PARAMETER ) {
        //
        // Open without inhibiting the reparse behavior.
        //

        Status = NtOpenFile(
                     &FileHandle,
                     DesiredAccess,
                     &Obja,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     0
                     );
        }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    if ( !NT_SUCCESS( Status ) ) {
        BaseSetLastNTError( Status );
        return FALSE;
        }

    Status = NtSetSecurityObject(
                FileHandle,
                SecurityInformation,
                pSecurityDescriptor
                );

    NtClose(FileHandle);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return TRUE;
}

BOOL
APIENTRY
SetFileSecurityA(
    LPCSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine Description:

    ANSI thunk to SetFileSecurityW

--*/

{

    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpFileName);
    if (AreFileApisANSI()) {
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    } else {
        Status = RtlOemStringToUnicodeString(Unicode,&AnsiString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return ( SetFileSecurityW( (LPCWSTR)Unicode->Buffer,
                               SecurityInformation,
                               pSecurityDescriptor
                        )
           );
}

BOOL
APIENTRY
GetFileSecurityW(
    LPCWSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    )

/*++

Routine Description:

    This API returns top the caller a copy of the security descriptor
    protecting a file or directory.  Based on the caller's access
    rights and privileges, this procedure will return a security
    descriptor containing the requested security descriptor fields.
    To read the handle's security descriptor the caller must be
    granted READ_CONTROL access or be the owner of the object.  In
    addition, the caller must have SeSecurityPrivilege privilege to
    read the system ACL.

Arguments:

    lpFileName - Represents the name of the file or directory whose
        security is being retrieved.

    RequestedInformation - A pointer to the security information being
        requested.

    pSecurityDescriptor - A pointer to the buffer to receive a copy of
        the secrity descriptor protecting the object that the caller
        has the rigth to view.  The security descriptor is returned in
        self-relative format.

    nLength - The size, in bytes, of the security descriptor buffer.

    lpnLengthNeeded - A pointer to the variable to receive the number
        of bytes needed to store the complete secruity descriptor.  If
        returned number of bytes is less than or equal to nLength then
        the entire security descriptor is returned in the output
        buffer, otherwise none of the descriptor is returned.

Return Value:

    TRUE is returned for success, FALSE if access is denied or if the
        buffer is too small to hold the security descriptor.


--*/
{
    NTSTATUS Status;
    HANDLE FileHandle;
    ACCESS_MASK DesiredAccess;

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID FreeBuffer;

    QuerySecurityAccessMask(
        RequestedInformation,
        &DesiredAccess
        );

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior. Thus, the
    // security will always be set, as before, in the file denoted by the name.
    //

    Status = NtOpenFile(
                 &FileHandle,
                 DesiredAccess,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN_REPARSE_POINT
                 );

    //
    // Back-level file systems may not support the FILE_OPEN_REPARSE_POINT
    // flag. We treat this case explicitly.
    //

    if ( Status == STATUS_INVALID_PARAMETER ) {
        //
        // Open without inhibiting the reparse behavior.
        //

        Status = NtOpenFile(
                     &FileHandle,
                     DesiredAccess,
                     &Obja,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     0
                     );
        }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    if (NT_SUCCESS(Status)) {
        Status = NtQuerySecurityObject(
                     FileHandle,
                     RequestedInformation,
                     pSecurityDescriptor,
                     nLength,
                     lpnLengthNeeded
                     );
        NtClose(FileHandle);
    }


    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return TRUE;
}

BOOL
APIENTRY
GetFileSecurityA(
    LPCSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    )

/*++

Routine Description:

    ANSI thunk to GetFileSecurityW

--*/

{

    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;

    RtlInitAnsiString(&AnsiString,lpFileName);
    if (AreFileApisANSI()) {
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    } else {
        Status = RtlOemStringToUnicodeString(Unicode,&AnsiString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return ( GetFileSecurityW( (LPCWSTR)Unicode->Buffer,
                               RequestedInformation,
                               pSecurityDescriptor,
                               nLength,
                               lpnLengthNeeded
                        )
           );
}




BOOL
APIENTRY
SetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

    This API can be used to set the security of a kernel object
    (process, file, event, etc.).  This call is only successful if the
    following conditions are met:

    o If the object's owner or group is to be set, the caller must
      have WRITE_OWNER permission or have SeTakeOwnershipPrivilege.

    o If the object's DACL is to be set, the caller must have
      WRITE_DAC permission or be the object's owner.

    o If the object's SACL is to be set, the caller must have
      SeSecurityPrivilege.

Arguments:

    Handle - Represents a handle of a kernel object.

    SecurityInformation - A pointer to information describing the
        contents of the Security Descriptor.

    pSecurityDescriptor - A pointer to a well formed Security
        Descriptor.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetSecurityObject(
                 Handle,
                 SecurityInformation,
                 SecurityDescriptor
                 );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
GetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    )
/*++

Routine Description:

    This API returns top the caller a copy of the security descriptor
    protecting a kernel object.  Based on the caller's access rights
    and privileges, this procedure will return a security descriptor
    containing the requested security descriptor fields.  To read the
    handle's security descriptor the caller must be granted
    READ_CONTROL access or be the owner of the object.  In addition,
    the caller must have SeSecurityPrivilege privilege to read the
    system ACL.


Arguments:

    Handle - Represents a handle of a kernel object.

    RequestedInformation - A pointer to the security information being
        requested.

    pSecurityDescriptor - A pointer to the buffer to receive a copy of
        the secrity descriptor protecting the object that the caller
        has the rigth to view.  The security descriptor is returned in
        self-relative format.

    nLength - The size, in bytes, of the security descriptor buffer.

    lpnLengthNeeded - A pointer to the variable to receive the number
        of bytes needed to store the complete secruity descriptor.  If
        returned number of bytes is less than or equal to nLength then
        the entire security descriptor is returned in the output
        buffer, otherwise none of the descriptor is returned.


Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    NTSTATUS Status;

    Status = NtQuerySecurityObject(
                 Handle,
                 RequestedInformation,
                 pSecurityDescriptor,
                 nLength,
                 lpnLengthNeeded
                 );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;

}


BOOL
APIENTRY
ImpersonateNamedPipeClient(
    IN HANDLE hNamedPipe
    )
/*++

Routine Description:

    Impersonate a named pipe client application.

Arguments:

    hNamedPipe - Handle to a named pipe.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    Status =  NtFsControlFile(
                  hNamedPipe,
                  NULL,
                  NULL,
                  NULL,
                  &IoStatusBlock,
                  FSCTL_PIPE_IMPERSONATE,
                  NULL,
                  0,
                  NULL,
                  0
                 );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
ImpersonateSelf(
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This routine may be used to obtain an Impersonation token representing
    your own process's context.  This may be useful for enabling a privilege
    for a single thread rather than for the entire process; or changing
    the default DACL for a single thread.

    The token is assigned to the callers thread.



Arguments:

    ImpersonationLevel - The level to make the impersonation token.



Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{

    NTSTATUS Status;

    Status = RtlImpersonateSelf( ImpersonationLevel );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;


}



BOOL
APIENTRY
RevertToSelf (
    VOID
    )
/*++

Routine Description:

    Terminate impersonation of a named pipe client application.

Arguments:

    None.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    HANDLE NewToken;
    NTSTATUS Status;

    NewToken = NULL;
    Status = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&NewToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;

}



BOOL
APIENTRY
SetThreadToken (
    PHANDLE Thread,
    HANDLE Token
    )
/*++

Routine Description:

    Assigns the specified impersonation token to the specified
    thread.

Arguments:

    Thread - Specifies the thread whose token is to be assigned.
        If NULL is specified, then the caller's thread is assumed.

    Token - The token to assign.  Must be open for TOKEN_IMPERSONATE
        access.  If null, then causes the specified thread to stop
        impersonating.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    NTSTATUS Status;
    HANDLE TargetThread;

    if (ARGUMENT_PRESENT(Thread)) {
        TargetThread = (*Thread);
    } else {
        TargetThread = NtCurrentThread();
    }


    Status = NtSetInformationThread(
                 TargetThread,
                 ThreadImpersonationToken,
                 (PVOID)&Token,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;

}

BOOL
LookupAccountNameInternal(
    LPCWSTR lpSystemName,
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse,
    BOOL fUnicode
    )

/*++

Routine Description:

    Translates a passed name into an account SID.  It will also return
    the name and SID of the first domain in which this name was found.

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpAccountName - Supplies the account name.

    Sid - Returns the SID corresponding to the passed account name.

    cbSid - Supplies the size of the buffer passed in for Sid.  If
        the buffer size is not big enough, this parameter will
        return the size necessary to hold the output Sid.

    ReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cbReferencedDomainName - Supplies the size (in Wide characters) of the
        ReferencedDomainName buffer.  If the buffer size is not large
        enough, this parameter will return the size necessary to hold
        the null-terminated output domain name.  If the buffer size is
        large enough, tis parameter will return the size (in Ansi characters,
        excluding the terminating null) of the Referenced Domain name.

    peUse - Returns an enumerated type inidicating the type of the
        account.

    fUnicode - indicates whether the caller wants a count of unicode or
        ansi characters.

Return Value:

    BOOL - TRUE is returned if successful, else FALSE.

--*/

{
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE PolicyHandle;
    NTSTATUS Status;
    NTSTATUS TmpStatus;
    UNICODE_STRING Name;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains = NULL;
    PLSA_TRANSLATED_SID2 TranslatedSid = NULL;
    PSID ReturnedDomainSid;
    UCHAR nSubAuthorities;
    UNICODE_STRING TmpString;
    DWORD ReturnedDomainNameSize;
    DWORD SidLengthRequired;
    BOOL Rc;
    UNICODE_STRING SystemName;
    PUNICODE_STRING pSystemName = NULL;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    if ( ARGUMENT_PRESENT( lpSystemName )) {
        RtlInitUnicodeString( &SystemName, lpSystemName );
        pSystemName = &SystemName;
    }

    //
    // Open the LSA Policy Database for the target system.  This is the
    // starting point for the Name Lookup operation.
    //

    Status = LsaOpenPolicy(
                 pSystemName,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    RtlInitUnicodeString( &Name, lpAccountName );

    //
    // Attempt to translate the Name to a Sid.
    //

    Status = LsaLookupNames2(
                 PolicyHandle,
                 0, // Flags
                 1,
                 &Name,
                 &ReferencedDomains,
                 &TranslatedSid
                 );

#if DBG
//
// This code is useful for tracking down components that call Lookup code
// before the system is initialized
//
    // ASSERT( Status != STATUS_INVALID_SERVER_STATE );
    if ( Status == STATUS_INVALID_SERVER_STATE ) {

        DbgPrint( "Process: %lu, Thread: %lu\n", GetCurrentProcessId(), GetCurrentThreadId() );
    }
#endif

    //
    // Close the Policy Handle,  which is not needed after here.
    //

    TmpStatus = LsaClose( PolicyHandle );
//    ASSERT( NT_SUCCESS( TmpStatus ));

    //
    // If an error was returned, check specifically for STATUS_NONE_MAPPED.
    // In this case, we may need to dispose of the returned Referenced Domain
    // List and Translated Sid structures.  For all other errors,
    // LsaLookupNames() frees these structures prior to exit.
    //

    if ( !NT_SUCCESS( Status )) {

        if (Status == STATUS_NONE_MAPPED) {

            if (ReferencedDomains != NULL) {

                TmpStatus = LsaFreeMemory( ReferencedDomains );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }

            if (TranslatedSid != NULL) {

                TmpStatus = LsaFreeMemory( TranslatedSid );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }
        }

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    //
    // The Name was successfully translated.  There should be exactly
    // one Referenced Domain and its DomainIndex should be zero.
    //

    ASSERT ( TranslatedSid->DomainIndex == 0 );
    ASSERT ( ReferencedDomains != NULL);
    ASSERT ( ReferencedDomains->Domains != NULL );

    //
    // Calculate the lengths of the returned Sid and Domain Name (in Wide
    // Characters, excluding null).
    //
    if ( !fUnicode ) {
        RtlUnicodeToMultiByteSize(&ReturnedDomainNameSize,
                                  ReferencedDomains->Domains->Name.Buffer,
                                  ReferencedDomains->Domains->Name.Length);
    } else {
        ReturnedDomainNameSize = (ReferencedDomains->Domains->Name.Length / sizeof(WCHAR));
    }
    SidLengthRequired = RtlLengthSid( TranslatedSid->Sid );

    //
    // Check if buffer sizes are too small.  For the returned domain,
    // the size in Wide characters provided must allow for the null
    // terminator that will be appended to the returned name.
    //

    if ( (SidLengthRequired > *cbSid) ||
         (ReturnedDomainNameSize + 1 > *cbReferencedDomainName)
       ) {

        //
        // One or both buffers are too small.  Return sizes required for
        // both buffers.
        //

        *cbSid = SidLengthRequired;
        *cbReferencedDomainName = ReturnedDomainNameSize + 1;
        BaseSetLastNTError( STATUS_BUFFER_TOO_SMALL );
        Rc = FALSE;

    } else {

        //
        // The provided buffers are large enough. 
        //
        CopySid( *cbSid, Sid, TranslatedSid->Sid );

        //
        // Copy the Domain Name into the return buffer and NULL terminate it.
        //

        TmpString.Buffer = ReferencedDomainName;
        TmpString.Length = 0;

        //
        // Watch for overflow of 16-bit name length
        //

        if (*cbReferencedDomainName < (DWORD) 32767) {

            TmpString.MaximumLength = (USHORT)((*cbReferencedDomainName) * sizeof(WCHAR));

        } else {

            TmpString.MaximumLength = (USHORT) 65534;
        }

        RtlCopyUnicodeString( &TmpString, &ReferencedDomains->Domains->Name );

        TmpString.Buffer[TmpString.Length/sizeof(WCHAR)] = (WCHAR) 0;

        //
        // Copy the Sid Use field.
        //

        *peUse = TranslatedSid->Use;

        //
        // Return the size (in Wide Characters, excluding the terminating
        // null) of the returned Referenced Domain Name.
        //

        *cbReferencedDomainName = ReturnedDomainNameSize;

        Rc = TRUE;
    }

    //
    // If necessary, free the structures returned by the LsaLookupNames()
    // function.
    //

    if (ReferencedDomains !=  NULL) {

        Status = LsaFreeMemory( ReferencedDomains );
        ASSERT( NT_SUCCESS( Status ));
    }

    if (TranslatedSid != NULL) {

        Status = LsaFreeMemory( TranslatedSid );
        ASSERT( NT_SUCCESS( Status ));
    }

    return( Rc );
}



BOOL
APIENTRY
LookupAccountNameA(
    LPCSTR lpSystemName,
    LPCSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    )

/*++

Routine Description:

    ANSI Thunk to LookupAccountNameW

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpAccountName - Supplies the account name.

    Sid - Returns the SID corresponding to the passed account name.

    cbSid - Supplies the size of the buffer passed in for Sid.  If
        the buffer size is not big enough, this parameter will
        return the size necessary to hold the output Sid.

    ReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cbReferencedDomainName - Supplies the size (in Ansi characters) of the
        ReferencedDomainName buffer.  If the buffer size is not large
        enough, this parameter will return the size necessary to hold
        the null-terminated output domain name.  If the buffer size is
        large enough, tis parameter will return the size (in Ansi characters,
        excluding the terminating null) of the Referenced Domain name.

    peUse - Returns an enumerated type indicating the type of the
        account.

Return Value:

    BOOL - TRUE is returned if successful, else FALSE.

--*/

{
    UNICODE_STRING Unicode;
    UNICODE_STRING TmpUnicode;
    ANSI_STRING  AnsiString;
    PWSTR WReferencedDomainName = NULL;
    UNICODE_STRING SystemName;
    PWSTR pSystemName = NULL;
    NTSTATUS Status;
    BOOL rc = TRUE;
    DWORD cbInitReferencedDomainName;

    Unicode.Buffer = NULL;
    SystemName.Buffer = NULL;

    //
    // Save the original buffer size
    //

    cbInitReferencedDomainName = *cbReferencedDomainName;

    //
    // Convert the passed lpAccountName to a WCHAR string to be
    // passed to the ..W routine.  Note that we cannot use the
    // StaticUnicodeString in the Thread Environment Block because
    // this is used by LdrpWalkImportDescriptor, called from the
    // client RPC stub code of the LsaOpenPolicy() call in
    // LookupAccountNameW.
    //

    RtlInitAnsiString( &AnsiString, lpAccountName );
    Status = RtlAnsiStringToUnicodeString( &Unicode, &AnsiString, TRUE );

    if (!NT_SUCCESS(Status)) {

        rc = FALSE;
    }

    //
    // Allocate a temporary buffer for ReferencedDomainName that
    // is twice as large as what was passed to adjust for the
    // intermediate conversion to a WCHAR string.
    //

    if (rc) {

        WReferencedDomainName = LocalAlloc(
                                    LMEM_FIXED,
                                    sizeof(WCHAR) * (*cbReferencedDomainName)
                                    );

        if (WReferencedDomainName == NULL) {

            Status = STATUS_NO_MEMORY;
            rc = FALSE;
        }
    }

    //
    // If the target system name is non NULL, convert it to Unicode
    //

    if (rc) {

        if ( ARGUMENT_PRESENT( lpSystemName ) ) {

            RtlInitAnsiString( &AnsiString, lpSystemName );
            Status = RtlAnsiStringToUnicodeString( &SystemName, &AnsiString, TRUE );

            if (!NT_SUCCESS(Status)) {

                rc = FALSE;
            }

            pSystemName = SystemName.Buffer;
        }
    }

    //
    // Lookup the Account Sid and obtain its Unicode Account Name.
    //

    if (rc) {

        rc = LookupAccountNameInternal(
                 (LPCWSTR)pSystemName,
                 (LPCWSTR)Unicode.Buffer,
                 Sid,
                 cbSid,
                 WReferencedDomainName,
                 cbReferencedDomainName,
                 peUse,
                 FALSE          // not unicode
                 );
    }

    if ( SystemName.Buffer != NULL ) {

        RtlFreeUnicodeString( &SystemName );
    }

    //
    // Convert the returned null-terminated WCHAR string
    // back to a null-terminated CHAR string.
    //

    if (rc) {

        RtlInitUnicodeString( &TmpUnicode, WReferencedDomainName );
        AnsiString.Buffer = ReferencedDomainName;

        //
        // Watch for 16-bit overflow of MaximumLength
        //

        if (cbInitReferencedDomainName <= (DWORD) 65535) {

            AnsiString.MaximumLength = (USHORT) cbInitReferencedDomainName;

        } else {

            AnsiString.MaximumLength = (USHORT) 65535;
        }

        Status = RtlUnicodeStringToAnsiString( &AnsiString, &TmpUnicode, FALSE );

        if ( NT_SUCCESS( Status )) {

            ReferencedDomainName[AnsiString.Length] = 0;

        } else {

            rc = FALSE;
        }
    }

    if ( WReferencedDomainName != NULL) {

        LocalFree( WReferencedDomainName );
    }

    if (Unicode.Buffer != NULL) {

        RtlFreeUnicodeString(&Unicode);
    }

    if (!NT_SUCCESS(Status)) {

        BaseSetLastNTError( Status );
    }

    return( rc );
}





BOOL
APIENTRY
LookupAccountNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    )

/*++

Routine Description:

    Translates a passed name into an account SID.  It will also return
    the name and SID of the first domain in which this name was found.

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpAccountName - Supplies the account name.

    Sid - Returns the SID corresponding to the passed account name.

    cbSid - Supplies the size of the buffer passed in for Sid.  If
        the buffer size is not big enough, this parameter will
        return the size necessary to hold the output Sid.

    ReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cbReferencedDomainName - Supplies the size (in Wide characters) of the
        ReferencedDomainName buffer.  If the buffer size is not large
        enough, this parameter will return the size necessary to hold
        the null-terminated output domain name.  If the buffer size is
        large enough, tis parameter will return the size (in Ansi characters,
        excluding the terminating null) of the Referenced Domain name.

    peUse - Returns an enumerated type inidicating the type of the
        account.

Return Value:

    BOOL - TRUE is returned if successful, else FALSE.

--*/

{
    return(LookupAccountNameInternal( lpSystemName,
                                      lpAccountName,
                                      Sid,
                                      cbSid,
                                      ReferencedDomainName,
                                      cbReferencedDomainName,
                                      peUse,
                                      TRUE              // Unicode
                                    ) );

}


BOOL
APIENTRY
LookupAccountSidInternal(
    LPCWSTR lpSystemName,
    PSID lpSid,
    LPWSTR lpName,
    LPDWORD cbName,
    LPWSTR lpReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse,
    BOOL fUnicode
    )

/*++

Routine Description:

    Translates a passed SID into an account name.  It will also return
    the name and SID of the first domain in which this SID was found.

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpSid - Supplies the account Sid.

    lpName - Returns the name corresponding to the passed account SID.

    cbName - Supplies the size (in Wide characters) of the buffer passed in for
        lpName.  This size must allow one character for the null terminator
        that will be appended to the returned name.  If the buffer size is not
        large enough, this parameter will return the size necessary to hold
        the null-terminated output name.  If the buffer size is large enough,
        this parameter will return the size (in Ansi characters, excluding
        the null terminator) of the name returned.

    lpReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cbReferencedDomainName - Supplies the size (in Wide characters) of the
        ReferencedDomainName buffer.  This size must allow one charcter for the
        null terminator that will be appended to the returned name.  If the
        buffer size is not large enough, this parameter will return the size
        necessary to hold the output null-terminated domain name.  If the
        buffer size is large enough, the size of the returned name, excluding
        the terminating null will be returned.

    peUse - Returns an enumerated type inidicating the type of the
        account.

    fUnicode - indicates whether the caller wants a count of unicode or
        ansi characters.

Return Value:

    BOOL - TRUE if successful, else FALSE.

--*/

{

    PLSA_TRANSLATED_NAME Names;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE PolicyHandle;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains;
    DWORD ReturnedDomainNameSize;
    DWORD ReturnedNameSize;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    NTSTATUS Status;
    UNICODE_STRING TmpString;
    NTSTATUS TmpStatus;
    UNICODE_STRING SystemName;
    PUNICODE_STRING pSystemName = NULL;
    BOOLEAN Rc = FALSE;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    if ( ARGUMENT_PRESENT( lpSystemName )) {
        RtlInitUnicodeString( &SystemName, lpSystemName );
        pSystemName = &SystemName;
    }

    Status = LsaOpenPolicy(
                 pSystemName,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    Status = LsaLookupSids(
                 PolicyHandle,
                 1,
                 &lpSid,
                 &ReferencedDomains,
                 &Names
                 );
#if DBG
//
// This code is useful for tracking down components that call Lookup code
// before the system is initialized
//
    // ASSERT( Status != STATUS_INVALID_SERVER_STATE );
    if ( Status == STATUS_INVALID_SERVER_STATE ) {

        DbgPrint( "Process: %lu, Thread: %lu\n", GetCurrentProcessId(), GetCurrentThreadId() );
    }
#endif

    TmpStatus = LsaClose( PolicyHandle );


    //
    // If an error was returned, check specifically for STATUS_NONE_MAPPED.
    // In this case, we may need to dispose of the returned Referenced Domain
    // List and Names structures.  For all other errors, LsaLookupSids()
    // frees these structures prior to exit.
    //

    if ( !NT_SUCCESS( Status )) {

        if (Status == STATUS_NONE_MAPPED) {

            if (ReferencedDomains != NULL) {

                TmpStatus = LsaFreeMemory( ReferencedDomains );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }

            if (Names != NULL) {

                TmpStatus = LsaFreeMemory( Names );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }
        }

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    //
    // The Sid was successfully translated.  There should be exactly
    // one Referenced Domain and its DomainIndex should be zero.
    //

    ASSERT(Names->DomainIndex == 0);
    ASSERT(ReferencedDomains != NULL);
    ASSERT(ReferencedDomains->Domains != NULL);

    if ( ! fUnicode ) {

        RtlUnicodeToMultiByteSize(&ReturnedNameSize,
                                  Names->Name.Buffer,
                                  Names->Name.Length);


        RtlUnicodeToMultiByteSize(&ReturnedDomainNameSize,
                                  ReferencedDomains->Domains->Name.Buffer,
                                  ReferencedDomains->Domains->Name.Length);

    } else {
        ReturnedNameSize = (Names->Name.Length / sizeof(WCHAR));
        ReturnedDomainNameSize = (ReferencedDomains->Domains->Name.Length / sizeof(WCHAR));
    }


    //
    // Check if buffer sizes  for the Name and Referenced Domain Name are too
    // small.  The sizes in Wide characters provided must allow for the null
    // terminator that will be appended to the returned names.
    //

    if ((ReturnedNameSize + 1 > *cbName) ||
        (ReturnedDomainNameSize + 1 > *cbReferencedDomainName)) {

        //
        // One or both buffers are too small.  Return sizes required for
        // both buffers, allowing one character for the null terminator.
        //

        *cbReferencedDomainName = ReturnedDomainNameSize + 1;
        *cbName = ReturnedNameSize + 1;
        BaseSetLastNTError( STATUS_BUFFER_TOO_SMALL );
        Rc = FALSE;

    } else {

        //
        // Both buffers are of sufficient size.  Copy in the Name
        // information and add NULL terminators.
        //

        TmpString.Buffer = lpName;
        TmpString.Length = 0;

        //
        // Watch for 16-bit overflow on buffer size.  Clamp size to
        // 16 bits if necessary.
        //

        if (*cbName <= 32766) {

            TmpString.MaximumLength = (USHORT)((*cbName) * sizeof(WCHAR));

        } else {

            TmpString.MaximumLength = (USHORT) 65532;
        }

        if ((*cbName) > 0) {

            RtlCopyUnicodeString( &TmpString, &Names->Name );
            TmpString.Buffer[TmpString.Length/sizeof(WCHAR)] = (WCHAR) 0;
        }

        //
        // Copy in the Referenced Domain information.
        //

        TmpString.Buffer = lpReferencedDomainName;
        TmpString.Length = 0;

        //
        // Watch for 16-bit overflow on buffer size.  Clamp size to
        // 16 bits if necessary.
        //

        if (*cbReferencedDomainName <= 32767) {

            TmpString.MaximumLength = (USHORT)((*cbReferencedDomainName) * sizeof(WCHAR));

        } else {

            TmpString.MaximumLength = (USHORT) 65534;
        }

        RtlCopyUnicodeString( &TmpString, &ReferencedDomains->Domains->Name );
        TmpString.Buffer[TmpString.Length/sizeof(WCHAR)] = (WCHAR) 0;

        //
        // Return the sizes (in Wide Characters, excluding the terminating
        // null) of the name and domain name.
        //

        *cbReferencedDomainName = ReturnedDomainNameSize;
        *cbName = ReturnedNameSize;

        // Copy in the Use field.
        //

        *peUse = Names->Use;
        Rc = TRUE;
    }

    //
    // If necessary, free output buffers returned by LsaLookupSids
    //

    if (Names != NULL) {

        Status = LsaFreeMemory( Names );
        ASSERT( NT_SUCCESS( Status ));
    }

    if (ReferencedDomains != NULL) {

        Status = LsaFreeMemory( ReferencedDomains );
        ASSERT( NT_SUCCESS( Status ));
    }

    return(Rc);
}



BOOL
APIENTRY
LookupAccountSidA(
    LPCSTR lpSystemName,
    PSID lpSid,
    LPSTR lpName,
    LPDWORD cbName,
    LPSTR lpReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    )
/*++

Routine Description:

    ANSI Thunk to LookupAccountSidW

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpSid - Supplies the account Sid.

    lpName - Returns the name corresponding to the passed account SID.

    cbName - Supplies the size (in Ansi characters) of the buffer passed in for
        lpName.  This size must allow one character for the null terminator
        that will be appended to the returned name.  If the buffer size is not
        large enough, this parameter will return the size necessary to hold
        the null-terminated output name.  If the buffer size is large enough,
        this parameter will return the size (in Ansi characters, excluding
        the null terminator) of the name returned.

    lpReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cbReferencedDomainName - Supplies the size (in Ansi characters) of the
        ReferencedDomainName buffer.  This size must allow one charcter for the
        null terminator that will be appended to the returned name.  If the
        buffer size is not large enough, this parameter will return the size
        necessary to hold the output null-terminated domain name.  If the
        buffer size is large enough, the size of the returned name, excluding
        the terminating null will be returned.

    peUse - Returns an enumerated type indicating the type of the
        account.


Return Value:

    BOOL - TRUE if successful, else FALSE.

--*/

{
    NTSTATUS Status;
    LPWSTR WName = NULL;
    LPWSTR WReferencedDomainName = NULL;
    BOOL BoolStatus;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING SystemName;
    PWSTR pSystemName = NULL;
    DWORD cbInitName, cbInitReferencedDomainName;

    //
    // Save the original buffer sizes specified for the returned account Name
    // and Referenced Domain Name.
    //

    cbInitName = *cbName;
    cbInitReferencedDomainName = *cbReferencedDomainName;

    //
    // Construct temporary buffers for the Name and Domain information
    // that are twice the size of those passed in to adjust for the
    // intermediate conversion to WCHAR strings.
    //

    if ( *cbName > 0 ) {
        WName = LocalAlloc( LMEM_FIXED, (*cbName) * sizeof(WCHAR));

        if ( !WName )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE ;
        }
    }

    if ( *cbReferencedDomainName > 0 ) {
        WReferencedDomainName =
            LocalAlloc( LMEM_FIXED, (*cbReferencedDomainName) * sizeof(WCHAR));

        if ( !WReferencedDomainName )
        {
            if ( WName )
            {
                LocalFree( WName );
            }

            SetLastError( ERROR_OUTOFMEMORY );

            return FALSE ;
        }
    }

    if ( ARGUMENT_PRESENT( lpSystemName ) ) {

        RtlInitAnsiString( &AnsiString, lpSystemName );
        RtlAnsiStringToUnicodeString( &SystemName, &AnsiString, TRUE );
        pSystemName = SystemName.Buffer;
    }

    BoolStatus = LookupAccountSidInternal(
                     (LPCWSTR)pSystemName,
                     lpSid,
                     WName,
                     cbName,
                     WReferencedDomainName,
                     cbReferencedDomainName,
                     peUse,
                     FALSE              // not unicode
                     );

    if ( ARGUMENT_PRESENT( lpSystemName ) ) {
        RtlFreeUnicodeString( &SystemName );
    }

    if ( BoolStatus ) {

        //
        // Copy the Name and DomainName information into the passed CHAR
        // buffers.
        //

        if ( ARGUMENT_PRESENT(lpName) ) {

            AnsiString.Buffer = lpName;

            //
            // Watch for 16-bit overflow on buffer size.  Clamp size to
            // 16 bits if necessary.
            //

            if (cbInitName <= (DWORD) 65535) {

                AnsiString.MaximumLength = (USHORT) cbInitName;

            } else {

                AnsiString.MaximumLength = (USHORT) 65535;
            }

            RtlInitUnicodeString( &UnicodeString, WName );
            Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                                   &UnicodeString,
                                                   FALSE );
            ASSERT(NT_SUCCESS(Status));
            AnsiString.Buffer[AnsiString.Length] = 0;
        }

        if ( ARGUMENT_PRESENT(lpReferencedDomainName) ) {

            AnsiString.Buffer = lpReferencedDomainName;

            //
            // Watch for 16-bit overflow on buffer size.  Clamp size to
            // 16 bits if necessary.
            //

            if (cbInitReferencedDomainName <= (DWORD) 65535) {

                AnsiString.MaximumLength = (USHORT) cbInitReferencedDomainName;

            } else {

                AnsiString.MaximumLength = (USHORT) 65535;
            }

            RtlInitUnicodeString( &UnicodeString, WReferencedDomainName );
            Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                                   &UnicodeString,
                                                   FALSE );
            ASSERT(NT_SUCCESS(Status));
            AnsiString.Buffer[AnsiString.Length] = 0;
        }

    }

    if (ARGUMENT_PRESENT(WName)) {
        LocalFree( WName );
    }
    if (ARGUMENT_PRESENT(WReferencedDomainName)) {
        LocalFree( WReferencedDomainName );
    }

    return( BoolStatus );
}




BOOL
APIENTRY
LookupAccountSidW(
    LPCWSTR lpSystemName,
    PSID lpSid,
    LPWSTR lpName,
    LPDWORD cbName,
    LPWSTR lpReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    )

/*++

Routine Description:

    Translates a passed SID into an account name.  It will also return
    the name and SID of the first domain in which this SID was found.

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpSid - Supplies the account Sid.

    lpName - Returns the name corresponding to the passed account SID.

    cbName - Supplies the size (in Wide characters) of the buffer passed in for
        lpName.  This size must allow one character for the null terminator
        that will be appended to the returned name.  If the buffer size is not
        large enough, this parameter will return the size necessary to hold
        the null-terminated output name.  If the buffer size is large enough,
        this parameter will return the size (in Ansi characters, excluding
        the null terminator) of the name returned.

    lpReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cbReferencedDomainName - Supplies the size (in Wide characters) of the
        ReferencedDomainName buffer.  This size must allow one charcter for the
        null terminator that will be appended to the returned name.  If the
        buffer size is not large enough, this parameter will return the size
        necessary to hold the output null-terminated domain name.  If the
        buffer size is large enough, the size of the returned name, excluding
        the terminating null will be returned.

    peUse - Returns an enumerated type inidicating the type of the
        account.

Return Value:

    BOOL - TRUE if successful, else FALSE.

--*/

{
    return(LookupAccountSidInternal(
                lpSystemName,
                lpSid,
                lpName,
                cbName,
                lpReferencedDomainName,
                cbReferencedDomainName,
                peUse,
                TRUE                    // Unicode
                ));
}


BOOL
APIENTRY
LookupPrivilegeValueA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    PLUID lpLuid
    )
/*++

Routine Description:

    ANSI Thunk to LookupPrivilegeValueW().

Arguments:


Return Value:


--*/
{
    NTSTATUS Status;
    UNICODE_STRING USystemName, UName;
    ANSI_STRING ASystemName, AName;
    BOOL bool;

    RtlInitAnsiString( &ASystemName, lpSystemName );
    RtlInitAnsiString( &AName, lpName );

    USystemName.Buffer = NULL;
    UName.Buffer = NULL;

    Status = RtlAnsiStringToUnicodeString( &USystemName, &ASystemName, TRUE );
    if (NT_SUCCESS(Status)) {

        Status = RtlAnsiStringToUnicodeString( &UName, &AName, TRUE );
        if (NT_SUCCESS(Status)) {


            bool = LookupPrivilegeValueW( (LPCWSTR)USystemName.Buffer,
                                          (LPCWSTR)UName.Buffer,
                                          lpLuid
                                          );

            RtlFreeUnicodeString( &UName );
        }

        RtlFreeUnicodeString( &USystemName );
    }

    if (!NT_SUCCESS(Status)) {

        BaseSetLastNTError( Status );
        return( FALSE );

    }

    return(bool);


}

BOOL
APIENTRY
LookupPrivilegeValueW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    PLUID  lpLuid
    )

/*++

Routine Description:


    This function retrieves the value used on the target system
    to locally represent the specified privilege.  The privilege
    is specified by programmatic name.


Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpName - provides the privilege's programmatic name.

    lpLuid - Receives the locally unique ID the privilege is known by on the
        target machine.


Return Value:



--*/
{
    NTSTATUS                    Status,
                                TmpStatus;

    LSA_HANDLE                  PolicyHandle;

    OBJECT_ATTRIBUTES           ObjectAttributes;

    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    UNICODE_STRING              USystemName,
                                UName;

    PUNICODE_STRING             SystemName = NULL;


    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0L, NULL, NULL );
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


    if ( ARGUMENT_PRESENT( lpSystemName )) {
        RtlInitUnicodeString( &USystemName, lpSystemName );
        SystemName = &USystemName;
    }

    Status = LsaOpenPolicy(
                 SystemName,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }



    RtlInitUnicodeString( &UName, lpName );
    Status = LsaLookupPrivilegeValue( PolicyHandle, &UName, lpLuid );

    TmpStatus = LsaClose( PolicyHandle );
//    ASSERT( NT_SUCCESS( TmpStatus ));


    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }


    return(TRUE);
}



BOOL
APIENTRY
LookupPrivilegeNameA(
    LPCSTR   lpSystemName,
    PLUID   lpLuid,
    LPSTR   lpName,
    LPDWORD cchName
    )
/*++

Routine Description:

    ANSI Thunk to LookupPrivilegeValueW().

Arguments:


Return Value:


--*/
{
    NTSTATUS       Status;

    ANSI_STRING    AnsiName;
    LPWSTR         UnicodeBuffer;
    UNICODE_STRING UnicodeString;

    ANSI_STRING    AnsiSystemName;
    UNICODE_STRING UnicodeSystemName;
    DWORD          LengthRequired;

    //
    // Convert the passed SystemName to Unicode.  Let the Rtl function
    // allocate the memory we need.
    //

    RtlInitAnsiString( &AnsiSystemName, lpSystemName );
    Status = RtlAnsiStringToUnicodeString( &UnicodeSystemName, &AnsiSystemName, TRUE );

    if (!NT_SUCCESS( Status )) {

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    //
    // Make sure we don't exceed the limits of a unicode string.
    //

    if (*cchName > 0xFFFC) {
        *cchName = 0xFFFC;
    }

    UnicodeBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, *cchName * sizeof(WCHAR) );

    if (UnicodeBuffer == NULL) {

        RtlFreeUnicodeString( &UnicodeSystemName );
        BaseSetLastNTError( STATUS_NO_MEMORY );
        return( FALSE );
    }

    //
    // Don't pass in cchName, since it will be overwritten by LookupPrivilegeNameW,
    // and we need it later.
    //

    LengthRequired = *cchName;

    if (!LookupPrivilegeNameW( (LPCWSTR)UnicodeSystemName.Buffer,
                               lpLuid,
                               UnicodeBuffer,
                               &LengthRequired
                               )) {

        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );
        RtlFreeUnicodeString( &UnicodeSystemName );
        *cchName = LengthRequired;
        return(FALSE);
    }

    //
    // Now convert back to ANSI for the caller
    //

    RtlInitUnicodeString(&UnicodeString, UnicodeBuffer);

    AnsiName.Buffer = lpName;
    AnsiName.Length = 0;
    AnsiName.MaximumLength = (USHORT)*cchName;

    Status = RtlUnicodeStringToAnsiString(&AnsiName, &UnicodeString, FALSE);

    ASSERT( NT_SUCCESS( Status ));

    *cchName = AnsiName.Length;

    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );
    RtlFreeUnicodeString( &UnicodeSystemName );

    return(TRUE);
}



BOOL
APIENTRY
LookupPrivilegeNameW(
    LPCWSTR  lpSystemName,
    PLUID   lpLuid,
    LPWSTR  lpName,
    LPDWORD cchName
    )
/*++

Routine Description:


    This function returns the programmatic name corresponding to
    the privilege represented on the target system by the provided
    LUID.


Arguments:


    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.


    lpLuid - is the locally unique ID the privilege is known by on the
        target machine.

    lpName - Receives the privilege's programmatic name.

    cchName - indicates how large the buffer is (in characters).  This
        count does not include the null-terminator that is added at the
        end of the string.



Return Value:



--*/
{
    NTSTATUS                    Status,
                                TmpStatus;
    LSA_HANDLE                  PolicyHandle;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    UNICODE_STRING              USystemName;
    PUNICODE_STRING             SystemName,
                                UName;


    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0L, NULL, NULL );
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


    SystemName = NULL;
    if ( ARGUMENT_PRESENT( lpSystemName )) {
        RtlInitUnicodeString( &USystemName, lpSystemName );
        SystemName = &USystemName;
    }

    Status = LsaOpenPolicy(
                 SystemName,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }


    UName = NULL;
    Status = LsaLookupPrivilegeName( PolicyHandle,lpLuid, &UName );

    if (NT_SUCCESS(Status) ) {

        if ((DWORD)UName->Length + sizeof( WCHAR) > (*cchName) * sizeof( WCHAR )) {
            Status = STATUS_BUFFER_TOO_SMALL;
            (*cchName) = ( UName->Length + sizeof( WCHAR) ) / sizeof( WCHAR );

        } else {

            RtlMoveMemory( lpName, UName->Buffer, UName->Length );
            lpName[UName->Length/sizeof(WCHAR)] = 0;  // NULL terminate it
            (*cchName) = UName->Length / sizeof( WCHAR );
        }

        LsaFreeMemory( UName->Buffer );
        LsaFreeMemory( UName );
    }

    TmpStatus = LsaClose( PolicyHandle );
//    ASSERT( NT_SUCCESS( TmpStatus ));


    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }


    return(TRUE);
}



BOOL
APIENTRY
LookupPrivilegeDisplayNameA(
    LPCSTR   lpSystemName,
    LPCSTR   lpName,
    LPSTR   lpDisplayName,
    LPDWORD cchDisplayName,
    LPDWORD lpLanguageId
    )

/*++

Routine Description:

    ANSI Thunk to LookupPrivilegeValueW().

Arguments:


Return Value:


--*/
{
    NTSTATUS                Status;

    UNICODE_STRING          UnicodeSystemName;
    UNICODE_STRING          UnicodeString;
    UNICODE_STRING          UnicodeName;

    ANSI_STRING             AnsiSystemName;
    ANSI_STRING             AnsiDisplayName;
    ANSI_STRING             AnsiName;

    LPWSTR                  UnicodeBuffer;
    DWORD                   RequiredLength;


    RtlInitAnsiString( &AnsiSystemName, lpSystemName );
    Status = RtlAnsiStringToUnicodeString( &UnicodeSystemName, &AnsiSystemName, TRUE );

    if (!NT_SUCCESS( Status )) {

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    //
    // Make sure we don't exceed that limits of a unicode string.
    //

    if (*cchDisplayName > 0xFFFC) {
        *cchDisplayName = 0xFFFC;
    }

    UnicodeBuffer =  RtlAllocateHeap( RtlProcessHeap(), 0, *cchDisplayName * sizeof(WCHAR));

    if (UnicodeBuffer == NULL) {

        RtlFreeUnicodeString( &UnicodeSystemName );
        BaseSetLastNTError( STATUS_NO_MEMORY );
        return( FALSE );
    }

    RtlInitAnsiString( &AnsiName, lpName );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS( Status )) {

        RtlFreeUnicodeString( &UnicodeSystemName );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );
        BaseSetLastNTError( Status );
        return( FALSE );
    }

    RequiredLength = *cchDisplayName;

    if (! LookupPrivilegeDisplayNameW( (LPCWSTR)UnicodeSystemName.Buffer,
                                       (LPCWSTR)UnicodeName.Buffer,
                                       UnicodeBuffer,
                                       &RequiredLength,
                                       lpLanguageId
                                       )) {

        //
        // No need to set last error here, we can assume the W routine did so.
        //

        *cchDisplayName = RequiredLength;

        RtlFreeUnicodeString( &UnicodeSystemName );
        RtlFreeUnicodeString( &UnicodeName );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );
        return( FALSE );
    }

    //
    // Now convert back to ANSI for the caller
    //

    RtlInitUnicodeString( &UnicodeString, UnicodeBuffer );

    AnsiDisplayName.Buffer = lpDisplayName;
    AnsiDisplayName.Length = 0;
    AnsiDisplayName.MaximumLength = (USHORT)(*cchDisplayName);

    Status = RtlUnicodeStringToAnsiString( &AnsiDisplayName, &UnicodeString, FALSE );

    ASSERT( NT_SUCCESS( Status ));

    *cchDisplayName = AnsiDisplayName.Length;

    RtlFreeUnicodeString( &UnicodeSystemName );
    RtlFreeUnicodeString( &UnicodeName );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );

    return( TRUE );
}



BOOL
APIENTRY
LookupPrivilegeDisplayNameW(
    LPCWSTR  lpSystemName,
    LPCWSTR  lpName,
    LPWSTR  lpDisplayName,
    LPDWORD cchDisplayName,
    LPDWORD lpLanguageId
    )

/*++

Routine Description:

    This function retrieves a displayable name representing the
    specified privilege.


Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.


    lpName - provides the privilege's programmatic name.


    lpDisplayName - Receives the privilege's displayable name.

    cchDisplayName - indicates how large the buffer is (in characters).  This
        count does not include the null-terminator that is added at the
        end of the string.

    lpLanguageId - Receives the language of the returned displayable
        name.


Return Value:


--*/

{
    NTSTATUS                    Status,
                                TmpStatus;

    LSA_HANDLE                  PolicyHandle;

    OBJECT_ATTRIBUTES           ObjectAttributes;

    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    UNICODE_STRING              USystemName,
                                UName;

    PUNICODE_STRING             SystemName,
                                UDisplayName;

    SHORT                       LanguageId;


    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0L, NULL, NULL );
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


    SystemName = NULL;
    if ( ARGUMENT_PRESENT( lpSystemName )) {
        RtlInitUnicodeString( &USystemName, lpSystemName );
        SystemName = &USystemName;
    }

    Status = LsaOpenPolicy(
                 SystemName,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }

    RtlInitUnicodeString( &UName, lpName );


    UDisplayName = NULL;
    Status = LsaLookupPrivilegeDisplayName( PolicyHandle,
                                            &UName,
                                            &UDisplayName,
                                            &LanguageId
                                            );
    (*lpLanguageId) = LanguageId;

    if (NT_SUCCESS(Status)) {

        if (UDisplayName->Length + sizeof(WCHAR) > (*cchDisplayName) * sizeof(WCHAR)) {
            Status = STATUS_BUFFER_TOO_SMALL;
            (*cchDisplayName) = (UDisplayName->Length + sizeof( WCHAR )) / sizeof( WCHAR );

        } else {

            RtlMoveMemory( lpDisplayName,
                           UDisplayName->Buffer,
                           UDisplayName->Length
                           );
            lpDisplayName[UDisplayName->Length/sizeof(WCHAR)] = 0;  // Null terminate it.
            (*cchDisplayName) = UDisplayName->Length / sizeof( WCHAR );
        }

        LsaFreeMemory( UDisplayName->Buffer );
        LsaFreeMemory( UDisplayName );

    }
    TmpStatus = LsaClose( PolicyHandle );
//    ASSERT( NT_SUCCESS( TmpStatus ));


    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }


    return(TRUE);
}


BOOL
APIENTRY
ImpersonateAnonymousToken(
    IN HANDLE ThreadHandle
    )
/*++

Routine Description:

    Win32 wrapper for NtImpersonateAnonymousToken();

    Impersonates the system's anonymous logon token on this thread.

Arguments:

    ThreadHandle - Handle to the thread to do the impersonation.

Return Value:

    TRUE for success, FALSE for failure.

    Call GetLastError() for more information.

--*/
{
    NTSTATUS Status;

    Status = NtImpersonateAnonymousToken(
                ThreadHandle
                );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );

    } else {
        return( TRUE );
    }
}





/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//               Private Routines                                          //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

VOID
SepFormatAccountSid(
    PSID Sid,
    LPWSTR OutputBuffer
    )
{
    UCHAR Buffer[128];
    UCHAR TmpBuffer[128];
    ANSI_STRING AccountName;
    UCHAR i;
    ULONG Tmp;
    UNICODE_STRING OutputString;
    PISID iSid;
    NTSTATUS Status;

    //
    // Do everything as ANSI for the time being, and then
    // convert to wide-char at the bottom.
    //
    // We need to do this until we have more complete c-runtime support
    // for w-char strings.
    //

    iSid = (PISID) Sid;

    OutputString.Buffer = OutputBuffer;
    OutputString.MaximumLength = 127;

    Buffer[0] = 0;
    TmpBuffer[0] = 0;

    AccountName.MaximumLength = 127;
    AccountName.Length = (USHORT)((GetLengthSid( Sid ) > MAXUSHORT) ? MAXUSHORT : GetLengthSid( Sid ));
    AccountName.Buffer = Buffer;

    sprintf(TmpBuffer, "S-%u-", (USHORT)iSid->Revision );
    lstrcpy(Buffer, TmpBuffer);

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){
        sprintf(TmpBuffer, "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)iSid->IdentifierAuthority.Value[0],
                    (USHORT)iSid->IdentifierAuthority.Value[1],
                    (USHORT)iSid->IdentifierAuthority.Value[2],
                    (USHORT)iSid->IdentifierAuthority.Value[3],
                    (USHORT)iSid->IdentifierAuthority.Value[4],
                    (USHORT)iSid->IdentifierAuthority.Value[5] );
        lstrcat(Buffer, TmpBuffer);
    } else {
        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);
        sprintf(TmpBuffer, "%lu", Tmp);
        lstrcat(Buffer, TmpBuffer);
    }

    for (i=0;i<iSid->SubAuthorityCount ;i++ ) {
        sprintf(TmpBuffer, "-%lu", iSid->SubAuthority[i]);
        lstrcat(Buffer, TmpBuffer);
    }

    Status = RtlAnsiStringToUnicodeString( &OutputString, &AccountName, FALSE );

    ASSERT( NT_SUCCESS( Status ));

    return;
}

BOOL
APIENTRY
CreateRestrictedToken(
    IN HANDLE ExistingTokenHandle,
    IN DWORD Flags,
    IN DWORD DisableSidCount,
    IN PSID_AND_ATTRIBUTES SidsToDisable OPTIONAL,
    IN DWORD DeletePrivilegeCount,
    IN PLUID_AND_ATTRIBUTES PrivilegesToDelete OPTIONAL,
    IN DWORD RestrictedSidCount,
    IN PSID_AND_ATTRIBUTES SidsToRestrict OPTIONAL,
    OUT PHANDLE NewTokenHandle
    )
{
    NTSTATUS Status;
    PTOKEN_GROUPS DisabledSids = NULL;
    PTOKEN_PRIVILEGES DeletedPrivileges = NULL;
    PTOKEN_GROUPS RestrictedSids = NULL;

    //
    // Convert the input parameters into the native NT format
    //

    if (DisableSidCount != 0) {
        if (SidsToDisable == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        DisabledSids = (PTOKEN_GROUPS) LocalAlloc(0,sizeof(TOKEN_GROUPS) +
                                        (DisableSidCount - 1) * sizeof(SID_AND_ATTRIBUTES) );
        if (DisabledSids == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        DisabledSids->GroupCount = DisableSidCount;
        RtlCopyMemory(
            DisabledSids->Groups,
            SidsToDisable,
            DisableSidCount * sizeof(SID_AND_ATTRIBUTES)
            );
    }

    if (DeletePrivilegeCount != 0) {
        if (PrivilegesToDelete == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        DeletedPrivileges = (PTOKEN_PRIVILEGES) LocalAlloc(0,sizeof(TOKEN_PRIVILEGES) +
                                        (DeletePrivilegeCount - 1) * sizeof(LUID_AND_ATTRIBUTES) );
        if (DeletedPrivileges == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        DeletedPrivileges->PrivilegeCount = DeletePrivilegeCount;
        RtlCopyMemory(
            DeletedPrivileges->Privileges,
            PrivilegesToDelete,
            DeletePrivilegeCount * sizeof(LUID_AND_ATTRIBUTES)
            );
    }

    if (RestrictedSidCount != 0) {
        if (SidsToRestrict == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        RestrictedSids = (PTOKEN_GROUPS) LocalAlloc(0,sizeof(TOKEN_GROUPS) +
                                        (RestrictedSidCount - 1) * sizeof(SID_AND_ATTRIBUTES) );
        if (RestrictedSids == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RestrictedSids->GroupCount = RestrictedSidCount;
        RtlCopyMemory(
            RestrictedSids->Groups,
            SidsToRestrict,
            RestrictedSidCount * sizeof(SID_AND_ATTRIBUTES)
            );
    }

    Status = NtFilterToken(
                ExistingTokenHandle,
                Flags,
                DisabledSids,
                DeletedPrivileges,
                RestrictedSids,
                NewTokenHandle
                );

Cleanup:
    if (DisabledSids != NULL) {
        LocalFree(DisabledSids);
    }
    if (DeletedPrivileges != NULL) {
        LocalFree(DeletedPrivileges);
    }
    if (RestrictedSids != NULL) {
        LocalFree(RestrictedSids);
    }
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError( Status );
        return(FALSE);
    }
    return(TRUE);
}

BOOL
APIENTRY
IsTokenRestricted(
    IN HANDLE TokenHandle
    )
{
    PTOKEN_GROUPS RestrictedSids = NULL;
    ULONG ReturnLength;
    NTSTATUS Status;
    BOOL Result = FALSE;


    Status = NtQueryInformationToken(
                TokenHandle,
                TokenRestrictedSids,
                NULL,
                0,
                &ReturnLength
                );
    if (Status != STATUS_BUFFER_TOO_SMALL)
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    RestrictedSids = (PTOKEN_GROUPS) LocalAlloc(0, ReturnLength);
    if (RestrictedSids == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    Status = NtQueryInformationToken(
                TokenHandle,
                TokenRestrictedSids,
                RestrictedSids,
                ReturnLength,
                &ReturnLength
                );
    if (NT_SUCCESS(Status))
    {
        if (RestrictedSids->GroupCount != 0)
        {
            Result = TRUE;
        }
    }
    else
    {
        BaseSetLastNTError(Status);
    }
    LocalFree(RestrictedSids);
    return(Result);
}


BOOL
APIENTRY
CheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    )
/*++

Routine Description:

    This function checks to see whether the specified sid is enabled in
    the specified token.

Arguments:

    TokenHandle - If present, this token is checked for the sid. If not
        present then the current effective token will be used. This must
        be an impersonation token.

    SidToCheck - The sid to check for presence in the token

    IsMember - If the sid is enabled in the token, contains TRUE otherwise
        false.

Return Value:

    TRUE - The API completed successfully. It does not indicate that the
        sid is a member of the token.

    FALSE - The API failed. A more detailed status code can be retrieved
        via GetLastError()


--*/
{
    HANDLE ProcessToken = NULL;
    HANDLE EffectiveToken = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PISECURITY_DESCRIPTOR SecDesc = NULL;
    ULONG SecurityDescriptorSize;
    GENERIC_MAPPING GenericMapping = {
        STANDARD_RIGHTS_READ,
        STANDARD_RIGHTS_EXECUTE,
        STANDARD_RIGHTS_WRITE,
        STANDARD_RIGHTS_ALL };
    //
    // The size of the privilege set needs to contain the set itself plus
    // any privileges that may be used. The privileges that are used
    // are SeTakeOwnership and SeSecurity, plus one for good measure
    //

    BYTE PrivilegeSetBuffer[sizeof(PRIVILEGE_SET) + 3*sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET PrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;
    ULONG PrivilegeSetLength = sizeof(PrivilegeSetBuffer);
    ACCESS_MASK AccessGranted = 0;
    NTSTATUS AccessStatus = 0;
    PACL Dacl = NULL;

#define MEMBER_ACCESS 1

    *IsMember = FALSE;

    //
    // Get a handle to the token
    //

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        EffectiveToken = TokenHandle;
    }
    else
    {
        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    FALSE,              // don't open as self
                    &EffectiveToken
                    );

        //
        // if there is no thread token, try the process token
        //

        if (Status == STATUS_NO_TOKEN)
        {
            Status = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_QUERY | TOKEN_DUPLICATE,
                        &ProcessToken
                        );
            //
            // If we have a process token, we need to convert it to an
            // impersonation token
            //

            if (NT_SUCCESS(Status))
            {
                BOOL Result;
                Result = DuplicateToken(
                            ProcessToken,
                            SecurityImpersonation,
                            &EffectiveToken
                            );

                CloseHandle(ProcessToken);
                if (!Result)
                {
                    return(FALSE);
                }
            }
        }

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

    //
    // Construct a security descriptor to pass to access check
    //

    //
    // The size is equal to the size of an SD + twice the length of the SID
    // (for owner and group) + size of the DACL = sizeof ACL + size of the
    // ACE, which is an ACE + length of
    // ths SID.
    //

    SecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR) +
                                sizeof(ACCESS_ALLOWED_ACE) +
                                sizeof(ACL) +
                                3 * RtlLengthSid(SidToCheck);

    SecDesc = (PISECURITY_DESCRIPTOR) LocalAlloc(LMEM_ZEROINIT, SecurityDescriptorSize );
    if (SecDesc == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Dacl = (PACL) (SecDesc + 1);

    RtlCreateSecurityDescriptor(
        SecDesc,
        SECURITY_DESCRIPTOR_REVISION
        );

    //
    // Fill in fields of security descriptor
    //

    RtlSetOwnerSecurityDescriptor(
        SecDesc,
        SidToCheck,
        FALSE
        );
    RtlSetGroupSecurityDescriptor(
        SecDesc,
        SidToCheck,
        FALSE
        );

    Status = RtlCreateAcl(
                Dacl,
                SecurityDescriptorSize - sizeof(SECURITY_DESCRIPTOR),
                ACL_REVISION
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = RtlAddAccessAllowedAce(
                Dacl,
                ACL_REVISION,
                MEMBER_ACCESS,
                SidToCheck
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the DACL on the security descriptor
    //

    Status = RtlSetDaclSecurityDescriptor(
                SecDesc,
                TRUE,   // DACL present
                Dacl,
                FALSE   // not defaulted
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = NtAccessCheck(
                SecDesc,
                EffectiveToken,
                MEMBER_ACCESS,
                &GenericMapping,
                PrivilegeSet,
                &PrivilegeSetLength,
                &AccessGranted,
                &AccessStatus
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // if the access check failed, then the sid is not a member of the
    // token
    //

    if ((AccessStatus == STATUS_SUCCESS) && (AccessGranted == MEMBER_ACCESS))
    {
        *IsMember = TRUE;
    }




Cleanup:
    if (!ARGUMENT_PRESENT(TokenHandle) && (EffectiveToken != NULL))
    {
        (VOID) NtClose(EffectiveToken);
    }

    if (SecDesc != NULL)
    {
        LocalFree(SecDesc);
    }

    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}

BOOL
APIENTRY
MakeAbsoluteSD2 (
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    LPDWORD lpdwBufferSize
    )
/*++

Routine Description:

    Converts a security descriptor from self-relative format to absolute
    format

Arguments:

    pSelfRelativeSecurityDescriptor - Supplies a pointer to a security descriptor
        in Self-Relative format

    lpdwBufferSize - The size in bytes of the
        buffer pointed to by pSelfRelativeSecurityDescriptor.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSelfRelativeToAbsoluteSD2 (
                pSelfRelativeSecurityDescriptor,
                lpdwBufferSize
                );

    //
    // MakeAbsoluteSD2() has the same prototype as
    // RtlSelfRelativeToAbsoluteSD2() so the parameters check
    // returns the same parameter order if the caller passes invalid parameter.
    //

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;

} // MakeAbsoluteSD2()




DWORD
APIENTRY
GetSecurityDescriptorRMControl(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PUCHAR RMControl
    )
/*++

Routine Description:

    This procedure returns the RM Control flags from a SecurityDescriptor if
    SE_RM_CONTROL_VALID flags is present in the control field.

Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure

    RMControl          - Returns the flags in the SecurityDescriptor if
                         SE_RM_CONTROL_VALID is set in the control bits of the
                         SecurityDescriptor.

Return Value:
    ERROR_INVALID_DATA      if the SE_RM_CONTROL_VALID flag is not present in
                            the security descriptor
    ERROR_SUCCESS           otherwise

--*/


{
    BOOLEAN Result;

    Result = RtlGetSecurityDescriptorRMControl(
                 SecurityDescriptor,
                 RMControl
                 );

    if (FALSE == Result)
    {
        return ERROR_INVALID_DATA;
    }

    return ERROR_SUCCESS;
}

DWORD
APIENTRY
SetSecurityDescriptorRMControl(
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PUCHAR RMControl OPTIONAL
    )


/*++

Routine Description:

    This procedure sets the RM Control flag in the control field of
    SecurityDescriptor and sets Sbz1 to the the byte to which RMContol point
    If RMControl is NULL then the bits are cleared.


Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure

    RMControl          - Pointer to the flags to set. If NULL then the bits
                         are cleared.


Return Value: ERROR_SUCCESS

--*/

{
    RtlSetSecurityDescriptorRMControl(
        SecurityDescriptor,
        RMControl
        );

    return ERROR_SUCCESS;
}


//
// Datatypes for identifying and constructing well known sids
//
//
// N.B When adding a new well known security principal, all that is 
// necessary is to update one of the domain tables below. For example,
// if adding a new domain group, add an entry to AccountDomainSids
// with the new RID and the new WELL_KNOWN_SID_TYPE enumeration.
//

#define NELEMENTS(x)  sizeof(x)/sizeof((x)[0])

typedef struct 
{
    ULONG               Rid;
    WELL_KNOWN_SID_TYPE Type;

} WELL_KNOWN_RID_ARRAY;

WELL_KNOWN_RID_ARRAY NullAuthoritySids[] = 
{
    {SECURITY_NULL_RID, WinNullSid}
};

WELL_KNOWN_RID_ARRAY WorldAuthoritySids[] =
{
    {SECURITY_WORLD_RID, WinWorldSid}
};

WELL_KNOWN_RID_ARRAY LocalAuthoritySids[] =
{
    {SECURITY_LOCAL_RID, WinLocalSid}
};

WELL_KNOWN_RID_ARRAY CreatorOwnerAuthoritySids[] =
{
    {SECURITY_CREATOR_OWNER_RID, WinCreatorOwnerSid},
    {SECURITY_CREATOR_GROUP_RID, WinCreatorGroupSid},
    {SECURITY_CREATOR_OWNER_SERVER_RID, WinCreatorOwnerServerSid},
    {SECURITY_CREATOR_GROUP_SERVER_RID, WinCreatorGroupServerSid}
};

WELL_KNOWN_RID_ARRAY NtAuthoritySids[] =
{
    {SECURITY_DIALUP_RID, WinDialupSid},
    {SECURITY_NETWORK_RID, WinNetworkSid},
    {SECURITY_BATCH_RID, WinBatchSid},
    {SECURITY_INTERACTIVE_RID, WinInteractiveSid},
    {SECURITY_SERVICE_RID, WinServiceSid},
    {SECURITY_ANONYMOUS_LOGON_RID, WinAnonymousSid},
    {SECURITY_PROXY_RID, WinProxySid},
    {SECURITY_ENTERPRISE_CONTROLLERS_RID, WinEnterpriseControllersSid},
    {SECURITY_PRINCIPAL_SELF_RID, WinSelfSid},
    {SECURITY_AUTHENTICATED_USER_RID, WinAuthenticatedUserSid},
    {SECURITY_RESTRICTED_CODE_RID, WinRestrictedCodeSid},
    {SECURITY_TERMINAL_SERVER_RID, WinTerminalServerSid},
    {SECURITY_REMOTE_LOGON_RID, WinRemoteLogonIdSid},
//
// N.B. The Logon IDs SID is special in that it has three subauth's.
// IsWellKnownSid() special cases this, CreateWellKnownSid doesn't accept
// WinLogonIdsSid
//
//    {SECURITY_LOGON_IDS_RID, WinLogonIdsSid},
    {SECURITY_LOCAL_SYSTEM_RID, WinLocalSystemSid},
    {SECURITY_LOCAL_SERVICE_RID, WinLocalServiceSid},
    {SECURITY_NETWORK_SERVICE_RID, WinNetworkServiceSid},
    {SECURITY_BUILTIN_DOMAIN_RID, WinBuiltinDomainSid},
};

WELL_KNOWN_RID_ARRAY BuiltinDomainSids[] =
{
    {DOMAIN_ALIAS_RID_ADMINS, WinBuiltinAdministratorsSid},
    {DOMAIN_ALIAS_RID_USERS, WinBuiltinUsersSid},
    {DOMAIN_ALIAS_RID_GUESTS, WinBuiltinGuestsSid},
    {DOMAIN_ALIAS_RID_POWER_USERS, WinBuiltinPowerUsersSid},
    {DOMAIN_ALIAS_RID_ACCOUNT_OPS, WinBuiltinAccountOperatorsSid},
    {DOMAIN_ALIAS_RID_SYSTEM_OPS, WinBuiltinSystemOperatorsSid},
    {DOMAIN_ALIAS_RID_PRINT_OPS, WinBuiltinPrintOperatorsSid},
    {DOMAIN_ALIAS_RID_BACKUP_OPS, WinBuiltinBackupOperatorsSid},
    {DOMAIN_ALIAS_RID_REPLICATOR, WinBuiltinReplicatorSid},
    {DOMAIN_ALIAS_RID_PREW2KCOMPACCESS, WinBuiltinPreWindows2000CompatibleAccessSid},
    {DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, WinBuiltinRemoteDesktopUsersSid},
    {DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS, WinBuiltinNetworkConfigurationOperatorsSid},
};

WELL_KNOWN_RID_ARRAY AccountDomainSids[] =
{
    {DOMAIN_USER_RID_ADMIN, WinAccountAdministratorSid},
    {DOMAIN_USER_RID_GUEST, WinAccountGuestSid},
    {DOMAIN_USER_RID_KRBTGT, WinAccountKrbtgtSid},
    {DOMAIN_GROUP_RID_ADMINS, WinAccountDomainAdminsSid},
    {DOMAIN_GROUP_RID_USERS, WinAccountDomainUsersSid},
    {DOMAIN_GROUP_RID_GUESTS, WinAccountDomainGuestsSid},
    {DOMAIN_GROUP_RID_COMPUTERS, WinAccountComputersSid},
    {DOMAIN_GROUP_RID_CONTROLLERS, WinAccountControllersSid},
    {DOMAIN_GROUP_RID_CERT_ADMINS, WinAccountCertAdminsSid},
    {DOMAIN_GROUP_RID_SCHEMA_ADMINS, WinAccountSchemaAdminsSid},
    {DOMAIN_GROUP_RID_ENTERPRISE_ADMINS, WinAccountEnterpriseAdminsSid},
    {DOMAIN_GROUP_RID_POLICY_ADMINS, WinAccountPolicyAdminsSid},
    {DOMAIN_ALIAS_RID_RAS_SERVERS, WinAccountRasAndIasServersSid},
};

typedef struct 
{
    SID_IDENTIFIER_AUTHORITY Authority;
    WELL_KNOWN_RID_ARRAY*    WellKnownRids;
    ULONG                    Count;

} WELL_KNOWN_AUTHORITIES_TYPE;

//
// WARNING!  Do not change the numbering here without changing the order
// of the KnownAuthoritiesAndDomains table.  There should never be a reason
// to change the ordering.
//

#define AUTHORITY_INDEX_START          0
#define NULL_AUTHORITY_INDEX           0
#define WORLD_AUTHORITY_INDEX          1
#define LOCAL_AUTHORITY_INDEX          2
#define CREATOR_OWNER_AUTHORITY_INDEX  3
#define NT_AUTHORITY_INDEX             4
#define AUTHORITY_INDEX_SENTINEL       5

#define BUILTIN_DOMAIN_INDEX           5
#define ACCOUNT_DOMAIN_INDEX           6
                                
WELL_KNOWN_AUTHORITIES_TYPE KnownAuthoritiesAndDomains[] = 
{
    {SECURITY_NULL_SID_AUTHORITY, NullAuthoritySids, NELEMENTS(NullAuthoritySids)},
    {SECURITY_WORLD_SID_AUTHORITY, WorldAuthoritySids, NELEMENTS(WorldAuthoritySids)},
    {SECURITY_LOCAL_SID_AUTHORITY, LocalAuthoritySids, NELEMENTS(LocalAuthoritySids)},
    {SECURITY_CREATOR_SID_AUTHORITY, CreatorOwnerAuthoritySids, NELEMENTS(CreatorOwnerAuthoritySids)},
    {SECURITY_NT_AUTHORITY, NtAuthoritySids, NELEMENTS(NtAuthoritySids)},
    {SECURITY_NT_AUTHORITY, BuiltinDomainSids, NELEMENTS(BuiltinDomainSids)},
    {SECURITY_NT_AUTHORITY, AccountDomainSids, NELEMENTS(AccountDomainSids)},
};

WINADVAPI
BOOL
WINAPI
IsWellKnownSid (
    IN  PSID pSid,
    IN  WELL_KNOWN_SID_TYPE WellKnownSidType
    )
/*++

Routine Description:

    This routine determines is pSID is the well known SID specified.
    
    It is purely runtime routine (that is, it makes no network or kernel 
    calls).
    
Parameters:

    pSid -- the SID to inspect
    
    WellKnownSidType - the well known SID to check for

Return Values

    TRUE is the SID matches the well known SID, 
    FALSE otherwise
    
 --*/
{

    ULONG i;
    BOOL fFound = FALSE;
    WELL_KNOWN_SID_TYPE Type;
    SID_IDENTIFIER_AUTHORITY *pAuthority = NULL;
    WELL_KNOWN_RID_ARRAY *RidArray = NULL;
    UCHAR SubAuthCount = 0;
    ULONG RidArrayCount;

#define IS_EQUAL_AUTHORITY(x, y) \
    RtlEqualMemory((x),(y),sizeof(SID_IDENTIFIER_AUTHORITY))

    //
    // Guard against bad parameters
    //
    if (!RtlValidSid(pSid)) {
        return FALSE;
    }

    pAuthority = GetSidIdentifierAuthority(pSid);
    if (NULL == pAuthority) {
        return FALSE;
    }

    SubAuthCount = *RtlSubAuthorityCountSid(pSid);
    if (SubAuthCount == 0) {

        //
        // Only one such known sid -- the Nt Authority domain sid has no
        // sub auth's
        //
        if ( IS_EQUAL_AUTHORITY(pAuthority, 
                  &KnownAuthoritiesAndDomains[NT_AUTHORITY_INDEX].Authority) ) {
            fFound = TRUE;
            Type = WinNtAuthoritySid;
        }

    } else if (SubAuthCount == 1) {

        //
        // Try the known authorities that aren't domains
        //

        for ( i = AUTHORITY_INDEX_START; i < AUTHORITY_INDEX_SENTINEL; i++) {
            if  (IS_EQUAL_AUTHORITY(pAuthority, 
                                   &KnownAuthoritiesAndDomains[i].Authority)) {
                RidArray = KnownAuthoritiesAndDomains[i].WellKnownRids;
                RidArrayCount = KnownAuthoritiesAndDomains[i].Count;
                break;
            }
        }

    } else if (SubAuthCount > 1) {

        //
        // Try the domains (builtin and account)
        //
        if ( IS_EQUAL_AUTHORITY(pAuthority, 
                  &KnownAuthoritiesAndDomains[NT_AUTHORITY_INDEX].Authority) ) {

            ULONG FirstSubAuth = *RtlSubAuthoritySid(pSid, 0);
    
            if  ( (FirstSubAuth == SECURITY_BUILTIN_DOMAIN_RID)
             &&   (SubAuthCount == 2)  ) {

                // Builtin domain sids always have 2 sub auth's: the builtin
                // RID and the principal RID
                RidArray = BuiltinDomainSids;
                RidArrayCount = NELEMENTS(BuiltinDomainSids);

            } else if ((FirstSubAuth == SECURITY_NT_NON_UNIQUE)
                    && (SubAuthCount == SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT+2)){

                // These account domains have 
                // 1 subauth for the SECURITY_NT_NON_UNIQUE,
                // 1 for the principal and
                // SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT for the domain portion
                RidArray = AccountDomainSids;
                RidArrayCount = NELEMENTS(AccountDomainSids);

            } else if  ( (FirstSubAuth == SECURITY_LOGON_IDS_RID)
                    &&   (SubAuthCount == SECURITY_LOGON_IDS_RID_COUNT)) {
                //
                // This is the special LogonId sid S-1-5-5-X-Y
                //
                fFound = TRUE;
                Type = WinLogonIdsSid;
            }
        }                    
    }

    //
    // If we matched for authority or domain, try to match RID
    //
    if ( RidArray ) {

        ULONG Rid;
        ASSERT(SubAuthCount > 0);

        Rid = *RtlSubAuthoritySid(pSid, SubAuthCount - 1);
        for (i = 0; i < RidArrayCount; i++) {
            if (Rid == RidArray[i].Rid) {
                fFound = TRUE;
                Type = RidArray[i].Type;
                break;
            }
        }
    }

    if (fFound && (Type == WellKnownSidType)) {
        fFound = TRUE;
    } else {
        fFound = FALSE;
    }

    return fFound;

}


WINADVAPI
BOOL
WINAPI
CreateWellKnownSid(
    IN WELL_KNOWN_SID_TYPE WellKnownSidType,
    IN PSID pDomainSid  OPTIONAL,
    OUT PSID pSid,
    IN OUT DWORD *cbSid
    )
/*++

Routine Description:

    This routines creates the SID of a well known principal.
   
Parameters:

    WellKnownSidType - the well known account sid that the caller desires

    pDomainSid - if the WellKnownSidType is an SID from an Account domain, this
                 value can be set; if not set and the WellKnownSidType is from 
                 an Account domain, the local account domain will be used - this
                 may result in an ACCESS_DENIED if the caller doesn't have 
                 access to read the local account domain sid. If the 
                 WellKnownSidType is not from an Account domain, this parameter 
                 is ignored.

    pSID - a client allocated buffer
    
    cbSid - the number of bytes pointed to by pSID

Return Values

    TRUE if WellKnownSidType is understood and pSID points to a buffer large 
    enough to hold the SID

    FALSE otherwise
    
 --*/
{

    BOOL  fFound = FALSE;
    ULONG Rid;
    ULONG i, j;
    ULONG SizeRequired;
    NTSTATUS Status;
    UCHAR SubAuthCount;

    if (pDomainSid && !RtlValidSid(pDomainSid)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (IsBadWritePtr(cbSid, sizeof(*cbSid))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // special case -- can't create this one
    if (WinLogonIdsSid == WellKnownSidType) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    //
    // Find the requested type
    //
    for (i = 0; i < NELEMENTS(KnownAuthoritiesAndDomains); i++) {
        for (j = 0; j < KnownAuthoritiesAndDomains[i].Count; j++) {
            if (WellKnownSidType == KnownAuthoritiesAndDomains[i].WellKnownRids[j].Type){
                Rid = KnownAuthoritiesAndDomains[i].WellKnownRids[j].Rid;
                fFound = TRUE;
                break;
            }
        }
        if (fFound) {
            break;
        }
    }

    // special case since the NtAuthority domain doesn't have any sub auth's
    if (!fFound && (WellKnownSidType == WinNtAuthoritySid)) {
        i = NT_AUTHORITY_INDEX;
        fFound = TRUE;
    }

    if (!fFound) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Determine how much space we need
    //
    switch (i) {
        case NULL_AUTHORITY_INDEX:
        case WORLD_AUTHORITY_INDEX:
        case LOCAL_AUTHORITY_INDEX:
        case CREATOR_OWNER_AUTHORITY_INDEX:
        case NT_AUTHORITY_INDEX:
            if (WellKnownSidType == WinNtAuthoritySid) {
                SubAuthCount = 0;
            } else {
                SubAuthCount = 1;
            }
            break;
        case BUILTIN_DOMAIN_INDEX:
            SubAuthCount = 2;
            break;
        case ACCOUNT_DOMAIN_INDEX:
            if (NULL == pDomainSid) {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            SubAuthCount = *RtlSubAuthorityCountSid(pDomainSid);
            if (SubAuthCount == SID_MAX_SUB_AUTHORITIES) {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            // Add for the RID
            SubAuthCount++;
            break;
        default:
            ASSERT(!"Invalid index");
    }

    //
    // Make sure we have enough space
    //
    SizeRequired = GetSidLengthRequired(SubAuthCount);
    if (*cbSid < SizeRequired) {
        *cbSid = SizeRequired;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    *cbSid = SizeRequired;

    if (IsBadWritePtr(pSid, SizeRequired)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Fill the sid in
    //
    switch (i) {
    
        case ACCOUNT_DOMAIN_INDEX:
            Status = RtlCopySid(*cbSid, pSid, pDomainSid);
            if (NT_SUCCESS(Status)) {
                (*RtlSubAuthorityCountSid(pSid))++;
            }
            break;

        case BUILTIN_DOMAIN_INDEX:
        case NULL_AUTHORITY_INDEX:
        case WORLD_AUTHORITY_INDEX:
        case LOCAL_AUTHORITY_INDEX:
        case CREATOR_OWNER_AUTHORITY_INDEX:
        case NT_AUTHORITY_INDEX:
    
            Status = RtlInitializeSid(pSid,
                                     &KnownAuthoritiesAndDomains[i].Authority,
                                     SubAuthCount);

            if (NT_SUCCESS(Status) && (i == BUILTIN_DOMAIN_INDEX)) {
                ASSERT(SubAuthCount > 1);
                *RtlSubAuthoritySid(pSid, 0) = SECURITY_BUILTIN_DOMAIN_RID;
            }
    
            break;
    default:
        ASSERT(!"Invalid index");

    }

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Append the Rid
    //
    if (SubAuthCount > 0) {
        *RtlSubAuthoritySid(pSid, SubAuthCount-1) = Rid;
    }

    return TRUE;

}

WINADVAPI
BOOL
WINAPI
GetWindowsAccountDomainSid(
    IN PSID pSid,
    IN OUT PSID pDomainSid OPTIONAL,
    OUT DWORD* cbDomainSid
    )
/*++

Routine Description:

    This routine returns the domain portion of pSid, if any if the SID is
    from an account domain.  If the SID is not from an account domain, then
    ERROR_NON_ACCOUNT_SID is returned.

Parameters:

    pSid -- the SID from which to extract the domain portion
    
    pDomainSid -- the domain portion of pSid; caller must allocate buffer
    
    cbDomainSid -- the number of bytes pointed to by pDomainSid; if 
                   insufficient, this value will be set to the number of
                   bytes required.

Return Values

    TRUE if a domain portion could be extracted and placed into pDomainSid
    
    FALSE otherwise; win32 errors are
    
        ERROR_INVALID_SID
        ERROR_INVALID_PARAMETER
        ERROR_NON_ACCOUNT_SID
        ERROR_INSUFFICIENT_BUFFER
        
 --*/
{
    NTSTATUS Status;
    ULONG SizeRequired;
    UCHAR SubAuthCount;
    UCHAR DomainSubAuthCount = 0;
    BOOL  fRecognized = FALSE;
    ULONG i;

    if (!RtlValidSid(pSid)) {
        SetLastError(ERROR_INVALID_SID);
        return FALSE;
    }

    if (cbDomainSid == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( IS_EQUAL_AUTHORITY(RtlIdentifierAuthoritySid(pSid), 
              &KnownAuthoritiesAndDomains[NT_AUTHORITY_INDEX].Authority)) {

        SubAuthCount = *RtlSubAuthorityCountSid(pSid);
        if (SubAuthCount > SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT) {
            ULONG FirstSubAuth;
            FirstSubAuth = *RtlSubAuthoritySid(pSid, 0);
            if ( (SECURITY_NT_NON_UNIQUE == FirstSubAuth) ) {
                // This is an NT Account Domain
                DomainSubAuthCount = SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT+1;
                fRecognized = TRUE;
            }
        }
    }

    if (!fRecognized) {
        SetLastError(ERROR_NON_ACCOUNT_SID);
        return FALSE;
    }

    SizeRequired = RtlLengthRequiredSid(DomainSubAuthCount);
    if (*cbDomainSid < SizeRequired) {
        *cbDomainSid = SizeRequired;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    *cbDomainSid = SizeRequired;

    if (IsBadWritePtr(pDomainSid, SizeRequired)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Status = RtlInitializeSid(pDomainSid,
                              RtlIdentifierAuthoritySid(pSid),
                              DomainSubAuthCount);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    for (i = 0; i < DomainSubAuthCount; i++) {
        *RtlSubAuthoritySid(pDomainSid, i) = *RtlSubAuthoritySid(pSid,i);
    }

    return TRUE;

}

WINADVAPI
BOOL
WINAPI
EqualDomainSid(
    IN PSID pSid1,
    IN PSID pSid2,
    OUT BOOL *pfEqual
    )
/*++

Routine Description:
    
    This routine determines if either 
    
    1) Both sids are the same domain SID
    
    2) One SID is from the other SID's domain
    
    The "domains" recognized are BUILTIN and NT account domains
    
Parameters:

    pSid1 -- the first SID
    
    pSid2 -- the second SID
    
    pfEqual -- on success, set to TRUE if the domain portions are equal

Return Values

    TRUE if the SID's are recognized (are either from an account domain or
    the BUILTIN domain).
    
    FALSE otherwise                           
    
    Win32 Errors:
    
    ERROR_NON_DOMAIN_SID
    ERROR_REVISION_MISMATCH
    ERROR_INVALID_PARAMETER
    ERROR_INVALID_SID
    

 --*/
{
    ULONG i;
    SID *ISid1 = pSid1;
    SID *ISid2 = pSid2;

    BYTE Buffer1[SECURITY_MAX_SID_SIZE];
    PSID BuiltinDomainSid = (PSID) Buffer1;

    BYTE Buffer2[SECURITY_MAX_SID_SIZE];
    PSID pDomainSid1 = (PSID) Buffer2;

    BYTE Buffer3[SECURITY_MAX_SID_SIZE];
    PSID pDomainSid2 = (PSID) Buffer3;

    ULONG Size;

    if ( !RtlValidSid(pSid1) || !RtlValidSid(pSid2) ) {
        SetLastError(ERROR_INVALID_SID);
        return FALSE;
    }

    if (NULL == pfEqual) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( ISid1->Revision != ISid2->Revision ) {
        SetLastError(ERROR_REVISION_MISMATCH);
        return FALSE;
    }

    // Create the builtin SID
    Size = sizeof(Buffer1);
    if (!CreateWellKnownSid(WinBuiltinDomainSid, NULL, BuiltinDomainSid, &Size)) {
        // LastError is set
        return FALSE;
    }

    // Extract the first SID's domain portion if any
    Size = sizeof(Buffer2);
    if (!GetWindowsAccountDomainSid(pSid1, pDomainSid1, &Size)) {
        // The SID is not an account domain SID -- try for builtin
        pDomainSid1 = NULL;
        if ( (IS_EQUAL_AUTHORITY(RtlIdentifierAuthoritySid(pSid1), &KnownAuthoritiesAndDomains[NT_AUTHORITY_INDEX].Authority))
          && (*RtlSubAuthorityCountSid(pSid1) > 0)
          && (*RtlSubAuthoritySid(pSid1, 0) == SECURITY_BUILTIN_DOMAIN_RID)) {
                pDomainSid1 = BuiltinDomainSid;
        }
    }

    if (NULL == pDomainSid1) {
        SetLastError(ERROR_NON_DOMAIN_SID);
        return FALSE;
    }

    Size = sizeof(Buffer3);
    if (!GetWindowsAccountDomainSid(pSid2, pDomainSid2, &Size)) {
        // The SID is not an account domain SID -- try for builtin
        pDomainSid2 = NULL;
        if ( (IS_EQUAL_AUTHORITY(RtlIdentifierAuthoritySid(pSid2), &KnownAuthoritiesAndDomains[NT_AUTHORITY_INDEX].Authority))
          && (*RtlSubAuthorityCountSid(pSid2) > 0)
          && (*RtlSubAuthoritySid(pSid2, 0) == SECURITY_BUILTIN_DOMAIN_RID)) {
                pDomainSid2 = BuiltinDomainSid;
        }
    }

    if (NULL == pDomainSid2) {
        SetLastError(ERROR_NON_DOMAIN_SID);
        return FALSE;
    }

    *pfEqual = EqualSid(pDomainSid1, pDomainSid2);

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\termutil.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "tsappcmp.h"
#include <regapi.h>

PTERMSRVCREATEREGENTRY gpfnTermsrvCreateRegEntry;

PTERMSRVOPENREGENTRY gpfnTermsrvOpenRegEntry;

PTERMSRVSETVALUEKEY gpfnTermsrvSetValueKey;

PTERMSRVDELETEKEY gpfnTermsrvDeleteKey;

PTERMSRVDELETEVALUE gpfnTermsrvDeleteValue;

PTERMSRVRESTOREKEY gpfnTermsrvRestoreKey;

PTERMSRVSETKEYSECURITY gpfnTermsrvSetKeySecurity;

PTERMSRVOPENUSERCLASSES gpfnTermsrvOpenUserClasses;

PTERMSRVGETPRESETVALUE gpfnTermsrvGetPreSetValue;

DWORD gdwRegistryExtensionFlags=0;

BOOL IsTerminalServerCompatible(VOID)
{

PIMAGE_NT_HEADERS NtHeader = RtlImageNtHeader( NtCurrentPeb()->ImageBaseAddress );

    if ((NtHeader) && (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL IsSystemLUID(VOID)
{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ sizeof( TOKEN_STATISTICS ) ];
    ULONG       ReturnLength;
    LUID        CurrentLUID = { 0, 0 };
    LUID        SystemLUID = SYSTEM_LUID;
    NTSTATUS Status;

    if ( CurrentLUID.LowPart == 0 && CurrentLUID.HighPart == 0 ) {

        Status = NtOpenProcessToken( NtCurrentProcess(),
                                     TOKEN_QUERY,
                                     &TokenHandle );
        if ( !NT_SUCCESS( Status ) )
            return(TRUE);

        NtQueryInformationToken( TokenHandle, TokenStatistics, &TokenInformation,
                                 sizeof(TokenInformation), &ReturnLength );
        NtClose( TokenHandle );

        RtlCopyLuid(&CurrentLUID,
                    &(((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId));
    }

    if (RtlEqualLuid(&CurrentLUID, &SystemLUID)) {
        return(TRUE);
    } else {
        return(FALSE );
    }
}

/**

Params: 
    [out]   Boolean        *RelaxedSecurityMode
                            If TRUE, then we are running app server in relaxed security mode
                            which means that the TsUserSID will be present in user's token, allowing
                            user more access to various reg and file system components.
                            
Retrun:                            
    TRUE    means app server is enabled, and it is in app-compat mode ( the default)
    FALSE   means this is not an app server

**/
BOOL IsTSAppCompatEnabled( BOOLEAN  *RelaxedSecurityMode )
{

   NTSTATUS NtStatus;
   OBJECT_ATTRIBUTES ObjectAttributes;
   UNICODE_STRING UniString;
   HKEY   hKey = 0;
   ULONG  ul, ulcbuf;
   PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;

   BOOL retval = TRUE;


   RtlInitUnicodeString(&UniString,REG_NTAPI_CONTROL_TSERVER);



   // Determine the value info buffer size
   ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
            sizeof(ULONG);

   pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                 0,
                                 ulcbuf);

   // Did everything initialize OK?
   if (UniString.Buffer && pKeyValInfo) {

       InitializeObjectAttributes(&ObjectAttributes,
                                  &UniString,
                                  OBJ_CASE_INSENSITIVE,
                                  NULL,
                                  NULL
                                 );

       NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

       if (NT_SUCCESS(NtStatus)) {

           RtlInitUnicodeString(&UniString,
                               L"TSAppCompat");
           NtStatus = NtQueryValueKey(hKey,
                                      &UniString,
                                      KeyValuePartialInformation,
                                      pKeyValInfo,
                                      ulcbuf,
                                      &ul);

           if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {

               if ((*(PULONG)pKeyValInfo->Data) == 0) {
                  retval = FALSE;
               }
           }

           RtlInitUnicodeString(&UniString,
                               L"TSUserEnabled");

           NtStatus = NtQueryValueKey(hKey,
                                      &UniString,
                                      KeyValuePartialInformation,
                                      pKeyValInfo,
                                      ulcbuf,
                                      &ul);

           if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type) ) 
           {
               *RelaxedSecurityMode = (BOOLEAN ) (*(PULONG)pKeyValInfo->Data);
           }
           else     // in case of any problems, assume standard security mode
           {
               *RelaxedSecurityMode = FALSE;
           }

           NtClose(hKey);
       }
   }

   // Free up the buffers we allocated
   // Need to zero out the buffers, because some apps (MS Internet Assistant)
   // won't install if the heap is not zero filled.
   if (pKeyValInfo) {
       memset(pKeyValInfo, 0, ulcbuf);
       RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
   }

   return(retval);

}


ULONG GetCompatFlags()
{
    ULONG    ulAppFlags = 0;
    PRTL_USER_PROCESS_PARAMETERS pUserParam;
    PWCHAR  pwch, pwchext;
    WCHAR   pwcAppName[MAX_PATH+1];
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY   hKey = 0;
    ULONG  ul, ulcbuf;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;
    LPWSTR UniBuff = NULL;

    ULONG dwCompatFlags = 0;
    UniString.Buffer = NULL;



    // Get the path of the executable name
    pUserParam = NtCurrentPeb()->ProcessParameters;

    // Get the executable name, if there's no \ just use the name as it is
    pwch = wcsrchr(pUserParam->ImagePathName.Buffer, L'\\');
    if (pwch) {
        pwch++;
    } else {
        pwch = pUserParam->ImagePathName.Buffer;
    }
    wcscpy(pwcAppName, pwch);
    pwch = pwcAppName;

    // Remove the extension
    if (pwchext = wcsrchr(pwch, L'.')) {
        *pwchext = '\0';
    }


    UniString.Buffer = NULL;


    ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(pwch) + 1)*sizeof(WCHAR);

    UniBuff = RtlAllocateHeap(RtlProcessHeap(),
                              0,
                              ul);

    if (UniBuff) {
        wcscpy(UniBuff, TERMSRV_COMPAT_APP);
        wcscat(UniBuff, pwch);

        RtlInitUnicodeString(&UniString, UniBuff);
    }

    // Determine the value info buffer size
    ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
             sizeof(ULONG);

    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ulcbuf);

    // Did everything initialize OK?
    if (UniString.Buffer && pKeyValInfo) {

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            RtlInitUnicodeString(&UniString,
                                COMPAT_FLAGS);
            NtStatus = NtQueryValueKey(hKey,
                                       &UniString,
                                       KeyValuePartialInformation,
                                       pKeyValInfo,
                                       ulcbuf,
                                       &ul);

            if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {


                dwCompatFlags = *(PULONG)pKeyValInfo->Data;

            }

            NtClose(hKey);
        }
    }

    // Free up the buffers we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValInfo) {
        memset(pKeyValInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    }

    return(dwCompatFlags);

}

/**

Return code :
    TRUE  means app compat is enabled for this app
    FALSE means app compat is not enabled for this app

**/
BOOLEAN AdvApi_InitializeTermsrvFpns( BOOLEAN   *pIsInRelaxedSecurityMode , DWORD *pdwCompatFlags )
{

    HANDLE          dllHandle;
    ULONG           dwCompatFlags;
    BOOLEAN         rc=FALSE;


    if (IsTerminalServerCompatible() || (!IsTSAppCompatEnabled( pIsInRelaxedSecurityMode ))) {
        return rc;
    }

    *pdwCompatFlags = dwCompatFlags = GetCompatFlags();


    //Don't load app compatibility dll for system components

    if (IsSystemLUID()) {

        if ( (dwCompatFlags & (TERMSRV_COMPAT_SYSREGMAP | TERMSRV_COMPAT_WIN32))
                     != (TERMSRV_COMPAT_SYSREGMAP | TERMSRV_COMPAT_WIN32) ) {

            //
            // Process is running as SYSTEM and we don't have an app
            // compatibility flag telling us to do the regmap stuff.
            //

            return rc;

        }

    } else if ( (dwCompatFlags & (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32))
                     == (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32) ) {
        //
        // We don't want to do registry mapping for this user process
        //
        return rc;

    }

    //
    // Load Terminal Server application compatibility dll
    //
    dllHandle = LoadLibrary("tsappcmp.dll");

    if (dllHandle) {

        gpfnTermsrvCreateRegEntry =
            (PTERMSRVCREATEREGENTRY)GetProcAddress(dllHandle,"TermsrvCreateRegEntry");

        gpfnTermsrvOpenRegEntry =
            (PTERMSRVOPENREGENTRY)GetProcAddress(dllHandle,"TermsrvOpenRegEntry");

        gpfnTermsrvSetValueKey =
            (PTERMSRVSETVALUEKEY)GetProcAddress(dllHandle,"TermsrvSetValueKey");

        gpfnTermsrvDeleteKey =
            (PTERMSRVDELETEKEY)GetProcAddress(dllHandle,"TermsrvDeleteKey");

        gpfnTermsrvDeleteValue =
            (PTERMSRVDELETEVALUE)GetProcAddress(dllHandle,"TermsrvDeleteValue");

         gpfnTermsrvRestoreKey =
            (PTERMSRVRESTOREKEY)GetProcAddress(dllHandle,"TermsrvRestoreKey");

        gpfnTermsrvSetKeySecurity =
            (PTERMSRVSETKEYSECURITY)GetProcAddress(dllHandle,"TermsrvSetKeySecurity");

        gpfnTermsrvOpenUserClasses =
            (PTERMSRVOPENUSERCLASSES)GetProcAddress(dllHandle,"TermsrvOpenUserClasses");

        gpfnTermsrvGetPreSetValue =
            (PTERMSRVGETPRESETVALUE)GetProcAddress(dllHandle,"TermsrvGetPreSetValue");

        rc = TRUE;
    }

    return rc;
}


void
GetRegistryExtensionFlags( DWORD dwCompatFlags )
/*++
GetRegistryExtensionFlags

Routine Description:

    Reads DWORD value of 
    Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion\Terminal Server\RegistryExtensionFlags

Arguments:

    none

Return Value:

    none

--*/
{

    DWORD dwResult=0;
    NTSTATUS Status; 
    HANDLE hKey;
    UNICODE_STRING KeyName;
    PCWSTR wszKeyName=TERMSRV_BASE;
    OBJECT_ATTRIBUTES ObjAttr;
    
    RtlInitUnicodeString(&KeyName,wszKeyName );
    InitializeObjectAttributes(&ObjAttr,&KeyName,OBJ_CASE_INSENSITIVE,NULL,NULL);
    Status = NtOpenKey(&hKey,KEY_QUERY_VALUE,&ObjAttr);

    if(NT_SUCCESS(Status)){

        
        UNICODE_STRING ValueName;
        PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;
        ULONG ulSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(DWORD);
        
        pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(), 0, ulSize);
        
        if(pKeyValInfo){

            PCWSTR wszValueName=L"RegistryExtensionFlags";

            RtlInitUnicodeString(&ValueName,wszValueName );

            Status=NtQueryValueKey(hKey,&ValueName,KeyValuePartialInformation,
                (PVOID)pKeyValInfo,ulSize,&ulSize);

            if(NT_SUCCESS(Status)){
                gdwRegistryExtensionFlags=*((LPDWORD)(pKeyValInfo->Data));
            }

            RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );

            // the global advapi extension flags might be turned off for this app, so check.
            if ( dwCompatFlags & TERMSRV_COMPAT_NO_PER_USER_CLASSES_REDIRECTION )
            {
                gdwRegistryExtensionFlags &= ~ TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION;
            }

            if ( dwCompatFlags & TERMSRV_COMPAT_NO_ENABLE_ACCESS_FLAG_MODIFICATION  )
            {
                gdwRegistryExtensionFlags &= ~TERMSRV_ENABLE_ACCESS_FLAG_MODIFICATION;
            }
        }

        NtClose(hKey);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\win31io.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    win31io.h

Abstract:

    This header file contains the Win 3.1 Group/REG.DAT data
    structure definitions, as well as the 32 bit group definitions.
    Why these aren't in the shell32.dll somewhere I don't know

Author:

    Steve Wood (stevewo) 22-Feb-1993

Revision History:

--*/

#ifndef _WIN31IO_
#define _WIN31IO_

#include "win31evt.h"

typedef struct GROUP_DEF {
    union {
        DWORD   dwMagic;    /* magical bytes 'PMCC' */
        DWORD   dwCurrentSize;  /* During conversion only */
    };
    WORD    wCheckSum;      /* adjust this for zero sum of file */
    WORD    cbGroup;        /* length of group segment (does NOT include tags) */
    RECT    rcNormal;       /* rectangle of normal window */
    POINT   ptMin;          /* point of icon */
    WORD    nCmdShow;       /* min, max, or normal state */
    WORD    pName;          /* name of group */
                            /* these four change interpretation */
    WORD    cxIcon;         /* width of icons */
    WORD    cyIcon;         /* hieght of icons */
    WORD    wIconFormat;    /* planes and BPP in icons */
    WORD    wReserved;      /* This word is no longer used. */
                            /* Used internally to hold total size of group, including tags */
    WORD    cItems;         /* number of items in group */
    WORD    rgiItems[1];    /* array of ITEMDEF offsets */
} GROUP_DEF, *PGROUP_DEF;

#define NSLOTS 16           /* initial number of items entries */

typedef struct ITEM_DEF {
    POINT   pt;             /* location of item icon in group */
    WORD    idIcon;         /* id of item icon */
    WORD    wIconVer;       /* icon version */
    WORD    cbIconRes;      /* size of icon resource */
    WORD    indexIcon;      /* index of item icon */
    WORD    dummy2;         /* - not used anymore */
    WORD    pIconRes;       /* offset of icon resource */
    WORD    dummy3;         /* - not used anymore */
    WORD    pName;          /* offset of name string */
    WORD    pCommand;       /* offset of command string */
    WORD    pIconPath;      /* offset of icon path */
} ITEM_DEF, *PITEM_DEF;


/* the pointers in the above structures are short pointers relative to the
 * beginning of the segments.  This macro converts the short pointer into
 * a long pointer including the proper segment/selector value.        It assumes
 * that its argument is an lvalue somewhere in a group segment, for example,
 * PTR(lpgd->pName) returns a pointer to the group name, but k=lpgd->pName;
 * PTR(k) is obviously wrong as it will use either SS or DS for its segment,
 * depending on the storage class of k.
 */
#define PTR( base, offset ) (LPSTR)((PBYTE)base + offset)

/* this macro is used to retrieve the i-th item in the group segment.  Note
 * that this pointer will NOT be NULL for an unused slot.
 */
#define ITEM( lpgd, i ) ((PITEM_DEF)PTR( lpgd, lpgd->rgiItems[i] ))

#define VER31           0x030A
#define VER30           0x0300
#define VER20           0x0201

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Tag Stuff                                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

typedef struct _TAG_DEF {
    WORD wID;                   // tag identifier
    WORD dummy1;                // need this for alignment!
    int wItem;                  // (unde the covers 32 bit point!)item the tag belongs to
    WORD cb;                    // size of record, including id and count
    WORD dummy2;                // need this for alignment!
    BYTE rgb[1];
} TAG_DEF, *PTAG_DEF;

#define GROUP_MAGIC 0x43434D50L  /* 'PMCC' */
#define PMTAG_MAGIC GROUP_MAGIC

    /* range 8000 - 80FF > global
     * range 8100 - 81FF > per item
     * all others reserved
     */

#define ID_MAINTAIN             0x8000
    /* bit used to indicate a tag that should be kept even if the writer
     * doesn't recognize it.
     */

#define ID_MAGIC                0x8000
    /* data: the string 'TAGS'
     */

#define ID_WRITERVERSION        0x8001
    /* data: string in the form [9]9.99[Z].99
     */

#define ID_APPLICATIONDIR       0x8101
    /* data: ASCIZ string of directory where application may be
     * located.
     * this is defined as application dir rather than default dir
     * since the default dir is explicit in the 3.0 command line and
     * must stay there.  The true "new information" is the application
     * directory.  If not present, search the path.
     */

#define ID_HOTKEY               0x8102
    /* data: WORD hotkey index
     */

#define ID_MINIMIZE             0x8103
    /* data none
     */

#define ID_LASTTAG              0xFFFF
    /* the last tag in the file
     */

    /*
     * Maximium number of items allowed in a group
     */
#define CITEMSMAX   50


    /*
     * Maximium number of groups allowed in PROGMAN
     */

#define CGROUPSMAX  40

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/

//
// This is the structure of the .grp files in Windows3.1
//

/* .GRP File format structures -
 */
typedef struct _GROUP_DEF16 {
    DWORD         dwMagic;      /* magical bytes 'PMCC' */
    WORD          wCheckSum;    /* adjust this for zero sum of file */
    WORD          cbGroup;      /* length of group segment (does NOT include tags) */
    WORD          nCmdShow;     /* min, max, or normal state */
    SMALL_RECT    rcNormal;     /* rectangle of normal window */
    POINTS        ptMin;        /* point of icon */
    WORD          pName;        /* name of group */
                                /* these four change interpretation */
    WORD          cxIcon;       /* width of icons */
    WORD          cyIcon;       /* hieght of icons */
    WORD          wIconFormat;  /* planes and BPP in icons */
    WORD          wReserved;    /* This word is no longer used. */
                                /* Used internally to hold total size of group, including tags */

    WORD          cItems;       /* number of items in group */
    WORD          rgiItems[1];  /* array of ITEMDEF offsets */
} GROUP_DEF16, *PGROUP_DEF16;

/* this macro is used to retrieve the i-th item in the group segment.  Note
 * that this pointer will NOT be NULL for an unused slot.
 */
#define ITEM16( lpgd16, i ) ((PITEM_DEF16)PTR( lpgd16, lpgd16->rgiItems[i] ))

//
// These structures are not needed for the conversion but it is useful to
// understand what is going on.
//
typedef struct _ITEM_DEF16 {
    POINTS    pt;               /* location of item icon in group */
    WORD          iIcon;        /* index of item icon */
    WORD          cbHeader;     /* size of icon header */
    WORD          cbANDPlane;   /* size of and part of icon */
    WORD          cbXORPlane;   /* size of xor part of icon */
    WORD          pHeader;      /* file offset of icon header */
    WORD          pANDPlane;    /* file offset of AND plane */
    WORD          pXORPlane;    /* file offset of XOR plane */
    WORD          pName;        /* file offset of name string */
    WORD          pCommand;     /* file offset of command string */
    WORD          pIconPath;    /* file offset of icon path */
} ITEM_DEF16, *PITEM_DEF16;


typedef struct _CURSORSHAPE_16 {
    WORD xHotSpot;
    WORD yHotSpot;
    WORD cx;
    WORD cy;
    WORD cbWidth;  /* Bytes per row, accounting for word alignment. */
    BYTE Planes;
    BYTE BitsPixel;
} CURSORSHAPE_16, *PCURSORSHAPE_16;



typedef struct _TAG_DEF16 {
    WORD wID;			// tag identifier
    WORD wItem; 		// item the tag belongs to
    WORD cb;			// size of record, including id and count
    BYTE rgb[1];
} TAG_DEF16, *PTAG_DEF16;

typedef struct _ICON_HEADER16 {
    WORD xHotSpot;
    WORD yHotSpot;
    WORD cx;
    WORD cy;
    WORD cbWidth;  /* Bytes per row, accounting for word alignment. */
    BYTE Planes;
    BYTE BitsPixel;
} ICON_HEADER16, *PICON_HEADER16;


#pragma pack(2)

typedef struct _REG_KEY16 {     // key nodes
    WORD iNext;                 // next sibling key
    WORD iChild;                // first child key
    WORD iKey;                  // string defining key
    WORD iValue;                // string defining value of key-tuple
} REG_KEY16, *PREG_KEY16;

typedef struct _REG_STRING16 {
    WORD iNext;                 // next string in chain
    WORD cRef;                  // reference count
    WORD cb;                    // length of string
    WORD irgb;                  // offset in string segment
} REG_STRING16, *PREG_STRING16;

typedef union _REG_NODE16 {     // a node may be...
    REG_KEY16 key;              //      a key
    REG_STRING16 str;           //      a string
} REG_NODE16, *PREG_NODE16;

typedef struct _REG_HEADER16 {
    DWORD dwMagic;              // magic number
    DWORD dwVersion;            // version number
    DWORD dwHdrSize;            // size of header
    DWORD dwNodeTable;          // offset of node table
    DWORD dwNTSize;             // size of node table
    DWORD dwStringValue;        // offset of string values
    DWORD dwSVSize;             // size of string values
    WORD nHash;                 // number of initial string table entries
    WORD iFirstFree;            // first free node
} REG_HEADER16, *PREG_HEADER16;

#define MAGIC_NUMBER 0x43434853L        // 'SHCC'
#define VERSION_NUMBER 0x30312E33L      // '3.10'

#pragma pack()

//
// Routines defined in group32.c
//

ULONG
QueryNumberOfPersonalGroupNames(
    HANDLE CurrentUser,
    PHANDLE GroupNamesKey,
    PHANDLE SettingsKey
    );

BOOL
NewPersonalGroupName(
    HANDLE GroupNamesKey,
    PWSTR GroupName,
    ULONG GroupNumber
    );

BOOL
DoesExistGroup(
    HANDLE GroupsKey,
    PWSTR GroupName
    );

PGROUP_DEF
LoadGroup(
    HANDLE GroupsKey,
    PWSTR GroupFileName
    );

BOOL
UnloadGroup(
    PGROUP_DEF Group
    );


BOOL
ExtendGroup(
    PGROUP_DEF Group,
    BOOL AppendToGroup,
    DWORD cb
    );

WORD
AddDataToGroup(
    PGROUP_DEF Group,
    PBYTE Data,
    DWORD cb
    );

BOOL
AddTagToGroup(
    PGROUP_DEF Group,
    WORD wID,
    WORD wItem,
    WORD cb,
    PBYTE rgb
    );

PGROUP_DEF
CreateGroupFromGroup16(
    LPSTR GroupName,
    PGROUP_DEF16 Group16
    );

BOOL
SaveGroup(
    HANDLE GroupsKey,
    PWSTR GroupName,
    PGROUP_DEF Group
    );

BOOL
DeleteGroup(
    HANDLE GroupsKey,
    PWSTR GroupName
    );

#if DBG
BOOL
DumpGroup(
    PWSTR GroupFileName,
    PGROUP_DEF Group
    );
#endif


//
// Routines defined in group16.c
//

PGROUP_DEF16
LoadGroup16(
    PWSTR GroupFileName
    );

BOOL
UnloadGroup16(
    PGROUP_DEF16 Group
    );

#if DBG
BOOL
DumpGroup16(
    PWSTR GroupFileName,
    PGROUP_DEF16 Group
    );
#endif



//
// Routines defined in regdat16.c
//

PREG_HEADER16
LoadRegistry16(
    PWSTR RegistryFileName
    );

BOOL
UnloadRegistry16(
    PREG_HEADER16 Registry
    );

BOOL
CreateRegistryClassesFromRegistry16(
    HANDLE SoftwareRoot,
    PREG_HEADER16 Registry
    );

#if DBG
BOOL
DumpRegistry16(
    PREG_HEADER16 Registry
    );
#endif


#endif // _WIN31IO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\username.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    USERNAME.C

Abstract:

    This module contains the GetUserName API.

Author:

    Dave Snipp (DaveSn)    27-May-1992


Revision History:


--*/

#include <advapi.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <secext.h>
#include <stdlib.h>
#include <ntlsa.h>


//
// UNICODE APIs
//


BOOL
WINAPI
GetUserNameW (
    LPWSTR pBuffer,
    LPDWORD pcbBuffer
    )

/*++

Routine Description:

  This returns the name of the user currently being impersonated.

Arguments:

    pBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the user name.

    pcbBuffer - Specifies the size (in characters) of the buffer.
                The length of the string is returned in pcbBuffer.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{
    return GetUserNameExW(
                NameSamCompatible | 0x00010000,
                pBuffer,
                pcbBuffer );
}



//
// ANSI APIs
//

BOOL
WINAPI
GetUserNameA (
    LPSTR pBuffer,
    LPDWORD pcbBuffer
    )

/*++

Routine Description:

  This returns the name of the user currently being impersonated.

Arguments:

    pBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the user name.

    pcbBuffer - Specifies the size (in characters) of the buffer.
                The length of the string is returned in pcbBuffer.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{
    return GetUserNameExA(
                NameSamCompatible | 0x00010000,
                pBuffer,
                pcbBuffer );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\win31io.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    win31io.c

Abstract:

    This file contains Win 3.1 Inter-Operability functions.

Author:

    Steve Wood (stevewo) 21-Feb-1993

Revision History:

--*/

#include "advapi.h"
#include <stdio.h>

#include <winbasep.h>
#include "win31io.h"

#define EVENTLOG_SOURCE "Windows 3.1 Migration"

BOOL
WaitForEventLogToStart( VOID );

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

typedef struct _WIN31IO_STATE {
    HANDLE EventLog;
    HANDLE SoftwareRoot;
    HANDLE UserRoot;
    HANDLE Win31IOKey;
    BOOL QueryOnly;
    PWSTR WindowsPath;
    PWSTR FileNamePart;
    PWSTR WorkBuffer;
    ULONG cchWorkBuffer;
    PWIN31IO_STATUS_CALLBACK StatusCallback;
    PVOID CallbackParameter;
    WCHAR szWindowsDirectory[ MAX_PATH ];
    PSID UserSid;
    UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    WCHAR QueryBuffer[ 64 ];
} WIN31IO_STATE, *PWIN31IO_STATE;


HANDLE
OpenCreateKey(
    IN HANDLE Root,
    IN PWSTR Path,
    IN BOOL WriteAccess
    );

BOOL
SnapShotWin31IniFilesToRegistry(
    IN OUT PWIN31IO_STATE State
    );

BOOL
SnapShotWin31GroupsToRegistry(
    IN OUT PWIN31IO_STATE State
    );

BOOL
SnapShotWin31RegDatToRegistry(
    IN OUT PWIN31IO_STATE State
    );

BOOL
InitializeWin31State(
    IN WIN31IO_EVENT EventType,
    OUT PWIN31IO_STATE State
    );


VOID
TerminateWin31State(
    IN WIN31IO_EVENT EventType,
    IN OUT PWIN31IO_STATE State
    );

BOOL
InitializeWin31State(
    IN WIN31IO_EVENT EventType,
    OUT PWIN31IO_STATE State
    )
{
    NTSTATUS Status;
    ULONG cch;
    HANDLE TokenHandle;
    ULONG ReturnLength;

    memset( State, 0, sizeof( *State ) );
    cch = GetWindowsDirectoryW( State->szWindowsDirectory,
                                sizeof( State->szWindowsDirectory ) / sizeof (WCHAR)
                              );
    State->WindowsPath = State->szWindowsDirectory;
    State->FileNamePart = State->WindowsPath + cch;
    *State->FileNamePart++ = OBJ_NAME_PATH_SEPARATOR;

    if (EventType == Win31SystemStartEvent) {
        State->SoftwareRoot = OpenCreateKey( NULL,
                                             L"\\Registry\\Machine\\Software",
                                             FALSE
                                           );
        if (State->SoftwareRoot == NULL) {
            return FALSE;
            }
        }
    else {
        Status = RtlOpenCurrentUser( GENERIC_READ, &State->UserRoot );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            return FALSE;
            }

        if (OpenThreadToken( GetCurrentThread(),
                             TOKEN_READ,
                             TRUE,
                             &TokenHandle
                           ) ||
            OpenProcessToken( GetCurrentProcess(),
                              TOKEN_READ,
                              &TokenHandle
                            )
           ) {
            if (GetTokenInformation( TokenHandle,
                                     TokenUser,
                                     &State->TokenInformation,
                                     sizeof( State->TokenInformation ),
                                     &ReturnLength
                                   )
               ) {
                PTOKEN_USER UserToken = (PTOKEN_USER)&State->TokenInformation;

                State->UserSid = UserToken->User.Sid;
                }

            CloseHandle( TokenHandle );
            }
        }

    State->Win31IOKey = OpenCreateKey( EventType == Win31SystemStartEvent ?
                                            State->SoftwareRoot : State->UserRoot,
                                       L"Windows 3.1 Migration Status",
                                       TRUE
                                     );
    if (State->Win31IOKey == NULL) {
        if (State->SoftwareRoot != NULL) {
            NtClose( State->SoftwareRoot );
            }

        if (State->UserRoot != NULL) {
            NtClose( State->UserRoot );
            }

        if (State->EventLog != NULL) {
            DeregisterEventSource( State->EventLog );
            }

        return FALSE;
        }
    else {
        return TRUE;
        }

    return TRUE;
}


VOID
TerminateWin31State(
    IN WIN31IO_EVENT EventType,
    IN OUT PWIN31IO_STATE State
    )
{
    if (State->Win31IOKey != NULL) {
        NtClose( State->Win31IOKey );
        }

    if (State->SoftwareRoot != NULL) {
        NtClose( State->SoftwareRoot );
        }

    if (State->UserRoot != NULL) {
        NtClose( State->UserRoot );
        }

    if (State->EventLog != NULL && State->EventLog != INVALID_HANDLE_VALUE) {
        DeregisterEventSource( State->EventLog );
        }

    return;
}

#define MAX_EVENT_STRINGS 8

VOID
ReportWin31IOEvent(
    IN PWIN31IO_STATE State,
    IN WORD EventType,
    IN DWORD EventId,
    IN DWORD SizeOfRawData,
    IN PVOID RawData,
    IN DWORD NumberOfStrings,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PWSTR Strings[ MAX_EVENT_STRINGS ];

    va_start( arglist, NumberOfStrings );

    if (NumberOfStrings > MAX_EVENT_STRINGS) {
        NumberOfStrings = MAX_EVENT_STRINGS;
        }

    for (i=0; i<NumberOfStrings; i++) {
        Strings[ i ] = va_arg( arglist, PWSTR );
        }

    if (State->EventLog == NULL) {
        State->EventLog = RegisterEventSource( NULL, EVENTLOG_SOURCE );
        if (State->EventLog == NULL) {
            if (WaitForEventLogToStart()) {
                State->EventLog = RegisterEventSource( NULL, EVENTLOG_SOURCE );
                }

            if (State->EventLog == NULL) {
                KdPrint(( "WIN31IO: RegisterEventSource( %s ) failed - %u\n", EVENTLOG_SOURCE, GetLastError() ));
                State->EventLog = INVALID_HANDLE_VALUE;
                return;
                }
            }
        }

    if (State->EventLog != INVALID_HANDLE_VALUE) {
        if (!ReportEventW( State->EventLog,
                           EventType,
                           0,            // event category
                           EventId,
                           State->UserSid,
                           (WORD)NumberOfStrings,
                           SizeOfRawData,
                           Strings,
                           RawData
                         )
           ) {
            KdPrint(( "WIN31IO: ReportEvent( %u ) failed - %u\n", EventId, GetLastError() ));
            }
        }
}

int
Win31IOExceptionHandler(
    IN DWORD ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionInfo,
    IN OUT PWIN31IO_STATE State
    );

int
Win31IOExceptionHandler(
    IN DWORD ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionInfo,
    IN OUT PWIN31IO_STATE State
    )
{
    KdPrint(( "WIN31IO: Unexpected exception %08x at %08x referencing %08x\n",
              ExceptionInfo->ExceptionRecord->ExceptionCode,
              ExceptionInfo->ExceptionRecord->ExceptionAddress,
              ExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ]
           ));

    //
    // Unexpected exception.  Log the event with the exception record
    // so we can figure it out later.
    //

    ReportWin31IOEvent( State,
                        EVENTLOG_ERROR_TYPE,
                        WIN31IO_EVENT_EXCEPTION,
                        sizeof( *(ExceptionInfo->ExceptionRecord) ),
                        ExceptionInfo->ExceptionRecord,
                        0
                      );

    return EXCEPTION_EXECUTE_HANDLER;
}


DWORD
WINAPI
QueryWindows31FilesMigration(
    IN WIN31IO_EVENT EventType
    )
{
    DWORD Flags;
    WIN31IO_STATE State;

    if (EventType == Win31LogoffEvent) {
        return 0;
        }

    if (!InitializeWin31State( EventType, &State )) {
        return 0;
        }

    State.QueryOnly = TRUE;
    State.WorkBuffer = State.QueryBuffer;
    State.cchWorkBuffer = sizeof( State.QueryBuffer ) / sizeof( WCHAR );
    Flags = 0;

    try {
        try {
            if (EventType == Win31SystemStartEvent) {
                if (SnapShotWin31IniFilesToRegistry( &State )) {
                    Flags |= WIN31_MIGRATE_INIFILES;
                    }

                if (SnapShotWin31RegDatToRegistry( &State )) {
                    Flags |= WIN31_MIGRATE_REGDAT;
                    }
                }
            else {
                if (SnapShotWin31IniFilesToRegistry( &State )) {
                    Flags |= WIN31_MIGRATE_INIFILES;
                    }

                if (SnapShotWin31GroupsToRegistry( &State )) {
                    Flags |= WIN31_MIGRATE_GROUPS;
                    }
                }
            }
    except( Win31IOExceptionHandler( GetExceptionCode(),
                                     GetExceptionInformation(),
                                     &State
                                   )
          ) {
            BaseSetLastNTError( GetExceptionCode() );
            }
        }
    finally {
        TerminateWin31State( EventType, &State );
        }

    return Flags;
}


BOOL
WINAPI
SynchronizeWindows31FilesAndWindowsNTRegistry(
    IN WIN31IO_EVENT EventType,
    IN DWORD Flags,
    IN PWIN31IO_STATUS_CALLBACK StatusCallback,
    IN PVOID CallbackParameter
    )
{
    BOOL Result;
    VIRTUAL_BUFFER Buffer;
    ULONG cch;
    WIN31IO_STATE State;

    if (Flags == 0 || EventType == Win31LogoffEvent) {
        return TRUE;
        }

    if (!InitializeWin31State( EventType, &State )) {
        return TRUE;
        }
    State.QueryOnly = FALSE;
    State.StatusCallback = StatusCallback;
    State.CallbackParameter = CallbackParameter;

    Result = FALSE;
    try {
        try {
            try {
                cch = ((64 * 1024) / sizeof( WCHAR )) - 1;
                if (!CreateVirtualBuffer( &Buffer, cch * sizeof( WCHAR ), cch * sizeof( WCHAR ) )) {
                    leave;
                    }

                State.WorkBuffer = Buffer.Base;
                State.cchWorkBuffer = cch;

                Result = TRUE;
                if (EventType == Win31SystemStartEvent) {
                    if (Flags & WIN31_MIGRATE_INIFILES) {
                        Result &= SnapShotWin31IniFilesToRegistry( &State );
                        }

                    if (Flags & WIN31_MIGRATE_REGDAT) {
                        Result &= SnapShotWin31RegDatToRegistry( &State );
                        }
                    }
                else {
                    if (Flags & WIN31_MIGRATE_INIFILES) {
                        Result &= SnapShotWin31IniFilesToRegistry( &State );
                        }

                    if (Flags & WIN31_MIGRATE_GROUPS) {
                        Result &= SnapShotWin31GroupsToRegistry( &State );
                        }
                    }
                }
            except( VirtualBufferExceptionHandler( GetExceptionCode(),
                                                   GetExceptionInformation(),
                                                   &Buffer
                                                 )
                  ) {
                if (GetExceptionCode() == STATUS_ACCESS_VIOLATION) {
                    BaseSetLastNTError( STATUS_NO_MEMORY );
                    }
                else {
                    BaseSetLastNTError( GetExceptionCode() );
                    }

                Result = FALSE;
                }
            }
        except( Win31IOExceptionHandler( GetExceptionCode(),
                                         GetExceptionInformation(),
                                         &State
                                       )
              ) {
            BaseSetLastNTError( GetExceptionCode() );
            Result = FALSE;
            }
        }
    finally {
        TerminateWin31State( EventType, &State );
        FreeVirtualBuffer( &Buffer );
        }

    return Result;
}


BOOL
SnapShotWin31IniFileKey(
    IN OUT PWIN31IO_STATE State,
    IN PWSTR TempFileName,
    IN PWSTR FileName,
    IN PWSTR ApplicationName,
    IN PWSTR KeyName
    );

BOOL
SnapShotWin31IniFileSection(
    IN OUT PWIN31IO_STATE State,
    IN PWSTR TempFileName,
    IN PWSTR FileName,
    IN PWSTR ApplicationName
    );

BOOL
SnapShotWin31IniFileSections(
    IN OUT PWIN31IO_STATE State,
    IN PWSTR TempFileName,
    IN PWSTR FileName
    );

BOOL
SnapShotWin31IniFilesToRegistry(
    IN OUT PWIN31IO_STATE State
    )
{
    BOOL Result;
    PWSTR s, s1, FileName, ApplicationName, KeyName;
    ULONG n;
    PWSTR CurrentFileName;
    WCHAR Win31IniFileName[ MAX_PATH ];
    WCHAR TempIniFileName[ MAX_PATH ];
    HANDLE FindHandle;
    WIN32_FIND_DATAW FindFileData;
    HANDLE MigrationKey, Key;
    ULONG cchBufferUsed;

    MigrationKey = OpenCreateKey( State->Win31IOKey, L"IniFiles", !State->QueryOnly );
    if (State->QueryOnly) {
        if (MigrationKey != NULL) {
            NtClose( MigrationKey );
            return FALSE;
            }
        }
    else {
        if (MigrationKey == NULL) {
            return FALSE;
            }
        }

    Result = FALSE;
    wcscpy( State->FileNamePart, L"system.ini" );
    FindHandle = FindFirstFileW( State->WindowsPath, &FindFileData );
    if (FindHandle != INVALID_HANDLE_VALUE) {
        FindClose( FindHandle );
	if (FindFileData.nFileSizeLow > 1024) {
            Result = TRUE;
            }
        }

    if (!Result || State->QueryOnly) {
        if (MigrationKey == NULL) {
            MigrationKey = OpenCreateKey( State->Win31IOKey, L"IniFiles", TRUE );
            }

        if (MigrationKey != NULL) {
            NtClose( MigrationKey );
            }

        return Result;
        }

    cchBufferUsed = 0;
    if (State->UserRoot != NULL) {
        Result = QueryWin31IniFilesMappedToRegistry( WIN31_INIFILES_MAPPED_TO_USER,
                                                     State->WorkBuffer,
                                                     State->cchWorkBuffer,
                                                     &cchBufferUsed
                                                   );
        }
    else {
        Result = QueryWin31IniFilesMappedToRegistry( WIN31_INIFILES_MAPPED_TO_SYSTEM,
                                                     State->WorkBuffer,
                                                     State->cchWorkBuffer,
                                                     &cchBufferUsed
                                                   );
        }

    if (Result) {
        s = State->WorkBuffer;
        State->WorkBuffer += cchBufferUsed;
        State->cchWorkBuffer -= cchBufferUsed;
        CurrentFileName = NULL;
        TempIniFileName[ 0 ] = UNICODE_NULL;
        do {
            FileName = (PWSTR)((*s == UNICODE_NULL) ? NULL : s);
            while (*s++) {
                ;
                }
            ApplicationName = (PWSTR)((*s == UNICODE_NULL) ? NULL : s);
            while (*s++) {
                ;
                }
            KeyName = (PWSTR)((*s == UNICODE_NULL) ? NULL : s);
            while (*s++) {
                ;
                }

            if (FileName) {
                if (!CurrentFileName || _wcsicmp( FileName, CurrentFileName )) {
                    if (TempIniFileName[ 0 ] != UNICODE_NULL) {
                        WritePrivateProfileStringW( NULL, NULL, NULL, L"" );
                        if (!DeleteFileW( TempIniFileName )) {
                            KdPrint(( "WIN31IO: DeleteFile( %ws ) - failed (%u)\n",
                                      TempIniFileName,
                                      GetLastError()
                                   ));
                            }

                        TempIniFileName[ 0 ] = UNICODE_NULL;
                        }

                    CurrentFileName = NULL;
                    GetWindowsDirectoryW( Win31IniFileName, sizeof( Win31IniFileName ) / sizeof (WCHAR) );
                    wcscat( Win31IniFileName, L"\\" );
                    wcscat( Win31IniFileName, FileName );
                    wcscpy( TempIniFileName, Win31IniFileName );
                    _wcslwr( TempIniFileName );
                    s1 = wcsstr( TempIniFileName, L".ini" );
                    if (!s1) {
                        s1 = wcschr( TempIniFileName, UNICODE_NULL );
                        if (s1[-1] == L'.') {
                            s1--;
                            }
                        }
                    n = 0;
                    while (n < 1000) {
                        swprintf( s1, L".%03u", n++ );
                        if (CopyFileW( Win31IniFileName, TempIniFileName, TRUE )) {
                            if (State->StatusCallback != NULL) {
                                (State->StatusCallback)( FileName, State->CallbackParameter );
                                }
                            Key = OpenCreateKey( MigrationKey, FileName, TRUE );
                            if (Key != NULL) {
                                NtClose( Key );
                                }
                            CurrentFileName = FileName;
                            break;
                            }
                        else
                        if (GetLastError() != ERROR_FILE_EXISTS) {
                            if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                                KdPrint(("WIN31IO: CopyFile( %ws, %ws ) failed - %u\n",
                                          Win31IniFileName,
                                          TempIniFileName,
                                          GetLastError()
                                       ));
                                }
                            break;
                            }
                        }

                    if (CurrentFileName == NULL) {
                        TempIniFileName[ 0 ] = UNICODE_NULL;
                        CurrentFileName = FileName;
                        }
                    }


                if (TempIniFileName[ 0 ] != UNICODE_NULL) {
                    if (ApplicationName) {
                        if (KeyName) {
                            if (SnapShotWin31IniFileKey( State,
                                                         TempIniFileName,
                                                         FileName,
                                                         ApplicationName,
                                                         KeyName
                                                       )
                               ) {
                                ReportWin31IOEvent( State,
                                                    EVENTLOG_INFORMATION_TYPE,
                                                    WIN31IO_EVENT_MIGRATE_INI_VARIABLE,
                                                    0,
                                                    NULL,
                                                    3,
                                                    KeyName,
                                                    ApplicationName,
                                                    FileName
                                                  );
                                }
                            else {
                                ReportWin31IOEvent( State,
                                                    EVENTLOG_WARNING_TYPE,
                                                    WIN31IO_EVENT_MIGRATE_INI_VARIABLE_FAILED,
                                                    0,
                                                    NULL,
                                                    3,
                                                    KeyName,
                                                    ApplicationName,
                                                    FileName
                                                  );
                                }

                            }
                        else {
                            if (SnapShotWin31IniFileSection( State,
                                                             TempIniFileName,
                                                             FileName,
                                                             ApplicationName
                                                           )
                               ) {
                                ReportWin31IOEvent( State,
                                                    EVENTLOG_INFORMATION_TYPE,
                                                    WIN31IO_EVENT_MIGRATE_INI_SECTION,
                                                    0,
                                                    NULL,
                                                    2,
                                                    ApplicationName,
                                                    FileName
                                                  );
                                }
                            else {
                                ReportWin31IOEvent( State,
                                                    EVENTLOG_WARNING_TYPE,
                                                    WIN31IO_EVENT_MIGRATE_INI_SECTION_FAILED,
                                                    0,
                                                    NULL,
                                                    2,
                                                    ApplicationName,
                                                    FileName
                                                  );
                                }

                            }
                        }
                    else {
                        if (SnapShotWin31IniFileSections( State,
                                                          TempIniFileName,
                                                          FileName
                                                        )
                            ) {
                            ReportWin31IOEvent( State,
                                                EVENTLOG_INFORMATION_TYPE,
                                                WIN31IO_EVENT_MIGRATE_INI_FILE,
                                                0,
                                                NULL,
                                                1,
                                                FileName
                                              );
                            }
                        else {
                            ReportWin31IOEvent( State,
                                                EVENTLOG_WARNING_TYPE,
                                                WIN31IO_EVENT_MIGRATE_INI_FILE_FAILED,
                                                0,
                                                NULL,
                                                1,
                                                FileName
                                              );
                            }
                        }
                    }
                }
            }
        while (*s != UNICODE_NULL);

        State->WorkBuffer -= cchBufferUsed;
        State->cchWorkBuffer += cchBufferUsed;
        }

    if (TempIniFileName[ 0 ] != UNICODE_NULL) {
        WritePrivateProfileStringW( NULL, NULL, NULL, L"" );
        if (!DeleteFileW( TempIniFileName )) {
            KdPrint(( "WIN31IO: DeleteFile( %ws ) - failed (%u)\n",
                      TempIniFileName,
                      GetLastError()
                   ));
            }
        }

    if (MigrationKey != NULL) {
        NtClose( MigrationKey );
        }
    return Result;
}



BOOL
SnapShotWin31IniFileKey(
    IN OUT PWIN31IO_STATE State,
    IN PWSTR TempFileName,
    IN PWSTR FileName,
    IN PWSTR ApplicationName,
    IN PWSTR KeyName
    )
{
    ULONG cch;

    cch = GetPrivateProfileStringW( ApplicationName,
                                    KeyName,
                                    NULL,
                                    State->WorkBuffer,
                                    State->cchWorkBuffer,
                                    TempFileName
                                  );
    if (cch != 0) {
        if (WritePrivateProfileStringW( ApplicationName,
                                        KeyName,
                                        State->WorkBuffer,
                                        FileName
                                      )
           ) {
            return TRUE;
            }
        else {
            KdPrint(( "WIN31IO: Copy to %ws [%ws].%ws == %ws (failed - %u)\n", FileName, ApplicationName, KeyName, State->WorkBuffer, GetLastError() ));
            return FALSE;
            }
        }
    else {
        return TRUE;
        }
}

BOOL
SnapShotWin31IniFileSection(
    IN OUT PWIN31IO_STATE State,
    IN PWSTR TempFileName,
    IN PWSTR FileName,
    IN PWSTR ApplicationName
    )
{
    BOOL Result;
    PWSTR KeyName;
    ULONG cch;

    Result = TRUE;
    cch = GetPrivateProfileStringW( ApplicationName,
                                    NULL,
                                    NULL,
                                    State->WorkBuffer,
                                    State->cchWorkBuffer,
                                    TempFileName
                                  );
    if (cch != 0) {
        KeyName = State->WorkBuffer;
        cch += 1;                   // Account for extra null
        State->WorkBuffer += cch;
        State->cchWorkBuffer -= cch;
        while (*KeyName != UNICODE_NULL) {
            Result &= SnapShotWin31IniFileKey( State,
                                               TempFileName,
                                               FileName,
                                               ApplicationName,
                                               KeyName
                                             );

            while (*KeyName++) {
                ;
                }
            }

        State->WorkBuffer -= cch;
        State->cchWorkBuffer += cch;
        }

    return Result;
}

BOOL
SnapShotWin31IniFileSections(
    IN OUT PWIN31IO_STATE State,
    IN PWSTR TempFileName,
    IN PWSTR FileName
    )
{
    BOOL Result;
    PWSTR ApplicationName;
    ULONG cch;

    Result = TRUE;
    cch = GetPrivateProfileStringW( NULL,
                                    NULL,
                                    NULL,
                                    State->WorkBuffer,
                                    State->cchWorkBuffer,
                                    TempFileName
                                  );
    if (cch != 0) {
        ApplicationName = State->WorkBuffer;
        cch += 1;                   // Account for extra null
        State->WorkBuffer += cch;
        State->cchWorkBuffer -= cch;
        while (*ApplicationName != UNICODE_NULL) {
            Result &= SnapShotWin31IniFileSection( State,
                                                   TempFileName,
                                                   FileName,
                                                   ApplicationName
                                                 );

            while (*ApplicationName++) {
                ;
                }
            }

        State->WorkBuffer -= cch;
        State->cchWorkBuffer += cch;
        }

    return Result;
}


BOOL
ConvertWindows31GroupsToRegistry(
    IN OUT PWIN31IO_STATE State,
    IN HANDLE MigrationKey,
    IN HANDLE CommonGroupsKey,
    IN HANDLE PersonalGroupsKey,
    IN PWSTR IniFileName,
    IN PWSTR GroupNames,
    IN ULONG nGroupNames
    );

BOOL
SnapShotWin31GroupsToRegistry(
    IN OUT PWIN31IO_STATE State
    )
{
    BOOL Result;
    PWSTR GroupNames, s;
    DWORD nGroupNames, cchGroupNames;
    HANDLE MigrationKey, PersonalGroupsKey, CommonGroupsKey;

    MigrationKey = OpenCreateKey( State->Win31IOKey, L"Groups", !State->QueryOnly );
    if (State->QueryOnly) {
        if (MigrationKey != NULL) {
            NtClose( MigrationKey );
            return FALSE;
            }
        }
    else {
        if (MigrationKey == NULL) {
            return FALSE;
            }
        }

    Result = FALSE;
    wcscpy( State->FileNamePart, L"progman.ini" );
    if (GetFileAttributesW( State->WindowsPath ) != 0xFFFFFFFF) {
        cchGroupNames = GetPrivateProfileStringW( L"Groups",
                                                  NULL,
                                                  L"",
                                                  State->WorkBuffer,
                                                  State->cchWorkBuffer,
                                                  State->WindowsPath
                                                );
        if (cchGroupNames != 0) {
            Result = TRUE;
            }
        }

    if (!Result || State->QueryOnly) {
        if (MigrationKey == NULL) {
            MigrationKey = OpenCreateKey( State->Win31IOKey, L"Groups", TRUE );
            }

        if (MigrationKey != NULL) {
            NtClose( MigrationKey );
            }

        return Result;
        }

    if (cchGroupNames) {
        PersonalGroupsKey = OpenCreateKey( State->UserRoot,
                                           L"UNICODE Program Groups",
                                           !State->QueryOnly
                                         );
        if (PersonalGroupsKey == NULL) {
            if (MigrationKey != NULL) {
                NtClose( MigrationKey );
                }

            return FALSE;
            }

        CommonGroupsKey = OpenCreateKey( NULL,
                                         L"\\Registry\\Machine\\Software\\Program Groups",
                                         FALSE
                                       );
        GroupNames = s = State->WorkBuffer;
        nGroupNames = 0;
        while (*s) {
            while (*s++) {
                ;
                }

            nGroupNames += 1;
            }
        State->WorkBuffer = s + 1;
        State->cchWorkBuffer -= cchGroupNames + 1;

        ConvertWindows31GroupsToRegistry( State,
                                          MigrationKey,
                                          CommonGroupsKey,
                                          PersonalGroupsKey,
                                          State->WindowsPath,
                                          GroupNames,
                                          nGroupNames
                                        );

        State->WorkBuffer = GroupNames,
        State->cchWorkBuffer += cchGroupNames + 1;

        NtClose( PersonalGroupsKey );
        if (CommonGroupsKey != NULL) {
            NtClose( CommonGroupsKey );
            }
        }

    if (MigrationKey != NULL) {
        NtClose( MigrationKey );
        }

    return TRUE;
}


BOOL
ConvertWindows31GroupsToRegistry(
    IN OUT PWIN31IO_STATE State,
    IN HANDLE MigrationKey,
    IN HANDLE CommonGroupsKey,
    IN HANDLE PersonalGroupsKey,
    IN PWSTR IniFileName,
    IN PWSTR GroupNames,
    IN ULONG nGroupNames
    )
{
    BOOL Result;
    NTSTATUS Status;
    PGROUP_DEF16 Group16;
    PGROUP_DEF Group32;
    UNICODE_STRING Group32Name;
    PWSTR Group16PathName;
    PWSTR Group16FileName;
    PWSTR s;
    ANSI_STRING AnsiString;
    ULONG NumberOfPersonalGroupNames;
    ULONG OldNumberOfPersonalGroupNames;
    HANDLE GroupNamesKey, SettingsKey, Key;

    NumberOfPersonalGroupNames = QueryNumberOfPersonalGroupNames( State->UserRoot,
                                                                  &GroupNamesKey,
                                                                  &SettingsKey
                                                                );
    OldNumberOfPersonalGroupNames = NumberOfPersonalGroupNames;

    Result = TRUE;
    while (*GroupNames) {
        //
        // Get the group file (.grp) name
        //
        if (GetPrivateProfileStringW( L"Groups",
                                      GroupNames,
                                      L"",
                                      State->WorkBuffer,
                                      State->cchWorkBuffer,
                                      IniFileName
                                    )
           ) {
            Group16PathName = State->WorkBuffer;
            Group16 = LoadGroup16( Group16PathName );
            if (Group16 != NULL) {
                Group16FileName = Group16PathName + wcslen( Group16PathName );
                while (Group16FileName > Group16PathName) {
                    if (Group16FileName[ -1 ] == OBJ_NAME_PATH_SEPARATOR) {
                        break;
                        }

                    Group16FileName -= 1;
                    }

                //
                // Get the group name.
                //
                if (Group16->pName == 0) {
                    RtlInitUnicodeString( &Group32Name, Group16FileName );
                    Status = STATUS_SUCCESS;
                    }
                else {
                    RtlInitAnsiString( &AnsiString, (PSZ)PTR( Group16, Group16->pName ) );
                    Status = RtlAnsiStringToUnicodeString( &Group32Name, &AnsiString, TRUE );
                    s = Group32Name.Buffer;
                    while (*s) {
                        if (*s == OBJ_NAME_PATH_SEPARATOR) {
                            *s = L'/';
                            }
                        s += 1;
                        }
                    }

                if (NT_SUCCESS( Status )) {
                    if (DoesExistGroup( PersonalGroupsKey, Group32Name.Buffer )) {
                        ReportWin31IOEvent( State,
                                            EVENTLOG_INFORMATION_TYPE,
                                            WIN31IO_EVENT_MIGRATE_GROUP_EXISTS,
                                            0,
                                            NULL,
                                            2,
                                            Group16PathName,
                                            Group32Name.Buffer
                                          );
                        }
                    else
                    if (DoesExistGroup( CommonGroupsKey, Group32Name.Buffer )) {
                        ReportWin31IOEvent( State,
                                            EVENTLOG_INFORMATION_TYPE,
                                            WIN31IO_EVENT_MIGRATE_GROUP_EXISTS,
                                            0,
                                            NULL,
                                            2,
                                            Group16PathName,
                                            Group32Name.Buffer
                                          );
                        }
                    else {
                        // DumpGroup16( State->WorkBuffer, Group16 );
                        Group32 = CreateGroupFromGroup16( AnsiString.Buffer, Group16 );
                        if (Group32 != NULL) {
                            if (Group32 == (PGROUP_DEF)-1) {
                                ReportWin31IOEvent( State,
                                                    EVENTLOG_WARNING_TYPE,
                                                    WIN31IO_EVENT_MIGRATE_GROUP_FAILED4,
                                                    0,
                                                    NULL,
                                                    1,
                                                    Group32Name.Buffer
                                                  );
                                Group32 = NULL;
                                }
                            else {
                                // DumpGroup( Group32Name.Buffer, Group32 );
                                if (!SaveGroup( PersonalGroupsKey,
                                                Group32Name.Buffer,
                                                Group32
                                              )
                                   ) {
                                    ReportWin31IOEvent( State,
                                                        EVENTLOG_WARNING_TYPE,
                                                        WIN31IO_EVENT_MIGRATE_GROUP_FAILED,
                                                        0,
                                                        NULL,
                                                        1,
                                                        Group32Name.Buffer
                                                      );
                                    }
                                else
                                if (!NewPersonalGroupName( GroupNamesKey,
                                                           Group32Name.Buffer,
                                                           NumberOfPersonalGroupNames+1
                                                         )
                                   ) {
                                    DeleteGroup( PersonalGroupsKey, Group32Name.Buffer );
                                    ReportWin31IOEvent( State,
                                                        EVENTLOG_WARNING_TYPE,
                                                        WIN31IO_EVENT_MIGRATE_GROUP_FAILED,
                                                        0,
                                                        NULL,
                                                        1,
                                                        Group32Name.Buffer
                                                      );
                                    }
                                else {
                                    if (State->StatusCallback != NULL) {
                                        (State->StatusCallback)( Group16FileName, State->CallbackParameter );
                                        }
                                    ReportWin31IOEvent( State,
                                                        EVENTLOG_INFORMATION_TYPE,
                                                        WIN31IO_EVENT_MIGRATE_GROUP,
                                                        0,
                                                        NULL,
                                                        1,
                                                        Group32Name.Buffer
                                                      );
                                    NumberOfPersonalGroupNames += 1;
                                    Key = OpenCreateKey( MigrationKey, Group16FileName, TRUE );
                                    if (Key != NULL) {
                                        NtClose( Key );
                                        }
                                    else {
                                        KdPrint(("WIN31IO: (3)Unable to create sub migration key for %ws (%u)\n", State->WorkBuffer, GetLastError() ));
                                        }
                                    }

                                UnloadGroup( Group32 );
                                }
                            }
                        else {
                            WCHAR ErrorCode[ 32 ];

                            _snwprintf( ErrorCode,
                                         sizeof( ErrorCode ) / sizeof( WCHAR ),
                                         L"%u",
                                         GetLastError()
                                       );
                            ReportWin31IOEvent( State,
                                                EVENTLOG_WARNING_TYPE,
                                                WIN31IO_EVENT_MIGRATE_GROUP_FAILED1,
                                                0,
                                                NULL,
                                                2,
                                                State->WorkBuffer,
                                                ErrorCode
                                              );
                            }
                        }

                    RtlFreeUnicodeString( &Group32Name );
                    }

                UnloadGroup16( Group16 );
                }
            else {
                WCHAR ErrorCode[ 32 ];

                _snwprintf( ErrorCode,
                             sizeof( ErrorCode ) / sizeof( WCHAR ),
                             L"%u",
                             GetLastError()
                           );
                ReportWin31IOEvent( State,
                                    EVENTLOG_WARNING_TYPE,
                                    WIN31IO_EVENT_MIGRATE_GROUP_FAILED1,
                                    0,
                                    NULL,
                                    2,
                                    State->WorkBuffer,
                                    ErrorCode
                                  );
                }
            }
        else {
            ReportWin31IOEvent( State,
                                EVENTLOG_WARNING_TYPE,
                                WIN31IO_EVENT_MIGRATE_GROUP_FAILED2,
                                0,
                                NULL,
                                2,
                                IniFileName,
                                GroupNames
                              );
            }

        while (*GroupNames++) {
            ;
            }
        }


    if (OldNumberOfPersonalGroupNames != NumberOfPersonalGroupNames) {
        UNICODE_STRING ValueName;
        ULONG ValueData = TRUE;

        RtlInitUnicodeString( &ValueName, L"InitialArrange" );
        Status = NtSetValueKey( SettingsKey,
                                &ValueName,
                                0,
                                REG_DWORD,
                                &ValueData,
                                sizeof( ValueData )
                              );
#if DBG
        if (!NT_SUCCESS( Status )) {
            KdPrint(( "WIN31IO: Unable to set value of %wZ - Status == %x\n", &ValueName, Status ));
            }
#endif
        }

    NtClose( SettingsKey );
    NtClose( GroupNamesKey );
    return Result;
}


BOOL
SnapShotWin31RegDatToRegistry(
    IN OUT PWIN31IO_STATE State
    )
{
    BOOL Result;
    HANDLE MigrationKey;
    PREG_HEADER16 RegDat16;

    MigrationKey = OpenCreateKey( State->Win31IOKey, L"REG.DAT", !State->QueryOnly );
    if (State->QueryOnly) {
        if (MigrationKey != NULL) {
            NtClose( MigrationKey );
            return FALSE;
            }
        }
    else {
        if (MigrationKey == NULL) {
            return FALSE;
            }
        }

    Result = FALSE;
    wcscpy( State->FileNamePart, L"reg.dat" );
    if (GetFileAttributesW( State->WindowsPath ) != 0xFFFFFFFF) {
        Result = TRUE;
        }

    if (!Result || State->QueryOnly) {
        if (MigrationKey == NULL) {
            MigrationKey = OpenCreateKey( State->Win31IOKey, L"REG.DAT", TRUE );
            }

        if (MigrationKey != NULL) {
            NtClose( MigrationKey );
            }

        return Result;
        }

    RegDat16 = LoadRegistry16( State->WindowsPath );
    if (RegDat16 != NULL) {
        if (State->StatusCallback != NULL) {
            (State->StatusCallback)( State->WindowsPath, State->CallbackParameter );
            }

        if (CreateRegistryClassesFromRegistry16( State->SoftwareRoot, RegDat16 )) {
            ReportWin31IOEvent( State,
                                EVENTLOG_INFORMATION_TYPE,
                                WIN31IO_EVENT_MIGRATE_REGDAT,
                                0,
                                NULL,
                                1,
                                State->WindowsPath
                              );
            }
        else {
            ReportWin31IOEvent( State,
                                EVENTLOG_WARNING_TYPE,
                                WIN31IO_EVENT_MIGRATE_REGDAT_FAILED,
                                0,
                                NULL,
                                1,
                                State->WindowsPath
                              );
            }
        UnloadRegistry16( RegDat16 );
        }

    if (MigrationKey != NULL) {
        NtClose( MigrationKey );
        }

    return TRUE;
}


#define SERVICE_TO_WAIT_FOR "EventLog"
#define MAX_TICKS_WAIT   90000   // ms

BOOL
WaitForEventLogToStart( VOID )
{
    BOOL bStarted = FALSE;
    DWORD StartTickCount;
    DWORD dwOldCheckPoint = (DWORD)-1;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS ServiceStatus;

    if ((hScManager = OpenSCManager( NULL,
                                     NULL,
                                     SC_MANAGER_CONNECT
                                   )
        ) == (SC_HANDLE) NULL
       ) {
        KdPrint(("WIN31IO: IsNetworkStarted: OpenSCManager failed, error = %d\n", GetLastError()));
        goto Exit;
    }

    //
    // OpenService
    //

    if ((hService = OpenService( hScManager,
                                 SERVICE_TO_WAIT_FOR,
                                 SERVICE_QUERY_STATUS
                               )
        ) == (SC_HANDLE) NULL
       ) {
        KdPrint(("WIN31IO: IsNetworkStarted: OpenService failed, error = %d\n", GetLastError()));
        goto Exit;
        }

    //
    // Loop until the service starts or we think it never will start
    // or we've exceeded our maximum time delay.
    //

    StartTickCount = GetTickCount();
    while (!bStarted) {

        if ((GetTickCount() - StartTickCount) > MAX_TICKS_WAIT) {
            KdPrint(("WIN31IO: Max wait exceeded waiting for service <%s> to start\n", SERVICE_TO_WAIT_FOR));
            break;
            }

        if (!QueryServiceStatus( hService, &ServiceStatus )) {
            KdPrint(("WIN31IO: IsNetworkStarted: QueryServiceStatus failed, error = %d\n", GetLastError()));
            break;
            }

        if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
            KdPrint(("WIN31IO: Service STOPPED"));

            if (ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED) {
                KdPrint(("WIN31IO: Waiting for 3 secs"));
                Sleep(3000);
                }
            else {
                KdPrint(("WIN31IO: Service exit code = %d, returning failure\n", ServiceStatus.dwWin32ExitCode));
                break;
                }
            }
        else
        if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
             (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
             (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
             (ServiceStatus.dwCurrentState == SERVICE_PAUSED)
           ) {
            bStarted = TRUE;
            }
        else
        if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING) {

            //
            // Wait to give a chance for the network to start.
            //

            Sleep( ServiceStatus.dwWaitHint );
            }
        else {
            KdPrint(( "WIN31IO: Service in unknown state : %d\n", ServiceStatus.dwCurrentState ));
            }
        }

Exit:
    if (hScManager != NULL) {
        CloseServiceHandle( hScManager );
    }
    if (hService != NULL) {
        CloseServiceHandle( hService );
    }

    return( bStarted );
}


HANDLE
OpenCreateKey(
    IN HANDLE Root,
    IN PWSTR Path,
    IN BOOL WriteAccess
    )
{
    NTSTATUS Status;
    HANDLE Key;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG CreateDisposition;

    RtlInitUnicodeString( &KeyName, Path );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                Root,
                                NULL
                              );
    Status = NtOpenKey( &Key,
                        WriteAccess ? (STANDARD_RIGHTS_WRITE |
                                          KEY_QUERY_VALUE |
                                          KEY_ENUMERATE_SUB_KEYS |
                                          KEY_SET_VALUE |
                                          KEY_CREATE_SUB_KEY
                                      )
                                    : GENERIC_READ,
                        &ObjectAttributes
                      );
    if (NT_SUCCESS( Status )) {
        return Key;
        }
    else
    if (!WriteAccess) {
        BaseSetLastNTError( Status );
        return NULL;
        }

    Status = NtCreateKey( &Key,
                          STANDARD_RIGHTS_WRITE |
                            KEY_QUERY_VALUE |
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_SET_VALUE |
                            KEY_CREATE_SUB_KEY,
                          &ObjectAttributes,
                          0,
                          NULL,
                          0,
                          &CreateDisposition
                        );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return NULL;
        }
    else {
        return Key;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\ddk\makefile.inc ===
DDK_TOOL_PATH=\sdktools\ddk\generate
PROJECT_ROOT=$(BASEDIR)
ddk:
!IFNDEF PASS0ONLY
ddk:
#
# Process only on the second pass
#
# NOTE: DDKBUILD.CMD will exit w/o building a DDK on AXP64 and Alpha.
#        This is by design.
        @perl -e "while (<>) { if (m/QFEBUILDNUMBER=(\d*)/) { printf(qq($$1\n)); }}" $(SDXROOT)\__qfenum__ > QFE_NUM.TXT
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ddk_public.ini  ddk $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  hal_public.ini  hal $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ifs_public.ini  ifs $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  processor_public.ini  processor $(PROJECT_ROOT)

!ENDIF
#
# Remove generated files
#
clean:
	@if EXIST .\obj          rd  /s/q .\obj
	@if EXIST .\objchk       rd  /s/q .\objchk
	@if EXIST .\objfre       rd  /s/q .\objfre
	@if EXIST .\build.log    del /f/q .\build.log
	@if EXIST .\build.wrn    del /f/q .\build.wrn
	@if EXIST .\build.err    del /f/q .\build.err
	@if EXIST .\buildfre.log del /f/q .\buildfre.log
	@if EXIST .\buildfre.wrn del /f/q .\buildfre.wrn
	@if EXIST .\buildfre.err del /f/q .\buildfre.err
	@if EXIST .\buildchk.log del /f/q .\buildchk.log
	@if EXIST .\buildchk.wrn del /f/q .\buildchk.wrn
	@if EXIST .\buildchk.err del /f/q .\buildchk.err
	@echo Clean
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dload\advapi.c ===
#include "pch.h"
#pragma hdrstop

#include "winreg.h"
#include "ntelfapi.h"
#include <wincrypt.h>
#include <winsafer.h>

/*
Elf == Event Log
a notable difference between Elf and the Win32 API is Elf accepts non nul terminated UNICODE_STRINGs.
*/

static
NTSTATUS
NTAPI
ElfReportEventW(
    IN     HANDLE      LogHandle,
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING* Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL,
    IN     USHORT      Flags,
    IN OUT PULONG      RecordNumber    OPTIONAL,
    IN OUT PULONG      TimeWritten     OPTIONAL
    )
{
    if (ARGUMENT_PRESENT(RecordNumber))
    {
        *RecordNumber = 0;
    }
    if (ARGUMENT_PRESENT(TimeWritten))
    {
        *TimeWritten = 0;
    }
    return STATUS_ENTRYPOINT_NOT_FOUND;
}

static
NTSTATUS
NTAPI
ElfRegisterEventSourceW(
    IN  PUNICODE_STRING UNCServerName,
    IN  PUNICODE_STRING SourceName,
    OUT PHANDLE         LogHandle
    )
{
    if (ARGUMENT_PRESENT(LogHandle))
    {
        *LogHandle = NULL;
    }
    return STATUS_ENTRYPOINT_NOT_FOUND;
}

static
NTSTATUS
NTAPI
ElfDeregisterEventSource(
    IN  HANDLE LogHandle
    )
{
    return STATUS_ENTRYPOINT_NOT_FOUND;
}

static
LONG
APIENTRY
RegCreateKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegCreateKeyExW(
    IN HKEY hKey,
    IN PCWSTR lpSubKey,
    IN DWORD Reserved,
    IN PWSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN PSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    )
{
    if (ARGUMENT_PRESENT(phkResult))
    {
        *phkResult = INVALID_HANDLE_VALUE;
    }
    if (ARGUMENT_PRESENT(lpdwDisposition))
    {
        *lpdwDisposition = 0;
    }
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegOpenKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegOpenKeyExW(
    IN HKEY hKey,
    IN PCWSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )
{
    if (ARGUMENT_PRESENT(phkResult))
    {
        *phkResult = INVALID_HANDLE_VALUE;
    }
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegSetValueExA (
    IN HKEY hKey,
    IN LPCSTR lpValueName,
    IN DWORD Reserved,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegSetValueExW (
    IN HKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD Reserved,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegQueryValueExA (
    IN HKEY hKey,
    IN LPCSTR lpValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegQueryValueExW(
    IN HKEY hKey,
    IN PCWSTR lpValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    if (ARGUMENT_PRESENT(lpType))
    {
        *lpType = 0;
    }
    if (ARGUMENT_PRESENT(lpcbData))
    {
        *lpcbData = 0;
    }
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
GetUserNameW (
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
LONG
APIENTRY
RegCloseKey(
    IN HKEY hKey
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegDeleteKeyW(
    IN HKEY hKey,
    IN PCWSTR lpSubKey
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
QueryServiceStatus(
    SC_HANDLE           hService,
    LPSERVICE_STATUS    lpServiceStatus
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
LONG
APIENTRY
RegSaveKeyA(
    IN HKEY hKey,
    IN PCSTR lpFile,
    IN LPSECURITY_ATTRIBUTES lpSecurity
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegSaveKeyExW(
    IN HKEY hKey,
    IN PCWSTR lpFile,
    IN LPSECURITY_ATTRIBUTES lpSecurity,
    DWORD Flags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegSaveKeyW(
    IN HKEY hKey,
    IN PCWSTR lpFile,
    IN LPSECURITY_ATTRIBUTES lpSecurity
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegDeleteValueA (
    IN HKEY hKey,
    IN LPCSTR lpValueName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegDeleteValueW(
    IN HKEY hKey,
    IN PCWSTR lpValueName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegNotifyChangeKeyValue(
    IN HKEY hKey,
    IN BOOL bWatchSubtree,
    IN DWORD dwNotifyFilter,
    IN HANDLE hEvent,
    IN BOOL fAsynchronus
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegOpenKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegOpenKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegEnumKeyExW(
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN OUT LPDWORD lpcbName,
    IN LPDWORD lpReserved,
    IN OUT LPWSTR lpClass,
    IN OUT LPDWORD lpcbClass,
    OUT PFILETIME lpftLastWriteTime
    )
{
    if (ARGUMENT_PRESENT(lpcbName))
    {
        *lpcbName = 0;
    }
    return ERROR_PROC_NOT_FOUND;
}

static
WINADVAPI
LONG
APIENTRY
RegQueryInfoKeyW(
    IN HKEY hKey,
    OUT LPWSTR lpClass,
    IN OUT LPDWORD lpcbClass,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcbMaxSubKeyLen,
    OUT LPDWORD lpcbMaxClassLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
APIENTRY
RegRestoreKeyW(
    HKEY hkey,
    LPCWSTR lpFile,
    DWORD dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINADVAPI
BOOL
WINAPI
DeregisterEventSource(
    IN OUT HANDLE hEventLog
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINADVAPI
HANDLE
WINAPI
RegisterEventSourceW(
    IN LPCWSTR lpUNCServerName,
    IN LPCWSTR lpSourceName
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINADVAPI
BOOL
WINAPI
ReportEventW(
    IN HANDLE     hEventLog,
    IN WORD       wType,
    IN WORD       wCategory,
    IN DWORD      dwEventID,
    IN PSID       lpUserSid,
    IN WORD       wNumStrings,
    IN DWORD      dwDataSize,
    IN LPCWSTR   *lpStrings,
    IN LPVOID     lpRawData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
AdjustTokenPrivileges(
    IN HANDLE TokenHandle,
    IN BOOL DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState,
    IN DWORD BufferLength,
    OUT PTOKEN_PRIVILEGES PreviousState,
    OUT PDWORD ReturnLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
LookupPrivilegeValueA(
    IN LPCSTR lpSystemName,
    IN LPCSTR lpName,
    OUT PLUID   lpLuid
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
LookupPrivilegeValueW(
    IN LPCWSTR lpSystemName,
    IN LPCWSTR lpName,
    OUT PLUID   lpLuid
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
PVOID
WINAPI
FreeSid(
    IN PSID pSid
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
APIENTRY
CheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
AllocateAndInitializeSid (
    IN PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    IN BYTE nSubAuthorityCount,
    IN DWORD nSubAuthority0,
    IN DWORD nSubAuthority1,
    IN DWORD nSubAuthority2,
    IN DWORD nSubAuthority3,
    IN DWORD nSubAuthority4,
    IN DWORD nSubAuthority5,
    IN DWORD nSubAuthority6,
    IN DWORD nSubAuthority7,
    OUT PSID *pSid
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
OpenProcessToken(
    IN HANDLE ProcessHandle,
    IN DWORD DesiredAccess,
    OUT PHANDLE TokenHandle
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
OpenThreadToken(
    IN HANDLE ThreadHandle,
    IN DWORD DesiredAccess,
    IN BOOL OpenAsSelf,
    OUT PHANDLE TokenHandle
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
GetTokenInformation(
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT LPVOID TokenInformation,
    IN DWORD TokenInformationLength,
    OUT PDWORD ReturnLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
LONG
APIENTRY
RegEnumKeyW (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN DWORD cbName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINADVAPI
LONG
APIENTRY
RegEnumValueW (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpValueName,
    IN OUT LPDWORD lpcbValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINADVAPI
BOOL
WINAPI
CryptHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags
    )
{
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags
    )
{
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR szContainer,
    LPCWSTR szProvider,
    DWORD dwProvType,
    DWORD dwFlags
    )
{
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptDestroyHash(
    HCRYPTHASH hHash
    )
{
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptDestroyKey(
    HCRYPTKEY hKey
    )
{
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    )
{
    return FALSE;
}
    

static
WINADVAPI
BOOL
WINAPI
CryptGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    )
{
    if (ARGUMENT_PRESENT(pdwDataLen))
    {
        *pdwDataLen = 0;
    }
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash
    )
{
    return FALSE;
}



static
WINADVAPI
BOOL WINAPI
SaferGetPolicyInformation (
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS          CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        IN OUT PVOID                        InfoBuffer,
        IN OUT PDWORD                       InfoBufferRetSize,
        IN LPVOID                           lpReserved
        )
{
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferSetPolicyInformation (
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS          CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        IN PVOID                            InfoBuffer,
        IN LPVOID                           lpReserved
        )
{
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferCreateLevel(
        IN DWORD            dwScopeId,
        IN DWORD            dwLevelId,
        IN DWORD            OpenFlags,
        OUT SAFER_LEVEL_HANDLE    *pLevelHandle,
        IN LPVOID           lpReserved)
{
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferCloseLevel(
        IN SAFER_LEVEL_HANDLE      hLevelHandle)
{
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferIdentifyLevel (
        IN DWORD                       dwNumProperties,
        IN PSAFER_CODE_PROPERTIES      pCodeProperties,
        OUT SAFER_LEVEL_HANDLE        *pLevelHandle,
        IN LPVOID                      lpReserved
        )
{
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferComputeTokenFromLevel (
        IN SAFER_LEVEL_HANDLE      LevelHandle,
        IN HANDLE                  InAccessToken         OPTIONAL,
        OUT PHANDLE                OutAccessToken,
        IN DWORD                   dwFlags,
        IN LPVOID                  lpReserved
        )
{
    return FALSE;
}

static
WINADVAPI
BOOL WINAPI
SaferGetLevelInformation (
        IN SAFER_LEVEL_HANDLE              LevelHandle,
        IN SAFER_OBJECT_INFO_CLASS         dwInfoType,
        OUT LPVOID                         lpQueryBuffer   OPTIONAL,
        IN DWORD                           dwInBufferSize,
        OUT LPDWORD                        lpdwOutBufferSize
        )
{
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferSetLevelInformation (
    IN SAFER_LEVEL_HANDLE          LevelHandle,
    IN SAFER_OBJECT_INFO_CLASS     dwInfoType,
    IN LPVOID                      pQueryBuffer,
    IN DWORD                       dwInBufferSize
    )
{
    return FALSE;
}



//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(advapi32)
{
    DLPENTRY(AdjustTokenPrivileges)
    DLPENTRY(AllocateAndInitializeSid)
    DLPENTRY(CheckTokenMembership)
    DLPENTRY(CryptAcquireContextW)
    DLPENTRY(CryptCreateHash)
    DLPENTRY(CryptDestroyHash)
    DLPENTRY(CryptDestroyKey)
    DLPENTRY(CryptExportKey)
    DLPENTRY(CryptGetHashParam)
    DLPENTRY(CryptHashData)
    DLPENTRY(CryptReleaseContext)
    DLPENTRY(DeregisterEventSource)
    DLPENTRY(ElfDeregisterEventSource)
    DLPENTRY(ElfRegisterEventSourceW)
    DLPENTRY(ElfReportEventW)
    DLPENTRY(FreeSid)
    DLPENTRY(GetTokenInformation)
    DLPENTRY(GetUserNameW)
    DLPENTRY(LookupPrivilegeValueA)
    DLPENTRY(LookupPrivilegeValueW)
    DLPENTRY(OpenProcessToken)
    DLPENTRY(OpenThreadToken)
    DLPENTRY(QueryServiceStatus)
    DLPENTRY(RegCloseKey)
    DLPENTRY(RegCreateKeyExW)
    DLPENTRY(RegCreateKeyW)
    DLPENTRY(RegDeleteKeyW)
    DLPENTRY(RegDeleteValueW)
    DLPENTRY(RegEnumKeyExW)
    DLPENTRY(RegEnumKeyW)
    DLPENTRY(RegEnumValueW)
    DLPENTRY(RegNotifyChangeKeyValue)
    DLPENTRY(RegOpenKeyA)
    DLPENTRY(RegOpenKeyExA)
    DLPENTRY(RegOpenKeyExW)
    DLPENTRY(RegOpenKeyW)
    DLPENTRY(RegQueryInfoKeyW)
    DLPENTRY(RegQueryValueExA)
    DLPENTRY(RegQueryValueExW)
    DLPENTRY(RegRestoreKeyW)
    DLPENTRY(RegSaveKeyA)
    DLPENTRY(RegSaveKeyExW)
    DLPENTRY(RegSaveKeyW)
    DLPENTRY(RegSetValueExA)
    DLPENTRY(RegSetValueExW)
    DLPENTRY(RegisterEventSourceW)
    DLPENTRY(ReportEventW)
    DLPENTRY(SaferCloseLevel)
    DLPENTRY(SaferComputeTokenFromLevel)
    DLPENTRY(SaferCreateLevel)
    DLPENTRY(SaferGetLevelInformation)
    DLPENTRY(SaferGetPolicyInformation)
    DLPENTRY(SaferIdentifyLevel)
    DLPENTRY(SaferSetLevelInformation)
    DLPENTRY(SaferSetPolicyInformation)};

DEFINE_PROCNAME_MAP(advapi32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dload\dllmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P R O C M A P . C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:
//
//  Author:     shaunco   19 May 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// All of the dll's that kernel32.dll supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)
DECLARE_ORDINAL_MAP(activeds)
DECLARE_PROCNAME_MAP(advapi32)
DECLARE_PROCNAME_MAP(advpack)
DECLARE_PROCNAME_MAP(apphelp)
DECLARE_PROCNAME_MAP(authz)
DECLARE_ORDINAL_MAP(browseui)
DECLARE_ORDINAL_MAP(cabinet)
DECLARE_PROCNAME_MAP(cdfview)
DECLARE_ORDINAL_MAP(certcli)
DECLARE_PROCNAME_MAP(certcli)
DECLARE_ORDINAL_MAP(comctl32)
DECLARE_PROCNAME_MAP(comctl32)
DECLARE_PROCNAME_MAP(comdlg32)
DECLARE_PROCNAME_MAP(credui)
DECLARE_PROCNAME_MAP(crypt32)
DECLARE_PROCNAME_MAP(cryptui)
DECLARE_ORDINAL_MAP(cscdll)
DECLARE_PROCNAME_MAP(ddraw)
DECLARE_ORDINAL_MAP(devmgr)
DECLARE_PROCNAME_MAP(dhcpcsvc)
DECLARE_PROCNAME_MAP(dnsapi)
DECLARE_PROCNAME_MAP(duser)
DECLARE_PROCNAME_MAP(efsadu)
DECLARE_PROCNAME_MAP(esent)
DECLARE_PROCNAME_MAP(gdi32)
DECLARE_PROCNAME_MAP(gdiplus)
DECLARE_PROCNAME_MAP(imagehlp)
DECLARE_PROCNAME_MAP(imgutil)
DECLARE_PROCNAME_MAP(imm32)
DECLARE_PROCNAME_MAP(inetcomm)
DECLARE_PROCNAME_MAP(iphlpapi)
DECLARE_PROCNAME_MAP(kdcsvc)
DECLARE_PROCNAME_MAP(keymgr)
DECLARE_PROCNAME_MAP(linkinfo)
DECLARE_PROCNAME_MAP(lz32)
DECLARE_ORDINAL_MAP(mlang)
DECLARE_PROCNAME_MAP(mobsync)
DECLARE_PROCNAME_MAP(mpr)
DECLARE_PROCNAME_MAP(mprapi)
DECLARE_PROCNAME_MAP(mprui)
DECLARE_PROCNAME_MAP(msacm32)
DECLARE_PROCNAME_MAP(mscat32)
DECLARE_ORDINAL_MAP(msgina)
DECLARE_PROCNAME_MAP(mshtml)
DECLARE_ORDINAL_MAP(msi)
DECLARE_PROCNAME_MAP(msimg32)
DECLARE_PROCNAME_MAP(msrating)
DECLARE_PROCNAME_MAP(mssign32)
DECLARE_PROCNAME_MAP(mswsock)
DECLARE_PROCNAME_MAP(netapi32)
DECLARE_PROCNAME_MAP(netcfgx)
DECLARE_PROCNAME_MAP(netplwiz)
DECLARE_PROCNAME_MAP(netrap)
DECLARE_PROCNAME_MAP(netshell)
DECLARE_PROCNAME_MAP(ntdsa)
DECLARE_PROCNAME_MAP(ntdsapi)
DECLARE_PROCNAME_MAP(ntlanman)
DECLARE_PROCNAME_MAP(ntlsapi)
DECLARE_PROCNAME_MAP(ntmarta)
DECLARE_PROCNAME_MAP(ocmanage)
DECLARE_ORDINAL_MAP(odbc32)
DECLARE_PROCNAME_MAP(ole32)
DECLARE_PROCNAME_MAP(oleacc)
DECLARE_ORDINAL_MAP(oleaut32)
DECLARE_PROCNAME_MAP(pautoenr)
DECLARE_ORDINAL_MAP(pidgen)
DECLARE_PROCNAME_MAP(powrprof)
DECLARE_PROCNAME_MAP(printui)
DECLARE_PROCNAME_MAP(pstorec)
DECLARE_PROCNAME_MAP(query)
DECLARE_PROCNAME_MAP(rasapi32)
DECLARE_PROCNAME_MAP(rasdlg)
DECLARE_PROCNAME_MAP(rasman)
DECLARE_PROCNAME_MAP(regapi)
DECLARE_PROCNAME_MAP(rpcrt4)
DECLARE_PROCNAME_MAP(rtutils)
DECLARE_PROCNAME_MAP(samlib)
DECLARE_PROCNAME_MAP(scecli)
DECLARE_PROCNAME_MAP(secur32)
DECLARE_PROCNAME_MAP(setupapi)
DECLARE_ORDINAL_MAP(sfc)
DECLARE_PROCNAME_MAP(sfc)
DECLARE_ORDINAL_MAP(shdocvw)
DECLARE_PROCNAME_MAP(shdocvw)
DECLARE_ORDINAL_MAP(shell32)
DECLARE_PROCNAME_MAP(shell32)
DECLARE_ORDINAL_MAP(shlwapi)
DECLARE_PROCNAME_MAP(shlwapi)
DECLARE_ORDINAL_MAP(shsvcs)
DECLARE_PROCNAME_MAP(sti)
DECLARE_PROCNAME_MAP(syssetup)
DECLARE_PROCNAME_MAP(urlmon)
DECLARE_PROCNAME_MAP(user32)
DECLARE_ORDINAL_MAP(userenv)
DECLARE_PROCNAME_MAP(userenv)
DECLARE_PROCNAME_MAP(utildll)
DECLARE_ORDINAL_MAP(uxtheme)
DECLARE_PROCNAME_MAP(uxtheme)
DECLARE_PROCNAME_MAP(version)
DECLARE_ORDINAL_MAP(wininet)
DECLARE_PROCNAME_MAP(wininet)
DECLARE_PROCNAME_MAP(winmm)
DECLARE_PROCNAME_MAP(winscard)
DECLARE_ORDINAL_MAP(winspool)
DECLARE_PROCNAME_MAP(winspool)
DECLARE_PROCNAME_MAP(winsta)
DECLARE_PROCNAME_MAP(wintrust)
DECLARE_ORDINAL_MAP(wldap32)
DECLARE_PROCNAME_MAP(wmi)
DECLARE_PROCNAME_MAP(wmvcore)
DECLARE_ORDINAL_MAP(ws2_32)
DECLARE_PROCNAME_MAP(ws2_32)
DECLARE_PROCNAME_MAP(wtsapi32)
DECLARE_PROCNAME_MAP(wzcdlg)
DECLARE_ORDINAL_MAP(wzcsapi)
DECLARE_PROCNAME_MAP(wzcsapi)

const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // alphabetical order (hint hint)
    DLDENTRYO(activeds)
    DLDENTRYP(advapi32)
    DLDENTRYP(advpack)
    DLDENTRYP(apphelp)
    DLDENTRYP(authz)
    DLDENTRYO(browseui)
    DLDENTRYO(cabinet)
    DLDENTRYP(cdfview)
    DLDENTRYB(certcli)
    DLDENTRYB(comctl32)
    DLDENTRYP(comdlg32)
    DLDENTRYP(credui)
    DLDENTRYP(crypt32)
    DLDENTRYP(cryptui)
    DLDENTRYO(cscdll)
    DLDENTRYP(ddraw)
    DLDENTRYO(devmgr)
    DLDENTRYP(dhcpcsvc)
    DLDENTRYP(dnsapi)
    DLDENTRYP(duser)
    DLDENTRYP(efsadu)
    DLDENTRYP(esent)
    DLDENTRYP(gdi32)
    DLDENTRYP(gdiplus)
    DLDENTRYP(imagehlp)
    DLDENTRYP(imgutil)
    DLDENTRYP(imm32)
    DLDENTRYP(inetcomm)
    DLDENTRYP(iphlpapi)
    DLDENTRYP(kdcsvc)
    DLDENTRYP(keymgr)
    DLDENTRYP(linkinfo)
    DLDENTRYP(lz32)
    DLDENTRYO(mlang)
    DLDENTRYP(mobsync)
    DLDENTRYP(mpr)
    DLDENTRYP(mprapi)
    DLDENTRYP(mprui)
    DLDENTRYP(msacm32)
    DLDENTRYP(mscat32)
    DLDENTRYO(msgina)
    DLDENTRYP(mshtml)
    DLDENTRYO(msi)
    DLDENTRYP(msimg32)
    DLDENTRYP(msrating)
    DLDENTRYP(mssign32)
    DLDENTRYP(mswsock)
    DLDENTRYP(netapi32)
    DLDENTRYP(netcfgx)
    DLDENTRYP(netplwiz)
    DLDENTRYP(netrap)
    DLDENTRYP(netshell)
    DLDENTRYP(ntdsa)
    DLDENTRYP(ntdsapi)
    DLDENTRYP(ntlanman)
    DLDENTRYP(ntlsapi)
    DLDENTRYP(ntmarta)
    DLDENTRYP(ocmanage)
    DLDENTRYO(odbc32)
    DLDENTRYP(ole32)
    DLDENTRYP(oleacc)
    DLDENTRYO(oleaut32)
    DLDENTRYP(pautoenr)
    DLDENTRYO(pidgen)
    DLDENTRYP(powrprof)
    DLDENTRYP(printui)
    DLDENTRYP(pstorec)
    DLDENTRYP(query)
    DLDENTRYP(rasapi32)
    DLDENTRYP(rasdlg)
    DLDENTRYP(rasman)
    DLDENTRYP(regapi)
    DLDENTRYP(rpcrt4)
    DLDENTRYP(rtutils)
    DLDENTRYP(samlib)
    DLDENTRYP(scecli)
    DLDENTRYP(secur32)
    DLDENTRYP(setupapi)
    DLDENTRYB(sfc)
    DLDENTRYB(shdocvw)
    DLDENTRYB(shell32)
    DLDENTRYB(shlwapi)
    DLDENTRYO(shsvcs)
    DLDENTRYP(sti)
    DLDENTRYP(syssetup)
    DLDENTRYP(urlmon)
    DLDENTRYP(user32)
    DLDENTRYB(userenv)
    DLDENTRYP(utildll)
    DLDENTRYB(uxtheme)
    DLDENTRYP(version)
    DLDENTRYB(wininet)
    DLDENTRYP(winmm)
    DLDENTRYP(winscard)
    DLDENTRYB_DRV(winspool)
    DLDENTRYP(winsta)
    DLDENTRYP(wintrust)
    DLDENTRYO(wldap32)
    DLDENTRYP(wmi)
    DLDENTRYP(wmvcore)
    DLDENTRYB(ws2_32)
    DLDENTRYP(wtsapi32)
    DLDENTRYP(wzcdlg)
    DLDENTRYB(wzcsapi)
};

const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dload\dload.h ===
#pragma once

// Get the public delay load stub definitions.
//
#include <dloaddef.h>

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYB_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },


extern const DLOAD_DLL_MAP g_DllMap;

FARPROC
LookupHandler (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dlcheck\dlcheck.c ===
/* dlcheck - verify that a DLL using delay-load calls APIs that have
 *           stubs in kernel32.dll (aka dload.lib)
 *
 * HISTORY:
 * 25-Nov-98    barrybo Wrote it.
 */

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>
#include <delayimp.h>
#include <dloaddef.h>

// Function Forward Parameters...
void Usage( void );
int __cdecl main( int, char ** );

int DloadBreakOnFail = FALSE;
extern int DloadDbgPrint = FALSE;

// implemented in kernel32p.lib
FARPROC
WINAPI
DelayLoadFailureHook (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    );


typedef FARPROC (WINAPI *PfnKernel32HookProc)(
    LPCSTR pszDllName,
    LPCSTR pszProcName
    );

PfnKernel32HookProc __pfnFailureProc = DelayLoadFailureHook;

const char rgstrUsage[] = {
    "Verify that delayloaded imports all have failure handlers in kernel32.\n"
    "usage: dlcheck [switches] image-name\n"
    "where: [-?] display this message\n"
    "       [-l] use the live version of kernel32.dll on the machine\n"
    "       [-s] use the static dload.lib linked into dlcheck\n"
    "       [-t] test the static dload.lib linked into dlcheck and exit\n"
    "       [-i <inifile>] use the information in inifile to check a binary\n"
    "       [-f] force check the binary (assumes -s)\n"
    "\n"
    };

HANDLE BaseDllHandle;
PLOADED_IMAGE g_pli;
PIMAGE_SECTION_HEADER g_DelaySection;
char g_szImageName[MAX_PATH];
char g_szDelayLoadHandler[MAX_PATH];
BOOL fForceCheckImage = FALSE;

//
// Convert an absolute pointer that points into the image if the image
// was loaded as a DLL at its preferred base, into a pointer into the
// DLL as it was mapped by imagehlp.
//
void *
ConvertImagePointer(void * p)
{
    if (!p) {
        return NULL;
    } else {
        return (void *)((ULONG_PTR)(p) -
                  (ULONG_PTR)g_pli->FileHeader->OptionalHeader.ImageBase +
                  (ULONG_PTR)g_pli->MappedAddress -
                  (ULONG_PTR)g_DelaySection->VirtualAddress +
                  (ULONG_PTR)g_DelaySection->PointerToRawData);
    }
}

void *
RvaToPtr(DWORD_PTR rva)
{
    DWORD i;
    PIMAGE_SECTION_HEADER pSect;
    if (!rva)
        return NULL;

    for (i = 0; i < g_pli->NumberOfSections; i++) {
        pSect = g_pli->Sections+i;
        if (rva >= g_pli->Sections[i].VirtualAddress &&
            rva <= (g_pli->Sections[i].VirtualAddress + g_pli->Sections[i].Misc.VirtualSize))
        {
            return (PVOID)
                   (g_pli->MappedAddress +
                    g_pli->Sections[i].PointerToRawData +
                   (rva - g_pli->Sections[i].VirtualAddress));
        }
    }
    return NULL;
}

void Usage( void )
{
    puts(rgstrUsage);

    exit (1);
}

BOOLEAN ImageLinksToKernel32Handler( void )
{
    PIMAGE_IMPORT_DESCRIPTOR Imports;
    ULONG ImportSize;
    PULONG_PTR pIAT;
    PIMAGE_IMPORT_BY_NAME pImport;

    Imports = (PIMAGE_IMPORT_DESCRIPTOR)
                  ImageDirectoryEntryToData(g_pli->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_IMPORT,
                                            &ImportSize
                                            );
    if (!Imports) {
        // Image has delayload imports, but no true imports.
        return FALSE;
    }

    while (Imports->Name) {
        char *szName;

        szName = ImageRvaToVa(g_pli->FileHeader, (PVOID)g_pli->MappedAddress, Imports->Name, NULL);

        if (szName && _stricmp(szName, "KERNEL32.DLL") == 0) {
            pIAT = ImageRvaToVa(g_pli->FileHeader,
                                 (PVOID)g_pli->MappedAddress,
                                 Imports->OriginalFirstThunk,
                                 NULL);

            while (pIAT && *pIAT) {
                pImport = ImageRvaToVa(g_pli->FileHeader,
                                       (PVOID)g_pli->MappedAddress,
                                       (ULONG) *pIAT,
                                       NULL);

                if (pImport && _stricmp(pImport->Name, "DelayLoadFailureHook") == 0) {
                    return TRUE;
                }
                pIAT++;
            }
        }
        Imports++;
    }

    return FALSE;
}

//
//  Validate that the statically-linked delayload stub table is not
//  blatantly broken.  The most common error is not listing the functions
//  in the correct order so the binary search fails.
//
int ValidateStaticDelayloadStubs()
{
    extern const DLOAD_DLL_MAP g_DllMap;
    UINT i, j;
    int Errors = 0;

    //
    //  Ensure that the DLL map is in alphabetical order.
    //
    for (i = 1; i < g_DllMap.NumberOfEntries; i++)
    {
        if (strcmp(g_DllMap.pDllEntry[i-1].pszDll,
                   g_DllMap.pDllEntry[i].pszDll) >= 0)
        {
            fprintf(stderr, "DLCHECK : error DL000001 : Static delayload table is corrupted\n"
                            "          %s and %s not in alphabetical order\n",
                            g_DllMap.pDllEntry[i-1].pszDll,
                            g_DllMap.pDllEntry[i].pszDll);
            Errors = 1;
        }
    }

    //  For each DLL...
    for (i = 0; i < g_DllMap.NumberOfEntries; i++)
    {
        const DLOAD_DLL_ENTRY *pEntry = &g_DllMap.pDllEntry[i];

        //
        //  Name must be lowercase.
        //
        char szLower[MAX_PATH];
        strcpy(szLower, pEntry->pszDll);
        _strlwr(szLower);
        if (strcmp(szLower, pEntry->pszDll) != 0)
        {
            fprintf(stderr, "DLCHECK : error DL000002 : Static delayload table is corrupted\n"
                            "          %s must be all-lowercase\n",
                            pEntry->pszDll);
            Errors = 1;
        }

        //
        // Ensure that the exports are in alphabetical order
        //
        {
            const DLOAD_PROCNAME_MAP *pProcNameMap = pEntry->pProcNameMap;

            if (pProcNameMap)
            {
                const DLOAD_PROCNAME_ENTRY *pProcNameEntry = pProcNameMap->pProcNameEntry;
                for (j = 1; j < pProcNameMap->NumberOfEntries; j++)
                {
                    if (strcmp(pProcNameEntry[j-1].pszProcName,
                               pProcNameEntry[j].pszProcName) >= 0)
                    {
                        fprintf(stderr, "DLCHECK : error DL000003 : Static delayload table is corrupted\n"
                                        "          %s.%s and %s.%s not in alphabetical order\n",
                                        g_DllMap.pDllEntry[i].pszDll,
                                        pProcNameEntry[j-1].pszProcName,
                                        g_DllMap.pDllEntry[i].pszDll,
                                        pProcNameEntry[j].pszProcName);

                        Errors = 1;
                    }
                }
            }
        }

        //
        // Ensure that the ordinals are in alphabetical order
        //
        {
            const DLOAD_ORDINAL_MAP *pOrdinalMap = pEntry->pOrdinalMap;

            if (pOrdinalMap)
            {
                const DLOAD_ORDINAL_ENTRY *pOrdinalEntry = pOrdinalMap->pOrdinalEntry;
                for (j = 1; j < pOrdinalMap->NumberOfEntries; j++)
                {
                    if (pOrdinalEntry[j-1].dwOrdinal >= pOrdinalEntry[j].dwOrdinal)
                    {
                        fprintf(stderr, "DLCHECK : error DL000001 : Static delayload table is corrupted\n"
                                        "          %s.%d and %s.%d not in numeric order\n",
                                        g_DllMap.pDllEntry[i].pszDll,
                                        pOrdinalEntry[j-1].dwOrdinal,
                                        g_DllMap.pDllEntry[i].pszDll,
                                        pOrdinalEntry[j-1].dwOrdinal);
                        Errors = 1;
                    }
                }
            }
        }

    }

    return Errors;
}

int
__cdecl
main (
    int c,
    char *v[]
    )
{
    PImgDelayDescr Imports;
    ULONG ImportSize;
    char *szName;
    PIMAGE_THUNK_DATA pINT;
    DelayLoadInfo dlinfo;
    FARPROC fp;
    int ReturnValue;
    BOOL fCallHandler;
    BOOL fPE32;

    if (*v[1] == '-' || *v[1] == '/') {
        switch ( *(v[1]+1) ) {
        case 's':
        case 'S':
            if (c != 3) {
                Usage();
            }
            strcpy(g_szImageName, v[2]);
            break;  // nothing needs to be done.

        case 'l':
        case 'L':
            __pfnFailureProc = (PfnKernel32HookProc)GetProcAddress(GetModuleHandleA("kernel32.dll"), "DelayLoadFailureHook");
            if (!__pfnFailureProc) {
                fprintf(stderr, "DLCHECK : fatal error %d: looking up kernel32 delayload hook\n", GetLastError());
                return 1;
            }   
            if (c != 3) {
                Usage();
            }
            strcpy(g_szImageName, v[2]);
            break;

        case 'i':
        case 'I':
            if (c != 3) {
                Usage();
            }
        {
            char szIniFile[MAX_PATH];
            char szTemp[MAX_PATH];
            char szTemp2[MAX_PATH];
            char* p = v[2];

            if (p[1] != ':')
            {
                // not a full path...
                GetCurrentDirectory(sizeof(szTemp), szTemp);
                sprintf(szIniFile, "%s\\%s", szTemp, v[2]);
            }
            
            GetPrivateProfileString("Default", "DelayLoadHandler", "", g_szDelayLoadHandler, sizeof(g_szDelayLoadHandler), szIniFile);

            // foomodule.dll.ini -> foomodule.dll
            strcpy(g_szImageName, v[2]);
            p = strstr(g_szImageName, ".ini");
            if (p)
            {
                *p = '\0';
            }

            if (_stricmp(g_szDelayLoadHandler, "FORCE") == 0)
            {
                // if the delayload handler is set to FORCE, we check the binary as if it were
                // using kernel32
                fForceCheckImage = TRUE;
            }

            if ((_stricmp(g_szDelayLoadHandler, "kernel32") != 0) &&
                (_stricmp(g_szDelayLoadHandler, "FORCE") != 0))
            {
                // currently only able to check dll's who use kernel32.dll for their delayload handler
                fprintf(stdout, "DLCHECK : warning DL000000 : Unable to check delayload failure behavior\n"
                                "          %s uses %s as a handler, not kernel32\n", g_szImageName, g_szDelayLoadHandler);
                return 0;
            }

            // foomodule.dll -> d:\binaries.x86chk\foomodule.dll
            if (ExpandEnvironmentStrings("%_NTPostBld%", szTemp, sizeof(szTemp)) == 0)
            {
                fprintf(stderr, "DLCHECK : fatal error : _NTPostBld environment variable not set\n");
                return 1;
            }
            GetPrivateProfileString("Default", "DestinationDir", "", szTemp2, sizeof(szTemp2), szIniFile);
            strcat(szTemp, "\\");
            strcat(szTemp, szTemp2);
            strcat(szTemp, g_szImageName);
            strcpy(g_szImageName, szTemp);
        }
        break;

        case 't':
        case 'T':
            if (c != 2) {
                Usage();
            }
            return ValidateStaticDelayloadStubs();

        case 'f':
        case 'F':
            if (c != 3)
            {
                Usage();
            }
            fForceCheckImage = TRUE;
            strcpy(g_szImageName, v[2]);
            break;  // nothing needs to be done.

        default:
            Usage();
        }
    } else {
        Usage();
    }

    g_pli = ImageLoad(g_szImageName, NULL);
    if (!g_pli) {
        fprintf(stderr, "DLCHECK : fatal error %d: loading '%s'\n", GetLastError(), g_szImageName);
        return 1;
    }
    Imports = (PImgDelayDescr)
                  ImageDirectoryEntryToDataEx(g_pli->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT,
                                            &ImportSize,
                                            &g_DelaySection
                                            );
    if (!Imports) {
        fprintf(stdout, "DLCHECK : warning DL000000: image '%s' has no delayload imports\n", g_szImageName);
        return 0;
    }

    fPE32 = g_pli->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ? TRUE : FALSE;

    if (fForceCheckImage)
    {
        fCallHandler = TRUE;
    }
    else
    {
        fCallHandler = ImageLinksToKernel32Handler();
    }

    if (!fCallHandler) {
        fprintf(stderr, "DLCHECK : fatal errror : DLL doesn't import kernel32!DelayLoadFailureHook.\n"
                        "(use -f option to override)\n"
                        "\n");
        return 1;
    }

    //
    // Walk each delayloaded DLL
    //
    ReturnValue = 0;    // assume success

    if (Imports->grAttrs & dlattrRva) {
        PImgDelayDescrV2 pImportsV2 = (PImgDelayDescrV2)Imports;
        szName = (char *)RvaToPtr(pImportsV2->rvaDLLName);
        pINT = (PIMAGE_THUNK_DATA)RvaToPtr(pImportsV2->rvaINT);
    } else {
        PImgDelayDescrV1 pImportsV1 = (PImgDelayDescrV1)Imports;
        szName = (char *)ConvertImagePointer((void *)pImportsV1->szName);
        pINT = (PIMAGE_THUNK_DATA)ConvertImagePointer((void *)pImportsV1->pINT);
    }

    while (szName) {
        // printf("DelayLoad DLL %s\n", szName);
        char szModuleName[MAX_PATH];
        char szImportName[MAX_PATH];
        
        {
            char* p;
            // change "module.dll" to just "module"
            strcpy(szModuleName, szName);
            p = szModuleName;
            while (*p != '\0')
            {
                if (*p == '.')
                {
                    *p = '\0';
                    break;
                }
                p++;
            }
        }

        //
        // Walk each function called from the delayloaded DLL
        //

        while (pINT->u1.AddressOfData) {
            dlinfo.cb = sizeof(dlinfo);
            dlinfo.pidd = NULL;
            dlinfo.ppfn = NULL;
            dlinfo.szDll = szName;
            dlinfo.pfnCur = NULL;
            dlinfo.dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            dlinfo.dlp.szProcName = NULL;   // Make sure the upper 32 bits are zeroed out on win64.

            if (
                ( fPE32 && IMAGE_SNAP_BY_ORDINAL32(((PIMAGE_THUNK_DATA32)pINT)->u1.AddressOfData)) ||
                (!fPE32 && IMAGE_SNAP_BY_ORDINAL64(((PIMAGE_THUNK_DATA64)pINT)->u1.AddressOfData))
               )
            {
                sprintf(szImportName, "Ordinal%d", IMAGE_ORDINAL(pINT->u1.AddressOfData));
                dlinfo.dlp.fImportByName = FALSE;
                dlinfo.dlp.dwOrdinal = IMAGE_ORDINAL((ULONG)pINT->u1.AddressOfData);
            } else {
                PIMAGE_IMPORT_BY_NAME pImport;
                if (Imports->grAttrs & dlattrRva) {
                    pImport = (PIMAGE_IMPORT_BY_NAME)RvaToPtr(pINT->u1.AddressOfData);
                } else {
                    pImport = (PIMAGE_IMPORT_BY_NAME)ConvertImagePointer((void *)pINT->u1.AddressOfData);
                }
                sprintf(szImportName, "%s", pImport->Name);
                dlinfo.dlp.fImportByName = TRUE;
                dlinfo.dlp.szProcName = pImport->Name;
            }

            if (fCallHandler) {
                //
                // Call the delayload handler and see what it does.
                //
                try {
                    fp = (*__pfnFailureProc)(dlinfo.szDll, dlinfo.dlp.szProcName);
                    if (!fp) {
                        fprintf(stderr, "DLCHECK : error DL000000: %s imports %s!%s which is not handled.\n", g_szImageName, szModuleName, szImportName);
                        ReturnValue = 1;
                    } else {
                        printf("DLCHECK : %s imports %s!%s - OK.\n", g_szImageName, szModuleName, szImportName);
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    fprintf(stderr, "DLCHECK : error %x: %s imports %s!%s - handler threw an exception.\n", GetExceptionCode(), g_szImageName, szModuleName, szImportName);
                    ReturnValue = 1;
                }
            }
            else
            {
                printf("DLCHECK : %s imports %s!%s - not checked.\n", g_szImageName, szModuleName, szImportName);
            }

            if (fPE32) {
                pINT = (PIMAGE_THUNK_DATA)(((PIMAGE_THUNK_DATA32)pINT)++);
            } else {
                pINT = (PIMAGE_THUNK_DATA)(((PIMAGE_THUNK_DATA64)pINT)++);
            }
        }
        if (Imports->grAttrs & dlattrRva) {
            PImgDelayDescrV2 pImportsV2 = (PImgDelayDescrV2)Imports;
            pImportsV2++;
            Imports = (PImgDelayDescr)pImportsV2;
            szName = (char *)RvaToPtr(pImportsV2->rvaDLLName);
            pINT = (PIMAGE_THUNK_DATA)RvaToPtr(pImportsV2->rvaINT);
        } else {
            PImgDelayDescrV1 pImportsV1 = (PImgDelayDescrV1)Imports;
            pImportsV1++;
            Imports = (PImgDelayDescr)pImportsV1;
            szName = (char *)ConvertImagePointer((void *)pImportsV1->szName);
            pINT = (PIMAGE_THUNK_DATA)ConvertImagePointer((void *)pImportsV1->pINT);
        }
    }

    if (ReturnValue == 0)
    {
        printf("DLCHECK : succeeded on %s \n", g_szImageName);
    }
    else
    {
        fprintf(stderr, "DLCHECK : failed on %s \n", g_szImageName);
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\ddk\legacy_files\drivinit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       drivinit.h
//
//----------------------------------------------------------------------------

// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dload\dload.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L O A D . C
//
//  Contents:   Delay Load Failure Hook
//
//  Notes:      This lib implements all of the stub functions for modules
//              that are delayloaded by the OS. It merges together all of the
//              dloadXXX.lib files from each depot.
//
//  To Use:     In your sources file, right after you specify the modules you
//              are delayloading do:
//
//                  DLOAD_ERROR_HANDLER=kernel32
//
//              If you want to use kernel32 as your dload error handler. If you
//              do this, your dll will be checked that everything it delayloads
//              has a proper error handler function by the delayload.cmd postbuild
//              script.
//
//              To check that all functions you delayload have error handlers you
//              can do the following:
//
//                  1. do a "link -dump -imports foo.dll", and find all functions 
//                     that you delay-import.
//
//                  2. do a "link -dump -symbols \nt\public\internal\base\lib\*\dload.lib"
//                     and make sure every function that shows up as delayloaded in step #1
//                     has a error handler fn. in dload.lib.
//
//                  3. if a function is missing in step #2 (dlcheck will also fails as 
//                     part of postbuild), you need to add an error handler. Go to the depot
//                     where that dll is build, and go to the dload subdir (usually under
//                     the root or under the published\dload subdir) and add an error handler.
//
//
//  Author:     shaunco   19 May 1998
//  Modified:   reinerf   12 Jan 2001   Changed above comment
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


// External global variables
//
extern HANDLE   BaseDllHandle;

#if DBG
extern int DloadBreakOnFail;
extern int DloadDbgPrint;
#endif

#if DBG

#define DBG_ERROR   0
#define DBG_INFO    1

//+---------------------------------------------------------------------------
// Trace a message to the debug console.  Prefix with who we are so
// people know who to contact.
//
INT
__cdecl
DbgTrace (
    INT     nLevel,
    PCSTR   Format,
    ...
    )
{
    INT cch = 0;
    if (DloadDbgPrint) {
    
        if (nLevel <= DBG_INFO)
        {
            CHAR    szBuf [1024];
            va_list argptr;
    
            va_start (argptr, Format);
            cch = vsprintf (szBuf, Format, argptr);
            va_end (argptr);
    
            OutputDebugStringA ("dload: ");
            OutputDebugStringA (szBuf);
        }
    }

    return cch;
}

//+---------------------------------------------------------------------------
// Cannot use RtlAssert since doing so will cause setupapi.dll to fail
// for upgrade over win95(gold)
//
VOID
WINAPI
DelayLoadAssertFailed(
    IN PCSTR FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCSTR Message OPTIONAL
    )
{
    DbgTrace (
        DBG_ERROR,
        "Assertion failure at line %u in file %s: %s%s%s\r\n",
        LineNumber,
        FileName,
        FailedAssertion,
        (Message && Message[0] && FailedAssertion[0]) ? " " : "",
        Message ? Message : ""
        );

    if (DloadBreakOnFail) {
        DebugBreak();
    }
}

#endif // DBG


//+---------------------------------------------------------------------------
//
//
FARPROC
WINAPI
DelayLoadFailureHook (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    )
{
    FARPROC ReturnValue = NULL;

    MYASSERT (pszDllName);
    MYASSERT (pszProcName);  

    // Trace some potentially useful information about why we were called.
    //
#if DBG
    if (!IS_INTRESOURCE(pszProcName))
    {
        DbgTrace (DBG_INFO,
            "DelayloadFailureHook: Dll=%s, ProcName=%s\n",
            pszDllName,
            pszProcName);
    }
    else
    {
        DbgTrace (DBG_INFO,
            "DelayloadFailureHook: Dll=%s, Ordinal=%u\n",
            pszDllName,
            (DWORD)((DWORD_PTR)pszProcName));
    }
#endif

    ReturnValue = LookupHandler(pszDllName, pszProcName);

    if (ReturnValue)
    {
#if DBG
        DbgTrace (DBG_INFO,
            "Returning handler function at address 0x%08x\n",
            (LONG_PTR)ReturnValue);
#endif
    }
#if DBG
    else
    {
        CHAR pszMsg [MAX_PATH];

        if (!IS_INTRESOURCE(pszProcName))
        {
            sprintf (pszMsg,
                "No delayload handler found for Dll=%s, ProcName=%s\n"
                "Please add one in private\\dload.",
                pszDllName,
                pszProcName);
        }
        else
        {
            sprintf (pszMsg,
                "No delayload handler found for Dll=%s, Ordinal=%u\n"
                "Please add one in private\\dload.",
                pszDllName,
                (DWORD)((DWORD_PTR)pszProcName));
        }

        DelayLoadAssertFailed ( "" , __FILE__, __LINE__, pszMsg);
    }
#endif

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dload\dloaddefaultbreak.c ===
#include "pch.h"
int DloadBreakOnFail = TRUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dload\dloaddefaulttrace.c ===
#include "pch.h"
int DloadDbgPrint = TRUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dload\pch.h ===
#pragma once

#include <dloadexcept.h>
#include "dload.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dload\wmi.c ===
#include "pch.h"
#pragma hdrstop

#define _WMI_SOURCE_
#include <wmium.h>

static
ULONG
WMIAPI
WmiNotificationRegistrationA(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
ULONG
WMIAPI
WmiNotificationRegistrationW(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wmi)
{
    DLPENTRY(WmiNotificationRegistrationA)
    DLPENTRY(WmiNotificationRegistrationW)
};

DEFINE_PROCNAME_MAP(wmi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dload\dloadexcept.h ===
#pragma once

// Our primary client is kernel32.dll.  Because we use APIs exported
// by kernel32.dll, we need to build this static library as if we
// are kernel32.dll.  If we don't we get link warnings like:
// warning LNK4049: locally defined symbol "_OutputDebugStringA@4" imported
// warning LNK4049: locally defined symbol "_SetLastError@4" imported
//
// Other clients of this library will just go through the import thunk
// instead of doing a call indirect for these APIs.
//
#define _KERNEL32_

// "Build as if we are advapi32.dll. If we don't we get" compiler errors like:
// advapi.c : error C2491: 'RegCreateKeyExW' : definition of dllimport function not allowed
#define _ADVAPI32_
// same problem..
#define _RPCRT4_
#define _USER32_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <delayimp.h>
#include <stdio.h>
#include <wtypes.h>

#include <dloaddef.h>

#if DBG

//
// DelayLoadAssertFailed/MYASSERT used instead of RtlAssert/ASSERT
// as dload is also compiled to run on Win95
//

VOID
WINAPI
DelayLoadAssertFailed(
    IN PCSTR FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCSTR Message OPTIONAL
    );

VOID
WINAPI
AssertDelayLoadFailureMapsAreSorted(
    VOID
    );

#define MYASSERT(x)     if(!(x)) { DelayLoadAssertFailed(#x,__FILE__,__LINE__,NULL); }

#else

#define MYASSERT(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dload\downlevel_dload.c ===
#include "pch.h"
#pragma hdrstop

// External function prototypes
FARPROC
WINAPI
DelayLoadFailureHook (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    );


//
// This function is for people who statically link to dload.lib so that
// the can get all of kernel32's dload error stubs on any os <= Whistler.
//

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// NOTE: You should ONLY use this if you have a binary that must run on NT4, win2k, win9x, etc.
//       If your binary is whistler or greater, use DLOAD_ERROR_HANDLER=kernel32 in your
//       sources file instead.
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

FARPROC
WINAPI
Downlevel_DelayLoadFailureHook(
    UINT unReason,
    PDelayLoadInfo pDelayInfo
    )
{
    FARPROC ReturnValue = NULL;

    // For a failed LoadLibrary, we will return the HINSTANCE of this DLL.
    // This will cause the loader to try a GetProcAddress on our DLL for the
    // function.  This will subsequently fail and then we will be called
    // for dliFailGetProc below.
    if (dliFailLoadLib == unReason)
    {
        // HACKHACK (reinerf)
        //
        // For ORDINAL delayload failures we cannot just return our base addr and be done with everything. The problem 
        // is that the linker stub code will turn around and call GetProcAddress() some random ordinal which probably 
        // exists and is definately NOT the correct function.
        //
        // So to get around this problem we return -1 for a the hModule, which should cause GetProcAddress(-1, ...) to
        // always fail. This is good, because the linker code will call us back for the GetProcAddress failure and we
        // can then return the stub error handler proc.
        ReturnValue = (FARPROC)-1;
    }
    else if (dliFailGetProc == unReason)
    {
        // The loader is asking us to return a pointer to a procedure.
        // Lookup the handler for this DLL/procedure and, if found, return it.
        ReturnValue = DelayLoadFailureHook(pDelayInfo->szDll, pDelayInfo->dlp.szProcName);

        if (ReturnValue)
        {
            // Do this on behalf of the handler now that it is about to
            // be called.
            SetLastError(ERROR_MOD_NOT_FOUND);
        }
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\dload\lookup.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L O O K U P . C
//
//  Contents:   Routines to find a handler for a DLL procedure.
//
//  Notes:
//
//  Author:     shaunco   21 May 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


VOID
WINAPI
AssertDelayLoadFailureMapsAreSorted (
    VOID
    )
{
#if DBG // Leave the function existing in free builds for binary compat on mixed checked/free,
        // since the checked in .lib is only free.
    UINT iDll, iProcName, iOrdinal;
    INT  nRet;
    CHAR pszMsg [1024];

    const DLOAD_DLL_ENTRY*      pDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;

    for (iDll = 0;
         iDll < g_DllMap.NumberOfEntries;
         iDll++)
    {
        if (iDll >= 1)
        {
            nRet = strcmp (
                        g_DllMap.pDllEntry[iDll].pszDll,
                        g_DllMap.pDllEntry[iDll-1].pszDll);

            if (nRet <= 0)
            {
                sprintf (pszMsg,
                    "dload: rows %u and %u are out of order in dload!g_DllMap",
                    iDll-1, iDll);

                DelayLoadAssertFailed ( "" , __FILE__, __LINE__, pszMsg);
            }
        }

        pDll = g_DllMap.pDllEntry + iDll;
        pProcNameMap = pDll->pProcNameMap;
        pOrdinalMap  = pDll->pOrdinalMap;

        if (pProcNameMap)
        {
            MYASSERT (pProcNameMap->NumberOfEntries);

            for (iProcName = 0;
                 iProcName < pProcNameMap->NumberOfEntries;
                 iProcName++)
            {
                if (iProcName >= 1)
                {
                    nRet = strcmp (
                                pProcNameMap->pProcNameEntry[iProcName].pszProcName,
                                pProcNameMap->pProcNameEntry[iProcName-1].pszProcName);

                    if (nRet <= 0)
                    {
                        sprintf (pszMsg,
                            "dload: rows %u and %u of pProcNameMap are out "
                            "of order in dload!g_DllMap for pszDll=%s",
                            iProcName-1, iProcName, pDll->pszDll);

                        DelayLoadAssertFailed ( "" , __FILE__, __LINE__, pszMsg);
                    }
                }
            }
        }

        if (pOrdinalMap)
        {
            MYASSERT (pOrdinalMap->NumberOfEntries);

            for (iOrdinal = 0;
                 iOrdinal < pOrdinalMap->NumberOfEntries;
                 iOrdinal++)
            {
                if (iOrdinal >= 1)
                {
                    if (pOrdinalMap->pOrdinalEntry[iOrdinal].dwOrdinal <=
                        pOrdinalMap->pOrdinalEntry[iOrdinal-1].dwOrdinal)
                    {
                        sprintf (pszMsg,
                            "dload: rows %u and %u of pOrdinalMap are out "
                            "of order in dload!g_DllMap for pszDll=%s",
                            iOrdinal-1, iOrdinal, pDll->pszDll);

                        DelayLoadAssertFailed ( "" , __FILE__, __LINE__, pszMsg);
                    }
                }
            }
        }
    }
#endif
}


const DLOAD_DLL_ENTRY*
FindDll (
    LPCSTR pszDll
    )
{
    const DLOAD_DLL_ENTRY* pDll = NULL;

    CHAR pszDllLowerCased [MAX_PATH + 1];
    INT nResult;

    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and nResult < 0.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    MYASSERT (pszDll);
    MYASSERT (strlen (pszDll) <= MAX_PATH);

    strcpy (pszDllLowerCased, pszDll);
    _strlwr (pszDllLowerCased);

    iLow = 0;
    iHigh = g_DllMap.NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        nResult = strcmp (pszDllLowerCased, g_DllMap.pDllEntry[iMiddle].pszDll);

        if (nResult < 0)
        {
            iHigh = iMiddle - 1;
        }
        else if (nResult > 0)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            MYASSERT (0 == nResult);
            pDll = &g_DllMap.pDllEntry[iMiddle];
            break;
        }
    }

    return pDll;
}

FARPROC
LookupHandlerByName (
    LPCSTR                      pszProcName,
    const DLOAD_PROCNAME_MAP*   pMap
    )
{
    FARPROC pfnHandler = NULL;

    INT nResult;

    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and nResult < 0.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    MYASSERT (pszProcName);

    iLow = 0;
    iHigh = pMap->NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        nResult = strcmp (
                    pszProcName,
                    pMap->pProcNameEntry[iMiddle].pszProcName);

        if (nResult < 0)
        {
            iHigh = iMiddle - 1;
        }
        else if (nResult > 0)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            MYASSERT (0 == nResult);
            pfnHandler = pMap->pProcNameEntry[iMiddle].pfnProc;
            break;
        }
    }

    return pfnHandler;
}

FARPROC
LookupHandlerByOrdinal (
    DWORD                       dwOrdinal,
    const DLOAD_ORDINAL_MAP*    pMap
    )
{
    FARPROC pfnHandler = NULL;

    DWORD dwOrdinalProbe;

    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and dwOrdinal < dwOrdinalProbe.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    iLow = 0;
    iHigh = pMap->NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        dwOrdinalProbe = pMap->pOrdinalEntry[iMiddle].dwOrdinal;

        if (dwOrdinal < dwOrdinalProbe)
        {
            iHigh = iMiddle - 1;
        }
        else if (dwOrdinal > dwOrdinalProbe)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            MYASSERT (dwOrdinal == dwOrdinalProbe);
            pfnHandler = pMap->pOrdinalEntry[iMiddle].pfnProc;
            break;
        }
    }

    return pfnHandler;
}

FARPROC
LookupHandler (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    )
{
    FARPROC                 pfnHandler = NULL;
    const DLOAD_DLL_ENTRY*  pDll;

    MYASSERT (pszDllName);
    MYASSERT (pszProcName);

    // Find the DLL record if we have one.
    //
    pDll = FindDll (pszDllName);
    if (pDll)
    {
        // Now find the handler whether it be by name or ordinal.
        //
        if (!IS_INTRESOURCE(pszProcName) &&
            pDll->pProcNameMap)
        {
            pfnHandler = LookupHandlerByName (
                            pszProcName,
                            pDll->pProcNameMap);
        }
        else if (pDll->pOrdinalMap)
        {
            pfnHandler = LookupHandlerByOrdinal (
                            PtrToUlong(pszProcName),
                            pDll->pOrdinalMap);
        }
    }

    return pfnHandler;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\sources.inc ===
#
# This file is designed to be included from 2 levels below
# (ie, daytona\srv, daytona\wks, cairo\srv, or cairo\wks).
#

#
# include definition of PRERELEASE
#
!include prerelease.inc

TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=LIBRARY

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=

#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
NTTARGETFILE0=make_infs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\prerelease.inc ===
#
# This file is used to control build options that should only appear in
# internal releases, and NOT the beta or RTM releases.  This controls
# features such as the GUI mode command prompt and the Win9x upgrade
# autostress option.
#
# To change, simply set PRERELEASE to 1 for private builds, or 0 for beta
# or RTM builds.
#
# **CHANGES HERE WILL REQUIRE A CLEAN BUILD OF THE SetupInfs and sub-components **
#

!ifndef PRERELEASE
PRERELEASE=0
!endif

!ifndef PRERELEASE_IDWLOG
PRERELEASE_IDWLOG=0
!endif

!if $(PRERELEASE)
C_DEFINES=$(C_DEFINES) -DPRERELEASE
!endif

!if $(PRERELEASE_IDWLOG)
C_DEFINES=$(C_DEFINES) -DPRERELEASE_IDWLOG
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\makefile.inc ===
#
# For daytona, this file is designed to be included from 3 levels below
# ie, dayona\$(LANGUAGE)inf\srv, or daytona\$(LANGUAGE)inf\wks
#
# Note: NEC98 builds go through this file twice, the second time
# with "ALT_PROJECT"=="NEC_98".  These latter produce a subset
# of binaries which are only used on NEC98 machines.
#


!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

#
# ANSI_CODEPAGE:  ANSI codepage for a given language.
#
# LANGUAGE_DRVCAB:  Offset to the language-specific list of files
#   contained in driver.cab:
#      setup\inf\win4\inf\lib\<language_drvcab>\<arch>\sorted.lst
#   European languages having a very similar set of files as US may
#   be able to leverage the US sorted.lst.  Far East languages have
#   extra files and their own language-specific list.
#
# LCID:  Locale ID in hex.
#
# UNITEXT_OPT:  Unitext.exe command line options to specify the ANSI codepage
#   for a given language.  Used for Multibuyte -> Unicode conversion.
#

# Defaults
ANSI_CODEPAGE=1252
LCID=409
LANGUAGE_DRVCAB=$(LANGUAGE)

!if "$(LANGUAGE)"=="ARA" || "$(LANGUAGE)"=="ara"
# Arabic
ANSI_CODEPAGE=1256
LCID=401

!elseif "$(LANGUAGE)"=="BR" || "$(LANGUAGE)"=="br"
# Portuguese, Brazilian
ANSI_CODEPAGE=1252
LCID=416

!elseif "$(LANGUAGE)"=="CHH" || "$(LANGUAGE)"=="chh"
# Chinese, Traditional (Hong Kong)
ANSI_CODEPAGE=950
LCID=C04

!elseif "$(LANGUAGE)"=="CHS" || "$(LANGUAGE)"=="chs"
# Chinese, Simplified
ANSI_CODEPAGE=936
LCID=804

!elseif "$(LANGUAGE)"=="CHT" || "$(LANGUAGE)"=="cht"
# Chinese, Traditional (Taiwan)
ANSI_CODEPAGE=950
LCID=404

!elseif "$(LANGUAGE)"=="CS" || "$(LANGUAGE)"=="cs"
# Czech
ANSI_CODEPAGE=1250
LCID=405

!elseif "$(LANGUAGE)"=="DA" || "$(LANGUAGE)"=="da"
# Danish
ANSI_CODEPAGE=1252
LCID=406

!elseif "$(LANGUAGE)"=="EL" || "$(LANGUAGE)"=="el"
# Greek
ANSI_CODEPAGE=1253
LCID=408

!elseif "$(LANGUAGE)"=="ES" || "$(LANGUAGE)"=="es"
# Spanish
ANSI_CODEPAGE=1252
LCID=C0A

!elseif "$(LANGUAGE)"=="FI" || "$(LANGUAGE)"=="fi"
# Finish
ANSI_CODEPAGE=1252
LCID=40b

!elseif "$(LANGUAGE)"=="FR" || "$(LANGUAGE)"=="fr"
# French
ANSI_CODEPAGE=1252
LCID=40C

!elseif "$(LANGUAGE)"=="GER" || "$(LANGUAGE)"=="ger"
# German
ANSI_CODEPAGE=1252
LCID=407

!elseif "$(LANGUAGE)"=="HEB" || "$(LANGUAGE)"=="heb"
# Hebrew
ANSI_CODEPAGE=1255
LCID=40D

!elseif "$(LANGUAGE)"=="HU" || "$(LANGUAGE)"=="hu"
# Hungarian
ANSI_CODEPAGE=1250
LCID=40e

!elseif "$(LANGUAGE)"=="IT" || "$(LANGUAGE)"=="it"
# Italian
ANSI_CODEPAGE=1252
LCID=410

!elseif "$(LANGUAGE)"=="JPN" || "$(LANGUAGE)"=="jpn"
# Japanese
ANSI_CODEPAGE=932
LCID=411

!elseif "$(LANGUAGE)"=="KOR" || "$(LANGUAGE)"=="kor"
# Korean
ANSI_CODEPAGE=949
LCID=412

!elseif "$(LANGUAGE)"=="NL" || "$(LANGUAGE)"=="nl"
# Dutch
ANSI_CODEPAGE=1252
LCID=413

!elseif "$(LANGUAGE)"=="NO" || "$(LANGUAGE)"=="no"
# Norwegian
ANSI_CODEPAGE=1252
LCID=414

!elseif "$(LANGUAGE)"=="PL" || "$(LANGUAGE)"=="pl"
# Polish
ANSI_CODEPAGE=1250
LCID=415

!elseif "$(LANGUAGE)"=="PSU" || "$(LANGUAGE)"=="psu"
# Pseudo-loc
ANSI_CODEPAGE=1253
LCID=408

!elseif "$(LANGUAGE)"=="PT" || "$(LANGUAGE)"=="pt"
# Portuguese
ANSI_CODEPAGE=1252
LCID=816

!elseif "$(LANGUAGE)"=="RU" || "$(LANGUAGE)"=="ru"
# Russian
ANSI_CODEPAGE=1251
LCID=419

!elseif "$(LANGUAGE)"=="SV" || "$(LANGUAGE)"=="sv"
# Swedish
ANSI_CODEPAGE=1252
LCID=41D

!elseif "$(LANGUAGE)"=="TR" || "$(LANGUAGE)"=="tr"
# Turkish
ANSI_CODEPAGE=1254
LCID=41F

!endif

UNITEXT_OPT=-m -$(ANSI_CODEPAGE)

!IF "$(TARGET_DIRECTORY)"=="i386"  || "$(TARGET_DIRECTORY)"=="I386"
PLATFORM_SWITCH=i
!ELSEIF "$(TARGET_DIRECTORY)"=="ia64"  || "$(TARGET_DIRECTORY)"=="IA64"
PLATFORM_SWITCH=m
!ELSEIF "$(TARGET_DIRECTORY)"=="amd64"  || "$(TARGET_DIRECTORY)"=="AMD64"
PLATFORM_SWITCH=a
!ELSE
! ERROR Invalid Platform Switch for infs
!ENDIF

!ifndef QFE_NUM
QFE_NUM=0
!endif

STAMP=stampinf -f $@
PREFLAGS=/DLANGUAGE_ID=0x0$(LCID) -nologo /EP
!if $(PRERELEASE)
PREFLAGS=/DPRERELEASE $(PREFLAGS)
!endif

!if $(PRERELEASE_IDWLOG)
PREFLAGS=/DPRERELEASE_IDWLOG $(PREFLAGS)
!endif

PREFILTFLAGS=/EP -DPLATFORM_SWITCH='$(PLATFORM_SWITCH)' -DPRODSWITCH='$(PRODSWITCH)'

_LNG=..\..\..\$(LANGUAGE)
_LIBLNG=..\..\..\lib\$(LANGUAGE)
_INX=..\..\..
_INF=$(O)
_RSINF=$(O)\realsign

BUILD_COVINF=0
!if "$(LANGUAGE)"=="usa" || "$(LANGUAGE)"=="USA"
!if !$(WIN64)
_COVINF=$(O)\covinf
_RSCOVINF=$(O)\covinf\realsign
BUILD_COVINF=1
!endif
!endif

STRIPCHAR=call $(_INX)\stripchar.cmd

!ifndef BUILD_SPECIFIC_INFS

!IF "$(ALT_PROJECT_TARGET)" == "CHH"
make_infs:$(O)\hivesft.inf
!ELSE
make_infs:$(O)\layout.inf    \
          $(_RSINF)\layout.inf  \
!IF $(BUILD_COVINF)
          $(_COVINF)\layout.inx  \
          $(_COVINF)\layout.inf  \
          $(_RSCOVINF)\layout.inf  \
!endif
          $(O)\testroot.cer  \
          $(O)\layout.inx    \
          $(O)\layout.txt    \
          $(O)\1394.inf      \
          $(O)\1394vdbg.inf  \
          $(O)\61883.inf     \
          $(O)\accessor.inf  \
!if $(WIN64)
          $(O)\accessor.wow  \
!endif
!IF !$(WIN64)
          $(O)\acerscan.inf  \
!endif
          $(O)\acpi.inf      \
          $(O)\apps.inf      \
          $(O)\apcompat.inf  \
!if $(WIN64)
          $(O)\apcompat.wow  \
!endif
!if "$(PRODSWITCH)" == "w"
          $(O)\apphlpui.inf  \
!endif
          $(O)\asroc.inf     \
          $(O)\avc.inf       \
          $(O)\battery.inf   \
          $(O)\bda.inf       \
!if $(386)
          $(O)\bfcab.inf     \
!endif
          $(O)\biosinfo.inf  \
!if $(386)
          $(O)\brmfcmdm.inf  \
          $(O)\brmfcmf.inf   \
          $(O)\brmfcsto.inf  \
          $(O)\brmfcumd.inf  \
          $(O)\brmfcwia.inf  \
          $(O)\brmfport.inf  \
!endif
          $(O)\camdsh20.inf  \
          $(O)\camvid20.inf  \
          $(O)\camvid30.inf  \
          $(O)\ccdecode.inf   \
          $(O)\cdrom.inf     \
          $(O)\certclas.inf  \
          $(O)\communic.inf  \
!if $(WIN64)
          $(O)\communic.wow  \
!endif
          $(O)\compatws.inf  \
          $(O)\cpu.inf       \
          $(O)\cyclad-z.inf  \
          $(O)\cyclom-y.inf  \
          $(O)\cyyport.inf   \
          $(O)\cyzport.inf   \
          $(O)\dbc.inf       \
          $(O)\dcfirst.inf   \
          $(O)\dcup.inf      \
          $(O)\dcup5.inf     \
          $(O)\defltdc.inf   \
          $(O)\defltsv.inf   \
          $(O)\defltwk.inf   \
          $(O)\defltp.inf    \
!IF $(BUILD_COVINF)
          $(_COVINF)\defltsv.inf \
          $(_COVINF)\defltwk.inf \
!endif
          $(O)\devxprop.inf  \
          $(O)\dfrg.inf      \
          $(O)\disk.inf      \
!IF !$(WIN64)
          $(O)\dimaps.inf    \
!endif
          $(O)\dispdet.inf   \
          $(O)\display.inf   \
          $(O)\dmreg.inf     \
          $(O)\dosnet.inf    \
          $(_RSINF)\dosnet.inf  \
!IF $(BUILD_COVINF)
          $(_COVINF)\dosnet.inf    \
          $(_RSCOVINF)\dosnet.inf \
!endif
          $(O)\dot4.inf      \
          $(O)\dot4prt.inf   \
          $(O)\dpup.inf      \
          $(O)\drvindex.inf  \
          $(O)\drivercab.inf \
          $(O)\dshowext.inf  \
          $(O)\dsup.inf      \
          $(O)\dsupt.inf     \
          $(O)\dvd.inf       \
          $(O)\dwup.inf      \
!IF !$(WIN64)
          $(O)\epcfw2k.inf   \
          $(O)\epstw2k.inf   \
          $(O)\epsnscan.inf  \
!endif
          $(O)\epsnmfp.inf   \
          $(O)\epstw2k.inf   \
!if "$(PRODSWITCH)" == "w"
          $(O)\ermui.inf     \
!endif
!IF $(BUILD_COVINF)
          $(_COVINF)\dsup.inf \
          $(_COVINF)\dsupt.inf \
          $(_COVINF)\dwup.inf \
!endif
          $(O)\exclude.inf   \
          $(O)\fdc.inf       \
          $(O)\filegen.inf   \
          $(O)\fjtscan.inf   \
          $(O)\flash.inf     \
          $(O)\flpydisk.inf  \
          $(O)\font.inf      \
!if !$(WIN64)
          $(O)\gameport.inf  \
!endif
          $(O)\games.inf     \
!if $(WIN64)
          $(O)\games.wow     \
!endif
          $(O)\genprint.inf  \
!if "$(PRODSWITCH)" == "w"
          $(O)\guidrvs.inf   \
!endif
          $(O)\hal.inf       \
          $(O)\hiddigi.inf   \
          $(O)\hidserv.inf   \
          $(O)\hfltpci.inf   \
          $(O)\hisecws.inf   \
          $(O)\hisecdc.inf   \
          $(O)\hivecls.inf   \
          $(O)\hivedef.inf   \
          $(O)\hivesft.inf   \
          $(O)\hivesys.inf   \
!if $(WIN64)
          $(O)\hivcls32.inf  \
          $(O)\hivsft32.inf  \
!endif
!IF $(BUILD_COVINF)
          $(_COVINF)\hivesys.inf   \
!endif
          $(O)\hiveusd.inf   \
          $(O)\hotfix.inf    \
!IF !$(WIN64)
          $(O)\hpdigwia.inf  \
!endif
          $(O)\hpojscan.inf  \
          $(O)\hpscan.inf    \
          $(O)\ibmvcap.inf   \
          $(O)\icwnt5.inf    \
!if $(WIN64)
          $(O)\icwnt5.wow    \
!endif
          $(O)\ie.inf        \
          $(O)\ieaccess.inf  \
!if $(WIN64)
          $(O)\ie.wow        \
!endif
!if "$(PRODSWITCH)" == "w"
          $(O)\ie5ui.inf     \
!endif
          $(O)\icam3.inf     \
          $(O)\icam4usb.inf  \
          $(O)\icam5usb.inf  \
          $(O)\image.inf     \
          $(O)\infsect.tbl   \
          $(O)\input.inf     \
          $(O)\install.ins   \
          $(O)\intl.inf      \
!if $(WIN64)
          $(O)\intl.wow      \
          $(O)\intlinfa.wow  \
!endif
          $(O)\irbus.inf     \
!if $(WIN64)
          $(O)\is_wow64.inf  \
!endif
          $(O)\keyboard.inf  \
          $(O)\kdk2x0.inf    \
!IF !$(WIN64)
          $(O)\kodak.inf     \
!endif
          $(O)\kdkscan.inf   \
          $(O)\ks.inf        \
          $(O)\kscaptur.inf  \
          $(O)\ksfilter.inf  \
!if "$(PRODSWITCH)" == "w"
          $(O)\langinst.inf  \
!endif
          $(O)\legacy.inf    \
          $(O)\legcydrv.inf  \
!if $(386)
          $(O)\lwusbhid.inf  \
          $(O)\lwngmadi.inf  \
!endif
          $(O)\machine.inf   \
          $(O)\mchgr.inf     \
          $(O)\mdac.inf      \
!if $(WIN64)
          $(O)\mdac.wow      \
!endif
          $(O)\mdacwx86.inf  \
          $(O)\memcard.inf   \
          $(O)\mednames.txt  \
          $(O)\memory.inf    \
          $(O)\memstpci.inf  \
          $(O)\mf.inf        \
          $(O)\mfsocket.inf  \
!if $(386)
          $(O)\migdb.inf     \
!endif
          $(O)\minioc.inf    \
          $(O)\mmdriver.inf  \
          $(O)\mmopt.inf     \
!if $(WIN64)
          $(O)\mmopt.wow     \
!endif
!if !$(WIN64)
!if "$(PRODSWITCH)" == "w"
          $(O)\moviemui.inf  \
!endif
!endif
          $(O)\mpe.inf       \
          $(O)\mscpqpa1.inf   \
          $(O)\msdv.inf      \
          $(O)\mshdc.inf     \
          $(O)\msinfo32.inf  \
!if $(WIN64)
          $(O)\msinfo32.wow  \
!endif
          $(O)\msmail.inf    \
          $(O)\msmouse.inf   \
!IF !$(WIN64)
          $(O)\msmscsi.inf   \
          $(O)\msmusb.inf    \
!endif
          $(O)\msnike.inf   \
          $(O)\msoe50.inf    \
!if $(WIN64)
          $(O)\msoe50.wow    \
!endif
          $(O)\msports.inf   \
          $(O)\msrio8.inf   \
          $(O)\msrio.inf    \
          $(O)\mstape.inf    \
          $(O)\mstask.inf    \
!if $(WIN64)
          $(O)\mstask.wow    \
!endif
!if "$(PRODSWITCH)" == "w"
          $(O)\mui.inf       \
!endif
          $(O)\multimed.inf  \
!if $(WIN64)
          $(O)\multimed.wow  \
!endif
          $(O)\multiprt.inf  \
          $(O)\mxboard.inf   \
          $(O)\mxport.inf    \
          $(O)\nabtsfec.inf  \
          $(O)\ndisip.inf    \
          $(O)\netbeac.inf   \
          $(O)\netdav.inf    \
          $(O)\netip6.inf    \
          $(O)\nettun.inf    \
          $(O)\ntapm.inf     \
          $(O)\ntautorun.inf \
!IF !$(WIN64)
          $(O)\ntgrip.inf  \
!endif
          $(O)\ntprint.inf   \
          $(O)\ocmri.inf     \
          $(O)\oeaccess.inf  \
          $(O)\oobe.inf      \
!if "$(PRODSWITCH)" == "w"
          $(O)\oobemui.inf   \
!endif
      $(O)\optional.inf  \
!if $(WIN64)
          $(O)\optional.wow  \
!endif
          $(O)\ovcam.inf     \
          $(O)\ovcomp.inf    \
          $(O)\ovsound.inf   \
          $(O)\pcmcia.inf    \
          $(O)\perms.inf     \
          $(O)\phdsext.inf   \
          $(O)\phil1vid.inf  \
          $(O)\phil2vid.inf  \
          $(O)\phildec.inf   \
          $(O)\philtune.inf  \
          $(O)\pinball.inf   \
!if $(WIN64)
          $(O)\pinball.wow   \
!endif
!if "$(PRODSWITCH)" == "w"
          $(O)\pchmui.inf    \
!endif
          $(O)\pchealth.inf  \
!IF !$(WIN64)
          $(O)\pmxmcro.inf   \
!endif
          $(O)\pnpscsi.inf   \
          $(O)\ppa.inf       \
          $(O)\ppa3.inf      \
          $(O)\printupg.inf  \
          $(O)\prod128.ini   \
          $(O)\prodspec.ini  \
          $(O)\prtupg9x.inf  \
          $(O)\ptpusb.inf  \
          $(O)\ramdisk.inf   \
          $(O)\reminst.inf   \
          $(O)\ricoh.inf  \
          $(O)\rinorprt.sif  \
          $(O)\riprep.inf    \
          $(O)\ristndrd.sif  \
          $(O)\rootsec.inf   \
          $(O)\rsoptcom.inf  \
          $(O)\rsoptwks.inf  \
          $(O)\sbp2.inf      \
          $(O)\sceregvl.inf  \
!if !$(WIN64)
          $(O)\scsi.inf      \
!endif
          $(O)\scsidev.inf   \
          $(O)\sdwndr2k.inf  \
          $(O)\securedc.inf  \
          $(O)\securews.inf  \
          $(O)\secrecs.inf   \
          $(O)\sfcgen.inf    \
          $(O)\shell.inf     \
          $(O)\shl_img.inf   \
!if "$(PRODSWITCH)" == "w"
          $(O)\shellmui.inf  \
!endif
!if "$(PRODSWITCH)" == "w"
          $(O)\skinsmui.inf  \
          $(O)\wmtrmui.inf  \
!endif
          $(O)\slip.inf      \
          $(O)\smartcrd.inf  \
          $(O)\sonypvu1.inf  \
          $(O)\spmap.txt     \
!if !$(WIN64)
          $(O)\sr.inf        \
!endif
          $(O)\srchasst.inf  \
!if "$(PRODSWITCH)" == "w"
          $(O)\srchmui.inf     \
!endif
!IF !$(WIN64)
          $(O)\srusbusd.inf  \
!endif
          $(O)\sti.inf       \
!IF !$(WIN64)
          $(O)\stillcam.inf  \
!endif
          $(O)\streamip.inf  \
          $(O)\swflash.inf   \
          $(O)\swnt.inf      \
          $(O)\sysoc.inf     \
          $(O)\syscomp.inf   \
          $(O)\syssetup.inf  \
          $(O)\syssetup.inx  \
!if $(WIN64)
          $(O)\syssetup.wow  \
!endif
!IF $(BUILD_COVINF)
          $(_COVINF)\syssetup.inf  \
!endif
!if $(386)
!if "$(PRODSWITCH)" == "w"
          $(O)\tabletpc.inf   \
          $(O)\tabletmui.inf \
!endif
!endif
          $(O)\tape.inf      \
!if $(386)
!if "$(PRODSWITCH)" == "w"
          $(O)\tourmui.inf   \
!endif
!endif
          $(O)\tsbvcap.inf   \
          $(O)\txtsetup.sif  \
          $(O)\txtsetup.inx  \
          $(_RSINF)\txtsetup.sif \
!IF $(BUILD_COVINF)
          $(_COVINF)\txtsetup.sif  \
          $(_RSCOVINF)\txtsetup.sif \
!endif
!if !$(WIN64)
          $(O)\umax.inf      \
          $(O)\umaxpp.inf    \
!endif
          $(O)\unknown.inf   \
          $(O)\update.inf    \
          $(O)\usb.inf       \
          $(O)\usbport.inf   \
          $(O)\usbstor.inf   \
          $(O)\usbprint.inf  \
!if $(386)
          $(O)\usermig.inf   \
!endif
          $(O)\vgx.inf    \
!if $(WIN64)
          $(O)\vgx.wow  \
!endif
          $(O)\volume.inf    \
          $(O)\volsnap.inf   \
!if $(386)
          $(O)\vscandb.inf   \
!endif
          $(O)\wdmjoy.inf    \
!if $(WIN64)
!if "$(PRODSWITCH)" == "w"
          $(O)\wie5ui.inf     \
!endif
!endif
!if $(WIN64)
!if "$(PRODSWITCH)" == "w"
          $(O)\wermui.inf     \
!endif
!endif
!if $(386)
          $(O)\win95upg.inf  \
          $(O)\wkstamig.inf  \
!endif
          $(O)\au.inf \
          $(O)\wab50.inf     \
!if $(WIN64)
          $(O)\wab50.wow     \
!endif
          $(O)\wbemoc.inf    \
!if $(WIN64)
          $(O)\wbemoc.wow    \
!endif
          $(O)\wbemsnmp.inf  \
          $(O)\wceusbsh.inf \
!if "$(PRODSWITCH)" == "w"
          $(O)\wmprfmui.inf  \
!endif
          $(O)\sapi5.inf     \
          $(O)\wordpad.inf   \
!if $(WIN64)
          $(O)\wordpad.wow   \
          $(O)\wowexcp.txt   \
          $(O)\wowfile.inf   \
          $(O)\wowfiled.inf  \
          $(O)\wowlist.inf   \
          $(O)\wowfrege.inf  \
          $(O)\wowfregc.inf  \
          $(O)\wowfrego.inf  \
!endif
          $(O)\wsh.inf       \
!if $(WIN64)
          $(O)\wsh.wow  \
!endif
          $(O)\wstcodec.inf  \
          $(O)\xscan_xp.inf
!ENDIF

!else           # ifdef BUILD_SPECIFIC_INFS

#
# Dev time saver -- build only the $(O) targets specified by
# BUILD_SPECIFIC_INFS. This variable is a space-separated list such as
#
# set BUILD_SPECIFIC_INFS=layout.inf syssetup.inf
#
# Does not support targets other than those in obj\i386, obj\amd64, or obj\ia64.
#
# NOTE: NMAKE does not support variable replacement strings in macro
# search/replace. So define inference rules for known $(O) combinations
#

! if "$(O)" == "obj\i386"

make_infs:$(O)\$(BUILD_SPECIFIC_INFS: = obj\i386\)

! else if "$(O)" == "obj\amd64"

make_infs:$(O)\$(BUILD_SPECIFIC_INFS: = obj\amd64\)

! else if "$(O)" == "obj\ia64"

make_infs:$(O)\$(BUILD_SPECIFIC_INFS: = obj\ia64\)

! endif

!endif          # else BUILD_SPECIFIC_INFS


!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD)
!ENDIF

!IFDEF PERSONALINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b perinf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b perinf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\perinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\perinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\perinf\winnt32\win9xupg)
!ENDIF
!ENDIF

!IFDEF SBSINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b sbsinf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b sbsinf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\sbsinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\sbsinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\sbsinf\winnt32\win9xupg)
!ENDIF
!ENDIF

!IFDEF BLAINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b blainf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b blainf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\blainf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\blainf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\blainf\winnt32\win9xupg)
!ENDIF
!ENDIF

!IFDEF SERVERINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\srvinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\srvinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\srvinf\winnt32\win9xupg)
!ENDIF
!ENDIF

!IFDEF ENTERPRISEINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b entinf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b entinf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\entinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\entinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\entinf\winnt32\win9xupg)
!ENDIF
!ENDIF

!IFDEF DATACENTERINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b dtcinf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b dtcinf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\dtcinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\dtcinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\dtcinf\winnt32\win9xupg)
!ENDIF
!ENDIF

$(O)\layout.inx : $(_INX)\layout.inx
    $(CC) $(PREFLAGS) $** > $@
!if "$(PRODSWITCH)" == "w"
    $(TSBINPLACE_CMD)
!endif

$(_COVINF)\layout.inx : $(_INX)\layout.inx $(_INX)\$(@B).mcv
    call MergeFiles.cmd $(_INX)\layout.inx $(_INX)\$(@B).mcv $(_COVINF)\layout.tmp
    $(CC) $(PREFLAGS) $(_COVINF)\layout.tmp > $@
    del $(_COVINF)\layout.tmp
!if "$(PRODSWITCH)" == "w"
    $(COVER_TSBINPLACE_CMD)
!endif

$(O)\layout.txt : $(_LNG)\layout.txt \
                  $(_LNG)\mednames.txt
    $(CC) $(PREFLAGS) $** > $@
    copy $(O)\$(@B).tmp1 + $(_LNG)\mednames.txt $@
!if "$(PRODSWITCH)" == "w"
    $(TSBINPLACE_CMD)
!endif
    del $(O)\$(@B).tmp1

$(O)\syssetup.inx : $(_INX)\syssetup.inx
    $(CC) $(PREFLAGS) $** > $@


$(O)\txtsetup.inx : $(_INX)\txtsetup.inx
    $(CC) $(PREFLAGS) $** > $@

$(O)\dosnet.inx : $(_INX)\dosnet.inx
    $(CC) $(PREFLAGS) $** > $@

$(_COVINF)\dosnet.inx : $(_INX)\dosnet.inx
    md $(_COVINF)
    $(CC) $(PREFLAGS) $** > $@

$(_RSCOVINF)\dosnet.inx : $(_INX)\dosnet.inx
    md $(_RSCOVINF)
    $(CC) $(PREFLAGS) $** > $@

$(O)\mednames.txt : $(_LNG)\mednames.txt
    $(CC) $(PREFLAGS) $** > $@
!if "$(PRODSWITCH)" == "w"
    $(TSBINPLACE_CMD)
!endif



#
# Explicit dependencies. We do it this way instead of trying to use rules
# because !#@&^$#% nmake doesn't allow multiple 'source' extensions
# when defining a rule, and we need to express a dependency between
# .txt OR .inx to the final .inf.
#

#
# 'Standard' (win95-style) infs. The rules are all the same.
#
# Real-signed layout.inf
#
$(_RSINF)\layout.inf: $(O)\layout.inx $(O)\spmap.txt \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfile.inf \
!endif
                      $(O)\layout.txt
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
!IF $(WIN64)
    copy $(@) $(O)\$(@B).tmp3
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +i
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -o $(O)\$(@B).tmp2 -ac -h $(O)\wowfile.inf -f w 2>NUL
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp2 $(@)
    @del $(O)\$(@B).tmp3
!ENDIF
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    perl $(_INX)\reorder_layout.pl $@ $(_INX)\layout.ord
    @del $@
    perl $(_INX)\splayout.pl $@.new $@ $(O)\spmap.txt
    @del $@.new
!IF "$(LANGUAGE)" !="JPN" && "$(LANGUAGE)" != "jpn" || !$(WIN64)
    perl $(_INX)\inftest.pl $(LANGUAGE) $@ /B /$(PLATFORM_SWITCH)
!ENDIF
    $(RSBINPLACE_CMD)

#
# Coverage Real-signed layout.inf
#
$(_RSCOVINF)\layout.inf: $(O)\layout.inx $(_INX)\$(@B).mcv $(_RSCOVINF)\dosnet.inx \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfile.inf \
!endif
                      $(O)\layout.txt $(O)\spmap.txt
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp1
    call MergeFiles.cmd $(O)\$(@B).tmp1 $(_INX)\$(@B).mcv $(O)\$(@B).tmp2
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    copy $(O)\$(@B).tmp2 $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    perl $(_INX)\reorder_layout.pl $@ $(_INX)\layout.ord
    @del $@
    perl $(_INX)\splayout.pl $@.new $@ $(O)\spmap.txt
    @del $@.new
    $(COVER_RSBINPLACE_CMD)


#
# Test-signed layout.inf
#
$(O)\layout.inf: $(O)\layout.inx $(_INX)\layout.tst \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfile.inf \
!endif
                      $(O)\layout.txt $(O)\spmap.txt
    copy $(O)\$(@B).inx+$(_INX)\$(@B).tst+$(O)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
!IF $(WIN64)
    copy $(@) $(O)\$(@B).tmp3
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +i
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -o $(O)\$(@B).tmp2 -ac -h $(O)\wowfile.inf -f w 2>NUL
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp2 $(@)
    @del $(O)\$(@B).tmp3
!ENDIF
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    perl $(_INX)\reorder_layout.pl $@ $(_INX)\layout.ord
    @del $@
    perl $(_INX)\splayout.pl $@.new $@ $(O)\spmap.txt
    @del $@.new
!IF "$(LANGUAGE)" !="JPN" && "$(LANGUAGE)" != "jpn" || !$(WIN64)
    perl $(_INX)\inftest.pl $(LANGUAGE) $@ /B /$(PLATFORM_SWITCH)
!ENDIF
    $(TSBINPLACE_CMD)

#
# Coverage Test-signed layout.inf
#
$(_COVINF)\layout.inf: $(_COVINF)\layout.inx \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfile.inf \
!endif
                      $(_INX)\layout.tst $(O)\spmap.txt
    copy $(_COVINF)\layout.inx+$(_INX)\$(@B).tst+$(O)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +$(PLATFORM_SWITCH)
    copy $(O)\$(@B).tmp1 $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    perl $(_INX)\reorder_layout.pl $@ $(_INX)\layout.ord
    @del $@
    perl $(_INX)\splayout.pl $@.new $@ $(O)\spmap.txt
    @del $@.new
    $(COVER_TSBINPLACE_CMD)


# we process syssetup.inf twice for win64.  we process one time to get the
# "olecontroldlls" data, then one more time to get the copyfiles entries, etc.
#
$(O)\syssetup.inf: $(O)\syssetup.inx \
!IF $(WIN64)
                   $(O)\wowlist.inf $(O)\wowfrege.inf    \
                   $(O)\wowfregc.inf $(O)\wowfrego.inf   \
                   $(O)\layout.inx $(O)\layout.txt    \
!ENDIF
                   $(_LNG)\syssetup.txt $(O)\spmap.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy /b $(O)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
!IF $(WIN64)
    copy $(@) $(O)\$(@B).tmp3
    copy $(O)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +i
    copy /b $(O)\layout.inx+$(O)\layout.txt $(O)\$(@B).tmp4
    prodfilt -s $(O)\$(@B).tmp4 $(O)\$(@B).tmp2 +@
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp4 +i
    wowlist -i $(O)\$(@B).tmp4 -c $(O)\wowlist.inf -l $(O)\$(@B).tmp1 -s OleControlDlls -o $(O)\$(@B).tmp5 -ao -h $(O)\wowfrego.inf -f w 2>NUL
    wowlist -i $(O)\$(@B).tmp4 -c $(O)\wowlist.inf -l $(O)\$(@B).tmp1 -s EarlyOleControlDlls -o $(O)\$(@B).tmp6 -ao -h $(O)\wowfrege.inf -f w 2>NUL
    wowlist -i $(O)\$(@B).tmp4 -c $(O)\wowlist.inf -l $(O)\$(@B).tmp1 -s CryptoDlls -o $(O)\$(@B).tmp7 -ao -h $(O)\wowfregc.inf -f w 2>NUL
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\syssetup.wow -o $(O)\$(@B).tmp8 -g Syssetup
    copy /b $(O)\$(@B).tmp3+$(O)\$(@B).tmp5+$(O)\$(@B).tmp6+$(O)\$(@B).tmp7+$(O)\$(@B).tmp8 $(@)
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4 $(O)\$(@B).tmp5 $(O)\$(@B).tmp6 $(O)\$(@B).tmp7 $(O)\$(@B).tmp8
!ENDIF
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    perl $(_INX)\splayout.pl $@ $@ $(O)\spmap.txt
    $(TSBINPLACE_CMD)

!IF !$(WIN64)
$(_COVINF)\syssetup.inf: $(O)\syssetup.inx $(_INX)\$(@B).mcv \
                   $(_LNG)\syssetup.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy /b $(O)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +$(PLATFORM_SWITCH)
    call MergeFiles.cmd $(O)\$(@B).tmp1 $(_INX)\$(@B).mcv $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(COVER_TSBINPLACE_CMD)
!ENDIF

!IF $(WIN64)
$(O)\syssetup.wow: $(O)\syssetup.inf
!ENDIF

$(O)\intl.inf: $(_INX)\intl.inx \
!if $(WIN64)
               $(O)\wowlist.inf \
!endif
               $(_LNG)\intl.txt
!if "$(LANGUAGE)"=="CHS" || "$(LANGUAGE)"=="chs" || \
    "$(LANGUAGE)"=="CHT" || "$(LANGUAGE)"=="cht" || \
    "$(LANGUAGE)"=="CHH" || "$(LANGUAGE)"=="chh" || \
    "$(LANGUAGE)"=="JPN" || "$(LANGUAGE)"=="jpn" || \
    "$(LANGUAGE)"=="KOR" || "$(LANGUAGE)"=="kor" || \
    "$(LANGUAGE)"=="ARA" || "$(LANGUAGE)"=="ara" || \
    "$(LANGUAGE)"=="HEB" || "$(LANGUAGE)"=="heb" || \
    "$(LANGUAGE)"=="PSU" || "$(LANGUAGE)"=="psu" || \
    "$(LANGUAGE)"=="RU"  || "$(LANGUAGE)"=="ru"  || \
    "$(LANGUAGE)"=="EL"  || "$(LANGUAGE)"=="el"  || \
    "$(LANGUAGE)"=="PL"  || "$(LANGUAGE)"=="pl"  || \
    "$(LANGUAGE)"=="CS"  || "$(LANGUAGE)"=="cs"  || \
    "$(LANGUAGE)"=="HU"  || "$(LANGUAGE)"=="hu"  || \
    "$(LANGUAGE)"=="TR"  || "$(LANGUAGE)"=="tr"
    infcat -t$(O)\$(@B).tmp -s$(_LNG)\$(@B).txt,0$(LCID) -a$(_INX)\usa\$(@B).txt
    copy $(_INX)\$(@B).inx+$(O)\$(@B).tmp $(O)\$(@B).tmp1
    del $(O)\$(@B).tmp
!else
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp1
!endif
    prodfilt -u $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -u $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -u $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt -u $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -u -d $(O)\intl.wow -o $(O)\$(@B).tmp4 -n $(O)\intlinf.wow -g Intl
    perl << $(O)\$(@B).tmp4 >$(O)\$(@B).tmp5
# perl script to convert "=10,IME" to "=10,IME (x86)" because it's too late to fix setup.
# This script would be a lot nicer except that intl.inf is UNICODE
undef $$/;
binmode(STDIN);
binmode(STDOUT);
$$_ = <>;
s/=\0\x31\0\x30\0,\0I\0M\0E\0\\\0([^\n\r]*)/=\0\x31\0\x30\0,\0"\0I\0M\0E\0 \0\(\0x\0\x38\0\x36\0\)\0\\\0\1"\0/g;
print;
<<NOKEEP
!if $(IA64)
    echo [SourceDisksFiles.ia64] >$(O)\intl.hdr1
!else
    echo [SourceDisksFiles.amd64] >$(O)\intl.hdr1
!endif
    unitext $(UNITEXT_OPT) $(O)\intl.hdr1 $(O)\intl.hdr
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp5+$(O)\intl.hdr+$(O)\intlinf.wow $(O)\$(@B).tmp2
# This is a temporary fix as cmd.exe on beta2 2462 introduces a ^Z char at the end of the file
# when using copy /a. Running a dummy prodfilt on this fixes the issue for now. Should be removed
# once the main build lab upgrades the build running on their machines
    prodfilt -u $(O)\$(@B).tmp2 $@ +@
    unitext -u -$(ANSI_CODEPAGE) $(O)\intlinf.wow $(O)\intlinfa.wow
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4 $(O)\$(@B).tmp5 $(O)\intl.hdr1 $(O)\intl.hdr
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    perl $(_INX)\splayout.pl $@ $@ $(O)\spmap.txt
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\intl.wow: $(O)\intl.inf

$(O)\intlinfa.wow: $(O)\intl.inf
!endif



$(O)\font.inf: $(_INX)\font.inx $(_LNG)\font.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netdav.inf: $(_INX)\netdav.inx $(_LNG)\netdav.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\display.inf: $(_INX)\display.inx $(_LNG)\display.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dispdet.inf: $(_INX)\dispdet.inx $(_LNG)\display.txt
    $(CC) $(PREFLAGS) $(_LNG)\display.txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+display.txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\optional.inf: $(_INX)\optional.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\optional.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\optional.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\optional.wow: $(O)\optional.inf
!endif

$(O)\accessor.inf: $(_INX)\accessor.inx  \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\accessor.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\accessor.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\accessor.wow: $(O)\accessor.inf
!endif

$(O)\communic.inf: $(_INX)\communic.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\communic.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\communic.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\communic.wow: $(O)\communic.inf
!endif


$(O)\games.inf: $(_INX)\games.inx \
!if $(WIN64)
                $(O)\wowlist.inf \
!endif
                $(_LNG)\games.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\games.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\games.wow: $(O)\games.inf
!endif

$(O)\au.inf: $(_INX)\au.inx $(_LNG)\au.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\wbemoc.inf: $(_INX)\wbemoc.inx \
!if $(WIN64)
                  $(O)\wowlist.inf   \
!endif
                  $(_LNG)\wbemoc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -g WbemOC -as -f w -d $(O)\wbemoc.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\wbemoc.wow: $(O)\wbemoc.inf
!endif

$(O)\wbemsnmp.inf: $(_INX)\wbemsnmp.inx $(_LNG)\wbemsnmp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

#
# IE.INF/INSTALL.INS notes:
# For ie.inf and install.ins, we have to replace all the
# TOK_xxx keys in the file with the appropriate entries from ieverp.h.
# To do this, we first build a makefile that will preprocess
# the file and extract the interesting entries...
#

$(O)\ietoken.mak : $(_INX)\makefile.inc $(SDK_INC_PATH)\ntverp.h
    echo !include $(NTMAKEENV)\makefile.plt > $@
    @$(TARGET_CPP) -nologo -I$(SDK_INC_PATH) -DNASHVILLE /EP /Tc << | qgrep TOK_ >> $@
#include "$(SDK_INC_PATH)\ntverp.h"

TOK_BUILDNUM = VER_PRODUCTBUILD
TOK_QFE = VER_PRODUCTBUILD_QFE
TOK_MAJOR_NUM = VER_MAJOR_PRODUCTVER
TOK_MINOR_NUM = VER_MINOR_PRODUCTVER
#if (VER_PRODUCTBUILD_QFE > 0)
TOK_FULLQFE = .VER_PRODUCTBUILD_QFE
#else
TOK_FULLQFE =
#endif
<<NOKEEP
    type << >> $@
PERL_SWITCHES = \
    $(_INX)\token.per \
    -tTOK_BUILDNUM=$$(TOK_BUILDNUM) \
    -tTOK_QFE=$$(TOK_QFE) \
    -tTOK_MAJOR_NUM=$$(TOK_MAJOR_NUM) \
    -tTOK_MINOR_NUM=$$(TOK_MINOR_NUM) \
    -tTOK_FULLQFE=$$(TOK_FULLQFE)

STD_DEP = \
    $(SDK_INC_PATH)\ntverp.h \
    $@

$(O)\ie.inf : $(O)\ie.inftok \
!if $(WIN64)
              $(O)\ie.inftok_6432 \
!endif
              $$(STD_DEP)
     perl $$(PERL_SWITCHES) $(O)\ie.inftok > $(O)\ie.inf
!if $(WIN64)
     perl $$(PERL_SWITCHES) $(O)\ie.inftok_6432 > $(O)\ie.tmp1
     wowlist -i $(O)\ie.tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\ie.wow -o $(O)\ie.tmp2
     copy $(O)\ie.inf $(O)\ie.tmp1
     copy $(O)\ie.tmp1+$(O)\ie.tmp2 $(O)\ie.inf
     @del $(O)\ie.tmp1 $(O)\ie.tmp2
!endif

$(O)\install.ins : $(O)\install.instok $(STD_DEP)
     perl $$(PERL_SWITCHES) $(O)\install.instok > $(O)\install.ins

$(O)\msoe50.inf : $(O)\msoe50.inftok \
!if $(WIN64)
                  $(O)\msoe50.inftok_6432 \
!endif
                  $(STD_DEP)
     perl $$(PERL_SWITCHES) $(O)\msoe50.inftok > $(O)\msoe50.inf
!if $(WIN64)
     perl $$(PERL_SWITCHES) $(O)\msoe50.inftok_6432 > $(O)\msoe50.tmp1
     wowlist -i $(O)\msoe50.tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\msoe50.wow -o $(O)\msoe50.tmp2
     copy $(O)\msoe50.inf $(O)\msoe50.tmp1
     copy $(O)\msoe50.tmp1+$(O)\msoe50.tmp2 $(O)\msoe50.inf
     @del $(O)\msoe50.tmp1 $(O)\msoe50.tmp2
!endif

$(O)\wab50.inf : $(O)\wab50.inftok $(STD_DEP)
     perl $$(PERL_SWITCHES) $(O)\wab50.inftok > $(O)\wab50.inf
!if $(WIN64)
     wowlist -i $(O)\wab50.inf -c $(O)\wowlist.inf -as -f w -d $(O)\wab50.wow -o $(O)\wab50.tmp2
     copy $(O)\wab50.inf $(O)\wab50.tmp1
     copy $(O)\wab50.tmp1+$(O)\wab50.tmp2 $(O)\wab50.inf
     @del $(O)\wab50.tmp1 $(O)\wab50.tmp2
!endif

$(O)\update.inf: $(O)\update.inftok $(STD_DEP)
     perl $$(PERL_SWITCHES) $(O)\update.inftok > $(O)\update.inf

$(O)\hivesft.inf: $(O)\hivesft.inftok $(STD_DEP)
     perl $$(PERL_SWITCHES) $(O)\hivesft.inftok > $(O)\hivesft.inf
<<NOKEEP

#
# IE/INSTALL notes.  Then we build a pretokenized file
# (tok added to the filename).
#

$(O)\ie.inftok: $(_INX)\ie.inx $(_LNG)\ie.txt
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$(_INX)\$(@B).inx > $(O)\$(@B).tmp
$(CPPXX: =
)
/DNT5
<<NOKEEP
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(O)\$(@B).tmp+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp $(O)\$(@B).txt1 $(O)\$(@B).tmp1 $(O)\$(@B).tmp2

$(O)\ie.inftok_6432: $(_INX)\ie.inx $(_LNG)\ie.txt
    @type <<$(ECHO_RSP)
$(C_COMPILER_NAME) -D_X86_=1 -Di386=1 $(_INX)\ie.inx
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) -D_X86_=1 -Di386=1 /Tc$(_INX)\$(@B).inx > $(O)\$(@B).tmp
$(CPPXX: =
)
/DNT5
<<NOKEEP
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(O)\$(@B).tmp+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +i
    @del $(O)\$(@B).tmp $(O)\$(@B).tmp1 $(O)\$(@B).tmp2

$(O)\install.instok: $(_INX)\install.inx $(_LNG)\install.txt $(O)\ietoken.mak
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\install.inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1

$(O)\msoe50.inftok: $(_INX)\msoe50.inx $(_LNG)\msoe50.txt
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$(_INX)\$(@B).inx > $(O)\$(@B).tmp
$(CPPXX: =
)
/DNT5
<<NOKEEP
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(O)\$(@B).tmp+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 $(O)\$(@B).txt1

$(O)\msoe50.inftok_6432: $(_INX)\msoe50.inx $(_LNG)\msoe50.txt
    @type <<$(ECHO_RSP)
$(C_COMPILER_NAME) -D_X86_=1 -Di386=1 $(_INX)\msoe50.inx
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) -D_X86_=1 -Di386=1 /Tc$(_INX)\$(@B).inx > $(O)\$(@B).tmp
$(CPPXX: =
)
/DNT5
<<NOKEEP
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(O)\$(@B).tmp+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +i
    @del $(O)\$(@B).tmp $(O)\$(@B).tmp1 $(O)\$(@B).tmp2

$(O)\wab50.inftok: $(_INX)\wab50.inx $(_LNG)\wab50.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 $(O)\$(@B).txt1
#
# IE/INSTALL notes: And finally, we run them through the
# makefile we created above, stamp, and binplace.
#

$(O)\ie.inf : $(O)\ietoken.mak \
!if $(WIN64)
              $(O)\wowlist.inf \
              $(O)\ie.inftok_6432 \
!endif
              $(O)\ie.inftok
    nmake -f $(O)\ietoken.mak $@
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\ie.wow: $(O)\ie.inf
!endif

$(O)\msoe50.inf : $(O)\ietoken.mak \
!if $(WIN64)
                  $(O)\wowlist.inf \
                  $(O)\msoe50.inftok_6432 \
!endif
                  $(O)\msoe50.inftok
    nmake -f $(O)\ietoken.mak $@
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\msoe50.wow: $(O)\msoe50.inf
!endif

$(O)\mstask.inf : $(_INX)\mstask.inx \
!if $(WIN64)
                  $(O)\wowlist.inf   \
!endif
                  $(_LNG)\mstask.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\mstask.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\mstask.wow: $(O)\mstask.inf
!endif

$(O)\wab50.inf :  $(O)\ietoken.mak \
!if $(WIN64)
                  $(O)\wowlist.inf \
                  $(O)\msoe50.inftok_6432 \
!endif
                  $(O)\wab50.inftok
    nmake -f $(O)\ietoken.mak $@
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\wab50.wow: $(O)\wab50.inf
!endif

$(O)\install.ins: $(O)\ietoken.mak $(O)\install.instok
    nmake -f $(O)\ietoken.mak $@
    $(TSBINPLACE_CMD)

$(O)\mmopt.inf: $(_INX)\mmopt.inx \
!if $(WIN64)
                $(O)\wowlist.inf \
!endif
                $(_LNG)\mmopt.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    wowlist -i $(O)\$(@B).tmp2 -c $(O)\wowlist.inf -as -f w -d $(O)\mmopt.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)


!if $(WIN64)
$(O)\mmopt.wow: $(O)\mmopt.inf
!endif


$(O)\msmail.inf: $(_INX)\msmail.inx $(_LNG)\msmail.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\perms.inf: $(_INX)\perms.inx $(_LNG)\perms.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hivesys.inf: $(_INX)\hivesys.inx $(_LNG)\hivesys.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\hivesys.inf: $(_INX)\hivesys.inx $(_LNG)\hivesys.txt $(_INX)\$(@B).mcv
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    call MergeFiles.cmd $(O)\$(@B).tmp2 $(_INX)\$(@B).mcv $(@)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\hivesft.inf: $(_INX)\hivesft.inx $(_LNG)\hivesft.txt $(O)\ietoken.mak
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $(O)\$(@B).inftok +$(PLATFORM_SWITCH)
    nmake -f $(O)\ietoken.mak $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    @del $(O)\$(@B).inftok
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hivedef.inf: $(_INX)\hivedef.inx $(_LNG)\hivedef.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hivecls.inf: $(_INX)\hivecls.inx $(_LNG)\hivecls.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hiveusd.inf: $(_INX)\hiveusd.inx $(_LNG)\hiveusd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\hivcls32.inf: $(_INX)\hivecls.inx $(_LNG)\hivecls.txt $(_INX)\hive32.pl
    $(CC) $(PREFLAGS) $(_LNG)\hivecls.txt > hivecls.txt1
    copy $(_INX)\hivecls.inx+hivecls.txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $(O)\$(@B).tmp1 +i
    perl $(_INX)\hive32.pl -input=$(O)\$(@B).tmp1 -output=$@
    @del $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 hivecls.txt1
    $(TSBINPLACE_CMD)

$(O)\hivsft32.inf: $(_INX)\hivesft.inx $(_LNG)\hivesft.txt $(_INX)\hive32.pl
    $(CC) $(PREFLAGS) $(_LNG)\hivesft.txt > $(O)\hivesft.txt1
    copy $(_INX)\hivesft.inx+$(O)\hivesft.txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $(O)\$(@B).tmp1 +i
    perl $(_INX)\hive32.pl -input=$(O)\$(@B).tmp1 -output=$@
    @del $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 $(O)\$(@B).tmp3
    $(TSBINPLACE_CMD)
!endif

$(O)\mdac.inf: $(_INX)\mdac.inx \
!if $(WIN64)
               $(O)\wowlist.inf \
!endif
               $(_LNG)\mdac.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +@
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +i
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\mdac.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\mdac.wow: $(O)\mdac.inf
!endif

$(O)\mdacwx86.inf: $(_INX)\mdacwx86.inx $(_LNG)\mdac.txt
    $(CC) $(PREFLAGS) $(_LNG)\mdac.txt > mdac.txt1
    copy $(_INX)\$(@B).inx+mdac.txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del mdac.txt1
    $(TSBINPLACE_CMD)

$(O)\multimed.inf: $(_INX)\multimed.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\multimed.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\multimed.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\multimed.wow: $(O)\multimed.inf
!endif


$(O)\pinball.inf: $(_INX)\pinball.inx \
!if $(WIN64)
                  $(O)\wowlist.inf \
!endif
                  $(_LNG)\pinball.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\pinball.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\pinball.wow: $(O)\pinball.inf
!endif


$(O)\sapi5.inf: $(_INX)\sapi5.inx \
                $(_LNG)\sapi5.txt
    $(CC) $(PREFLAGS) /nologo /c /EP $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    unitext -m -o $(O)\$(@B).txt1 $(O)\$(@B).txt2
    copy /b $(_INX)\$(@B).inx+$(O)\$(@B).txt2 $(O)\$(@B).tmp1
    prodfilt -u $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -u $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    @del $(O)\$(@B).txt2
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\wordpad.inf: $(_INX)\wordpad.inx \
!if $(WIN64)
                  $(O)\wowlist.inf \
!endif
                  $(_LNG)\wordpad.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\wordpad.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\wordpad.wow: $(O)\wordpad.inf
!endif

$(O)\devxprop.inf: $(_INX)\devxprop.inx $(_LNG)\devxprop.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\devxprop.inf: $(_INX)\devxprop.inx $(_LNG)\devxprop.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\shell.inf: $(_INX)\shell.inx $(_LNG)\shell.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\shl_img.inf: $(_INX)\shl_img.inx $(_LNG)\shl_img.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\shellmui.inf: $(_INX)\shellmui.inx $(_LNG)\shellmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\skinsmui.inf: $(_INX)\skinsmui.inx $(_LNG)\skinsmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\wmprfmui.inf: $(_INX)\wmprfmui.inx $(_LNG)\wmprfmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    $(CC) $(PREFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    @del $(O)\$(@B).inx1
    $(TSBINPLACE_CMD)

$(O)\wmtrmui.inf: $(_INX)\wmtrmui.inx $(_LNG)\wmtrmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\srchasst.inf: $(_INX)\srchasst.inx $(_LNG)\srchasst.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\srchmui.inf: $(_INX)\srchmui.inx $(_LNG)\srchmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sysoc.inf: $(_INX)\sysoc.inx $(_LNG)\sysoc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)



# using the sysoc.txt file for strings.
$(O)\asroc.inf: $(_INX)\asroc.inx $(_LNG)\sysoc.txt
    $(CC) $(PREFLAGS) $(_LNG)\sysoc.txt > sysoc.txt1
    copy $(_INX)\$(@B).inx+sysoc.txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del sysoc.txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ntprint.inf: $(_INX)\ntprint.inx $(_INX)\feprint.inx \
                     $(_LNG)\ntprint.txt
    $(CC) $(PREFLAGS) -I$(_INX) $(_INX)\ntprint.inx > $(O)\$(@B).txt1
    prodfilt $(O)\$(@B).txt1  $(O)\$(@B).tmp1 +$(PLATFORM_SWITCH)
    $(CC) $(PREFLAGS) -I$(_INX) $(_LNG)\ntprint.txt > $(O)\$(@B).txt2
    prodfilt $(O)\$(@B).txt2  $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp1 $(O)\$(@B).tmp11
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp2 $(O)\$(@B).tmp22
    copy $(O)\$(@B).tmp11+$(O)\$(@B).tmp22 $@
    @del $(O)\$(@B).tmp1 $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp11 $(O)\$(@B).tmp22
    @del $(O)\$(@B).txt1 $(O)\$(@B).txt2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\prtupg9x.inf: $(_INX)\prtupg9x.inx $(_LNG)\prtupg9x.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\printupg.inf: $(_INX)\printupg.inx $(_LNG)\printupg.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\bfcab.inf: $(_INX)\bfcab.inx $(_LNG)\bfcab.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\brmfcmdm.inf: $(_INX)\brmfcmdm.inx $(_LNG)\brmfcmdm.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\brmfcmf.inf: $(_INX)\brmfcmf.inx $(_LNG)\brmfcmf.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\brmfcsto.inf: $(_INX)\brmfcsto.inx $(_LNG)\brmfcsto.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\brmfcumd.inf: $(_INX)\brmfcumd.inx $(_LNG)\brmfcumd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\brmfcwia.inf: $(_INX)\brmfcwia.inx $(_LNG)\brmfcwia.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\brmfport.inf: $(_INX)\brmfport.inx $(_LNG)\brmfport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\apps.inf: $(_INX)\apps.inx $(_LNG)\apps.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\apcompat.inf: $(_INX)\apcompat.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\apcompat.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    wowlist -i $@ -c $(O)\wowlist.inf -as -f w -d $(O)\apcompat.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\apcompat.wow: $(O)\apcompat.inf
!endif

$(O)\keyboard.inf: $(_INX)\keyboard.inx $(_LNG)\keyboard.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\langinst.inf: $(_INX)\langinst.inx $(_LNG)\langinst.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\legcydrv.inf: $(_INX)\legcydrv.inx $(_LNG)\legcydrv.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\lwusbhid.inf: $(_INX)\lwusbhid.inx $(_LNG)\lwusbhid.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\lwngmadi.inf: $(_INX)\lwngmadi.inx $(_LNG)\lwngmadi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\machine.inf: $(_INX)\machine.inx $(_LNG)\machine.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mchgr.inf: $(_INX)\mchgr.inx $(_LNG)\mchgr.txt
    $(CC) $(PREFLAGS) $(PREFILTFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    $(CC) $(PREFILTFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    @del $(O)\$(@B).inx1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mshdc.inf: $(_INX)\mshdc.inx $(_LNG)\mshdc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\flash.inf: $(_INX)\flash.inx $(_LNG)\flash.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msmouse.inf: $(_INX)\msmouse.inx $(_LNG)\msmouse.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msports.inf: $(_INX)\msports.inx $(_LNG)\msports.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cyclad-z.inf: $(_INX)\cyclad-z.inx $(_LNG)\cyclad-z.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cyclom-y.inf: $(_INX)\cyclom-y.inx $(_LNG)\cyclom-y.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cyyport.inf: $(_INX)\cyyport.inx $(_LNG)\cyyport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cyzport.inf: $(_INX)\cyzport.inx $(_LNG)\cyzport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mxboard.inf: $(_INX)\mxboard.inx $(_LNG)\mxboard.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mxport.inf: $(_INX)\mxport.inx $(_LNG)\mxport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wceusbsh.inf: $(_INX)\wceusbsh.inx $(_LNG)\wceusbsh.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\multiprt.inf: $(_INX)\multiprt.inx $(_LNG)\multiprt.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ntapm.inf: $(_INX)\ntapm.inx $(_LNG)\ntapm.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\pnpscsi.inf: $(_INX)\pnpscsi.inx $(_LNG)\pnpscsi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    $(CC) $(PREFILTFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ramdisk.inf: $(_INX)\ramdisk.inx $(_LNG)\ramdisk.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


!if !$(WIN64)
$(O)\scsi.inf: $(_INX)\scsi.inx $(_LNG)\scsi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    $(CC) $(PREFILTFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)
!endif

$(O)\scsidev.inf: $(_INX)\scsidev.inx $(_LNG)\scsidev.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sdwndr2k.inf: $(_INX)\sdwndr2k.inx $(_LNG)\sdwndr2k.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $@ +@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\smartcrd.inf: $(_INX)\smartcrd.inx $(_LNG)\smartcrd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\swflash.inf: $(_INX)\swflash.inx $(_LNG)\swflash.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\swnt.inf: $(_INX)\swnt.inx $(_LNG)\swnt.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\tape.inf: $(_INX)\tape.inx $(_LNG)\tape.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\vgx.inf: $(_INX)\vgx.inx \
!if $(WIN64)
              $(O)\wowlist.inf \
!endif
              $(_LNG)\vgx.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    wowlist -i $@ -c $(O)\wowlist.inf -as -f w -d $(O)\vgx.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\vgx.wow: $(O)\vgx.inf
!endif

$(O)\volume.inf: $(_INX)\volume.inx $(_LNG)\volume.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\volsnap.inf: $(_INX)\volsnap.inx $(_LNG)\volsnap.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\prodspec.ini: $(_INX)\prodspec.inx $(_LNG)\prodspec.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    echo BitVersion=40 >> $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\prod128.ini: $(_INX)\prodspec.inx $(_LNG)\prodspec.txt
    $(CC) $(PREFLAGS) $(_LNG)\prodspec.txt > prodspec.txt1
    copy $(_INX)\prodspec.inx+prodspec.txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del prodspec.txt1
    echo BitVersion=128 >> $@
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(386)

$(O)\win95upg.inf: $(_INX)\win95upg.inx $(_LNG)\win95upg.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(WIN9XUPGBINPLACE_CMD)

$(O)\migdb.inf: $(_INX)\migdb.inx $(_LNG)\migdb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    @del $(O)\$(@B).tmpInx
    $(STAMP)
    $(WIN9XUPGBINPLACE_CMD)

$(O)\vscandb.inf: $(_INX)\vscandb.inx $(_LNG)\vscandb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(WIN9XUPGBINPLACE_CMD)

$(O)\wkstamig.inf: $(_INX)\wkstamig.inx $(_LNG)\wkstamig.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\usermig.inf: $(_INX)\usermig.inx $(_LNG)\usermig.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!endif

$(O)\filegen.inf: $(_INX)\filegen.inx $(_LNG)\filegen.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ntautorun.inf: $(_INX)\ntautorun.inx $(_LNG)\ntautorun.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy /A $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\acpi.inf: $(_INX)\acpi.inx $(_LNG)\acpi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hiddigi.inf: $(_INX)\hiddigi.inx $(_LNG)\hiddigi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hidserv.inf: $(_INX)\hidserv.inx $(_LNG)\hidserv.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\irbus.inf: $(_INX)\irbus.inx $(_LNG)\irbus.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\input.inf: $(_INX)\input.inx $(_LNG)\input.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\usbprint.inf: $(_INX)\usbprint.inx $(_LNG)\usbprint.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\usb.inf: $(_INX)\usb.inx $(_LNG)\usb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\usbstor.inf: $(_INX)\usbstor.inx $(_LNG)\usbstor.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\usbport.inf: $(_INX)\usbport.inx $(_LNG)\usbport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dbc.inf: $(_INX)\dbc.inx $(_LNG)\dbc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ccdecode.inf: $(_INX)\ccdecode.inx $(_LNG)\ccdecode.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\nabtsfec.inf: $(_INX)\nabtsfec.inx $(_LNG)\nabtsfec.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wstcodec.inf: $(_INX)\wstcodec.inx $(_LNG)\wstcodec.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cdrom.inf: $(_INX)\cdrom.inx $(_LNG)\cdrom.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cpu.inf: $(_INX)\cpu.inx $(_LNG)\cpu.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $@
    @del $(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\disk.inf: $(_INX)\disk.inx $(_LNG)\disk.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\gameport.inf: $(_INX)\gameport.inx $(_LNG)\gameport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wdmjoy.inf: $(_INX)\wdmjoy.inx $(_LNG)\wdmjoy.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ntgrip.inf: $(_INX)\ntgrip.inx $(_LNG)\ntgrip.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

# Alway filter for server product, other products used for other builds
$(O)\dimaps.inf: $(_INX)\dimaps.inx $(_LNG)\dimaps.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +s
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\battery.inf: $(_INX)\battery.inx $(_LNG)\battery.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\pcmcia.inf: $(_INX)\pcmcia.inx $(_LNG)\pcmcia.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\memcard.inf: $(_INX)\memcard.inx $(_LNG)\memcard.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\memory.inf: $(_INX)\memory.inx $(_LNG)\memory.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $@
    @del $(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\memstpci.inf: $(_INX)\memstpci.inx $(_LNG)\memstpci.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sonypvu1.inf: $(_INX)\sonypvu1.inx $(_LNG)\sonypvu1.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mf.inf: $(_INX)\mf.inx $(_LNG)\mf.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mfsocket.inf: $(_INX)\mfsocket.inx $(_LNG)\mfsocket.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\1394.inf: $(_INX)\1394.inx $(_LNG)\1394.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\1394vdbg.inf: $(_INX)\1394vdbg.inx $(_LNG)\1394vdbg.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sbp2.inf: $(_INX)\sbp2.inx $(_LNG)\sbp2.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\61883.inf: $(_INX)\61883.inx $(_LNG)\61883.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\avc.inf: $(_INX)\avc.inx $(_LNG)\avc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\oobe.inf: $(_INX)\oobe.inx $(_LNG)\oobe.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\oobemui.inf: $(_INX)\oobemui.inx $(_LNG)\oobemui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\genprint.inf: $(_INX)\genprint.inx $(_LNG)\genprint.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\guidrvs.inf: $(_INX)\guidrvs.inx
    prodfilt $(_INX)\guidrvs.inx $(O)\$(@B).tmp +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    $(TSBINPLACE_CMD)

$(O)\icam3.inf: $(_INX)\icam3.inx $(_LNG)\icam3.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\icam4usb.inf: $(_INX)\icam4usb.inx $(_LNG)\icam4usb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\icam5usb.inf: $(_INX)\icam5usb.inx $(_LNG)\icam5usb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\image.inf: $(_INX)\image.inx $(_LNG)\image.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ovcam.inf: $(_INX)\ovcam.inx $(_LNG)\ovcam.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ovcomp.inf: $(_INX)\ovcomp.inx $(_LNG)\ovcomp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ovsound.inf: $(_INX)\ovsound.inx $(_LNG)\ovsound.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msdv.inf: $(_INX)\msdv.inx $(_LNG)\msdv.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mstape.inf: $(_INX)\mstape.inx $(_LNG)\mstape.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\tsbvcap.inf: $(_INX)\tsbvcap.inx $(_LNG)\tsbvcap.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ibmvcap.inf: $(_INX)\ibmvcap.inx $(_LNG)\ibmvcap.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sti.inf: $(_INX)\sti.inx $(_LNG)\sti.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ricoh.inf: $(_INX)\ricoh.inx $(_LNG)\ricoh.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\kdkscan.inf: $(_INX)\kdkscan.inx $(_LNG)\kdkscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\srusbusd.inf: $(_INX)\srusbusd.inx $(_LNG)\srusbusd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hpdigwia.inf: $(_INX)\hpdigwia.inx $(_LNG)\hpdigwia.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\stillcam.inf: $(_INX)\stillcam.inx $(_LNG)\stillcam.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dot4.inf: $(_INX)\dot4.inx $(_LNG)\dot4.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dot4prt.inf: $(_INX)\dot4prt.inx $(_LNG)\dot4prt.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hpojscan.inf: $(_INX)\hpojscan.inx $(_LNG)\hpojscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hpscan.inf: $(_INX)\hpscan.inx $(_LNG)\hpscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\xscan_xp.inf: $(_INX)\xscan_xp.inx $(_LNG)\xscan_xp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\pmxmcro.inf: $(_INX)\pmxmcro.inx $(_LNG)\pmxmcro.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\epcfw2k.inf: $(_INX)\epcfw2k.inx $(_LNG)\epcfw2k.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\epsnscan.inf: $(_INX)\epsnscan.inx $(_LNG)\epsnscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\epsnmfp.inf: $(_INX)\epsnmfp.inx $(_LNG)\epsnmfp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\epstw2k.inf: $(_INX)\epstw2k.inx $(_LNG)\epstw2k.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\fjtscan.inf: $(_INX)\fjtscan.inx $(_LNG)\fjtscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\acerscan.inf: $(_INX)\acerscan.inx $(_LNG)\acerscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\kdk2x0.inf: $(_INX)\kdk2x0.inx $(_LNG)\kdk2x0.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\kodak.inf: $(_INX)\kodak.inx $(_LNG)\kodak.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\ptpusb.inf: $(_INX)\ptpusb.inx $(_LNG)\ptpusb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\bda.inf: $(_INX)\bda.inx $(_LNG)\bda.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mscpqpa1.inf: $(_INX)\mscpqpa1.inx $(_LNG)\mscpqpa1.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msnike.inf: $(_INX)\msnike.inx $(_LNG)\msnike.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msrio.inf: $(_INX)\msrio.inx $(_LNG)\msrio.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msrio8.inf: $(_INX)\msrio8.inx $(_LNG)\msrio8.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mpe.inf: $(_INX)\mpe.inx $(_LNG)\mpe.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ndisip.inf: $(_INX)\ndisip.inx $(_LNG)\ndisip.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netbeac.inf: $(_INX)\netbeac.inx $(_LNG)\netbeac.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netip6.inf: $(_INX)\netip6.inx $(_LNG)\netip6.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\nettun.inf: $(_INX)\nettun.inx
    copy $(_INX)\$(@B).inx $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\phildec.inf: $(_INX)\phildec.inx $(_LNG)\phildec.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\philtune.inf: $(_INX)\philtune.inx $(_LNG)\philtune.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\slip.inf: $(_INX)\slip.inx $(_LNG)\slip.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\streamip.inf: $(_INX)\streamip.inx $(_LNG)\streamip.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ks.inf: $(_INX)\ks.inx $(_LNG)\ks.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\kscaptur.inf: $(_INX)\kscaptur.inx $(_LNG)\kscaptur.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ksfilter.inf: $(_INX)\ksfilter.inx $(_LNG)\ksfilter.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\flpydisk.inf: $(_INX)\flpydisk.inx $(_LNG)\flpydisk.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\fdc.inf: $(_INX)\fdc.inx $(_LNG)\fdc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dvd.inf: $(_INX)\dvd.inx $(_LNG)\dvd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dshowext.inf: $(_INX)\dshowext.inx $(_LNG)\dshowext.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\phil1vid.inf: $(_INX)\phil1vid.inx $(_LNG)\phil1vid.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\phdsext.inf: $(_INX)\phdsext.inx $(_LNG)\phdsext.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\phil2vid.inf: $(_INX)\phil2vid.inx $(_LNG)\phil2vid.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\camdsh20.inf: $(_INX)\camdsh20.inx $(_LNG)\camdsh20.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\camvid20.inf: $(_INX)\camvid20.inx $(_LNG)\camvid20.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\camvid30.inf: $(_INX)\camvid30.inx $(_LNG)\camvid30.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mui.inf: $(_INX)\mui.inx $(_LNG)\mui.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    $(TSBINPLACE_CMD)

$(O)\wsh.inf: $(_INX)\wsh.inx \
!if $(WIN64)
              $(O)\wowlist.inf \
!endif
              $(_LNG)\wsh.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    wowlist -i $@ -c $(O)\wowlist.inf -as -f w -d $(O)\wsh.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\wsh.wow: $(O)\wsh.inf
!endif

!if $(WIN64)
$(O)\is_wow64.inf: $(_INX)\is_wow64.inx
    copy $(_INX)\$(@B).inx $(O)\$(@B).tmp1
    $(CC) $(PREFLAGS) $(O)\$(@B).tmp1 > $@
    del $(O)\$(@B).tmp1
    $(STAMP)
    $(TSBINPLACE_CMD)
!endif

$(O)\ppa.inf: $(_INX)\ppa.inx $(_LNG)\ppa.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ppa3.inf: $(_INX)\ppa3.inx $(_LNG)\ppa3.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dmreg.inf: $(_INX)\dmreg.inx $(_LNG)\dmreg.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dfrg.inf: $(_INX)\dfrg.inx $(_LNG)\dfrg.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\rsoptcom.inf: $(_INX)\rsoptcom.inx $(_LNG)\rsoptcom.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\umax.inf: $(_INX)\umax.inx $(_LNG)\umax.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\umaxpp.inf: $(_INX)\umaxpp.inx $(_LNG)\umaxpp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\rsoptwks.inf: $(_INX)\rsoptwks.inx $(_LNG)\rsoptwks.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msinfo32.inf: $(_INX)\msinfo32.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\msinfo32.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp1
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\msinfo32.wow -o $(O)\$(@B).tmp2 -g NOREGSVR
    copy $(O)\$(@B).tmp1+$(O)\$(@B).tmp2 $@
    @del $(O)\$(@B).tmp2 $(O)\$(@B).tmp1
!endif
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\msinfo32.wow: $(O)\msinfo32.inf
!endif

$(O)\defltp.inf: $(_INX)\defltp.inx $(_LNG)\defltp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dpup.inf: $(_INX)\dpup.inx $(_LNG)\dpup.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\defltwk.inf: $(_INX)\defltwk.inx $(_LNG)\defltwk.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\layout.inf $(O)\layout.u.inf
    escpeinf C $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\defltwk.inf: $(_INX)\defltwk.inx $(_LNG)\defltwk.txt $(_COVINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(_COVINF)\layout.inf $(O)\layout.u.inf
    escpeinf C $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\defltsv.inf: $(_INX)\defltsv.inx $(_LNG)\defltsv.txt $(O)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\layout.inf $(O)\layout.u.inf
    escpeinf C $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\defltsv.inf: $(_INX)\defltsv.inx $(_LNG)\defltsv.txt $(_COVINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(_COVINF)\layout.inf $(O)\layout.u.inf
    escpeinf C $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\defltdc.inf: $(_INX)\defltdc.inx $(_LNG)\defltdc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\compatws.inf: $(_INX)\compatws.inx $(_LNG)\compatws.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dcup.inf: $(_INX)\dcup.inx $(_LNG)\dcup.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dcfirst.inf: $(_INX)\dcfirst.inx $(_LNG)\dcfirst.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\rootsec.inf: $(_INX)\rootsec.inx $(_LNG)\rootsec.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\securews.inf: $(_INX)\securews.inx $(_LNG)\securews.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\securedc.inf: $(_INX)\securedc.inx $(_LNG)\securedc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hisecws.inf: $(_INX)\hisecws.inx $(_LNG)\hisecws.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hisecdc.inf: $(_INX)\hisecdc.inx $(_LNG)\hisecdc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\secrecs.inf: $(_INX)\secrecs.inx $(_LNG)\secrecs.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sceregvl.inf: $(_INX)\sceregvl.inx $(_LNG)\sceregvl.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dcup5.inf: $(_INX)\dcup5.inx $(_LNG)\dcup5.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dwup.inf: $(_INX)\dwup.inx $(_LNG)\dwup.txt $(O)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\dwup.inf: $(_INX)\dwup.inx $(_LNG)\dwup.txt $(_COVINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(_COVINF)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\dsup.inf: $(_INX)\dsup.inx $(_LNG)\dsup.txt $(O)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\dsup.inf: $(_INX)\dsup.inx $(_LNG)\dsup.txt $(_COVINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(_COVINF)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\dsupt.inf: $(_INX)\dsupt.inx $(_LNG)\dsupt.txt $(O)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\dsupt.inf: $(_INX)\dsupt.inx $(_LNG)\dsupt.txt $(_COVINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(_COVINF)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\syscomp.inf: $(_INX)\syscomp.inx $(_LNG)\syscomp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ocmri.inf: $(_INX)\ocmri.inx $(_LNG)\reminst.txt
    $(CC) $(PREFLAGS) $(_LNG)\reminst.txt > reminst.txt1
    copy $(_INX)\$(@B).inx+reminst.txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del reminst.txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\reminst.inf: $(_INX)\reminst.inx $(_LNG)\reminst.txt $(_INX)\ocmri.inx
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\ocmri.inx+$(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ristndrd.sif: $(_INX)\ristndrd.inx $(_LNG)\ristndrd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +R
    prodfilt $(O)\$(@B).tmp3 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\rinorprt.sif: $(_INX)\ristndrd.inx $(_LNG)\ristndrd.txt
    $(CC) $(PREFLAGS) $(_LNG)\ristndrd.txt > $(O)\$(@B).txt1
    copy $(_INX)\ristndrd.inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +N
    prodfilt $(O)\$(@B).tmp3 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\riprep.inf: $(_INX)\riprep.inx $(_LNG)\riprep.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    $(TSBINPLACE_CMD)


$(O)\minioc.inf: $(_INX)\minioc.inx $(_LNG)\minioc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hfltpci.inf: $(_INX)\hfltpci.inx $(_LNG)\hfltpci.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\msmscsi.inf: $(_INX)\msmscsi.inx $(_LNG)\msmscsi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msmusb.inf: $(_INX)\msmusb.inx $(_LNG)\msmusb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\biosinfo.inf: $(_INX)\biosinfo.inx $(_LNG)\biosinfo.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\unknown.inf: $(_INX)\unknown.inx $(_LNG)\unknown.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\tabletpc.inf: $(_INX)\tablet.inx $(_LNG)\tablet.txt
    $(CC) $(PREFLAGS) $(_LNG)\tablet.txt > $(@B).txt1
    $(CC) $(PREFLAGS) $(_INX)\tablet.inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    @del $(O)\$(@B).inx1
    $(TSBINPLACE_CMD)

$(O)\tabletmui.inf: $(_INX)\tabletmui.inx $(_LNG)\tabletmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    $(CC) $(PREFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    @del $(O)\$(@B).inx1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hal.inf: $(_INX)\hal.inx $(_LNG)\hal.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $(O)\$(@B).tmp1 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\exclude.inf: $(_INX)\exclude.inx $(_LNG)\exclude.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wowlist.inf: $(_INX)\wowlist.inx $(_LNG)\wowlist.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(@)
    @del $(O)\$(@B).txt1
!IF "$(PRODSWITCH)"=="w" || "$(PRODSWITCH)"=="W"
        $(TSBINPLACE_CMD)
!ENDIF

$(O)\wowfrege.inf: $(_INX)\wowfrege.inx $(_LNG)\wowfrege.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    echo [EarlyOleControlDlls] >$(O)\wowfrege.tmp1
    copy $(O)\wowfrege.tmp1+$(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(@)
    @del $(O)\$(@B).txt1
#    $(TSBINPLACE_CMD)

$(O)\wowfrego.inf: $(_INX)\wowfrego.inx $(_LNG)\wowfrego.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    echo [OleControlDlls] >$(O)\wowfrego.tmp1
    copy $(O)\wowfrego.tmp1+$(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(@)
    @del $(O)\$(@B).txt1
#    $(TSBINPLACE_CMD)

$(O)\wowfregc.inf: $(_INX)\wowfregc.inx $(_LNG)\wowfregc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    echo [CryptoDlls] >$(O)\wowfregc.tmp1
    copy $(O)\wowfregc.tmp1+$(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(@)
    @del $(O)\$(@B).txt1
#    $(TSBINPLACE_CMD)

$(O)\wowfile.inf: $(_INX)\wowfile.inx $(_LNG)\wowfile.txt \
                  $(O)\accessor.wow $(O)\communic.wow $(O)\games.wow \
                  $(O)\mmopt.wow $(O)\multimed.wow $(O)\optional.wow \
                  $(O)\pinball.wow $(O)\wordpad.wow $(O)\mdac.wow    \
                  $(O)\msinfo32.wow $(O)\ie.wow $(O)\msoe50.wow      \
                  $(O)\mstask.wow $(O)\wab50.wow $(O)\syssetup.wow $(O)\wsh.wow      \
                  $(O)\apcompat.wow $(O)\intl.wow $(O)\wbemoc.wow \
          $(O)\vgx.wow $(O)\icwnt5.wow
!IF $(IA64)
    echo [SourceDisksFiles.ia64] >$(O)\wowfile.tmp1
!ELSE
    echo [SourceDisksFiles.amd64] >$(O)\wowfile.tmp1
!ENDIF
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    for /f "tokens=*" %%i in ($(O)\$(@B).txt1) do echo w%%i >>$(O)\$(@B).txt2
    for /f "tokens=*" %%i in ($(_INX)\wowfile.inx) do echo w%%i >>$(O)\wowfile.tmp2
    copy $(O)\wowfile.tmp1+$(O)\wowfile.tmp2+$(O)\$(@B).txt2 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $(O)\$(@B).tmp1 +$(PLATFORM_SWITCH)
    del $(O)\$(@B).tmp
    for %%i in ($(O)\accessor.wow $(O)\communic.wow $(O)\games.wow \
                $(O)\mmopt.wow $(O)\multimed.wow $(O)\optional.wow \
                $(O)\pinball.wow $(O)\wordpad.wow $(O)\mdac.wow    \
                $(O)\msinfo32.wow $(O)\ie.wow $(O)\msoe50.wow      \
                $(O)\mstask.wow $(O)\wab50.wow $(O)\syssetup.wow $(O)\wsh.wow      \
                $(O)\apcompat.wow $(O)\intl.wow $(O)\wbemoc.wow $(O)\vgx.wow $(O)\icwnt5.wow)   \
        do type %%i >>$(O)\$(@B).tmp
    copy $(O)\$(@B).tmp1+$(O)\$(@B).tmp $(O)\$(@B).tmp3
    perl $(_INX)\wowfltr.pl /file=$(O)\$(@B).tmp3 > $@
    @del $(O)\$(@B).tmp $(O)\wowfile.tmp1 $(O)\wowfile.tmp2 $(O)\$(@B).tmp1 $(O)\$(@B).txt1 $(O)\$(@B).tmp3 $(O)\$(@B).txt1
#    $(TSBINPLACE_CMD)

$(O)\wowfiled.inf: $(_INX)\wowfile.inx $(_LNG)\wowfile.txt $(_INX)\header2     \
                  $(O)\accessor.wow $(O)\communic.wow $(O)\games.wow           \
                  $(O)\mmopt.wow $(O)\multimed.wow $(O)\optional.wow           \
                  $(O)\pinball.wow $(O)\wordpad.wow $(O)\mdac.wow              \
                  $(O)\msinfo32.wow $(O)\ie.wow $(O)\msoe50.wow                \
                  $(O)\mstask.wow $(O)\wab50.wow $(O)\syssetup.wow $(O)\wsh.wow                \
                  $(O)\apcompat.wow $(O)\intl.wow $(O)\wbemoc.wow \
          $(O)\vgx.wow $(O)\icwnt5.wow
    $(CC) $(PREFLAGS) $(_LNG)\wowfile.txt > $(O)\wowfile.txt1
    for /f "tokens=*" %%i in ($(O)\wowfile.txt1) do echo w%%i >>$(O)\wowfile.txt2
    for /f "tokens=*" %%i in ($(_INX)\wowfile.inx) do echo w%%i >>$(O)\wowfile.tmp1
    copy $(_INX)\header2+$(O)\wowfile.tmp1+$(O)\wowfile.txt2 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $(O)\$(@B).tmp1 +$(PLATFORM_SWITCH)
    del $(O)\$(@B).tmp
    for %%i in ($(O)\accessor.wow $(O)\communic.wow $(O)\games.wow \
                $(O)\mmopt.wow $(O)\multimed.wow $(O)\optional.wow \
                $(O)\pinball.wow $(O)\wordpad.wow $(O)\mdac.wow    \
                $(O)\msinfo32.wow $(O)\ie.wow $(O)\msoe50.wow      \
                $(O)\mstask.wow $(O)\wab50.wow $(O)\syssetup.wow $(O)\wsh.wow      \
                $(O)\apcompat.wow $(O)\intl.wow $(O)\wbemoc.wow $(O)\vgx.wow $(O)\icwnt5.wow)     \
         do type %%i >>$(O)\$(@B).tmp
    copy $(O)\$(@B).tmp1+$(O)\$(@B).tmp $(O)\$(@B).tmp2
    perl $(_INX)\wowfltr.pl /file=$(O)\$(@B).tmp2 > $@
    @del $(O)\$(@B).tmp $(O)\wowfile.tmp1 $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 $(O)\wowfile.txt1 $(O)\wowfile.txt2
#    $(TSBINPLACE_CMD)


$(O)\wowexcp.txt: $(_INX)\wowfile.inx  $(O)\accessor.wow $(O)\communic.wow     \
                  $(O)\games.wow $(O)\mmopt.wow $(O)\multimed.wow              \
                  $(O)\optional.wow $(O)\pinball.wow $(O)\wordpad.wow          \
                  $(O)\mdac.wow $(O)\msinfo32.wow $(O)\ie.wow $(O)\msoe50.wow  \
                  $(O)\mstask.wow $(O)\wab50.wow $(O)\syssetup.wow $(O)\wsh.wow                \
                  $(O)\apcompat.wow $(O)\intl.wow $(O)\intlinfa.wow $(O)\wbemoc.wow $(O)\vgx.wow \
                  $(O)\icwnt5.wow
    if exist $(O)\$(@B).tmp del $(O)\$(@B).tmp
    for %%i in ($(O)\accessor.wow $(O)\communic.wow $(O)\games.wow \
                $(O)\mmopt.wow $(O)\multimed.wow $(O)\optional.wow \
                $(O)\pinball.wow $(O)\wordpad.wow $(O)\mdac.wow    \
                $(O)\msinfo32.wow $(O)\ie.wow $(O)\msoe50.wow      \
                $(O)\mstask.wow $(O)\wab50.wow $(O)\syssetup.wow $(O)\wsh.wow      \
                $(O)\apcompat.wow $(O)\intl.wow $(O)\intlinfa.wow $(O)\wbemoc.wow $(O)\vgx.wow \
        $(O)\icwnt5.wow)    \
         do $(STRIPCHAR) %%i $(O)\$(@B).tmp
    copy /b $(_INX)\wowfile.inx+$(O)\$(@B).tmp $@
    @del $(O)\$(@B).tmp
    $(TSBINPLACE_CMD)

#
# Special infs (and the test certificate, which we deal with along with INFs in
# order to keep all the special magic we do for internal test builds in one
# place)...
#
# Real-signed txtsetup.sif
#

$(_RSINF)\txtsetup.sif: $(O)\txtsetup.inx $(_LNG)\txtsetup.txt $(_LNG)\dskspace.txt $(_RSINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\txtsetup.txt > $(O)\txtsetup.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\$(@B).inx+$(O)\txtsetup.txt1+$(O)\dskspace.txt1 $(O)\txtsetup.tmp1
    prodfilt -s $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\txtsetup.tmp2 $(O)\txtsetup.tmp1 +$(PRODSWITCH)
    copy $(_RSINF)\layout.inf+$(O)\txtsetup.tmp1 $(_RSINF)\txtsetup.sif
    inftest $(_RSINF)\txtsetup.sif /B /$(PLATFORM_SWITCH)
    @del $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 $(O)\txtsetup.txt1 $(O)\dskspace.txt1
    $(RSBINPLACE_CMD)

#
# Coverage Real-signed txtsetup.sif
#

$(_RSCOVINF)\txtsetup.sif: $(O)\txtsetup.inx $(_LNG)\txtsetup.txt $(_LNG)\dskspace.txt $(_RSCOVINF)\layout.inf $(_INX)\$(@B).mcv
    $(CC) $(PREFLAGS) $(_LNG)\txtsetup.txt > $(O)\txtsetup.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\$(@B).inx+$(O)\txtsetup.txt1+$(O)\dskspace.txt1 $(O)\txtsetup.tmp1
    prodfilt -s $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\txtsetup.tmp2 $(O)\txtsetup.tmp1 +$(PRODSWITCH)
    call MergeFiles.cmd $(O)\txtsetup.tmp1 $(_INX)\$(@B).mcv $(O)\txtsetup.tmp2
    copy $(_RSCOVINF)\layout.inf+$(O)\txtsetup.tmp2 $(_RSCOVINF)\txtsetup.sif
    @del $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 $(O)\txtsetup.txt1 $(O)\dskspace.txt1
    $(COVER_RSBINPLACE_CMD)

#
# Test-signed txtsetup.sif
#

$(O)\txtsetup.sif: $(O)\txtsetup.inx $(_LNG)\txtsetup.txt $(_LNG)\dskspace.txt $(O)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\txtsetup.txt > $(O)\txtsetup.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\$(@B).inx+$(O)\txtsetup.txt1+$(O)\dskspace.txt1 $(O)\txtsetup.tmp1
    prodfilt -s $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\txtsetup.tmp2 $(O)\txtsetup.tmp1 +$(PRODSWITCH)
    copy $(O)\layout.inf+$(O)\txtsetup.tmp1 $(O)\txtsetup.sif
    inftest $(O)\txtsetup.sif /B /$(PLATFORM_SWITCH)
    @del $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 $(O)\txtsetup.txt1 $(O)\dskspace.txt1
    $(TSBINPLACE_CMD)

#
# Coverage Test-signed txtsetup.sif
#

$(_COVINF)\txtsetup.sif: $(O)\txtsetup.inx $(_LNG)\txtsetup.txt $(_LNG)\dskspace.txt $(_COVINF)\layout.inf $(_INX)\$(@B).mcv
    $(CC) $(PREFLAGS) $(_LNG)\txtsetup.txt > $(O)\txtsetup.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\$(@B).inx+$(O)\txtsetup.txt1+$(O)\dskspace.txt1 $(O)\txtsetup.tmp1
    prodfilt -s $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\txtsetup.tmp2 $(O)\txtsetup.tmp1 +$(PRODSWITCH)
    call MergeFiles.cmd $(O)\txtsetup.tmp1 $(_INX)\$(@B).mcv $(O)\txtsetup.tmp2
    copy $(_COVINF)\layout.inf+$(O)\txtsetup.tmp2 $(_COVINF)\txtsetup.sif
    @del $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 $(O)\txtsetup.txt1 $(O)\dskspace.txt1
    $(COVER_TSBINPLACE_CMD)

#
# Real-signed dosnet.inf
#

$(_RSINF)\dosnet.inf: $(O)\dosnet.inx $(_LNG)\dosnet.txt \
                      $(_LNG)\dskspace.txt $(_RSINF)\layout.inf \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfiled.inf \
!endif
                      $(O)\layout.inx $(O)\layout.txt $(O)\exclude.inf $(O)\spmap.txt
    $(CC) $(PREFLAGS) $(_LNG)\dosnet.txt > $(O)\dosnet.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\dosnet.inx+$(O)\dosnet.txt1+$(O)\dskspace.txt1 $(O)\dosnet.tmp1
    prodfilt -s $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\dosnet.tmp2 $(O)\dosnet.tmp1 +$(PRODSWITCH)
    copy $(O)\layout.inx+$(O)\layout.txt $(O)\lydosnet.tmp1
    prodfilt -s $(O)\lydosnet.tmp1 $(O)\lydosnet.tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\lydosnet.tmp2 $(O)\lydosnet.tmp1 +$(PLATFORM_SWITCH)
!IF $(WIN64)
    xdosnet $(O)\lydosnet.tmp1 $(O)\dummy 1 $(O)\lydosnet.tmp2 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf $(O)\bootlist.tmp
    copy $(O)\lydosnet.tmp2+$(O)\bootlist.tmp $(O)\lydosnet.tmp3
!else
    xdosnet $(O)\lydosnet.tmp1 $(O)\dummy * $(O)\lydosnet.tmp3 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf
!endif
    copy $(O)\dosnet.tmp1+$(O)\lydosnet.tmp3 $(_RSINF)\dosnet.inf
!IF $(WIN64)
    copy $(_RSINF)\dosnet.inf $(O)\dosnet.tmp3
    copy $(O)\layout.inx+$(O)\layout.txt $(O)\dosnet.tmp1
    prodfilt -s $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 +@
    prodfilt -s $(O)\dosnet.tmp2 $(O)\dosnet.tmp1 +i
    wowlist -i $(O)\dosnet.tmp1 -c $(O)\wowlist.inf -o $(O)\dosnet.tmp2 -ac -h $(O)\wowfiled.inf -f w 2>NUL
    xdosnet $(O)\dosnet.tmp2 $(O)\dummy 2 $(O)\dosnet.tmp1 $(TARGET_DIRECTORY:i386=x86)
    copy $(O)\dosnet.tmp3+$(O)\dosnet.tmp1 $(_RSINF)\dosnet.inf
    perl $(_INX)\splayout.pl $@ $@ $(O)\spmap.txt
    @del $(O)\dosnet.tmp3 $(_INF)\dosnet.tmp2
!ENDIF
    @del $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 $(O)\lydosnet.tmp1 $(O)\lydosnet.tmp2 $(O)\dosnet.txt1 $(O)\dskspace.txt1 $(O)\lydosnet.tmp3 $(O)\bootlist.tmp
    set STAMPINF_VERSION=
    $(STAMP)
    $(RSBINPLACE_CMD)

#
# Coverage Real-signed dosnet.inf
#

$(_RSCOVINF)\dosnet.inf: $(_RSCOVINF)\dosnet.inx $(_LNG)\dosnet.txt $(_INX)\dosnet.mcv \
                      $(_LNG)\dskspace.txt $(_RSCOVINF)\layout.inf \
                      $(_COVINF)\layout.inx $(O)\layout.txt $(O)\exclude.inf $(O)\spmap.txt
    $(CC) $(PREFLAGS) $(_LNG)\dosnet.txt > $(_RSCOVINF)\dosnet.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(_RSCOVINF)\dskspace.txt1
    copy $(_RSCOVINF)\dosnet.inx+$(_RSCOVINF)\dosnet.txt1+$(_RSCOVINF)\dskspace.txt1 $(_RSCOVINF)\dosnet.tmp1
    call MergeFiles.cmd $(_RSCOVINF)\dosnet.tmp1 $(_INX)\dosnet.mcv $(_RSCOVINF)\dosnet.tmp2
    copy $(_RSCOVINF)\dosnet.tmp2 $(_RSCOVINF)\dosnet.tmp1
    prodfilt -s $(_RSCOVINF)\dosnet.tmp1 $(_RSCOVINF)\dosnet.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(_RSCOVINF)\dosnet.tmp2 $(_RSCOVINF)\dosnet.tmp1 +$(PRODSWITCH)
    copy $(_COVINF)\layout.inx+$(_INX)\layout.tst+$(O)\layout.txt $(_RSCOVINF)\lydosnet.tmp1
    prodfilt -s $(_RSCOVINF)\lydosnet.tmp1 $(_RSCOVINF)\lydosnet.tmp2 +$(PRODSWITCH)
    prodfilt -s $(_RSCOVINF)\lydosnet.tmp2 $(_RSCOVINF)\lydosnet.tmp1 +$(PLATFORM_SWITCH)
    xdosnet $(_RSCOVINF)\lydosnet.tmp1 $(_RSCOVINF)\dummy * $(_RSCOVINF)\lydosnet.tmp3 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf
    copy $(_RSCOVINF)\dosnet.tmp1+$(_RSCOVINF)\lydosnet.tmp3 $(_RSCOVINF)\dosnet.inf
    perl $(_INX)\splayout.pl $@ $@ $(O)\spmap.txt
    @del $(_RSCOVINF)\dosnet.tmp1 $(_RSCOVINF)\dosnet.tmp2 $(_RSCOVINF)\lydosnet.tmp1 $(_RSCOVINF)\lydosnet.tmp2 $(_RSCOVINF)\dosnet.txt1 $(_RSCOVINF)\dskspace.txt1 $(_RSCOVINF)\lydosnet.tmp3 $(_RSCOVINF)\bootlist.tmp
    set STAMPINF_VERSION=
    $(STAMP)
    $(COVER_RSBINPLACE_CMD)

#
# Test-signed dosnet.inf
# Note we need to create a native layout.inf for xdosnet.exe with no wow files
# present
#

$(O)\dosnet.inf: $(O)\dosnet.inx $(_LNG)\dosnet.txt \
                    $(_LNG)\dskspace.txt $(O)\layout.inf \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfiled.inf \
!endif
                    $(O)\layout.inx $(O)\layout.txt $(O)\exclude.inf $(O)\spmap.txt
    $(CC) $(PREFLAGS) $(_LNG)\dosnet.txt > $(O)\dosnet.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\dosnet.inx+$(O)\dosnet.txt1+$(O)\dskspace.txt1 $(O)\dosnet.tmp1
    prodfilt -s $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\dosnet.tmp2 $(O)\dosnet.tmp1 +$(PRODSWITCH)
    copy $(O)\layout.inx+$(_INX)\layout.tst+$(O)\layout.txt $(O)\lydosnet.tmp1
    prodfilt -s $(O)\lydosnet.tmp1 $(O)\lydosnet.tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\lydosnet.tmp2 $(O)\lydosnet.tmp1 +$(PLATFORM_SWITCH)
!IF $(WIN64)
    xdosnet $(O)\lydosnet.tmp1 $(O)\dummy 1 $(O)\lydosnet.tmp2 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf $(O)\bootlist.tmp
    copy $(O)\lydosnet.tmp2+$(O)\bootlist.tmp $(O)\lydosnet.tmp3
!else
    xdosnet $(O)\lydosnet.tmp1 $(O)\dummy * $(O)\lydosnet.tmp3 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf
!endif
    copy $(O)\dosnet.tmp1+$(O)\lydosnet.tmp3 $(O)\dosnet.inf
!IF $(WIN64)
    copy $(_INF)\dosnet.inf $(O)\dosnet.tmp3
    copy $(O)\layout.inx+$(O)\layout.txt $(O)\dosnet.tmp1
    prodfilt -s $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 +@
    prodfilt -s $(O)\dosnet.tmp2 $(O)\dosnet.tmp1 +i
    wowlist -i $(O)\dosnet.tmp1 -c $(O)\wowlist.inf -o $(O)\dosnet.tmp2 -ac -h $(O)\wowfiled.inf -f w 2>NUL
    xdosnet $(O)\dosnet.tmp2 $(O)\dummy 2 $(O)\dosnet.tmp1 $(TARGET_DIRECTORY:i386=x86)
    copy $(O)\dosnet.tmp3+$(O)\dosnet.tmp1 $(_INF)\dosnet.inf
    perl $(_INX)\splayout.pl $@ $@ $(O)\spmap.txt
    @del $(O)\dosnet.tmp3 $(_INF)\dosnet.tmp2
!ENDIF
    @del $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 $(O)\lydosnet.tmp1 $(O)\lydosnet.tmp2 $(O)\dosnet.txt1 $(O)\dskspace.txt1 $(O)\lydosnet.tmp3 $(O)\bootlist.tmp
    set STAMPINF_VERSION=
    $(STAMP)
    $(TSBINPLACE_CMD)

#
# Coverage Test-signed dosnet.inf
# Note we need to create a native layout.inf for xdosnet.exe with no wow files
# present
#

$(_COVINF)\dosnet.inf: $(_COVINF)\dosnet.inx $(_LNG)\dosnet.txt $(_INX)\dosnet.mcv \
                       $(_LNG)\dskspace.txt $(_COVINF)\layout.inf \
                       $(_COVINF)\layout.inx $(O)\layout.txt $(O)\exclude.inf
    $(CC) $(PREFLAGS) $(_LNG)\dosnet.txt > $(_COVINF)\dosnet.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(_COVINF)\dskspace.txt1
    copy $(_COVINF)\dosnet.inx+$(_COVINF)\dosnet.txt1+$(_COVINF)\dskspace.txt1 $(_COVINF)\dosnet.tmp1
    call MergeFiles.cmd $(_COVINF)\dosnet.tmp1 $(_INX)\dosnet.mcv $(_COVINF)\dosnet.tmp2
    copy $(_COVINF)\dosnet.tmp2 $(_COVINF)\dosnet.tmp1
    prodfilt -s $(_COVINF)\dosnet.tmp1 $(_COVINF)\dosnet.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(_COVINF)\dosnet.tmp2 $(_COVINF)\dosnet.tmp1 +$(PRODSWITCH)
    copy $(_COVINF)\layout.inx+$(_INX)\layout.tst+$(O)\layout.txt $(_COVINF)\lydosnet.tmp1
    prodfilt -s $(_COVINF)\lydosnet.tmp1 $(_COVINF)\lydosnet.tmp2 +$(PRODSWITCH)
    prodfilt -s $(_COVINF)\lydosnet.tmp2 $(_COVINF)\lydosnet.tmp1 +$(PLATFORM_SWITCH)
    xdosnet $(_COVINF)\lydosnet.tmp1 $(_COVINF)\dummy * $(_COVINF)\lydosnet.tmp3 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf
    copy $(_COVINF)\dosnet.tmp1+$(_COVINF)\lydosnet.tmp3 $(_COVINF)\dosnet.inf
    @del $(_COVINF)\dosnet.tmp1 $(_COVINF)\dosnet.tmp2 $(_COVINF)\lydosnet.tmp1 $(_COVINF)\lydosnet.tmp2 $(_COVINF)\dosnet.txt1 $(_COVINF)\dskspace.txt1 $(_COVINF)\lydosnet.tmp3 $(_COVINF)\bootlist.tmp
    set STAMPINF_VERSION=
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)


$(O)\sfcgen.inf: $(_INX)\sfcgen.inx $(_LNG)\sfcgen.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\legacy.inf: $(_INX)\legacy.inf
    copy $(_INX)\legacy.inf $(O)\.
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\certclas.inf: $(_INX)\certclas.inf
    prodfilt $(_INX)\certclas.inf $@ +$(PLATFORM_SWITCH)
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\testroot.cer: $(_INX)\testroot.cer
    copy $(_INX)\testroot.cer $(O)\.
    $(TSBINPLACE_CMD)

#
# BEGIN PCHealth preprocessing.
#
$(O)\pchmui.inf: $(_INX)\pchmui.inx $(_LNG)\pchmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\pchealth.inf: $(_INX)\pchealth.inx $(_LNG)\pchealth.txt
    $(CC) $(PREFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).tmp1
    copy $(O)\$(@B).tmp1+$(_LNG)\$(@B).txt $(O)\$(@B).tmp2
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp3 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    $(TSBINPLACE_CMD)
#
# END PCHealth preprocessing.
#

$(O)\apphlpui.inf: $(_INX)\apphlpui.inx $(_LNG)\apphlpui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sr.inf: $(_INX)\sr.inx $(_LNG)\sr.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    $(TSBINPLACE_CMD)

$(O)\mmdriver.inf: $(_INX)\mmdriver.inx
    prodfilt -s $(_INX)\$(@B).inx $@ +$(PRODSWITCH)
    $(TSBINPLACE_CMD)

$(O)\ie5ui.inf: $(_INX)\ie5ui.inx $(_LNG)\ie5ui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wie5ui.inf: $(_INX)\wie5ui.inx $(_LNG)\wie5ui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\moviemui.inf: $(_INX)\moviemui.inx $(_LNG)\moviemui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ermui.inf: $(_INX)\ermui.inx $(_LNG)\ermui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wermui.inf: $(_INX)\wermui.inx $(_LNG)\wermui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\tourmui.inf: $(_INX)\tourmui.inx $(_LNG)\tourmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\drivercab.inf: $(_INX)\drivercab.inx $(_LNG)\drivercab.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

#
# icwnt5.inf
# Note: THis is currently not run through prodfilt. You will need to do that if you make any platform specific or
# product specific changes to the inx/txt file in the future.
#


$(O)\icwnt5.inf: $(_INX)\icwnt5.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                 $(_LNG)\icwnt5.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$@
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp2
    wowlist -i $@ -c $(O)\wowlist.inf -as -f w -d $(O)\icwnt5.wow -o $(O)\$(@B).tmp3
    copy $(O)\$(@B).tmp2+$(O)\$(@B).tmp3 $@
    @del $(O)\$(@B).tmp2 $(O)\$(@B).tmp3
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\icwnt5.wow: $(O)\icwnt5.inf
!endif

$(O)\ieaccess.inf: $(_INX)\ieaccess.inx $(_LNG)\ieaccess.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\oeaccess.inf: $(_INX)\oeaccess.inx $(_LNG)\oeaccess.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\drvindex.inf: $(_INX)\drvindex.inx $(O)\spmap.txt
    $(CC) $(PREFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    perl $(_INX)\spdrivers.pl $(O)\$(@B).tmp3 $@ $(O)\spmap.txt
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    $(TSBINPLACE_CMD)



#
# Update.inf's for both Hotfixes and Service Pack are
# both built using update.inx and update.txt
#
# Update.inf
#
$(O)\update.inf: $(_INX)\update.inx $(_LNG)\update.txt $(O)\ietoken.mak
    $(CC) $(PREFLAGS) /DIE_VERS=$(IE_VERS) $(_INX)\update.inx > $(O)\$(@B).inx1
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt  > $(O)\$(@B).txt1
    infmerge.exe $(O)\$(@B).inx1 $(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).inftok +u
    nmake -f $(O)\ietoken.mak $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).inx1
    @del $(O)\$(@B).txt1
    @del $(O)\$(@B).inftok
!if "$(PRODSWITCH)"=="w" || "$(PRODSWITCH)"=="W"
    $(TSBINPLACE_CMD)
!endif

#
# Hotfix.inf using update.inx
#
$(O)\hotfix.inf: $(_INX)\update.inx $(_LNG)\update.txt
    $(CC) $(PREFLAGS) /DIE_VERS=$(IE_VERS) /DQFE_NUM=$(QFE_NUM) $(_INX)\update.inx > $(O)\$(@B).inx1
    $(CC) $(PREFLAGS) $(_LNG)\update.txt  > $(O)\$(@B).txt1
    infmerge.exe $(O)\$(@B).inx1 $(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +h
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).inx1
    @del $(O)\$(@B).txt1
!if "$(PRODSWITCH)"=="w" || "$(PRODSWITCH)"=="W"
    $(TSBINPLACE_CMD)
!endif

#
# Make files used in constructing the service pack.
#
$(O)\infsect.tbl: $(_INX)\infsect.inx $(_LNG)\infsect.txt
    prodfilt $(_LNG)\infsect.txt $(O)\$(@B).txt1 +$(PLATFORM_SWITCH)
    perl $(_INX)\maketable.pl $(O)\$(@B).inx1 $(_INX)\infsect.inx $(O)\$(@B).txt1
    prodfilt $(O)\$(@B).inx1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).txt1
    @del $(O)\$(@B).inx1
!if "$(PRODSWITCH)"=="w" || "$(PRODSWITCH)"=="W"
    $(TSBINPLACE_CMD)
!endif

$(O)\spmap.txt: $(_INX)\spmap.inx $(_LNG)\spmap.txt
    prodfilt $(_LNG)\spmap.txt $(O)\$(@B).txt1 +$(PLATFORM_SWITCH)
    perl $(_INX)\maketable.pl $(O)\$(@B).inx1 $(_INX)\spmap.inx $(O)\$(@B).txt1
    prodfilt $(O)\$(@B).inx1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).txt1
    @del $(O)\$(@B).inx1
!if "$(PRODSWITCH)"=="w" || "$(PRODSWITCH)"=="W"
    $(TSBINPLACE_CMD)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\makefile.inc ===
#################################################
# HOW TO UPDATE THIS FILE:
#
# 1. If you're adding a file that's the same in all sku's, skip down
#    to the BINPLACE_ONLY_FILES section and add your filename there
#
# 2. If you're adding a file that's different for one or more sku,
#    add it to the PREPROCESSED_HTMS macro.
#
# 3. There's no need to add it to both.
#

!ifndef BUILD_SPECIFIC_INFS

LCID=409
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!if "$(LANGUAGE)"=="CHS" || "$(LANGUAGE)"=="chs"
# Chinese, Simplified
LCID=804

!elseif "$(LANGUAGE)"=="CHT" || "$(LANGUAGE)"=="cht"
# Chinese, Traditional
LCID=404

!elseif "$(LANGUAGE)"=="CHH" || "$(LANGUAGE)"=="chh"
# Chinese, Traditional
LCID=C04

!elseif "$(LANGUAGE)"=="JPN" || "$(LANGUAGE)"=="jpn"
# Japanese
LCID=411

!elseif "$(LANGUAGE)"=="KOR" || "$(LANGUAGE)"=="kor"
# Korean
LCID=412

!elseif "$(LANGUAGE)"=="ARA" || "$(LANGUAGE)"=="ara"
# Arabic
LCID=401

!elseif "$(LANGUAGE)"=="HEB" || "$(LANGUAGE)"=="heb"
# Hebrew
LCID=40D

!elseif "$(LANGUAGE)"=="CS" || "$(LANGUAGE)"=="cs"
# Czech
LCID=405

!elseif "$(LANGUAGE)"=="HU" || "$(LANGUAGE)"=="hu"
# Hungarian
LCID=40E

!elseif "$(LANGUAGE)"=="PL" || "$(LANGUAGE)"=="pl"
# Polish
LCID=415

!elseif "$(LANGUAGE)"=="RU" || "$(LANGUAGE)"=="ru"
# Russian
LCID=419

!elseif "$(LANGUAGE)"=="EL" || "$(LANGUAGE)"=="el"
# Greek
LCID=408

!elseif "$(LANGUAGE)"=="TR" || "$(LANGUAGE)"=="tr"
# Turkish
LCID=41F

!elseif "$(LANGUAGE)"=="PSU" || "$(LANGUAGE)"=="psu"
LCID=408
!endif


!IF "$(TARGET_DIRECTORY)"=="i386"  || "$(TARGET_DIRECTORY)"=="I386"
PLATFORM_SWITCH=i
!ELSEIF "$(TARGET_DIRECTORY)"=="ia64"  || "$(TARGET_DIRECTORY)"=="IA64"
PLATFORM_SWITCH=m
!ELSEIF "$(TARGET_DIRECTORY)"=="amd64"  || "$(TARGET_DIRECTORY)"=="AMD64"
PLATFORM_SWITCH=a
!ELSE
! ERROR Invalid Platform Switch for infs
!ENDIF

PREFLAGS=/DLANGUAGE_ID=0x0$(LCID) -nologo /EP


_SRC=..\..
_LNG=$(_SRC)\$(LANGUAGE)

.SUFFIXES: .htm .txt

PREPROCESSED_HTMS= \
          $(O)\alpsprt.htm  \
          $(O)\alpsprt.txt  \
          $(O)\artcas6e.htm  \
          $(O)\artcas6e.txt  \
          $(O)\cano620p.htm \
          $(O)\cano620p.txt \
          $(O)\canos100.htm \
          $(O)\canos100.txt \
          $(O)\cnbj51.htm   \
          $(O)\cnbj51.txt   \
          $(O)\cnmulti1.htm  \
          $(O)\cnmulti1.txt  \
          $(O)\cpqij.htm    \
          $(O)\cpqij.txt    \
          $(O)\epscolor.htm \
          $(O)\epscolor.txt \
          $(O)\epson1.htm   \
          $(O)\epson1.txt   \
          $(O)\epson3.htm   \
          $(O)\epson3.txt   \
          $(O)\epson4.htm   \
          $(O)\epson4.txt   \
          $(O)\epsp1270.htm \
          $(O)\epsp1270.txt \
          $(O)\epsphoto.htm \
          $(O)\epsphoto.txt \
          $(O)\gsnw.htm     \
          $(O)\hp3300C.htm  \
          $(O)\hp3300C.txt  \
          $(O)\hp4050p6.htm \
          $(O)\hp4050p6.txt \
          $(O)\hp4300C.htm  \
          $(O)\hp4300C.txt  \
          $(O)\hp5300C.htm  \
          $(O)\hp5300C.txt  \
          $(O)\hpaio1.htm    \
          $(O)\hpaio1.txt    \
          $(O)\hpaio2.htm    \
          $(O)\hpaio2.txt    \
          $(O)\hpclj450.htm  \
          $(O)\hpclj450.txt  \
          $(O)\hpclj850.htm  \
          $(O)\hpclj850.txt  \
          $(O)\hpdj1000.htm  \
          $(O)\hpdj1000.txt  \
          $(O)\hpdj610.htm   \
          $(O)\hpdj610.txt   \
          $(O)\hpdj810.htm   \
          $(O)\hpdj810.txt   \
          $(O)\hpdj815.htm   \
          $(O)\hpdj815.txt   \
          $(O)\hpdj830.htm   \
          $(O)\hpdj830.txt   \
          $(O)\hpdj880.htm   \
          $(O)\hpdj880.txt   \
          $(O)\hpdj900.htm   \
          $(O)\hpdj900.txt   \
          $(O)\hpdsk1.htm    \
          $(O)\hpdsk1.txt    \
          $(O)\hpdsk10.htm   \
          $(O)\hpdsk10.txt   \
          $(O)\hpdsk11.htm   \
          $(O)\hpdsk11.txt   \
          $(O)\hpdsk12.htm   \
          $(O)\hpdsk12.txt   \
          $(O)\hpdsk13.htm   \
          $(O)\hpdsk13.txt   \
          $(O)\hpdsk14.htm   \
          $(O)\hpdsk14.txt   \
          $(O)\hpdsk2.htm    \
          $(O)\hpdsk2.txt    \
          $(O)\hpdsk3.htm    \
          $(O)\hpdsk3.txt    \
          $(O)\hpdsk4.htm    \
          $(O)\hpdsk4.txt    \
          $(O)\hpdsk5.htm    \
          $(O)\hpdsk5.txt    \
          $(O)\hpdsk6.htm    \
          $(O)\hpdsk6.txt    \
          $(O)\hpdsk7.htm    \
          $(O)\hpdsk7.txt    \
          $(O)\hpdsk8.htm    \
          $(O)\hpdsk8.txt    \
          $(O)\hpdsk9.htm    \
          $(O)\hpdsk9.txt    \
          $(O)\hplj1100.htm  \
          $(O)\hplj1100.txt  \
          $(O)\hplj4050.htm  \
          $(O)\hplj4050.txt  \
          $(O)\hplj5e.htm    \
          $(O)\hplj5e.txt    \
          $(O)\hpojg.htm    \
          $(O)\hpojg.txt    \
          $(O)\hpps.htm     \
          $(O)\hpps.txt     \
          $(O)\hp_pld.htm   \
          $(O)\hp_pld.txt   \
          $(O)\kodk4800.htm   \
          $(O)\kodk4800.txt   \
          $(O)\lex3200.htm  \
          $(O)\lex3200.txt  \
          $(O)\lexoptra.htm \
          $(O)\lexoptra.txt \
          $(O)\lm5700.htm   \
          $(O)\lm5700.txt   \
          $(O)\lmoptra.htm  \
          $(O)\lmoptra.txt  \
          $(O)\lqdaudio.htm \
          $(O)\mcrotk60.htm   \
          $(O)\mcrotk60.txt   \
          $(O)\mcrotkc3.htm \
          $(O)\mcrotkc3.txt \
          $(O)\mcrotks.htm  \
          $(O)\mcrotks.txt  \
          $(O)\mfpbr.htm    \
          $(O)\mfpbr.txt    \
          $(O)\mfphp.htm    \
          $(O)\mfphp.txt    \
          $(O)\min8e.htm \
          $(O)\min8e.txt \
          $(O)\minpw20.htm  \
          $(O)\minpw20.txt  \
          $(O)\mnlt1.htm    \
          $(O)\mnlt1.txt    \
          $(O)\mta57080.htm \
          $(O)\mta57080.txt \
          $(O)\necpg1.htm   \
          $(O)\necpg1.txt   \
          $(O)\ntcompat.inf \
          $(O)\okipg1.htm   \
          $(O)\okipg1.txt   \
          $(O)\okipg2.htm   \
          $(O)\okipg2.txt   \
          $(O)\okipg8w.htm \
          $(O)\okipg8w.txt \
          $(O)\plust120.htm   \
          $(O)\plust120.txt   \
          $(O)\sfunfscg.htm   \
          $(O)\sfunfscg.txt   \
          $(O)\tmaster.htm \
          $(O)\tmaster.txt \
          $(O)\tmdualag.htm \
          $(O)\tmdualag.txt \
          $(O)\visn5300.htm \
          $(O)\visn5300.txt \
          $(O)\visn6100.htm \
          $(O)\visn6100.txt \
          $(O)\winachsf.htm \
          $(O)\xerox1.htm   \
          $(O)\xerox1.txt   \
          $(O)\xerox2.htm   \
          $(O)\xerox2.txt   \
          $(O)\xerox4.htm   \
          $(O)\xerox4.txt   \
          $(O)\xerox5.htm   \
          $(O)\xerox5.txt   \
          $(O)\xerox6.htm   \
          $(O)\xerox6.txt   \
          $(O)\xeroxwct.htm \
          $(O)\xeroxwct.txt

BINPLACE_ONLY_FILES = \
!if "$(PRODSWITCH)" == "s"
          $(_SRC)\ClusComp.htm \
          $(_SRC)\ClusComp.txt \
!elseif "$(PRODSWITCH)" == "w"
          $(_SRC)\3com.htm     \
          $(_SRC)\3com.txt     \
          $(_SRC)\aacraid.htm  \
          $(_SRC)\aacraid.txt  \
          $(_SRC)\acer640p.htm \
          $(_SRC)\acer640p.txt \
          $(_SRC)\aclient.htm  \
          $(_SRC)\aclient.txt  \
          $(_SRC)\acs.htm      \
          $(_SRC)\acs.txt      \
          $(_SRC)\adaptec.htm  \
          $(_SRC)\adaptec.txt  \
          $(_SRC)\admpkw2k.htm \
          $(_SRC)\admpkw2k.txt \
          $(_SRC)\admpkxp.htm \
          $(_SRC)\admpkxp.txt \
          $(_SRC)\aha8940.htm  \
          $(_SRC)\aha8940.txt  \
          $(_SRC)\aicdrv.htm   \
          $(_SRC)\aicdrv.txt   \
          $(_SRC)\alkb2k.htm   \
          $(_SRC)\alkb2k.txt   \
          $(_SRC)\apmerror.htm \
          $(_SRC)\apmerror.txt \
          $(_SRC)\apfiltr.htm  \
          $(_SRC)\apfiltr.txt  \
          $(_SRC)\assetci.htm  \
          $(_SRC)\assetci.txt  \
          $(_SRC)\atguard.htm  \
          $(_SRC)\atguard.txt  \
          $(_SRC)\atkproto.htm \
          $(_SRC)\atkproto.txt \
          $(_SRC)\avpgatek.htm \
          $(_SRC)\avpgatek.txt \
          $(_SRC)\award.htm    \
          $(_SRC)\award.txt    \
          $(_SRC)\bayman.htm    \
          $(_SRC)\bayman.txt    \
          $(_SRC)\blackice.htm \
          $(_SRC)\blackice.txt \
          $(_SRC)\boserror.htm \
          $(_SRC)\boserror.txt \
          $(_SRC)\calcomp.htm  \
          $(_SRC)\calcomp.txt  \
          $(_SRC)\cardexec.htm \
          $(_SRC)\cardexec.txt \
          $(_SRC)\cdr4vsd.htm  \
          $(_SRC)\cdr4vsd.txt  \
          $(_SRC)\certsrv.htm  \
          $(_SRC)\certsrv.txt  \
          $(_SRC)\cic.htm      \
          $(_SRC)\cic.txt      \
          $(_SRC)\CiMgr.htm \
          $(_SRC)\CiMgr.txt \
          $(_SRC)\ciscoacu.htm \
          $(_SRC)\ciscoacu.txt \
          $(_SRC)\cldvd.htm    \
          $(_SRC)\cldvd.txt    \
          $(_SRC)\cltmgr.htm   \
          $(_SRC)\cltmgr.txt   \
          $(_SRC)\cpqdiagc.htm \
          $(_SRC)\cpqdiagc.txt \
          $(_SRC)\cpqkbd.htm   \
          $(_SRC)\cpqkbd.txt   \
          $(_SRC)\cpqmulti.htm \
          $(_SRC)\cpqmulti.txt \
          $(_SRC)\cpqpnpmg.htm \
          $(_SRC)\cpqpnpmg.txt \
          $(_SRC)\cpqpwrex.htm \
          $(_SRC)\cpqpwrex.txt \
          $(_SRC)\cpufeat.htm  \
          $(_SRC)\cpufeat.txt  \
          $(_SRC)\crashmon.htm \
          $(_SRC)\crashmon.txt \
          $(_SRC)\cruise.htm   \
          $(_SRC)\cruise.txt   \
          $(_SRC)\crystal.htm  \
          $(_SRC)\crystal.txt  \
          $(_SRC)\cs4281.htm   \
          $(_SRC)\cs4281.txt   \
          $(_SRC)\csa64xx.htm  \
          $(_SRC)\csa64xx.txt  \
          $(_SRC)\csmigrat.htm \
          $(_SRC)\csmigrat.txt \
          $(_SRC)\csrem32.htm  \
          $(_SRC)\csrem32.txt  \
          $(_SRC)\ctz_crdl.htm \
          $(_SRC)\ctz_crdl.txt \
          $(_SRC)\dayt.htm \
          $(_SRC)\dayt.txt \
          $(_SRC)\decatapi.htm \
          $(_SRC)\decatapi.txt \
          $(_SRC)\decml.htm    \
          $(_SRC)\decml.txt    \
          $(_SRC)\delperc2.htm \
          $(_SRC)\delperc2.txt \
          $(_SRC)\dellps.htm   \
          $(_SRC)\dellps.txt   \
          $(_SRC)\dellth.htm   \
          $(_SRC)\dellth.txt   \
          $(_SRC)\directcd.htm \
          $(_SRC)\directcd.txt \
          $(_SRC)\dlcproto.htm    \
          $(_SRC)\dlcproto.txt    \
          $(_SRC)\dmibios.htm  \
          $(_SRC)\dmibios.txt  \
          $(_SRC)\dock.htm     \
          $(_SRC)\dock.txt     \
          $(_SRC)\docksvc.htm  \
          $(_SRC)\docksvc.txt  \
          $(_SRC)\drvncdb.htm  \
          $(_SRC)\drvncdb.txt  \
          $(_SRC)\dsmu.htm     \
          $(_SRC)\dsmu.txt     \
          $(_SRC)\dv_comp.htm  \
          $(_SRC)\dv_comp.txt  \
          $(_SRC)\dv_gen.htm   \
          $(_SRC)\dv_gen.txt   \
          $(_SRC)\dwrite.htm   \
          $(_SRC)\dwrite.txt   \
          $(_SRC)\eiconta.htm  \
          $(_SRC)\eiconta.txt  \
          $(_SRC)\elsamx.htm \
          $(_SRC)\elsamx.txt \
          $(_SRC)\ensoniqv.htm \
          $(_SRC)\ensoniqv.txt \
          $(_SRC)\ensqaudm.htm \
          $(_SRC)\ensqaudm.txt \
          $(_SRC)\exchange.htm \
          $(_SRC)\exchange.txt \
          $(_SRC)\fazam.htm    \
          $(_SRC)\fazam.txt    \
          $(_SRC)\fidmou.htm   \
          $(_SRC)\fidmou.txt   \
          $(_SRC)\fjhwmn.htm   \
          $(_SRC)\fjhwmn.txt   \
          $(_SRC)\fjpman.htm   \
          $(_SRC)\fjpman.txt   \
          $(_SRC)\flowch7.htm  \
          $(_SRC)\flowch7.txt  \
          $(_SRC)\ftcomp1.htm   \
          $(_SRC)\ftcomp1.txt   \
          $(_SRC)\ftcomp2.htm   \
          $(_SRC)\ftcomp2.txt   \
          $(_SRC)\ftcomp3.htm   \
          $(_SRC)\ftcomp3.txt   \
          $(_SRC)\generic.htm  \
          $(_SRC)\generic.txt  \
          $(_SRC)\genius.htm   \
          $(_SRC)\genius.txt   \
          $(_SRC)\glint.htm    \
          $(_SRC)\glint.txt    \
          $(_SRC)\gsnw.txt     \
          $(_SRC)\halhook.htm  \
          $(_SRC)\halhook.txt  \
          $(_SRC)\hdmib.htm    \
          $(_SRC)\hdmib.txt    \
          $(_SRC)\hdmon.htm    \
          $(_SRC)\hdmon.txt    \
          $(_SRC)\hercules.htm  \
          $(_SRC)\hercules.txt  \
          $(_SRC)\hpcompat.htm \
          $(_SRC)\hpcompat.txt \
          $(_SRC)\hpdmi.htm    \
          $(_SRC)\hpdmi.txt    \
          $(_SRC)\hpi_usb.htm  \
          $(_SRC)\hpi_usb.txt  \
          $(_SRC)\hplock.htm   \
          $(_SRC)\hplock.txt   \
          $(_SRC)\hpmmkb.htm   \
          $(_SRC)\hpmmkb.txt   \
          $(_SRC)\hpmon.htm    \
          $(_SRC)\hpmon.txt    \
          $(_SRC)\hpnrd4m.htm  \
          $(_SRC)\hpnrd4m.txt  \
          $(_SRC)\hpsmart.htm  \
          $(_SRC)\hpsmart.txt  \
          $(_SRC)\hpsparnt.htm \
          $(_SRC)\hpsparnt.txt \
          $(_SRC)\hpttidm.htm  \
          $(_SRC)\hpttidm.txt  \
          $(_SRC)\iavboot4.htm \
          $(_SRC)\iavboot4.txt \
          $(_SRC)\i2cnt.htm    \
          $(_SRC)\i2cnt.txt    \
          $(_SRC)\ibmir.htm    \
          $(_SRC)\ibmir.txt    \
          $(_SRC)\ibmmpg.htm   \
          $(_SRC)\ibmmpg.txt   \
          $(_SRC)\ibmsva.htm   \
          $(_SRC)\ibmsva.txt   \
          $(_SRC)\ibmtp4.htm   \
          $(_SRC)\ibmtp4.txt   \
          $(_SRC)\ibm_ums.htm  \
          $(_SRC)\ibm_ums.txt  \
          $(_SRC)\ibmvc.htm    \
          $(_SRC)\ibmvc.txt    \
          $(_SRC)\icpv.htm     \
          $(_SRC)\icpv.txt     \
          $(_SRC)\icsupgrd.htm \
          $(_SRC)\icsupgrd.txt \
          $(_SRC)\ils.htm      \
          $(_SRC)\ils.txt      \
          $(_SRC)\imation.htm  \
          $(_SRC)\imation.txt  \
          $(_SRC)\incompat.htm \
          $(_SRC)\incompat.txt \
          $(_SRC)\initio.htm   \
          $(_SRC)\initio.txt   \
          $(_SRC)\intelapp.htm \
          $(_SRC)\intelapp.txt \
          $(_SRC)\intelata.htm \
          $(_SRC)\intelata.txt \
          $(_SRC)\intellip.htm \
          $(_SRC)\intellip.txt \
          $(_SRC)\intlsisl.htm \
          $(_SRC)\intlsisl.txt \
          $(_SRC)\ioclick.htm  \
          $(_SRC)\ioclick.txt  \
          $(_SRC)\iomega.htm   \
          $(_SRC)\iomega.txt   \
          $(_SRC)\ishrnt.htm   \
          $(_SRC)\ishrnt.txt   \
          $(_SRC)\isotp4.htm   \
          $(_SRC)\isotp4.txt   \
          $(_SRC)\isvgina.htm  \
          $(_SRC)\isvgina.txt  \
          $(_SRC)\ix526fc.htm  \
          $(_SRC)\ix526fc.txt  \
          $(_SRC)\kmw.htm      \
          $(_SRC)\kmw.txt      \
          $(_SRC)\krnlchk.htm      \
          $(_SRC)\krnlchk.txt      \
          $(_SRC)\laplink.htm  \
          $(_SRC)\laplink.txt  \
          $(_SRC)\laplnk2k.htm \
          $(_SRC)\laplnk2k.txt \
          $(_SRC)\ldcm.htm     \
          $(_SRC)\ldcm.txt     \
          $(_SRC)\lexdlc.htm   \
          $(_SRC)\lexdlc.txt   \
          $(_SRC)\lextcp.htm   \
          $(_SRC)\lextcp.txt   \
          $(_SRC)\lm75.htm     \
          $(_SRC)\lm75.txt     \
          $(_SRC)\lm78.htm     \
          $(_SRC)\lm78.txt     \
          $(_SRC)\lmrepl.htm   \
          $(_SRC)\lmrepl.txt   \
          $(_SRC)\logitech.htm \
          $(_SRC)\logitech.txt \
          $(_SRC)\logkcmd.htm  \
          $(_SRC)\logkcmd.txt  \
          $(_SRC)\lqdaudio.txt \
          $(_SRC)\ltmodem.htm  \
          $(_SRC)\ltmodem.txt  \
          $(_SRC)\macdrive.htm \
          $(_SRC)\macdrive.txt \
          $(_SRC)\maestro0.htm \
          $(_SRC)\maestro0.txt \
          $(_SRC)\maxell.htm   \
          $(_SRC)\maxell.txt   \
          $(_SRC)\mca.htm      \
          $(_SRC)\mca.txt      \
          $(_SRC)\mcfilter.htm \
          $(_SRC)\mcfilter.txt \
	  $(_SRC)\melco.htm    \
          $(_SRC)\melco.txt    \
          $(_SRC)\mgactrl.htm  \
          $(_SRC)\mgactrl.txt  \
          $(_SRC)\mpath.htm    \
          $(_SRC)\mpath.txt    \
          $(_SRC)\msmqcomp.htm \
          $(_SRC)\msmqcomp.txt \
          $(_SRC)\msp1.htm     \
          $(_SRC)\msp1.txt     \
          $(_SRC)\msp2.htm     \
          $(_SRC)\msp2.txt     \
          $(_SRC)\msss3.htm     \
          $(_SRC)\msss3.txt     \
          $(_SRC)\mstock.htm   \
          $(_SRC)\mstock.txt   \
          $(_SRC)\nav5.htm    \
          $(_SRC)\nav5.txt    \
          $(_SRC)\nbfproto.htm    \
          $(_SRC)\nbfproto.txt    \
          $(_SRC)\NdcPrtNS.htm \
          $(_SRC)\NdcPrtNS.txt \
          $(_SRC)\netfmigt.htm \
          $(_SRC)\netfmigt.txt \
          $(_SRC)\nmsms.htm   \
          $(_SRC)\nmsms.txt   \
          $(_SRC)\ntdsupg.htm  \
          $(_SRC)\ntdsupg.txt  \
          $(_SRC)\ntdsupgd.htm \
          $(_SRC)\ntdsupgd.txt \
          $(_SRC)\nv_agp.htm   \
          $(_SRC)\nv_agp.txt   \
          $(_SRC)\nwcli32.htm \
          $(_SRC)\nwcli32.txt \
          $(_SRC)\ocablock.htm \
          $(_SRC)\ocablock.txt \
          $(_SRC)\oilchg25.htm \
          $(_SRC)\oilchg25.txt \
          $(_SRC)\omc.htm      \
          $(_SRC)\omc.txt      \
          $(_SRC)\Omnipg10.htm \
          $(_SRC)\Omnipg10.txt \
          $(_SRC)\onstream.htm \
          $(_SRC)\onstream.txt \
          $(_SRC)\orb.htm      \
          $(_SRC)\orb.txt      \
          $(_SRC)\palm.htm     \
          $(_SRC)\palm.txt     \
          $(_SRC)\panadvd.htm  \
          $(_SRC)\panadvd.txt  \
          $(_SRC)\panda.htm    \
          $(_SRC)\panda.txt    \
          $(_SRC)\pcany.htm    \
          $(_SRC)\pcany.txt    \
          $(_SRC)\pccillin.htm \
          $(_SRC)\pccillin.txt \
          $(_SRC)\pciinfo.htm  \
          $(_SRC)\pciinfo.txt  \
          $(_SRC)\pcpnp.htm    \
          $(_SRC)\pcpnp.txt    \
          $(_SRC)\pelmouse.htm \
          $(_SRC)\pelmouse.txt \
          $(_SRC)\pfs.htm      \
          $(_SRC)\pfs.txt      \
          $(_SRC)\phnixad.htm  \
          $(_SRC)\phnixad.txt  \
          $(_SRC)\phpipe.htm   \
          $(_SRC)\phpipe.txt   \
          $(_SRC)\poolext.htm  \
          $(_SRC)\poolext.txt  \
          $(_SRC)\power.htm    \
          $(_SRC)\power.txt    \
          $(_SRC)\powpath.htm  \
          $(_SRC)\powpath.txt  \
          $(_SRC)\probepro.htm \
          $(_SRC)\probepro.txt \
          $(_SRC)\proccnt.htm  \
          $(_SRC)\proccnt.txt  \
          $(_SRC)\prolight.htm \
          $(_SRC)\prolight.txt \
          $(_SRC)\ps2cont.htm  \
          $(_SRC)\ps2cont.txt  \
          $(_SRC)\pstrip.htm   \
          $(_SRC)\pstrip.txt   \
          $(_SRC)\pumacsm.htm  \
          $(_SRC)\pumacsm.txt  \
          $(_SRC)\pwricon.htm  \
          $(_SRC)\pwricon.txt  \
          $(_SRC)\qic117.htm   \
          $(_SRC)\qic117.txt   \
          $(_SRC)\quick3.htm   \
          $(_SRC)\quick3.txt   \
          $(_SRC)\rcentrl.htm  \
          $(_SRC)\rcentrl.txt  \
          $(_SRC)\reachout.htm \
          $(_SRC)\reachout.txt \
          $(_SRC)\riptide.htm  \
          $(_SRC)\riptide.txt  \
          $(_SRC)\runonce.htm  \
          $(_SRC)\runonce.txt  \
          $(_SRC)\sbs45fxc.htm  \
          $(_SRC)\sbs45fxc.txt  \
          $(_SRC)\sbs50fxc.htm  \
          $(_SRC)\sbs50fxc.txt  \
          $(_SRC)\scandrv.htm  \
          $(_SRC)\scandrv.txt  \
          $(_SRC)\sdselect.htm  \
          $(_SRC)\sdselect.txt  \
          $(_SRC)\sharshtl.htm \
          $(_SRC)\sharshtl.txt \
          $(_SRC)\sigma.htm    \
          $(_SRC)\sigma.txt    \
          $(_SRC)\siig.htm     \
          $(_SRC)\siig.txt     \
          $(_SRC)\siigc.htm    \
          $(_SRC)\siigc.txt    \
          $(_SRC)\sisv.htm     \
          $(_SRC)\sisv.txt     \
          $(_SRC)\siwvid.htm   \
          $(_SRC)\siwvid.txt   \
          $(_SRC)\skusbkbf.htm \
          $(_SRC)\skusbkbf.txt \
          $(_SRC)\sms.htm      \
          $(_SRC)\sms.txt      \
          $(_SRC)\sna.htm      \
          $(_SRC)\sna.txt      \
          $(_SRC)\snidmi.htm   \
          $(_SRC)\snidmi.txt   \
          $(_SRC)\snidpms.htm  \
          $(_SRC)\snidpms.txt  \
          $(_SRC)\snipci.htm   \
          $(_SRC)\snipci.txt   \
          $(_SRC)\softoff.htm  \
          $(_SRC)\softoff.txt  \
          $(_SRC)\sonic.htm    \
          $(_SRC)\sonic.txt    \
          $(_SRC)\sonyjdu.htm  \
          $(_SRC)\sonyjdu.txt  \
          $(_SRC)\spxblock.htm \
          $(_SRC)\spxblock.txt \
          $(_SRC)\sql.htm      \
          $(_SRC)\sql.txt      \
          $(_SRC)\sscntrl.htm  \
          $(_SRC)\sscntrl.txt  \
          $(_SRC)\ssi365.htm   \
          $(_SRC)\ssi365.txt   \
          $(_SRC)\sspower.htm  \
          $(_SRC)\sspower.txt  \
          $(_SRC)\stb.htm      \
          $(_SRC)\stb.txt      \
          $(_SRC)\swoff.htm    \
          $(_SRC)\swoff.txt    \
          $(_SRC)\syshwcfg.htm \
          $(_SRC)\syshwcfg.txt \
          $(_SRC)\sysmgmt.htm  \
          $(_SRC)\sysmgmt.txt  \
          $(_SRC)\sysmon.htm   \
          $(_SRC)\sysmon.txt   \
          $(_SRC)\tcbenab.htm   \
          $(_SRC)\tcbenab.txt   \
          $(_SRC)\titsb.htm    \
          $(_SRC)\titsb.txt    \
          $(_SRC)\tivoli.htm   \
          $(_SRC)\tivoli.txt   \
          $(_SRC)\tmdigpro.htm \
          $(_SRC)\tmdigpro.txt \
          $(_SRC)\toptools.htm \
          $(_SRC)\toptools.txt \
          $(_SRC)\tosdvd.htm   \
          $(_SRC)\tosdvd.txt   \
          $(_SRC)\tpchrsrv.htm \
          $(_SRC)\tpchrsrv.txt \
          $(_SRC)\tpconfig.htm \
          $(_SRC)\tpconfig.txt \
          $(_SRC)\tpfuel.htm   \
          $(_SRC)\tpfuel.txt   \
          $(_SRC)\tppmport.htm \
          $(_SRC)\tppmport.txt \
          $(_SRC)\tridwnw.htm  \
          $(_SRC)\tridwnw.txt  \
          $(_SRC)\tsb24cdj.htm \
          $(_SRC)\tsb24cdj.txt \
          $(_SRC)\tsbams.htm   \
          $(_SRC)\tsbams.txt   \
          $(_SRC)\tsbapm.htm   \
          $(_SRC)\tsbapm.txt   \
          $(_SRC)\tsbapmdt.htm \
          $(_SRC)\tsbapmdt.txt \
          $(_SRC)\tsbasd.htm   \
          $(_SRC)\tsbasd.txt   \
          $(_SRC)\tsbhddpw.htm \
          $(_SRC)\tsbhddpw.txt \
          $(_SRC)\tsbmc.htm    \
          $(_SRC)\tsbmc.txt    \
          $(_SRC)\tsbselba.txt \
          $(_SRC)\tsbselba.htm \
          $(_SRC)\tsbspoff.htm \
          $(_SRC)\tsbspoff.txt \
          $(_SRC)\tsbds.txt   \
          $(_SRC)\tsbds.htm   \
          $(_SRC)\tsbvcap.htm  \
          $(_SRC)\tsbvcap.txt  \
          $(_SRC)\tscomp4.htm  \
          $(_SRC)\tscomp4.txt  \
          $(_SRC)\tscomp5.htm  \
          $(_SRC)\tscomp5.txt  \
          $(_SRC)\tsscidrv.htm \
          $(_SRC)\tsscidrv.txt \
          $(_SRC)\tt128.htm    \
          $(_SRC)\tt128.txt    \
          $(_SRC)\umax.htm     \
          $(_SRC)\umax.txt     \
          $(_SRC)\utupgr05.htm \
          $(_SRC)\utupgr05.txt \
          $(_SRC)\utupgr06.htm \
          $(_SRC)\utupgr06.txt \
          $(_SRC)\vidapplt.htm \
          $(_SRC)\vidapplt.txt \
          $(_SRC)\vgamode.htm  \
          $(_SRC)\vgamode.txt  \
          $(_SRC)\wacomdrv.htm \
          $(_SRC)\wacomdrv.txt \
          $(_SRC)\wce21.htm    \
          $(_SRC)\wce21.txt    \
          $(_SRC)\wcgodrv.htm  \
          $(_SRC)\wcgodrv.txt  \
          $(_SRC)\wcmigrat.htm \
          $(_SRC)\wcmigrat.txt \
          $(_SRC)\webscanx.htm \
          $(_SRC)\webscanx.txt \
          $(_SRC)\winachsf.txt \
          $(_SRC)\winsql.htm   \
          $(_SRC)\winsql.txt   \
          $(_SRC)\wtcls2k.htm  \
          $(_SRC)\wtcls2k.txt  \
          $(_SRC)\xlink.htm    \
          $(_SRC)\xlink.txt    \
          $(_SRC)\yacxg.htm    \
          $(_SRC)\yacxg.txt    \
          $(_SRC)\ymhsynth.htm \
          $(_SRC)\ymhsynth.txt \
          $(_SRC)\zipmagic.htm \
          $(_SRC)\zipmagic.txt \
          $(_SRC)\necdmi.htm \
          $(_SRC)\necdmi.txt \
          $(_SRC)\necldcm1.htm \
          $(_SRC)\necldcm1.txt \
          $(_SRC)\necldcm2.htm \
          $(_SRC)\necldcm2.txt \
          $(_SRC)\necupkit.htm \
          $(_SRC)\necupkit.txt \
          $(_SRC)\nxpad.htm \
          $(_SRC)\nxpad.txt \
          $(_SRC)\PCANY921.HTM \
          $(_SRC)\PCANY921.TXT \
          $(_SRC)\Pcanyex1.htm \
          $(_SRC)\Pcanyex1.txt \
          $(_SRC)\PCANYEX2.HTM \
          $(_SRC)\PCANYEX2.TXT

!endif

!IFDEF PERSONALFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\perinf\winnt32\compdata
!ENDIF

!IFDEF BLADEFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\blainf\winnt32\compdata
!ENDIF

!IFDEF SMALLBUSINESSSERVERFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\sbsinf\winnt32\compdata
!ENDIF

!IFDEF SERVERFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\srvinf\winnt32\compdata
!ENDIF

!IFDEF ENTERPRISEFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\entinf\winnt32\compdata
!ENDIF

!IFDEF DATACENTERFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\dtcinf\winnt32\compdata
!ENDIF

all:    \
!if "$(LANGUAGE)"=="usa" || "$(LANGUAGE)"=="USA"
    make_htms binplace_htms 
!else
    binplace_ntcompat 
!ENDIF

make_htms: $(PREPROCESSED_HTMS)

binplace_htms: $(BINPLACE_ONLY_FILES) $(PREPROCESSED_HTMS)
!ifndef NO_BINPLACE
    !binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) $**
!endif

binplace_ntcompat: $(O)\ntcompat.inf 
!ifndef NO_BINPLACE
    !binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) $**
!endif

{$(_SRC)}.htm{$(O)}.htm:
    prodfilt $< $@ +$(PRODSWITCH)

{$(_SRC)}.txt{$(O)}.txt:
    prodfilt $< $@ +$(PRODSWITCH)

$(O)\ntcompat.inf: $(_SRC)\ntcompat.inx $(_LNG)\ntcompat.txt
        $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
        copy /b $(_SRC)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
        prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
        prodfilt -s $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
        @del $(O)\$(@B).tmp1
        @del $(O)\$(@B).tmp2
        @del $(O)\$(@B).txt1

!else

make_htms:
!endif      # BUILD_SPECIFIC_INFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\sources.inc ===
TARGETNAME=htm
TARGETTYPE=NOTARGET
TARGETPATH=obj
SOURCES=
BINPLACE_PLACEFILE=..\..\placefil.txt
NTTARGETFILE0=make_htms
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\arainf\per\makefile.inc ===
PRODSWITCH=p
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\arainf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\brinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=BR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\brinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=BR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\brinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\brinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=BR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\brinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=BR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\brinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=BR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chsinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chsinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chsinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chsinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chsinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chsinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chtinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chtinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chtinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chtinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chtinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\csinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=CS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\csinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=CS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\chtinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\csinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=CS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\csinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\csinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=CS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\csinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=CS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\dainf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=DA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\dainf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=DA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\dainf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=DA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\dainf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\dainf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1 
LANGUAGE=DA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\dainf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=DA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\elinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=EL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\elinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=EL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\elinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=EL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\elinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\elinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=EL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\elinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=EL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\esinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=ES
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\esinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=ES
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\esinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=ES
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\esinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\esinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=ES
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\esinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=ES
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\fiinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=FI
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\fiinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=FI
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\fiinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\fiinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=FI
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\fiinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=FI
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\fiinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=FI
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\frinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\frinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1 
LANGUAGE=FR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\frinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=FR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\frinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=FR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\frinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=FR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\frinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=FR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\gerinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\gerinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\gerinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\gerinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\gerinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\hebinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\hebinf\per\makefile.inc ===
PRODSWITCH=p
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\gerinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\huinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=HU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\huinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=HU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\huinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=HU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\huinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=HU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\huinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\itinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=IT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\itinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=IT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\huinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=HU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\itinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=IT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\itinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\jpninf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\jpninf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\jpninf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\itinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=IT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\itinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=IT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\jpninf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\korinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\jpninf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\korinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\jpninf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\korinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\korinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\korinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\korinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\nlinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=NL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\nlinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=NL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\nlinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\nlinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=NL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\nlinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=NL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\nlinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=NL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\noinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1 
LANGUAGE=NO
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\noinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=NO
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\noinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\noinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=NO
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\plinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=PL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\noinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=NO
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\plinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=PL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\noinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=NO
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\plinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\plinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=PL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ptinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=PT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\plinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=PL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ptinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=PT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ptinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\plinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=PL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ptinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=PT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ptinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=PT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ruinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=RU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ptinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=PT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ruinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ruinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=RU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ruinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=RU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ruinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1 
LANGUAGE=RU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\ruinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=RU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\svinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=SV
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\svinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\svinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=SV
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\svinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=SV
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\svinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=SV
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\svinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=SV
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\trinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\trinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=TR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\trinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=TR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\trinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=TR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\trinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=TR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\trinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=TR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\usainf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\usainf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\usainf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\usainf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\usainf\sbs\makefile.inc ===
PRODSWITCH=l
SMALLBUSINESSSERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\usainf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\compdata\usainf\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\brinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=BR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\arainf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\arainf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\brinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\brinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\brinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\brinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chhinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chhinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\brinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chhinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chhinf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chsinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chsinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chhinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chsinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chsinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chhinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chsinf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chsinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chtinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chtinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chtinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chsinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chtinf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chtinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chtinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\chtinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\csinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=CS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\csinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\csinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\csinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\csinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\csinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\dainf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\dainf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\dainf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\dainf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\dainf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\elinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\elinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\elinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\elinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\elinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\esinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\esinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\esinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=ES
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\esinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\fiinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\fiinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\esinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\esinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\fiinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\fiinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\frinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=FR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\frinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\frinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\frinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\frinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\fiinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\gerinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\gerinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\frinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\gerinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\gerinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\gerinf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\gerinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\gerinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\hebinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\huinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\huinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\huinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\hebinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\huinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\huinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=HU
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\huinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\itinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\itinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\itinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=IT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\itinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\itinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\itinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\jpninf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\jpninf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\jpninf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\jpninf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\korinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\jpninf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\jpninf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\jpninf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\korinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\korinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\korinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\korinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\korinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\korinf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\necinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\necinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\nlinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\necinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\nlinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\nlinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\nlinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\nlinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=NL
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\nlinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\noinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\noinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\noinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\plinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=PL
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\plinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\noinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\plinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\noinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\plinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\plinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\plinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\psuinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\psuinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\psuinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\psuinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\psuinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ptinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=PT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ptinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ptinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ptinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ptinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ruinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=RU
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ruinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ptinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ruinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ruinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\svinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\svinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ruinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\ruinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\svinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\svinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=SV
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\svinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\svinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\trinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\trinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\trinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=TR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\trinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\trinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\trinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\tstinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\tstinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\tstinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\tstinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\usainf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\usainf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\tstinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\usainf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\usainf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\usainf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\usainf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\daytona\usainf\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\makefile.inc ===
#
#
# Description:
#
#   Builds WinPE infs
#
# Author:
#
#   Vijay Jayaseelan (vijayj@microsoft.com) 20 May 2001
#
# Revision:
#
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

#
# ANSI_CODEPAGE:  ANSI codepage for a given language.
#
# LCID:  Locale ID in hex.
#
# UNITEXT_OPT:  Unitext.exe command line options to specify the ANSI codepage
#   for a given language.  Used for Multibuyte -> Unicode conversion.
#

# Defaults
ANSI_CODEPAGE=1252
LCID=409

!if "$(LANGUAGE)"=="ARA" || "$(LANGUAGE)"=="ara"
# Arabic
ANSI_CODEPAGE=1256
LCID=401

!elseif "$(LANGUAGE)"=="BR" || "$(LANGUAGE)"=="br"
# Portuguese, Brazilian
ANSI_CODEPAGE=1252
LCID=416

!elseif "$(LANGUAGE)"=="CHH" || "$(LANGUAGE)"=="chh"
# Chinese, Traditional (Hong Kong)
ANSI_CODEPAGE=950
LCID=C04

!elseif "$(LANGUAGE)"=="CHS" || "$(LANGUAGE)"=="chs"
# Chinese, Simplified
ANSI_CODEPAGE=936
LCID=804

!elseif "$(LANGUAGE)"=="CHT" || "$(LANGUAGE)"=="cht"
# Chinese, Traditional (Taiwan)
ANSI_CODEPAGE=950
LCID=404

!elseif "$(LANGUAGE)"=="CS" || "$(LANGUAGE)"=="cs"
# Czech
ANSI_CODEPAGE=1250
LCID=405

!elseif "$(LANGUAGE)"=="DA" || "$(LANGUAGE)"=="da"
# Danish
ANSI_CODEPAGE=1252
LCID=406

!elseif "$(LANGUAGE)"=="EL" || "$(LANGUAGE)"=="el"
# Greek
ANSI_CODEPAGE=1253
LCID=408

!elseif "$(LANGUAGE)"=="ES" || "$(LANGUAGE)"=="es"
# Spanish
ANSI_CODEPAGE=1252
LCID=C0A

!elseif "$(LANGUAGE)"=="FI" || "$(LANGUAGE)"=="fi"
# Finish
ANSI_CODEPAGE=1252
LCID=40b

!elseif "$(LANGUAGE)"=="FR" || "$(LANGUAGE)"=="fr"
# French
ANSI_CODEPAGE=1252
LCID=40C

!elseif "$(LANGUAGE)"=="GER" || "$(LANGUAGE)"=="ger"
# German
ANSI_CODEPAGE=1252
LCID=407

!elseif "$(LANGUAGE)"=="HEB" || "$(LANGUAGE)"=="heb"
# Hebrew
ANSI_CODEPAGE=1255
LCID=40D

!elseif "$(LANGUAGE)"=="HU" || "$(LANGUAGE)"=="hu"
# Hungarian
ANSI_CODEPAGE=1250
LCID=40e

!elseif "$(LANGUAGE)"=="IT" || "$(LANGUAGE)"=="it"
# Italian
ANSI_CODEPAGE=1252
LCID=410

!elseif "$(LANGUAGE)"=="JPN" || "$(LANGUAGE)"=="jpn"
# Japanese
ANSI_CODEPAGE=932
LCID=411

!elseif "$(LANGUAGE)"=="KOR" || "$(LANGUAGE)"=="kor"
# Korean
ANSI_CODEPAGE=949
LCID=412

!elseif "$(LANGUAGE)"=="NL" || "$(LANGUAGE)"=="nl"
# Dutch
ANSI_CODEPAGE=1252
LCID=413

!elseif "$(LANGUAGE)"=="NO" || "$(LANGUAGE)"=="no"
# Norwegian
ANSI_CODEPAGE=1252
LCID=414

!elseif "$(LANGUAGE)"=="PL" || "$(LANGUAGE)"=="pl"
# Polish
ANSI_CODEPAGE=1250
LCID=415

!elseif "$(LANGUAGE)"=="PSU" || "$(LANGUAGE)"=="psu"
# Pseudo-loc
ANSI_CODEPAGE=1253
LCID=408

!elseif "$(LANGUAGE)"=="PT" || "$(LANGUAGE)"=="pt"
# Portuguese
ANSI_CODEPAGE=1252
LCID=816

!elseif "$(LANGUAGE)"=="RU" || "$(LANGUAGE)"=="ru"
# Russian
ANSI_CODEPAGE=1251
LCID=419

!elseif "$(LANGUAGE)"=="SV" || "$(LANGUAGE)"=="sv"
# Swedish
ANSI_CODEPAGE=1252
LCID=41D

!elseif "$(LANGUAGE)"=="TR" || "$(LANGUAGE)"=="tr"
# Turkish
ANSI_CODEPAGE=1254
LCID=41F

!endif


#
# unicode conversion options
#

UNITEXT_OPT=-m -$(ANSI_CODEPAGE)

#
# Precompile flags
#
PREFLAGS=/DLANGUAGE_ID=0x0$(LCID) -nologo /EP

!if $(PRERELEASE)
PREFLAGS=/DPRERELEASE $(PREFLAGS)
!endif

_SRC=..
_LNG=$(_SRC)\usa
_INF=$(O)

#
# targets to build
#
make_infs:  \
    $(O)\config.inf         \
    $(O)\extra.inf          \
    $(O)\winpesys.inf       \
    $(O)\winpesft.inf       \
    $(O)\winpedef.inf

  
#
# Can the below be optimized using rules ?
#

$(O)\config.inf: 
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt
    $(CC) $(PREFLAGS) $(_SRC)\$(@B).inx > $(O)\$(@B).inx
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp $(O)\$(@B).inf

$(O)\extra.inf: 
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt
    $(CC) $(PREFLAGS) $(_SRC)\$(@B).inx > $(O)\$(@B).inx
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp $(O)\$(@B).inf

$(O)\winpesys.inf: 
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt
    $(CC) $(PREFLAGS) $(_SRC)\$(@B).inx > $(O)\$(@B).inx
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp $(O)\$(@B).inf

$(O)\winpesft.inf: 
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt
    $(CC) $(PREFLAGS) $(_SRC)\$(@B).inx > $(O)\$(@B).inx
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp $(O)\$(@B).inf

$(O)\winpedef.inf: 
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt
    $(CC) $(PREFLAGS) $(_SRC)\$(@B).inx > $(O)\$(@B).inx
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp $(O)\$(@B).inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources

Abstract:

    Builds WinPE inf files

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)

!ENDIF

#
# include PRERELEASE define
#
!include ..\..\prerelease.inc

TARGETNAME=inf
TARGETTYPE=NOTARGET
TARGETPATH=obj

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=

BINPLACE_PLACEFILE=..\placefil.txt

#
# makefile.def will binplace any file listed in the MISCFILES macro.
#


#
# different files
#
MISCFILES = $(MISCFILES)    \
    $(O)\config.inf         \
    $(O)\extra.inf          \
    $(O)\winpesys.inf       \
    $(O)\winpesft.inf       \
    $(O)\winpedef.inf
    
#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
NTTARGETFILE0=make_infs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\arainf\makefile.inc ===
LANGUAGE=ARA
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\brinf\makefile.inc ===
LANGUAGE=BR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\chtinf\makefile.inc ===
LANGUAGE=CHT
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\chsinf\makefile.inc ===
LANGUAGE=CHS
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\chhinf\makefile.inc ===
LANGUAGE=CHH
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\csinf\makefile.inc ===
LANGUAGE=CS
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\dainf\makefile.inc ===
LANGUAGE=DA
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\elinf\makefile.inc ===
LANGUAGE=EL
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\fiinf\makefile.inc ===
LANGUAGE=FI
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\frinf\makefile.inc ===
LANGUAGE=FR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\gerinf\makefile.inc ===
LANGUAGE=GER
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\esinf\makefile.inc ===
LANGUAGE=ES
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\huinf\makefile.inc ===
LANGUAGE=HU
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\hebinf\makefile.inc ===
LANGUAGE=HEB
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\itinf\makefile.inc ===
LANGUAGE=IT
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\jpninf\makefile.inc ===
LANGUAGE=JPN
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\noinf\makefile.inc ===
LANGUAGE=NO
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\korinf\makefile.inc ===
LANGUAGE=KOR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\nlinf\makefile.inc ===
LANGUAGE=NL
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\plinf\makefile.inc ===
LANGUAGE=PL
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\ptinf\makefile.inc ===
LANGUAGE=PT
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\svinf\makefile.inc ===
LANGUAGE=SV
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\ruinf\makefile.inc ===
LANGUAGE=RU
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\trinf\makefile.inc ===
LANGUAGE=TR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\setupinfs\winpe\usainf\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\wlnotify\makefile.inc ===
!if exist($(TARGET_DIRECTORY).inc)
!include $(TARGET_DIRECTORY).inc
!endif

wlnotify.rc: notifyev.rc

notifyev.rc: notifyev.h msg00001.bin

notifyev.h msg00001.bin: notifyev.mc
    mc -v notifyev.mc -h . -r .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\wlnotify\wlnotify.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :
	
    wlnotify.h

Abstract:

    Shared wlnotify header.

Revision History:
--*/

#ifndef _WLNOTIFY_
#define _WLNOTIFY_

//
//	Resource string IDs
//
//
#define IDS_TSSESSION_STRING           2001
#define IDS_TSERRORDIALOG_STRING       2002
#define IDS_TSPTEMPLATE_FROM           2003
#define IDS_TSPTEMPLATE_FROM_IN        2004
#define IDS_TSPTEMPLATE_ON_FROM        2005
#define IDS_TSPTEMPLATE_ON_FROM_IN     2006
#define IDS_ON                         2007
#define IDS_DRIVE_INFO_TIP             2008

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\wlnotify\memory.cxx ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    memory.cxx

Abstract:

    Common memory utility routines.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/15/1999         Start.

--*/



#include <rpc.h>


//
// Externs
//

extern HANDLE ghNotifyHeap;



//
// Common allocator.
//

void * __cdecl
operator new(
    IN size_t size
    )
{
    return (HeapAlloc(ghNotifyHeap, 0, size));
}

void __cdecl
operator delete(
    IN void * lpvObj
    )
/*++

Notes:

    a. We depend on the fact that HeapFree() does the right
       thing when lpvObj is NULL.

--*/
{
    HeapFree(ghNotifyHeap, 0, lpvObj);
}



//
// Allocator for MIDL stubs
//

extern "C" void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    IN size_t len
    )
{
    return (new char[len]);
}

extern "C" void __RPC_API
MIDL_user_free(
    IN void __RPC_FAR * ptr
    )
{
    delete ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\wmistub\makefile.inc ===
PRIVLIB= $(TARGETPATH)\$(TARGET_DIRECTORY)\wmip.lib
$(TARGETPATH)\$(TARGET_DIRECTORY)\wmi.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\wmip.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\wmip.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\wmip.def: wmi.def
    $(C_PREPROCESSOR) $** -DPRIVATE= -DWMIDEF > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\common.inc ===
!ifndef ROOT
!error ROOT must be defined in makefile
!endif

# -------------------------------------------------------------
# MISC DEFAULTS
# -------------------------------------------------------------

#this enables build.exe to default BUILD_ALT_DIR
CHECKED_ALT_DIR=1

#TODO: examine define of USE_PRINT
C_DEFINES=$(C_DEFINES) /DNT_BUILD

# If we're building retail for NT, use MSVCRT runtime.  Else, use LIBCMT. Also, turn on
# incremental linking if we're not building for NT and in debug more, specify the
# debug CRT's.
!if ("$(BUILD_PRODUCT)" == "NT") && $(FREEBUILD)
USE_MSVCRT=1
!else
NO_NTDLL=1
USE_LIBCMT=1
!endif

!if !$(FREEBUILD)
DEBUG_CRTS=1
!if ("$(BUILD_PRODUCT)" != "NT")
USE_INCREMENTAL_LINKING=1
!endif
!endif

# this dissables optimization on Alpha
ALPHA_OPTIMIZATION=-Od

# due to dsound bug, only define on non NT5 (BUILD_PRODUCT==NT only set on nt5!)
!if "$(BUILD_PRODUCT)" == "NT"
DIRECTSOUND_VERSION=0x0700
!else
DIRECTSOUND_VERSION=0x0300
!endif

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
WIN32_IE_VERSION=0x0400
UMTYPE=windows
NOT_LEAN_AND_MEAN=1
SUBSYSTEM_VERSION=4.00
MSC_WARNING_LEVEL=/W3 /WX

# this will set up /Gr /Gx flag unless we've explicitly disabled it.
!if "$(DO_NOT_USE_EH)" != "1"
USE_NATIVE_EH=1
!endif

# MACHINE SPECIFIC MACROS

!if $(386)
_MACHINE=x86
EAT_ERRORS=2>nul:
EAT_OUTPUT=1>nul:
!elseif $(ALPHA)
_MACHINE=alpha
EAT_ERRORS=
EAT_OUTPUT=
!elseif $(AXP64)
_MACHINE=axp64
EAT_ERRORS=
EAT_OUTPUT=
!elseif $(IA64)
_MACHINE=ia64
EAT_ERRORS=
EAT_OUTPUT=
!endif

MKDIR = MKDIR $(EAT_ERRORS)

# -------------------------------------------------------------
# DIRECTORIES
# -------------------------------------------------------------

!if $(FREEBUILD)
_BLDROOT=$(ROOT)\build\ship
!else
_BLDROOT=$(ROOT)\build\debug
!endif

BLDROOT=$(_BLDROOT)
TOOLSROOT=$(ROOT)\tools
ELEVATEDIR=$(ROOT)\build\elevated
SRCROOT=$(ROOT)\src
TOOLSDIR=$(TOOLSROOT)\$(_MACHINE)
VCDIR=$(TOOLSDIR)\msvc50\vc
ATLDIR=$(SDK_INC_PATH)\atl21
AMOVIEDIR=$(SDK_PATH)\amovie\inc
ATLINCLUDE=$(ATLDIR)
SDKDIR=$(ROOT)\lib\$(O)
SDKDIR_DEST=$(ROOT)\lib\$(_OBJ_DIR)
#QUARTZDIR=$(TOOLSDIR)\quartz
SWEEPERDIR=$(VCDIR)
TOOLSLIBMSVC=$(VCDIR)\lib
TOOLSLIBWIN32=$(TOOLSLIBMSVC)
#TOOLSLIBQUARTZ=$(QUARTZDIR)\lib
TOOLSLIBSWEEPER=$(SWEEPERDIR)\lib
!if $(FREEBUILD)
TOOLSLIBQV=$(TOOLSDIR)\QVLib\lib\WinRel
!else
TOOLSLIBQV=$(TOOLSDIR)\QVLib\lib\WinDebug
!endif
TOOLSLIBMISC=$(TOOLSDIR)\misc\lib
TOOLSLIBTRIDENT=$(TOOLSDIR)\trident\lib

PARSER=$(ROOT)\src\prims\parse.pl
CPRIMS=$(SDKDIR)\cprims.h

# -------------------------------------------------------------
# INCLUDE PATH
# -------------------------------------------------------------

TOOLSUTILS=$(TOOLSDIR)\utils
TOOLSINCLUDE=

#    $(TOOLSDIR)\directx\inc;\
#    $(VCDIR)\include;\
#    $(TOOLSDIR)\aactive\inc;\
#    $(TOOLSDIR)\masm\include;\
#    $(TOOLSDIR)\qvlib\include;\
#    $(TOOLSDIR)\RL\inc;\
#    $(TOOLSDIR)\misc\include;\
#    $(TOOLSDIR)\quartz\include;\
#    $(TOOLSDIR)\trident\include

# -------------------------------------------------------------
# TOOL
# -------------------------------------------------------------
SED = sed
PERL= perl

# -------------------------------------------------------------
# GLOBAL INCLUDES
# -------------------------------------------------------------

APPEL_INC_DIRS= \
    $(ROOT)\extinc; \
    $(SRCROOT)\appel\include; \
    $(ATLINCLUDE); \
    $(SRCROOT)\appel; \
    $(SRCROOT)\include; \
    $(SDKDIR); \
    $(SRCROOT)\apeldbg; \
    $(AMOVIEDIR)

LM_INC_DIRS= \
    $(SRCROOT)\lm\include; \
    $(ATLINCLUDE); \
    $(SRCROOT)\lm; \
    $(SRCROOT)\include; \
    $(SRCROOT)\filters\lmrtrend; \
    $(SDKDIR); \
    $(AMOVIEDIR)

FILTER_INC_DIRS= \
    $(ATLINCLUDE); \
    $(SRCROOT)\include; \
    $(SRCROOT)\apeldbg; \
    $(SDKDIR); \

DALITE_INC_DIRS= \
    $(SRCROOT); \
    $(SRCROOT)\dalite\include; \
    $(ATLINCLUDE); \
    $(SRCROOT)\dalite; \
    $(SRCROOT)\include; \
    $(SDKDIR); \

DATIME_INC_DIRS= \
    $(SRCROOT); \
    $(SRCROOT)\time\include; \
    $(ATLINCLUDE); \
    $(SRCROOT)\time; \
    $(SRCROOT)\include; \
    $(SRCROOT)\time\idl\obj$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY); \
    $(SDKDIR); \

!ifdef PROJNAME
PROJROOT=$(SRCROOT)\$(PROJNAME)
INCLUDES= \
    $(SRCROOT); \
    $(PROJROOT)\include; \
    $(ATLINCLUDE); \
    $(PROJROOT); \
    $(SRCROOT)\include; \
    $(SDKDIR); \
!endif

# -------------------------------------------------------------
# MACHINE SPECIFIC
# -------------------------------------------------------------

386_STDCALL=0   #default to cdecl calling convention

# -------------------------------------------------------------
# COMPILER FLAGS
# -------------------------------------------------------------

# This turns on ieee compatible floating point for Alpha only
!if "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
USER_C_FLAGS=$(USER_C_FLAGS) /QAieee1
!endif

# for cod files....

!if "$(COD)" == "1"
USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Fa$(O)\$(@B).cod
!endif

# -------------------------------------------------------------
# DEFINES
# -------------------------------------------------------------

C_DEFINES = $(C_DEFINES) /DDA_MAJOR_VERSION=1 /DDA_MINOR_VERSION=0
C_DEFINES = $(C_DEFINES) /DDIRECTSOUND_VERSION=$(DIRECTSOUND_VERSION)

!if !$(FREEBUILD)
C_DEFINES= /D_DEBUG /DDEBUG /D_DEBUGMEM=1 /D_USE_PRINT=1 $(C_DEFINES)
DEVELOPER_BUILD=1
!else
C_DEFINES = $(C_DEFINES) /D_NO_CRT=1
!endif

!if "$(DEVELOPER_BUILD)" == "1"
C_DEFINES = $(C_DEFINES) /D_MEMORY_TRACKING=1 /DDEVELOPER_DEBUG=1
PERF_BUILD=1
# Turn on RTTI (/GR)  for everything but retail builds
USE_RTTI=1
!endif

!if "$(PERF_BUILD)" == "1"
C_DEFINES = $(C_DEFINES) /DPERFORMANCE_REPORTING
!endif

C_DEFINES=$(C_DEFINES) /DNOMINMAX /DSTRICT /DDIRECTDRAW_VERSION=0x0300

!if "$(_PROFILE)" == "1"
C_DEFINES=$(C_DEFINES) /DPRODUCT_PROF
ICECAPLIB=$(TOOLSLIBICAP)\icap.lib
!endif

!if "$(_TIMING)" == "1"
C_DEFINES =$(C_DEFINES) /DTIMING
!endif

C_DEFINES =$(C_DEFINES) /D_ATL_STATIC_REGISTRY

# -------------------------------------------------------------
# OTHER
# -------------------------------------------------------------

CONDITIONAL_INCLUDES= \
    algorithm \
        deque \
        functional \
        iterator \
        list \
        map \
        numeric \
        queue \
        set \
        stack \
        utility \
        vector \
        winwlm.h \
        macwin32.h \
        macocidl.h \
        subwtype.h \
        d3dvec.inl \
        d3dcom.h \
        strings.h \
        iostream \
        libc.h \
        rpcerr.h \
        rpcmac.h \
        macname1.h \
        macpube.h \
        macapi.h \
        macname2.h \
        streams.h \
        xstddef \
        string \
        stdafx.h \
        stdole32.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\wlnotify\schedlog.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       schedlog.c
//
//  Contents:   Task Scheduler StartShell notification
//
//  Classes:    None.
//
//  Functions:
//  			SchedStartShell - queue the work to the WinLogon thread pool.
//  			DoSchedStartShell - notify Sched service that a user logged on.
//
//  History:    07-Mar-01  JBenton   Created
//
//-----------------------------------------------------------------------------
//
//  Note: We don't build/publish a lib here as suggested in wlnotify.cxx.
//  Rather we include the source file here because there is only a single
//  simple function.
//
//  Note: We are using the StartShell event because the Scheduler service
//  expects the user's explorer session to be running.
//

#include <windows.h>
#include <winwlx.h>

#define SCHED_SERVICE_NAME          TEXT("Schedule")

//
// The following LOGON and LOGOFF defines must be kept in sync with
// the definition in %sdxroot%\admin\services\sched\inc\common.hxx
// 
#define SERVICE_CONTROL_USER_LOGON              128
#define SERVICE_CONTROL_USER_LOGOFF             133

DWORD WINAPI SchedStartShell(LPVOID lpvParam);
DWORD WINAPI DoSchedStartShell(LPVOID lpvParam);

DWORD WINAPI
SchedEventLogOff(LPVOID lpvParam)
//
//
// Routine Description:
//
//     Send a logoff notification to the Task Scheduler service
//     via a user defined Service Control.
//
//     Arguments:
//
//        lpvParam - Winlogon notification info (unused as of yet)
//
//     Return Value:
//
//        Extended error status from Service control functions.
//
{
   DWORD                  status     = ERROR_SUCCESS;
   SC_HANDLE              hSC        = NULL;
   SC_HANDLE              hSvc       = NULL;
   BOOL                   bSucceeded = FALSE;
   SERVICE_STATUS         ServiceStatus;

   hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
   if (hSC == NULL)
   {
       return GetLastError();
   }

   hSvc = OpenService(hSC, SCHED_SERVICE_NAME,
                                SERVICE_USER_DEFINED_CONTROL);
   if (hSvc == NULL)
   {
       CloseServiceHandle(hSC);
       return GetLastError();
   }

   bSucceeded = ControlService(hSvc,
                             SERVICE_CONTROL_USER_LOGOFF,
                             &ServiceStatus);
   if( !bSucceeded )
   {
      status = GetLastError();
   }

   CloseServiceHandle(hSvc);
   CloseServiceHandle(hSC);

   return status;
}

DWORD WINAPI
SchedStartShell(LPVOID lpvParam)

{
	DWORD dwSessionId = 0;

	//
	// Don't send logon notification to Terminal Server sessions.
	//
	if (ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId) &&
					(dwSessionId == 0))
	{
	    // 
    	// Queue the work to the thread pool since we may
    	// be looping on the notification.
    	// 
        QueueUserWorkItem(DoSchedStartShell, lpvParam, WT_EXECUTELONGFUNCTION);
	}

	return GetLastError();
}

DWORD WINAPI
DoSchedStartShell(LPVOID lpvParam)
//
//
// Routine Description:
//
//     Send a logon notification to the Task Scheduler service
//     via a user defined Service Control.
//
//     Arguments:
//
//        lpvParam - Winlogon notification info (unused as of yet)
//
//     Return Value:
//
//        Extended error status from Service control functions.
//
{
    DWORD status = ERROR_SUCCESS;
    PWLX_NOTIFICATION_INFO pTempInfo = (PWLX_NOTIFICATION_INFO) lpvParam;

    SC_HANDLE hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC == NULL)
    {
        return GetLastError();
    }

    SC_HANDLE hSvc = OpenService(hSC, SCHED_SERVICE_NAME,
                                 SERVICE_USER_DEFINED_CONTROL);
    if (hSvc == NULL)
    {
        CloseServiceHandle(hSC);
        return GetLastError();
    }

    BOOL fSucceeded;
    const int NOTIFY_RETRIES = 20;
    const DWORD NOTIFY_SLEEP = 4000;

    //
    // Use a retry loop to notify the service. This is done
    // because, if the user logs in quickly, the service may not
    // be started when the shell runs this instance.
    //
    for (int i = 1; ; i++)
    {
        SERVICE_STATUS Status;
        fSucceeded = ControlService(hSvc,
                                    SERVICE_CONTROL_USER_LOGON,
                                    &Status);
        if (fSucceeded)
        {
            break;
        }

        if (i >= NOTIFY_RETRIES)
        {
		    status = GetLastError();
            break;
        }

        Sleep(NOTIFY_SLEEP);
    }

    CloseServiceHandle(hSvc);
    CloseServiceHandle(hSC);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\wlnotify\wlnotify.cxx ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    wlnotify.cxx

Abstract:

    Main source file for the common DLL that receives Winlogon
    notifications.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    A. BACKGROUND:

    In Windows 2000, Winlogon allows components to hook into various events
    like Logon, Logoff, Lock, Unlock etc via the new Winlogon notifications.
    Components are required to write a DLL with exports (that process these
    notifications) and add them to the registry under HKLM\Software\Microsoft
    \Windows NT\CurrentVersion\Winlogon\Notify Key.



    B. PERFORMANCE ISSUE:

    As more and more components started hooking into these notifications, the
    number of DLLs that were being loaded increased. These notification DLLs
    also brought in other DLLs that they were implicitly linked to them and
    that were not related to processing of these notifications. This common
    DLL is a way to cut down on the number of DLLs that are loaded into the
    Winlogon process.



    C. HOW TO MERGE YOUR DLL INTO THIS DLL:

    In order to merge your DLL into this common notifcation DLL, you need to
    take the following steps:

        1. Compile and link your notification processing code into a library
           that is propagated to $(BASEDIR)\public\sdk\lib directory. Please
           ensure that there is no excess baggage in this library.

        2. Enlist in \nt\private\dllmerge\wlnotify directory.

        3. Modify the sources file to link your library into the DLL.

        4. Add your exports to the .def file for this common DLL. Please
           ensure that the names of exports reflect the component that is
           processing the notification.

        5. Add your exports to the Winlogon notification registry key, if
           you haven't done so already. Modify the DLL name in this registry
           key to point to the common DLL.

        6. Remove your standalone notification DLL from the system.

        7. Make sure you boot test your changes before checking them in.



Revision History:

    GopalP          1/15/1999         Start.

--*/


//
// Includes
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


//
// Globals
//
HANDLE      ghNotifyHeap;

#ifdef __cplusplus
extern "C" {
#endif
BOOL TSDLLInit(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);
#ifdef __cplusplus
}
#endif
#define IsTerminalServer() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))


//
// Functions
//


extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpvReserved
    )
/*++

Routine Description:

    This routine will get called either when a process attaches to this dll
    or when a process detaches from this dll.

Arguments:

    Standard DllMain signature.

Return Value:

    TRUE - Initialization successfully occurred.

    FALSE - Insufficient memory is available for the process to attach to
        this dll.

--*/
{
    BOOL bSuccess;

    switch (dwReason)
        {
        case DLL_PROCESS_ATTACH:
            //
            // Disable Thread attach/detach calls
            //
            bSuccess = DisableThreadLibraryCalls(hInstance);
            ASSERT(bSuccess == TRUE);

            // Use Default Process heap
            ghNotifyHeap = GetProcessHeap();
            ASSERT(ghNotifyHeap != NULL);
            break;

        case DLL_PROCESS_DETACH:
            break;

        }

    if (IsTerminalServer()) {
        TSDLLInit(hInstance, dwReason, lpvReserved);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\extinc\dxtguid.c ===
//
//  This .CPP file should be included once in your project.  It defines all GUIDs
//  used by DXTransforms as well as the Pixel formats for DX Surfaces
//

#define DX_DECLARE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
//
//  Pixel format definitions
//
// {e436eb78-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F3-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB2, 
0xbbf7d3f3, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb79-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {e436eb7a-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F6-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB332, 
0xbbf7d3f6, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D3F7-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB4444, 
0xbbf7d3f7, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7b-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F9-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR565, 
0xbbf7d3f9, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7c-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FB-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB1555, 
0xbbf7d3fb, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7d-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FD-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR24, 
0xbbf7d3fd, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7e-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FF-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR32, 
0xbbf7d3ff, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D401-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ABGR32, 
0xbbf7d401, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// Note: this GUID is used/shared in uuids.h's MEDIASUBTYPE_ARGB32
// {773c9ac0-3274-11d0-B724-00aa006c1A01}
DX_DECLARE_GUID(DDPF_ARGB32, 
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 );
// {BBF7D403-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_PMARGB32, 
0xbbf7d403, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94E-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A1, 
0x7846f94e, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94F-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A2, 
0x7846f94f, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F950-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A4, 
0x7846f950, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F951-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A8, 
0x7846f951, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F952-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z8, 
0x7846f952, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F953-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z16, 
0x7846f953, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F954-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z24, 
0x7846f954, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F955-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z32, 
0x7846f955, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
//
//  Component categories
//
// {C501EDBE-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXImageTransform, 
0xc501edbe, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {C501EDBF-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DX3DTransform, 
0xc501edbf, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {ACAC94FC-E5CF-11d1-9066-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXAuthoringTransform,
0xacac94fc, 0xe5cf, 0x11d1, 0x90, 0x66, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {52BA7097-B52C-11d1-81CB-0000F87557DB}
DX_DECLARE_GUID(CATID_DXSurface, 
0x52ba7097, 0xb52c, 0x11d1, 0x81, 0xcb, 0x0, 0x0, 0xf8, 0x75, 0x57, 0xdb);

//
//  Service IDs.  
//
//  NOTE:  The service ID for direct draw is == IID_IDirectDraw3 for compatibility
//         with trident service ID's.  This should be the service ID for DirectDraw
//         no matter what version.
//
//  BUGBUG -- Should we use this service provider ID for direct draw?
//
DX_DECLARE_GUID(SID_SDirectDraw,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
//
//  The service ID for Direct 3D Retain Mode is the same as IID_IDirect3DRM
//  
DX_DECLARE_GUID(SID_SDirect3DRM,
0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

//
//  The service ID for DirectDraw3 is the same as IID_IDirectDraw3
//  
DX_DECLARE_GUID(SID_SDirectDraw3,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\extinc\dxtdbg.h ===
/*******************************************************************************
* DXTDbg.h *
*----------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTDbg_h
#define DXTDbg_h

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

#define DXTDBG_FUNC_TRACE   1
#define DXTDBG_INFO         2

class CDXTDbgFlags
{
  public:
    DWORD m_F;
    CDXTDbgFlags()
    {
        m_F = 0;
        HKEY hkResult;
        DWORD dwDisposition;
        if( RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("DXTDbgFlags"), 0, NULL, 0,
                            KEY_ALL_ACCESS, NULL, &hkResult, &dwDisposition )
                            == ERROR_SUCCESS )
        {
            if( dwDisposition == REG_CREATED_NEW_KEY )
            {
                RegSetValueEx( hkResult, _T("Flags"), NULL, REG_DWORD, (PBYTE)&m_F, sizeof( m_F ) );
            }
            else
            {
                DWORD BuffSize = sizeof( m_F );
                RegQueryValueEx( hkResult, _T("Flags"), NULL, NULL, (PBYTE)&m_F, &BuffSize );
            }
            RegCloseKey( hkResult );
        }
    }
};

class CDXTDbgScope
{
  public:
    static CDXTDbgFlags m_DebugFlags; 
    PCHAR  m_pFuncName;
    CDXTDbgScope( PCHAR pFuncName )
    {
        m_pFuncName = pFuncName;
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "\nEntering Function: %s\n", m_pFuncName );
        }
    }
    ~CDXTDbgScope()
    {
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "Leaving Function: %s\n", m_pFuncName );
        }
    }
};

//=== User macros ==============================================================
#ifdef _DEBUG
#define DXTDBG_FUNC( name ) CDXTDbgScope DXTDbgScope( name ); 
#define DXTDBG_MSG0( reportType, format ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF0( reportType, format );
#define DXTDBG_MSG1( reportType, format, arg1 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF4( reportType, format, arg1, arg2, arg3, arg4 )
#else
#define DXTDBG_FUNC( name )
#define DXTDBG_MSG0( reportType, format )
#define DXTDBG_MSG1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 )
#endif

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\extinc\dxterror.h ===
/*******************************************************************************
* DXTError.h *
*------------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTError_h
#define DXTError_h

#ifndef _WINERROR_
#include <winerror.h>
#endif

//=== New codes ===============================================================
#define FACILITY_DXTRANS    0x87A

/*** DXTERR_UNINITIALIZED
*   The object (transform, surface, etc.) has not been properly initialized
*/
#define DXTERR_UNINITIALIZED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 1)

/*** DXTERR_ALREADY_INITIALIZED
*   The object (surface) has already been properly initialized
*/
#define DXTERR_ALREADY_INITIALIZED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 2)

/*** DXTERR_UNSUPPORTED_FORMAT
*   The caller has specified an unsupported format
*/
#define DXTERR_UNSUPPORTED_FORMAT   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 3)

/*** DXTERR_COPYRIGHT_IS_INVALID
*   The caller has specified an unsupported format
*/
#define DXTERR_COPYRIGHT_IS_INVALID   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 4)

/*** DXTERR_INVALID_BOUNDS
*   The caller has specified invalid bounds for this operation
*/
#define DXTERR_INVALID_BOUNDS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 5)

/*** DXTERR_INVALID_FLAGS
*   The caller has specified invalid flags for this operation
*/
#define DXTERR_INVALID_FLAGS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 6)

/*** DXTERR_OUTOFSTACK
*   There was not enough available stack space to complete the operation 
*/
#define DXTERR_OUTOFSTACK   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 7)

/*** DXTERR_REQ_IE_DLLNOTFOUND
*   Unable to load a required Internet Explorer DLL  
*/
#define DXTERR_REQ_IE_DLLNOTFOUND   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 8)

/*** DXT_S_HITOUTPUT
*   The specified point intersects the generated output
*/
#define DXT_S_HITOUTPUT   MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_DXTRANS, 1)

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\extinc\dxtmpl.h ===
/*****************************************************************************
* DXTmpl.h *
*-----------*
*       This is the header file contains the DX collection class templates. It
*   has been derived from the MFC collection templates for compatibility.
*-----------------------------------------------------------------------------
*   Created by: Ed Connell                     Date: 05/17/95
*
*****************************************************************************/
#ifndef DXTmpl_h
#define DXTmpl_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_STRING
#include <string.h>
#endif

#ifndef _INC_STDLIB
#include <stdlib.h>
#endif

#ifndef _INC_SEARCH
#include <search.h>
#endif

#define DXASSERT_VALID( pObj )

/////////////////////////////////////////////////////////////////////////////
typedef void* DXLISTPOS;
typedef DWORD DXLISTHANDLE;

#define DX_BEFORE_START_POSITION ((void*)-1L)

inline BOOL DXIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)
template<class TYPE>
inline void DXConstructElements(TYPE* pElements, int nCount)
{
    _ASSERT( nCount == 0 ||
             DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE ) );

    // default is bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));
}

template<class TYPE>
inline void DXDestructElements(TYPE* pElements, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE  ) ) );
    pElements;  // not used
    nCount; // not used

    // default does nothing
}

template<class TYPE>
inline void DXCopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pDest, nCount * sizeof(TYPE), TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pSrc, nCount * sizeof(TYPE), FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof(TYPE));
}

template<class TYPE, class ARG_TYPE>
BOOL DXCompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    _ASSERT( DXIsValidAddress( pElement1, sizeof(TYPE), FALSE ) );
    _ASSERT( DXIsValidAddress( pElement2, sizeof(ARG_TYPE), FALSE ) );
    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT DXHashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(void*)(DWORD)key) >> 4;
}

/////////////////////////////////////////////////////////////////////////////
// CDXPlex

struct CDXPlex    // warning variable length structure
{
    CDXPlex* pNext;
    UINT nMax;
    UINT nCur;
    /* BYTE data[maxNum*elementSize]; */
    void* data() { return this+1; }

    static CDXPlex* PASCAL Create( CDXPlex*& pHead, UINT nMax, UINT cbElement )
    {
        CDXPlex* p = (CDXPlex*) new BYTE[sizeof(CDXPlex) + nMax * cbElement];
        p->nMax = nMax;
        p->nCur = 0;
        p->pNext = pHead;
        pHead = p;  // change head (adds in reverse order for simplicity)
        return p;
    }

    void FreeDataChain()
    {
        CDXPlex* p = this;
        while (p != NULL)
        {
            BYTE* bytes = (BYTE*) p;
            CDXPlex* pNext = p->pNext;
            delete bytes;
            p = pNext;
        }
    }
};


/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXArray
{
public:
// Construction
    CDXArray();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    void SetAtGrow(int nIndex, ARG_TYPE newElement);
    int Add(ARG_TYPE newElement);
    int Append(const CDXArray& src);
    void Copy(const CDXArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
    void RemoveAt(int nIndex, int nCount = 1);
    void InsertAt(int nStartIndex, CDXArray* pNewArray);
    void Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ));

// Implementation
protected:
    TYPE* m_pData;   // the actual array of data
    int m_nSize;     // # of elements (upperBound - 1)
    int m_nMaxSize;  // max allocated
    int m_nGrowBy;   // grow amount

public:
    ~CDXArray();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetSize() const
    { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetUpperBound() const
    { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::RemoveAll()
    { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CDXArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CDXArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::CDXArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::~CDXArray()
{
    DXASSERT_VALID( this );

    if (m_pData != NULL)
    {
        DXDestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
    DXASSERT_VALID( this );
    _ASSERT( nNewSize >= 0 );

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            DXDestructElements(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        _ASSERT( nNewSize <= SIZE_T_MAX/sizeof(TYPE) );    // no overflow
#endif
        m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
        DXConstructElements(m_pData, nNewSize);
        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            DXConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            DXDestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
        }
        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determe growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        _ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        _ASSERT( nNewMax <= SIZE_T_MAX/sizeof(TYPE) ); // no overflow
#endif
        TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

        // construct remaining elements
        _ASSERT( nNewSize > m_nSize );
        DXConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

template<class TYPE, class ARG_TYPE>
int CDXArray<TYPE, ARG_TYPE>::Append(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);
    DXCopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
    return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Copy(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot copy to itself

    SetSize(src.m_nSize);
    DXCopyElements(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::FreeExtra()
{
    DXASSERT_VALID( this );

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        _ASSERT( m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nSize)
        SetSize(nIndex+1, -1);
    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );    // will expand to meet need
    _ASSERT( nCount > 0 );     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount, -1);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(TYPE));

        // re-init slots we copied from
        DXConstructElements(&m_pData[nIndex], nCount);
    }

    // insert new value in the gap
    _ASSERT( nIndex + nCount <= m_nSize );
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    _ASSERT( nCount >= 0 );
    _ASSERT( nIndex + nCount <= m_nSize );

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    DXDestructElements(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CDXArray* pNewArray)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewArray );
    _ASSERT( nStartIndex >= 0 );

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ))
{
    DXASSERT_VALID( this );
    _ASSERT( m_pData != NULL );

    qsort( m_pData, m_nSize, sizeof(TYPE), compare );
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_pData == NULL)
    {
        _ASSERT( m_nSize == 0 );
        _ASSERT( m_nMaxSize == 0 );
    }
    else
    {
        _ASSERT( m_nSize >= 0 );
        _ASSERT( m_nMaxSize >= 0 );
        _ASSERT( m_nSize <= m_nMaxSize );
        _ASSERT( DXIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE), TRUE ) );
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:

// Construction
    CDXList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    DXLISTPOS AddHead(ARG_TYPE newElement);
    DXLISTPOS AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CDXList* pNewList);
    void AddTail(CDXList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    DXLISTPOS GetHeadPosition() const;
    DXLISTPOS GetTailPosition() const;
    TYPE& GetNext(DXLISTPOS& rPosition); // return *Position++
    TYPE GetNext(DXLISTPOS& rPosition) const; // return *Position++
    TYPE& GetPrev(DXLISTPOS& rPosition); // return *Position--
    TYPE GetPrev(DXLISTPOS& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(DXLISTPOS position);
    TYPE GetAt(DXLISTPOS position) const;
    void SetAt(DXLISTPOS pos, ARG_TYPE newElement);
    void RemoveAt(DXLISTPOS position);

    // inserting before or after a given position
    DXLISTPOS InsertBefore(DXLISTPOS position, ARG_TYPE newElement);
    DXLISTPOS InsertAfter(DXLISTPOS position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    DXLISTPOS Find(ARG_TYPE searchValue, DXLISTPOS startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    DXLISTPOS FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CDXList();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CDXList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetHead()
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetHead() const
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetTail()
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetTail() const
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (DXLISTPOS) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (DXLISTPOS) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) const // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) const // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position)
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position) const
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CDXList<TYPE, ARG_TYPE>::SetAt(DXLISTPOS pos, ARG_TYPE newElement)
    {   CNode* pNode = (CNode*) pos;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::CDXList( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAll()
{
    DXASSERT_VALID( this );

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        DXDestructElements(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::~CDXList()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CDXPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CDXPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CDXPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::CNode*
CDXList<TYPE, ARG_TYPE>::NewNode(CDXList::CNode* pPrev, CDXList::CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CDXPlex* pNewBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    _ASSERT( m_pNodeFree != NULL );  // we must have something

    CDXList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow

    DXConstructElements(&pNode->data, 1);
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::FreeNode(CDXList::CNode* pNode)
{
    DXDestructElements(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddHead(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements to head (maintain order)
    DXLISTPOS pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddTail(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements
    DXLISTPOS pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveHead()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeHead != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveTail()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeTail != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertBefore(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeHead );
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertAfter(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ));
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeTail );
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAt(DXLISTPOS position)
{
    DXASSERT_VALID( this );

    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ) );

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ) );
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ));
        pNode = pNode->pNext;
    }
    return (DXLISTPOS) pNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, DXLISTPOS startAfter) const
{
    DXASSERT_VALID( this );

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (DXCompareElements(&pNode->data, &searchValue))
            return (DXLISTPOS)pNode;
    return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_nCount == 0)
    {
        // empty list
        _ASSERT( m_pNodeHead == NULL );
        _ASSERT( m_pNodeTail == NULL );
    }
    else
    {
        // non-empty list
        _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ));
        _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ));
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CDXMap
{
protected:
    // Association
    struct CAssoc
    {
        CAssoc* pNext;
        UINT nHashValue;  // needed for efficient iteration
        KEY key;
        VALUE value;
    };
public:
// Construction
    CDXMap( int nBlockSize = 10 );

// Attributes
    // number of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // Lookup
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
    // Lookup and add if not there
    VALUE& operator[](ARG_KEY key);

    // add a new (key, value) pair
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    // removing existing (key, ?) pair
    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    // iterating all (key, value) pairs
    DXLISTPOS GetStartPosition() const;
    void GetNextAssoc(DXLISTPOS& rNextPosition, KEY& rKey, VALUE& rValue) const;

    // advanced features for derived classes
    UINT GetHashTableSize() const;
    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
    ~CDXMap();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
    { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
    { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
    { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline DXLISTPOS CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
    { return (m_nCount == 0) ? NULL : DX_BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
    { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CDXMap( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
    DXASSERT_VALID( this );
    _ASSERT( m_nCount == 0 );
    _ASSERT( nHashSize > 0 );

    if (m_pHashTable != NULL)
    {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow)
    {
        m_pHashTable = new CAssoc* [nHashSize];
        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }
    m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
    DXASSERT_VALID( this );

    if (m_pHashTable != NULL)
    {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
              pAssoc = pAssoc->pNext)
            {
                DXDestructElements(&pAssoc->value, 1);
                DXDestructElements(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CDXMap()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
    if (m_pFreeList == NULL)
    {
        // add another block
        CDXPlex* newBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CDXMap::CAssoc));
        // chain them into free list
        CDXMap::CAssoc* pAssoc = (CDXMap::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
        {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    _ASSERT( m_pFreeList != NULL );  // we must have something

    CDXMap::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow
    DXConstructElements(&pAssoc->key, 1);
    DXConstructElements(&pAssoc->value, 1);   // special construct values
    return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CDXMap::CAssoc* pAssoc)
{
    DXDestructElements(&pAssoc->value, 1);
    DXDestructElements(&pAssoc->key, 1);
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
    nHash = DXHashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
            return pAssoc;
    }
    return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;  // not in map

    rValue = pAssoc->value;
    return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
    DXASSERT_VALID( this );

    if (m_pHashTable == NULL)
        return FALSE;  // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[DXHashKey(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
        {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }
    return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(DXLISTPOS& rNextPosition,
    KEY& rKey, VALUE& rValue) const
{
    DXASSERT_VALID( this );
    _ASSERT( m_pHashTable != NULL );  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    _ASSERT( pAssocRet != NULL );

    if (pAssocRet == (CAssoc*) DX_BEFORE_START_POSITION)
    {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        _ASSERT( pAssocRet != NULL );  // must find something
    }

    // find next association
    _ASSERT( DXIsValidAddress(pAssocRet, sizeof(CAssoc), TRUE ));
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL)
    {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (DXLISTPOS) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
    _ASSERT( m_nHashTableSize > 0 );
    _ASSERT( (m_nCount == 0 || m_pHashTable != NULL) );
        // non-empty map should have hash table
}
#endif //_DEBUG

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\extinc\dxtmsft.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtmsft_h__
#define __dxtmsft_h__

/* Forward Declarations */ 

#ifndef __IDXLUTBuilder_FWD_DEFINED__
#define __IDXLUTBuilder_FWD_DEFINED__
typedef interface IDXLUTBuilder IDXLUTBuilder;
#endif 	/* __IDXLUTBuilder_FWD_DEFINED__ */


#ifndef __IDXDLUTBuilder_FWD_DEFINED__
#define __IDXDLUTBuilder_FWD_DEFINED__
typedef interface IDXDLUTBuilder IDXDLUTBuilder;
#endif 	/* __IDXDLUTBuilder_FWD_DEFINED__ */


#ifndef __IDXTGradientD_FWD_DEFINED__
#define __IDXTGradientD_FWD_DEFINED__
typedef interface IDXTGradientD IDXTGradientD;
#endif 	/* __IDXTGradientD_FWD_DEFINED__ */


#ifndef __IDXTConvolution_FWD_DEFINED__
#define __IDXTConvolution_FWD_DEFINED__
typedef interface IDXTConvolution IDXTConvolution;
#endif 	/* __IDXTConvolution_FWD_DEFINED__ */


#ifndef __IDXMapper_FWD_DEFINED__
#define __IDXMapper_FWD_DEFINED__
typedef interface IDXMapper IDXMapper;
#endif 	/* __IDXMapper_FWD_DEFINED__ */


#ifndef __IDXDMapper_FWD_DEFINED__
#define __IDXDMapper_FWD_DEFINED__
typedef interface IDXDMapper IDXDMapper;
#endif 	/* __IDXDMapper_FWD_DEFINED__ */


#ifndef __IDXTComposite_FWD_DEFINED__
#define __IDXTComposite_FWD_DEFINED__
typedef interface IDXTComposite IDXTComposite;
#endif 	/* __IDXTComposite_FWD_DEFINED__ */


#ifndef __IDXTWipe_FWD_DEFINED__
#define __IDXTWipe_FWD_DEFINED__
typedef interface IDXTWipe IDXTWipe;
#endif 	/* __IDXTWipe_FWD_DEFINED__ */


#ifndef __ICrBlur_FWD_DEFINED__
#define __ICrBlur_FWD_DEFINED__
typedef interface ICrBlur ICrBlur;
#endif 	/* __ICrBlur_FWD_DEFINED__ */


#ifndef __ICrEngrave_FWD_DEFINED__
#define __ICrEngrave_FWD_DEFINED__
typedef interface ICrEngrave ICrEngrave;
#endif 	/* __ICrEngrave_FWD_DEFINED__ */


#ifndef __ICrEmboss_FWD_DEFINED__
#define __ICrEmboss_FWD_DEFINED__
typedef interface ICrEmboss ICrEmboss;
#endif 	/* __ICrEmboss_FWD_DEFINED__ */


#ifndef __IDXTFade_FWD_DEFINED__
#define __IDXTFade_FWD_DEFINED__
typedef interface IDXTFade IDXTFade;
#endif 	/* __IDXTFade_FWD_DEFINED__ */


#ifndef __IDXBasicImage_FWD_DEFINED__
#define __IDXBasicImage_FWD_DEFINED__
typedef interface IDXBasicImage IDXBasicImage;
#endif 	/* __IDXBasicImage_FWD_DEFINED__ */


#ifndef __IDXPixelate_FWD_DEFINED__
#define __IDXPixelate_FWD_DEFINED__
typedef interface IDXPixelate IDXPixelate;
#endif 	/* __IDXPixelate_FWD_DEFINED__ */


#ifndef __ICrIris_FWD_DEFINED__
#define __ICrIris_FWD_DEFINED__
typedef interface ICrIris ICrIris;
#endif 	/* __ICrIris_FWD_DEFINED__ */


#ifndef __ICrSlide_FWD_DEFINED__
#define __ICrSlide_FWD_DEFINED__
typedef interface ICrSlide ICrSlide;
#endif 	/* __ICrSlide_FWD_DEFINED__ */


#ifndef __ICrRadialWipe_FWD_DEFINED__
#define __ICrRadialWipe_FWD_DEFINED__
typedef interface ICrRadialWipe ICrRadialWipe;
#endif 	/* __ICrRadialWipe_FWD_DEFINED__ */


#ifndef __ICrBarn_FWD_DEFINED__
#define __ICrBarn_FWD_DEFINED__
typedef interface ICrBarn ICrBarn;
#endif 	/* __ICrBarn_FWD_DEFINED__ */


#ifndef __ICrBlinds_FWD_DEFINED__
#define __ICrBlinds_FWD_DEFINED__
typedef interface ICrBlinds ICrBlinds;
#endif 	/* __ICrBlinds_FWD_DEFINED__ */


#ifndef __ICrInset_FWD_DEFINED__
#define __ICrInset_FWD_DEFINED__
typedef interface ICrInset ICrInset;
#endif 	/* __ICrInset_FWD_DEFINED__ */


#ifndef __ICrStretch_FWD_DEFINED__
#define __ICrStretch_FWD_DEFINED__
typedef interface ICrStretch ICrStretch;
#endif 	/* __ICrStretch_FWD_DEFINED__ */


#ifndef __ICrSpiral_FWD_DEFINED__
#define __ICrSpiral_FWD_DEFINED__
typedef interface ICrSpiral ICrSpiral;
#endif 	/* __ICrSpiral_FWD_DEFINED__ */


#ifndef __ICrZigzag_FWD_DEFINED__
#define __ICrZigzag_FWD_DEFINED__
typedef interface ICrZigzag ICrZigzag;
#endif 	/* __ICrZigzag_FWD_DEFINED__ */


#ifndef __ICrWheel_FWD_DEFINED__
#define __ICrWheel_FWD_DEFINED__
typedef interface ICrWheel ICrWheel;
#endif 	/* __ICrWheel_FWD_DEFINED__ */


#ifndef __IDXTChroma_FWD_DEFINED__
#define __IDXTChroma_FWD_DEFINED__
typedef interface IDXTChroma IDXTChroma;
#endif 	/* __IDXTChroma_FWD_DEFINED__ */


#ifndef __IDXTDropShadow_FWD_DEFINED__
#define __IDXTDropShadow_FWD_DEFINED__
typedef interface IDXTDropShadow IDXTDropShadow;
#endif 	/* __IDXTDropShadow_FWD_DEFINED__ */


#ifndef __IDXTMetaRoll_FWD_DEFINED__
#define __IDXTMetaRoll_FWD_DEFINED__
typedef interface IDXTMetaRoll IDXTMetaRoll;
#endif 	/* __IDXTMetaRoll_FWD_DEFINED__ */


#ifndef __IDXTMetaRipple_FWD_DEFINED__
#define __IDXTMetaRipple_FWD_DEFINED__
typedef interface IDXTMetaRipple IDXTMetaRipple;
#endif 	/* __IDXTMetaRipple_FWD_DEFINED__ */


#ifndef __IDXTMetaPageTurn_FWD_DEFINED__
#define __IDXTMetaPageTurn_FWD_DEFINED__
typedef interface IDXTMetaPageTurn IDXTMetaPageTurn;
#endif 	/* __IDXTMetaPageTurn_FWD_DEFINED__ */


#ifndef __IDXTMetaLiquid_FWD_DEFINED__
#define __IDXTMetaLiquid_FWD_DEFINED__
typedef interface IDXTMetaLiquid IDXTMetaLiquid;
#endif 	/* __IDXTMetaLiquid_FWD_DEFINED__ */


#ifndef __IDXTMetaCenterPeel_FWD_DEFINED__
#define __IDXTMetaCenterPeel_FWD_DEFINED__
typedef interface IDXTMetaCenterPeel IDXTMetaCenterPeel;
#endif 	/* __IDXTMetaCenterPeel_FWD_DEFINED__ */


#ifndef __IDXTMetaPeelSmall_FWD_DEFINED__
#define __IDXTMetaPeelSmall_FWD_DEFINED__
typedef interface IDXTMetaPeelSmall IDXTMetaPeelSmall;
#endif 	/* __IDXTMetaPeelSmall_FWD_DEFINED__ */


#ifndef __IDXTMetaPeelPiece_FWD_DEFINED__
#define __IDXTMetaPeelPiece_FWD_DEFINED__
typedef interface IDXTMetaPeelPiece IDXTMetaPeelPiece;
#endif 	/* __IDXTMetaPeelPiece_FWD_DEFINED__ */


#ifndef __IDXTMetaPeelSplit_FWD_DEFINED__
#define __IDXTMetaPeelSplit_FWD_DEFINED__
typedef interface IDXTMetaPeelSplit IDXTMetaPeelSplit;
#endif 	/* __IDXTMetaPeelSplit_FWD_DEFINED__ */


#ifndef __IDXTMetaWater_FWD_DEFINED__
#define __IDXTMetaWater_FWD_DEFINED__
typedef interface IDXTMetaWater IDXTMetaWater;
#endif 	/* __IDXTMetaWater_FWD_DEFINED__ */


#ifndef __IDXTMetaLightWipe_FWD_DEFINED__
#define __IDXTMetaLightWipe_FWD_DEFINED__
typedef interface IDXTMetaLightWipe IDXTMetaLightWipe;
#endif 	/* __IDXTMetaLightWipe_FWD_DEFINED__ */


#ifndef __IDXTMetaRadialScaleWipe_FWD_DEFINED__
#define __IDXTMetaRadialScaleWipe_FWD_DEFINED__
typedef interface IDXTMetaRadialScaleWipe IDXTMetaRadialScaleWipe;
#endif 	/* __IDXTMetaRadialScaleWipe_FWD_DEFINED__ */


#ifndef __IDXTMetaWhiteOut_FWD_DEFINED__
#define __IDXTMetaWhiteOut_FWD_DEFINED__
typedef interface IDXTMetaWhiteOut IDXTMetaWhiteOut;
#endif 	/* __IDXTMetaWhiteOut_FWD_DEFINED__ */


#ifndef __IDXTMetaTwister_FWD_DEFINED__
#define __IDXTMetaTwister_FWD_DEFINED__
typedef interface IDXTMetaTwister IDXTMetaTwister;
#endif 	/* __IDXTMetaTwister_FWD_DEFINED__ */


#ifndef __IDXTMetaBurnFilm_FWD_DEFINED__
#define __IDXTMetaBurnFilm_FWD_DEFINED__
typedef interface IDXTMetaBurnFilm IDXTMetaBurnFilm;
#endif 	/* __IDXTMetaBurnFilm_FWD_DEFINED__ */


#ifndef __IDXTMetaJaws_FWD_DEFINED__
#define __IDXTMetaJaws_FWD_DEFINED__
typedef interface IDXTMetaJaws IDXTMetaJaws;
#endif 	/* __IDXTMetaJaws_FWD_DEFINED__ */


#ifndef __IDXTMetaColorFade_FWD_DEFINED__
#define __IDXTMetaColorFade_FWD_DEFINED__
typedef interface IDXTMetaColorFade IDXTMetaColorFade;
#endif 	/* __IDXTMetaColorFade_FWD_DEFINED__ */


#ifndef __IDXTMetaFlowMotion_FWD_DEFINED__
#define __IDXTMetaFlowMotion_FWD_DEFINED__
typedef interface IDXTMetaFlowMotion IDXTMetaFlowMotion;
#endif 	/* __IDXTMetaFlowMotion_FWD_DEFINED__ */


#ifndef __IDXTMetaVacuum_FWD_DEFINED__
#define __IDXTMetaVacuum_FWD_DEFINED__
typedef interface IDXTMetaVacuum IDXTMetaVacuum;
#endif 	/* __IDXTMetaVacuum_FWD_DEFINED__ */


#ifndef __IDXTMetaGriddler_FWD_DEFINED__
#define __IDXTMetaGriddler_FWD_DEFINED__
typedef interface IDXTMetaGriddler IDXTMetaGriddler;
#endif 	/* __IDXTMetaGriddler_FWD_DEFINED__ */


#ifndef __IDXTMetaGriddler2_FWD_DEFINED__
#define __IDXTMetaGriddler2_FWD_DEFINED__
typedef interface IDXTMetaGriddler2 IDXTMetaGriddler2;
#endif 	/* __IDXTMetaGriddler2_FWD_DEFINED__ */


#ifndef __IDXTMetaThreshold_FWD_DEFINED__
#define __IDXTMetaThreshold_FWD_DEFINED__
typedef interface IDXTMetaThreshold IDXTMetaThreshold;
#endif 	/* __IDXTMetaThreshold_FWD_DEFINED__ */


#ifndef __IDXTMetaWormHole_FWD_DEFINED__
#define __IDXTMetaWormHole_FWD_DEFINED__
typedef interface IDXTMetaWormHole IDXTMetaWormHole;
#endif 	/* __IDXTMetaWormHole_FWD_DEFINED__ */


#ifndef __DXTComposite_FWD_DEFINED__
#define __DXTComposite_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTComposite DXTComposite;
#else
typedef struct DXTComposite DXTComposite;
#endif /* __cplusplus */

#endif 	/* __DXTComposite_FWD_DEFINED__ */


#ifndef __DXLUTBuilder_FWD_DEFINED__
#define __DXLUTBuilder_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXLUTBuilder DXLUTBuilder;
#else
typedef struct DXLUTBuilder DXLUTBuilder;
#endif /* __cplusplus */

#endif 	/* __DXLUTBuilder_FWD_DEFINED__ */


#ifndef __DXTGradientD_FWD_DEFINED__
#define __DXTGradientD_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTGradientD DXTGradientD;
#else
typedef struct DXTGradientD DXTGradientD;
#endif /* __cplusplus */

#endif 	/* __DXTGradientD_FWD_DEFINED__ */


#ifndef __DXTWipe_FWD_DEFINED__
#define __DXTWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTWipe DXTWipe;
#else
typedef struct DXTWipe DXTWipe;
#endif /* __cplusplus */

#endif 	/* __DXTWipe_FWD_DEFINED__ */


#ifndef __DXTConvolution_FWD_DEFINED__
#define __DXTConvolution_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTConvolution DXTConvolution;
#else
typedef struct DXTConvolution DXTConvolution;
#endif /* __cplusplus */

#endif 	/* __DXTConvolution_FWD_DEFINED__ */


#ifndef __CrBlur_FWD_DEFINED__
#define __CrBlur_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlur CrBlur;
#else
typedef struct CrBlur CrBlur;
#endif /* __cplusplus */

#endif 	/* __CrBlur_FWD_DEFINED__ */


#ifndef __CrEmboss_FWD_DEFINED__
#define __CrEmboss_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrEmboss CrEmboss;
#else
typedef struct CrEmboss CrEmboss;
#endif /* __cplusplus */

#endif 	/* __CrEmboss_FWD_DEFINED__ */


#ifndef __CrEngrave_FWD_DEFINED__
#define __CrEngrave_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrEngrave CrEngrave;
#else
typedef struct CrEngrave CrEngrave;
#endif /* __cplusplus */

#endif 	/* __CrEngrave_FWD_DEFINED__ */


#ifndef __DXFade_FWD_DEFINED__
#define __DXFade_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXFade DXFade;
#else
typedef struct DXFade DXFade;
#endif /* __cplusplus */

#endif 	/* __DXFade_FWD_DEFINED__ */


#ifndef __FadePP_FWD_DEFINED__
#define __FadePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class FadePP FadePP;
#else
typedef struct FadePP FadePP;
#endif /* __cplusplus */

#endif 	/* __FadePP_FWD_DEFINED__ */


#ifndef __BasicImageEffects_FWD_DEFINED__
#define __BasicImageEffects_FWD_DEFINED__

#ifdef __cplusplus
typedef class BasicImageEffects BasicImageEffects;
#else
typedef struct BasicImageEffects BasicImageEffects;
#endif /* __cplusplus */

#endif 	/* __BasicImageEffects_FWD_DEFINED__ */


#ifndef __BasicImageEffectsPP_FWD_DEFINED__
#define __BasicImageEffectsPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class BasicImageEffectsPP BasicImageEffectsPP;
#else
typedef struct BasicImageEffectsPP BasicImageEffectsPP;
#endif /* __cplusplus */

#endif 	/* __BasicImageEffectsPP_FWD_DEFINED__ */


#ifndef __Pixelate_FWD_DEFINED__
#define __Pixelate_FWD_DEFINED__

#ifdef __cplusplus
typedef class Pixelate Pixelate;
#else
typedef struct Pixelate Pixelate;
#endif /* __cplusplus */

#endif 	/* __Pixelate_FWD_DEFINED__ */


#ifndef __PixelatePP_FWD_DEFINED__
#define __PixelatePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class PixelatePP PixelatePP;
#else
typedef struct PixelatePP PixelatePP;
#endif /* __cplusplus */

#endif 	/* __PixelatePP_FWD_DEFINED__ */


#ifndef __DXTWipePP_FWD_DEFINED__
#define __DXTWipePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTWipePP DXTWipePP;
#else
typedef struct DXTWipePP DXTWipePP;
#endif /* __cplusplus */

#endif 	/* __DXTWipePP_FWD_DEFINED__ */


#ifndef __CrBlurPP_FWD_DEFINED__
#define __CrBlurPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlurPP CrBlurPP;
#else
typedef struct CrBlurPP CrBlurPP;
#endif /* __cplusplus */

#endif 	/* __CrBlurPP_FWD_DEFINED__ */


#ifndef __GradientPP_FWD_DEFINED__
#define __GradientPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class GradientPP GradientPP;
#else
typedef struct GradientPP GradientPP;
#endif /* __cplusplus */

#endif 	/* __GradientPP_FWD_DEFINED__ */


#ifndef __CompositePP_FWD_DEFINED__
#define __CompositePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CompositePP CompositePP;
#else
typedef struct CompositePP CompositePP;
#endif /* __cplusplus */

#endif 	/* __CompositePP_FWD_DEFINED__ */


#ifndef __ConvolvePP_FWD_DEFINED__
#define __ConvolvePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class ConvolvePP ConvolvePP;
#else
typedef struct ConvolvePP ConvolvePP;
#endif /* __cplusplus */

#endif 	/* __ConvolvePP_FWD_DEFINED__ */


#ifndef __LUTBuilderPP_FWD_DEFINED__
#define __LUTBuilderPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class LUTBuilderPP LUTBuilderPP;
#else
typedef struct LUTBuilderPP LUTBuilderPP;
#endif /* __cplusplus */

#endif 	/* __LUTBuilderPP_FWD_DEFINED__ */


#ifndef __CrIris_FWD_DEFINED__
#define __CrIris_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrIris CrIris;
#else
typedef struct CrIris CrIris;
#endif /* __cplusplus */

#endif 	/* __CrIris_FWD_DEFINED__ */


#ifndef __CrIrisPP_FWD_DEFINED__
#define __CrIrisPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrIrisPP CrIrisPP;
#else
typedef struct CrIrisPP CrIrisPP;
#endif /* __cplusplus */

#endif 	/* __CrIrisPP_FWD_DEFINED__ */


#ifndef __CrSlide_FWD_DEFINED__
#define __CrSlide_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSlide CrSlide;
#else
typedef struct CrSlide CrSlide;
#endif /* __cplusplus */

#endif 	/* __CrSlide_FWD_DEFINED__ */


#ifndef __CrSlidePP_FWD_DEFINED__
#define __CrSlidePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSlidePP CrSlidePP;
#else
typedef struct CrSlidePP CrSlidePP;
#endif /* __cplusplus */

#endif 	/* __CrSlidePP_FWD_DEFINED__ */


#ifndef __CrRadialWipe_FWD_DEFINED__
#define __CrRadialWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrRadialWipe CrRadialWipe;
#else
typedef struct CrRadialWipe CrRadialWipe;
#endif /* __cplusplus */

#endif 	/* __CrRadialWipe_FWD_DEFINED__ */


#ifndef __CrRadialWipePP_FWD_DEFINED__
#define __CrRadialWipePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrRadialWipePP CrRadialWipePP;
#else
typedef struct CrRadialWipePP CrRadialWipePP;
#endif /* __cplusplus */

#endif 	/* __CrRadialWipePP_FWD_DEFINED__ */


#ifndef __CrBarn_FWD_DEFINED__
#define __CrBarn_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBarn CrBarn;
#else
typedef struct CrBarn CrBarn;
#endif /* __cplusplus */

#endif 	/* __CrBarn_FWD_DEFINED__ */


#ifndef __CrBlinds_FWD_DEFINED__
#define __CrBlinds_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlinds CrBlinds;
#else
typedef struct CrBlinds CrBlinds;
#endif /* __cplusplus */

#endif 	/* __CrBlinds_FWD_DEFINED__ */


#ifndef __CrBlindPP_FWD_DEFINED__
#define __CrBlindPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlindPP CrBlindPP;
#else
typedef struct CrBlindPP CrBlindPP;
#endif /* __cplusplus */

#endif 	/* __CrBlindPP_FWD_DEFINED__ */


#ifndef __CrStretch_FWD_DEFINED__
#define __CrStretch_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrStretch CrStretch;
#else
typedef struct CrStretch CrStretch;
#endif /* __cplusplus */

#endif 	/* __CrStretch_FWD_DEFINED__ */


#ifndef __CrStretchPP_FWD_DEFINED__
#define __CrStretchPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrStretchPP CrStretchPP;
#else
typedef struct CrStretchPP CrStretchPP;
#endif /* __cplusplus */

#endif 	/* __CrStretchPP_FWD_DEFINED__ */


#ifndef __CrInset_FWD_DEFINED__
#define __CrInset_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrInset CrInset;
#else
typedef struct CrInset CrInset;
#endif /* __cplusplus */

#endif 	/* __CrInset_FWD_DEFINED__ */


#ifndef __CrSpiral_FWD_DEFINED__
#define __CrSpiral_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSpiral CrSpiral;
#else
typedef struct CrSpiral CrSpiral;
#endif /* __cplusplus */

#endif 	/* __CrSpiral_FWD_DEFINED__ */


#ifndef __CrSpiralPP_FWD_DEFINED__
#define __CrSpiralPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSpiralPP CrSpiralPP;
#else
typedef struct CrSpiralPP CrSpiralPP;
#endif /* __cplusplus */

#endif 	/* __CrSpiralPP_FWD_DEFINED__ */


#ifndef __CrZigzag_FWD_DEFINED__
#define __CrZigzag_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrZigzag CrZigzag;
#else
typedef struct CrZigzag CrZigzag;
#endif /* __cplusplus */

#endif 	/* __CrZigzag_FWD_DEFINED__ */


#ifndef __CrZigzagPP_FWD_DEFINED__
#define __CrZigzagPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrZigzagPP CrZigzagPP;
#else
typedef struct CrZigzagPP CrZigzagPP;
#endif /* __cplusplus */

#endif 	/* __CrZigzagPP_FWD_DEFINED__ */


#ifndef __CrWheel_FWD_DEFINED__
#define __CrWheel_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrWheel CrWheel;
#else
typedef struct CrWheel CrWheel;
#endif /* __cplusplus */

#endif 	/* __CrWheel_FWD_DEFINED__ */


#ifndef __CrWheelPP_FWD_DEFINED__
#define __CrWheelPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrWheelPP CrWheelPP;
#else
typedef struct CrWheelPP CrWheelPP;
#endif /* __cplusplus */

#endif 	/* __CrWheelPP_FWD_DEFINED__ */


#ifndef __DXTChroma_FWD_DEFINED__
#define __DXTChroma_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTChroma DXTChroma;
#else
typedef struct DXTChroma DXTChroma;
#endif /* __cplusplus */

#endif 	/* __DXTChroma_FWD_DEFINED__ */


#ifndef __DXTChromaPP_FWD_DEFINED__
#define __DXTChromaPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTChromaPP DXTChromaPP;
#else
typedef struct DXTChromaPP DXTChromaPP;
#endif /* __cplusplus */

#endif 	/* __DXTChromaPP_FWD_DEFINED__ */


#ifndef __DXTDropShadow_FWD_DEFINED__
#define __DXTDropShadow_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTDropShadow DXTDropShadow;
#else
typedef struct DXTDropShadow DXTDropShadow;
#endif /* __cplusplus */

#endif 	/* __DXTDropShadow_FWD_DEFINED__ */


#ifndef __DXTDropShadowPP_FWD_DEFINED__
#define __DXTDropShadowPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTDropShadowPP DXTDropShadowPP;
#else
typedef struct DXTDropShadowPP DXTDropShadowPP;
#endif /* __cplusplus */

#endif 	/* __DXTDropShadowPP_FWD_DEFINED__ */


#ifndef __DXTMetaRoll_FWD_DEFINED__
#define __DXTMetaRoll_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaRoll DXTMetaRoll;
#else
typedef struct DXTMetaRoll DXTMetaRoll;
#endif /* __cplusplus */

#endif 	/* __DXTMetaRoll_FWD_DEFINED__ */


#ifndef __DXTMetaRipple_FWD_DEFINED__
#define __DXTMetaRipple_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaRipple DXTMetaRipple;
#else
typedef struct DXTMetaRipple DXTMetaRipple;
#endif /* __cplusplus */

#endif 	/* __DXTMetaRipple_FWD_DEFINED__ */


#ifndef __DXTMetaPageTurn_FWD_DEFINED__
#define __DXTMetaPageTurn_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPageTurn DXTMetaPageTurn;
#else
typedef struct DXTMetaPageTurn DXTMetaPageTurn;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPageTurn_FWD_DEFINED__ */


#ifndef __DXTMetaLiquid_FWD_DEFINED__
#define __DXTMetaLiquid_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaLiquid DXTMetaLiquid;
#else
typedef struct DXTMetaLiquid DXTMetaLiquid;
#endif /* __cplusplus */

#endif 	/* __DXTMetaLiquid_FWD_DEFINED__ */


#ifndef __DXTMetaCenterPeel_FWD_DEFINED__
#define __DXTMetaCenterPeel_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaCenterPeel DXTMetaCenterPeel;
#else
typedef struct DXTMetaCenterPeel DXTMetaCenterPeel;
#endif /* __cplusplus */

#endif 	/* __DXTMetaCenterPeel_FWD_DEFINED__ */


#ifndef __DXTMetaPeelSmall_FWD_DEFINED__
#define __DXTMetaPeelSmall_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPeelSmall DXTMetaPeelSmall;
#else
typedef struct DXTMetaPeelSmall DXTMetaPeelSmall;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPeelSmall_FWD_DEFINED__ */


#ifndef __DXTMetaPeelPiece_FWD_DEFINED__
#define __DXTMetaPeelPiece_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPeelPiece DXTMetaPeelPiece;
#else
typedef struct DXTMetaPeelPiece DXTMetaPeelPiece;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPeelPiece_FWD_DEFINED__ */


#ifndef __DXTMetaPeelSplit_FWD_DEFINED__
#define __DXTMetaPeelSplit_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPeelSplit DXTMetaPeelSplit;
#else
typedef struct DXTMetaPeelSplit DXTMetaPeelSplit;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPeelSplit_FWD_DEFINED__ */


#ifndef __DXTMetaWater_FWD_DEFINED__
#define __DXTMetaWater_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaWater DXTMetaWater;
#else
typedef struct DXTMetaWater DXTMetaWater;
#endif /* __cplusplus */

#endif 	/* __DXTMetaWater_FWD_DEFINED__ */


#ifndef __DXTMetaLightWipe_FWD_DEFINED__
#define __DXTMetaLightWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaLightWipe DXTMetaLightWipe;
#else
typedef struct DXTMetaLightWipe DXTMetaLightWipe;
#endif /* __cplusplus */

#endif 	/* __DXTMetaLightWipe_FWD_DEFINED__ */


#ifndef __DXTMetaRadialScaleWipe_FWD_DEFINED__
#define __DXTMetaRadialScaleWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaRadialScaleWipe DXTMetaRadialScaleWipe;
#else
typedef struct DXTMetaRadialScaleWipe DXTMetaRadialScaleWipe;
#endif /* __cplusplus */

#endif 	/* __DXTMetaRadialScaleWipe_FWD_DEFINED__ */


#ifndef __DXTMetaWhiteOut_FWD_DEFINED__
#define __DXTMetaWhiteOut_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaWhiteOut DXTMetaWhiteOut;
#else
typedef struct DXTMetaWhiteOut DXTMetaWhiteOut;
#endif /* __cplusplus */

#endif 	/* __DXTMetaWhiteOut_FWD_DEFINED__ */


#ifndef __DXTMetaTwister_FWD_DEFINED__
#define __DXTMetaTwister_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaTwister DXTMetaTwister;
#else
typedef struct DXTMetaTwister DXTMetaTwister;
#endif /* __cplusplus */

#endif 	/* __DXTMetaTwister_FWD_DEFINED__ */


#ifndef __DXTMetaBurnFilm_FWD_DEFINED__
#define __DXTMetaBurnFilm_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaBurnFilm DXTMetaBurnFilm;
#else
typedef struct DXTMetaBurnFilm DXTMetaBurnFilm;
#endif /* __cplusplus */

#endif 	/* __DXTMetaBurnFilm_FWD_DEFINED__ */


#ifndef __DXTMetaJaws_FWD_DEFINED__
#define __DXTMetaJaws_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaJaws DXTMetaJaws;
#else
typedef struct DXTMetaJaws DXTMetaJaws;
#endif /* __cplusplus */

#endif 	/* __DXTMetaJaws_FWD_DEFINED__ */


#ifndef __DXTMetaColorFade_FWD_DEFINED__
#define __DXTMetaColorFade_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaColorFade DXTMetaColorFade;
#else
typedef struct DXTMetaColorFade DXTMetaColorFade;
#endif /* __cplusplus */

#endif 	/* __DXTMetaColorFade_FWD_DEFINED__ */


#ifndef __DXTMetaFlowMotion_FWD_DEFINED__
#define __DXTMetaFlowMotion_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaFlowMotion DXTMetaFlowMotion;
#else
typedef struct DXTMetaFlowMotion DXTMetaFlowMotion;
#endif /* __cplusplus */

#endif 	/* __DXTMetaFlowMotion_FWD_DEFINED__ */


#ifndef __DXTMetaVacuum_FWD_DEFINED__
#define __DXTMetaVacuum_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaVacuum DXTMetaVacuum;
#else
typedef struct DXTMetaVacuum DXTMetaVacuum;
#endif /* __cplusplus */

#endif 	/* __DXTMetaVacuum_FWD_DEFINED__ */


#ifndef __DXTMetaGriddler_FWD_DEFINED__
#define __DXTMetaGriddler_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaGriddler DXTMetaGriddler;
#else
typedef struct DXTMetaGriddler DXTMetaGriddler;
#endif /* __cplusplus */

#endif 	/* __DXTMetaGriddler_FWD_DEFINED__ */


#ifndef __DXTMetaGriddler2_FWD_DEFINED__
#define __DXTMetaGriddler2_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaGriddler2 DXTMetaGriddler2;
#else
typedef struct DXTMetaGriddler2 DXTMetaGriddler2;
#endif /* __cplusplus */

#endif 	/* __DXTMetaGriddler2_FWD_DEFINED__ */


#ifndef __DXTMetaThreshold_FWD_DEFINED__
#define __DXTMetaThreshold_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaThreshold DXTMetaThreshold;
#else
typedef struct DXTMetaThreshold DXTMetaThreshold;
#endif /* __cplusplus */

#endif 	/* __DXTMetaThreshold_FWD_DEFINED__ */


#ifndef __DXTMetaWormHole_FWD_DEFINED__
#define __DXTMetaWormHole_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaWormHole DXTMetaWormHole;
#else
typedef struct DXTMetaWormHole DXTMetaWormHole;
#endif /* __cplusplus */

#endif 	/* __DXTMetaWormHole_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxtmsft_0000 */
/* [local] */ 

#include <dxtmsft3.h>






typedef 
enum OPIDDXLUTBUILDER
    {	OPID_DXLUTBUILDER_Gamma	= 0,
	OPID_DXLUTBUILDER_Opacity	= OPID_DXLUTBUILDER_Gamma + 1,
	OPID_DXLUTBUILDER_Brightness	= OPID_DXLUTBUILDER_Opacity + 1,
	OPID_DXLUTBUILDER_Contrast	= OPID_DXLUTBUILDER_Brightness + 1,
	OPID_DXLUTBUILDER_ColorBalance	= OPID_DXLUTBUILDER_Contrast + 1,
	OPID_DXLUTBUILDER_Posterize	= OPID_DXLUTBUILDER_ColorBalance + 1,
	OPID_DXLUTBUILDER_Invert	= OPID_DXLUTBUILDER_Posterize + 1,
	OPID_DXLUTBUILDER_Threshold	= OPID_DXLUTBUILDER_Invert + 1,
	OPID_DXLUTBUILDER_NUM_OPS	= OPID_DXLUTBUILDER_Threshold + 1
    }	OPIDDXLUTBUILDER;

typedef 
enum DXLUTCOLOR
    {	DXLUTCOLOR_RED	= 0,
	DXLUTCOLOR_GREEN	= DXLUTCOLOR_RED + 1,
	DXLUTCOLOR_BLUE	= DXLUTCOLOR_GREEN + 1
    }	DXLUTCOLOR;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0000_v0_0_s_ifspec;

#ifndef __IDXLUTBuilder_INTERFACE_DEFINED__
#define __IDXLUTBuilder_INTERFACE_DEFINED__

/* interface IDXLUTBuilder */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXLUTBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4370FC1-CADB-11D0-B52C-00A0C9054373")
    IDXLUTBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumBuildSteps( 
            /* [out] */ ULONG __RPC_FAR *pulNumSteps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuildOrder( 
            /* [size_is][out] */ OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBuildOrder( 
            /* [size_is][in] */ const OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulNumSteps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGamma( 
            /* [in] */ float newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGamma( 
            /* [out] */ float __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacity( 
            /* [out] */ float __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacity( 
            /* [in] */ float newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrightness( 
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBrightness( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContrast( 
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContrast( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLevelsPerChannel( 
            /* [out] */ ULONG __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLevelsPerChannel( 
            /* [in] */ ULONG newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInvert( 
            /* [out] */ float __RPC_FAR *pThreshold) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInvert( 
            /* [in] */ float Threshold) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreshold( 
            /* [out] */ float __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreshold( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXLUTBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXLUTBuilder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXLUTBuilder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumBuildSteps )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumSteps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuildOrder )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [size_is][out] */ OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBuildOrder )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [size_is][in] */ const OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulNumSteps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGamma )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGamma )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpacity )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpacity )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBrightness )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBrightness )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContrast )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContrast )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColorBalance )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColorBalance )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLevelsPerChannel )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLevelsPerChannel )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInvert )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pThreshold);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInvert )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float Threshold);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreshold )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetThreshold )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXLUTBuilderVtbl;

    interface IDXLUTBuilder
    {
        CONST_VTBL struct IDXLUTBuilderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXLUTBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXLUTBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXLUTBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXLUTBuilder_GetNumBuildSteps(This,pulNumSteps)	\
    (This)->lpVtbl -> GetNumBuildSteps(This,pulNumSteps)

#define IDXLUTBuilder_GetBuildOrder(This,OpOrder,ulSize)	\
    (This)->lpVtbl -> GetBuildOrder(This,OpOrder,ulSize)

#define IDXLUTBuilder_SetBuildOrder(This,OpOrder,ulNumSteps)	\
    (This)->lpVtbl -> SetBuildOrder(This,OpOrder,ulNumSteps)

#define IDXLUTBuilder_SetGamma(This,newVal)	\
    (This)->lpVtbl -> SetGamma(This,newVal)

#define IDXLUTBuilder_GetGamma(This,pVal)	\
    (This)->lpVtbl -> GetGamma(This,pVal)

#define IDXLUTBuilder_GetOpacity(This,pVal)	\
    (This)->lpVtbl -> GetOpacity(This,pVal)

#define IDXLUTBuilder_SetOpacity(This,newVal)	\
    (This)->lpVtbl -> SetOpacity(This,newVal)

#define IDXLUTBuilder_GetBrightness(This,pulCount,Weights)	\
    (This)->lpVtbl -> GetBrightness(This,pulCount,Weights)

#define IDXLUTBuilder_SetBrightness(This,ulCount,Weights)	\
    (This)->lpVtbl -> SetBrightness(This,ulCount,Weights)

#define IDXLUTBuilder_GetContrast(This,pulCount,Weights)	\
    (This)->lpVtbl -> GetContrast(This,pulCount,Weights)

#define IDXLUTBuilder_SetContrast(This,ulCount,Weights)	\
    (This)->lpVtbl -> SetContrast(This,ulCount,Weights)

#define IDXLUTBuilder_GetColorBalance(This,Color,pulCount,Weights)	\
    (This)->lpVtbl -> GetColorBalance(This,Color,pulCount,Weights)

#define IDXLUTBuilder_SetColorBalance(This,Color,ulCount,Weights)	\
    (This)->lpVtbl -> SetColorBalance(This,Color,ulCount,Weights)

#define IDXLUTBuilder_GetLevelsPerChannel(This,pVal)	\
    (This)->lpVtbl -> GetLevelsPerChannel(This,pVal)

#define IDXLUTBuilder_SetLevelsPerChannel(This,newVal)	\
    (This)->lpVtbl -> SetLevelsPerChannel(This,newVal)

#define IDXLUTBuilder_GetInvert(This,pThreshold)	\
    (This)->lpVtbl -> GetInvert(This,pThreshold)

#define IDXLUTBuilder_SetInvert(This,Threshold)	\
    (This)->lpVtbl -> SetInvert(This,Threshold)

#define IDXLUTBuilder_GetThreshold(This,pVal)	\
    (This)->lpVtbl -> GetThreshold(This,pVal)

#define IDXLUTBuilder_SetThreshold(This,newVal)	\
    (This)->lpVtbl -> SetThreshold(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetNumBuildSteps_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumSteps);


void __RPC_STUB IDXLUTBuilder_GetNumBuildSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetBuildOrder_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [size_is][out] */ OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
    /* [in] */ ULONG ulSize);


void __RPC_STUB IDXLUTBuilder_GetBuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetBuildOrder_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [size_is][in] */ const OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
    /* [in] */ ULONG ulNumSteps);


void __RPC_STUB IDXLUTBuilder_SetBuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetGamma_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetGamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetGamma_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetGamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetOpacity_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetOpacity_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetBrightness_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pulCount,
    /* [size_is][out] */ float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetBrightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetBrightness_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetBrightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetContrast_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pulCount,
    /* [size_is][out] */ float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetContrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetContrast_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetContrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetColorBalance_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [out][in] */ ULONG __RPC_FAR *pulCount,
    /* [size_is][out] */ float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetColorBalance_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetLevelsPerChannel_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetLevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetLevelsPerChannel_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ ULONG newVal);


void __RPC_STUB IDXLUTBuilder_SetLevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetInvert_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pThreshold);


void __RPC_STUB IDXLUTBuilder_GetInvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetInvert_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float Threshold);


void __RPC_STUB IDXLUTBuilder_SetInvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetThreshold_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetThreshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetThreshold_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetThreshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXLUTBuilder_INTERFACE_DEFINED__ */


#ifndef __IDXDLUTBuilder_INTERFACE_DEFINED__
#define __IDXDLUTBuilder_INTERFACE_DEFINED__

/* interface IDXDLUTBuilder */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXDLUTBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73068231-35EE-11d1-81A1-0000F87557DB")
    IDXDLUTBuilder : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NumBuildSteps( 
            /* [retval][out] */ long __RPC_FAR *pNumSteps) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BuildOrder( 
            /* [retval][out] */ VARIANT __RPC_FAR *pOpOrder) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BuildOrder( 
            /* [in] */ VARIANT __RPC_FAR *pOpOrder) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Gamma( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Gamma( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Opacity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Opacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Brightness( 
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Brightness( 
            /* [in] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Contrast( 
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Contrast( 
            /* [in] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LevelsPerChannel( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LevelsPerChannel( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invert( 
            /* [retval][out] */ float __RPC_FAR *pThreshold) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Invert( 
            /* [in] */ float Threshold) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Threshold( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Threshold( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXDLUTBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXDLUTBuilder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXDLUTBuilder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumBuildSteps )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pNumSteps);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BuildOrder )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pOpOrder);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BuildOrder )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pOpOrder);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Gamma )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Gamma )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Opacity )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Opacity )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Brightness )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Brightness )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contrast )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Contrast )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorBalance )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorBalance )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LevelsPerChannel )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LevelsPerChannel )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Invert )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pThreshold);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Invert )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float Threshold);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Threshold )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Threshold )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXDLUTBuilderVtbl;

    interface IDXDLUTBuilder
    {
        CONST_VTBL struct IDXDLUTBuilderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXDLUTBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXDLUTBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXDLUTBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXDLUTBuilder_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXDLUTBuilder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXDLUTBuilder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXDLUTBuilder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXDLUTBuilder_get_NumBuildSteps(This,pNumSteps)	\
    (This)->lpVtbl -> get_NumBuildSteps(This,pNumSteps)

#define IDXDLUTBuilder_get_BuildOrder(This,pOpOrder)	\
    (This)->lpVtbl -> get_BuildOrder(This,pOpOrder)

#define IDXDLUTBuilder_put_BuildOrder(This,pOpOrder)	\
    (This)->lpVtbl -> put_BuildOrder(This,pOpOrder)

#define IDXDLUTBuilder_get_Gamma(This,pVal)	\
    (This)->lpVtbl -> get_Gamma(This,pVal)

#define IDXDLUTBuilder_put_Gamma(This,newVal)	\
    (This)->lpVtbl -> put_Gamma(This,newVal)

#define IDXDLUTBuilder_get_Opacity(This,pVal)	\
    (This)->lpVtbl -> get_Opacity(This,pVal)

#define IDXDLUTBuilder_put_Opacity(This,newVal)	\
    (This)->lpVtbl -> put_Opacity(This,newVal)

#define IDXDLUTBuilder_get_Brightness(This,pWeights)	\
    (This)->lpVtbl -> get_Brightness(This,pWeights)

#define IDXDLUTBuilder_put_Brightness(This,pWeights)	\
    (This)->lpVtbl -> put_Brightness(This,pWeights)

#define IDXDLUTBuilder_get_Contrast(This,pWeights)	\
    (This)->lpVtbl -> get_Contrast(This,pWeights)

#define IDXDLUTBuilder_put_Contrast(This,pWeights)	\
    (This)->lpVtbl -> put_Contrast(This,pWeights)

#define IDXDLUTBuilder_get_ColorBalance(This,Color,pWeights)	\
    (This)->lpVtbl -> get_ColorBalance(This,Color,pWeights)

#define IDXDLUTBuilder_put_ColorBalance(This,Color,pWeights)	\
    (This)->lpVtbl -> put_ColorBalance(This,Color,pWeights)

#define IDXDLUTBuilder_get_LevelsPerChannel(This,pVal)	\
    (This)->lpVtbl -> get_LevelsPerChannel(This,pVal)

#define IDXDLUTBuilder_put_LevelsPerChannel(This,newVal)	\
    (This)->lpVtbl -> put_LevelsPerChannel(This,newVal)

#define IDXDLUTBuilder_get_Invert(This,pThreshold)	\
    (This)->lpVtbl -> get_Invert(This,pThreshold)

#define IDXDLUTBuilder_put_Invert(This,Threshold)	\
    (This)->lpVtbl -> put_Invert(This,Threshold)

#define IDXDLUTBuilder_get_Threshold(This,pVal)	\
    (This)->lpVtbl -> get_Threshold(This,pVal)

#define IDXDLUTBuilder_put_Threshold(This,newVal)	\
    (This)->lpVtbl -> put_Threshold(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_NumBuildSteps_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pNumSteps);


void __RPC_STUB IDXDLUTBuilder_get_NumBuildSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_BuildOrder_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pOpOrder);


void __RPC_STUB IDXDLUTBuilder_get_BuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_BuildOrder_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pOpOrder);


void __RPC_STUB IDXDLUTBuilder_put_BuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Gamma_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Gamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Gamma_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Gamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Opacity_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Opacity_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Brightness_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_Brightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Brightness_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_Brightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Contrast_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_Contrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Contrast_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_Contrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_ColorBalance_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [retval][out] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_ColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_ColorBalance_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [in] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_ColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_LevelsPerChannel_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_LevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_LevelsPerChannel_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXDLUTBuilder_put_LevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Invert_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pThreshold);


void __RPC_STUB IDXDLUTBuilder_get_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Invert_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float Threshold);


void __RPC_STUB IDXDLUTBuilder_put_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Threshold_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Threshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Threshold_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Threshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXDLUTBuilder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0281 */
/* [local] */ 

typedef 
enum DXGRADIENTTYPE
    {	DXGRADIENT_VERTICAL	= 0,
	DXGRADIENT_HORIZONTAL	= DXGRADIENT_VERTICAL + 1,
	DXGRADIENT_NUM_GRADIENTS	= DXGRADIENT_HORIZONTAL + 1
    }	DXGRADIENTTYPE;

typedef 
enum DXGRADDISPID
    {	DISPID_GradientType	= 1,
	DISPID_StartColor	= DISPID_GradientType + 1,
	DISPID_EndColor	= DISPID_StartColor + 1,
	DISPID_GradientWidth	= DISPID_EndColor + 1,
	DISPID_GradientHeight	= DISPID_GradientWidth + 1,
	DISPID_GradientAspect	= DISPID_GradientHeight + 1,
	DISPID_StartColorStr	= DISPID_GradientAspect + 1,
	DISPID_EndColorStr	= DISPID_StartColorStr + 1
    }	DXGRADDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0281_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0281_v0_0_s_ifspec;

#ifndef __IDXTGradientD_INTERFACE_DEFINED__
#define __IDXTGradientD_INTERFACE_DEFINED__

/* interface IDXTGradientD */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTGradientD;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("623E2881-FC0E-11d1-9A77-0000F8756A10")
    IDXTGradientD : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientType( 
            /* [in] */ DXGRADIENTTYPE eType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientType( 
            /* [retval][out] */ DXGRADIENTTYPE __RPC_FAR *peType) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartColor( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EndColor( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EndColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientWidth( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientWidth( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientHeight( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientHeight( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_KeepAspectRatio( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_KeepAspectRatio( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartColorStr( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EndColorStr( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTGradientDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTGradientD __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTGradientD __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTGradientD __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientType )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ DXGRADIENTTYPE eType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientType )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ DXGRADIENTTYPE __RPC_FAR *peType);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StartColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EndColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EndColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientWidth )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientWidth )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientHeight )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientHeight )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_KeepAspectRatio )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_KeepAspectRatio )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StartColorStr )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EndColorStr )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTGradientDVtbl;

    interface IDXTGradientD
    {
        CONST_VTBL struct IDXTGradientDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTGradientD_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTGradientD_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTGradientD_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTGradientD_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTGradientD_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTGradientD_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTGradientD_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTGradientD_put_GradientType(This,eType)	\
    (This)->lpVtbl -> put_GradientType(This,eType)

#define IDXTGradientD_get_GradientType(This,peType)	\
    (This)->lpVtbl -> get_GradientType(This,peType)

#define IDXTGradientD_put_StartColor(This,newVal)	\
    (This)->lpVtbl -> put_StartColor(This,newVal)

#define IDXTGradientD_get_StartColor(This,pVal)	\
    (This)->lpVtbl -> get_StartColor(This,pVal)

#define IDXTGradientD_put_EndColor(This,newVal)	\
    (This)->lpVtbl -> put_EndColor(This,newVal)

#define IDXTGradientD_get_EndColor(This,pVal)	\
    (This)->lpVtbl -> get_EndColor(This,pVal)

#define IDXTGradientD_put_GradientWidth(This,newVal)	\
    (This)->lpVtbl -> put_GradientWidth(This,newVal)

#define IDXTGradientD_get_GradientWidth(This,pVal)	\
    (This)->lpVtbl -> get_GradientWidth(This,pVal)

#define IDXTGradientD_put_GradientHeight(This,newVal)	\
    (This)->lpVtbl -> put_GradientHeight(This,newVal)

#define IDXTGradientD_get_GradientHeight(This,pVal)	\
    (This)->lpVtbl -> get_GradientHeight(This,pVal)

#define IDXTGradientD_put_KeepAspectRatio(This,newVal)	\
    (This)->lpVtbl -> put_KeepAspectRatio(This,newVal)

#define IDXTGradientD_get_KeepAspectRatio(This,pVal)	\
    (This)->lpVtbl -> get_KeepAspectRatio(This,pVal)

#define IDXTGradientD_put_StartColorStr(This,newVal)	\
    (This)->lpVtbl -> put_StartColorStr(This,newVal)

#define IDXTGradientD_put_EndColorStr(This,newVal)	\
    (This)->lpVtbl -> put_EndColorStr(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientType_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ DXGRADIENTTYPE eType);


void __RPC_STUB IDXTGradientD_put_GradientType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientType_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ DXGRADIENTTYPE __RPC_FAR *peType);


void __RPC_STUB IDXTGradientD_get_GradientType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_StartColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IDXTGradientD_put_StartColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_StartColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_StartColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_EndColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IDXTGradientD_put_EndColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_EndColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_EndColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientWidth_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTGradientD_put_GradientWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientWidth_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_GradientWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientHeight_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTGradientD_put_GradientHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientHeight_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_GradientHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_KeepAspectRatio_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTGradientD_put_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_KeepAspectRatio_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_StartColorStr_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTGradientD_put_StartColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_EndColorStr_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTGradientD_put_EndColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTGradientD_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0282 */
/* [local] */ 

typedef 
enum DXCONVFILTERTYPE
    {	DXCFILTER_SRCCOPY	= 0,
	DXCFILTER_BOX7X7	= DXCFILTER_SRCCOPY + 1,
	DXCFILTER_BLUR3X3	= DXCFILTER_BOX7X7 + 1,
	DXCFILTER_SHARPEN	= DXCFILTER_BLUR3X3 + 1,
	DXCFILTER_EMBOSS	= DXCFILTER_SHARPEN + 1,
	DXCFILTER_ENGRAVE	= DXCFILTER_EMBOSS + 1,
	DXCFILTER_NUM_FILTERS	= DXCFILTER_ENGRAVE + 1,
	DXCFILTER_CUSTOM	= DXCFILTER_NUM_FILTERS + 1
    }	DXCONVFILTERTYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0282_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0282_v0_0_s_ifspec;

#ifndef __IDXTConvolution_INTERFACE_DEFINED__
#define __IDXTConvolution_INTERFACE_DEFINED__

/* interface IDXTConvolution */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTConvolution;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7BA7F8AF-E5EA-11d1-81DD-0000F87557DB")
    IDXTConvolution : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFilterType( 
            /* [in] */ DXCONVFILTERTYPE eType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterType( 
            /* [out] */ DXCONVFILTERTYPE __RPC_FAR *peType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCustomFilter( 
            /* [in] */ float __RPC_FAR *pFilter,
            /* [in] */ SIZE Size) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConvertToGray( 
            /* [in] */ BOOL bConvertToGray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConvertToGray( 
            /* [out] */ BOOL __RPC_FAR *pbConvertToGray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBias( 
            /* [in] */ float Bias) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBias( 
            /* [out] */ float __RPC_FAR *pBias) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExcludeAlpha( 
            /* [in] */ BOOL bExcludeAlpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExcludeAlpha( 
            /* [out] */ BOOL __RPC_FAR *pbExcludeAlpha) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTConvolutionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTConvolution __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTConvolution __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFilterType )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ DXCONVFILTERTYPE eType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilterType )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ DXCONVFILTERTYPE __RPC_FAR *peType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCustomFilter )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ float __RPC_FAR *pFilter,
            /* [in] */ SIZE Size);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConvertToGray )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ BOOL bConvertToGray);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConvertToGray )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pbConvertToGray);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBias )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ float Bias);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBias )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pBias);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExcludeAlpha )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ BOOL bExcludeAlpha);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExcludeAlpha )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pbExcludeAlpha);
        
        END_INTERFACE
    } IDXTConvolutionVtbl;

    interface IDXTConvolution
    {
        CONST_VTBL struct IDXTConvolutionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTConvolution_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTConvolution_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTConvolution_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTConvolution_SetFilterType(This,eType)	\
    (This)->lpVtbl -> SetFilterType(This,eType)

#define IDXTConvolution_GetFilterType(This,peType)	\
    (This)->lpVtbl -> GetFilterType(This,peType)

#define IDXTConvolution_SetCustomFilter(This,pFilter,Size)	\
    (This)->lpVtbl -> SetCustomFilter(This,pFilter,Size)

#define IDXTConvolution_SetConvertToGray(This,bConvertToGray)	\
    (This)->lpVtbl -> SetConvertToGray(This,bConvertToGray)

#define IDXTConvolution_GetConvertToGray(This,pbConvertToGray)	\
    (This)->lpVtbl -> GetConvertToGray(This,pbConvertToGray)

#define IDXTConvolution_SetBias(This,Bias)	\
    (This)->lpVtbl -> SetBias(This,Bias)

#define IDXTConvolution_GetBias(This,pBias)	\
    (This)->lpVtbl -> GetBias(This,pBias)

#define IDXTConvolution_SetExcludeAlpha(This,bExcludeAlpha)	\
    (This)->lpVtbl -> SetExcludeAlpha(This,bExcludeAlpha)

#define IDXTConvolution_GetExcludeAlpha(This,pbExcludeAlpha)	\
    (This)->lpVtbl -> GetExcludeAlpha(This,pbExcludeAlpha)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTConvolution_SetFilterType_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ DXCONVFILTERTYPE eType);


void __RPC_STUB IDXTConvolution_SetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetFilterType_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ DXCONVFILTERTYPE __RPC_FAR *peType);


void __RPC_STUB IDXTConvolution_GetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetCustomFilter_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ float __RPC_FAR *pFilter,
    /* [in] */ SIZE Size);


void __RPC_STUB IDXTConvolution_SetCustomFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetConvertToGray_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ BOOL bConvertToGray);


void __RPC_STUB IDXTConvolution_SetConvertToGray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetConvertToGray_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pbConvertToGray);


void __RPC_STUB IDXTConvolution_GetConvertToGray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetBias_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ float Bias);


void __RPC_STUB IDXTConvolution_SetBias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetBias_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pBias);


void __RPC_STUB IDXTConvolution_GetBias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetExcludeAlpha_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ BOOL bExcludeAlpha);


void __RPC_STUB IDXTConvolution_SetExcludeAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetExcludeAlpha_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pbExcludeAlpha);


void __RPC_STUB IDXTConvolution_GetExcludeAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTConvolution_INTERFACE_DEFINED__ */


#ifndef __IDXMapper_INTERFACE_DEFINED__
#define __IDXMapper_INTERFACE_DEFINED__

/* interface IDXMapper */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("555278E5-05DB-11D1-883A-3C8B00C10000")
    IDXMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapIn2Out( 
            /* [in] */ DXVEC __RPC_FAR *pInPt,
            /* [out] */ DXVEC __RPC_FAR *pOutPt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapOut2In( 
            /* [in] */ DXVEC __RPC_FAR *pOutPt,
            /* [out] */ DXVEC __RPC_FAR *pInPt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXMapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXMapper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXMapper __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapIn2Out )( 
            IDXMapper __RPC_FAR * This,
            /* [in] */ DXVEC __RPC_FAR *pInPt,
            /* [out] */ DXVEC __RPC_FAR *pOutPt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapOut2In )( 
            IDXMapper __RPC_FAR * This,
            /* [in] */ DXVEC __RPC_FAR *pOutPt,
            /* [out] */ DXVEC __RPC_FAR *pInPt);
        
        END_INTERFACE
    } IDXMapperVtbl;

    interface IDXMapper
    {
        CONST_VTBL struct IDXMapperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXMapper_MapIn2Out(This,pInPt,pOutPt)	\
    (This)->lpVtbl -> MapIn2Out(This,pInPt,pOutPt)

#define IDXMapper_MapOut2In(This,pOutPt,pInPt)	\
    (This)->lpVtbl -> MapOut2In(This,pOutPt,pInPt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXMapper_MapIn2Out_Proxy( 
    IDXMapper __RPC_FAR * This,
    /* [in] */ DXVEC __RPC_FAR *pInPt,
    /* [out] */ DXVEC __RPC_FAR *pOutPt);


void __RPC_STUB IDXMapper_MapIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXMapper_MapOut2In_Proxy( 
    IDXMapper __RPC_FAR * This,
    /* [in] */ DXVEC __RPC_FAR *pOutPt,
    /* [out] */ DXVEC __RPC_FAR *pInPt);


void __RPC_STUB IDXMapper_MapOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXMapper_INTERFACE_DEFINED__ */


#ifndef __IDXDMapper_INTERFACE_DEFINED__
#define __IDXDMapper_INTERFACE_DEFINED__

/* interface IDXDMapper */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXDMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FD9088B-35ED-11d1-81A1-0000F87557DB")
    IDXDMapper : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapIn2Out( 
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapOut2In( 
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXDMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXDMapper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXDMapper __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXDMapper __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapIn2Out )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapOut2In )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt);
        
        END_INTERFACE
    } IDXDMapperVtbl;

    interface IDXDMapper
    {
        CONST_VTBL struct IDXDMapperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXDMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXDMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXDMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXDMapper_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXDMapper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXDMapper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXDMapper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXDMapper_MapIn2Out(This,pInPt,pOutPt)	\
    (This)->lpVtbl -> MapIn2Out(This,pInPt,pOutPt)

#define IDXDMapper_MapOut2In(This,pOutPt,pInPt)	\
    (This)->lpVtbl -> MapOut2In(This,pOutPt,pInPt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXDMapper_MapIn2Out_Proxy( 
    IDXDMapper __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt);


void __RPC_STUB IDXDMapper_MapIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXDMapper_MapOut2In_Proxy( 
    IDXDMapper __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt);


void __RPC_STUB IDXDMapper_MapOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXDMapper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0285 */
/* [local] */ 

typedef 
enum DXCOMPFUNC
    {	DXCOMPFUNC_SWAP_AB	= 0x10,
	DXCOMPFUNC_FUNCMASK	= 0xf,
	DXCOMPFUNC_CLEAR	= 0,
	DXCOMPFUNC_MIN	= DXCOMPFUNC_CLEAR + 1,
	DXCOMPFUNC_MAX	= DXCOMPFUNC_MIN + 1,
	DXCOMPFUNC_A	= DXCOMPFUNC_MAX + 1,
	DXCOMPFUNC_A_OVER_B	= DXCOMPFUNC_A + 1,
	DXCOMPFUNC_A_IN_B	= DXCOMPFUNC_A_OVER_B + 1,
	DXCOMPFUNC_A_OUT_B	= DXCOMPFUNC_A_IN_B + 1,
	DXCOMPFUNC_A_ATOP_B	= DXCOMPFUNC_A_OUT_B + 1,
	DXCOMPFUNC_A_SUBTRACT_B	= DXCOMPFUNC_A_ATOP_B + 1,
	DXCOMPFUNC_A_ADD_B	= DXCOMPFUNC_A_SUBTRACT_B + 1,
	DXCOMPFUNC_A_XOR_B	= DXCOMPFUNC_A_ADD_B + 1,
	DXCOMPFUNC_B	= DXCOMPFUNC_A | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_OVER_A	= DXCOMPFUNC_A_OVER_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_IN_A	= DXCOMPFUNC_A_IN_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_OUT_A	= DXCOMPFUNC_A_OUT_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_ATOP_A	= DXCOMPFUNC_A_ATOP_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_SUBTRACT_A	= DXCOMPFUNC_A_SUBTRACT_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_ADD_A	= DXCOMPFUNC_A_ADD_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_NUMFUNCS	= DXCOMPFUNC_B_ADD_A + 1
    }	DXCOMPFUNC;

typedef 
enum DXCOMPOSITEDISPID
    {	DISPID_DXCOMPOSITE_Function	= 1
    }	DXCOMPOSITEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0285_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0285_v0_0_s_ifspec;

#ifndef __IDXTComposite_INTERFACE_DEFINED__
#define __IDXTComposite_INTERFACE_DEFINED__

/* interface IDXTComposite */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTComposite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9A43A843-0831-11D1-817F-0000F87557DB")
    IDXTComposite : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Function( 
            /* [in] */ DXCOMPFUNC eFunc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Function( 
            /* [retval][out] */ DXCOMPFUNC __RPC_FAR *peFunc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTCompositeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTComposite __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTComposite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTComposite __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Function )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ DXCOMPFUNC eFunc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Function )( 
            IDXTComposite __RPC_FAR * This,
            /* [retval][out] */ DXCOMPFUNC __RPC_FAR *peFunc);
        
        END_INTERFACE
    } IDXTCompositeVtbl;

    interface IDXTComposite
    {
        CONST_VTBL struct IDXTCompositeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTComposite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTComposite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTComposite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTComposite_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTComposite_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTComposite_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTComposite_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTComposite_put_Function(This,eFunc)	\
    (This)->lpVtbl -> put_Function(This,eFunc)

#define IDXTComposite_get_Function(This,peFunc)	\
    (This)->lpVtbl -> get_Function(This,peFunc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTComposite_put_Function_Proxy( 
    IDXTComposite __RPC_FAR * This,
    /* [in] */ DXCOMPFUNC eFunc);


void __RPC_STUB IDXTComposite_put_Function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTComposite_get_Function_Proxy( 
    IDXTComposite __RPC_FAR * This,
    /* [retval][out] */ DXCOMPFUNC __RPC_FAR *peFunc);


void __RPC_STUB IDXTComposite_get_Function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTComposite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0286 */
/* [local] */ 

typedef 
enum DXWIPEDIRECTION
    {	DXWD_HORIZONTAL	= 0,
	DXWD_VERTICAL	= DXWD_HORIZONTAL + 1
    }	DXWIPEDIRECTION;

typedef 
enum DXWIPEDISPID
    {	DISPID_DXW_GradientSize	= DISPID_DXE_NEXT_ID,
	DISPID_DXW_WipeStyle	= DISPID_DXW_GradientSize + 1
    }	DXWIPEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0286_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0286_v0_0_s_ifspec;

#ifndef __IDXTWipe_INTERFACE_DEFINED__
#define __IDXTWipe_INTERFACE_DEFINED__

/* interface IDXTWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF279B2F-86EB-11D1-81BF-0000F87557DB")
    IDXTWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientSize( 
            /* [retval][out] */ float __RPC_FAR *pPercentSize) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientSize( 
            /* [in] */ float PercentSize) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_WipeStyle( 
            /* [retval][out] */ DXWIPEDIRECTION __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_WipeStyle( 
            /* [in] */ DXWIPEDIRECTION newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTWipe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTWipe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTWipe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientSize )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pPercentSize);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientSize )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ float PercentSize);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WipeStyle )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ DXWIPEDIRECTION __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WipeStyle )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ DXWIPEDIRECTION newVal);
        
        END_INTERFACE
    } IDXTWipeVtbl;

    interface IDXTWipe
    {
        CONST_VTBL struct IDXTWipeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTWipe_get_GradientSize(This,pPercentSize)	\
    (This)->lpVtbl -> get_GradientSize(This,pPercentSize)

#define IDXTWipe_put_GradientSize(This,PercentSize)	\
    (This)->lpVtbl -> put_GradientSize(This,PercentSize)

#define IDXTWipe_get_WipeStyle(This,pVal)	\
    (This)->lpVtbl -> get_WipeStyle(This,pVal)

#define IDXTWipe_put_WipeStyle(This,newVal)	\
    (This)->lpVtbl -> put_WipeStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWipe_get_GradientSize_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pPercentSize);


void __RPC_STUB IDXTWipe_get_GradientSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWipe_put_GradientSize_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [in] */ float PercentSize);


void __RPC_STUB IDXTWipe_put_GradientSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWipe_get_WipeStyle_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [retval][out] */ DXWIPEDIRECTION __RPC_FAR *pVal);


void __RPC_STUB IDXTWipe_get_WipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWipe_put_WipeStyle_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [in] */ DXWIPEDIRECTION newVal);


void __RPC_STUB IDXTWipe_put_WipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTWipe_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0287 */
/* [local] */ 

typedef 
enum CRBLURDISPID
    {	DISPID_CRB_MakeShadow	= 1,
	DISPID_CRB_ShadowOpacity	= DISPID_CRB_MakeShadow + 1,
	DISPID_CRB_PixelRadius	= DISPID_CRB_ShadowOpacity + 1
    }	CRBLURDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0287_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0287_v0_0_s_ifspec;

#ifndef __ICrBlur_INTERFACE_DEFINED__
#define __ICrBlur_INTERFACE_DEFINED__

/* interface ICrBlur */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBlur;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F7C7827-E87A-11d1-81E0-0000F87557DB")
    ICrBlur : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MakeShadow( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MakeShadow( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ShadowOpacity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ShadowOpacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PixelRadius( 
            /* [retval][out] */ float __RPC_FAR *pPixelRadius) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PixelRadius( 
            /* [in] */ float PixelRadius) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBlurVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrBlur __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrBlur __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrBlur __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MakeShadow )( 
            ICrBlur __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MakeShadow )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShadowOpacity )( 
            ICrBlur __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShadowOpacity )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PixelRadius )( 
            ICrBlur __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pPixelRadius);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PixelRadius )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ float PixelRadius);
        
        END_INTERFACE
    } ICrBlurVtbl;

    interface ICrBlur
    {
        CONST_VTBL struct ICrBlurVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBlur_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBlur_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBlur_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBlur_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBlur_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBlur_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBlur_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBlur_get_MakeShadow(This,pVal)	\
    (This)->lpVtbl -> get_MakeShadow(This,pVal)

#define ICrBlur_put_MakeShadow(This,newVal)	\
    (This)->lpVtbl -> put_MakeShadow(This,newVal)

#define ICrBlur_get_ShadowOpacity(This,pVal)	\
    (This)->lpVtbl -> get_ShadowOpacity(This,pVal)

#define ICrBlur_put_ShadowOpacity(This,newVal)	\
    (This)->lpVtbl -> put_ShadowOpacity(This,newVal)

#define ICrBlur_get_PixelRadius(This,pPixelRadius)	\
    (This)->lpVtbl -> get_PixelRadius(This,pPixelRadius)

#define ICrBlur_put_PixelRadius(This,PixelRadius)	\
    (This)->lpVtbl -> put_PixelRadius(This,PixelRadius)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_MakeShadow_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB ICrBlur_get_MakeShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_MakeShadow_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB ICrBlur_put_MakeShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_ShadowOpacity_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrBlur_get_ShadowOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_ShadowOpacity_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrBlur_put_ShadowOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_PixelRadius_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pPixelRadius);


void __RPC_STUB ICrBlur_get_PixelRadius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_PixelRadius_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [in] */ float PixelRadius);


void __RPC_STUB ICrBlur_put_PixelRadius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBlur_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0288 */
/* [local] */ 

typedef 
enum CRENGRAVEDISPID
    {	DISPID_CREN_Bias	= 1
    }	CRENGRAVEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0288_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0288_v0_0_s_ifspec;

#ifndef __ICrEngrave_INTERFACE_DEFINED__
#define __ICrEngrave_INTERFACE_DEFINED__

/* interface ICrEngrave */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrEngrave;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E4ACFB7F-053E-11d2-81EA-0000F87557DB")
    ICrEngrave : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Bias( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Bias( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrEngraveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrEngrave __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrEngrave __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrEngrave __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bias )( 
            ICrEngrave __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Bias )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrEngraveVtbl;

    interface ICrEngrave
    {
        CONST_VTBL struct ICrEngraveVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrEngrave_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrEngrave_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrEngrave_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrEngrave_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrEngrave_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrEngrave_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrEngrave_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrEngrave_get_Bias(This,pVal)	\
    (This)->lpVtbl -> get_Bias(This,pVal)

#define ICrEngrave_put_Bias(This,newVal)	\
    (This)->lpVtbl -> put_Bias(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrEngrave_get_Bias_Proxy( 
    ICrEngrave __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrEngrave_get_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrEngrave_put_Bias_Proxy( 
    ICrEngrave __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrEngrave_put_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrEngrave_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0289 */
/* [local] */ 

typedef 
enum CREMBOSSDISPID
    {	DISPID_CREM_Bias	= 1
    }	CREMBOSSDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0289_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0289_v0_0_s_ifspec;

#ifndef __ICrEmboss_INTERFACE_DEFINED__
#define __ICrEmboss_INTERFACE_DEFINED__

/* interface ICrEmboss */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrEmboss;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E4ACFB80-053E-11d2-81EA-0000F87557DB")
    ICrEmboss : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Bias( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Bias( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrEmbossVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrEmboss __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrEmboss __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrEmboss __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bias )( 
            ICrEmboss __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Bias )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrEmbossVtbl;

    interface ICrEmboss
    {
        CONST_VTBL struct ICrEmbossVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrEmboss_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrEmboss_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrEmboss_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrEmboss_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrEmboss_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrEmboss_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrEmboss_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrEmboss_get_Bias(This,pVal)	\
    (This)->lpVtbl -> get_Bias(This,pVal)

#define ICrEmboss_put_Bias(This,newVal)	\
    (This)->lpVtbl -> put_Bias(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrEmboss_get_Bias_Proxy( 
    ICrEmboss __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrEmboss_get_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrEmboss_put_Bias_Proxy( 
    ICrEmboss __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrEmboss_put_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrEmboss_INTERFACE_DEFINED__ */


#ifndef __IDXTFade_INTERFACE_DEFINED__
#define __IDXTFade_INTERFACE_DEFINED__

/* interface IDXTFade */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTFade;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16B280C4-EE70-11D1-9066-00C04FD9189D")
    IDXTFade : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Overlap( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Overlap( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Center( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Center( 
            /* [in] */ BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFadeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTFade __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTFade __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTFade __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Overlap )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Overlap )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Center )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Center )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        END_INTERFACE
    } IDXTFadeVtbl;

    interface IDXTFade
    {
        CONST_VTBL struct IDXTFadeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFade_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFade_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFade_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFade_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTFade_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTFade_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTFade_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTFade_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTFade_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTFade_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTFade_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTFade_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTFade_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTFade_get_Overlap(This,pVal)	\
    (This)->lpVtbl -> get_Overlap(This,pVal)

#define IDXTFade_put_Overlap(This,newVal)	\
    (This)->lpVtbl -> put_Overlap(This,newVal)

#define IDXTFade_get_Center(This,pVal)	\
    (This)->lpVtbl -> get_Center(This,pVal)

#define IDXTFade_put_Center(This,newVal)	\
    (This)->lpVtbl -> put_Center(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTFade_get_Overlap_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTFade_get_Overlap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTFade_put_Overlap_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTFade_put_Overlap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTFade_get_Center_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTFade_get_Center_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTFade_put_Center_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXTFade_put_Center_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFade_INTERFACE_DEFINED__ */


#ifndef __IDXBasicImage_INTERFACE_DEFINED__
#define __IDXBasicImage_INTERFACE_DEFINED__

/* interface IDXBasicImage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXBasicImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16B280C7-EE70-11D1-9066-00C04FD9189D")
    IDXBasicImage : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Rotation( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Rotation( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Mirror( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Mirror( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GrayScale( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GrayScale( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Opacity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Opacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invert( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Invert( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XRay( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XRay( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Mask( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Mask( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaskColor( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaskColor( 
            /* [in] */ int newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXBasicImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXBasicImage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXBasicImage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXBasicImage __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rotation )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Rotation )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mirror )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mirror )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GrayScale )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GrayScale )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Opacity )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Opacity )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Invert )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Invert )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XRay )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XRay )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mask )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mask )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaskColor )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaskColor )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ int newVal);
        
        END_INTERFACE
    } IDXBasicImageVtbl;

    interface IDXBasicImage
    {
        CONST_VTBL struct IDXBasicImageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXBasicImage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXBasicImage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXBasicImage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXBasicImage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXBasicImage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXBasicImage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXBasicImage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXBasicImage_get_Rotation(This,pVal)	\
    (This)->lpVtbl -> get_Rotation(This,pVal)

#define IDXBasicImage_put_Rotation(This,newVal)	\
    (This)->lpVtbl -> put_Rotation(This,newVal)

#define IDXBasicImage_get_Mirror(This,pVal)	\
    (This)->lpVtbl -> get_Mirror(This,pVal)

#define IDXBasicImage_put_Mirror(This,newVal)	\
    (This)->lpVtbl -> put_Mirror(This,newVal)

#define IDXBasicImage_get_GrayScale(This,pVal)	\
    (This)->lpVtbl -> get_GrayScale(This,pVal)

#define IDXBasicImage_put_GrayScale(This,newVal)	\
    (This)->lpVtbl -> put_GrayScale(This,newVal)

#define IDXBasicImage_get_Opacity(This,pVal)	\
    (This)->lpVtbl -> get_Opacity(This,pVal)

#define IDXBasicImage_put_Opacity(This,newVal)	\
    (This)->lpVtbl -> put_Opacity(This,newVal)

#define IDXBasicImage_get_Invert(This,pVal)	\
    (This)->lpVtbl -> get_Invert(This,pVal)

#define IDXBasicImage_put_Invert(This,newVal)	\
    (This)->lpVtbl -> put_Invert(This,newVal)

#define IDXBasicImage_get_XRay(This,pVal)	\
    (This)->lpVtbl -> get_XRay(This,pVal)

#define IDXBasicImage_put_XRay(This,newVal)	\
    (This)->lpVtbl -> put_XRay(This,newVal)

#define IDXBasicImage_get_Mask(This,pVal)	\
    (This)->lpVtbl -> get_Mask(This,pVal)

#define IDXBasicImage_put_Mask(This,newVal)	\
    (This)->lpVtbl -> put_Mask(This,newVal)

#define IDXBasicImage_get_MaskColor(This,pVal)	\
    (This)->lpVtbl -> get_MaskColor(This,pVal)

#define IDXBasicImage_put_MaskColor(This,newVal)	\
    (This)->lpVtbl -> put_MaskColor(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Rotation_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Rotation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Rotation_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXBasicImage_put_Rotation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Mirror_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Mirror_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Mirror_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Mirror_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_GrayScale_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_GrayScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_GrayScale_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_GrayScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Opacity_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Opacity_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXBasicImage_put_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Invert_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Invert_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_XRay_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_XRay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_XRay_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_XRay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Mask_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Mask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Mask_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Mask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_MaskColor_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_MaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_MaskColor_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXBasicImage_put_MaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXBasicImage_INTERFACE_DEFINED__ */


#ifndef __IDXPixelate_INTERFACE_DEFINED__
#define __IDXPixelate_INTERFACE_DEFINED__

/* interface IDXPixelate */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXPixelate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D33E180F-FBE9-11d1-906A-00C04FD9189D")
    IDXPixelate : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxSquare( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxSquare( 
            /* [in] */ int newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXPixelateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXPixelate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXPixelate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXPixelate __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxSquare )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxSquare )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ int newVal);
        
        END_INTERFACE
    } IDXPixelateVtbl;

    interface IDXPixelate
    {
        CONST_VTBL struct IDXPixelateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXPixelate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXPixelate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXPixelate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXPixelate_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXPixelate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXPixelate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXPixelate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXPixelate_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXPixelate_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXPixelate_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXPixelate_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXPixelate_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXPixelate_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXPixelate_get_MaxSquare(This,pVal)	\
    (This)->lpVtbl -> get_MaxSquare(This,pVal)

#define IDXPixelate_put_MaxSquare(This,newVal)	\
    (This)->lpVtbl -> put_MaxSquare(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXPixelate_get_MaxSquare_Proxy( 
    IDXPixelate __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXPixelate_get_MaxSquare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXPixelate_put_MaxSquare_Proxy( 
    IDXPixelate __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXPixelate_put_MaxSquare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXPixelate_INTERFACE_DEFINED__ */


#ifndef __ICrIris_INTERFACE_DEFINED__
#define __ICrIris_INTERFACE_DEFINED__

/* interface ICrIris */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrIris;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F69F350-0379-11D2-A484-00C04F8EFB69")
    ICrIris : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_irisStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_irisStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrIrisVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrIris __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrIris __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrIris __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_irisStyle )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_irisStyle )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrIrisVtbl;

    interface ICrIris
    {
        CONST_VTBL struct ICrIrisVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrIris_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrIris_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrIris_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrIris_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrIris_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrIris_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrIris_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrIris_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrIris_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrIris_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrIris_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrIris_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrIris_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrIris_get_irisStyle(This,pVal)	\
    (This)->lpVtbl -> get_irisStyle(This,pVal)

#define ICrIris_put_irisStyle(This,newVal)	\
    (This)->lpVtbl -> put_irisStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrIris_get_irisStyle_Proxy( 
    ICrIris __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrIris_get_irisStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrIris_put_irisStyle_Proxy( 
    ICrIris __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrIris_put_irisStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrIris_INTERFACE_DEFINED__ */


#ifndef __ICrSlide_INTERFACE_DEFINED__
#define __ICrSlide_INTERFACE_DEFINED__

/* interface ICrSlide */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrSlide;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("810E402E-056B-11D2-A484-00C04F8EFB69")
    ICrSlide : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bands( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bands( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_slideStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_slideStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrSlideVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrSlide __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrSlide __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrSlide __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bands )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bands )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_slideStyle )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_slideStyle )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrSlideVtbl;

    interface ICrSlide
    {
        CONST_VTBL struct ICrSlideVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrSlide_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrSlide_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrSlide_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrSlide_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrSlide_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrSlide_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrSlide_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrSlide_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrSlide_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrSlide_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrSlide_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrSlide_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrSlide_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrSlide_get_bands(This,pVal)	\
    (This)->lpVtbl -> get_bands(This,pVal)

#define ICrSlide_put_bands(This,newVal)	\
    (This)->lpVtbl -> put_bands(This,newVal)

#define ICrSlide_get_slideStyle(This,pVal)	\
    (This)->lpVtbl -> get_slideStyle(This,pVal)

#define ICrSlide_put_slideStyle(This,newVal)	\
    (This)->lpVtbl -> put_slideStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSlide_get_bands_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrSlide_get_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSlide_put_bands_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrSlide_put_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSlide_get_slideStyle_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrSlide_get_slideStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSlide_put_slideStyle_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrSlide_put_slideStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrSlide_INTERFACE_DEFINED__ */


#ifndef __ICrRadialWipe_INTERFACE_DEFINED__
#define __ICrRadialWipe_INTERFACE_DEFINED__

/* interface ICrRadialWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrRadialWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("424B71AE-0695-11D2-A484-00C04F8EFB69")
    ICrRadialWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_wipeStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_wipeStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrRadialWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrRadialWipe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrRadialWipe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_wipeStyle )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_wipeStyle )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrRadialWipeVtbl;

    interface ICrRadialWipe
    {
        CONST_VTBL struct ICrRadialWipeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrRadialWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrRadialWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrRadialWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrRadialWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrRadialWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrRadialWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrRadialWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrRadialWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrRadialWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrRadialWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrRadialWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrRadialWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrRadialWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrRadialWipe_get_wipeStyle(This,pVal)	\
    (This)->lpVtbl -> get_wipeStyle(This,pVal)

#define ICrRadialWipe_put_wipeStyle(This,newVal)	\
    (This)->lpVtbl -> put_wipeStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrRadialWipe_get_wipeStyle_Proxy( 
    ICrRadialWipe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrRadialWipe_get_wipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrRadialWipe_put_wipeStyle_Proxy( 
    ICrRadialWipe __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrRadialWipe_put_wipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrRadialWipe_INTERFACE_DEFINED__ */


#ifndef __ICrBarn_INTERFACE_DEFINED__
#define __ICrBarn_INTERFACE_DEFINED__

/* interface ICrBarn */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBarn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("276A2EE0-0B5D-11d2-A484-00C04F8EFB69")
    ICrBarn : public IDXEffect
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrBarnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrBarn __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrBarn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrBarn __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrBarnVtbl;

    interface ICrBarn
    {
        CONST_VTBL struct ICrBarnVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBarn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBarn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBarn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBarn_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBarn_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBarn_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBarn_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBarn_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBarn_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBarn_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBarn_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBarn_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBarn_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrBarn_INTERFACE_DEFINED__ */


#ifndef __ICrBlinds_INTERFACE_DEFINED__
#define __ICrBlinds_INTERFACE_DEFINED__

/* interface ICrBlinds */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBlinds;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AF5C340-0BA9-11d2-A484-00C04F8EFB69")
    ICrBlinds : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bands( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bands( 
            /* [in] */ short newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBlindsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrBlinds __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrBlinds __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrBlinds __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bands )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bands )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ short newVal);
        
        END_INTERFACE
    } ICrBlindsVtbl;

    interface ICrBlinds
    {
        CONST_VTBL struct ICrBlindsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBlinds_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBlinds_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBlinds_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBlinds_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBlinds_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBlinds_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBlinds_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBlinds_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBlinds_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBlinds_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBlinds_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBlinds_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBlinds_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrBlinds_get_bands(This,pVal)	\
    (This)->lpVtbl -> get_bands(This,pVal)

#define ICrBlinds_put_bands(This,newVal)	\
    (This)->lpVtbl -> put_bands(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlinds_get_bands_Proxy( 
    ICrBlinds __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrBlinds_get_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlinds_put_bands_Proxy( 
    ICrBlinds __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrBlinds_put_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBlinds_INTERFACE_DEFINED__ */


#ifndef __ICrInset_INTERFACE_DEFINED__
#define __ICrInset_INTERFACE_DEFINED__

/* interface ICrInset */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrInset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05C5EE20-0BA6-11d2-A484-00C04F8EFB69")
    ICrInset : public IDXEffect
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrInsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrInset __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrInset __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrInset __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrInsetVtbl;

    interface ICrInset
    {
        CONST_VTBL struct ICrInsetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrInset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrInset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrInset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrInset_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrInset_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrInset_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrInset_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrInset_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrInset_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrInset_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrInset_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrInset_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrInset_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrInset_INTERFACE_DEFINED__ */


#ifndef __ICrStretch_INTERFACE_DEFINED__
#define __ICrStretch_INTERFACE_DEFINED__

/* interface ICrStretch */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrStretch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6684AF00-0A87-11d2-A484-00C04F8EFB69")
    ICrStretch : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_stretchStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_stretchStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrStretchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrStretch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrStretch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrStretch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_stretchStyle )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_stretchStyle )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrStretchVtbl;

    interface ICrStretch
    {
        CONST_VTBL struct ICrStretchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrStretch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrStretch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrStretch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrStretch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrStretch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrStretch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrStretch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrStretch_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrStretch_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrStretch_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrStretch_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrStretch_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrStretch_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrStretch_get_stretchStyle(This,pVal)	\
    (This)->lpVtbl -> get_stretchStyle(This,pVal)

#define ICrStretch_put_stretchStyle(This,newVal)	\
    (This)->lpVtbl -> put_stretchStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrStretch_get_stretchStyle_Proxy( 
    ICrStretch __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrStretch_get_stretchStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrStretch_put_stretchStyle_Proxy( 
    ICrStretch __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrStretch_put_stretchStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrStretch_INTERFACE_DEFINED__ */


#ifndef __ICrSpiral_INTERFACE_DEFINED__
#define __ICrSpiral_INTERFACE_DEFINED__

/* interface ICrSpiral */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrSpiral;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DE527A0-0C7E-11d2-A484-00C04F8EFB69")
    ICrSpiral : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeX( 
            /* [retval][out] */ short __RPC_FAR *pX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeX( 
            /* [in] */ short newX) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeY( 
            /* [retval][out] */ short __RPC_FAR *pY) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeY( 
            /* [in] */ short newY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrSpiralVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrSpiral __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrSpiral __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrSpiral __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeX )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeX )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ short newX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeY )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeY )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ short newY);
        
        END_INTERFACE
    } ICrSpiralVtbl;

    interface ICrSpiral
    {
        CONST_VTBL struct ICrSpiralVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrSpiral_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrSpiral_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrSpiral_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrSpiral_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrSpiral_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrSpiral_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrSpiral_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrSpiral_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrSpiral_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrSpiral_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrSpiral_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrSpiral_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrSpiral_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrSpiral_get_gridSizeX(This,pX)	\
    (This)->lpVtbl -> get_gridSizeX(This,pX)

#define ICrSpiral_put_gridSizeX(This,newX)	\
    (This)->lpVtbl -> put_gridSizeX(This,newX)

#define ICrSpiral_get_gridSizeY(This,pY)	\
    (This)->lpVtbl -> get_gridSizeY(This,pY)

#define ICrSpiral_put_gridSizeY(This,newY)	\
    (This)->lpVtbl -> put_gridSizeY(This,newY)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSpiral_get_gridSizeX_Proxy( 
    ICrSpiral __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pX);


void __RPC_STUB ICrSpiral_get_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSpiral_put_gridSizeX_Proxy( 
    ICrSpiral __RPC_FAR * This,
    /* [in] */ short newX);


void __RPC_STUB ICrSpiral_put_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSpiral_get_gridSizeY_Proxy( 
    ICrSpiral __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pY);


void __RPC_STUB ICrSpiral_get_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSpiral_put_gridSizeY_Proxy( 
    ICrSpiral __RPC_FAR * This,
    /* [in] */ short newY);


void __RPC_STUB ICrSpiral_put_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrSpiral_INTERFACE_DEFINED__ */


#ifndef __ICrZigzag_INTERFACE_DEFINED__
#define __ICrZigzag_INTERFACE_DEFINED__

/* interface ICrZigzag */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrZigzag;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4E5A64A0-0C8B-11d2-A484-00C04F8EFB69")
    ICrZigzag : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeX( 
            /* [retval][out] */ short __RPC_FAR *pX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeX( 
            /* [in] */ short newX) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeY( 
            /* [retval][out] */ short __RPC_FAR *pY) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeY( 
            /* [in] */ short newY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrZigzagVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrZigzag __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrZigzag __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrZigzag __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeX )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeX )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ short newX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeY )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeY )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ short newY);
        
        END_INTERFACE
    } ICrZigzagVtbl;

    interface ICrZigzag
    {
        CONST_VTBL struct ICrZigzagVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrZigzag_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrZigzag_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrZigzag_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrZigzag_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrZigzag_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrZigzag_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrZigzag_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrZigzag_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrZigzag_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrZigzag_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrZigzag_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrZigzag_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrZigzag_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrZigzag_get_gridSizeX(This,pX)	\
    (This)->lpVtbl -> get_gridSizeX(This,pX)

#define ICrZigzag_put_gridSizeX(This,newX)	\
    (This)->lpVtbl -> put_gridSizeX(This,newX)

#define ICrZigzag_get_gridSizeY(This,pY)	\
    (This)->lpVtbl -> get_gridSizeY(This,pY)

#define ICrZigzag_put_gridSizeY(This,newY)	\
    (This)->lpVtbl -> put_gridSizeY(This,newY)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrZigzag_get_gridSizeX_Proxy( 
    ICrZigzag __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pX);


void __RPC_STUB ICrZigzag_get_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrZigzag_put_gridSizeX_Proxy( 
    ICrZigzag __RPC_FAR * This,
    /* [in] */ short newX);


void __RPC_STUB ICrZigzag_put_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrZigzag_get_gridSizeY_Proxy( 
    ICrZigzag __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pY);


void __RPC_STUB ICrZigzag_get_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrZigzag_put_gridSizeY_Proxy( 
    ICrZigzag __RPC_FAR * This,
    /* [in] */ short newY);


void __RPC_STUB ICrZigzag_put_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrZigzag_INTERFACE_DEFINED__ */


#ifndef __ICrWheel_INTERFACE_DEFINED__
#define __ICrWheel_INTERFACE_DEFINED__

/* interface ICrWheel */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrWheel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3943DE80-1464-11d2-A484-00C04F8EFB69")
    ICrWheel : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_spokes( 
            /* [retval][out] */ short __RPC_FAR *pX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_spokes( 
            /* [in] */ short newX) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrWheelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrWheel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrWheel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrWheel __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_spokes )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_spokes )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ short newX);
        
        END_INTERFACE
    } ICrWheelVtbl;

    interface ICrWheel
    {
        CONST_VTBL struct ICrWheelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrWheel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrWheel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrWheel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrWheel_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrWheel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrWheel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrWheel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrWheel_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrWheel_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrWheel_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrWheel_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrWheel_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrWheel_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrWheel_get_spokes(This,pX)	\
    (This)->lpVtbl -> get_spokes(This,pX)

#define ICrWheel_put_spokes(This,newX)	\
    (This)->lpVtbl -> put_spokes(This,newX)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrWheel_get_spokes_Proxy( 
    ICrWheel __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pX);


void __RPC_STUB ICrWheel_get_spokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrWheel_put_spokes_Proxy( 
    ICrWheel __RPC_FAR * This,
    /* [in] */ short newX);


void __RPC_STUB ICrWheel_put_spokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrWheel_INTERFACE_DEFINED__ */


#ifndef __IDXTChroma_INTERFACE_DEFINED__
#define __IDXTChroma_INTERFACE_DEFINED__

/* interface IDXTChroma */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTChroma;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E2-383C-11d2-952A-00C04FA34F05")
    IDXTChroma : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTChromaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTChroma __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTChroma __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTChroma __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ VARIANT newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTChroma __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } IDXTChromaVtbl;

    interface IDXTChroma
    {
        CONST_VTBL struct IDXTChromaVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTChroma_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTChroma_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTChroma_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTChroma_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTChroma_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTChroma_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTChroma_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTChroma_put_Color(This,newVal)	\
    (This)->lpVtbl -> put_Color(This,newVal)

#define IDXTChroma_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTChroma_put_Color_Proxy( 
    IDXTChroma __RPC_FAR * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IDXTChroma_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTChroma_get_Color_Proxy( 
    IDXTChroma __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IDXTChroma_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTChroma_INTERFACE_DEFINED__ */


#ifndef __IDXTDropShadow_INTERFACE_DEFINED__
#define __IDXTDropShadow_INTERFACE_DEFINED__

/* interface IDXTDropShadow */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTDropShadow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E3-383C-11d2-952A-00C04FA34F05")
    IDXTDropShadow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OffX( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OffX( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OffY( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OffY( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Positive( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Positive( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTDropShadowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTDropShadow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTDropShadow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ VARIANT newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OffX )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OffX )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OffY )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OffY )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Positive )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Positive )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IDXTDropShadowVtbl;

    interface IDXTDropShadow
    {
        CONST_VTBL struct IDXTDropShadowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTDropShadow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTDropShadow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTDropShadow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTDropShadow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTDropShadow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTDropShadow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTDropShadow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTDropShadow_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#define IDXTDropShadow_put_Color(This,newVal)	\
    (This)->lpVtbl -> put_Color(This,newVal)

#define IDXTDropShadow_get_OffX(This,pVal)	\
    (This)->lpVtbl -> get_OffX(This,pVal)

#define IDXTDropShadow_put_OffX(This,newVal)	\
    (This)->lpVtbl -> put_OffX(This,newVal)

#define IDXTDropShadow_get_OffY(This,pVal)	\
    (This)->lpVtbl -> get_OffY(This,pVal)

#define IDXTDropShadow_put_OffY(This,newVal)	\
    (This)->lpVtbl -> put_OffY(This,newVal)

#define IDXTDropShadow_get_Positive(This,pVal)	\
    (This)->lpVtbl -> get_Positive(This,pVal)

#define IDXTDropShadow_put_Positive(This,newVal)	\
    (This)->lpVtbl -> put_Positive(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_Color_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_Color_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IDXTDropShadow_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_OffX_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_OffX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_OffX_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTDropShadow_put_OffX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_OffY_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_OffY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_OffY_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTDropShadow_put_OffY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_Positive_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_Positive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_Positive_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTDropShadow_put_Positive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTDropShadow_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaRoll_INTERFACE_DEFINED__
#define __IDXTMetaRoll_INTERFACE_DEFINED__

/* interface IDXTMetaRoll */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaRoll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C61F46D-0530-11D2-8F98-00C04FB92EB7")
    IDXTMetaRoll : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaRollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaRoll __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaRoll __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaRollVtbl;

    interface IDXTMetaRoll
    {
        CONST_VTBL struct IDXTMetaRollVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaRoll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaRoll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaRoll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaRoll_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaRoll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaRoll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaRoll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaRoll_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaRoll_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaRoll_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaRoll_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaRoll_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaRoll_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaRoll_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaRoll_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaRoll_get_Copyright_Proxy( 
    IDXTMetaRoll __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaRoll_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaRoll_put_Copyright_Proxy( 
    IDXTMetaRoll __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaRoll_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaRoll_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaRipple_INTERFACE_DEFINED__
#define __IDXTMetaRipple_INTERFACE_DEFINED__

/* interface IDXTMetaRipple */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaRipple;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D02-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaRipple : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaRippleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaRipple __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaRipple __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaRippleVtbl;

    interface IDXTMetaRipple
    {
        CONST_VTBL struct IDXTMetaRippleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaRipple_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaRipple_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaRipple_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaRipple_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaRipple_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaRipple_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaRipple_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaRipple_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaRipple_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaRipple_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaRipple_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaRipple_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaRipple_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaRipple_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaRipple_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaRipple_get_Copyright_Proxy( 
    IDXTMetaRipple __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaRipple_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaRipple_put_Copyright_Proxy( 
    IDXTMetaRipple __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaRipple_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaRipple_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPageTurn_INTERFACE_DEFINED__
#define __IDXTMetaPageTurn_INTERFACE_DEFINED__

/* interface IDXTMetaPageTurn */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPageTurn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D07-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPageTurn : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPageTurnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaPageTurn __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaPageTurn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPageTurnVtbl;

    interface IDXTMetaPageTurn
    {
        CONST_VTBL struct IDXTMetaPageTurnVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPageTurn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPageTurn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPageTurn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPageTurn_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPageTurn_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPageTurn_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPageTurn_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPageTurn_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPageTurn_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPageTurn_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPageTurn_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPageTurn_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPageTurn_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPageTurn_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPageTurn_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPageTurn_get_Copyright_Proxy( 
    IDXTMetaPageTurn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaPageTurn_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPageTurn_put_Copyright_Proxy( 
    IDXTMetaPageTurn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPageTurn_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPageTurn_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaLiquid_INTERFACE_DEFINED__
#define __IDXTMetaLiquid_INTERFACE_DEFINED__

/* interface IDXTMetaLiquid */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaLiquid;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D09-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaLiquid : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaLiquidVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaLiquid __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaLiquid __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaLiquidVtbl;

    interface IDXTMetaLiquid
    {
        CONST_VTBL struct IDXTMetaLiquidVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaLiquid_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaLiquid_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaLiquid_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaLiquid_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaLiquid_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaLiquid_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaLiquid_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaLiquid_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaLiquid_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaLiquid_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaLiquid_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaLiquid_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaLiquid_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaLiquid_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaLiquid_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaLiquid_get_Copyright_Proxy( 
    IDXTMetaLiquid __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaLiquid_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaLiquid_put_Copyright_Proxy( 
    IDXTMetaLiquid __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaLiquid_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaLiquid_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaCenterPeel_INTERFACE_DEFINED__
#define __IDXTMetaCenterPeel_INTERFACE_DEFINED__

/* interface IDXTMetaCenterPeel */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaCenterPeel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D0B-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaCenterPeel : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaCenterPeelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaCenterPeel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaCenterPeel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaCenterPeelVtbl;

    interface IDXTMetaCenterPeel
    {
        CONST_VTBL struct IDXTMetaCenterPeelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaCenterPeel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaCenterPeel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaCenterPeel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaCenterPeel_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaCenterPeel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaCenterPeel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaCenterPeel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaCenterPeel_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaCenterPeel_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaCenterPeel_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaCenterPeel_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaCenterPeel_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaCenterPeel_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaCenterPeel_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaCenterPeel_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaCenterPeel_get_Copyright_Proxy( 
    IDXTMetaCenterPeel __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaCenterPeel_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaCenterPeel_put_Copyright_Proxy( 
    IDXTMetaCenterPeel __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaCenterPeel_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaCenterPeel_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPeelSmall_INTERFACE_DEFINED__
#define __IDXTMetaPeelSmall_INTERFACE_DEFINED__

/* interface IDXTMetaPeelSmall */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPeelSmall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D0D-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPeelSmall : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPeelSmallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaPeelSmall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaPeelSmall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPeelSmallVtbl;

    interface IDXTMetaPeelSmall
    {
        CONST_VTBL struct IDXTMetaPeelSmallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPeelSmall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPeelSmall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPeelSmall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPeelSmall_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPeelSmall_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPeelSmall_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPeelSmall_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPeelSmall_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPeelSmall_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPeelSmall_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPeelSmall_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPeelSmall_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPeelSmall_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPeelSmall_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPeelSmall_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSmall_get_Copyright_Proxy( 
    IDXTMetaPeelSmall __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaPeelSmall_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSmall_put_Copyright_Proxy( 
    IDXTMetaPeelSmall __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPeelSmall_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPeelSmall_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPeelPiece_INTERFACE_DEFINED__
#define __IDXTMetaPeelPiece_INTERFACE_DEFINED__

/* interface IDXTMetaPeelPiece */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPeelPiece;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D0F-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPeelPiece : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPeelPieceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaPeelPiece __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaPeelPiece __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPeelPieceVtbl;

    interface IDXTMetaPeelPiece
    {
        CONST_VTBL struct IDXTMetaPeelPieceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPeelPiece_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPeelPiece_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPeelPiece_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPeelPiece_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPeelPiece_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPeelPiece_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPeelPiece_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPeelPiece_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPeelPiece_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPeelPiece_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPeelPiece_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPeelPiece_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPeelPiece_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPeelPiece_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPeelPiece_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelPiece_get_Copyright_Proxy( 
    IDXTMetaPeelPiece __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaPeelPiece_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelPiece_put_Copyright_Proxy( 
    IDXTMetaPeelPiece __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPeelPiece_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPeelPiece_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPeelSplit_INTERFACE_DEFINED__
#define __IDXTMetaPeelSplit_INTERFACE_DEFINED__

/* interface IDXTMetaPeelSplit */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPeelSplit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D11-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPeelSplit : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPeelSplitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaPeelSplit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaPeelSplit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPeelSplitVtbl;

    interface IDXTMetaPeelSplit
    {
        CONST_VTBL struct IDXTMetaPeelSplitVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPeelSplit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPeelSplit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPeelSplit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPeelSplit_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPeelSplit_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPeelSplit_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPeelSplit_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPeelSplit_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPeelSplit_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPeelSplit_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPeelSplit_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPeelSplit_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPeelSplit_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPeelSplit_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPeelSplit_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSplit_get_Copyright_Proxy( 
    IDXTMetaPeelSplit __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaPeelSplit_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSplit_put_Copyright_Proxy( 
    IDXTMetaPeelSplit __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPeelSplit_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPeelSplit_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaWater_INTERFACE_DEFINED__
#define __IDXTMetaWater_INTERFACE_DEFINED__

/* interface IDXTMetaWater */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaWater;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045C4-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaWater : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaWaterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaWater __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaWater __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaWaterVtbl;

    interface IDXTMetaWater
    {
        CONST_VTBL struct IDXTMetaWaterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaWater_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaWater_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaWater_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaWater_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaWater_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaWater_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaWater_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaWater_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaWater_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaWater_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaWater_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaWater_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaWater_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaWater_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaWater_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaWater_get_Copyright_Proxy( 
    IDXTMetaWater __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaWater_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaWater_put_Copyright_Proxy( 
    IDXTMetaWater __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaWater_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaWater_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaLightWipe_INTERFACE_DEFINED__
#define __IDXTMetaLightWipe_INTERFACE_DEFINED__

/* interface IDXTMetaLightWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaLightWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045C7-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaLightWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaLightWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaLightWipe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaLightWipe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaLightWipeVtbl;

    interface IDXTMetaLightWipe
    {
        CONST_VTBL struct IDXTMetaLightWipeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaLightWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaLightWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaLightWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaLightWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaLightWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaLightWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaLightWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaLightWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaLightWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaLightWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaLightWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaLightWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaLightWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaLightWipe_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaLightWipe_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaLightWipe_get_Copyright_Proxy( 
    IDXTMetaLightWipe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaLightWipe_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaLightWipe_put_Copyright_Proxy( 
    IDXTMetaLightWipe __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaLightWipe_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaLightWipe_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaRadialScaleWipe_INTERFACE_DEFINED__
#define __IDXTMetaRadialScaleWipe_INTERFACE_DEFINED__

/* interface IDXTMetaRadialScaleWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaRadialScaleWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045C9-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaRadialScaleWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaRadialScaleWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaRadialScaleWipeVtbl;

    interface IDXTMetaRadialScaleWipe
    {
        CONST_VTBL struct IDXTMetaRadialScaleWipeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaRadialScaleWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaRadialScaleWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaRadialScaleWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaRadialScaleWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaRadialScaleWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaRadialScaleWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaRadialScaleWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaRadialScaleWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaRadialScaleWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaRadialScaleWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaRadialScaleWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaRadialScaleWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaRadialScaleWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaRadialScaleWipe_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaRadialScaleWipe_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaRadialScaleWipe_get_Copyright_Proxy( 
    IDXTMetaRadialScaleWipe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaRadialScaleWipe_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaRadialScaleWipe_put_Copyright_Proxy( 
    IDXTMetaRadialScaleWipe __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaRadialScaleWipe_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaRadialScaleWipe_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaWhiteOut_INTERFACE_DEFINED__
#define __IDXTMetaWhiteOut_INTERFACE_DEFINED__

/* interface IDXTMetaWhiteOut */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaWhiteOut;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045CB-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaWhiteOut : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaWhiteOutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaWhiteOut __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaWhiteOut __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaWhiteOutVtbl;

    interface IDXTMetaWhiteOut
    {
        CONST_VTBL struct IDXTMetaWhiteOutVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaWhiteOut_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaWhiteOut_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaWhiteOut_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaWhiteOut_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaWhiteOut_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaWhiteOut_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaWhiteOut_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaWhiteOut_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaWhiteOut_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaWhiteOut_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaWhiteOut_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaWhiteOut_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaWhiteOut_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaWhiteOut_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaWhiteOut_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaWhiteOut_get_Copyright_Proxy( 
    IDXTMetaWhiteOut __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaWhiteOut_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaWhiteOut_put_Copyright_Proxy( 
    IDXTMetaWhiteOut __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaWhiteOut_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaWhiteOut_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaTwister_INTERFACE_DEFINED__
#define __IDXTMetaTwister_INTERFACE_DEFINED__

/* interface IDXTMetaTwister */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaTwister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045CE-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaTwister : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaTwisterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaTwister __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaTwister __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaTwisterVtbl;

    interface IDXTMetaTwister
    {
        CONST_VTBL struct IDXTMetaTwisterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaTwister_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaTwister_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaTwister_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaTwister_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaTwister_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaTwister_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaTwister_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaTwister_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaTwister_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaTwister_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaTwister_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaTwister_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaTwister_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaTwister_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaTwister_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaTwister_get_Copyright_Proxy( 
    IDXTMetaTwister __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaTwister_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaTwister_put_Copyright_Proxy( 
    IDXTMetaTwister __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaTwister_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaTwister_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaBurnFilm_INTERFACE_DEFINED__
#define __IDXTMetaBurnFilm_INTERFACE_DEFINED__

/* interface IDXTMetaBurnFilm */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaBurnFilm;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045D0-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaBurnFilm : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaBurnFilmVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaBurnFilm __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaBurnFilm __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaBurnFilmVtbl;

    interface IDXTMetaBurnFilm
    {
        CONST_VTBL struct IDXTMetaBurnFilmVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaBurnFilm_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaBurnFilm_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaBurnFilm_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaBurnFilm_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaBurnFilm_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaBurnFilm_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaBurnFilm_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaBurnFilm_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaBurnFilm_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaBurnFilm_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaBurnFilm_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaBurnFilm_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaBurnFilm_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaBurnFilm_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaBurnFilm_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaBurnFilm_get_Copyright_Proxy( 
    IDXTMetaBurnFilm __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaBurnFilm_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaBurnFilm_put_Copyright_Proxy( 
    IDXTMetaBurnFilm __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaBurnFilm_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaBurnFilm_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaJaws_INTERFACE_DEFINED__
#define __IDXTMetaJaws_INTERFACE_DEFINED__

/* interface IDXTMetaJaws */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaJaws;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C903-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaJaws : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaJawsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaJaws __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaJaws __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaJawsVtbl;

    interface IDXTMetaJaws
    {
        CONST_VTBL struct IDXTMetaJawsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaJaws_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaJaws_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaJaws_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaJaws_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaJaws_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaJaws_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaJaws_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaJaws_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaJaws_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaJaws_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaJaws_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaJaws_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaJaws_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaJaws_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaJaws_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaJaws_get_Copyright_Proxy( 
    IDXTMetaJaws __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaJaws_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaJaws_put_Copyright_Proxy( 
    IDXTMetaJaws __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaJaws_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaJaws_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaColorFade_INTERFACE_DEFINED__
#define __IDXTMetaColorFade_INTERFACE_DEFINED__

/* interface IDXTMetaColorFade */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaColorFade;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C907-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaColorFade : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaColorFadeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaColorFade __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaColorFade __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaColorFadeVtbl;

    interface IDXTMetaColorFade
    {
        CONST_VTBL struct IDXTMetaColorFadeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaColorFade_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaColorFade_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaColorFade_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaColorFade_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaColorFade_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaColorFade_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaColorFade_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaColorFade_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaColorFade_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaColorFade_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaColorFade_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaColorFade_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaColorFade_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaColorFade_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaColorFade_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaColorFade_get_Copyright_Proxy( 
    IDXTMetaColorFade __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaColorFade_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaColorFade_put_Copyright_Proxy( 
    IDXTMetaColorFade __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaColorFade_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaColorFade_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaFlowMotion_INTERFACE_DEFINED__
#define __IDXTMetaFlowMotion_INTERFACE_DEFINED__

/* interface IDXTMetaFlowMotion */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaFlowMotion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C90A-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaFlowMotion : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaFlowMotionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaFlowMotion __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaFlowMotion __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaFlowMotionVtbl;

    interface IDXTMetaFlowMotion
    {
        CONST_VTBL struct IDXTMetaFlowMotionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaFlowMotion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaFlowMotion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaFlowMotion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaFlowMotion_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaFlowMotion_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaFlowMotion_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaFlowMotion_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaFlowMotion_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaFlowMotion_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaFlowMotion_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaFlowMotion_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaFlowMotion_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaFlowMotion_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaFlowMotion_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaFlowMotion_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaFlowMotion_get_Copyright_Proxy( 
    IDXTMetaFlowMotion __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaFlowMotion_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaFlowMotion_put_Copyright_Proxy( 
    IDXTMetaFlowMotion __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaFlowMotion_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaFlowMotion_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaVacuum_INTERFACE_DEFINED__
#define __IDXTMetaVacuum_INTERFACE_DEFINED__

/* interface IDXTMetaVacuum */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaVacuum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C90C-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaVacuum : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaVacuumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaVacuum __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaVacuum __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaVacuumVtbl;

    interface IDXTMetaVacuum
    {
        CONST_VTBL struct IDXTMetaVacuumVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaVacuum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaVacuum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaVacuum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaVacuum_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaVacuum_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaVacuum_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaVacuum_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaVacuum_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaVacuum_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaVacuum_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaVacuum_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaVacuum_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaVacuum_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaVacuum_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaVacuum_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaVacuum_get_Copyright_Proxy( 
    IDXTMetaVacuum __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaVacuum_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaVacuum_put_Copyright_Proxy( 
    IDXTMetaVacuum __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaVacuum_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaVacuum_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaGriddler_INTERFACE_DEFINED__
#define __IDXTMetaGriddler_INTERFACE_DEFINED__

/* interface IDXTMetaGriddler */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaGriddler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C910-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaGriddler : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaGriddlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaGriddler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaGriddler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaGriddlerVtbl;

    interface IDXTMetaGriddler
    {
        CONST_VTBL struct IDXTMetaGriddlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaGriddler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaGriddler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaGriddler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaGriddler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaGriddler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaGriddler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaGriddler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaGriddler_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaGriddler_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaGriddler_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaGriddler_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaGriddler_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaGriddler_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaGriddler_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaGriddler_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler_get_Copyright_Proxy( 
    IDXTMetaGriddler __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaGriddler_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler_put_Copyright_Proxy( 
    IDXTMetaGriddler __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaGriddler_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaGriddler_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaGriddler2_INTERFACE_DEFINED__
#define __IDXTMetaGriddler2_INTERFACE_DEFINED__

/* interface IDXTMetaGriddler2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaGriddler2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C912-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaGriddler2 : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaGriddler2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaGriddler2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaGriddler2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaGriddler2Vtbl;

    interface IDXTMetaGriddler2
    {
        CONST_VTBL struct IDXTMetaGriddler2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaGriddler2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaGriddler2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaGriddler2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaGriddler2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaGriddler2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaGriddler2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaGriddler2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaGriddler2_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaGriddler2_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaGriddler2_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaGriddler2_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaGriddler2_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaGriddler2_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaGriddler2_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaGriddler2_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler2_get_Copyright_Proxy( 
    IDXTMetaGriddler2 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaGriddler2_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler2_put_Copyright_Proxy( 
    IDXTMetaGriddler2 __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaGriddler2_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaGriddler2_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaThreshold_INTERFACE_DEFINED__
#define __IDXTMetaThreshold_INTERFACE_DEFINED__

/* interface IDXTMetaThreshold */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaThreshold;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C914-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaThreshold : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaThresholdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaThreshold __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaThreshold __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaThresholdVtbl;

    interface IDXTMetaThreshold
    {
        CONST_VTBL struct IDXTMetaThresholdVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaThreshold_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaThreshold_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaThreshold_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaThreshold_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaThreshold_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaThreshold_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaThreshold_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaThreshold_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaThreshold_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaThreshold_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaThreshold_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaThreshold_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaThreshold_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaThreshold_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaThreshold_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaThreshold_get_Copyright_Proxy( 
    IDXTMetaThreshold __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaThreshold_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaThreshold_put_Copyright_Proxy( 
    IDXTMetaThreshold __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaThreshold_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaThreshold_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaWormHole_INTERFACE_DEFINED__
#define __IDXTMetaWormHole_INTERFACE_DEFINED__

/* interface IDXTMetaWormHole */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaWormHole;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E6AE021-0C83-11D2-8CD4-00104BC75D9A")
    IDXTMetaWormHole : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaWormHoleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaWormHole __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaWormHole __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaWormHoleVtbl;

    interface IDXTMetaWormHole
    {
        CONST_VTBL struct IDXTMetaWormHoleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaWormHole_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaWormHole_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaWormHole_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaWormHole_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaWormHole_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaWormHole_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaWormHole_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaWormHole_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaWormHole_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaWormHole_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaWormHole_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaWormHole_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaWormHole_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaWormHole_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaWormHole_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaWormHole_get_Copyright_Proxy( 
    IDXTMetaWormHole __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaWormHole_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaWormHole_put_Copyright_Proxy( 
    IDXTMetaWormHole __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaWormHole_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaWormHole_INTERFACE_DEFINED__ */



#ifndef __DXTMSFTLib_LIBRARY_DEFINED__
#define __DXTMSFTLib_LIBRARY_DEFINED__

/* library DXTMSFTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTMSFTLib;

EXTERN_C const CLSID CLSID_DXTComposite;

#ifdef __cplusplus

class DECLSPEC_UUID("9A43A844-0831-11D1-817F-0000F87557DB")
DXTComposite;
#endif

EXTERN_C const CLSID CLSID_DXLUTBuilder;

#ifdef __cplusplus

class DECLSPEC_UUID("1E54333B-2A00-11d1-8198-0000F87557DB")
DXLUTBuilder;
#endif

EXTERN_C const CLSID CLSID_DXTGradientD;

#ifdef __cplusplus

class DECLSPEC_UUID("623E2882-FC0E-11d1-9A77-0000F8756A10")
DXTGradientD;
#endif

EXTERN_C const CLSID CLSID_DXTWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("AF279B30-86EB-11D1-81BF-0000F87557DB")
DXTWipe;
#endif

EXTERN_C const CLSID CLSID_DXTConvolution;

#ifdef __cplusplus

class DECLSPEC_UUID("2BC0EF29-E6BA-11d1-81DD-0000F87557DB")
DXTConvolution;
#endif

EXTERN_C const CLSID CLSID_CrBlur;

#ifdef __cplusplus

class DECLSPEC_UUID("7312498D-E87A-11d1-81E0-0000F87557DB")
CrBlur;
#endif

EXTERN_C const CLSID CLSID_CrEmboss;

#ifdef __cplusplus

class DECLSPEC_UUID("F515306D-0156-11d2-81EA-0000F87557DB")
CrEmboss;
#endif

EXTERN_C const CLSID CLSID_CrEngrave;

#ifdef __cplusplus

class DECLSPEC_UUID("F515306E-0156-11d2-81EA-0000F87557DB")
CrEngrave;
#endif

EXTERN_C const CLSID CLSID_DXFade;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C5-EE70-11D1-9066-00C04FD9189D")
DXFade;
#endif

EXTERN_C const CLSID CLSID_FadePP;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C6-EE70-11D1-9066-00C04FD9189D")
FadePP;
#endif

EXTERN_C const CLSID CLSID_BasicImageEffects;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C8-EE70-11D1-9066-00C04FD9189D")
BasicImageEffects;
#endif

EXTERN_C const CLSID CLSID_BasicImageEffectsPP;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C9-EE70-11D1-9066-00C04FD9189D")
BasicImageEffectsPP;
#endif

EXTERN_C const CLSID CLSID_Pixelate;

#ifdef __cplusplus

class DECLSPEC_UUID("4CCEA634-FBE0-11d1-906A-00C04FD9189D")
Pixelate;
#endif

EXTERN_C const CLSID CLSID_PixelatePP;

#ifdef __cplusplus

class DECLSPEC_UUID("4CCEA635-FBE0-11d1-906A-00C04FD9189D")
PixelatePP;
#endif

EXTERN_C const CLSID CLSID_DXTWipePP;

#ifdef __cplusplus

class DECLSPEC_UUID("7FFE4D08-FBFD-11d1-9A77-0000F8756A10")
DXTWipePP;
#endif

EXTERN_C const CLSID CLSID_CrBlurPP;

#ifdef __cplusplus

class DECLSPEC_UUID("623E287E-FC0E-11d1-9A77-0000F8756A10")
CrBlurPP;
#endif

EXTERN_C const CLSID CLSID_GradientPP;

#ifdef __cplusplus

class DECLSPEC_UUID("623E2880-FC0E-11d1-9A77-0000F8756A10")
GradientPP;
#endif

EXTERN_C const CLSID CLSID_CompositePP;

#ifdef __cplusplus

class DECLSPEC_UUID("25B33660-FD83-11d1-8ADE-444553540001")
CompositePP;
#endif

EXTERN_C const CLSID CLSID_ConvolvePP;

#ifdef __cplusplus

class DECLSPEC_UUID("25B33661-FD83-11d1-8ADE-444553540001")
ConvolvePP;
#endif

EXTERN_C const CLSID CLSID_LUTBuilderPP;

#ifdef __cplusplus

class DECLSPEC_UUID("25B33662-FD83-11d1-8ADE-444553540001")
LUTBuilderPP;
#endif

EXTERN_C const CLSID CLSID_CrIris;

#ifdef __cplusplus

class DECLSPEC_UUID("3F69F351-0379-11D2-A484-00C04F8EFB69")
CrIris;
#endif

EXTERN_C const CLSID CLSID_CrIrisPP;

#ifdef __cplusplus

class DECLSPEC_UUID("80DE22C4-0F44-11d2-8B82-00A0C93C09B2")
CrIrisPP;
#endif

EXTERN_C const CLSID CLSID_CrSlide;

#ifdef __cplusplus

class DECLSPEC_UUID("810E402F-056B-11D2-A484-00C04F8EFB69")
CrSlide;
#endif

EXTERN_C const CLSID CLSID_CrSlidePP;

#ifdef __cplusplus

class DECLSPEC_UUID("CC8CEDE1-1003-11d2-8B82-00A0C93C09B2")
CrSlidePP;
#endif

EXTERN_C const CLSID CLSID_CrRadialWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("424B71AF-0695-11D2-A484-00C04F8EFB69")
CrRadialWipe;
#endif

EXTERN_C const CLSID CLSID_CrRadialWipePP;

#ifdef __cplusplus

class DECLSPEC_UUID("33D932E0-0F48-11d2-8B82-00A0C93C09B2")
CrRadialWipePP;
#endif

EXTERN_C const CLSID CLSID_CrBarn;

#ifdef __cplusplus

class DECLSPEC_UUID("C3BDF740-0B58-11d2-A484-00C04F8EFB69")
CrBarn;
#endif

EXTERN_C const CLSID CLSID_CrBlinds;

#ifdef __cplusplus

class DECLSPEC_UUID("00C429C0-0BA9-11d2-A484-00C04F8EFB69")
CrBlinds;
#endif

EXTERN_C const CLSID CLSID_CrBlindPP;

#ifdef __cplusplus

class DECLSPEC_UUID("213052C1-100D-11d2-8B82-00A0C93C09B2")
CrBlindPP;
#endif

EXTERN_C const CLSID CLSID_CrStretch;

#ifdef __cplusplus

class DECLSPEC_UUID("7658F2A2-0A83-11d2-A484-00C04F8EFB69")
CrStretch;
#endif

EXTERN_C const CLSID CLSID_CrStretchPP;

#ifdef __cplusplus

class DECLSPEC_UUID("15FB95E0-0F77-11d2-8B82-00A0C93C09B2")
CrStretchPP;
#endif

EXTERN_C const CLSID CLSID_CrInset;

#ifdef __cplusplus

class DECLSPEC_UUID("93073C40-0BA5-11d2-A484-00C04F8EFB69")
CrInset;
#endif

EXTERN_C const CLSID CLSID_CrSpiral;

#ifdef __cplusplus

class DECLSPEC_UUID("ACA97E00-0C7D-11d2-A484-00C04F8EFB69")
CrSpiral;
#endif

EXTERN_C const CLSID CLSID_CrSpiralPP;

#ifdef __cplusplus

class DECLSPEC_UUID("C6A4FE81-1022-11d2-8B82-00A0C93C09B2")
CrSpiralPP;
#endif

EXTERN_C const CLSID CLSID_CrZigzag;

#ifdef __cplusplus

class DECLSPEC_UUID("E6E73D20-0C8A-11d2-A484-00C04F8EFB69")
CrZigzag;
#endif

EXTERN_C const CLSID CLSID_CrZigzagPP;

#ifdef __cplusplus

class DECLSPEC_UUID("1559A3C1-102B-11d2-8B82-00A0C93C09B2")
CrZigzagPP;
#endif

EXTERN_C const CLSID CLSID_CrWheel;

#ifdef __cplusplus

class DECLSPEC_UUID("5AE1DAE0-1461-11d2-A484-00C04F8EFB69")
CrWheel;
#endif

EXTERN_C const CLSID CLSID_CrWheelPP;

#ifdef __cplusplus

class DECLSPEC_UUID("FA9F6180-1464-11d2-A484-00C04F8EFB69")
CrWheelPP;
#endif

EXTERN_C const CLSID CLSID_DXTChroma;

#ifdef __cplusplus

class DECLSPEC_UUID("421516C1-3CF8-11D2-952A-00C04FA34F05")
DXTChroma;
#endif

EXTERN_C const CLSID CLSID_DXTChromaPP;

#ifdef __cplusplus

class DECLSPEC_UUID("EC7E0760-4C76-11D2-8ADE-00A0C98E6527")
DXTChromaPP;
#endif

EXTERN_C const CLSID CLSID_DXTDropShadow;

#ifdef __cplusplus

class DECLSPEC_UUID("ADC6CB86-424C-11D2-952A-00C04FA34F05")
DXTDropShadow;
#endif

EXTERN_C const CLSID CLSID_DXTDropShadowPP;

#ifdef __cplusplus

class DECLSPEC_UUID("EC7E0761-4C76-11D2-8ADE-00A0C98E6527")
DXTDropShadowPP;
#endif

EXTERN_C const CLSID CLSID_DXTMetaRoll;

#ifdef __cplusplus

class DECLSPEC_UUID("9C61F46E-0530-11D2-8F98-00C04FB92EB7")
DXTMetaRoll;
#endif

EXTERN_C const CLSID CLSID_DXTMetaRipple;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D03-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaRipple;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPageTurn;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D08-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPageTurn;
#endif

EXTERN_C const CLSID CLSID_DXTMetaLiquid;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D0A-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaLiquid;
#endif

EXTERN_C const CLSID CLSID_DXTMetaCenterPeel;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D0C-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaCenterPeel;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPeelSmall;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D0E-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPeelSmall;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPeelPiece;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D10-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPeelPiece;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPeelSplit;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D12-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPeelSplit;
#endif

EXTERN_C const CLSID CLSID_DXTMetaWater;

#ifdef __cplusplus

class DECLSPEC_UUID("107045C5-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaWater;
#endif

EXTERN_C const CLSID CLSID_DXTMetaLightWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("107045C8-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaLightWipe;
#endif

EXTERN_C const CLSID CLSID_DXTMetaRadialScaleWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("107045CA-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaRadialScaleWipe;
#endif

EXTERN_C const CLSID CLSID_DXTMetaWhiteOut;

#ifdef __cplusplus

class DECLSPEC_UUID("107045CC-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaWhiteOut;
#endif

EXTERN_C const CLSID CLSID_DXTMetaTwister;

#ifdef __cplusplus

class DECLSPEC_UUID("107045CF-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaTwister;
#endif

EXTERN_C const CLSID CLSID_DXTMetaBurnFilm;

#ifdef __cplusplus

class DECLSPEC_UUID("107045D1-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaBurnFilm;
#endif

EXTERN_C const CLSID CLSID_DXTMetaJaws;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C904-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaJaws;
#endif

EXTERN_C const CLSID CLSID_DXTMetaColorFade;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C908-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaColorFade;
#endif

EXTERN_C const CLSID CLSID_DXTMetaFlowMotion;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C90B-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaFlowMotion;
#endif

EXTERN_C const CLSID CLSID_DXTMetaVacuum;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C90D-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaVacuum;
#endif

EXTERN_C const CLSID CLSID_DXTMetaGriddler;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C911-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaGriddler;
#endif

EXTERN_C const CLSID CLSID_DXTMetaGriddler2;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C913-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaGriddler2;
#endif

EXTERN_C const CLSID CLSID_DXTMetaThreshold;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C915-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaThreshold;
#endif

EXTERN_C const CLSID CLSID_DXTMetaWormHole;

#ifdef __cplusplus

class DECLSPEC_UUID("0E6AE022-0C83-11D2-8CD4-00104BC75D9A")
DXTMetaWormHole;
#endif
#endif /* __DXTMSFTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\extinc\dxtmsft3guid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft3.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IExplode,0x141DBAF0,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(IID, IID_ICrShatter,0x63500AE1,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTBlackHole,0xC3853C21,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTRoll,0x78F30B81,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTSpin,0x3D2807C1,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRipple,0x6DA4A05E,0x8E9E,0x11D1,0x90,0x4E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IHeightField,0x0492170A,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaStream,0x48654BC0,0xE51F,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(IID, IID_IDXTText3D,0x50C4B592,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(IID, IID_IDXTShapes,0x8241F013,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFT3Lib,0xE4BBA4C0,0x69B7,0x11d2,0x83,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_Explode,0x141DBAF1,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(CLSID, CLSID_ExplodeProp,0xC53059E1,0xE6E3,0x11d1,0xBA,0x12,0x00,0xC0,0x4F,0xB6,0xBD,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_Ripple,0x945F5842,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_RipProp,0x945F5843,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_HeightField,0x04921709,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_HtFieldProp,0x7A8402E3,0xFBD6,0x11D1,0xB5,0xE0,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStream,0x60A0C080,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStreamProp,0xE3D77340,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3D,0xD56F34F2,0x7E89,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3DPP,0x50C4B593,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatter,0x63500AE2,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatterPP,0x99275F01,0x102E,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHole,0xC3853C22,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHolePP,0xC3853C23,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRoll,0x78F30B82,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRollPP,0x78F30B83,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpin,0x3D2807C2,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpinPP,0x3D2807C3,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapes,0x8241F015,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapesPP,0x8241F016,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft3.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IExplode,0x141DBAF0,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(IID, IID_ICrShatter,0x63500AE1,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTBlackHole,0xC3853C21,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTRoll,0x78F30B81,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTSpin,0x3D2807C1,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRipple,0x6DA4A05E,0x8E9E,0x11D1,0x90,0x4E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IHeightField,0x0492170A,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaStream,0x48654BC0,0xE51F,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(IID, IID_IDXTText3D,0x50C4B592,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(IID, IID_IDXTShapes,0x8241F013,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFT3Lib,0xE4BBA4C0,0x69B7,0x11d2,0x83,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_Explode,0x141DBAF1,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(CLSID, CLSID_ExplodeProp,0xC53059E1,0xE6E3,0x11d1,0xBA,0x12,0x00,0xC0,0x4F,0xB6,0xBD,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_Ripple,0x945F5842,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_RipProp,0x945F5843,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_HeightField,0x04921709,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_HtFieldProp,0x7A8402E3,0xFBD6,0x11D1,0xB5,0xE0,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStream,0x60A0C080,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStreamProp,0xE3D77340,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3D,0xD56F34F2,0x7E89,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3DPP,0x50C4B593,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatter,0x63500AE2,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatterPP,0x99275F01,0x102E,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHole,0xC3853C22,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHolePP,0xC3853C23,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRoll,0x78F30B82,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRollPP,0x78F30B83,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpin,0x3D2807C2,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpinPP,0x3D2807C3,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapes,0x8241F015,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapesPP,0x8241F016,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\extinc\dxtrans.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtrans_h__
#define __dxtrans_h__

/* Forward Declarations */ 

#ifndef __IDXBaseObject_FWD_DEFINED__
#define __IDXBaseObject_FWD_DEFINED__
typedef interface IDXBaseObject IDXBaseObject;
#endif 	/* __IDXBaseObject_FWD_DEFINED__ */


#ifndef __IDXTransformFactory_FWD_DEFINED__
#define __IDXTransformFactory_FWD_DEFINED__
typedef interface IDXTransformFactory IDXTransformFactory;
#endif 	/* __IDXTransformFactory_FWD_DEFINED__ */


#ifndef __IDXTransform_FWD_DEFINED__
#define __IDXTransform_FWD_DEFINED__
typedef interface IDXTransform IDXTransform;
#endif 	/* __IDXTransform_FWD_DEFINED__ */


#ifndef __IDXSurfacePick_FWD_DEFINED__
#define __IDXSurfacePick_FWD_DEFINED__
typedef interface IDXSurfacePick IDXSurfacePick;
#endif 	/* __IDXSurfacePick_FWD_DEFINED__ */


#ifndef __IDXTBindHost_FWD_DEFINED__
#define __IDXTBindHost_FWD_DEFINED__
typedef interface IDXTBindHost IDXTBindHost;
#endif 	/* __IDXTBindHost_FWD_DEFINED__ */


#ifndef __IDXTaskManager_FWD_DEFINED__
#define __IDXTaskManager_FWD_DEFINED__
typedef interface IDXTaskManager IDXTaskManager;
#endif 	/* __IDXTaskManager_FWD_DEFINED__ */


#ifndef __IDXSurfaceFactory_FWD_DEFINED__
#define __IDXSurfaceFactory_FWD_DEFINED__
typedef interface IDXSurfaceFactory IDXSurfaceFactory;
#endif 	/* __IDXSurfaceFactory_FWD_DEFINED__ */


#ifndef __IDXSurfaceModifier_FWD_DEFINED__
#define __IDXSurfaceModifier_FWD_DEFINED__
typedef interface IDXSurfaceModifier IDXSurfaceModifier;
#endif 	/* __IDXSurfaceModifier_FWD_DEFINED__ */


#ifndef __IDXSurface_FWD_DEFINED__
#define __IDXSurface_FWD_DEFINED__
typedef interface IDXSurface IDXSurface;
#endif 	/* __IDXSurface_FWD_DEFINED__ */


#ifndef __IDXSurfaceInit_FWD_DEFINED__
#define __IDXSurfaceInit_FWD_DEFINED__
typedef interface IDXSurfaceInit IDXSurfaceInit;
#endif 	/* __IDXSurfaceInit_FWD_DEFINED__ */


#ifndef __IDXARGBSurfaceInit_FWD_DEFINED__
#define __IDXARGBSurfaceInit_FWD_DEFINED__
typedef interface IDXARGBSurfaceInit IDXARGBSurfaceInit;
#endif 	/* __IDXARGBSurfaceInit_FWD_DEFINED__ */


#ifndef __IDXARGBReadPtr_FWD_DEFINED__
#define __IDXARGBReadPtr_FWD_DEFINED__
typedef interface IDXARGBReadPtr IDXARGBReadPtr;
#endif 	/* __IDXARGBReadPtr_FWD_DEFINED__ */


#ifndef __IDXARGBReadWritePtr_FWD_DEFINED__
#define __IDXARGBReadWritePtr_FWD_DEFINED__
typedef interface IDXARGBReadWritePtr IDXARGBReadWritePtr;
#endif 	/* __IDXARGBReadWritePtr_FWD_DEFINED__ */


#ifndef __IDXDCLock_FWD_DEFINED__
#define __IDXDCLock_FWD_DEFINED__
typedef interface IDXDCLock IDXDCLock;
#endif 	/* __IDXDCLock_FWD_DEFINED__ */


#ifndef __IDXTScaleOutput_FWD_DEFINED__
#define __IDXTScaleOutput_FWD_DEFINED__
typedef interface IDXTScaleOutput IDXTScaleOutput;
#endif 	/* __IDXTScaleOutput_FWD_DEFINED__ */


#ifndef __IDXGradient_FWD_DEFINED__
#define __IDXGradient_FWD_DEFINED__
typedef interface IDXGradient IDXGradient;
#endif 	/* __IDXGradient_FWD_DEFINED__ */


#ifndef __IDXGradient2_FWD_DEFINED__
#define __IDXGradient2_FWD_DEFINED__
typedef interface IDXGradient2 IDXGradient2;
#endif 	/* __IDXGradient2_FWD_DEFINED__ */


#ifndef __IDXTScale_FWD_DEFINED__
#define __IDXTScale_FWD_DEFINED__
typedef interface IDXTScale IDXTScale;
#endif 	/* __IDXTScale_FWD_DEFINED__ */


#ifndef __IDXTLabel_FWD_DEFINED__
#define __IDXTLabel_FWD_DEFINED__
typedef interface IDXTLabel IDXTLabel;
#endif 	/* __IDXTLabel_FWD_DEFINED__ */


#ifndef __IDXRasterizer_FWD_DEFINED__
#define __IDXRasterizer_FWD_DEFINED__
typedef interface IDXRasterizer IDXRasterizer;
#endif 	/* __IDXRasterizer_FWD_DEFINED__ */


#ifndef __IDXEffect_FWD_DEFINED__
#define __IDXEffect_FWD_DEFINED__
typedef interface IDXEffect IDXEffect;
#endif 	/* __IDXEffect_FWD_DEFINED__ */


#ifndef __IDXLookupTable_FWD_DEFINED__
#define __IDXLookupTable_FWD_DEFINED__
typedef interface IDXLookupTable IDXLookupTable;
#endif 	/* __IDXLookupTable_FWD_DEFINED__ */


#ifndef __IDX2DDebug_FWD_DEFINED__
#define __IDX2DDebug_FWD_DEFINED__
typedef interface IDX2DDebug IDX2DDebug;
#endif 	/* __IDX2DDebug_FWD_DEFINED__ */


#ifndef __IDX2D_FWD_DEFINED__
#define __IDX2D_FWD_DEFINED__
typedef interface IDX2D IDX2D;
#endif 	/* __IDX2D_FWD_DEFINED__ */


#ifndef __IDXRawSurface_FWD_DEFINED__
#define __IDXRawSurface_FWD_DEFINED__
typedef interface IDXRawSurface IDXRawSurface;
#endif 	/* __IDXRawSurface_FWD_DEFINED__ */


#ifndef __DXTransformFactory_FWD_DEFINED__
#define __DXTransformFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTransformFactory DXTransformFactory;
#else
typedef struct DXTransformFactory DXTransformFactory;
#endif /* __cplusplus */

#endif 	/* __DXTransformFactory_FWD_DEFINED__ */


#ifndef __DXTaskManager_FWD_DEFINED__
#define __DXTaskManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTaskManager DXTaskManager;
#else
typedef struct DXTaskManager DXTaskManager;
#endif /* __cplusplus */

#endif 	/* __DXTaskManager_FWD_DEFINED__ */


#ifndef __DXTScale_FWD_DEFINED__
#define __DXTScale_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTScale DXTScale;
#else
typedef struct DXTScale DXTScale;
#endif /* __cplusplus */

#endif 	/* __DXTScale_FWD_DEFINED__ */


#ifndef __DXTLabel_FWD_DEFINED__
#define __DXTLabel_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTLabel DXTLabel;
#else
typedef struct DXTLabel DXTLabel;
#endif /* __cplusplus */

#endif 	/* __DXTLabel_FWD_DEFINED__ */


#ifndef __DX2D_FWD_DEFINED__
#define __DX2D_FWD_DEFINED__

#ifdef __cplusplus
typedef class DX2D DX2D;
#else
typedef struct DX2D DX2D;
#endif /* __cplusplus */

#endif 	/* __DX2D_FWD_DEFINED__ */


#ifndef __DXSurface_FWD_DEFINED__
#define __DXSurface_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXSurface DXSurface;
#else
typedef struct DXSurface DXSurface;
#endif /* __cplusplus */

#endif 	/* __DXSurface_FWD_DEFINED__ */


#ifndef __DXSurfaceModifier_FWD_DEFINED__
#define __DXSurfaceModifier_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXSurfaceModifier DXSurfaceModifier;
#else
typedef struct DXSurfaceModifier DXSurfaceModifier;
#endif /* __cplusplus */

#endif 	/* __DXSurfaceModifier_FWD_DEFINED__ */


#ifndef __DXRasterizer_FWD_DEFINED__
#define __DXRasterizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXRasterizer DXRasterizer;
#else
typedef struct DXRasterizer DXRasterizer;
#endif /* __cplusplus */

#endif 	/* __DXRasterizer_FWD_DEFINED__ */


#ifndef __DXGradient_FWD_DEFINED__
#define __DXGradient_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXGradient DXGradient;
#else
typedef struct DXGradient DXGradient;
#endif /* __cplusplus */

#endif 	/* __DXGradient_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "comcat.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxtrans_0000 */
/* [local] */ 

#include <servprov.h>
#include <ddraw.h>
#include <d3d.h>
#include <d3drm.h>
#include <urlmon.h>
#if 0
// Bogus definition used to make MIDL compiler happy
typedef void DDSURFACEDESC;

typedef void D3DRMBOX;

typedef void D3DVECTOR;

typedef void D3DRMMATRIX4D;

typedef void __RPC_FAR *LPSECURITY_ATTRIBUTES;

#endif
#ifdef _DXTRANSIMPL
    #define _DXTRANS_IMPL_EXT _declspec(dllexport)
#else
    #define _DXTRANS_IMPL_EXT _declspec(dllimport)
#endif


















//
//   All GUIDs for DXTransforms are declared in DXTGUID.CPP in the SDK include directory
//
EXTERN_C const GUID DDPF_RGB1;
EXTERN_C const GUID DDPF_RGB2;
EXTERN_C const GUID DDPF_RGB4;
EXTERN_C const GUID DDPF_RGB8;
EXTERN_C const GUID DDPF_RGB332;
EXTERN_C const GUID DDPF_ARGB4444;
EXTERN_C const GUID DDPF_RGB565;
EXTERN_C const GUID DDPF_BGR565;
EXTERN_C const GUID DDPF_RGB555;
EXTERN_C const GUID DDPF_ARGB1555;
EXTERN_C const GUID DDPF_RGB24;
EXTERN_C const GUID DDPF_BGR24;
EXTERN_C const GUID DDPF_RGB32;
EXTERN_C const GUID DDPF_BGR32;
EXTERN_C const GUID DDPF_ABGR32;
EXTERN_C const GUID DDPF_ARGB32;
EXTERN_C const GUID DDPF_PMARGB32;
EXTERN_C const GUID DDPF_A1;
EXTERN_C const GUID DDPF_A2;
EXTERN_C const GUID DDPF_A4;
EXTERN_C const GUID DDPF_A8;
EXTERN_C const GUID DDPF_Z8;
EXTERN_C const GUID DDPF_Z16;
EXTERN_C const GUID DDPF_Z24;
EXTERN_C const GUID DDPF_Z32;
//
//   Component categories
//
EXTERN_C const GUID CATID_DXImageTransform;
EXTERN_C const GUID CATID_DX3DTransform;
EXTERN_C const GUID CATID_DXAuthoringTransform;
EXTERN_C const GUID CATID_DXSurface;
//
//   Service IDs
//
EXTERN_C const GUID SID_SDirectDraw;
EXTERN_C const GUID SID_SDirect3DRM;
#define SID_SDXTaskManager CLSID_DXTaskManager
#define SID_SDXSurfaceFactory IID_IDXSurfaceFactory


extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0000_v0_0_s_ifspec;

#ifndef __IDXBaseObject_INTERFACE_DEFINED__
#define __IDXBaseObject_INTERFACE_DEFINED__

/* interface IDXBaseObject */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXBaseObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17B59B2B-9CC8-11d1-9053-00C04FD9189D")
    IDXBaseObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGenerationId( 
            /* [out] */ ULONG __RPC_FAR *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IncrementGenerationId( 
            /* [in] */ BOOL bRefresh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectSize( 
            /* [out] */ ULONG __RPC_FAR *pcbSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXBaseObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXBaseObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXBaseObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXBaseObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXBaseObject __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXBaseObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        END_INTERFACE
    } IDXBaseObjectVtbl;

    interface IDXBaseObject
    {
        CONST_VTBL struct IDXBaseObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXBaseObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXBaseObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXBaseObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXBaseObject_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXBaseObject_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXBaseObject_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXBaseObject_GetGenerationId_Proxy( 
    IDXBaseObject __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pID);


void __RPC_STUB IDXBaseObject_GetGenerationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXBaseObject_IncrementGenerationId_Proxy( 
    IDXBaseObject __RPC_FAR * This,
    /* [in] */ BOOL bRefresh);


void __RPC_STUB IDXBaseObject_IncrementGenerationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXBaseObject_GetObjectSize_Proxy( 
    IDXBaseObject __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcbSize);


void __RPC_STUB IDXBaseObject_GetObjectSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXBaseObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0252 */
/* [local] */ 

typedef 
enum DXFILTERTYPE
    {	DXFILTER_NEAREST	= 0,
	DXFILTER_BILINEAR	= DXFILTER_NEAREST + 1,
	DXFILTER_CUBIC	= DXFILTER_BILINEAR + 1,
	DXFILTER_BSPLINE	= DXFILTER_CUBIC + 1,
	DXFILTER_NUM_FILTERS	= DXFILTER_BSPLINE + 1
    }	DXFILTERTYPE;

typedef 
enum DX2DXFORMOPS
    {	DX2DXO_IDENTITY	= 0,
	DX2DXO_TRANSLATE	= DX2DXO_IDENTITY + 1,
	DX2DXO_SCALE	= DX2DXO_TRANSLATE + 1,
	DX2DXO_SCALE_AND_TRANS	= DX2DXO_SCALE + 1,
	DX2DXO_GENERAL	= DX2DXO_SCALE_AND_TRANS + 1,
	DX2DXO_GENERAL_AND_TRANS	= DX2DXO_GENERAL + 1
    }	DX2DXFORMOPS;

typedef struct DX2DXFORM
    {
    FLOAT eM11;
    FLOAT eM12;
    FLOAT eM21;
    FLOAT eM22;
    FLOAT eDx;
    FLOAT eDy;
    DX2DXFORMOPS eOp;
    }	DX2DXFORM;

typedef struct DX2DXFORM __RPC_FAR *PDX2DXFORM;

typedef 
enum DXBNDID
    {	DXB_X	= 0,
	DXB_Y	= 1,
	DXB_Z	= 2,
	DXB_T	= 3
    }	DXBNDID;

typedef 
enum DXBNDTYPE
    {	DXBT_DISCRETE	= 0,
	DXBT_DISCRETE64	= DXBT_DISCRETE + 1,
	DXBT_CONTINUOUS	= DXBT_DISCRETE64 + 1,
	DXBT_CONTINUOUS64	= DXBT_CONTINUOUS + 1
    }	DXBNDTYPE;

typedef struct DXDBND
    {
    long Min;
    long Max;
    }	DXDBND;

typedef DXDBND __RPC_FAR DXDBNDS[ 4 ];

typedef struct DXDBND64
    {
    LONGLONG Min;
    LONGLONG Max;
    }	DXDBND64;

typedef DXDBND64 __RPC_FAR DXDBNDS64[ 4 ];

typedef struct DXCBND
    {
    float Min;
    float Max;
    }	DXCBND;

typedef DXCBND __RPC_FAR DXCBNDS[ 4 ];

typedef struct DXCBND64
    {
    double Min;
    double Max;
    }	DXCBND64;

typedef DXCBND64 __RPC_FAR DXCBNDS64[ 4 ];

typedef struct DXBNDS
    {
    DXBNDTYPE eType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_dxtrans_0252_0001
        {
        /* [case()] */ DXDBND D[ 4 ];
        /* [case()] */ DXDBND64 LD[ 4 ];
        /* [case()] */ DXCBND C[ 4 ];
        /* [case()] */ DXCBND64 LC[ 4 ];
        }	u;
    }	DXBNDS;

typedef long __RPC_FAR DXDVEC[ 4 ];

typedef LONGLONG __RPC_FAR DXDVEC64[ 4 ];

typedef float __RPC_FAR DXCVEC[ 4 ];

typedef double __RPC_FAR DXCVEC64[ 4 ];

typedef struct DXVEC
    {
    DXBNDTYPE eType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_dxtrans_0252_0002
        {
        /* [case()] */ long D[ 4 ];
        /* [case()] */ LONGLONG LD[ 4 ];
        /* [case()] */ float C[ 4 ];
        /* [case()] */ double LC[ 4 ];
        }	u;
    }	DXVEC;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0252_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0252_v0_0_s_ifspec;

#ifndef __IDXTransformFactory_INTERFACE_DEFINED__
#define __IDXTransformFactory_INTERFACE_DEFINED__

/* interface IDXTransformFactory */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTransformFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6A950B2B-A971-11d1-81C8-0000F87557DB")
    IDXTransformFactory : public IServiceProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown __RPC_FAR *pUnkService,
            /* [in] */ BOOL bWeakReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTransform( 
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog,
            /* [in] */ REFCLSID TransCLSID,
            /* [in] */ REFIID TransIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTransform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeTransform( 
            /* [in] */ IDXTransform __RPC_FAR *pTransform,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTransformFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTransformFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTransformFactory __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryService )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetService )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown __RPC_FAR *pUnkService,
            /* [in] */ BOOL bWeakReference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateTransform )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog,
            /* [in] */ REFCLSID TransCLSID,
            /* [in] */ REFIID TransIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTransform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeTransform )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ IDXTransform __RPC_FAR *pTransform,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog);
        
        END_INTERFACE
    } IDXTransformFactoryVtbl;

    interface IDXTransformFactory
    {
        CONST_VTBL struct IDXTransformFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTransformFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTransformFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTransformFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTransformFactory_QueryService(This,guidService,riid,ppvObject)	\
    (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject)


#define IDXTransformFactory_SetService(This,guidService,pUnkService,bWeakReference)	\
    (This)->lpVtbl -> SetService(This,guidService,pUnkService,bWeakReference)

#define IDXTransformFactory_CreateTransform(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog,TransCLSID,TransIID,ppTransform)	\
    (This)->lpVtbl -> CreateTransform(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog,TransCLSID,TransIID,ppTransform)

#define IDXTransformFactory_InitializeTransform(This,pTransform,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog)	\
    (This)->lpVtbl -> InitializeTransform(This,pTransform,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTransformFactory_SetService_Proxy( 
    IDXTransformFactory __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ IUnknown __RPC_FAR *pUnkService,
    /* [in] */ BOOL bWeakReference);


void __RPC_STUB IDXTransformFactory_SetService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransformFactory_CreateTransform_Proxy( 
    IDXTransformFactory __RPC_FAR * This,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
    /* [in] */ IErrorLog __RPC_FAR *pErrLog,
    /* [in] */ REFCLSID TransCLSID,
    /* [in] */ REFIID TransIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTransform);


void __RPC_STUB IDXTransformFactory_CreateTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransformFactory_InitializeTransform_Proxy( 
    IDXTransformFactory __RPC_FAR * This,
    /* [in] */ IDXTransform __RPC_FAR *pTransform,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
    /* [in] */ IErrorLog __RPC_FAR *pErrLog);


void __RPC_STUB IDXTransformFactory_InitializeTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTransformFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0253 */
/* [local] */ 

typedef 
enum DXTMISCFLAGS
    {	DXTMF_BLEND_WITH_OUTPUT	= 1L << 0,
	DXTMF_DITHER_OUTPUT	= 1L << 1,
	DXTMF_OPTION_MASK	= 0xffff,
	DXTMF_VALID_OPTIONS	= DXTMF_BLEND_WITH_OUTPUT | DXTMF_DITHER_OUTPUT,
	DXTMF_BLEND_SUPPORTED	= 1L << 16,
	DXTMF_DITHER_SUPPORTED	= 1L << 17,
	DXTMF_INPLACE_OPERATION	= 1L << 24,
	DXTMF_BOUNDS_SUPPORTED	= 1L << 25,
	DXTMF_PLACEMENT_SUPPORTED	= 1L << 26,
	DXTMF_QUALITY_SUPPORTED	= 1L << 27,
	DXTMF_OPAQUE_RESULT	= 1L << 28
    }	DXTMISCFLAGS;

typedef 
enum DXINOUTINFOFLAGS
    {	DXINOUTF_OPTIONAL	= 1L << 0
    }	DXINOUTINFOFLAGS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0253_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0253_v0_0_s_ifspec;

#ifndef __IDXTransform_INTERFACE_DEFINED__
#define __IDXTransform_INTERFACE_DEFINED__

/* interface IDXTransform */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30A5FB78-E11F-11d1-9064-00C04FD9189D")
    IDXTransform : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Setup( 
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ const GUID __RPC_FAR *pRequestID,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsIn2Out( 
            /* [in] */ const DXBNDS __RPC_FAR *pInBounds,
            /* [in] */ ULONG ulNumInBnds,
            /* [in] */ ULONG ulOutIndex,
            /* [out] */ DXBNDS __RPC_FAR *pOutBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsOut2In( 
            /* [in] */ ULONG ulOutIndex,
            /* [in] */ const DXBNDS __RPC_FAR *pOutBounds,
            /* [in] */ ULONG ulInIndex,
            /* [out] */ DXBNDS __RPC_FAR *pInBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMiscFlags( 
            /* [in] */ DWORD dwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMiscFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInOutInfo( 
            /* [in] */ BOOL bIsOutput,
            /* [in] */ ULONG ulIndex,
            /* [out] */ DWORD __RPC_FAR *pdwFlags,
            /* [size_is][out] */ GUID __RPC_FAR *pIDs,
            /* [out][in] */ ULONG __RPC_FAR *pcIDs,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkCurrentObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQuality( 
            /* [in] */ float fQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuality( 
            /* [out] */ float __RPC_FAR *fQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTransform __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTransform __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Setup )( 
            IDXTransform __RPC_FAR * This,
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ const GUID __RPC_FAR *pRequestID,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBoundsIn2Out )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pInBounds,
            /* [in] */ ULONG ulNumInBnds,
            /* [in] */ ULONG ulOutIndex,
            /* [out] */ DXBNDS __RPC_FAR *pOutBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBoundsOut2In )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ ULONG ulOutIndex,
            /* [in] */ const DXBNDS __RPC_FAR *pOutBounds,
            /* [in] */ ULONG ulInIndex,
            /* [out] */ DXBNDS __RPC_FAR *pInBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMiscFlags )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ DWORD dwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMiscFlags )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInOutInfo )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ BOOL bIsOutput,
            /* [in] */ ULONG ulIndex,
            /* [out] */ DWORD __RPC_FAR *pdwFlags,
            /* [size_is][out] */ GUID __RPC_FAR *pIDs,
            /* [out][in] */ ULONG __RPC_FAR *pcIDs,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkCurrentObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetQuality )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ float fQuality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuality )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *fQuality);
        
        END_INTERFACE
    } IDXTransformVtbl;

    interface IDXTransform
    {
        CONST_VTBL struct IDXTransformVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTransform_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTransform_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTransform_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTransform_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXTransform_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXTransform_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXTransform_Setup(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,dwFlags)	\
    (This)->lpVtbl -> Setup(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,dwFlags)

#define IDXTransform_Execute(This,pRequestID,pClipBnds,pPlacement)	\
    (This)->lpVtbl -> Execute(This,pRequestID,pClipBnds,pPlacement)

#define IDXTransform_MapBoundsIn2Out(This,pInBounds,ulNumInBnds,ulOutIndex,pOutBounds)	\
    (This)->lpVtbl -> MapBoundsIn2Out(This,pInBounds,ulNumInBnds,ulOutIndex,pOutBounds)

#define IDXTransform_MapBoundsOut2In(This,ulOutIndex,pOutBounds,ulInIndex,pInBounds)	\
    (This)->lpVtbl -> MapBoundsOut2In(This,ulOutIndex,pOutBounds,ulInIndex,pInBounds)

#define IDXTransform_SetMiscFlags(This,dwMiscFlags)	\
    (This)->lpVtbl -> SetMiscFlags(This,dwMiscFlags)

#define IDXTransform_GetMiscFlags(This,pdwMiscFlags)	\
    (This)->lpVtbl -> GetMiscFlags(This,pdwMiscFlags)

#define IDXTransform_GetInOutInfo(This,bIsOutput,ulIndex,pdwFlags,pIDs,pcIDs,ppUnkCurrentObject)	\
    (This)->lpVtbl -> GetInOutInfo(This,bIsOutput,ulIndex,pdwFlags,pIDs,pcIDs,ppUnkCurrentObject)

#define IDXTransform_SetQuality(This,fQuality)	\
    (This)->lpVtbl -> SetQuality(This,fQuality)

#define IDXTransform_GetQuality(This,fQuality)	\
    (This)->lpVtbl -> GetQuality(This,fQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTransform_Setup_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTransform_Setup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_Execute_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ const GUID __RPC_FAR *pRequestID,
    /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
    /* [in] */ const DXVEC __RPC_FAR *pPlacement);


void __RPC_STUB IDXTransform_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_MapBoundsIn2Out_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pInBounds,
    /* [in] */ ULONG ulNumInBnds,
    /* [in] */ ULONG ulOutIndex,
    /* [out] */ DXBNDS __RPC_FAR *pOutBounds);


void __RPC_STUB IDXTransform_MapBoundsIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_MapBoundsOut2In_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ ULONG ulOutIndex,
    /* [in] */ const DXBNDS __RPC_FAR *pOutBounds,
    /* [in] */ ULONG ulInIndex,
    /* [out] */ DXBNDS __RPC_FAR *pInBounds);


void __RPC_STUB IDXTransform_MapBoundsOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_SetMiscFlags_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ DWORD dwMiscFlags);


void __RPC_STUB IDXTransform_SetMiscFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetMiscFlags_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMiscFlags);


void __RPC_STUB IDXTransform_GetMiscFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetInOutInfo_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ BOOL bIsOutput,
    /* [in] */ ULONG ulIndex,
    /* [out] */ DWORD __RPC_FAR *pdwFlags,
    /* [size_is][out] */ GUID __RPC_FAR *pIDs,
    /* [out][in] */ ULONG __RPC_FAR *pcIDs,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkCurrentObject);


void __RPC_STUB IDXTransform_GetInOutInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_SetQuality_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ float fQuality);


void __RPC_STUB IDXTransform_SetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetQuality_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *fQuality);


void __RPC_STUB IDXTransform_GetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTransform_INTERFACE_DEFINED__ */


#ifndef __IDXSurfacePick_INTERFACE_DEFINED__
#define __IDXSurfacePick_INTERFACE_DEFINED__

/* interface IDXSurfacePick */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfacePick;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30A5FB79-E11F-11d1-9064-00C04FD9189D")
    IDXSurfacePick : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PointPick( 
            /* [in] */ const DXVEC __RPC_FAR *pPoint,
            /* [out] */ ULONG __RPC_FAR *pulInputSurfaceIndex,
            /* [out] */ DXVEC __RPC_FAR *pInputPoint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfacePickVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfacePick __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfacePick __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfacePick __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PointPick )( 
            IDXSurfacePick __RPC_FAR * This,
            /* [in] */ const DXVEC __RPC_FAR *pPoint,
            /* [out] */ ULONG __RPC_FAR *pulInputSurfaceIndex,
            /* [out] */ DXVEC __RPC_FAR *pInputPoint);
        
        END_INTERFACE
    } IDXSurfacePickVtbl;

    interface IDXSurfacePick
    {
        CONST_VTBL struct IDXSurfacePickVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfacePick_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfacePick_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfacePick_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfacePick_PointPick(This,pPoint,pulInputSurfaceIndex,pInputPoint)	\
    (This)->lpVtbl -> PointPick(This,pPoint,pulInputSurfaceIndex,pInputPoint)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfacePick_PointPick_Proxy( 
    IDXSurfacePick __RPC_FAR * This,
    /* [in] */ const DXVEC __RPC_FAR *pPoint,
    /* [out] */ ULONG __RPC_FAR *pulInputSurfaceIndex,
    /* [out] */ DXVEC __RPC_FAR *pInputPoint);


void __RPC_STUB IDXSurfacePick_PointPick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfacePick_INTERFACE_DEFINED__ */


#ifndef __IDXTBindHost_INTERFACE_DEFINED__
#define __IDXTBindHost_INTERFACE_DEFINED__

/* interface IDXTBindHost */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTBindHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D26BCE55-E9DC-11d1-9066-00C04FD9189D")
    IDXTBindHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBindHost( 
            /* [in] */ IBindHost __RPC_FAR *pBindHost) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTBindHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTBindHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTBindHost __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTBindHost __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBindHost )( 
            IDXTBindHost __RPC_FAR * This,
            /* [in] */ IBindHost __RPC_FAR *pBindHost);
        
        END_INTERFACE
    } IDXTBindHostVtbl;

    interface IDXTBindHost
    {
        CONST_VTBL struct IDXTBindHostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTBindHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTBindHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTBindHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTBindHost_SetBindHost(This,pBindHost)	\
    (This)->lpVtbl -> SetBindHost(This,pBindHost)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTBindHost_SetBindHost_Proxy( 
    IDXTBindHost __RPC_FAR * This,
    /* [in] */ IBindHost __RPC_FAR *pBindHost);


void __RPC_STUB IDXTBindHost_SetBindHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTBindHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0256 */
/* [local] */ 

typedef void __stdcall __stdcall DXTASKPROC( 
    void __RPC_FAR *pTaskData,
    BOOL __RPC_FAR *pbContinueProcessing);

typedef DXTASKPROC __RPC_FAR *PFNDXTASKPROC;

typedef void __stdcall __stdcall DXAPCPROC( 
    DWORD dwData);

typedef DXAPCPROC __RPC_FAR *PFNDXAPCPROC;

#ifdef __cplusplus
typedef struct DXTMTASKINFO
{
    PFNDXTASKPROC pfnTaskProc;       // Pointer to function to execute
    PVOID         pTaskData;         // Pointer to argument data
    PFNDXAPCPROC  pfnCompletionAPC;  // Pointer to completion APC proc
    DWORD         dwCompletionData;  // Pointer to APC proc data
    const GUID*   pRequestID;        // Used to identify groups of tasks
} DXTMTASKINFO;
#else
typedef struct DXTMTASKINFO
    {
    PVOID pfnTaskProc;
    PVOID pTaskData;
    PVOID pfnCompletionAPC;
    DWORD dwCompletionData;
    const GUID __RPC_FAR *pRequestID;
    }	DXTMTASKINFO;

#endif


extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0256_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0256_v0_0_s_ifspec;

#ifndef __IDXTaskManager_INTERFACE_DEFINED__
#define __IDXTaskManager_INTERFACE_DEFINED__

/* interface IDXTaskManager */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IDXTaskManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("254DBBC1-F922-11d0-883A-3C8B00C10000")
    IDXTaskManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryNumProcessors( 
            /* [out] */ ULONG __RPC_FAR *pulNumProc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadPoolSize( 
            /* [in] */ ULONG ulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadPoolSize( 
            /* [out] */ ULONG __RPC_FAR *pulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConcurrencyLimit( 
            /* [in] */ ULONG ulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConcurrencyLimit( 
            /* [out] */ ULONG __RPC_FAR *pulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScheduleTasks( 
            /* [in] */ DXTMTASKINFO __RPC_FAR TaskInfo[  ],
            /* [in] */ HANDLE __RPC_FAR Events[  ],
            /* [out] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulNumTasks,
            /* [in] */ ULONG ulWaitPeriod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateTasks( 
            /* [in] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulCount,
            /* [in] */ ULONG ulTimeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateRequest( 
            /* [in] */ REFIID RequestID,
            /* [in] */ ULONG ulTimeOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTaskManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTaskManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTaskManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryNumProcessors )( 
            IDXTaskManager __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumProc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetThreadPoolSize )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ ULONG ulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreadPoolSize )( 
            IDXTaskManager __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConcurrencyLimit )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ ULONG ulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConcurrencyLimit )( 
            IDXTaskManager __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScheduleTasks )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ DXTMTASKINFO __RPC_FAR TaskInfo[  ],
            /* [in] */ HANDLE __RPC_FAR Events[  ],
            /* [out] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulNumTasks,
            /* [in] */ ULONG ulWaitPeriod);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TerminateTasks )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulCount,
            /* [in] */ ULONG ulTimeOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TerminateRequest )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ REFIID RequestID,
            /* [in] */ ULONG ulTimeOut);
        
        END_INTERFACE
    } IDXTaskManagerVtbl;

    interface IDXTaskManager
    {
        CONST_VTBL struct IDXTaskManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTaskManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTaskManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTaskManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTaskManager_QueryNumProcessors(This,pulNumProc)	\
    (This)->lpVtbl -> QueryNumProcessors(This,pulNumProc)

#define IDXTaskManager_SetThreadPoolSize(This,ulNumThreads)	\
    (This)->lpVtbl -> SetThreadPoolSize(This,ulNumThreads)

#define IDXTaskManager_GetThreadPoolSize(This,pulNumThreads)	\
    (This)->lpVtbl -> GetThreadPoolSize(This,pulNumThreads)

#define IDXTaskManager_SetConcurrencyLimit(This,ulNumThreads)	\
    (This)->lpVtbl -> SetConcurrencyLimit(This,ulNumThreads)

#define IDXTaskManager_GetConcurrencyLimit(This,pulNumThreads)	\
    (This)->lpVtbl -> GetConcurrencyLimit(This,pulNumThreads)

#define IDXTaskManager_ScheduleTasks(This,TaskInfo,Events,TaskIDs,ulNumTasks,ulWaitPeriod)	\
    (This)->lpVtbl -> ScheduleTasks(This,TaskInfo,Events,TaskIDs,ulNumTasks,ulWaitPeriod)

#define IDXTaskManager_TerminateTasks(This,TaskIDs,ulCount,ulTimeOut)	\
    (This)->lpVtbl -> TerminateTasks(This,TaskIDs,ulCount,ulTimeOut)

#define IDXTaskManager_TerminateRequest(This,RequestID,ulTimeOut)	\
    (This)->lpVtbl -> TerminateRequest(This,RequestID,ulTimeOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTaskManager_QueryNumProcessors_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumProc);


void __RPC_STUB IDXTaskManager_QueryNumProcessors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_SetThreadPoolSize_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ ULONG ulNumThreads);


void __RPC_STUB IDXTaskManager_SetThreadPoolSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_GetThreadPoolSize_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumThreads);


void __RPC_STUB IDXTaskManager_GetThreadPoolSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_SetConcurrencyLimit_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ ULONG ulNumThreads);


void __RPC_STUB IDXTaskManager_SetConcurrencyLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_GetConcurrencyLimit_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumThreads);


void __RPC_STUB IDXTaskManager_GetConcurrencyLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_ScheduleTasks_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ DXTMTASKINFO __RPC_FAR TaskInfo[  ],
    /* [in] */ HANDLE __RPC_FAR Events[  ],
    /* [out] */ DWORD __RPC_FAR TaskIDs[  ],
    /* [in] */ ULONG ulNumTasks,
    /* [in] */ ULONG ulWaitPeriod);


void __RPC_STUB IDXTaskManager_ScheduleTasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_TerminateTasks_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ DWORD __RPC_FAR TaskIDs[  ],
    /* [in] */ ULONG ulCount,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXTaskManager_TerminateTasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_TerminateRequest_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ REFIID RequestID,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXTaskManager_TerminateRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTaskManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0257 */
/* [local] */ 

#ifdef __cplusplus
/////////////////////////////////////////////////////

class DXBASESAMPLE;
class DXSAMPLE;
class DXPMSAMPLE;

/////////////////////////////////////////////////////

class DXBASESAMPLE
{
public:
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    DXBASESAMPLE() {}
    DXBASESAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
        Alpha(alpha),
        Red(red),
        Green(green),
        Blue(blue) {}
    DXBASESAMPLE(const DWORD val) { *this = (*(DXBASESAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXBASESAMPLE *)&val); }
}; // DXBASESAMPLE

/////////////////////////////////////////////////////

class DXSAMPLE : public DXBASESAMPLE
{
public:
    DXSAMPLE() {}
    DXSAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
         DXBASESAMPLE(alpha, red, green, blue) {}
    DXSAMPLE(const DWORD val) { *this = (*(DXSAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXSAMPLE *)&val); }
    operator DXPMSAMPLE() const;
}; // DXSAMPLE

/////////////////////////////////////////////////////

class DXPMSAMPLE : public DXBASESAMPLE
{
public:
    DXPMSAMPLE() {}
    DXPMSAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
         DXBASESAMPLE(alpha, red, green, blue) {}
    DXPMSAMPLE(const DWORD val) { *this = (*(DXPMSAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXPMSAMPLE *)&val); }
    operator DXSAMPLE() const;
}; // DXPMSAMPLE

//
// The following cast operators are to prevent a direct assignment of a DXSAMPLE to a DXPMSAMPLE
//
inline DXSAMPLE::operator DXPMSAMPLE() const { return *((DXPMSAMPLE *)this); }
inline DXPMSAMPLE::operator DXSAMPLE() const { return *((DXSAMPLE *)this); }
#else // !__cplusplus
typedef struct DXBASESAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    }	DXBASESAMPLE;

typedef struct DXSAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    }	DXSAMPLE;

typedef struct DXPMSAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    }	DXPMSAMPLE;

#endif // !__cplusplus
typedef 
enum DXRUNTYPE
    {	DXRUNTYPE_CLEAR	= 0,
	DXRUNTYPE_OPAQUE	= 1,
	DXRUNTYPE_TRANS	= 2,
	DXRUNTYPE_UNKNOWN	= 3
    }	DXRUNTYPE;

#define	DX_MAX_RUN_INFO_COUNT	( 128 )

// Ignore the definition used by MIDL for TLB generation
#if 0
typedef struct DXRUNINFO
    {
    ULONG Bitfields;
    }	DXRUNINFO;

#endif // 0
typedef struct DXRUNINFO
{
    ULONG   Type  : 2;   // Type
    ULONG   Count : 30;  // Number of samples in run
} DXRUNINFO;
typedef 
enum DXSFCREATE
    {	DXSF_FORMAT_IS_CLSID	= 1L << 0,
	DXSF_NO_LAZY_DDRAW_LOCK	= 1L << 1
    }	DXSFCREATE;

typedef 
enum DXBLTOPTIONS
    {	DXBOF_DO_OVER	= 1L << 0,
	DXBOF_DITHER	= 1L << 1
    }	DXBLTOPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0257_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0257_v0_0_s_ifspec;

#ifndef __IDXSurfaceFactory_INTERFACE_DEFINED__
#define __IDXSurfaceFactory_INTERFACE_DEFINED__

/* interface IDXSurfaceFactory */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfaceFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("144946F5-C4D4-11d1-81D1-0000F87557DB")
    IDXSurfaceFactory : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFromDDSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE LoadImage( 
            /* [in] */ const LPWSTR pszFileName,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE LoadImageFromStream( 
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopySurfaceToNewFormat( 
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pDestFormatID,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppNewSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateD3DRMTexture( 
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ IUnknown __RPC_FAR *pD3DRM3,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTexture3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BitBlt( 
            /* [in] */ IDXSurface __RPC_FAR *pDest,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfaceFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfaceFactory __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSurface )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateFromDDSurface )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadImage )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ const LPWSTR pszFileName,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadImageFromStream )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopySurfaceToNewFormat )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pDestFormatID,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppNewSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateD3DRMTexture )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ IUnknown __RPC_FAR *pD3DRM3,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTexture3);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BitBlt )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pDest,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXSurfaceFactoryVtbl;

    interface IDXSurfaceFactory
    {
        CONST_VTBL struct IDXSurfaceFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceFactory_CreateSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags,punkOuter,riid,ppDXSurface)	\
    (This)->lpVtbl -> CreateSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags,punkOuter,riid,ppDXSurface)

#define IDXSurfaceFactory_CreateFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags,punkOuter,riid,ppDXSurface)	\
    (This)->lpVtbl -> CreateFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags,punkOuter,riid,ppDXSurface)

#define IDXSurfaceFactory_LoadImage(This,pszFileName,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)	\
    (This)->lpVtbl -> LoadImage(This,pszFileName,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)

#define IDXSurfaceFactory_LoadImageFromStream(This,pStream,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)	\
    (This)->lpVtbl -> LoadImageFromStream(This,pStream,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)

#define IDXSurfaceFactory_CopySurfaceToNewFormat(This,pSrc,pDirectDraw,pDDSurfaceDesc,pDestFormatID,ppNewSurface)	\
    (This)->lpVtbl -> CopySurfaceToNewFormat(This,pSrc,pDirectDraw,pDDSurfaceDesc,pDestFormatID,ppNewSurface)

#define IDXSurfaceFactory_CreateD3DRMTexture(This,pSrc,pDirectDraw,pD3DRM3,riid,ppTexture3)	\
    (This)->lpVtbl -> CreateD3DRMTexture(This,pSrc,pDirectDraw,pD3DRM3,riid,ppTexture3)

#define IDXSurfaceFactory_BitBlt(This,pDest,pPlacement,pSrc,pClipBounds,dwFlags)	\
    (This)->lpVtbl -> BitBlt(This,pDest,pPlacement,pSrc,pClipBounds,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateSurface_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_CreateSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateFromDDSurface_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_CreateFromDDSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_LoadImage_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ const LPWSTR pszFileName,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_LoadImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_LoadImageFromStream_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_LoadImageFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CopySurfaceToNewFormat_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSrc,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pDestFormatID,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppNewSurface);


void __RPC_STUB IDXSurfaceFactory_CopySurfaceToNewFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateD3DRMTexture_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSrc,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ IUnknown __RPC_FAR *pD3DRM3,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTexture3);


void __RPC_STUB IDXSurfaceFactory_CreateD3DRMTexture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_BitBlt_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pDest,
    /* [in] */ const DXVEC __RPC_FAR *pPlacement,
    /* [in] */ IDXSurface __RPC_FAR *pSrc,
    /* [in] */ const DXBNDS __RPC_FAR *pClipBounds,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXSurfaceFactory_BitBlt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0258 */
/* [local] */ 

typedef 
enum DXSURFMODCOMPOP
    {	DXSURFMOD_COMP_OVER	= 0,
	DXSURFMOD_COMP_ALPHA_MASK	= 1,
	DXSURFMOD_COMP_MAX_VALID	= 1
    }	DXSURFMODCOMPOP;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0258_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0258_v0_0_s_ifspec;

#ifndef __IDXSurfaceModifier_INTERFACE_DEFINED__
#define __IDXSurfaceModifier_INTERFACE_DEFINED__

/* interface IDXSurfaceModifier */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfaceModifier;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B637-C37D-11d1-905E-00C04FD9189D")
    IDXSurfaceModifier : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFillColor( 
            /* [in] */ DXSAMPLE Color) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillColor( 
            /* [out] */ DXSAMPLE __RPC_FAR *pColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBounds( 
            /* [in] */ const DXBNDS __RPC_FAR *pBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackground( 
            /* [in] */ IDXSurface __RPC_FAR *pSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackground( 
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositeOperation( 
            /* [in] */ DXSURFMODCOMPOP CompOp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositeOperation( 
            /* [out] */ DXSURFMODCOMPOP __RPC_FAR *pCompOp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForeground( 
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ BOOL bTile,
            /* [in] */ const POINT __RPC_FAR *pOrigin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForeground( 
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ BOOL __RPC_FAR *pbTile,
            /* [out] */ POINT __RPC_FAR *pOrigin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacity( 
            /* [in] */ float Opacity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacity( 
            /* [out] */ float __RPC_FAR *pOpacity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLookup( 
            /* [in] */ IDXLookupTable __RPC_FAR *pLookupTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLookup( 
            /* [out] */ IDXLookupTable __RPC_FAR *__RPC_FAR *ppLookupTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceModifierVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfaceModifier __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfaceModifier __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFillColor )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ DXSAMPLE Color);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFillColor )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ DXSAMPLE __RPC_FAR *pColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBounds )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositeOperation )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ DXSURFMODCOMPOP CompOp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositeOperation )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ DXSURFMODCOMPOP __RPC_FAR *pCompOp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForeground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ BOOL bTile,
            /* [in] */ const POINT __RPC_FAR *pOrigin);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForeground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ BOOL __RPC_FAR *pbTile,
            /* [out] */ POINT __RPC_FAR *pOrigin);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpacity )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ float Opacity);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpacity )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pOpacity);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLookup )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ IDXLookupTable __RPC_FAR *pLookupTable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLookup )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ IDXLookupTable __RPC_FAR *__RPC_FAR *ppLookupTable);
        
        END_INTERFACE
    } IDXSurfaceModifierVtbl;

    interface IDXSurfaceModifier
    {
        CONST_VTBL struct IDXSurfaceModifierVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceModifier_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceModifier_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceModifier_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceModifier_SetFillColor(This,Color)	\
    (This)->lpVtbl -> SetFillColor(This,Color)

#define IDXSurfaceModifier_GetFillColor(This,pColor)	\
    (This)->lpVtbl -> GetFillColor(This,pColor)

#define IDXSurfaceModifier_SetBounds(This,pBounds)	\
    (This)->lpVtbl -> SetBounds(This,pBounds)

#define IDXSurfaceModifier_SetBackground(This,pSurface)	\
    (This)->lpVtbl -> SetBackground(This,pSurface)

#define IDXSurfaceModifier_GetBackground(This,ppSurface)	\
    (This)->lpVtbl -> GetBackground(This,ppSurface)

#define IDXSurfaceModifier_SetCompositeOperation(This,CompOp)	\
    (This)->lpVtbl -> SetCompositeOperation(This,CompOp)

#define IDXSurfaceModifier_GetCompositeOperation(This,pCompOp)	\
    (This)->lpVtbl -> GetCompositeOperation(This,pCompOp)

#define IDXSurfaceModifier_SetForeground(This,pSurface,bTile,pOrigin)	\
    (This)->lpVtbl -> SetForeground(This,pSurface,bTile,pOrigin)

#define IDXSurfaceModifier_GetForeground(This,ppSurface,pbTile,pOrigin)	\
    (This)->lpVtbl -> GetForeground(This,ppSurface,pbTile,pOrigin)

#define IDXSurfaceModifier_SetOpacity(This,Opacity)	\
    (This)->lpVtbl -> SetOpacity(This,Opacity)

#define IDXSurfaceModifier_GetOpacity(This,pOpacity)	\
    (This)->lpVtbl -> GetOpacity(This,pOpacity)

#define IDXSurfaceModifier_SetLookup(This,pLookupTable)	\
    (This)->lpVtbl -> SetLookup(This,pLookupTable)

#define IDXSurfaceModifier_GetLookup(This,ppLookupTable)	\
    (This)->lpVtbl -> GetLookup(This,ppLookupTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetFillColor_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ DXSAMPLE Color);


void __RPC_STUB IDXSurfaceModifier_SetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetFillColor_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ DXSAMPLE __RPC_FAR *pColor);


void __RPC_STUB IDXSurfaceModifier_GetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetBounds_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds);


void __RPC_STUB IDXSurfaceModifier_SetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetBackground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSurface);


void __RPC_STUB IDXSurfaceModifier_SetBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetBackground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDXSurfaceModifier_GetBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetCompositeOperation_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ DXSURFMODCOMPOP CompOp);


void __RPC_STUB IDXSurfaceModifier_SetCompositeOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetCompositeOperation_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ DXSURFMODCOMPOP __RPC_FAR *pCompOp);


void __RPC_STUB IDXSurfaceModifier_GetCompositeOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetForeground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSurface,
    /* [in] */ BOOL bTile,
    /* [in] */ const POINT __RPC_FAR *pOrigin);


void __RPC_STUB IDXSurfaceModifier_SetForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetForeground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
    /* [out] */ BOOL __RPC_FAR *pbTile,
    /* [out] */ POINT __RPC_FAR *pOrigin);


void __RPC_STUB IDXSurfaceModifier_GetForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetOpacity_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ float Opacity);


void __RPC_STUB IDXSurfaceModifier_SetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetOpacity_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pOpacity);


void __RPC_STUB IDXSurfaceModifier_GetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetLookup_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ IDXLookupTable __RPC_FAR *pLookupTable);


void __RPC_STUB IDXSurfaceModifier_SetLookup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetLookup_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ IDXLookupTable __RPC_FAR *__RPC_FAR *ppLookupTable);


void __RPC_STUB IDXSurfaceModifier_GetLookup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceModifier_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0259 */
/* [local] */ 

typedef 
enum DXSAMPLEFORMATENUM
    {	DXPF_FLAGSMASK	= 0xffff0000,
	DXPF_NONPREMULT	= 0x10000,
	DXPF_TRANSPARENCY	= 0x20000,
	DXPF_TRANSLUCENCY	= 0x40000,
	DXPF_2BITERROR	= 0x200000,
	DXPF_3BITERROR	= 0x300000,
	DXPF_4BITERROR	= 0x400000,
	DXPF_5BITERROR	= 0x500000,
	DXPF_ERRORMASK	= 0x700000,
	DXPF_NONSTANDARD	= 0,
	DXPF_PMARGB32	= 1 | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_ARGB32	= 2 | DXPF_NONPREMULT | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_ARGB4444	= 3 | DXPF_NONPREMULT | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY | DXPF_4BITERROR,
	DXPF_A8	= 4 | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_RGB32	= 5,
	DXPF_RGB24	= 6,
	DXPF_RGB565	= 7 | DXPF_3BITERROR,
	DXPF_RGB555	= 8 | DXPF_3BITERROR,
	DXPF_RGB8	= 9 | DXPF_5BITERROR,
	DXPF_ARGB1555	= 10 | DXPF_TRANSPARENCY | DXPF_3BITERROR,
	DXPF_RGB32_CK	= DXPF_RGB32 | DXPF_TRANSPARENCY,
	DXPF_RGB24_CK	= DXPF_RGB24 | DXPF_TRANSPARENCY,
	DXPF_RGB555_CK	= DXPF_RGB555 | DXPF_TRANSPARENCY,
	DXPF_RGB565_CK	= DXPF_RGB565 | DXPF_TRANSPARENCY,
	DXPF_RGB8_CK	= DXPF_RGB8 | DXPF_TRANSPARENCY
    }	DXSAMPLEFORMATENUM;

typedef 
enum DXLOCKSURF
    {	DXLOCKF_READ	= 0,
	DXLOCKF_READWRITE	= 1 << 0,
	DXLOCKF_EXISTINGINFOONLY	= 1 << 1,
	DXLOCKF_WANTRUNINFO	= 1 << 2,
	DXLOCKF_NONPREMULT	= 1 << 16,
	DXLOCKF_VALIDFLAGS	= DXLOCKF_READWRITE | DXLOCKF_EXISTINGINFOONLY | DXLOCKF_WANTRUNINFO | DXLOCKF_NONPREMULT
    }	DXLOCKSURF;

typedef 
enum DXSURFSTATUS
    {	DXSURF_TRANSIENT	= 1 << 0,
	DXSURF_READONLY	= 1 << 1,
	DXSURF_VALIDFLAGS	= DXSURF_TRANSIENT | DXSURF_READONLY
    }	DXSURFSTATUS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0259_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0259_v0_0_s_ifspec;

#ifndef __IDXSurface_INTERFACE_DEFINED__
#define __IDXSurface_INTERFACE_DEFINED__

/* interface IDXSurface */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B39FD73F-E139-11d1-9065-00C04FD9189D")
    IDXSurface : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPixelFormat( 
            /* [out] */ GUID __RPC_FAR *pFormatID,
            /* [out] */ DXSAMPLEFORMATENUM __RPC_FAR *pSampleFormatEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBounds( 
            /* [out] */ DXBNDS __RPC_FAR *pBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwStatusFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusFlags( 
            /* [in] */ DWORD dwStatusFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurface( 
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppPointer,
            /* [out] */ ULONG __RPC_FAR *pulGenerationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectDrawSurface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            DXSAMPLE __RPC_FAR *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            DXSAMPLE ColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurfaceDC( 
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDXDCLock __RPC_FAR *__RPC_FAR *ppDCLock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppData( 
            DWORD dwAppData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppData( 
            DWORD __RPC_FAR *pdwAppData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurface __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurface __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPixelFormat )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pFormatID,
            /* [out] */ DXSAMPLEFORMATENUM __RPC_FAR *pSampleFormatEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBounds )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ DXBNDS __RPC_FAR *pBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatusFlags )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatusFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusFlags )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ DWORD dwStatusFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockSurface )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppPointer,
            /* [out] */ ULONG __RPC_FAR *pulGenerationId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDirectDrawSurface )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColorKey )( 
            IDXSurface __RPC_FAR * This,
            DXSAMPLE __RPC_FAR *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColorKey )( 
            IDXSurface __RPC_FAR * This,
            DXSAMPLE ColorKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockSurfaceDC )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDXDCLock __RPC_FAR *__RPC_FAR *ppDCLock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAppData )( 
            IDXSurface __RPC_FAR * This,
            DWORD dwAppData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAppData )( 
            IDXSurface __RPC_FAR * This,
            DWORD __RPC_FAR *pdwAppData);
        
        END_INTERFACE
    } IDXSurfaceVtbl;

    interface IDXSurface
    {
        CONST_VTBL struct IDXSurfaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurface_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXSurface_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXSurface_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXSurface_GetPixelFormat(This,pFormatID,pSampleFormatEnum)	\
    (This)->lpVtbl -> GetPixelFormat(This,pFormatID,pSampleFormatEnum)

#define IDXSurface_GetBounds(This,pBounds)	\
    (This)->lpVtbl -> GetBounds(This,pBounds)

#define IDXSurface_GetStatusFlags(This,pdwStatusFlags)	\
    (This)->lpVtbl -> GetStatusFlags(This,pdwStatusFlags)

#define IDXSurface_SetStatusFlags(This,dwStatusFlags)	\
    (This)->lpVtbl -> SetStatusFlags(This,dwStatusFlags)

#define IDXSurface_LockSurface(This,pBounds,ulTimeOut,dwFlags,riid,ppPointer,pulGenerationId)	\
    (This)->lpVtbl -> LockSurface(This,pBounds,ulTimeOut,dwFlags,riid,ppPointer,pulGenerationId)

#define IDXSurface_GetDirectDrawSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetDirectDrawSurface(This,riid,ppSurface)

#define IDXSurface_GetColorKey(This,pColorKey)	\
    (This)->lpVtbl -> GetColorKey(This,pColorKey)

#define IDXSurface_SetColorKey(This,ColorKey)	\
    (This)->lpVtbl -> SetColorKey(This,ColorKey)

#define IDXSurface_LockSurfaceDC(This,pBounds,ulTimeOut,dwFlags,ppDCLock)	\
    (This)->lpVtbl -> LockSurfaceDC(This,pBounds,ulTimeOut,dwFlags,ppDCLock)

#define IDXSurface_SetAppData(This,dwAppData)	\
    (This)->lpVtbl -> SetAppData(This,dwAppData)

#define IDXSurface_GetAppData(This,pdwAppData)	\
    (This)->lpVtbl -> GetAppData(This,pdwAppData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurface_GetPixelFormat_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pFormatID,
    /* [out] */ DXSAMPLEFORMATENUM __RPC_FAR *pSampleFormatEnum);


void __RPC_STUB IDXSurface_GetPixelFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetBounds_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [out] */ DXBNDS __RPC_FAR *pBounds);


void __RPC_STUB IDXSurface_GetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetStatusFlags_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatusFlags);


void __RPC_STUB IDXSurface_GetStatusFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetStatusFlags_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ DWORD dwStatusFlags);


void __RPC_STUB IDXSurface_SetStatusFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_LockSurface_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ ULONG ulTimeOut,
    /* [in] */ DWORD dwFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppPointer,
    /* [out] */ ULONG __RPC_FAR *pulGenerationId);


void __RPC_STUB IDXSurface_LockSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetDirectDrawSurface_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDXSurface_GetDirectDrawSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetColorKey_Proxy( 
    IDXSurface __RPC_FAR * This,
    DXSAMPLE __RPC_FAR *pColorKey);


void __RPC_STUB IDXSurface_GetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetColorKey_Proxy( 
    IDXSurface __RPC_FAR * This,
    DXSAMPLE ColorKey);


void __RPC_STUB IDXSurface_SetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_LockSurfaceDC_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ ULONG ulTimeOut,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDXDCLock __RPC_FAR *__RPC_FAR *ppDCLock);


void __RPC_STUB IDXSurface_LockSurfaceDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetAppData_Proxy( 
    IDXSurface __RPC_FAR * This,
    DWORD dwAppData);


void __RPC_STUB IDXSurface_SetAppData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetAppData_Proxy( 
    IDXSurface __RPC_FAR * This,
    DWORD __RPC_FAR *pdwAppData);


void __RPC_STUB IDXSurface_GetAppData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurface_INTERFACE_DEFINED__ */


#ifndef __IDXSurfaceInit_INTERFACE_DEFINED__
#define __IDXSurfaceInit_INTERFACE_DEFINED__

/* interface IDXSurfaceInit */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfaceInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B639-C37D-11d1-905E-00C04FD9189D")
    IDXSurfaceInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfaceInit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfaceInit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfaceInit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitSurface )( 
            IDXSurfaceInit __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXSurfaceInitVtbl;

    interface IDXSurfaceInit
    {
        CONST_VTBL struct IDXSurfaceInitVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceInit_InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)	\
    (This)->lpVtbl -> InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfaceInit_InitSurface_Proxy( 
    IDXSurfaceInit __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXSurfaceInit_InitSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceInit_INTERFACE_DEFINED__ */


#ifndef __IDXARGBSurfaceInit_INTERFACE_DEFINED__
#define __IDXARGBSurfaceInit_INTERFACE_DEFINED__

/* interface IDXARGBSurfaceInit */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXARGBSurfaceInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B63A-C37D-11d1-905E-00C04FD9189D")
    IDXARGBSurfaceInit : public IDXSurfaceInit
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitFromDDSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitFromRawSurface( 
            /* [in] */ IDXRawSurface __RPC_FAR *pRawSurface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBSurfaceInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXARGBSurfaceInit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXARGBSurfaceInit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitSurface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitFromDDSurface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitFromRawSurface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ IDXRawSurface __RPC_FAR *pRawSurface);
        
        END_INTERFACE
    } IDXARGBSurfaceInitVtbl;

    interface IDXARGBSurfaceInit
    {
        CONST_VTBL struct IDXARGBSurfaceInitVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBSurfaceInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBSurfaceInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBSurfaceInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBSurfaceInit_InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)	\
    (This)->lpVtbl -> InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)


#define IDXARGBSurfaceInit_InitFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags)	\
    (This)->lpVtbl -> InitFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags)

#define IDXARGBSurfaceInit_InitFromRawSurface(This,pRawSurface)	\
    (This)->lpVtbl -> InitFromRawSurface(This,pRawSurface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXARGBSurfaceInit_InitFromDDSurface_Proxy( 
    IDXARGBSurfaceInit __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXARGBSurfaceInit_InitFromDDSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXARGBSurfaceInit_InitFromRawSurface_Proxy( 
    IDXARGBSurfaceInit __RPC_FAR * This,
    /* [in] */ IDXRawSurface __RPC_FAR *pRawSurface);


void __RPC_STUB IDXARGBSurfaceInit_InitFromRawSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBSurfaceInit_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0262 */
/* [local] */ 

typedef struct tagDXNATIVETYPEINFO
    {
    BYTE __RPC_FAR *pCurrentData;
    BYTE __RPC_FAR *pFirstByte;
    long lPitch;
    DWORD dwColorKey;
    }	DXNATIVETYPEINFO;

typedef struct tagDXPACKEDRECTDESC
    {
    DXBASESAMPLE __RPC_FAR *pSamples;
    BOOL bPremult;
    RECT rect;
    long lRowPadding;
    }	DXPACKEDRECTDESC;

typedef struct tagDXOVERSAMPLEDESC
    {
    POINT p;
    DXPMSAMPLE Color;
    }	DXOVERSAMPLEDESC;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0262_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0262_v0_0_s_ifspec;

#ifndef __IDXARGBReadPtr_INTERFACE_DEFINED__
#define __IDXARGBReadPtr_INTERFACE_DEFINED__

/* interface IDXARGBReadPtr */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXARGBReadPtr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAAAC2D6-C290-11d1-905D-00C04FD9189D")
    IDXARGBReadPtr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual DXSAMPLEFORMATENUM STDMETHODCALLTYPE GetNativeType( 
            /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo) = 0;
        
        virtual void STDMETHODCALLTYPE Move( 
            /* [in] */ long cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE MoveToRow( 
            /* [in] */ ULONG y) = 0;
        
        virtual void STDMETHODCALLTYPE MoveToXY( 
            /* [in] */ ULONG x,
            /* [in] */ ULONG y) = 0;
        
        virtual ULONG STDMETHODCALLTYPE MoveAndGetRunInfo( 
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo) = 0;
        
        virtual DXSAMPLE __RPC_FAR *STDMETHODCALLTYPE Unpack( 
            /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove) = 0;
        
        virtual DXPMSAMPLE __RPC_FAR *STDMETHODCALLTYPE UnpackPremult( 
            /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove) = 0;
        
        virtual void STDMETHODCALLTYPE UnpackRect( 
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBReadPtrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXARGBReadPtr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXARGBReadPtr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);
        
        DXSAMPLEFORMATENUM ( STDMETHODCALLTYPE __RPC_FAR *GetNativeType )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ long cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToRow )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ ULONG y);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToXY )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ ULONG x,
            /* [in] */ ULONG y);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *MoveAndGetRunInfo )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo);
        
        DXSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Unpack )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        DXPMSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *UnpackPremult )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *UnpackRect )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);
        
        END_INTERFACE
    } IDXARGBReadPtrVtbl;

    interface IDXARGBReadPtr
    {
        CONST_VTBL struct IDXARGBReadPtrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBReadPtr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBReadPtr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBReadPtr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBReadPtr_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDXARGBReadPtr_GetNativeType(This,pInfo)	\
    (This)->lpVtbl -> GetNativeType(This,pInfo)

#define IDXARGBReadPtr_Move(This,cSamples)	\
    (This)->lpVtbl -> Move(This,cSamples)

#define IDXARGBReadPtr_MoveToRow(This,y)	\
    (This)->lpVtbl -> MoveToRow(This,y)

#define IDXARGBReadPtr_MoveToXY(This,x,y)	\
    (This)->lpVtbl -> MoveToXY(This,x,y)

#define IDXARGBReadPtr_MoveAndGetRunInfo(This,Row,ppInfo)	\
    (This)->lpVtbl -> MoveAndGetRunInfo(This,Row,ppInfo)

#define IDXARGBReadPtr_Unpack(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> Unpack(This,pSamples,cSamples,bMove)

#define IDXARGBReadPtr_UnpackPremult(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> UnpackPremult(This,pSamples,cSamples,bMove)

#define IDXARGBReadPtr_UnpackRect(This,pRectDesc)	\
    (This)->lpVtbl -> UnpackRect(This,pRectDesc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXARGBReadPtr_GetSurface_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDXARGBReadPtr_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXSAMPLEFORMATENUM STDMETHODCALLTYPE IDXARGBReadPtr_GetNativeType_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo);


void __RPC_STUB IDXARGBReadPtr_GetNativeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_Move_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ long cSamples);


void __RPC_STUB IDXARGBReadPtr_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_MoveToRow_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ ULONG y);


void __RPC_STUB IDXARGBReadPtr_MoveToRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_MoveToXY_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ ULONG x,
    /* [in] */ ULONG y);


void __RPC_STUB IDXARGBReadPtr_MoveToXY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IDXARGBReadPtr_MoveAndGetRunInfo_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ ULONG Row,
    /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo);


void __RPC_STUB IDXARGBReadPtr_MoveAndGetRunInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXSAMPLE __RPC_FAR *STDMETHODCALLTYPE IDXARGBReadPtr_Unpack_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bMove);


void __RPC_STUB IDXARGBReadPtr_Unpack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXPMSAMPLE __RPC_FAR *STDMETHODCALLTYPE IDXARGBReadPtr_UnpackPremult_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bMove);


void __RPC_STUB IDXARGBReadPtr_UnpackPremult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_UnpackRect_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);


void __RPC_STUB IDXARGBReadPtr_UnpackRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBReadPtr_INTERFACE_DEFINED__ */


#ifndef __IDXARGBReadWritePtr_INTERFACE_DEFINED__
#define __IDXARGBReadWritePtr_INTERFACE_DEFINED__

/* interface IDXARGBReadWritePtr */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXARGBReadWritePtr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAAAC2D7-C290-11d1-905D-00C04FD9189D")
    IDXARGBReadWritePtr : public IDXARGBReadPtr
    {
    public:
        virtual void STDMETHODCALLTYPE PackAndMove( 
            /* [in] */ const DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE PackPremultAndMove( 
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE PackRect( 
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc) = 0;
        
        virtual void STDMETHODCALLTYPE CopyAndMoveBoth( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bIsOpaque) = 0;
        
        virtual void STDMETHODCALLTYPE CopyRect( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const RECT __RPC_FAR *pDestRect,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ const POINT __RPC_FAR *pSrcOrigin,
            /* [in] */ BOOL bIsOpaque) = 0;
        
        virtual void STDMETHODCALLTYPE FillAndMove( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bDoOver) = 0;
        
        virtual void STDMETHODCALLTYPE FillRect( 
            /* [in] */ const RECT __RPC_FAR *pRect,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ BOOL bDoOver) = 0;
        
        virtual void STDMETHODCALLTYPE OverSample( 
            /* [in] */ const DXOVERSAMPLEDESC __RPC_FAR *pOverDesc) = 0;
        
        virtual void STDMETHODCALLTYPE OverArrayAndMove( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBReadWritePtrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXARGBReadWritePtr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXARGBReadWritePtr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);
        
        DXSAMPLEFORMATENUM ( STDMETHODCALLTYPE __RPC_FAR *GetNativeType )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ long cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToRow )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ ULONG y);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToXY )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ ULONG x,
            /* [in] */ ULONG y);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *MoveAndGetRunInfo )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo);
        
        DXSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Unpack )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        DXPMSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *UnpackPremult )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *UnpackRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PackAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PackPremultAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PackRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *CopyAndMoveBoth )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bIsOpaque);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *CopyRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const RECT __RPC_FAR *pDestRect,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ const POINT __RPC_FAR *pSrcOrigin,
            /* [in] */ BOOL bIsOpaque);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *FillAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bDoOver);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *FillRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const RECT __RPC_FAR *pRect,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ BOOL bDoOver);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OverSample )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXOVERSAMPLEDESC __RPC_FAR *pOverDesc);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OverArrayAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples);
        
        END_INTERFACE
    } IDXARGBReadWritePtrVtbl;

    interface IDXARGBReadWritePtr
    {
        CONST_VTBL struct IDXARGBReadWritePtrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBReadWritePtr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBReadWritePtr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBReadWritePtr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBReadWritePtr_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDXARGBReadWritePtr_GetNativeType(This,pInfo)	\
    (This)->lpVtbl -> GetNativeType(This,pInfo)

#define IDXARGBReadWritePtr_Move(This,cSamples)	\
    (This)->lpVtbl -> Move(This,cSamples)

#define IDXARGBReadWritePtr_MoveToRow(This,y)	\
    (This)->lpVtbl -> MoveToRow(This,y)

#define IDXARGBReadWritePtr_MoveToXY(This,x,y)	\
    (This)->lpVtbl -> MoveToXY(This,x,y)

#define IDXARGBReadWritePtr_MoveAndGetRunInfo(This,Row,ppInfo)	\
    (This)->lpVtbl -> MoveAndGetRunInfo(This,Row,ppInfo)

#define IDXARGBReadWritePtr_Unpack(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> Unpack(This,pSamples,cSamples,bMove)

#define IDXARGBReadWritePtr_UnpackPremult(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> UnpackPremult(This,pSamples,cSamples,bMove)

#define IDXARGBReadWritePtr_UnpackRect(This,pRectDesc)	\
    (This)->lpVtbl -> UnpackRect(This,pRectDesc)


#define IDXARGBReadWritePtr_PackAndMove(This,pSamples,cSamples)	\
    (This)->lpVtbl -> PackAndMove(This,pSamples,cSamples)

#define IDXARGBReadWritePtr_PackPremultAndMove(This,pSamples,cSamples)	\
    (This)->lpVtbl -> PackPremultAndMove(This,pSamples,cSamples)

#define IDXARGBReadWritePtr_PackRect(This,pRectDesc)	\
    (This)->lpVtbl -> PackRect(This,pRectDesc)

#define IDXARGBReadWritePtr_CopyAndMoveBoth(This,pScratchBuffer,pSrc,cSamples,bIsOpaque)	\
    (This)->lpVtbl -> CopyAndMoveBoth(This,pScratchBuffer,pSrc,cSamples,bIsOpaque)

#define IDXARGBReadWritePtr_CopyRect(This,pScratchBuffer,pDestRect,pSrc,pSrcOrigin,bIsOpaque)	\
    (This)->lpVtbl -> CopyRect(This,pScratchBuffer,pDestRect,pSrc,pSrcOrigin,bIsOpaque)

#define IDXARGBReadWritePtr_FillAndMove(This,pScratchBuffer,SampVal,cSamples,bDoOver)	\
    (This)->lpVtbl -> FillAndMove(This,pScratchBuffer,SampVal,cSamples,bDoOver)

#define IDXARGBReadWritePtr_FillRect(This,pRect,SampVal,bDoOver)	\
    (This)->lpVtbl -> FillRect(This,pRect,SampVal,bDoOver)

#define IDXARGBReadWritePtr_OverSample(This,pOverDesc)	\
    (This)->lpVtbl -> OverSample(This,pOverDesc)

#define IDXARGBReadWritePtr_OverArrayAndMove(This,pScratchBuffer,pSrc,cSamples)	\
    (This)->lpVtbl -> OverArrayAndMove(This,pScratchBuffer,pSrc,cSamples)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_PackAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackPremultAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXPMSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_PackPremultAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackRect_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);


void __RPC_STUB IDXARGBReadWritePtr_PackRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_CopyAndMoveBoth_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bIsOpaque);


void __RPC_STUB IDXARGBReadWritePtr_CopyAndMoveBoth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_CopyRect_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ const RECT __RPC_FAR *pDestRect,
    /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
    /* [in] */ const POINT __RPC_FAR *pSrcOrigin,
    /* [in] */ BOOL bIsOpaque);


void __RPC_STUB IDXARGBReadWritePtr_CopyRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_FillAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ DXPMSAMPLE SampVal,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bDoOver);


void __RPC_STUB IDXARGBReadWritePtr_FillAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_FillRect_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const RECT __RPC_FAR *pRect,
    /* [in] */ DXPMSAMPLE SampVal,
    /* [in] */ BOOL bDoOver);


void __RPC_STUB IDXARGBReadWritePtr_FillRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_OverSample_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXOVERSAMPLEDESC __RPC_FAR *pOverDesc);


void __RPC_STUB IDXARGBReadWritePtr_OverSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_OverArrayAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ const DXPMSAMPLE __RPC_FAR *pSrc,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_OverArrayAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBReadWritePtr_INTERFACE_DEFINED__ */


#ifndef __IDXDCLock_INTERFACE_DEFINED__
#define __IDXDCLock_INTERFACE_DEFINED__

/* interface IDXDCLock */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXDCLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0F619456-CF39-11d1-905E-00C04FD9189D")
    IDXDCLock : public IUnknown
    {
    public:
        virtual HDC STDMETHODCALLTYPE GetDC( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXDCLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXDCLock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXDCLock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXDCLock __RPC_FAR * This);
        
        HDC ( STDMETHODCALLTYPE __RPC_FAR *GetDC )( 
            IDXDCLock __RPC_FAR * This);
        
        END_INTERFACE
    } IDXDCLockVtbl;

    interface IDXDCLock
    {
        CONST_VTBL struct IDXDCLockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXDCLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXDCLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXDCLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXDCLock_GetDC(This)	\
    (This)->lpVtbl -> GetDC(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HDC STDMETHODCALLTYPE IDXDCLock_GetDC_Proxy( 
    IDXDCLock __RPC_FAR * This);


void __RPC_STUB IDXDCLock_GetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXDCLock_INTERFACE_DEFINED__ */


#ifndef __IDXTScaleOutput_INTERFACE_DEFINED__
#define __IDXTScaleOutput_INTERFACE_DEFINED__

/* interface IDXTScaleOutput */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTScaleOutput;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2024B50-EE77-11d1-9066-00C04FD9189D")
    IDXTScaleOutput : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOutputSize( 
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTScaleOutputVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTScaleOutput __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTScaleOutput __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTScaleOutput __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXTScaleOutput __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        END_INTERFACE
    } IDXTScaleOutputVtbl;

    interface IDXTScaleOutput
    {
        CONST_VTBL struct IDXTScaleOutputVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTScaleOutput_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTScaleOutput_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTScaleOutput_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTScaleOutput_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTScaleOutput_SetOutputSize_Proxy( 
    IDXTScaleOutput __RPC_FAR * This,
    /* [in] */ const SIZE OutSize,
    /* [in] */ BOOL bMaintainAspect);


void __RPC_STUB IDXTScaleOutput_SetOutputSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTScaleOutput_INTERFACE_DEFINED__ */


#ifndef __IDXGradient_INTERFACE_DEFINED__
#define __IDXGradient_INTERFACE_DEFINED__

/* interface IDXGradient */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXGradient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2024B51-EE77-11d1-9066-00C04FD9189D")
    IDXGradient : public IDXTScaleOutput
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGradient( 
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSize( 
            /* [out] */ SIZE __RPC_FAR *pOutSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGradientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXGradient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXGradient __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXGradient __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXGradient __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGradient )( 
            IDXGradient __RPC_FAR * This,
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSize )( 
            IDXGradient __RPC_FAR * This,
            /* [out] */ SIZE __RPC_FAR *pOutSize);
        
        END_INTERFACE
    } IDXGradientVtbl;

    interface IDXGradient
    {
        CONST_VTBL struct IDXGradientVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGradient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXGradient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXGradient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXGradient_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXGradient_SetGradient(This,StartColor,EndColor,bHorizontal)	\
    (This)->lpVtbl -> SetGradient(This,StartColor,EndColor,bHorizontal)

#define IDXGradient_GetOutputSize(This,pOutSize)	\
    (This)->lpVtbl -> GetOutputSize(This,pOutSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXGradient_SetGradient_Proxy( 
    IDXGradient __RPC_FAR * This,
    DXSAMPLE StartColor,
    DXSAMPLE EndColor,
    BOOL bHorizontal);


void __RPC_STUB IDXGradient_SetGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXGradient_GetOutputSize_Proxy( 
    IDXGradient __RPC_FAR * This,
    /* [out] */ SIZE __RPC_FAR *pOutSize);


void __RPC_STUB IDXGradient_GetOutputSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXGradient_INTERFACE_DEFINED__ */


#ifndef __IDXGradient2_INTERFACE_DEFINED__
#define __IDXGradient2_INTERFACE_DEFINED__

/* interface IDXGradient2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXGradient2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0ef2a80-61dc-11d2-b2eb-00a0c936b212")
    IDXGradient2 : public IDXGradient
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradient( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradient( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGradient2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXGradient2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXGradient2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXGradient2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXGradient2 __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGradient )( 
            IDXGradient2 __RPC_FAR * This,
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSize )( 
            IDXGradient2 __RPC_FAR * This,
            /* [out] */ SIZE __RPC_FAR *pOutSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRadialGradient )( 
            IDXGradient2 __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLinearGradient )( 
            IDXGradient2 __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXGradient2Vtbl;

    interface IDXGradient2
    {
        CONST_VTBL struct IDXGradient2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGradient2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXGradient2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXGradient2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXGradient2_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXGradient2_SetGradient(This,StartColor,EndColor,bHorizontal)	\
    (This)->lpVtbl -> SetGradient(This,StartColor,EndColor,bHorizontal)

#define IDXGradient2_GetOutputSize(This,pOutSize)	\
    (This)->lpVtbl -> GetOutputSize(This,pOutSize)


#define IDXGradient2_SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDXGradient2_SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXGradient2_SetRadialGradient_Proxy( 
    IDXGradient2 __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetRadialGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXGradient2_SetLinearGradient_Proxy( 
    IDXGradient2 __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetLinearGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXGradient2_INTERFACE_DEFINED__ */


#ifndef __IDXTScale_INTERFACE_DEFINED__
#define __IDXTScale_INTERFACE_DEFINED__

/* interface IDXTScale */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTScale;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B39FD742-E139-11d1-9065-00C04FD9189D")
    IDXTScale : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetScales( 
            /* [in] */ float __RPC_FAR Scales[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScales( 
            /* [out] */ float __RPC_FAR Scales[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScaleFitToSize( 
            /* [out][in] */ DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ SIZE FitToSize,
            /* [in] */ BOOL bMaintainAspect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTScaleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTScale __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTScale __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTScale __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScales )( 
            IDXTScale __RPC_FAR * This,
            /* [in] */ float __RPC_FAR Scales[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScales )( 
            IDXTScale __RPC_FAR * This,
            /* [out] */ float __RPC_FAR Scales[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScaleFitToSize )( 
            IDXTScale __RPC_FAR * This,
            /* [out][in] */ DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ SIZE FitToSize,
            /* [in] */ BOOL bMaintainAspect);
        
        END_INTERFACE
    } IDXTScaleVtbl;

    interface IDXTScale
    {
        CONST_VTBL struct IDXTScaleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTScale_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTScale_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTScale_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTScale_SetScales(This,Scales)	\
    (This)->lpVtbl -> SetScales(This,Scales)

#define IDXTScale_GetScales(This,Scales)	\
    (This)->lpVtbl -> GetScales(This,Scales)

#define IDXTScale_ScaleFitToSize(This,pClipBounds,FitToSize,bMaintainAspect)	\
    (This)->lpVtbl -> ScaleFitToSize(This,pClipBounds,FitToSize,bMaintainAspect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTScale_SetScales_Proxy( 
    IDXTScale __RPC_FAR * This,
    /* [in] */ float __RPC_FAR Scales[ 2 ]);


void __RPC_STUB IDXTScale_SetScales_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTScale_GetScales_Proxy( 
    IDXTScale __RPC_FAR * This,
    /* [out] */ float __RPC_FAR Scales[ 2 ]);


void __RPC_STUB IDXTScale_GetScales_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTScale_ScaleFitToSize_Proxy( 
    IDXTScale __RPC_FAR * This,
    /* [out][in] */ DXBNDS __RPC_FAR *pClipBounds,
    /* [in] */ SIZE FitToSize,
    /* [in] */ BOOL bMaintainAspect);


void __RPC_STUB IDXTScale_ScaleFitToSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTScale_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0269 */
/* [local] */ 

typedef 
enum DXLOGFONTENUM
    {	DXLF_HEIGHT	= 1,
	DXLF_WIDTH	= 2,
	DXLF_ESC	= 4,
	DXLF_ORIENTATION	= 8,
	DXLF_WEIGHT	= 16,
	DXLF_ITALIC	= 32,
	DXLF_UNDERLINE	= 64,
	DXLF_STRIKEOUT	= 128,
	DXLF_CHARSET	= 256,
	DXLF_OUTPREC	= 512,
	DXLF_CLIPPREC	= 1024,
	DXLF_QUALITY	= 2048,
	DXLF_PITCHANDFAM	= 4096,
	DXLF_FACENAME	= 8192,
	DXLF_ALL	= 0x3fff
    }	DXLOGFONTENUM;

#ifndef _WINGDI_
typedef struct tagLOGFONTA
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    }	LOGFONTA;

typedef struct tagLOGFONTW
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    }	LOGFONTW;

typedef LOGFONTA LOGFONT;

#endif


extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0269_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0269_v0_0_s_ifspec;

#ifndef __IDXTLabel_INTERFACE_DEFINED__
#define __IDXTLabel_INTERFACE_DEFINED__

/* interface IDXTLabel */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTLabel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0C17F0E-AE41-11d1-9A3B-0000F8756A10")
    IDXTLabel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFontHandle( 
            /* [in] */ HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFontHandle( 
            /* [out] */ HFONT __RPC_FAR *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextString( 
            /* [in] */ LPCWSTR pString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextString( 
            /* [out] */ LPWSTR __RPC_FAR *ppString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillColor( 
            /* [out] */ DXSAMPLE __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundColor( 
            /* [out] */ DXSAMPLE __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTexturePosition( 
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTexturePosition( 
            /* [in] */ long x,
            /* [in] */ long y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMatrix( 
            /* [out] */ PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMatrix( 
            /* [in] */ const PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogfont( 
            /* [in] */ const LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogfont( 
            /* [out] */ LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteWithRasterizer( 
            /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaselineOffset( 
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py,
            /* [out] */ long __RPC_FAR *pdx,
            /* [out] */ long __RPC_FAR *pdy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTLabelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTLabel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTLabel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFontHandle )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFontHandle )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ HFONT __RPC_FAR *phFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTextString )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ LPCWSTR pString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTextString )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFillColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ DXSAMPLE __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFillColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackgroundColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ DXSAMPLE __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackgroundColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTexturePosition )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTexturePosition )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMatrix )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMatrix )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ const PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogfont )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ const LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogfont )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteWithRasterizer )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBaselineOffset )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py,
            /* [out] */ long __RPC_FAR *pdx,
            /* [out] */ long __RPC_FAR *pdy);
        
        END_INTERFACE
    } IDXTLabelVtbl;

    interface IDXTLabel
    {
        CONST_VTBL struct IDXTLabelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTLabel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTLabel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTLabel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTLabel_SetFontHandle(This,hFont)	\
    (This)->lpVtbl -> SetFontHandle(This,hFont)

#define IDXTLabel_GetFontHandle(This,phFont)	\
    (This)->lpVtbl -> GetFontHandle(This,phFont)

#define IDXTLabel_SetTextString(This,pString)	\
    (This)->lpVtbl -> SetTextString(This,pString)

#define IDXTLabel_GetTextString(This,ppString)	\
    (This)->lpVtbl -> GetTextString(This,ppString)

#define IDXTLabel_GetFillColor(This,pVal)	\
    (This)->lpVtbl -> GetFillColor(This,pVal)

#define IDXTLabel_SetFillColor(This,newVal)	\
    (This)->lpVtbl -> SetFillColor(This,newVal)

#define IDXTLabel_GetBackgroundColor(This,pVal)	\
    (This)->lpVtbl -> GetBackgroundColor(This,pVal)

#define IDXTLabel_SetBackgroundColor(This,newVal)	\
    (This)->lpVtbl -> SetBackgroundColor(This,newVal)

#define IDXTLabel_GetTexturePosition(This,px,py)	\
    (This)->lpVtbl -> GetTexturePosition(This,px,py)

#define IDXTLabel_SetTexturePosition(This,x,y)	\
    (This)->lpVtbl -> SetTexturePosition(This,x,y)

#define IDXTLabel_GetMatrix(This,pXform)	\
    (This)->lpVtbl -> GetMatrix(This,pXform)

#define IDXTLabel_SetMatrix(This,pXform)	\
    (This)->lpVtbl -> SetMatrix(This,pXform)

#define IDXTLabel_SetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> SetLogfont(This,plf,dwFlags)

#define IDXTLabel_GetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> GetLogfont(This,plf,dwFlags)

#define IDXTLabel_ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)	\
    (This)->lpVtbl -> ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)

#define IDXTLabel_GetBaselineOffset(This,px,py,pdx,pdy)	\
    (This)->lpVtbl -> GetBaselineOffset(This,px,py,pdx,pdy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTLabel_SetFontHandle_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ HFONT hFont);


void __RPC_STUB IDXTLabel_SetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFontHandle_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ HFONT __RPC_FAR *phFont);


void __RPC_STUB IDXTLabel_GetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTextString_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ LPCWSTR pString);


void __RPC_STUB IDXTLabel_SetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTextString_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppString);


void __RPC_STUB IDXTLabel_GetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFillColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ DXSAMPLE __RPC_FAR *pVal);


void __RPC_STUB IDXTLabel_GetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetFillColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBackgroundColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ DXSAMPLE __RPC_FAR *pVal);


void __RPC_STUB IDXTLabel_GetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetBackgroundColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTexturePosition_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py);


void __RPC_STUB IDXTLabel_GetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTexturePosition_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y);


void __RPC_STUB IDXTLabel_SetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetMatrix_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_GetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetMatrix_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ const PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_SetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetLogfont_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ const LOGFONT __RPC_FAR *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_SetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetLogfont_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ LOGFONT __RPC_FAR *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_GetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_ExecuteWithRasterizer_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
    /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
    /* [in] */ const DXVEC __RPC_FAR *pPlacement);


void __RPC_STUB IDXTLabel_ExecuteWithRasterizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBaselineOffset_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py,
    /* [out] */ long __RPC_FAR *pdx,
    /* [out] */ long __RPC_FAR *pdy);


void __RPC_STUB IDXTLabel_GetBaselineOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTLabel_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0270 */
/* [local] */ 

typedef 
enum DXRASTERFILL
    {	DXRASTER_PEN	= 0,
	DXRASTER_BRUSH	= 1,
	DXRASTER_BACKGROUND	= 2
    }	DXRASTERFILL;

typedef struct DXRASTERSCANINFO
    {
    ULONG ulIndex;
    ULONG Row;
    const BYTE __RPC_FAR *pWeights;
    const DXRUNINFO __RPC_FAR *pRunInfo;
    ULONG cRunInfo;
    }	DXRASTERSCANINFO;

typedef struct DXRASTERPOINTINFO
    {
    DXOVERSAMPLEDESC Pixel;
    ULONG ulIndex;
    BYTE Weight;
    }	DXRASTERPOINTINFO;

typedef struct DXRASTERRECTINFO
    {
    ULONG ulIndex;
    RECT Rect;
    BYTE Weight;
    }	DXRASTERRECTINFO;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0270_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0270_v0_0_s_ifspec;

#ifndef __IDXRasterizer_INTERFACE_DEFINED__
#define __IDXRasterizer_INTERFACE_DEFINED__

/* interface IDXRasterizer */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXRasterizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B635-C37D-11d1-905E-00C04FD9189D")
    IDXRasterizer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            /* [in] */ IDXSurface __RPC_FAR *pDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFill( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ const POINT __RPC_FAR *ppt,
            /* [in] */ DXSAMPLE FillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFill( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ POINT __RPC_FAR *ppt,
            /* [out] */ DXSAMPLE __RPC_FAR *pFillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginRendering( 
            /* [in] */ ULONG ulTimeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndRendering( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderScan( 
            /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPixel( 
            /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillRect( 
            /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBounds( 
            /* [out] */ DXBNDS __RPC_FAR *pBounds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXRasterizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXRasterizer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXRasterizer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSurface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFill )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ const POINT __RPC_FAR *ppt,
            /* [in] */ DXSAMPLE FillColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFill )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ POINT __RPC_FAR *ppt,
            /* [out] */ DXSAMPLE __RPC_FAR *pFillColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginRendering )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulTimeOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndRendering )( 
            IDXRasterizer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RenderScan )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPixel )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FillRect )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBounds )( 
            IDXRasterizer __RPC_FAR * This,
            /* [out] */ DXBNDS __RPC_FAR *pBounds);
        
        END_INTERFACE
    } IDXRasterizerVtbl;

    interface IDXRasterizer
    {
        CONST_VTBL struct IDXRasterizerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXRasterizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXRasterizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXRasterizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXRasterizer_SetSurface(This,pDXSurface)	\
    (This)->lpVtbl -> SetSurface(This,pDXSurface)

#define IDXRasterizer_GetSurface(This,ppDXSurface)	\
    (This)->lpVtbl -> GetSurface(This,ppDXSurface)

#define IDXRasterizer_SetFill(This,ulIndex,pSurface,ppt,FillColor)	\
    (This)->lpVtbl -> SetFill(This,ulIndex,pSurface,ppt,FillColor)

#define IDXRasterizer_GetFill(This,ulIndex,ppSurface,ppt,pFillColor)	\
    (This)->lpVtbl -> GetFill(This,ulIndex,ppSurface,ppt,pFillColor)

#define IDXRasterizer_BeginRendering(This,ulTimeOut)	\
    (This)->lpVtbl -> BeginRendering(This,ulTimeOut)

#define IDXRasterizer_EndRendering(This)	\
    (This)->lpVtbl -> EndRendering(This)

#define IDXRasterizer_RenderScan(This,pScanInfo)	\
    (This)->lpVtbl -> RenderScan(This,pScanInfo)

#define IDXRasterizer_SetPixel(This,pPointInfo)	\
    (This)->lpVtbl -> SetPixel(This,pPointInfo)

#define IDXRasterizer_FillRect(This,pRectInfo)	\
    (This)->lpVtbl -> FillRect(This,pRectInfo)

#define IDXRasterizer_GetBounds(This,pBounds)	\
    (This)->lpVtbl -> GetBounds(This,pBounds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXRasterizer_SetSurface_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pDXSurface);


void __RPC_STUB IDXRasterizer_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetSurface_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXRasterizer_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetFill_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulIndex,
    /* [in] */ IDXSurface __RPC_FAR *pSurface,
    /* [in] */ const POINT __RPC_FAR *ppt,
    /* [in] */ DXSAMPLE FillColor);


void __RPC_STUB IDXRasterizer_SetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetFill_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
    /* [out] */ POINT __RPC_FAR *ppt,
    /* [out] */ DXSAMPLE __RPC_FAR *pFillColor);


void __RPC_STUB IDXRasterizer_GetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_BeginRendering_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXRasterizer_BeginRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_EndRendering_Proxy( 
    IDXRasterizer __RPC_FAR * This);


void __RPC_STUB IDXRasterizer_EndRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_RenderScan_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo);


void __RPC_STUB IDXRasterizer_RenderScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetPixel_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo);


void __RPC_STUB IDXRasterizer_SetPixel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_FillRect_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo);


void __RPC_STUB IDXRasterizer_FillRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetBounds_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [out] */ DXBNDS __RPC_FAR *pBounds);


void __RPC_STUB IDXRasterizer_GetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXRasterizer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0271 */
/* [local] */ 

typedef 
enum DISPIDDXEFFECT
    {	DISPID_DXECAPABILITIES	= 10000,
	DISPID_DXEPROGRESS	= DISPID_DXECAPABILITIES + 1,
	DISPID_DXESTEP	= DISPID_DXEPROGRESS + 1,
	DISPID_DXEDURATION	= DISPID_DXESTEP + 1,
	DISPID_DXE_NEXT_ID	= DISPID_DXEDURATION + 1
    }	DISPIDDXBOUNDEDEFFECT;

typedef 
enum DXEFFECTTYPE
    {	DXTET_PERIODIC	= 1 << 0,
	DXTET_MORPH	= 1 << 1
    }	DXEFFECTTYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0271_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0271_v0_0_s_ifspec;

#ifndef __IDXEffect_INTERFACE_DEFINED__
#define __IDXEffect_INTERFACE_DEFINED__

/* interface IDXEffect */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXEffect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E31FB81B-1335-11d1-8189-0000F87557DB")
    IDXEffect : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Capabilities( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Progress( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Progress( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StepResolution( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Duration( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXEffectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXEffect __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXEffect __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXEffect __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXEffectVtbl;

    interface IDXEffect
    {
        CONST_VTBL struct IDXEffectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXEffect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXEffect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXEffect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXEffect_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXEffect_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXEffect_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXEffect_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXEffect_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXEffect_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXEffect_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXEffect_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXEffect_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXEffect_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Capabilities_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_Capabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Progress_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXEffect_put_Progress_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXEffect_put_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_StepResolution_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_StepResolution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Duration_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXEffect_put_Duration_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXEffect_put_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXEffect_INTERFACE_DEFINED__ */


#ifndef __IDXLookupTable_INTERFACE_DEFINED__
#define __IDXLookupTable_INTERFACE_DEFINED__

/* interface IDXLookupTable */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXLookupTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01BAFC7F-9E63-11d1-9053-00C04FD9189D")
    IDXLookupTable : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTables( 
            /* [out] */ BYTE __RPC_FAR RedLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR GreenLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR BlueLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR AlphaLUT[ 256 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsChannelIdentity( 
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSampleBools) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexValues( 
            /* [in] */ ULONG Index,
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyTables( 
            /* [out][in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXLookupTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXLookupTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXLookupTable __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXLookupTable __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXLookupTable __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTables )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR RedLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR GreenLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR BlueLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR AlphaLUT[ 256 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsChannelIdentity )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSampleBools);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndexValues )( 
            IDXLookupTable __RPC_FAR * This,
            /* [in] */ ULONG Index,
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ApplyTables )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out][in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples);
        
        END_INTERFACE
    } IDXLookupTableVtbl;

    interface IDXLookupTable
    {
        CONST_VTBL struct IDXLookupTableVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXLookupTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXLookupTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXLookupTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXLookupTable_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXLookupTable_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXLookupTable_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXLookupTable_GetTables(This,RedLUT,GreenLUT,BlueLUT,AlphaLUT)	\
    (This)->lpVtbl -> GetTables(This,RedLUT,GreenLUT,BlueLUT,AlphaLUT)

#define IDXLookupTable_IsChannelIdentity(This,pSampleBools)	\
    (This)->lpVtbl -> IsChannelIdentity(This,pSampleBools)

#define IDXLookupTable_GetIndexValues(This,Index,pSample)	\
    (This)->lpVtbl -> GetIndexValues(This,Index,pSample)

#define IDXLookupTable_ApplyTables(This,pSamples,cSamples)	\
    (This)->lpVtbl -> ApplyTables(This,pSamples,cSamples)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXLookupTable_GetTables_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR RedLUT[ 256 ],
    /* [out] */ BYTE __RPC_FAR GreenLUT[ 256 ],
    /* [out] */ BYTE __RPC_FAR BlueLUT[ 256 ],
    /* [out] */ BYTE __RPC_FAR AlphaLUT[ 256 ]);


void __RPC_STUB IDXLookupTable_GetTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_IsChannelIdentity_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [out] */ DXBASESAMPLE __RPC_FAR *pSampleBools);


void __RPC_STUB IDXLookupTable_IsChannelIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_GetIndexValues_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [in] */ ULONG Index,
    /* [out] */ DXBASESAMPLE __RPC_FAR *pSample);


void __RPC_STUB IDXLookupTable_GetIndexValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_ApplyTables_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [out][in] */ DXSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXLookupTable_ApplyTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXLookupTable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0273 */
/* [local] */ 

typedef 
enum DX2DPOLYDRAW
    {	DX2D_WINDING_FILL	= 1L << 0,
	DX2D_NO_FLATTEN	= 1L << 1,
	DX2D_DO_GRID_FIT	= 1L << 2,
	DX2D_IS_RECT	= 1L << 3,
	DX2D_STROKE	= 1L << 4,
	DX2D_FILL	= 1L << 5,
	DX2D_UNUSED	= 0xffffffc0
    }	DX2DPOLYDRAW;

typedef struct DXFPOINT
    {
    FLOAT x;
    FLOAT y;
    }	DXFPOINT;

typedef 
enum DX2DPEN
    {	DX2D_PEN_DEFAULT	= 0,
	DX2D_PEN_WIDTH_IN_DISPLAY_COORDS	= 1L << 0,
	DX2D_PEN_UNUSED	= 0xfffffffe
    }	DX2DPEN;

typedef struct DXPEN
    {
    DXSAMPLE Color;
    float Width;
    DWORD Style;
    IDXSurface __RPC_FAR *pTexture;
    DXFPOINT TexturePos;
    DWORD dwFlags;
    }	DXPEN;

typedef struct DXBRUSH
    {
    DXSAMPLE Color;
    IDXSurface __RPC_FAR *pTexture;
    DXFPOINT TexturePos;
    }	DXBRUSH;

typedef 
enum DX2DGRADIENT
    {	DX2DGRAD_DEFAULT	= 0,
	DX2DGRAD_CLIPGRADIENT	= 1,
	DX2DGRAD_UNUSED	= 0xfffffffe
    }	DX2DGRADIENT;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0273_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0273_v0_0_s_ifspec;

#ifndef __IDX2DDebug_INTERFACE_DEFINED__
#define __IDX2DDebug_INTERFACE_DEFINED__

/* interface IDX2DDebug */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IDX2DDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03BB2457-A279-11d1-81C6-0000F87557DB")
    IDX2DDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDC( 
            HDC hDC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDC( 
            HDC __RPC_FAR *phDC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDX2DDebug __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDX2DDebug __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDX2DDebug __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDC )( 
            IDX2DDebug __RPC_FAR * This,
            HDC hDC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDC )( 
            IDX2DDebug __RPC_FAR * This,
            HDC __RPC_FAR *phDC);
        
        END_INTERFACE
    } IDX2DDebugVtbl;

    interface IDX2DDebug
    {
        CONST_VTBL struct IDX2DDebugVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2DDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2DDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2DDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2DDebug_SetDC(This,hDC)	\
    (This)->lpVtbl -> SetDC(This,hDC)

#define IDX2DDebug_GetDC(This,phDC)	\
    (This)->lpVtbl -> GetDC(This,phDC)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2DDebug_SetDC_Proxy( 
    IDX2DDebug __RPC_FAR * This,
    HDC hDC);


void __RPC_STUB IDX2DDebug_SetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2DDebug_GetDC_Proxy( 
    IDX2DDebug __RPC_FAR * This,
    HDC __RPC_FAR *phDC);


void __RPC_STUB IDX2DDebug_GetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2DDebug_INTERFACE_DEFINED__ */


#ifndef __IDX2D_INTERFACE_DEFINED__
#define __IDX2D_INTERFACE_DEFINED__

/* interface IDX2D */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IDX2D;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EFD02A9-A996-11d1-81C9-0000F87557DB")
    IDX2D : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTransformFactory( 
            IDXTransformFactory __RPC_FAR *pTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformFactory( 
            IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            IUnknown __RPC_FAR *pSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClipRect( 
            RECT __RPC_FAR *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClipRect( 
            RECT __RPC_FAR *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorldTransform( 
            const DX2DXFORM __RPC_FAR *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorldTransform( 
            DX2DXFORM __RPC_FAR *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPen( 
            const DXPEN __RPC_FAR *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPen( 
            DXPEN __RPC_FAR *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBrush( 
            const DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrush( 
            DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundBrush( 
            const DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundBrush( 
            DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFont( 
            HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFont( 
            HFONT __RPC_FAR *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Blt( 
            IUnknown __RPC_FAR *punkSrc,
            const RECT __RPC_FAR *pSrcRect,
            const POINT __RPC_FAR *pDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAPolyDraw( 
            const DXFPOINT __RPC_FAR *pPos,
            const BYTE __RPC_FAR *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAText( 
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradientBrush( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradientBrush( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDX2D __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDX2D __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDX2D __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTransformFactory )( 
            IDX2D __RPC_FAR * This,
            IDXTransformFactory __RPC_FAR *pTransFact);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransformFactory )( 
            IDX2D __RPC_FAR * This,
            IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSurface )( 
            IDX2D __RPC_FAR * This,
            IUnknown __RPC_FAR *pSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDX2D __RPC_FAR * This,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClipRect )( 
            IDX2D __RPC_FAR * This,
            RECT __RPC_FAR *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClipRect )( 
            IDX2D __RPC_FAR * This,
            RECT __RPC_FAR *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWorldTransform )( 
            IDX2D __RPC_FAR * This,
            const DX2DXFORM __RPC_FAR *pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWorldTransform )( 
            IDX2D __RPC_FAR * This,
            DX2DXFORM __RPC_FAR *pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPen )( 
            IDX2D __RPC_FAR * This,
            const DXPEN __RPC_FAR *pPen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPen )( 
            IDX2D __RPC_FAR * This,
            DXPEN __RPC_FAR *pPen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBrush )( 
            IDX2D __RPC_FAR * This,
            const DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBrush )( 
            IDX2D __RPC_FAR * This,
            DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackgroundBrush )( 
            IDX2D __RPC_FAR * This,
            const DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackgroundBrush )( 
            IDX2D __RPC_FAR * This,
            DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )( 
            IDX2D __RPC_FAR * This,
            HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )( 
            IDX2D __RPC_FAR * This,
            HFONT __RPC_FAR *phFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Blt )( 
            IDX2D __RPC_FAR * This,
            IUnknown __RPC_FAR *punkSrc,
            const RECT __RPC_FAR *pSrcRect,
            const POINT __RPC_FAR *pDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AAPolyDraw )( 
            IDX2D __RPC_FAR * This,
            const DXFPOINT __RPC_FAR *pPos,
            const BYTE __RPC_FAR *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AAText )( 
            IDX2D __RPC_FAR * This,
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRadialGradientBrush )( 
            IDX2D __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLinearGradientBrush )( 
            IDX2D __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDX2DVtbl;

    interface IDX2D
    {
        CONST_VTBL struct IDX2DVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2D_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2D_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2D_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2D_SetTransformFactory(This,pTransFact)	\
    (This)->lpVtbl -> SetTransformFactory(This,pTransFact)

#define IDX2D_GetTransformFactory(This,ppTransFact)	\
    (This)->lpVtbl -> GetTransformFactory(This,ppTransFact)

#define IDX2D_SetSurface(This,pSurface)	\
    (This)->lpVtbl -> SetSurface(This,pSurface)

#define IDX2D_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDX2D_SetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> SetClipRect(This,pClipRect)

#define IDX2D_GetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> GetClipRect(This,pClipRect)

#define IDX2D_SetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> SetWorldTransform(This,pXform)

#define IDX2D_GetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> GetWorldTransform(This,pXform)

#define IDX2D_SetPen(This,pPen)	\
    (This)->lpVtbl -> SetPen(This,pPen)

#define IDX2D_GetPen(This,pPen)	\
    (This)->lpVtbl -> GetPen(This,pPen)

#define IDX2D_SetBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBrush(This,pBrush)

#define IDX2D_GetBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBrush(This,pBrush)

#define IDX2D_SetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBackgroundBrush(This,pBrush)

#define IDX2D_GetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBackgroundBrush(This,pBrush)

#define IDX2D_SetFont(This,hFont)	\
    (This)->lpVtbl -> SetFont(This,hFont)

#define IDX2D_GetFont(This,phFont)	\
    (This)->lpVtbl -> GetFont(This,phFont)

#define IDX2D_Blt(This,punkSrc,pSrcRect,pDest)	\
    (This)->lpVtbl -> Blt(This,punkSrc,pSrcRect,pDest)

#define IDX2D_AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)	\
    (This)->lpVtbl -> AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)

#define IDX2D_AAText(This,Pos,pString,ulCount,dwFlags)	\
    (This)->lpVtbl -> AAText(This,Pos,pString,ulCount,dwFlags)

#define IDX2D_SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDX2D_SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2D_SetTransformFactory_Proxy( 
    IDX2D __RPC_FAR * This,
    IDXTransformFactory __RPC_FAR *pTransFact);


void __RPC_STUB IDX2D_SetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetTransformFactory_Proxy( 
    IDX2D __RPC_FAR * This,
    IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact);


void __RPC_STUB IDX2D_GetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetSurface_Proxy( 
    IDX2D __RPC_FAR * This,
    IUnknown __RPC_FAR *pSurface);


void __RPC_STUB IDX2D_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetSurface_Proxy( 
    IDX2D __RPC_FAR * This,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDX2D_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetClipRect_Proxy( 
    IDX2D __RPC_FAR * This,
    RECT __RPC_FAR *pClipRect);


void __RPC_STUB IDX2D_SetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetClipRect_Proxy( 
    IDX2D __RPC_FAR * This,
    RECT __RPC_FAR *pClipRect);


void __RPC_STUB IDX2D_GetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetWorldTransform_Proxy( 
    IDX2D __RPC_FAR * This,
    const DX2DXFORM __RPC_FAR *pXform);


void __RPC_STUB IDX2D_SetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetWorldTransform_Proxy( 
    IDX2D __RPC_FAR * This,
    DX2DXFORM __RPC_FAR *pXform);


void __RPC_STUB IDX2D_GetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetPen_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXPEN __RPC_FAR *pPen);


void __RPC_STUB IDX2D_SetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetPen_Proxy( 
    IDX2D __RPC_FAR * This,
    DXPEN __RPC_FAR *pPen);


void __RPC_STUB IDX2D_GetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_SetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_GetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBackgroundBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_SetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBackgroundBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_GetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetFont_Proxy( 
    IDX2D __RPC_FAR * This,
    HFONT hFont);


void __RPC_STUB IDX2D_SetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetFont_Proxy( 
    IDX2D __RPC_FAR * This,
    HFONT __RPC_FAR *phFont);


void __RPC_STUB IDX2D_GetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_Blt_Proxy( 
    IDX2D __RPC_FAR * This,
    IUnknown __RPC_FAR *punkSrc,
    const RECT __RPC_FAR *pSrcRect,
    const POINT __RPC_FAR *pDest);


void __RPC_STUB IDX2D_Blt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAPolyDraw_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXFPOINT __RPC_FAR *pPos,
    const BYTE __RPC_FAR *pTypes,
    ULONG ulCount,
    ULONG SubSampRes,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAPolyDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAText_Proxy( 
    IDX2D __RPC_FAR * This,
    DXFPOINT Pos,
    LPWSTR pString,
    ULONG ulCount,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetRadialGradientBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetRadialGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetLinearGradientBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetLinearGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2D_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0275 */
/* [local] */ 

typedef struct DXRAWSURFACEINFO
    {
    BYTE __RPC_FAR *pFirstByte;
    long lPitch;
    ULONG Width;
    ULONG Height;
    const GUID __RPC_FAR *pPixelFormat;
    HDC hdc;
    DWORD dwColorKey;
    DXBASESAMPLE __RPC_FAR *pPalette;
    }	DXRAWSURFACEINFO;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0275_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0275_v0_0_s_ifspec;

#ifndef __IDXRawSurface_INTERFACE_DEFINED__
#define __IDXRawSurface_INTERFACE_DEFINED__

/* interface IDXRawSurface */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXRawSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09756C8A-D96A-11d1-9062-00C04FD9189D")
    IDXRawSurface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurfaceInfo( 
            DXRAWSURFACEINFO __RPC_FAR *pSurfaceInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXRawSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXRawSurface __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXRawSurface __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXRawSurface __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurfaceInfo )( 
            IDXRawSurface __RPC_FAR * This,
            DXRAWSURFACEINFO __RPC_FAR *pSurfaceInfo);
        
        END_INTERFACE
    } IDXRawSurfaceVtbl;

    interface IDXRawSurface
    {
        CONST_VTBL struct IDXRawSurfaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXRawSurface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXRawSurface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXRawSurface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXRawSurface_GetSurfaceInfo(This,pSurfaceInfo)	\
    (This)->lpVtbl -> GetSurfaceInfo(This,pSurfaceInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXRawSurface_GetSurfaceInfo_Proxy( 
    IDXRawSurface __RPC_FAR * This,
    DXRAWSURFACEINFO __RPC_FAR *pSurfaceInfo);


void __RPC_STUB IDXRawSurface_GetSurfaceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXRawSurface_INTERFACE_DEFINED__ */



#ifndef __DXTRANSLib_LIBRARY_DEFINED__
#define __DXTRANSLib_LIBRARY_DEFINED__

/* library DXTRANSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTRANSLib;

EXTERN_C const CLSID CLSID_DXTransformFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("D1FE6762-FC48-11D0-883A-3C8B00C10000")
DXTransformFactory;
#endif

EXTERN_C const CLSID CLSID_DXTaskManager;

#ifdef __cplusplus

class DECLSPEC_UUID("4CB26C03-FF93-11d0-817E-0000F87557DB")
DXTaskManager;
#endif

EXTERN_C const CLSID CLSID_DXTScale;

#ifdef __cplusplus

class DECLSPEC_UUID("555278E2-05DB-11D1-883A-3C8B00C10000")
DXTScale;
#endif

EXTERN_C const CLSID CLSID_DXTLabel;

#ifdef __cplusplus

class DECLSPEC_UUID("54702535-2606-11D1-999C-0000F8756A10")
DXTLabel;
#endif

EXTERN_C const CLSID CLSID_DX2D;

#ifdef __cplusplus

class DECLSPEC_UUID("473AA80B-4577-11D1-81A8-0000F87557DB")
DX2D;
#endif

EXTERN_C const CLSID CLSID_DXSurface;

#ifdef __cplusplus

class DECLSPEC_UUID("0E890F83-5F79-11D1-9043-00C04FD9189D")
DXSurface;
#endif

EXTERN_C const CLSID CLSID_DXSurfaceModifier;

#ifdef __cplusplus

class DECLSPEC_UUID("3E669F1D-9C23-11d1-9053-00C04FD9189D")
DXSurfaceModifier;
#endif

EXTERN_C const CLSID CLSID_DXRasterizer;

#ifdef __cplusplus

class DECLSPEC_UUID("8652CE55-9E80-11D1-9053-00C04FD9189D")
DXRasterizer;
#endif

EXTERN_C const CLSID CLSID_DXGradient;

#ifdef __cplusplus

class DECLSPEC_UUID("C6365470-F667-11d1-9067-00C04FD9189D")
DXGradient;
#endif
#endif /* __DXTRANSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HFONT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HFONT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HFONT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HFONT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HFONT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HFONT __RPC_FAR * ); 
void                      __RPC_USER  HFONT_UserFree(     unsigned long __RPC_FAR *, HFONT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\extinc\dxtmsftguid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXLUTBuilder,0xF4370FC1,0xCADB,0x11D0,0xB5,0x2C,0x00,0xA0,0xC9,0x05,0x43,0x73);


MIDL_DEFINE_GUID(IID, IID_IDXDLUTBuilder,0x73068231,0x35EE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTGradientD,0x623E2881,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTConvolution,0x7BA7F8AF,0xE5EA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXMapper,0x555278E5,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXDMapper,0x7FD9088B,0x35ED,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTComposite,0x9A43A843,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTWipe,0xAF279B2F,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrBlur,0x9F7C7827,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEngrave,0xE4ACFB7F,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEmboss,0xE4ACFB80,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTFade,0x16B280C4,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXBasicImage,0x16B280C7,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXPixelate,0xD33E180F,0xFBE9,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_ICrIris,0x3F69F350,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrSlide,0x810E402E,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrRadialWipe,0x424B71AE,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBarn,0x276A2EE0,0x0B5D,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBlinds,0x5AF5C340,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrInset,0x05C5EE20,0x0BA6,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrStretch,0x6684AF00,0x0A87,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrSpiral,0x0DE527A0,0x0C7E,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrZigzag,0x4E5A64A0,0x0C8B,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrWheel,0x3943DE80,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTChroma,0x1D4637E2,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTDropShadow,0x1D4637E3,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRoll,0x9C61F46D,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRipple,0xAA0D4D02,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPageTurn,0xAA0D4D07,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLiquid,0xAA0D4D09,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaCenterPeel,0xAA0D4D0B,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSmall,0xAA0D4D0D,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelPiece,0xAA0D4D0F,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSplit,0xAA0D4D11,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWater,0x107045C4,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLightWipe,0x107045C7,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRadialScaleWipe,0x107045C9,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWhiteOut,0x107045CB,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaTwister,0x107045CE,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaBurnFilm,0x107045D0,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaJaws,0x2A54C903,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaColorFade,0x2A54C907,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaFlowMotion,0x2A54C90A,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaVacuum,0x2A54C90C,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler,0x2A54C910,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler2,0x2A54C912,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaThreshold,0x2A54C914,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWormHole,0x0E6AE021,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFTLib,0x5E77EB03,0x937C,0x11D1,0xB0,0x47,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTComposite,0x9A43A844,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXLUTBuilder,0x1E54333B,0x2A00,0x11d1,0x81,0x98,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGradientD,0x623E2882,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipe,0xAF279B30,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTConvolution,0x2BC0EF29,0xE6BA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlur,0x7312498D,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEmboss,0xF515306D,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEngrave,0xF515306E,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXFade,0x16B280C5,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_FadePP,0x16B280C6,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffects,0x16B280C8,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffectsPP,0x16B280C9,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_Pixelate,0x4CCEA634,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_PixelatePP,0x4CCEA635,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipePP,0x7FFE4D08,0xFBFD,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlurPP,0x623E287E,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_GradientPP,0x623E2880,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CompositePP,0x25B33660,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_ConvolvePP,0x25B33661,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_LUTBuilderPP,0x25B33662,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIris,0x3F69F351,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIrisPP,0x80DE22C4,0x0F44,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlide,0x810E402F,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlidePP,0xCC8CEDE1,0x1003,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipe,0x424B71AF,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipePP,0x33D932E0,0x0F48,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBarn,0xC3BDF740,0x0B58,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlinds,0x00C429C0,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlindPP,0x213052C1,0x100D,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretch,0x7658F2A2,0x0A83,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretchPP,0x15FB95E0,0x0F77,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrInset,0x93073C40,0x0BA5,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiral,0xACA97E00,0x0C7D,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiralPP,0xC6A4FE81,0x1022,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzag,0xE6E73D20,0x0C8A,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzagPP,0x1559A3C1,0x102B,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheel,0x5AE1DAE0,0x1461,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheelPP,0xFA9F6180,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChroma,0x421516C1,0x3CF8,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChromaPP,0xEC7E0760,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadow,0xADC6CB86,0x424C,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadowPP,0xEC7E0761,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRoll,0x9C61F46E,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRipple,0xAA0D4D03,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPageTurn,0xAA0D4D08,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLiquid,0xAA0D4D0A,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaCenterPeel,0xAA0D4D0C,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSmall,0xAA0D4D0E,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelPiece,0xAA0D4D10,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSplit,0xAA0D4D12,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWater,0x107045C5,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLightWipe,0x107045C8,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRadialScaleWipe,0x107045CA,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWhiteOut,0x107045CC,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaTwister,0x107045CF,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaBurnFilm,0x107045D1,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaJaws,0x2A54C904,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaColorFade,0x2A54C908,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaFlowMotion,0x2A54C90B,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaVacuum,0x2A54C90D,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler,0x2A54C911,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler2,0x2A54C913,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaThreshold,0x2A54C915,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWormHole,0x0E6AE022,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXLUTBuilder,0xF4370FC1,0xCADB,0x11D0,0xB5,0x2C,0x00,0xA0,0xC9,0x05,0x43,0x73);


MIDL_DEFINE_GUID(IID, IID_IDXDLUTBuilder,0x73068231,0x35EE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTGradientD,0x623E2881,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTConvolution,0x7BA7F8AF,0xE5EA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXMapper,0x555278E5,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXDMapper,0x7FD9088B,0x35ED,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTComposite,0x9A43A843,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTWipe,0xAF279B2F,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrBlur,0x9F7C7827,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEngrave,0xE4ACFB7F,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEmboss,0xE4ACFB80,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTFade,0x16B280C4,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXBasicImage,0x16B280C7,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXPixelate,0xD33E180F,0xFBE9,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_ICrIris,0x3F69F350,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrSlide,0x810E402E,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrRadialWipe,0x424B71AE,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBarn,0x276A2EE0,0x0B5D,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBlinds,0x5AF5C340,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrInset,0x05C5EE20,0x0BA6,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrStretch,0x6684AF00,0x0A87,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrSpiral,0x0DE527A0,0x0C7E,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrZigzag,0x4E5A64A0,0x0C8B,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrWheel,0x3943DE80,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTChroma,0x1D4637E2,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTDropShadow,0x1D4637E3,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRoll,0x9C61F46D,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRipple,0xAA0D4D02,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPageTurn,0xAA0D4D07,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLiquid,0xAA0D4D09,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaCenterPeel,0xAA0D4D0B,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSmall,0xAA0D4D0D,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelPiece,0xAA0D4D0F,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSplit,0xAA0D4D11,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWater,0x107045C4,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLightWipe,0x107045C7,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRadialScaleWipe,0x107045C9,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWhiteOut,0x107045CB,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaTwister,0x107045CE,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaBurnFilm,0x107045D0,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaJaws,0x2A54C903,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaColorFade,0x2A54C907,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaFlowMotion,0x2A54C90A,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaVacuum,0x2A54C90C,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler,0x2A54C910,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler2,0x2A54C912,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaThreshold,0x2A54C914,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWormHole,0x0E6AE021,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFTLib,0x5E77EB03,0x937C,0x11D1,0xB0,0x47,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTComposite,0x9A43A844,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXLUTBuilder,0x1E54333B,0x2A00,0x11d1,0x81,0x98,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGradientD,0x623E2882,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipe,0xAF279B30,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTConvolution,0x2BC0EF29,0xE6BA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlur,0x7312498D,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEmboss,0xF515306D,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEngrave,0xF515306E,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXFade,0x16B280C5,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_FadePP,0x16B280C6,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffects,0x16B280C8,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffectsPP,0x16B280C9,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_Pixelate,0x4CCEA634,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_PixelatePP,0x4CCEA635,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipePP,0x7FFE4D08,0xFBFD,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlurPP,0x623E287E,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_GradientPP,0x623E2880,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CompositePP,0x25B33660,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_ConvolvePP,0x25B33661,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_LUTBuilderPP,0x25B33662,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIris,0x3F69F351,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIrisPP,0x80DE22C4,0x0F44,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlide,0x810E402F,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlidePP,0xCC8CEDE1,0x1003,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipe,0x424B71AF,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipePP,0x33D932E0,0x0F48,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBarn,0xC3BDF740,0x0B58,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlinds,0x00C429C0,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlindPP,0x213052C1,0x100D,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretch,0x7658F2A2,0x0A83,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretchPP,0x15FB95E0,0x0F77,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrInset,0x93073C40,0x0BA5,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiral,0xACA97E00,0x0C7D,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiralPP,0xC6A4FE81,0x1022,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzag,0xE6E73D20,0x0C8A,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzagPP,0x1559A3C1,0x102B,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheel,0x5AE1DAE0,0x1461,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheelPP,0xFA9F6180,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChroma,0x421516C1,0x3CF8,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChromaPP,0xEC7E0760,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadow,0xADC6CB86,0x424C,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadowPP,0xEC7E0761,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRoll,0x9C61F46E,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRipple,0xAA0D4D03,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPageTurn,0xAA0D4D08,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLiquid,0xAA0D4D0A,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaCenterPeel,0xAA0D4D0C,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSmall,0xAA0D4D0E,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelPiece,0xAA0D4D10,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSplit,0xAA0D4D12,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWater,0x107045C5,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLightWipe,0x107045C8,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRadialScaleWipe,0x107045CA,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWhiteOut,0x107045CC,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaTwister,0x107045CF,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaBurnFilm,0x107045D1,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaJaws,0x2A54C904,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaColorFade,0x2A54C908,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaFlowMotion,0x2A54C90B,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaVacuum,0x2A54C90D,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler,0x2A54C911,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler2,0x2A54C913,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaThreshold,0x2A54C915,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWormHole,0x0E6AE022,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\extinc\dxtransguid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXBaseObject,0x17B59B2B,0x9CC8,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTransformFactory,0x6A950B2B,0xA971,0x11d1,0x81,0xC8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTransform,0x30A5FB78,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfacePick,0x30A5FB79,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTBindHost,0xD26BCE55,0xE9DC,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTaskManager,0x254DBBC1,0xF922,0x11d0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceFactory,0x144946F5,0xC4D4,0x11d1,0x81,0xD1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceModifier,0x9EA3B637,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurface,0xB39FD73F,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceInit,0x9EA3B639,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBSurfaceInit,0x9EA3B63A,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadPtr,0xEAAAC2D6,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadWritePtr,0xEAAAC2D7,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXDCLock,0x0F619456,0xCF39,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScaleOutput,0xB2024B50,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient,0xB2024B51,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTScale,0xB39FD742,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXEffect,0xE31FB81B,0x1335,0x11d1,0x81,0x89,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXLookupTable,0x01BAFC7F,0x9E63,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXRawSurface,0x09756C8A,0xD96A,0x11d1,0x90,0x62,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSLib,0x54314D1D,0x35FE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTransformFactory,0xD1FE6762,0xFC48,0x11D0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTaskManager,0x4CB26C03,0xFF93,0x11d0,0x81,0x7E,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTScale,0x555278E2,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurface,0x0E890F83,0x5F79,0x11D1,0x90,0x43,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurfaceModifier,0x3E669F1D,0x9C23,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXGradient,0xC6365470,0xF667,0x11d1,0x90,0x67,0x00,0xC0,0x4F,0xD9,0x18,0x9D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXBaseObject,0x17B59B2B,0x9CC8,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTransformFactory,0x6A950B2B,0xA971,0x11d1,0x81,0xC8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTransform,0x30A5FB78,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfacePick,0x30A5FB79,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTBindHost,0xD26BCE55,0xE9DC,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTaskManager,0x254DBBC1,0xF922,0x11d0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceFactory,0x144946F5,0xC4D4,0x11d1,0x81,0xD1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceModifier,0x9EA3B637,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurface,0xB39FD73F,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceInit,0x9EA3B639,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBSurfaceInit,0x9EA3B63A,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadPtr,0xEAAAC2D6,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadWritePtr,0xEAAAC2D7,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXDCLock,0x0F619456,0xCF39,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScaleOutput,0xB2024B50,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient,0xB2024B51,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTScale,0xB39FD742,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXEffect,0xE31FB81B,0x1335,0x11d1,0x81,0x89,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXLookupTable,0x01BAFC7F,0x9E63,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXRawSurface,0x09756C8A,0xD96A,0x11d1,0x90,0x62,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSLib,0x54314D1D,0x35FE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTransformFactory,0xD1FE6762,0xFC48,0x11D0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTaskManager,0x4CB26C03,0xFF93,0x11d0,0x81,0x7E,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTScale,0x555278E2,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurface,0x0E890F83,0x5F79,0x11D1,0x90,0x43,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurfaceModifier,0x3E669F1D,0x9C23,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXGradient,0xC6365470,0xF667,0x11d1,0x90,0x67,0x00,0xC0,0x4F,0xD9,0x18,0x9D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\extinc\dxvector.h ===
/*******************************************************************************
* DXVector.h *
*------------*
*   Description:
*       This is the header file for the vector and matrix classes.
*-------------------------------------------------------------------------------
*  Created By: Mike Arnstein                            Date: 04/11/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXVector_h
#define DXVector_h

#ifndef _INC_MATH
#include <math.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

//=== Constants ====================================================


//=== Class, Enum, Struct and Union Declarations ===================
class CDXMatrix4x4F;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================
float det4x4( CDXMatrix4x4F *pIn );
float det3x3( float a1, float a2, float a3, float b1, float b2, float b3, 
              float c1, float c2, float c3 );
float det2x2( float a, float b, float c, float d );

//=== Class, Struct and Union Definitions ==========================

/*** CDXVec ************
*   This template implements basic vector operations for each of the
*   union types
*/
#define CDXV_C CDXVec<TYPE, eBndType>
#define CDXV_T ((TYPE*)u.D)
#define CDXV_O( OtherVec ) ((TYPE*)OtherVec.u.D)

template<class TYPE, DXBNDTYPE eBndType>
class CDXVec : public DXVEC
{
  /*=== Methods =======*/
  public:
    /*--- Constructors ---*/
    CDXVec() { eType = eBndType; ZeroVector(); }
    CDXVec(BOOL bInit) { eType = eBndType; if (bInit) ZeroVector(); }
    CDXVec( TYPE x, TYPE y, TYPE z, TYPE t )
        { eType = eBndType; CDXV_T[DXB_X] = x; CDXV_T[DXB_Y] = y;
                            CDXV_T[DXB_Z] = z; CDXV_T[DXB_T] = t; }
    CDXVec( const CDXVec& Other ) { memcpy( this, (void *)&Other, sizeof(DXVEC) ); }
    CDXVec( const DXVEC Other ) { memcpy( this, &Other, sizeof(DXVEC) ); }
    operator TYPE *() { return CDXV_T; }
    operator const TYPE *() { return CDXV_T; }

    /*--- operations ---*/
    void ZeroVector( void ) { memset( u.D, 0, sizeof(TYPE) * 4); }

    /*--- operators ---*/
    TYPE&  operator[]( int index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( long index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( USHORT index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( DWORD index ) const { return CDXV_T[index]; }
    CDXV_C operator+(const CDXV_C& v);
    CDXV_C operator-(const CDXV_C& v);
    void   operator=(const CDXV_C& srcVector);
    void   operator+=(const CDXV_C& vOther);
    void   operator-=(const CDXV_C& vOther);
    BOOL   operator==(const CDXV_C& otherVector) const;
    BOOL   operator!=(const CDXV_C& otherVector) const;
};

template<class TYPE, DXBNDTYPE eBndType>
CDXV_C CDXV_C::operator+( const CDXV_C& srcVector )
{
    CDXV_C Result( this );
    CDXV_O( Result )[DXB_X] += CDXV_O( srcVector )[DXB_X];
    CDXV_O( Result )[DXB_Y] += CDXV_O( srcVector )[DXB_Y];
    CDXV_O( Result )[DXB_Z] += CDXV_O( srcVector )[DXB_Z];
    CDXV_O( Result )[DXB_T] += CDXV_O( srcVector )[DXB_T];
    return Result;
} /* CDXVec::operator+ */

template<class TYPE, DXBNDTYPE eBndType>
CDXV_C CDXV_C::operator-( const CDXV_C& srcVector )
{
    CDXV_C Result( this );
    CDXV_O( Result )[DXB_X] -= CDXV_O( srcVector )[DXB_X];
    CDXV_O( Result )[DXB_Y] -= CDXV_O( srcVector )[DXB_Y];
    CDXV_O( Result )[DXB_Z] -= CDXV_O( srcVector )[DXB_Z];
    CDXV_O( Result )[DXB_T] -= CDXV_O( srcVector )[DXB_T];
    return Result;
} /* CDXVec::operator- */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator=( const CDXV_C& srcVector )
{
    memcpy( this, &srcVector, sizeof(CDXVec) );
} /* CDXVec::operator= */

template<class TYPE, DXBNDTYPE eBndType>
BOOL CDXV_C::operator==(const CDXV_C& otherVector) const
{
    return !memcmp( this, &otherVector, sizeof(otherVector) );
} /* CDXVec::operator== */

template<class TYPE, DXBNDTYPE eBndType>
BOOL CDXV_C::operator!=(const CDXV_C& otherVector) const
{
    return memcmp( this, &otherVector, sizeof(otherVector) );
} /* CDXVec::operator!= */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator+=(const CDXV_C& vOther)
{
    CDXV_T[DXB_X] += CDXV_O( vOther )[DXB_X];
    CDXV_T[DXB_Y] += CDXV_O( vOther )[DXB_Y];
    CDXV_T[DXB_Z] += CDXV_O( vOther )[DXB_Z];
    CDXV_T[DXB_T] += CDXV_O( vOther )[DXB_T];
} /* CDXVec::operator+= */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator-=(const CDXVec& vOther)
{
    CDXV_T[DXB_X] -= CDXV_O( vOther )[DXB_X];
    CDXV_T[DXB_Y] -= CDXV_O( vOther )[DXB_Y];
    CDXV_T[DXB_Z] -= CDXV_O( vOther )[DXB_Z];
    CDXV_T[DXB_T] -= CDXV_O( vOther )[DXB_T];
} /* CDXVec::operator-= */

typedef CDXVec<long, DXBT_DISCRETE> CDXDVec;
typedef CDXVec<LONGLONG, DXBT_DISCRETE64> CDXDVec64;
typedef CDXVec<float, DXBT_CONTINUOUS> CDXCVec;
typedef CDXVec<double, DXBT_CONTINUOUS64> CDXCVec64;

/*** CDX2DXForm ************
*   This class implements basic matrix operation based on the GDI XFORM
*   structure.
*/
//const DX2DXFORM g_DX2DXFORMIdentity = { 1., 0., 0., 1., 0., 0., DX2DXO_IDENTITY };

class CDX2DXForm : public DX2DXFORM
{
  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDX2DXForm() { SetIdentity(); }
    CDX2DXForm( const CDX2DXForm& Other ) { memcpy( this, &Other, sizeof(*this) ); }
    CDX2DXForm( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); }

    /*--- methods ---*/
    void DetermineOp( void );
    void Set( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); DetermineOp(); }
    void ZeroMatrix( void ) { memset( this, 0, sizeof( *this ) ); }
    void SetIdentity( void ) {  
        eM11 = 1.;
        eM12 = 0.;
        eM21 = 0.;
        eM22 = 1.;
        eDx = 0.;
        eDy = 0.;
        eOp = DX2DXO_IDENTITY;
    }
    BOOL IsIdentity() const { return eOp == DX2DXO_IDENTITY; }
    void Scale( float sx, float sy );
    void Rotate( float Rotation );
    void Translate( float dx, float dy );
    BOOL Invert();
    void TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const;
    void TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const;
    void GetMinMaxScales( float& MinScale, float& MaxScale );

    /*--- operators ---*/
    DXFPOINT operator*( const DXFPOINT& v ) const;
    CDX2DXForm operator*( const CDX2DXForm& Other ) const;
};

//=== CDX2DXForm methods ==============================================================
inline void CDX2DXForm::DetermineOp( void )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        if( ( eM11 == 1. ) && ( eM22 == 1. ) )
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_IDENTITY):(DX2DXO_TRANSLATE);
        }
        else
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_SCALE):(DX2DXO_SCALE_AND_TRANS);
        }
    }
    else
    {
        eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_GENERAL):(DX2DXO_GENERAL_AND_TRANS);
    }
} /* CDX2DXForm::DetermineOp */

inline float DXSq( float f ) { return f * f; }

// This function computes the Min and Max scale that a matrix represents.
// In other words, what is the maximum/minimum length that a line of length 1
// could get stretched/shrunk to if the line was transformed by this matrix.
//
// The function uses eigenvalues; and returns two float numbers. Both are
// non-negative; and MaxScale >= MinScale.
// 
inline void CDX2DXForm::GetMinMaxScales( float& MinScale, float& MaxScale )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        // Let MinScale = abs(eM11)
        if (eM11 < 0)
            MinScale = -eM11;
        else
            MinScale = eM11;

        // Let MaxScale = abs(eM22)
        if (eM22 < 0)
            MaxScale = -eM22;
        else
            MaxScale = eM22;

        // Swap Min/Max if necessary
        if (MinScale > MaxScale)
        {
            float flTemp = MinScale;
            MinScale = MaxScale;
            MaxScale = flTemp;
        }
    }
    else
    {
        float t1 = DXSq(eM11) + DXSq(eM12) + DXSq(eM21) + DXSq(eM22);
        if( t1 == 0. )
        {
            MinScale = MaxScale = 0;
        }
        else
        {
            float t2 = (float)sqrt( (DXSq(eM12 + eM21) + DXSq(eM11 - eM22)) *
                                    (DXSq(eM12 - eM21) + DXSq(eM11 + eM22)) );

            // Due to floating point error; t1 may end up less than t2;
            // but that would mean that the min scale was small (relative
            // to max scale)
            if (t1 <= t2)
                MinScale = 0;
            else
                MinScale = (float)sqrt( (t1 - t2) * .5f );

            MaxScale = (float)sqrt( (t1 + t2) * .5f );
        }
    }
} /* CDX2DXForm::GetMinMaxScales */

inline void CDX2DXForm::Rotate( float Rotation )
{
    double Angle = Rotation * (3.1415926535/180.0);
    float CosZ   = (float)cos( Angle );
    float SinZ   = (float)sin( Angle );
    if (CosZ > 0.0F && CosZ < 0.0000005F)
    {
        CosZ = .0F;
    }
    if (SinZ > -0.0000005F && SinZ < .0F)
    {
        SinZ = .0F;
    }

    float M11 = ( CosZ * eM11 ) + ( SinZ * eM21 ); 
    float M21 = (-SinZ * eM11 ) + ( CosZ * eM21 );
    float M12 = ( CosZ * eM12 ) + ( SinZ * eM22 ); 
    float M22 = (-SinZ * eM12 ) + ( CosZ * eM22 );
    eM11 = M11; eM21 = M21; eM12 = M12; eM22 = M22;
    DetermineOp();
} /* CDX2DXForm::Rotate */

inline void CDX2DXForm::Scale( float sx, float sy )
{
    eM11 *= sx;
    eM12 *= sx;
    eDx  *= sx;
    eM21 *= sy;
    eM22 *= sy;
    eDy  *= sy;
    DetermineOp();
} /* CDX2DXForm::Scale */

inline void CDX2DXForm::Translate( float dx, float dy )
{
    eDx += dx;
    eDy += dy;
    DetermineOp();
} /* CDX2DXForm::Translate */

inline void CDX2DXForm::TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const
{
    ResultBnds = Bnds;
    if( eOp != DX2DXO_IDENTITY )
    {
        ResultBnds.u.D[DXB_X].Min = (long)(( eM11 * Bnds.u.D[DXB_X].Min ) + ( eM12 * Bnds.u.D[DXB_Y].Min ) + eDx);
        ResultBnds.u.D[DXB_X].Max = (long)(( eM11 * Bnds.u.D[DXB_X].Max ) + ( eM12 * Bnds.u.D[DXB_Y].Max ) + eDx);
        ResultBnds.u.D[DXB_Y].Min = (long)(( eM21 * Bnds.u.D[DXB_X].Min ) + ( eM22 * Bnds.u.D[DXB_Y].Min ) + eDy);
        ResultBnds.u.D[DXB_Y].Max = (long)(( eM21 * Bnds.u.D[DXB_X].Max ) + ( eM22 * Bnds.u.D[DXB_Y].Max ) + eDy);
    }
} /* CDX2DXForm::TransformBounds */

inline void CDX2DXForm::TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const
{
    ULONG i;
    switch( eOp )
    {
      case DX2DXO_IDENTITY:
        memcpy( OutPnts, InPnts, ulCount * sizeof( DXFPOINT ) );
        break;
      case DX2DXO_TRANSLATE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x + eDx;
            OutPnts[i].y = InPnts[i].y + eDy;
        }
        break;
      case DX2DXO_SCALE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x * eM11;
            OutPnts[i].y = InPnts[i].y * eM22;
        }
        break;
      case DX2DXO_SCALE_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = (InPnts[i].x * eM11) + eDx;
            OutPnts[i].y = (InPnts[i].y * eM22) + eDy;
        }
        break;
      case DX2DXO_GENERAL:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 );
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 );
        }
        break;
      case DX2DXO_GENERAL_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 ) + eDx;
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 ) + eDy;
        }
        break;
      default:
        _ASSERT( 0 );   // invalid operation id
    }
} /* CDX2DXForm::TransformPoints */

inline DXFPOINT CDX2DXForm::operator*( const DXFPOINT& v ) const
{
    DXFPOINT NewPnt;
    NewPnt.x = ( v.x * eM11 ) + ( v.y * eM12 ) + eDx;
    NewPnt.y = ( v.x * eM21 ) + ( v.y * eM22 ) + eDy;
    return NewPnt;
} /* CDX2DXForm::operator* */

inline CDX2DXForm CDX2DXForm::operator*( const CDX2DXForm& Other ) const
{
    DX2DXFORM x;
    x.eM11 = ( eM11 * Other.eM11 ) + ( eM12 * Other.eM21 );
    x.eM12 = ( eM11 * Other.eM12 ) + ( eM12 * Other.eM22 );
    x.eDx  = ( eM11 * Other.eDx  ) + ( eM12 * Other.eDy  ) + eDx;

    x.eM21 = ( eM21 * Other.eM11 ) + ( eM22 * Other.eM21 );
    x.eM22 = ( eM21 * Other.eM12 ) + ( eM22 * Other.eM22 );
    x.eDy  = ( eM21 * Other.eDx  ) + ( eM22 * Other.eDy  ) + eDy;
    return x;
} /* CDX2DXForm::operator*= */

inline BOOL CDX2DXForm::Invert()
{
    switch( eOp )
    {
    case DX2DXO_IDENTITY:
        break;
    case DX2DXO_TRANSLATE:
        eDx = -eDx;
        eDy = -eDy;
        break;
    case DX2DXO_SCALE:

        if (eM11 == 0.0 || eM22 == 0.0)
            return false;
        eM11 = 1.0f / eM11;
        eM22 = 1.0f / eM22;
        break;

    case DX2DXO_SCALE_AND_TRANS:
        {
            if (eM11 == 0.0f || eM22 == 0.0f)
                return false;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM11 and b is eDx
            float flOneOverA = 1.0f / eM11;
            eDx = -eDx * flOneOverA;
            eM11 = flOneOverA;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM22 and b is eDy

            flOneOverA = 1.0f / eM22;
            eDy = -eDy * flOneOverA;
            eM22 = flOneOverA;
            break;
        }

    case DX2DXO_GENERAL:
    case DX2DXO_GENERAL_AND_TRANS:
        {
            // The inverse of A=  |a b| is | d -c|*(1/Det) where Det is the determinant of A
            //                    |c d|    |-b  a|
            // Det(A) = ad - bc

            // Compute determininant
            float flDet = (eM11 * eM22 -  eM12 * eM21);
            if (flDet == 0.0f)
                return FALSE;

            float flCoef = 1.0f / flDet;

            // Remember old value of eM11
            float flM11Original = eM11;

            eM11 = flCoef * eM22;
            eM12 = -flCoef * eM12;
            eM21 = -flCoef * eM21;
            eM22 = flCoef * flM11Original;

            // If we have a translation; then we need to 
            // compute new values for that translation
            if (eOp == DX2DXO_GENERAL_AND_TRANS)
            {
                // Remember original value of eDx
                float eDxOriginal = eDx;

                eDx = -eM11 * eDx - eM12 * eDy;
                eDy = -eM21 * eDxOriginal - eM22 * eDy;
            }
        }
        break;

    default:
        _ASSERT( 0 );   // invalid operation id
    }

    // We don't need to call DetermineOp here
    // because the op doesn't change when inverted
    // i.e. a scale remains a scale, etc.

    return true;
} /* CDX2DXForm::Invert */

/*** CDXMatrix4x4F ************
*   This class implements basic matrix operation based on a 4x4 array.
*/
//const float g_DXMat4X4Identity[4][4] =
//{
//    { 1.0, 0. , 0. , 0.  },
//    { 0. , 1.0, 0. , 0.  },
//    { 0. , 0. , 1.0, 0.  },
//    { 0. , 0. , 0. , 1.0 }
//};

class CDXMatrix4x4F
{
public:
  /*=== Member Data ===*/
    float m_Coeff[4][4];

  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDXMatrix4x4F() { SetIdentity(); }
    CDXMatrix4x4F( const CDXMatrix4x4F& Other )
        { CopyMemory( (void *)&m_Coeff, (void *)&Other.m_Coeff, sizeof(m_Coeff) ); }
    CDXMatrix4x4F( DX2DXFORM& XForm );

    /*--- operations ---*/
    void ZeroMatrix( void ) { memset( m_Coeff, 0, sizeof( m_Coeff ) ); }
    void SetIdentity( void ) {
        memset( m_Coeff, 0, sizeof( m_Coeff ) );
        m_Coeff[0][0] = m_Coeff[1][1] = m_Coeff[2][2] = m_Coeff[3][3] = 1.0;
    }
    void SetCoefficients( float Coeff[4][4] ) { memcpy( m_Coeff, Coeff, sizeof( m_Coeff )); }
    void GetCoefficients( float Coeff[4][4] ) { memcpy( Coeff, m_Coeff, sizeof( m_Coeff )); }

    //BOOL IsIdentity();
    void Scale( float sx, float sy, float sz );
    void Rotate( float rx, float ry, float rz );
    void Translate( float dx, float dy, float dz );
    BOOL Invert();
    BOOL GetInverse( CDXMatrix4x4F *pIn );
    void Transpose();
    void GetTranspose( CDXMatrix4x4F *pIn );
    void GetAdjoint( CDXMatrix4x4F *pIn );
    HRESULT InitFromSafeArray( SAFEARRAY *psa );
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void TransformBounds( DXBNDS& Bnds, DXBNDS& ResultBnds );

    /*--- operators ---*/
    CDXDVec operator*( CDXDVec& v) const;
    CDXCVec operator*( CDXCVec& v) const;
    CDXMatrix4x4F operator*(CDXMatrix4x4F Matrix) const;
    void operator*=(CDXMatrix4x4F Matrix) const;
    void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix);
    void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix);
    void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix);
    BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const;
    BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const;
};

inline CDXMatrix4x4F::CDXMatrix4x4F( DX2DXFORM& XForm )
{
    SetIdentity();
    m_Coeff[0][0] = XForm.eM11;
    m_Coeff[0][1] = XForm.eM12;
    m_Coeff[1][0] = XForm.eM21;
    m_Coeff[1][1] = XForm.eM22;
    m_Coeff[0][3] = XForm.eDx;
    m_Coeff[1][3] = XForm.eDy;
}

// Additional Operations

inline void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix)
{
    CopyMemory( (void *)m_Coeff, (const void *)srcMatrix.m_Coeff, sizeof(srcMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator= */

inline BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const
{
    return !memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator== */

inline BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const
{
    return memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator!= */

inline void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix)
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] += otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator+= */

inline void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix) 
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] -= otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator-= */

inline CDXDVec CDXMatrix4x4F::operator*(CDXDVec& v) const
{
    CDXDVec t;
    float temp;
    temp = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[0] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[1] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[2] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    t[3] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    return t;
} /* CDXMatrix4x4F::operator*(DXDVEC) */

inline CDXCVec CDXMatrix4x4F::operator*(CDXCVec& v) const
{
    CDXCVec t;
    t[0] = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[1] = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[2] = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[3] = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    return t;
} /* CDXMatrix4x4F::operator*(DXCVEC) */

inline CDXMatrix4x4F CDXMatrix4x4F::operator*(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    return t;
} /* CDXMatrix4x4F::operator*(CDXMatrix4x4F) */
            
inline void CDXMatrix4x4F::operator*=(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    CopyMemory( (void *)m_Coeff, (void *)t.m_Coeff, sizeof(m_Coeff) );
} /* CDXMatrix4x4F::operator*=(CDXMatrix4x4F) */
            

inline void CDXMatrix4x4F::Scale( float sx, float sy, float sz )
{
    if( sx != 1. )
    {
        m_Coeff[0][0] *= sx;
        m_Coeff[0][1] *= sx;
        m_Coeff[0][2] *= sx;
        m_Coeff[0][3] *= sx;
    }
    if( sy != 1. )
    {
        m_Coeff[1][0] *= sy;
        m_Coeff[1][1] *= sy;
        m_Coeff[1][2] *= sy;
        m_Coeff[1][3] *= sy;
    }
    if( sz != 1. )
    {
        m_Coeff[2][0] *= sz;
        m_Coeff[2][1] *= sz;
        m_Coeff[2][2] *= sz;
        m_Coeff[2][3] *= sz;
    }
} /* CDXMatrix4x4F::Scale */

inline void CDXMatrix4x4F::Translate( float dx, float dy, float dz )
{
    float a, b, c, d;
    a = b = c = d = 0;
    if( dx != 0. )
    {
        a += m_Coeff[0][0]*dx;
        b += m_Coeff[0][1]*dx;
        c += m_Coeff[0][2]*dx;
        d += m_Coeff[0][3]*dx;
    }
    if( dy != 0. )
    {
        a += m_Coeff[1][0]*dy;
        b += m_Coeff[1][1]*dy;
        c += m_Coeff[1][2]*dy;
        d += m_Coeff[1][3]*dy;
    }
    if( dz != 0. )
    {
        a += m_Coeff[2][0]*dz;
        b += m_Coeff[2][1]*dz;
        c += m_Coeff[2][2]*dz;
        d += m_Coeff[2][3]*dz;
    }
    m_Coeff[3][0] += a;
    m_Coeff[3][1] += b;
    m_Coeff[3][2] += c;
    m_Coeff[3][3] += d;
} /* CDXMatrix4x4F::Translate */

inline void CDXMatrix4x4F::Rotate( float rx, float ry, float rz )
{
    const float l_dfCte = (const float)(3.1415926535/180.0);

    float lAngleY = 0.0;
    float lAngleX = 0.0;
    float lAngleZ = 0.0;
    float lCosX = 1.0;
    float lSinX = 0.0;
    float lCosY = 1.0;
    float lSinY = 0.0;
    float lCosZ = 1.0;
    float lSinZ = 0.0;

    // calculate rotation angle sines and cosines
    if( rx != 0 )
    {
        lAngleX = rx * l_dfCte;
        lCosX = (float)cos(lAngleX);
        lSinX = (float)sin(lAngleX);
        if (lCosX > 0.0F && lCosX < 0.0000005F)
        {
            lCosX = .0F;
        }
        if (lSinX > -0.0000005F && lSinX < .0F)
        {
            lSinX = .0F;
        }
    }
    if( ry != 0 )
    {
        lAngleY = ry * l_dfCte;
        lCosY = (float)cos(lAngleY);
        lSinY = (float)sin(lAngleY);
        if (lCosY > 0.0F && lCosY < 0.0000005F)
        {
            lCosY = .0F;
        }
        if (lSinY > -0.0000005F && lSinY < .0F)
        {
            lSinY = .0F;
        }
    }
    if( rz != 0 )
    {
        lAngleZ = rz * l_dfCte;
        lCosZ = (float)cos(lAngleZ);
        lSinZ = (float)sin(lAngleZ);
        if (lCosZ > 0.0F && lCosZ < 0.0000005F)
        {
            lCosZ = .0F;
        }
        if (lSinZ > -0.0000005F && lSinZ < .0F)
        {
            lSinZ = .0F;
        }
    }

    float u, v;
    int i;

    //--- X Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[1][i]; 
        v = m_Coeff[2][i];
        m_Coeff[1][i] = lCosX*u+lSinX*v; 
        m_Coeff[2][i] = -lSinX*u+lCosX*v;
    }

    //--- Y Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[2][i];
        m_Coeff[0][i] = lCosY*u-lSinY*v; 
        m_Coeff[2][i] = lSinY*u+lCosY*v;
    }

    //--- Z Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[1][i];
        m_Coeff[0][i] = lCosZ*u+lSinZ*v; 
        m_Coeff[1][i] = -lSinZ*u+lCosZ*v;
    }
}

/*
inline BOOL CDXMatrix4x4F::IsIdentity()
{
    return  !memcmp( m_Coeff, g_DXMat4X4Identity, sizeof(g_DXMat4X4Identity) );
} /* CDXMatrix4x4F::IsIdentity */


/*
   Uses Gaussian elimination to invert the 4 x 4 non-linear matrix in t and
   return the result in Mx.  The matrix t is destroyed in the process.
*/
inline BOOL CDXMatrix4x4F::Invert()
{
    int i,j,k,Pivot;
    float PValue;
    CDXMatrix4x4F Mx;
    Mx.SetIdentity();

/* Find pivot element.  Use partial pivoting by row */
    for( i = 0;i < 4; i++ )
    {
        Pivot = 0;
        for( j = 0; j < 4; j++ )
        {
            if( fabs(m_Coeff[i][j]) > fabs(m_Coeff[i][Pivot]) ) Pivot = j;
        }

        if( m_Coeff[i][Pivot] == 0.0 )
        {
            ZeroMatrix();   /* Singular Matrix */
            return FALSE; 
        }

/* Normalize */
        PValue = m_Coeff[i][Pivot];
        for( j = 0; j < 4; j++ )
        {
            m_Coeff[i][j] /= PValue;
            Mx.m_Coeff[i][j] /= PValue;
        }

/* Zeroing */
        for( j = 0; j < 4; j++ )
        {
            if( j != i )
            {
                PValue = m_Coeff[j][Pivot];
                for( k = 0; k < 4; k++ )
                {
                    m_Coeff[j][k] -= PValue*m_Coeff[i][k];
                    Mx.m_Coeff[j][k] -= PValue*Mx.m_Coeff[i][k];
                }
            }
        }
    }

/* Reorder rows */
    for( i = 0; i < 4; i++ )
    {
        if( m_Coeff[i][i] != 1.0 )
        {
            for( j = i + 1; j < 4; j++ )
                if( m_Coeff[j][i] == 1.0 ) break;
            if( j >= 4 )
            {
                ZeroMatrix();
                return FALSE;
            }

            //--- swap rows i and j of original
            for( k = 0; k < 4; k++ )
            {
                m_Coeff[i][k] += m_Coeff[j][k];
                m_Coeff[j][k] = m_Coeff[i][k] - m_Coeff[j][k];
                m_Coeff[i][k] -= m_Coeff[j][k];
            }
            
            //--- swap rows i and j of result
            for( k = 0; k < 4; k++ )
            {
                Mx.m_Coeff[i][k] += Mx.m_Coeff[j][k];
                Mx.m_Coeff[j][k] = Mx.m_Coeff[i][k] - Mx.m_Coeff[j][k];
                Mx.m_Coeff[i][k] -= Mx.m_Coeff[j][k];
            }
        }
    }
    *this = Mx;
    return TRUE;
} /* CDXMatrix4x4F::Invert */

inline void CDXMatrix4x4F::Transpose()
{
    float temp;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */

inline void CDXMatrix4x4F::GetTranspose( CDXMatrix4x4F *m )
{
    float temp;

    (*this) = *m;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */


/*
Matrix Inversion
by Richard Carling
from "Graphics Gems", Academic Press, 1990
*/

#define SMALL_NUMBER    1.e-8
/* 
 *   inverse( original_matrix, inverse_matrix )
 * 
 *    calculate the inverse of a 4x4 matrix
 *
 *     -1     
 *     A  = ___1__ adjoint A
 *         det A
 */

inline BOOL CDXMatrix4x4F::GetInverse( CDXMatrix4x4F *pIn )
{
    int i, j;
    float det;

    /* calculate the adjoint matrix */

    GetAdjoint( pIn );

    /*  calculate the 4x4 determinant
     *  if the determinant is zero, 
     *  then the inverse matrix is not unique.
     */

    det = det4x4( pIn );

    if( fabs( det ) < SMALL_NUMBER )
    {
        //  Non-singular matrix, no inverse!
        return FALSE;;
    }

    /* scale the adjoint matrix to get the inverse */

    for( i = 0; i < 4; i++ )
        for( j = 0; j < 4; j++ )
            m_Coeff[i][j] = m_Coeff[i][j] / det;

    return TRUE;
}


/* 
 *   adjoint( original_matrix, inverse_matrix )
 * 
 *     calculate the adjoint of a 4x4 matrix
 *
 *      Let  a   denote the minor determinant of matrix A obtained by
 *           ij
 *
 *      deleting the ith row and jth column from A.
 *
 *                    i+j
 *     Let  b   = (-1)    a
 *          ij            ji
 *
 *    The matrix B = (b  ) is the adjoint of A
 *                     ij
 */
inline void CDXMatrix4x4F::GetAdjoint( CDXMatrix4x4F *pIn )
{
    float a1, a2, a3, a4, b1, b2, b3, b4;
    float c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid  */
    /* selecting correct values  */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1];
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];


    /* row column labeling reversed since we transpose rows & columns */

    m_Coeff[0][0]  =   det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4);
    m_Coeff[1][0]  = - det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4);
    m_Coeff[2][0]  =   det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4);
    m_Coeff[3][0]  = - det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4);
        
    m_Coeff[0][1]  = - det3x3( b1, b3, b4, c1, c3, c4, d1, d3, d4);
    m_Coeff[1][1]  =   det3x3( a1, a3, a4, c1, c3, c4, d1, d3, d4);
    m_Coeff[2][1]  = - det3x3( a1, a3, a4, b1, b3, b4, d1, d3, d4);
    m_Coeff[3][1]  =   det3x3( a1, a3, a4, b1, b3, b4, c1, c3, c4);
        
    m_Coeff[0][2]  =   det3x3( b1, b2, b4, c1, c2, c4, d1, d2, d4);
    m_Coeff[1][2]  = - det3x3( a1, a2, a4, c1, c2, c4, d1, d2, d4);
    m_Coeff[2][2]  =   det3x3( a1, a2, a4, b1, b2, b4, d1, d2, d4);
    m_Coeff[3][2]  = - det3x3( a1, a2, a4, b1, b2, b4, c1, c2, c4);
        
    m_Coeff[0][3]  = - det3x3( b1, b2, b3, c1, c2, c3, d1, d2, d3);
    m_Coeff[1][3]  =   det3x3( a1, a2, a3, c1, c2, c3, d1, d2, d3);
    m_Coeff[2][3]  = - det3x3( a1, a2, a3, b1, b2, b3, d1, d2, d3);
    m_Coeff[3][3]  =   det3x3( a1, a2, a3, b1, b2, b3, c1, c2, c3);
}
/*
 * float = det4x4( matrix )
 * 
 * calculate the determinant of a 4x4 matrix.
 */
inline float det4x4( CDXMatrix4x4F *pIn )
{
    float ans;
    float a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid selecting */
    /*  correct elements */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1]; 
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];

    ans = a1 * det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4 )
        - b1 * det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4 )
        + c1 * det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4 )
        - d1 * det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4 );
    return ans;
}

/*
 * float = det3x3(  a1, a2, a3, b1, b2, b3, c1, c2, c3 )
 * 
 * calculate the determinant of a 3x3 matrix
 * in the form
 *
 *     | a1,  b1,  c1 |
 *     | a2,  b2,  c2 |
 *     | a3,  b3,  c3 |
 */

inline float det3x3( float a1, float a2, float a3, 
                     float b1, float b2, float b3, 
                     float c1, float c2, float c3 )
{
    float ans;

    ans = a1 * det2x2( b2, b3, c2, c3 )
        - b1 * det2x2( a2, a3, c2, c3 )
        + c1 * det2x2( a2, a3, b2, b3 );
    return ans;
}

/*
 * float = det2x2( float a, float b, float c, float d )
 * 
 * calculate the determinant of a 2x2 matrix.
 */
inline float det2x2( float a, float b, float c, float d )
{
    float ans = a * d - b * c;
    return ans;
}

inline HRESULT CDXMatrix4x4F::InitFromSafeArray( SAFEARRAY * /*pSA*/ )
{
    HRESULT hr = S_OK;
#if 0
    long *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(float) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                m_Bounds[i].Min = pData[i];
                m_Bounds[i].Max = pData[i+4];
                m_Bounds[i].SampleRate = SampleRate;
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::InitFromSafeArray */

inline HRESULT CDXMatrix4x4F::GetSafeArray( SAFEARRAY ** /*ppSA*/ ) const
{
    HRESULT hr = S_OK;
#if 0
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 16;

        if( !(pSA = SafeArrayCreate( VT_I4, 1, &rgsabound ) ) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            long *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = m_Bounds[i].Min;
                    pData[i+4] = m_Bounds[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::GetSafeArray */

inline void CDXMatrix4x4F::TransformBounds( DXBNDS& /*Bnds*/, DXBNDS& /*ResultBnds*/ )
{

} /* CDXMatrix4x4F::TransformBounds */

#endif  // DXVector_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\extinc\dxtmsft3.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft3.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtmsft3_h__
#define __dxtmsft3_h__

/* Forward Declarations */ 

#ifndef __IExplode_FWD_DEFINED__
#define __IExplode_FWD_DEFINED__
typedef interface IExplode IExplode;
#endif 	/* __IExplode_FWD_DEFINED__ */


#ifndef __ICrShatter_FWD_DEFINED__
#define __ICrShatter_FWD_DEFINED__
typedef interface ICrShatter ICrShatter;
#endif 	/* __ICrShatter_FWD_DEFINED__ */


#ifndef __IDXTBlackHole_FWD_DEFINED__
#define __IDXTBlackHole_FWD_DEFINED__
typedef interface IDXTBlackHole IDXTBlackHole;
#endif 	/* __IDXTBlackHole_FWD_DEFINED__ */


#ifndef __IDXTRoll_FWD_DEFINED__
#define __IDXTRoll_FWD_DEFINED__
typedef interface IDXTRoll IDXTRoll;
#endif 	/* __IDXTRoll_FWD_DEFINED__ */


#ifndef __IDXTSpin_FWD_DEFINED__
#define __IDXTSpin_FWD_DEFINED__
typedef interface IDXTSpin IDXTSpin;
#endif 	/* __IDXTSpin_FWD_DEFINED__ */


#ifndef __IRipple_FWD_DEFINED__
#define __IRipple_FWD_DEFINED__
typedef interface IRipple IRipple;
#endif 	/* __IRipple_FWD_DEFINED__ */


#ifndef __IHeightField_FWD_DEFINED__
#define __IHeightField_FWD_DEFINED__
typedef interface IHeightField IHeightField;
#endif 	/* __IHeightField_FWD_DEFINED__ */


#ifndef __IDXTMetaStream_FWD_DEFINED__
#define __IDXTMetaStream_FWD_DEFINED__
typedef interface IDXTMetaStream IDXTMetaStream;
#endif 	/* __IDXTMetaStream_FWD_DEFINED__ */


#ifndef __IDXTText3D_FWD_DEFINED__
#define __IDXTText3D_FWD_DEFINED__
typedef interface IDXTText3D IDXTText3D;
#endif 	/* __IDXTText3D_FWD_DEFINED__ */


#ifndef __IDXTShapes_FWD_DEFINED__
#define __IDXTShapes_FWD_DEFINED__
typedef interface IDXTShapes IDXTShapes;
#endif 	/* __IDXTShapes_FWD_DEFINED__ */


#ifndef __Explode_FWD_DEFINED__
#define __Explode_FWD_DEFINED__

#ifdef __cplusplus
typedef class Explode Explode;
#else
typedef struct Explode Explode;
#endif /* __cplusplus */

#endif 	/* __Explode_FWD_DEFINED__ */


#ifndef __ExplodeProp_FWD_DEFINED__
#define __ExplodeProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class ExplodeProp ExplodeProp;
#else
typedef struct ExplodeProp ExplodeProp;
#endif /* __cplusplus */

#endif 	/* __ExplodeProp_FWD_DEFINED__ */


#ifndef __Ripple_FWD_DEFINED__
#define __Ripple_FWD_DEFINED__

#ifdef __cplusplus
typedef class Ripple Ripple;
#else
typedef struct Ripple Ripple;
#endif /* __cplusplus */

#endif 	/* __Ripple_FWD_DEFINED__ */


#ifndef __RipProp_FWD_DEFINED__
#define __RipProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class RipProp RipProp;
#else
typedef struct RipProp RipProp;
#endif /* __cplusplus */

#endif 	/* __RipProp_FWD_DEFINED__ */


#ifndef __HeightField_FWD_DEFINED__
#define __HeightField_FWD_DEFINED__

#ifdef __cplusplus
typedef class HeightField HeightField;
#else
typedef struct HeightField HeightField;
#endif /* __cplusplus */

#endif 	/* __HeightField_FWD_DEFINED__ */


#ifndef __HtFieldProp_FWD_DEFINED__
#define __HtFieldProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class HtFieldProp HtFieldProp;
#else
typedef struct HtFieldProp HtFieldProp;
#endif /* __cplusplus */

#endif 	/* __HtFieldProp_FWD_DEFINED__ */


#ifndef __DXTMetaStream_FWD_DEFINED__
#define __DXTMetaStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaStream DXTMetaStream;
#else
typedef struct DXTMetaStream DXTMetaStream;
#endif /* __cplusplus */

#endif 	/* __DXTMetaStream_FWD_DEFINED__ */


#ifndef __DXTMetaStreamProp_FWD_DEFINED__
#define __DXTMetaStreamProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaStreamProp DXTMetaStreamProp;
#else
typedef struct DXTMetaStreamProp DXTMetaStreamProp;
#endif /* __cplusplus */

#endif 	/* __DXTMetaStreamProp_FWD_DEFINED__ */


#ifndef __DXTText3D_FWD_DEFINED__
#define __DXTText3D_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTText3D DXTText3D;
#else
typedef struct DXTText3D DXTText3D;
#endif /* __cplusplus */

#endif 	/* __DXTText3D_FWD_DEFINED__ */


#ifndef __DXTText3DPP_FWD_DEFINED__
#define __DXTText3DPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTText3DPP DXTText3DPP;
#else
typedef struct DXTText3DPP DXTText3DPP;
#endif /* __cplusplus */

#endif 	/* __DXTText3DPP_FWD_DEFINED__ */


#ifndef __CrShatter_FWD_DEFINED__
#define __CrShatter_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrShatter CrShatter;
#else
typedef struct CrShatter CrShatter;
#endif /* __cplusplus */

#endif 	/* __CrShatter_FWD_DEFINED__ */


#ifndef __CrShatterPP_FWD_DEFINED__
#define __CrShatterPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrShatterPP CrShatterPP;
#else
typedef struct CrShatterPP CrShatterPP;
#endif /* __cplusplus */

#endif 	/* __CrShatterPP_FWD_DEFINED__ */


#ifndef __DXTBlackHole_FWD_DEFINED__
#define __DXTBlackHole_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTBlackHole DXTBlackHole;
#else
typedef struct DXTBlackHole DXTBlackHole;
#endif /* __cplusplus */

#endif 	/* __DXTBlackHole_FWD_DEFINED__ */


#ifndef __DXTBlackHolePP_FWD_DEFINED__
#define __DXTBlackHolePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTBlackHolePP DXTBlackHolePP;
#else
typedef struct DXTBlackHolePP DXTBlackHolePP;
#endif /* __cplusplus */

#endif 	/* __DXTBlackHolePP_FWD_DEFINED__ */


#ifndef __DXTRoll_FWD_DEFINED__
#define __DXTRoll_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRoll DXTRoll;
#else
typedef struct DXTRoll DXTRoll;
#endif /* __cplusplus */

#endif 	/* __DXTRoll_FWD_DEFINED__ */


#ifndef __DXTRollPP_FWD_DEFINED__
#define __DXTRollPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRollPP DXTRollPP;
#else
typedef struct DXTRollPP DXTRollPP;
#endif /* __cplusplus */

#endif 	/* __DXTRollPP_FWD_DEFINED__ */


#ifndef __DXTSpin_FWD_DEFINED__
#define __DXTSpin_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTSpin DXTSpin;
#else
typedef struct DXTSpin DXTSpin;
#endif /* __cplusplus */

#endif 	/* __DXTSpin_FWD_DEFINED__ */


#ifndef __DXTSpinPP_FWD_DEFINED__
#define __DXTSpinPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTSpinPP DXTSpinPP;
#else
typedef struct DXTSpinPP DXTSpinPP;
#endif /* __cplusplus */

#endif 	/* __DXTSpinPP_FWD_DEFINED__ */


#ifndef __DXTShapes_FWD_DEFINED__
#define __DXTShapes_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTShapes DXTShapes;
#else
typedef struct DXTShapes DXTShapes;
#endif /* __cplusplus */

#endif 	/* __DXTShapes_FWD_DEFINED__ */


#ifndef __DXTShapesPP_FWD_DEFINED__
#define __DXTShapesPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTShapesPP DXTShapesPP;
#else
typedef struct DXTShapesPP DXTShapesPP;
#endif /* __cplusplus */

#endif 	/* __DXTShapesPP_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxtmsft3_0000 */
/* [local] */ 

typedef 
enum EXPLODEDISPID
    {	DISPID_Explode_Tumble	= DISPID_DXE_NEXT_ID,
	DISPID_Explode_MaxRotations	= DISPID_Explode_Tumble + 1,
	DISPID_Explode_FinalVelocity	= DISPID_Explode_MaxRotations + 1,
	DISPID_Explode_PositionJump	= DISPID_Explode_FinalVelocity + 1,
	DISPID_Explode_DecayTime	= DISPID_Explode_PositionJump + 1
    }	EXPLODEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0000_v0_0_s_ifspec;

#ifndef __IExplode_INTERFACE_DEFINED__
#define __IExplode_INTERFACE_DEFINED__

/* interface IExplode */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IExplode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("141DBAF0-55FB-11D1-B83E-00A0C933BE86")
    IExplode : public IDXEffect
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Tumble( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Tumble( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxRotations( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxRotations( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FinalVelocity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FinalVelocity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PositionJump( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PositionJump( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DecayTime( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DecayTime( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExplode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExplode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExplode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IExplode __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IExplode __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IExplode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IExplode __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Tumble )( 
            IExplode __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Tumble )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxRotations )( 
            IExplode __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxRotations )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FinalVelocity )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FinalVelocity )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PositionJump )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PositionJump )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DecayTime )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DecayTime )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        END_INTERFACE
    } IExplodeVtbl;

    interface IExplode
    {
        CONST_VTBL struct IExplodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExplode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExplode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExplode_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IExplode_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IExplode_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IExplode_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IExplode_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IExplode_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IExplode_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IExplode_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IExplode_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IExplode_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IExplode_put_Tumble(This,newVal)	\
    (This)->lpVtbl -> put_Tumble(This,newVal)

#define IExplode_get_Tumble(This,pVal)	\
    (This)->lpVtbl -> get_Tumble(This,pVal)

#define IExplode_put_MaxRotations(This,newVal)	\
    (This)->lpVtbl -> put_MaxRotations(This,newVal)

#define IExplode_get_MaxRotations(This,pVal)	\
    (This)->lpVtbl -> get_MaxRotations(This,pVal)

#define IExplode_put_FinalVelocity(This,newVal)	\
    (This)->lpVtbl -> put_FinalVelocity(This,newVal)

#define IExplode_get_FinalVelocity(This,pVal)	\
    (This)->lpVtbl -> get_FinalVelocity(This,pVal)

#define IExplode_put_PositionJump(This,newVal)	\
    (This)->lpVtbl -> put_PositionJump(This,newVal)

#define IExplode_get_PositionJump(This,pVal)	\
    (This)->lpVtbl -> get_PositionJump(This,pVal)

#define IExplode_put_DecayTime(This,newVal)	\
    (This)->lpVtbl -> put_DecayTime(This,newVal)

#define IExplode_get_DecayTime(This,pVal)	\
    (This)->lpVtbl -> get_DecayTime(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_Tumble_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IExplode_put_Tumble_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_Tumble_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_Tumble_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_MaxRotations_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IExplode_put_MaxRotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_MaxRotations_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_MaxRotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_FinalVelocity_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IExplode_put_FinalVelocity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_FinalVelocity_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_FinalVelocity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_PositionJump_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IExplode_put_PositionJump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_PositionJump_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_PositionJump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_DecayTime_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IExplode_put_DecayTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_DecayTime_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_DecayTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExplode_INTERFACE_DEFINED__ */


#ifndef __ICrShatter_INTERFACE_DEFINED__
#define __ICrShatter_INTERFACE_DEFINED__

/* interface ICrShatter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrShatter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63500AE1-0858-11D2-8CE4-00C04F8ECB10")
    ICrShatter : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_seed( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_seed( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_maxShards( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_maxShards( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_depth( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_depth( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_backColor( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_backColor( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateX( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateX( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateY( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateY( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateZ( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateZ( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateDeltaX( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateDeltaX( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateDeltaY( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateDeltaY( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateDeltaZ( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateDeltaZ( 
            /* [in] */ short newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrShatterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrShatter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrShatter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrShatter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_seed )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_seed )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_maxShards )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_maxShards )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_depth )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_depth )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_backColor )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_backColor )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateX )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateX )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateY )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateY )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateZ )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateZ )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateDeltaX )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateDeltaX )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateDeltaY )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateDeltaY )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateDeltaZ )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateDeltaZ )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        END_INTERFACE
    } ICrShatterVtbl;

    interface ICrShatter
    {
        CONST_VTBL struct ICrShatterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrShatter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrShatter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrShatter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrShatter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrShatter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrShatter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrShatter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrShatter_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrShatter_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrShatter_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrShatter_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrShatter_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrShatter_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrShatter_get_seed(This,pVal)	\
    (This)->lpVtbl -> get_seed(This,pVal)

#define ICrShatter_put_seed(This,newVal)	\
    (This)->lpVtbl -> put_seed(This,newVal)

#define ICrShatter_get_maxShards(This,pVal)	\
    (This)->lpVtbl -> get_maxShards(This,pVal)

#define ICrShatter_put_maxShards(This,newVal)	\
    (This)->lpVtbl -> put_maxShards(This,newVal)

#define ICrShatter_get_depth(This,pVal)	\
    (This)->lpVtbl -> get_depth(This,pVal)

#define ICrShatter_put_depth(This,newVal)	\
    (This)->lpVtbl -> put_depth(This,newVal)

#define ICrShatter_get_backColor(This,pVal)	\
    (This)->lpVtbl -> get_backColor(This,pVal)

#define ICrShatter_put_backColor(This,newVal)	\
    (This)->lpVtbl -> put_backColor(This,newVal)

#define ICrShatter_get_evacuateX(This,pVal)	\
    (This)->lpVtbl -> get_evacuateX(This,pVal)

#define ICrShatter_put_evacuateX(This,newVal)	\
    (This)->lpVtbl -> put_evacuateX(This,newVal)

#define ICrShatter_get_evacuateY(This,pVal)	\
    (This)->lpVtbl -> get_evacuateY(This,pVal)

#define ICrShatter_put_evacuateY(This,newVal)	\
    (This)->lpVtbl -> put_evacuateY(This,newVal)

#define ICrShatter_get_evacuateZ(This,pVal)	\
    (This)->lpVtbl -> get_evacuateZ(This,pVal)

#define ICrShatter_put_evacuateZ(This,newVal)	\
    (This)->lpVtbl -> put_evacuateZ(This,newVal)

#define ICrShatter_get_evacuateDeltaX(This,pVal)	\
    (This)->lpVtbl -> get_evacuateDeltaX(This,pVal)

#define ICrShatter_put_evacuateDeltaX(This,newVal)	\
    (This)->lpVtbl -> put_evacuateDeltaX(This,newVal)

#define ICrShatter_get_evacuateDeltaY(This,pVal)	\
    (This)->lpVtbl -> get_evacuateDeltaY(This,pVal)

#define ICrShatter_put_evacuateDeltaY(This,newVal)	\
    (This)->lpVtbl -> put_evacuateDeltaY(This,newVal)

#define ICrShatter_get_evacuateDeltaZ(This,pVal)	\
    (This)->lpVtbl -> get_evacuateDeltaZ(This,pVal)

#define ICrShatter_put_evacuateDeltaZ(This,newVal)	\
    (This)->lpVtbl -> put_evacuateDeltaZ(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_seed_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_seed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_seed_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB ICrShatter_put_seed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_maxShards_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_maxShards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_maxShards_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB ICrShatter_put_maxShards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_depth_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_depth_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrShatter_put_depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_backColor_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_backColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_backColor_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrShatter_put_backColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateDeltaX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateDeltaX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateDeltaX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateDeltaX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateDeltaY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateDeltaY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateDeltaY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateDeltaY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateDeltaZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateDeltaZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateDeltaZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateDeltaZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrShatter_INTERFACE_DEFINED__ */


#ifndef __IDXTBlackHole_INTERFACE_DEFINED__
#define __IDXTBlackHole_INTERFACE_DEFINED__

/* interface IDXTBlackHole */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTBlackHole;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C3853C21-3F2E-11D2-9900-0000F803FF7A")
    IDXTBlackHole : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HoleX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HoleX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HoleY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HoleY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HoleZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HoleZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StretchPercent( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StretchPercent( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FallX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FallX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FallY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FallY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FallZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FallZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpiralX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpiralX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpiralY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpiralY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpiralZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpiralZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Rotations( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Rotations( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Movement( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Movement( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTBlackHoleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTBlackHole __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTBlackHole __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HoleX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HoleX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HoleY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HoleY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HoleZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HoleZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StretchPercent )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StretchPercent )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FallX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FallX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FallY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FallY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FallZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FallZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpiralX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpiralX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpiralY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpiralY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpiralZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpiralZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rotations )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Rotations )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Movement )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Movement )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTBlackHoleVtbl;

    interface IDXTBlackHole
    {
        CONST_VTBL struct IDXTBlackHoleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTBlackHole_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTBlackHole_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTBlackHole_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTBlackHole_GetTypeInfoCount(This,pctinfo)	\
    (This)->l