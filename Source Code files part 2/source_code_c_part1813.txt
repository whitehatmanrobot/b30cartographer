RAM)&biis
        };

        _GenerateDialogTitle(szTitle, ARRAYSIZE(szTitle));

        if (RegOpenKeyEx(HKEY_CURRENT_USER, COPYMOVETO_REGKEY, 0, KEY_READ | KEY_WRITE, &hkey) == ERROR_SUCCESS)
        {
            pstrm = OpenRegStream(hkey, COPYMOVETO_SUBKEY, COPYMOVETO_VALUE, STGM_READWRITE);
            if (pstrm)  // OpenRegStream will fail if the reg key is empty.
                ILLoadFromStream(pstrm, &pidlSelectedFolder);

            // This will switch the pidl to My Docs if the pidl does not exist.
            // This prevents us from having My Computer as the default (that's what happens if our
            // initial set selected call fails).
            // Note: ideally, we would check in BFFM_INITIALIZED, if our BFFM_SETSELECTION failed
            // then do a BFFM_SETSELECTION on My Documents instead.  However, BFFM_SETSELECTION always
            // returns zero (it's doc'd to do this to, so we can't change).  So we do the validation
            // here instead.  There is still a small chance that this folder will be deleted in between our
            // check here, and when we call BFFM_SETSELECTION, but oh well.
            _BFFSwitchToMyDocsIfPidlNotExist(&pidlSelectedFolder);
        }

        if (_DidZoneCheckPass(m_pidlSource))
        {
            // Go modal during the UI.
            IUnknown_EnableModless(_punkSite, FALSE);
            pidlFolder = SHBrowseForFolder(&bi);
            IUnknown_EnableModless(_punkSite, TRUE);
            if (pidlFolder)
            {
                hres = _DoDragDrop(pici, pidlFolder);
            }
            else
                hres = E_FAIL;
        }
        else
            hres = E_FAIL;

        if (pstrm)
        {
            if (S_OK == hres)
            {
                TCHAR szFolder[MAX_PATH];
                
                if (SUCCEEDED(SHGetNameAndFlags(pidlFolder, SHGDN_FORPARSING, szFolder, SIZECHARS(szFolder), NULL))
                    && !PathIsRemote(szFolder))
                {
                    ULARGE_INTEGER uli;

                    // rewind the stream to the beginning so that when we
                    // add a new pidl it does not get appended to the first one
                    pstrm->Seek(g_li0, STREAM_SEEK_SET, &uli);
                    ILSaveToStream(pstrm, pidlFolder);

#if DEBUG
                    // pfortier 3/23/01:
                    // We've been seeing a problem where the result of this is the My Computer folder.
                    // Since we can never copy there, that doesn't make any sense.
                    // ASSERT that this isn't true!
                    LPITEMIDLIST pidlMyComputer;
                    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer)))
                    {
                        ASSERTMSG(!ILIsEqual(pidlMyComputer, pidlFolder), "SHBrowseForFolder returned My Computer as a copyto destination!");
                        ILFree(pidlMyComputer);
                    }
#endif

                }
            }

            pstrm->Release();
        }

        if (hkey)
        {
            RegCloseKey(hkey);
        }

        ILFree(pidlFolder); // ILFree() works for NULL pidls.
        ILFree(pidlSelectedFolder); // ILFree() works for NULL pidls.
    }
    else
        hres = E_INVALIDARG;

    return hres;
}

HRESULT CCopyMoveToMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

HRESULT CCopyMoveToMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg, wParam, lParam, NULL);
}

HRESULT CCopyMoveToMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hr = S_OK;

    switch(uMsg)
    {
    //case WM_INITMENUPOPUP:
    //    break;

    case WM_DRAWITEM:
    {
        DRAWITEMSTRUCT * pdi = (DRAWITEMSTRUCT *)lParam;
    
        if (pdi->CtlType == ODT_MENU && pdi->itemID == m_idCmdFirst) 
        {
            FileMenu_DrawItem(NULL, pdi);
        }
        break;
    }

    case WM_MEASUREITEM:
    {
        MEASUREITEMSTRUCT *pmi = (MEASUREITEMSTRUCT *)lParam;
    
        if (pmi->CtlType == ODT_MENU && pmi->itemID == m_idCmdFirst) 
        {
            FileMenu_MeasureItem(NULL, pmi);
        }
        break;
    }

    default:
        hr = E_NOTIMPL;
        break;
    }

    if (plres)
        *plres = 0;

    return hr;
}

HRESULT CCopyMoveToMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    HRESULT hres = S_OK;

    if (!pdtobj)
        return E_INVALIDARG;

    IUnknown_Set((IUnknown **) &m_pdtobj, (IUnknown *) pdtobj);
    ASSERT(m_pdtobj);

    // (jeffreys) pidlFolder is now NULL when pdtobj is non-NULL
    // See comments above the call to HDXA_AppendMenuItems2 in
    // defcm.cpp!CDefFolderMenu::QueryContextMenu.  Raid #232106
    if (!pidlFolder)
    {
        hres = PidlFromDataObject(m_pdtobj, &m_pidlSource);
        if (SUCCEEDED(hres))
        {
            // Make it the parent pidl of this pidl
            if (!ILRemoveLastID(m_pidlSource))
            {
                hres = E_INVALIDARG;
            }
        }
    }
    else if (!Pidl_Set(&m_pidlSource, pidlFolder))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

HRESULT CCopyMoveToMenu::ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    LPITEMIDLIST pidlNotShown;
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlFolderActual; // Why is pidlFolder is NULL???
    if (SUCCEEDED(SHGetIDListFromUnk(psf, &pidlFolderActual)))
    {
        LPITEMIDLIST pidlFull = ILCombine(pidlFolderActual, pidlItem);
        if (pidlFull)
        {
            // Filter out control panel and recycle bin.
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlNotShown)))
            {
                if (ILIsEqual(pidlFull, pidlNotShown))
                    hr = S_FALSE;

                ILFree(pidlNotShown);
            }

            if ((hr == S_OK) && (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_BITBUCKET, &pidlNotShown))))
            {
                if (ILIsEqual(pidlFull, pidlNotShown))
                    hr = S_FALSE;

                ILFree(pidlNotShown);
            }
            

            ILFree(pidlFull);
        }
        ILFree(pidlFolderActual);
    }
    return hr;
}


HRESULT CCopyMoveToMenu::GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags)
{
    // Only want drop targets - this doesn't appear to work.
    *pgrfFlags |= SFGAO_DROPTARGET;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\dcompp.cpp ===
#include "stdafx.h"
#pragma hdrstop

class CCompPreview
{
public:
protected:
    HWND _hwnd;
    HBITMAP _hbmMonitor;
    HDC _hdcCompMemory;
    int _iScreenWidth;
    int _iScreenHeight;
    int _iXBorders;
    int _iYBorders;

    static LRESULT CALLBACK CompPreviewWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
    friend BOOL RegisterCompPreviewClass(void);

    LONG _OnCreate(HWND hwnd);
    void _OnDestroy(void);
    void _OnPaint(void);
    void _RecalcMetrics(void);
};

void CCompPreview::_RecalcMetrics(void)
{
    RECT rect;
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rect, FALSE);
    _iScreenWidth = rect.right - rect.left;
    _iScreenHeight = rect.bottom - rect.top;
    _iXBorders = (2 * GET_CXSIZE);
    _iYBorders = (GET_CYSIZE + GET_CYCAPTION);
}

LONG CCompPreview::_OnCreate(HWND hwnd)
{
    LONG lRet = 0;

    _hwnd = hwnd;
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)this);

    HDC hdc = GetDC(NULL);
    _hdcCompMemory = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);

    _hbmMonitor = LoadMonitorBitmap();

    if (_hbmMonitor == NULL)
    {
        lRet = -1;
    }

    _RecalcMetrics();  //Initialize the screen width and height etc.,

    return lRet;
}

void CCompPreview::_OnDestroy()
{
    if (_hbmMonitor)
    {
        DeleteObject(_hbmMonitor);
    }
    if (_hdcCompMemory)
    {
        DeleteDC(_hdcCompMemory);
    }
    delete this;
}

void CCompPreview::_OnPaint()
{
    PAINTSTRUCT     ps;
    BITMAP          bm;
    RECT            rc;

    BeginPaint(_hwnd,&ps);
    if (_hbmMonitor)
    {
        DWORD dwDefWidth = (_iScreenWidth / (COMPONENT_PER_ROW + 1)) - _iXBorders;
        DWORD dwDefHeight = (_iScreenHeight / (COMPONENT_PER_COL + 1)) - _iYBorders;

        //
        // Select the monitor bitmap into an hdc.
        //
        HBITMAP hbmOld = (HBITMAP)SelectObject(_hdcCompMemory, _hbmMonitor);

        //
        // Get the size of the bitmap and of our window.
        //
        GetClientRect(_hwnd, &rc);
        GetObject(_hbmMonitor, sizeof(bm), &bm);

        //
        // Center the bitmap in the window.
        //
        rc.left = ( rc.right - bm.bmWidth ) / 2;
        rc.top = ( rc.bottom - bm.bmHeight ) / 2;
        BitBlt(ps.hdc, rc.left, rc.top, bm.bmWidth, bm.bmHeight, _hdcCompMemory,
            0, 0, SRCCOPY);

        SelectObject(_hdcCompMemory, hbmOld);

        //
        // From now on, only paint in the "monitor" area of the bitmap.
        //
        IntersectClipRect(ps.hdc, rc.left + MON_X, rc.top + MON_Y, rc.left + MON_X + MON_DX, rc.top + MON_Y + MON_DY);

        //
        // Determine who the selected component is.
        //
        int iSelectedComponent;
        SendMessage(GetParent(_hwnd), WM_COMP_GETCURSEL, 0, (LPARAM)&iSelectedComponent);

        //
        // Create two new brush/pen combos, and remember the original
        // brush & pen.
        //
        HBRUSH hbrushActComp = CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION));
        HPEN hpenActComp = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_CAPTIONTEXT));

        HBRUSH hbrushComp = CreateSolidBrush(GetSysColor(COLOR_INACTIVECAPTION));
        HPEN hpenComp = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_INACTIVECAPTIONTEXT));

        HBRUSH hbrushOld = (HBRUSH)SelectObject(ps.hdc, hbrushComp);
        HPEN hpenOld = (HPEN)SelectObject(ps.hdc, hpenComp);

        int iPrimaryMonitorX = -GetSystemMetrics(SM_XVIRTUALSCREEN);
        int iPrimaryMonitorY = -GetSystemMetrics(SM_YVIRTUALSCREEN);
        int iPrimaryMonitorCX = GetSystemMetrics(SM_CXSCREEN);
        int iPrimaryMonitorCY = GetSystemMetrics(SM_CYSCREEN);
        //
        // Draw each component in the "monitor" area of the bitmap.
        //
        int i, cComp;
        g_pActiveDeskAdv->GetDesktopItemCount(&cComp, 0);
        for (i=0; i < cComp; i++)
        {
            COMPONENT comp;
            comp.dwSize = sizeof(COMPONENT);
            if (SUCCEEDED(g_pActiveDeskAdv->GetDesktopItem(i, &comp, 0)) && (comp.fChecked))
            {
                // FEATURE: We show only components in the primary monitor in IE v4.01
                if (comp.cpPos.iLeft < iPrimaryMonitorX
                        || comp.cpPos.iLeft > iPrimaryMonitorX + iPrimaryMonitorCX
                        || comp.cpPos.iTop < iPrimaryMonitorY
                        || comp.cpPos.iTop > iPrimaryMonitorY + iPrimaryMonitorCY)
                {
                    continue;
                }

                // If the width or Height is -1, then we don't know what the actual
                // size is going to be. So, we try to give a default size here for comp
                // in the preview bitmap.
                DWORD dwCompWidth = (comp.cpPos.dwWidth == COMPONENT_DEFAULT_WIDTH)? dwDefWidth : comp.cpPos.dwWidth;
                DWORD dwCompHeight = (comp.cpPos.dwHeight == COMPONENT_DEFAULT_HEIGHT)? dwDefHeight : comp.cpPos.dwHeight;

                if (i == iSelectedComponent)
                {
                    SelectObject(ps.hdc, hbrushActComp);
                    SelectObject(ps.hdc, hpenActComp);
                }

                int nLeft = rc.left + MON_X + MulDiv(comp.cpPos.iLeft - iPrimaryMonitorX, MON_DX, GetDeviceCaps(_hdcCompMemory, HORZRES));
                int nTop = rc.top + MON_Y + MulDiv(comp.cpPos.iTop - iPrimaryMonitorY, MON_DY, GetDeviceCaps(_hdcCompMemory, VERTRES));
                int nRight = rc.left + MON_X + MulDiv((comp.cpPos.iLeft - iPrimaryMonitorX) + dwCompWidth, MON_DX, GetDeviceCaps(_hdcCompMemory, HORZRES));
                int nBottom = rc.top + MON_Y + MulDiv((comp.cpPos.iTop - iPrimaryMonitorY)+ dwCompHeight, MON_DY, GetDeviceCaps(_hdcCompMemory, VERTRES));

                Rectangle(ps.hdc, nLeft, nTop, nRight, nBottom);

                if (i == iSelectedComponent)
                {
                    SelectObject(ps.hdc, hbrushComp);
                    SelectObject(ps.hdc, hpenComp);
                }
            }
        }

        SelectObject(ps.hdc, hpenOld);
        SelectObject(ps.hdc, hbrushOld);

        DeleteObject(hpenComp);
        DeleteObject(hbrushComp);
        DeleteObject(hpenActComp);
        DeleteObject(hbrushActComp);
    }

    EndPaint(_hwnd,&ps);
}

LRESULT CALLBACK CCompPreview::CompPreviewWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    CCompPreview *pcp = (CCompPreview *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(message)
    {
    case WM_CREATE:
        pcp = new CCompPreview();
        return pcp ? pcp->_OnCreate(hwnd) : -1;

    case WM_DESTROY:
        pcp->_OnDestroy();
        break;

    case WM_PAINT:
        pcp->_OnPaint();
        return 0;

    case WM_DISPLAYCHANGE:
    case WM_WININICHANGE:
        pcp->_RecalcMetrics();
        break;

//  98/09/01 vtan #190588: WM_SYSCOLORCHANGE is passed when the desktop
//  background color is changed. This message is passed to the property
//  sheet common control which sends the message through to all the
//  children. The message is now processed here. The old monitor background
//  bitmap is discarded and a new one created with the current (new)
//  setting.

    case WM_SYSCOLORCHANGE:
        if (pcp->_hbmMonitor != NULL)
        {
            DeleteObject(pcp->_hbmMonitor);
            pcp->_hbmMonitor = LoadMonitorBitmap();
        }
        break;
    }
    return DefWindowProc(hwnd,message,wParam,lParam);
}

BOOL RegisterCompPreviewClass(void)
{
    WNDCLASS wc;

    if (!GetClassInfo(HINST_THISDLL, c_szComponentPreview, &wc)) {
        wc.style = 0;
        wc.lpfnWndProc = CCompPreview::CompPreviewWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = HINST_THISDLL;
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = c_szComponentPreview;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\dback.h ===
#ifndef _DBACK_H_
#define _DBACK_H_

#include <shimgdata.h>
#include "theme.h"
#include "dcomp.h"
#include "colorctrl.h"

#define SZ_ICONHEADER           L"CLSID\\{"

HRESULT GetActiveDesktop(IActiveDesktop ** ppActiveDesktop);
HRESULT ReleaseActiveDesktop(IActiveDesktop ** ppActiveDesktop);

EXTERN_C BOOL g_fDirtyAdvanced;
EXTERN_C BOOL g_fLaunchGallery;

typedef struct  tagDESKICONDATA {
    BOOL    fHideIcon;  //To hide the icon on desktop?
    BOOL    fDirty;     //Has this entry been modified and we not yet saved.
} DESKICONDATA;

typedef struct tagDeskIconNonEnumData {

    ULONG       rgfAttributes;           // ShellFolder\Attributes are saved here.
    BOOL        fNonEnumPolicySet;       // Disable the control because of policy Set.
  
} DESKICON_NONENUMDATA;

class CBackPropSheetPage : public CObjectWithSite
                         , public CObjectCLSID
                         , public IBasePropPage
                         , public IPropertyBag
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}


    CBackPropSheetPage(void);
    virtual ~CBackPropSheetPage(void);

protected:
    ICONDATA _IconData[NUM_ICONS];

    DESKICONDATA  _aHideDesktopIcon[2][NUM_DESKICONS];
    BOOL          _fHideDesktopIconDirty;
    DESKICON_NONENUMDATA _aDeskIconNonEnumData[NUM_DESKICONS];

    BOOL _fStateLoaded;         // Have we loaded the state yet?
    BOOL _fOpenAdvOnInit;       // Does the caller want us to open the Advanced dialog when we initialize?
    HWND _hwnd;                 // This is the hwnd of the property page.
    HWND _hwndLV;
    HWND _hwndWPStyle;
    BOOL _fAllowHtml;
    BOOL _fAllowAD;
    BOOL _fAllowChanges;
    BOOL _fPolicyForWallpaper;  //Is there a policy for wallpaper?
    BOOL _fPolicyForStyle;      //Is there a policy for Wallpaper style?
    BOOL _fForceAD;             //Is there a policy to force Active desktop to be ON?
    BOOL _fSelectionFromUser;   // Is the user making the selection?
    DWORD _dwApplyFlags;             //Is there a policy to force Active desktop to be ON?
    CColorControl _colorControl;
    COLORREF _rgbBkgdColor;

    void _AddPicturesFromDir(LPCTSTR pszDirName, BOOL fCount);
    int _AddAFileToLV(LPCTSTR pszDir, LPTSTR pszFile, UINT nBitmap);
    void _AddFilesToLV(LPCTSTR pszDir, LPCTSTR pszSpec, UINT nBitmap, BOOL fCount);
    int _FindWallpaper(LPCTSTR pszFile);
    HRESULT _SetNewWallpaper(IN LPCTSTR pszFile, IN BOOL fUpdateThemePage);
    void _UpdatePreview(IN WPARAM flags, IN BOOL fUpdateThemePage);
    void _EnableControls(void);
    int _GetImageIndex(LPCTSTR pszFile);
    static int CALLBACK _SortBackgrounds(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

    HRESULT _LoadState(void);
    HRESULT _LoadIconState(void);
    HRESULT _LoadDesktopOptionsState(void);
    HRESULT _SaveIconState(void);
    HRESULT _SaveDesktopOptionsState(void);
    HRESULT _GetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN BOOL fOldIcon, IN LPWSTR pszPath, IN DWORD cchSize);
    HRESULT _SetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN LPCWSTR pszPath, IN int nResourceID);

    void _OnInitDialog(HWND hwnd);
    void _OnNotify(LPNMHDR lpnm);
    void _OnCommand(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnDestroy(void);

    HRESULT _OnApply(void);
    HRESULT _AddFilesToList(void);
    HRESULT _AddPicturesFromDirRecursively(IN LPCTSTR pszDirName, BOOL fCount);
    HRESULT _GetHardDirThemesDir(LPTSTR pszPath, DWORD cchSize);
    HRESULT _GetKidsThemesDir(LPTSTR pszPath, DWORD cchSize);
    HRESULT _GetPlus95ThemesDir(LPTSTR pszPath, DWORD cchSize);
    HRESULT _GetPlus98ThemesDir(LPTSTR pszPath, DWORD cchSize);

    HRESULT _StartSizeChecker(void);
    DWORD _SizeCheckerThreadProc(void);
    static DWORD CALLBACK SizeCheckerThreadProc(LPVOID pvThis) { return ((CBackPropSheetPage *) pvThis)->_SizeCheckerThreadProc(); };

private:
    UINT _cRef;     // Reference count
    BOOL  _fThemePreviewCreated;
    IThemePreview* _pThemePreview;
    LPTSTR _pszOriginalFile;        // If we are using a temp file, this is the original file selected. (non-.bmp).  This updates as the user selects different files.
    LPTSTR _pszOrigLastApplied;     // Same as _pszOriginalFile except it doesn't change until apply is pressed.
    LPWSTR _pszWallpaperInUse;      // If using a temp file, keep the name in use so we don't stomp it while the user is previewing other files.
    LPWSTR _pszLastSourcePath;      // This will always be the last wallpaper set and it will be the pre-converted path.

    FILETIME _ftLastWrite;          // The date that the original file was last written to.
    BOOL _fWallpaperChanged;        // Did another tab change the wallpaper?
    IMruDataList * _pSizeMRU;       // MRU of Background wallpapers.
    BOOL _fScanFinished;            // Did we finish the background scan?
    BOOL _fInitialized;             // 
    int _nFileCount;                // This is used when counting how many pictures are in the "My Pictures" folder.
    int _nFileMax;                  // This is used when counting how many pictures are in the "My Pictures" folder.

    // These objects are owned by the background thread.
    IMruDataList * _pSizeMRUBk;     // WARNING: Owned by SizeCheckerThreadProc background thread.
    IShellImageDataFactory * _pImgFactBk; // Image factory used to compute size of background image to decide to default to tile or stretch

    // Private Member Functions
    HRESULT _LoadTempWallpaperSettings(IN LPCWSTR pszWallpaperFile);
    HRESULT _LaunchAdvancedDisplayProperties(HWND hwnd);
    INT_PTR _BackgroundDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _SetNewWallpaperTile(IN DWORD dwMode, IN BOOL fUpdateThemePage);
    HRESULT _BrowseForBackground(void);
    HRESULT _LoadBackgroundColor(IN BOOL fInit);
    HRESULT _Initialize(void);

    BOOL _DoesDirHaveMoreThanMax(LPCTSTR pszPath, int nMax);
    DWORD _GetStretchMode(IN LPCTSTR pszPath);
    HRESULT _GetMRUObject(IMruDataList ** ppSizeMRU);
    HRESULT _CalcSizeFromDir(IN LPCTSTR szPath, IN OUT DWORD * pdwAdded, IN BOOL fRecursive);
    HRESULT _CalcSizeForFile(IN LPCTSTR pszPath, IN WIN32_FIND_DATA * pfdFile, IN OUT DWORD * pdwAdded);

    static INT_PTR CALLBACK BackgroundDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\dcompp.h ===
#ifndef _DCOMPP_H_
#define _DCOMPP_H_

#define WM_UPDATEBITMAP  (WM_USER+1)

BOOL RegisterCompPreviewClass();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\dcomp.h ===
#ifndef _DCOMP_H_
#define _DCOMP_H_

#include <cowsite.h>

EXTERN_C IActiveDesktop * g_pActiveDeskAdv;

//
// Whether a particular desktop icon is shown or not depends on whether start panel is on or off.
// So, the individual preferences are persisted in two different registry locations given below!
#define REGSTR_PATH_HIDDEN_DESKTOP_ICONS  REGSTR_PATH_EXPLORER TEXT("\\HideDesktopIcons\\%s")
#define REGSTR_VALUE_STARTPANEL     TEXT("NewStartPanel")
#define REGSTR_VALUE_CLASSICMENU    TEXT("ClassicStartMenu")

#define REGSTR_PATH_HIDDEN_MYCOMP_ICONS  REGSTR_PATH_EXPLORER TEXT("\\HideMyComputerIcons")

#define REGSTR_PATH_EXP_SHELLFOLDER   REGSTR_PATH_EXPLORER TEXT("\\CLSID\\%s\\ShellFolder")
#define REGVAL_ATTRIBUTES       TEXT("Attributes")

// The following array has the two registry sub-locations where the desktop icon on/off data 
// is stored based on whether start panel is off/on.
const LPTSTR  c_apstrRegLocation[] =
{
    REGSTR_VALUE_CLASSICMENU,       // Use this if classic menu is on.
    REGSTR_VALUE_STARTPANEL         // Use this if start panel is on.
};


// Name of the file that holds each icon, and an index for which icon to use in the file
typedef struct tagIconKeys
{
    TCHAR szOldFile[MAX_PATH];
    int   iOldIndex;
    TCHAR szNewFile[MAX_PATH];
    int   iNewIndex;
}ICONDATA;

extern GUID CLSID_EffectsPage;

// Registry Info for the icons
typedef struct tagIconRegKeys
{
    const CLSID* pclsid;
    TCHAR szIconValue[16];
    int  iTitleResource;
    int  iDefaultTitleResource;
    LPCWSTR pszDefault;
    int  nDefaultIndex;
}ICONREGKEYS;

static const ICONREGKEYS c_aIconRegKeys[] =
{
    { &CLSID_MyComputer,    TEXT("\0"),     0,          IDS_MYCOMPUTER,     L"%WinDir%\\explorer.exe",            0},
    { &CLSID_MyDocuments,   TEXT("\0"),     0,          IDS_MYDOCUMENTS2,   L"%WinDir%\\system32\\mydocs.dll",    0},
    { &CLSID_NetworkPlaces, TEXT("\0"),     0,          IDS_NETNEIGHBOUR,   L"%WinDir%\\system32\\shell32.dll",   17},
    { &CLSID_RecycleBin,    TEXT("full"),   IDS_FULL,   IDS_TRASHFULL,      L"%WinDir%\\system32\\shell32.dll",   32},
    { &CLSID_RecycleBin,    TEXT("empty"),  IDS_EMPTY2, IDS_TRASHEMPTY,     L"%WinDir%\\system32\\shell32.dll",   31},
};

#define NUM_ICONS (ARRAYSIZE(c_aIconRegKeys))

enum ICON_SIZE_TYPES {
   ICON_DEFAULT         = 0,
   ICON_LARGE           = 1,
   ICON_INDETERMINATE   = 2
};

#define ICON_DEFAULT_SMALL    16
#define ICON_DEFAULT_NORMAL   32
#define ICON_DEFAULT_LARGE    48


typedef struct tagDeskIconId {
    int         iDeskIconDlgItemId;
    LPCWSTR     pwszCLSID;
    const CLSID *pclsid;
    BOOL        fCheckNonEnumAttrib;
    BOOL        fCheckNonEnumPolicy;
} DESKICONID;

// Array if desktop icons we would like to turn-on/off individually
static const DESKICONID c_aDeskIconId[] =
{
    {IDC_DESKTOP_ICON_MYDOCS,   L"{450D8FBA-AD25-11D0-98A8-0800361B1103}", &CLSID_MyDocuments,     TRUE  , TRUE }, // My Documents
    {IDC_DESKTOP_ICON_MYCOMP,   L"{20D04FE0-3AEA-1069-A2D8-08002B30309D}", &CLSID_MyComputer,      FALSE , TRUE }, // My Computer
    {IDC_DESKTOP_ICON_MYNET,    L"{208D2C60-3AEA-1069-A2D7-08002B30309D}", &CLSID_NetworkPlaces,   TRUE  , TRUE }, // Network Places
    {IDC_DESKTOP_ICON_IE,       L"{871C5380-42A0-1069-A2EA-08002B30309D}", &CLSID_Internet,        TRUE  , TRUE }  // Internet Explorer
};


// The sub-string that preceeds the CLSID when passed as the property name.
// For example, when "SP_1{645FF040-5081-101B-9F08-00AA002F954E}" is passed as the property name,
// it refers to the recycle icon when StartPage is ON.
//
static const LPWSTR c_awszSP[] = 
{
    L"SP_0",        //Indicates StartPage Off.
    L"SP_1",        //Indicates StartPage On.
    L"POLI"         //Indicates that we want the policy info!
};

static const LPWSTR c_wszPropNameFormat = L"%s%s";

#define STARTPAGE_ON_PREFIX     c_awszSP[1]          //The prefix string for StartPage_On.
#define STARTPAGE_OFF_PREFIX    c_awszSP[0]          //The prefix string for StartPage_Off.
#define LEN_PROP_PREFIX         lstrlenW(c_awszSP[0]) //Length of the prefix string.
#define POLICY_PREFIX           c_awszSP[2]

#define NUM_DESKICONS   (ARRAYSIZE(c_aDeskIconId))


#ifndef EXCLUDE_COMPPROPSHEET

class CCompPropSheetPage        : public CObjectWithSite
                                , public IAdvancedDialog
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAdvancedDialog ***
    virtual STDMETHODIMP DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pAdvPage, IN BOOL * pfEnableApply);

    CCompPropSheetPage(void);

protected:
    int  _cRef;

    ICONDATA _IconData[NUM_ICONS];

    HWND _hwndLV;
    BOOL _fAllowAdd;
    BOOL _fAllowDel;
    BOOL _fAllowEdit;
    BOOL _fAllowClose;
    BOOL _fAllowReset;
    BOOL _fLockDesktopItems;
    BOOL _fForceAD;
    BOOL _fLaunchGallery;           // Did we launch the gallery at any time?
    BOOL _fInitialized;             // Did we finished adding the items to the list view?
    HWND _hWndList;          // handle to the list view window
    HIMAGELIST _hIconList;   // handles to image lists for large icons

    BOOL   _fCustomizeDesktopOK; // was OK clicked when the customize desktop property sheet dialog was closed?
    int    _iStartPanelOn;
    BOOL   _afHideIcon[2][NUM_DESKICONS];
    BOOL   _afDisableCheckBox[NUM_DESKICONS];
    
    int  _iPreviousSelection;
    int  m_nIndex;

    void _ConstructLVString(COMPONENTA *pcomp, LPTSTR pszBuf, DWORD cchBuf);
    void _AddComponentToLV(COMPONENTA *pcomp);
    void _SetUIFromDeskState(BOOL fEmpty);
    void _OnInitDialog(HWND hwnd, INT iPage);
    void _OnNotify(HWND hwnd, WPARAM wParam, LPNMHDR lpnm);
    void _OnCommand(HWND hwnd, WORD wNotifyCode, WORD wID, HWND hwndCtl);
    void _OnDestroy(INT iPage);
    void _OnGetCurSel(int *piIndex);
    void _EnableControls(HWND hwnd);
    BOOL _VerifyFolderOptions(void);
    void _SelectComponent(LPWSTR pwszUrl);

    HRESULT _OnInitDesktopOptionsUI(HWND hwnd);
    HRESULT _LoadIconState(IN IPropertyBag * pAdvPage);
    HWND _CreateListView(HWND hWndParent);

    void _NewComponent(HWND hwnd);
    void _EditComponent(HWND hwnd);
    void _DeleteComponent(HWND hwnd);
    void _SynchronizeAllComponents(IActiveDesktop *pActDesktop);
    void _TryIt(void);

    void _DesktopCleaner(HWND hwnd);

    HRESULT _IsDirty(IN BOOL * pIsDirty);
    HRESULT _MergeIconState(IN IPropertyBag * pAdvPage);
    HRESULT _LoadDeskIconState(IN IPropertyBag * pAdvPage);
    HRESULT _MergeDeskIconState(IN IPropertyBag * pAdvPage);
    HRESULT _UpdateDesktopIconsUI(HWND hwnd);
private:
    virtual ~CCompPropSheetPage(void);

    // Private Member Functions
    INT_PTR _CustomizeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, INT iPage);

    static INT_PTR _CustomizeDlgProcHelper(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam, INT iPage);
    static INT_PTR CALLBACK CustomizeDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK WebDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

BOOL FindComponent(IN LPCTSTR pszUrl, IN IActiveDesktop * pActiveDesktop);
void CreateComponent(COMPONENTA *pcomp, LPCTSTR pszUrl);
INT_PTR NewComponent(HWND hwndOwner, IActiveDesktop * pad, BOOL fDeferGallery, COMPONENT * pcomp);
BOOL LooksLikeFile(LPCTSTR psz);
BOOL IsUrlPicture(LPCTSTR pszUrl);

#endif // EXCLUDE_COMPPROPSHEET

#define WM_COMP_GETCURSEL    (WM_USER+1)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\deskcls.h ===
STDAPI CDeskHtmlProp_RegUnReg(BOOL bReg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\deskhtm.h ===
//
//  This header file contains symbols and typedefs needed by any
//  files that exist outside the deskhtm sub-directory.
//

#ifndef _DESKHTM_H_
#define _DESKHTM_H_

// deskcls.cpp
STDAPI CDeskHtmlProp_RegUnReg(BOOL bReg);

// dutil.cpp
STDAPI_(BOOL) SetDesktopFlags(DWORD dwMask, DWORD dwNewFlags);
STDAPI_(DWORD)GetDesktopFlags(void);
STDAPI_(VOID) ActiveDesktop_ApplyChanges();

#define COMPONENTS_DIRTY        0x00000001
#define COMPONENTS_LOCKED       0x00000002
#define COMPONENTS_ZOOMDIRTY    0x00000004

STDAPI_(void) RefreshWebViewDesktop(void);
BOOL PokeWebViewDesktop(DWORD dwFlags);
void RemoveDefaultWallpaper(void);
#define REFRESHACTIVEDESKTOP() (PokeWebViewDesktop(AD_APPLY_FORCE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH | AD_APPLY_DYNAMICREFRESH))
void OnDesktopSysColorChange(void);


void SetSafeMode(DWORD dwFlags);

// 
// Desk Mover and Sizer stuff
//

EXTERN_C const CLSID CLSID_DeskMovr;
EXTERN_C const IID IID_IDeskMovr;

STDAPI_(BOOL) DeskMovr_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);


#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp

#endif // _DESKHTM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\deskhtml.cpp ===
#include "stdafx.h"
#pragma hdrstop

HRESULT CDeskHtmlProp::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] = {
        QITABENT(CDeskHtmlProp, IObjectWithSite),
        QITABENT(CDeskHtmlProp, IShellExtInit),
        QITABENT(CDeskHtmlProp, IPersist),
        QITABENT(CDeskHtmlProp, IPropertyBag),
        QITABENT(CDeskHtmlProp, IBasePropPage),
        QITABENTMULTI(CDeskHtmlProp, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDeskHtmlProp::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CDeskHtmlProp::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

CDeskHtmlProp::CDeskHtmlProp() : _cRef(1), CObjectCLSID(&PPID_Background)
{
    DllAddRef();
    OleInitialize(NULL);

    _pspseBkgdPage = NULL;
}

CDeskHtmlProp::~CDeskHtmlProp()
{
    ATOMICRELEASE(_pspseBkgdPage);
    OleUninitialize();
    DllRelease();
}


HRESULT CDeskHtmlProp::_InitBackgroundTab(void)
{
    HRESULT hr = S_OK;

    if (!_pspseBkgdPage)
    {
        CBackPropSheetPage * pbpsp = new CBackPropSheetPage();

        hr = E_OUTOFMEMORY;
        if (pbpsp)
        {
            hr = pbpsp->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &_pspseBkgdPage));
            pbpsp->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "DeskHtml - ReplacePage could not create a page");
        }
    }

    return hr;
}


// *** IObjectWithSite ***
HRESULT CDeskHtmlProp::SetSite(IN IUnknown * punkSite)
{
    HRESULT hr = _InitBackgroundTab();

    if (SUCCEEDED(hr))
    {
        hr = IUnknown_SetSite(_pspseBkgdPage, punkSite);
    }

    return hr;
}


HRESULT CDeskHtmlProp::GetSite(IN REFIID riid, OUT void ** ppvSite)
{
    HRESULT hr = _InitBackgroundTab();

    if (SUCCEEDED(hr))
    {
        IObjectWithSite * punk;

        hr = _pspseBkgdPage->QueryInterface(IID_PPV_ARG(IObjectWithSite, &punk));
        if (SUCCEEDED(hr))
        {
            hr = punk->GetSite(riid, ppvSite);
            punk->Release();
        }
    }

    return hr;
}



// *** IShellExtInit ***
HRESULT CDeskHtmlProp::Initialize(LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdtobj, HKEY hkeyProgID)
{
    TraceMsg(TF_GENERAL, "DeskHtmlProp - Initialize");
    HRESULT hr = E_INVALIDARG;

    // Forward on to the Background tab (CBackPropSheetPage)
    hr = _InitBackgroundTab();
    if (SUCCEEDED(hr))
    {
        IShellExtInit * pShellExtInt;

        if (SUCCEEDED(_pspseBkgdPage->QueryInterface(IID_PPV_ARG(IShellExtInit, &pShellExtInt))))
        {
            hr = pShellExtInt->Initialize(pidlFolder, pdtobj, hkeyProgID);
            pShellExtInt->Release();
        }
    }

    return hr;
}



// *** IBasePropPage ***
HRESULT CDeskHtmlProp::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    // Forward on to the Background tab (CBackPropSheetPage)
    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;

        hr = _InitBackgroundTab();
        if (SUCCEEDED(hr))
        {
            IBasePropPage * pBasePage;

            hr = _pspseBkgdPage->QueryInterface(IID_PPV_ARG(IBasePropPage, &pBasePage));
            if (SUCCEEDED(hr))
            {
                hr = pBasePage->GetAdvancedDialog(ppAdvDialog);
                pBasePage->Release();
            }
        }
    }

    return hr;
}


HRESULT CDeskHtmlProp::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = _InitBackgroundTab();

    if (SUCCEEDED(hr))
    {
        IBasePropPage * pBasePage;

        hr = _pspseBkgdPage->QueryInterface(IID_PPV_ARG(IBasePropPage, &pBasePage));
        if (SUCCEEDED(hr))
        {
            hr = pBasePage->OnApply(oaAction);
            pBasePage->Release();
        }
    }

    return hr;
}




// *** IPropertyBag ***
HRESULT CDeskHtmlProp::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = _InitBackgroundTab();

    if (SUCCEEDED(hr))
    {
        IPropertyBag * pPropertyBag;

        hr = _pspseBkgdPage->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            hr = pPropertyBag->Read(pszPropName, pVar, pErrorLog);
            pPropertyBag->Release();
        }
    }

    return hr;
}


HRESULT CDeskHtmlProp::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = _InitBackgroundTab();

    if (SUCCEEDED(hr))
    {
        IPropertyBag * pPropertyBag;

        hr = _pspseBkgdPage->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            hr = pPropertyBag->Write(pszPropName, pVar);
            pPropertyBag->Release();
        }
    }

    return hr;
}







// *** IShellPropSheetExt ***
HRESULT CDeskHtmlProp::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    TraceMsg(TF_GENERAL, "DeskHtmlProp - ReplacePage");

    RegisterBackPreviewClass();

    HRESULT hr = _InitBackgroundTab();
    if (SUCCEEDED(hr))
    {
        hr = _pspseBkgdPage->AddPages(lpfnAddPage, lParam);
    }

    return hr;
}


typedef struct tagREPLACEPAGE_LPARAM
{
    void * pvDontTouch;
    IThemeUIPages * ptuiPages;
} REPLACEPAGE_LPARAM;

//-----------------------------------------------------------------------------
//
// _PSXACALLINFO
//
// used to forward LPFNADDPROPSHEETPAGE calls with added error checking
//
//-----------------------------------------------------------------------------

typedef struct
{
    LPFNADDPROPSHEETPAGE pfn;
    LPARAM lparam;
    UINT count;
    BOOL allowmulti;
    BOOL alreadycalled;
} _PSXACALLINFO;


HRESULT CDeskHtmlProp::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    return S_OK;
}


HRESULT CDeskHtmlProp_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    TraceMsg(TF_GENERAL, "DeskHtmlProp - CreateInstance");

    CDeskHtmlProp* pdhd = new CDeskHtmlProp();
    if (pdhd) 
    {
        HRESULT hres = pdhd->QueryInterface(riid, ppvOut);
        pdhd->Release();
        return hres;
    }
    
    *ppvOut = NULL;
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\deskcls.cpp ===
#include "stdafx.h"
#include <LMCONS.H>     // 97/07/22 vtan: for UNLEN

#pragma hdrstop

BOOL   OnUpgradeDisableActiveDesktopFeatures();

void CreateMyCurHomeComponent(BOOL fChecked)
{
    // If there is a policy to prevent adding desktop components, then we should not attempt to add.
    // Otherwise, a new user gets an error message when they login for the first time.
    // Bug #21300 -- Fixed on 2/28/2001 -- Sankar
    if (SHRestricted(REST_NOADDDESKCOMP))
        return;
        
    //Add the base components!
    TCHAR szBuf[MAX_PATH];
    ISubscriptionMgr * psm;

    // Add a component that points to "about:home"
    LoadString(HINST_THISDLL, IDS_MY_CURRENT_HOMEPAGE, szBuf, ARRAYSIZE(szBuf));

//  98/07/14 vtan #176721: Changed the following to pass default component
//  positions to AddRemoveDesktopComponentNoUI so that the restored position may
//  be set to the default component position.

//  int   iTop, iLeft;
//  DWORD dwWidth, dwHeight;
//  GetMyCurHomePageStartPos(&iLeft, &iTop, &dwWidth, &dwHeight);
//  AddRemoveDesktopComponentNoUI(TRUE, AD_APPLY_SAVE, MY_HOMEPAGE_SOURCE, szBuf, COMP_TYPE_WEBSITE, iLeft, iTop, dwWidth, dwHeight, TRUE, IS_SPLIT);
    AddRemoveDesktopComponentNoUI(TRUE, AD_APPLY_SAVE, MY_HOMEPAGE_SOURCE, szBuf, COMP_TYPE_WEBSITE, COMPONENT_DEFAULT_LEFT, COMPONENT_DEFAULT_TOP, COMPONENT_DEFAULT_WIDTH, COMPONENT_DEFAULT_HEIGHT, fChecked, IS_SPLIT);
    if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, (void**)&psm)))
    {
        WCHAR wszName[MAX_PATH];
        //We need to zero init this structure except the cbSize field.
        SUBSCRIPTIONINFO siDefault = {sizeof(SUBSCRIPTIONINFO)};

        SHTCharToUnicode(szBuf, wszName, ARRAYSIZE(wszName));

        //This field is already initialized above.
        //siDefault.cbSize = sizeof(siDefault);
        psm->CreateSubscription(NULL, MY_HOMEPAGE_SOURCEW, wszName, CREATESUBS_NOUI, SUBSTYPE_DESKTOPURL, &siDefault);
        psm->Release();
    }
}

STDAPI CDeskHtmlProp_RegUnReg(BOOL bReg)
{
    HKEY    hKey;
    DWORD   userNameSize;
    TCHAR   lpszDeskcomp[MAX_PATH];
    TCHAR   userName[UNLEN];

//  98/07/22 vtan #202707: Problem: This code gets called for the first time when NT
//  runs. This sets up the default user profile. Anything that is added to this profile
//  is propagated to any current user when upgrading from NT 4.0 to NT 5.0. This
//  causes the DeskHtmlVersion, DeskHtmlMinorVersion and Component\0 to be replaced
//  with the default component. By replacing the version registry entries any old
//  components will not get correctly upgraded by the component reading code. It also
//  destroys the first component.

//  Solution: Prevent a default component being added at setup time by checking the
//  logged on user is "SYSTEM". If the user is anybody other than system then perform
//  the update or addition of the default component.

    userNameSize = ARRAYSIZE(userName);
    if ((GetUserName(userName, &userNameSize) != 0) && (lstrcmp(userName, TEXT("SYSTEM")) == 0))
        return(S_OK);           // an ungracious exit right here and now!

    if(bReg)
    {
        DWORD dwDisposition;
        DWORD dwDeskHtmlVersion = 0;
        DWORD dwDeskHtmlMinorVersion = 0;
        DWORD dwType;

        GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_COMPONENTS, NULL);

        if(RegCreateKeyEx(HKEY_CURRENT_USER, (LPCTSTR)lpszDeskcomp, 
               0, NULL, 0, KEY_CREATE_SUB_KEY|KEY_QUERY_VALUE, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
        {
            //Get the version stamp from the registry
            if(dwDisposition == REG_OPENED_EXISTING_KEY)
            {
                DWORD dwDataLength = SIZEOF(DWORD);
                SHQueryValueEx(hKey, REG_VAL_COMP_VERSION, NULL, &dwType, (LPBYTE)(&dwDeskHtmlVersion), &dwDataLength);
                SHQueryValueEx(hKey, REG_VAL_COMP_MINOR_VERSION, NULL, &dwType, (LPBYTE)(&dwDeskHtmlMinorVersion), &dwDataLength);
            }

            //We need to close this key before we delete it
            RegCloseKey(hKey);

            // If this branch is already there, don't set default comp.
            // Note: The differences between IE4_DESKHTML_VERSION and CUR_DESKHTML_VERSION are 
            // automatically taken care of when we read the components. So, we need to check only
            // for very old versions here.
            if (dwDeskHtmlVersion < IE4_DESKHTML_VERSION)
            {
                //Delete the existing components.
                SHDeleteKey(HKEY_CURRENT_USER, (LPCTSTR)lpszDeskcomp);

                // Create the default active desktop configuration
                if(RegCreateKeyEx(HKEY_CURRENT_USER, (LPCTSTR)lpszDeskcomp, 0, NULL, 0, 
                            (KEY_CREATE_SUB_KEY | KEY_SET_VALUE), NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
                {
                    //We need an initial state
                    DWORD dw;

                    dw = CUR_DESKHTML_VERSION;
                    RegSetValueEx(hKey, REG_VAL_COMP_VERSION, 0, REG_DWORD, (LPBYTE)&dw, SIZEOF(dw));

                    dw = CUR_DESKHTML_MINOR_VERSION;
                    RegSetValueEx(hKey, REG_VAL_COMP_MINOR_VERSION, 0, REG_DWORD, (LPBYTE)&dw, SIZEOF(dw));
                    
                    dw = COMPSETTING_ENABLE;
                    RegSetValueEx(hKey, REG_VAL_COMP_SETTINGS, 0, REG_DWORD, (LPBYTE)&dw, SIZEOF(dw));

                    //Add the home page component
                    CreateMyCurHomeComponent(FALSE); //For millennium we want to disable the component.

                    RegCloseKey(hKey);
                }

                // Create the default active desktop safemode configuration
                if(RegCreateKeyEx(HKEY_CURRENT_USER, REG_DESKCOMP_SAFEMODE,
                        0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
                {
                    DWORD dwDisposition;
                    HKEY hKey2;

                    if(RegCreateKeyEx(hKey, REG_DESKCOMP_GENERAL_SUFFIX, 0, NULL, 0, 
                                (KEY_CREATE_SUB_KEY | KEY_SET_VALUE), NULL, &hKey2, &dwDisposition) == ERROR_SUCCESS)
                    {
                        TCHAR szSafeMode[MAX_PATH];
                        GetWindowsDirectory(szSafeMode, ARRAYSIZE(szSafeMode));
                        lstrcat(szSafeMode, DESKTOPHTML_DEFAULT_SAFEMODE);
                        // Show safemode.htx
                        SHRegSetPath(hKey2, NULL, REG_VAL_GENERAL_WALLPAPER, szSafeMode, 0);
                        // Don't bring up the gallery dialog box
                        dwDisposition = 0;
                        RegSetValueEx(hKey2, REG_VAL_GENERAL_VISITGALLERY, 0, REG_DWORD, (LPBYTE)&dwDisposition, sizeof(dwDisposition));
                        RegCloseKey(hKey2);
                    }
                    
                    RegCloseKey(hKey);
                }

                // Create the default scheme key
                if(RegCreateKeyEx(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME, 0, NULL, 0, 
                        (KEY_CREATE_SUB_KEY | KEY_SET_VALUE), NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
                {
                    RegSetValueEx(hKey, REG_VAL_SCHEME_EDIT, 0, REG_SZ, (LPBYTE)TEXT(""), SIZEOF(TCHAR));
                    RegSetValueEx(hKey, REG_VAL_SCHEME_DISPLAY, 0, REG_SZ, (LPBYTE)TEXT(""), SIZEOF(TCHAR));
                    RegCloseKey(hKey);
                }

                // Set the components to be dirty sothat we re-generate desktop.htm
                // the first boot after installing IE4.0.
                SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);

                GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_GENERAL, NULL);
                RegCreateKeyEx(HKEY_CURRENT_USER, lpszDeskcomp, 
                    0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hKey, &dwDisposition);
                RegCloseKey(hKey);
            }
            else
            {
                //See if we are upgrading from an older version like IE4.
                if (dwDeskHtmlVersion < CUR_DESKHTML_VERSION)
                {
                    // If so, save the DESKHTML_VERSION we are upgrading from.
                    // We use this later in SHGetSetSettings to decide if active desktop is ON/OFF.
                    // NOTE: The "UpgradedFrom" value is at "...\Desktop" and NOT at "..\Desktop\Components"
                    // This is because the "Components" key gets destroyed very often.
                    SHSetValue(HKEY_CURRENT_USER, REG_DESKCOMP, REG_VAL_COMP_UPGRADED_FROM,
                                REG_DWORD, (LPBYTE)&dwDeskHtmlVersion, SIZEOF(dwDeskHtmlVersion));
                }
                 // The major version numbers match. So check if the minor version numbers 
                // match too!
                if(dwDeskHtmlMinorVersion < CUR_DESKHTML_MINOR_VERSION)
                {
                    //Update the new Minor version number!
                    if(RegCreateKeyEx(HKEY_CURRENT_USER, (LPCTSTR)lpszDeskcomp, 0, NULL, 0, 
                            (KEY_CREATE_SUB_KEY | KEY_SET_VALUE), NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
                    {
                        DWORD   dw;
                        
                        dw = CUR_DESKHTML_MINOR_VERSION;
                        RegSetValueEx(hKey, REG_VAL_COMP_MINOR_VERSION, 0, REG_DWORD, (LPBYTE)&dw, SIZEOF(dw));
                        
                        RegCloseKey(hKey);
                    }
                    
                    // Add the new home page component
                    if((dwDeskHtmlVersion <= 0x10f) && (dwDeskHtmlMinorVersion <= 0x0001))
                        CreateMyCurHomeComponent(FALSE);

                    // 
                    // If this is an upgrade from W2K or earlier, we need to check if the
                    // active desktop is OFF. If so, we need to turn off all the desktop components
                    // sothat the active desktop continues to be OFF.
                    if((dwDeskHtmlVersion <= NT5_DESKHTML_VERSION) && 
                       (dwDeskHtmlMinorVersion <= NT5_DESKHTML_MINOR_VERSION))
                    {
                        OnUpgradeDisableActiveDesktopFeatures();
                    }
                    
                    // Minor version numbers do not match. So, set the dirty bit to force
                    // the regeneration of desktop.htt later when needed.
                    SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);

//  98/07/16 vtan #176721/#202707: Added the following code to delete HKCU\Software\
//  Microsoft\Internet Explorer\Desktop\General\ComponentsPositioned because in NT 4.0
//  with IE 4.0 SP1 this registry entry is incorrectly incremented when the components
//  are iterated rather than when they are positioned. This resets the counter
//  in NT 5.0 where the bug has been fixed.

                    GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_GENERAL, NULL);

                    DWORD   dw;

                    if (RegCreateKeyEx(HKEY_CURRENT_USER, (LPCTSTR)lpszDeskcomp, 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &hKey, &dw) == ERROR_SUCCESS)
                    {
                        (LONG)RegDeleteValue(hKey, REG_VAL_GENERAL_CCOMPPOS);
                        (LONG)RegCloseKey(hKey);
                    }
                }
            }
        }
    }
    else
    {
        SHDeleteKey(HKEY_LOCAL_MACHINE, c_szRegDeskHtmlProp);
        SHDeleteKey(HKEY_CURRENT_USER, REG_DESKCOMP_COMPONENTS_ROOT);
        SHDeleteKey(HKEY_CURRENT_USER, REG_DESKCOMP_GENERAL_ROOT);
        SHDeleteKey(HKEY_CURRENT_USER, REG_DESKCOMP_SAFEMODE);
        SHDeleteKey(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\deskmovr.cpp ===
// DeskMovr.cpp : Implementation of CDeskMovr
#include "stdafx.h"
#pragma hdrstop

#include "deskmovr.h"

#define DEFAULT_INTERVAL        200     // check every 1/5th of a second.
#define DEFAULT_ENABLED         TRUE
#define DETECT_TIMER_ID         2323
#ifndef SHDOC401_DLL
#define ANIMATE_TIMER_ID        2324
#define ANIMATE_TIMER_INTERVAL  (60*1000)
#endif

#ifdef DEBUG
const static TCHAR sz_DM1[]  = TEXT("no dragable part");
const static TCHAR sz_DM2[]  = TEXT("caption menu button");
const static TCHAR sz_DM3[]  = TEXT("caption close button");
const static TCHAR sz_DM4[]  = TEXT("move the component");
const static TCHAR sz_DM5[]  = TEXT("resize width and height from bottom right corner");
const static TCHAR sz_DM6[]  = TEXT("resize width and height from top left corner");
const static TCHAR sz_DM7[]  = TEXT("resize width and height from top right corner");
const static TCHAR sz_DM8[]  = TEXT("resize width and height from bottom left corner");
const static TCHAR sz_DM9[]  = TEXT("resize from the top edge");
const static TCHAR sz_DM10[]  = TEXT("resize from the bottom edge");
const static TCHAR sz_DM11[]  = TEXT("resize from the left edge");
const static TCHAR sz_DM12[] = TEXT("resize from the right edge");

const LPCTSTR g_szDragModeStr[] = {
        sz_DM1,
        sz_DM2,
        sz_DM3,
        sz_DM4,
        sz_DM5,
        sz_DM6,
        sz_DM7,
        sz_DM8,
        sz_DM9,
        sz_DM10,
        sz_DM11,
        sz_DM12
    };

#endif // DEBUG

// Globals used to track cdeskmovr instances.  Useful for optimizing the
// detection code so we can turn off the timer when the mouse is not over our
// window.  We track the cdeskmovr instances only on the first thread that instantiates
// us to keep the code simple, this should be the active desktop case.
#define CDESKMOVR_TRACK_COUNT 16    // 2 is what we use now for the active desktop, but we need
                                    // extra slots in the array due to the fact that a new instance
                                    // is created before the old one is destroyed during refresh.
                                    // Make the array large to handle nested refreshes!
HHOOK g_hMouseHook;
HHOOK g_hKeyboardHook;
DWORD g_dwHookThreadId;
#ifndef SHDOC401_DLL
BOOL  g_fAnimTimer = FALSE;
#endif
typedef CDeskMovr *PDM;
PDM g_apDM[CDESKMOVR_TRACK_COUNT];
BOOL CombView_EnableAnimations(BOOL fEnable);


DWORD  g_fIgnoreTimers = 0;
#define IGNORE_CONTEXTMENU_UP 0x0001
#define IGNORE_CAPTURE_SET    0x0002

#define GET_SKIP_COUNT  (2 * ((GetDoubleClickTime() / m_lInterval) + 1))

MAKE_CONST_BSTR(s_sstrNameMember,       L"name");
MAKE_CONST_BSTR(s_sstrHidden,           L"hidden");
MAKE_CONST_BSTR(s_sstrVisible,          L"visible");
MAKE_CONST_BSTR(s_sstrResizeableMember, L"resizeable");

// These were declared in shellprv.h, so use DEFINE instead of MAKE
DEFINE_CONST_BSTR(s_sstrIDMember,         L"id");
DEFINE_CONST_BSTR(s_sstrSubSRCMember,     L"subscribed_url");
DEFINE_CONST_BSTR(s_sstrSRCMember,        L"src");

#define CAPTION_ONLY (m_ItemState & (IS_FULLSCREEN | IS_SPLIT))
#define ISNORMAL (m_ItemState & IS_NORMAL)
#define ISFULLSCREEN (m_ItemState & IS_FULLSCREEN)
#define ISSPLIT (m_ItemState & IS_SPLIT)
#define CAPTIONBAR_HOTAREA(cyDefaultCaption, cyCurrentCaption) (((cyCurrentCaption == 0) && CAPTION_ONLY) ? (cyDefaultCaption / 2) : 3 * cyDefaultCaption)

#define MAX_ID_LENGTH 5

void ObtainSavedStateForElem( IHTMLElement *pielem,
                       LPCOMPSTATEINFO pCompState, BOOL fRestoredState);

DWORD g_aDMtoCSPushed[] = {0, CS_MENUPUSHED, CS_CLOSEPUSHED, CS_RESTOREPUSHED, CS_FULLSCREENPUSHED, CS_SPLITPUSHED};
DWORD g_aDMtoCSTracked[] = {0, CS_MENUTRACKED, CS_CLOSETRACKED, CS_RESTORETRACKED, CS_FULLSCREENTRACKED, CS_SPLITTRACKED};
DWORD g_aDMDCfromDragMode[] = {0, DMDC_MENU, DMDC_CLOSE, DMDC_RESTORE, DMDC_FULLSCREEN, DMDC_SPLIT};
#define PUSHED(dm) (g_aDMtoCSPushed[(dm)])
#define TRACKED(dm) (g_aDMtoCSTracked[(dm)])
#define DMDCFROMDM(dm) (g_aDMDCfromDragMode[(dm)])

// Trident will flash if you change the zindex, even if it's to the same index,
// so we prevent the no-op call.
HRESULT SafeZOrderSet(IHTMLStyle * pistyle, LONG lNewZIndex)
{
    HRESULT hr = S_OK;
    VARIANT varZ;

    ASSERT(pistyle);
    pistyle->get_zIndex(&varZ);

    // Does the component need to be moved to the top?
    if ((VT_I4 != varZ.vt) || (varZ.lVal != lNewZIndex))
    {
        // Yes.
        varZ.vt = VT_I4;
        varZ.lVal = lNewZIndex;
        hr = pistyle->put_zIndex(varZ);
    }

    return hr;
}

// Keyboard hook is installed when first instance of deskmovr is created.  Used to implement the keyboard
// interface for accessing the deskmovr control.  Hook is removed when there are no more deskmovr's
// being tracked.
LRESULT CALLBACK DeskMovr_KeyboardHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes;
    BOOL fHaveMover = FALSE;

    for (int i = 0; i < CDESKMOVR_TRACK_COUNT; i++) {
        if (g_apDM[i])
        {
            g_apDM[i]->OnKeyboardHook(wParam, lParam);
            fHaveMover = TRUE;
        }
    }

    lRes = CallNextHookEx(g_hKeyboardHook, nCode, wParam, lParam);

    if (!fHaveMover)
    {
        UnhookWindowsHookEx(g_hKeyboardHook);
        g_hKeyboardHook = NULL;
    }

    return lRes;
}

// Helper function used to track cdeskmovr intances so that we can turn off the
// timer if the mouse leaves our window.
void TrackMover(PDM pdm, BOOL fAdd)
{
    if (!g_dwHookThreadId)
        g_dwHookThreadId = GetCurrentThreadId();

    if (!g_hKeyboardHook && fAdd)
        g_hKeyboardHook = SetWindowsHookEx(WH_KEYBOARD, DeskMovr_KeyboardHook, NULL, GetCurrentThreadId());

    if (!fAdd || (g_dwHookThreadId == GetCurrentThreadId())) {
        int i = 0;
        PDM pdmFind = fAdd ? NULL : pdm;
        PDM pdmAssign = fAdd ? pdm : NULL;

        while (i < CDESKMOVR_TRACK_COUNT) {
            if (g_apDM[i] == pdmFind) {
                g_apDM[i] = pdmAssign;
                break;
            }
            i++;
        }

        // If we ever fail to track a mover then we'll never be able to optimize
        // again.  Shouldn't happen in practice for the case we care about.
        if (fAdd && (i >= CDESKMOVR_TRACK_COUNT))
            g_dwHookThreadId = 0xffffffff;

        ASSERT(!fAdd || (i < CDESKMOVR_TRACK_COUNT));
    }
}

#if 0
void AnimateToTray(HWND hwnd, LONG lLeft, LONG lTop, LONG lWidth, LONG lHeight)
{
    HWND hwndTray;
    if (hwndTray = FindWindow(c_szTrayClass, NULL))
    {
        RECT rcComp, rcTray;

        SetRect(&rcComp, lLeft, lTop, lLeft + lWidth, lTop + lHeight);
        MapWindowPoints(hwnd, NULL, (LPPOINT)&rcComp, 2);

        GetWindowRect(hwndTray, &rcTray);
        if ((rcTray.right - rcTray.left) > (rcTray.bottom - rcTray.top))
            rcTray.left = rcTray.right - GetSystemMetrics(SM_CXSMICON);
        else
            rcTray.top = rcTray.bottom - GetSystemMetrics(SM_CYSMICON);

        DrawAnimatedRects(hwnd, IDANI_CAPTION, (CONST RECT *)&rcComp, (CONST RECT *)&rcTray);
    }
}
#endif

void AnimateComponent(HWND hwnd, LONG lLeftS, LONG lTopS, LONG lWidthS, LONG lHeightS,
                      LONG lLeftD, LONG lTopD, LONG lWidthD, LONG lHeightD)
{
    RECT rcSource, rcDest;

    SetRect(&rcSource, lLeftS, lTopS, lLeftS + lWidthS, lTopS + lHeightS);
    SetRect(&rcDest, lLeftD, lTopD, lLeftD + lWidthD, lTopD + lHeightD);

//  98/10/02 vtan: Removed the mapping as not required.

//  MapWindowPoints(hwnd, NULL, (LPPOINT)&rcSource, 2);
//  MapWindowPoints(hwnd, NULL, (LPPOINT)&rcDest, 2);

    DrawAnimatedRects(hwnd, IDANI_CAPTION, (CONST RECT *)&rcSource, (CONST RECT *)&rcDest);
}

// Hook is installed when we detect we can turn our tracking timer off.  The first
// time we get a mouse event in the hook we reactivate all the movers and unhook
// ourself.
LRESULT CALLBACK DeskMovr_MouseHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes;

#ifndef SHDOC401_DLL
    // If we are getting mouse messages then a portion of the window must be
    // visible so enable animations.
    CombView_EnableAnimations(TRUE);
#endif

    for (int i = 0; i < CDESKMOVR_TRACK_COUNT; i++) {
        if (g_apDM[i]) 
            g_apDM[i]->SmartActivateMovr(ERROR_SUCCESS);
    }

    lRes = CallNextHookEx(g_hMouseHook, nCode, wParam, lParam);

    UnhookWindowsHookEx(g_hMouseHook);
    g_hMouseHook = NULL;

    return lRes;
}

/////////////////////////////////////////////////////////////////////////////
// CDeskMovr

CDeskMovr::CDeskMovr()
 : m_TimerWnd(_T("STATIC"), this, 1)
{
    TraceMsg(TF_CUSTOM2, "CDeskMovr::CDeskMovr()");

    m_fEnabled = DEFAULT_ENABLED;
    m_lInterval = DEFAULT_INTERVAL;

    m_cxSMBorder = GetSystemMetrics(SM_CXBORDER);
    m_cySMBorder = GetSystemMetrics(SM_CYBORDER);
    m_cxBorder = m_cxSMBorder;
    m_cyBorder = m_cySMBorder;
    m_cyCaption = 0; 

    m_dmCur = dmNull;
    m_dmTrack = dmNull;

    m_hcursor = LoadCursor(NULL, IDC_ARROW);
    m_CaptionState = 0;
    m_hwndParent;

    m_fTimer = FALSE;
    m_fCaptured = FALSE;
    m_uiTimerID = DETECT_TIMER_ID;
    m_pistyle = NULL;

    m_pistyleTarget = NULL;
    m_pielemTarget = NULL;
    m_iSrcTarget = -1;
    
    m_bstrTargetName = NULL;

    m_dx = m_dy = 0;
    
    m_top = m_left = m_width = m_height = 0;

    // Tell ATL that we don't want to be Windowless
    m_bWindowOnly = TRUE;

    // Track this instance
    TrackMover(this, TRUE);
}

CDeskMovr::~CDeskMovr(void)
{
    TraceMsg(TF_CUSTOM2, "CDeskMovr::~CDeskMovr() m_bstrTargetName=%ls.", GEN_DEBUGSTRW(m_bstrTargetName));

 // clean up, detach from events, if necessary. 
    DeactivateMovr(TRUE);

    if ( m_bstrTargetName != NULL )
        SysFreeString( m_bstrTargetName );

    TrackMover(this, FALSE);
}


HRESULT CDeskMovr::SmartActivateMovr(HRESULT hrPropagate)
{
    if ((FALSE == m_nFreezeEvents) && m_fEnabled && !m_pielemTarget)
    {
#ifndef SHDOC401_DLL
        // Release our animation timer if it exists and create our regular one
        if (g_fAnimTimer && (m_uiTimerID == ANIMATE_TIMER_ID))
        {
            m_TimerWnd.KillTimer(m_uiTimerID);
            m_uiTimerID = DETECT_TIMER_ID;
            g_fAnimTimer = FALSE;
            m_fTimer = m_TimerWnd.SetTimer(m_uiTimerID, m_lInterval) != 0;
        }
#endif
        hrPropagate = ActivateMovr();
        if (!EVAL(SUCCEEDED(hrPropagate)))
            DeactivateMovr(FALSE);   // Clean up mess.
    }

    return hrPropagate;
}

HRESULT CDeskMovr::FreezeEvents(BOOL fFreeze)
{
    HRESULT hr = IOleControlImpl<CDeskMovr>::FreezeEvents(fFreeze);
    TraceMsg(TF_CUSTOM1, "CDeskMovr::FreezeEvents(fFreeze=%lx) m_nFreezeEvents=%lx; m_fEnabled=%lx, m_bstrTargetName=%ls", (DWORD)fFreeze, m_nFreezeEvents, m_fEnabled, GEN_DEBUGSTRW(m_bstrTargetName));

    m_nFreezeEvents = fFreeze;

    if (fFreeze)
        DeactivateMovr(FALSE);
    else
        hr = SmartActivateMovr(hr);

    return hr;
}

HRESULT CDeskMovr::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    HRESULT hr;
    VARIANT var;

    ATLTRACE(_T("IPersistPropertyBagImpl::Load\n"));

    var.vt = VT_BOOL;
    hr = pPropBag->Read(L"Enabled", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_BOOL) {
        m_fEnabled = var.boolVal;
    }

    var.vt = VT_I4;
    hr = pPropBag->Read(L"Interval", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_I4) {
        m_lInterval = var.lVal;
    }

    var.vt = VT_BSTR;
    var.bstrVal = NULL;
    hr = pPropBag->Read(L"TargetName", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_BSTR) {
        m_bstrTargetName = var.bstrVal;
    }

    // This PARAM determines whether the control will be in the
    // windowed or windowless "layer" of the Trident layout.
    var.vt = VT_BOOL;
    hr = pPropBag->Read(L"WindowOnly", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_BOOL) {
        m_bWindowOnly = var.boolVal;
    }

    hr = _GetZOrderSlot(&m_zIndexTop, TRUE);
    ASSERT(SUCCEEDED(hr));
    hr = _GetZOrderSlot(&m_zIndexBottom, FALSE);
    ASSERT(SUCCEEDED(hr));

    return hr;
}

HRESULT CDeskMovr::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return E_NOTIMPL;
}

BOOL CDeskMovr::GetCaptionButtonRect(DragMode dm, LPRECT lprc)
{
    BOOL fSuccess;

    *lprc = m_rectCaption;

    switch (dm) {
        case dmClose:
            lprc->left = m_rectCaption.right - (m_cyCaption + m_cxSMBorder);
            fSuccess = (lprc->left > (m_rectCaption.left + m_cyCaption));
            break;

        case dmMenu:
            lprc->right = lprc->left + (m_cyCaption + m_cxSMBorder);
            fSuccess = (m_rectCaption.right > (m_rectCaption.left + m_cyCaption));
            break;

        case dmRestore:
            if (ISNORMAL)
                return FALSE;
            else if (ISSPLIT)
                goto CalcSplit;
            else if (ISFULLSCREEN)
                goto CalcFullScreen;

            ASSERT(FALSE);

        case dmSplit:
            if (ISSPLIT || !m_fCanResizeX || !m_fCanResizeY)
            {
                return FALSE;
            }
CalcSplit:
            lprc->left = m_rectCaption.right - (m_cyCaption + m_cxSMBorder);
            OffsetRect(lprc, -(lprc->right - lprc->left), 0);
            fSuccess = (lprc->left > (m_rectCaption.left + 2 * m_cyCaption));
            break;

        case dmFullScreen:
            if (ISFULLSCREEN || !m_fCanResizeX || !m_fCanResizeY)
            {
                return FALSE;
            }
CalcFullScreen:
            lprc->left = m_rectCaption.right - (m_cyCaption + m_cxSMBorder);
            OffsetRect(lprc, -((lprc->right - lprc->left) * 2 - 2 * m_cxSMBorder), 0);
            fSuccess = (lprc->left > (m_rectCaption.left + 2 * m_cyCaption));
            break;

        default:
            ASSERT(FALSE);
            fSuccess = FALSE;
            break;
    }

    // Shrink the button within the caption and position it adjacent to the border
    if (fSuccess) {
        OffsetRect(lprc, ((dm == dmClose) ? m_cxSMBorder : -m_cxSMBorder), -m_cySMBorder);
        InflateRect(lprc, -m_cxSMBorder, -m_cySMBorder);
        lprc->bottom -= m_cySMBorder;  // Take an extra border off the bottom
    }

    return fSuccess;
}

void CDeskMovr::DrawCaptionButton(HDC hdc, LPRECT lprc, UINT uType, UINT uState, BOOL fErase)
{
    RECT rcT;
    HRGN hrgnWnd, hrgnRect;
    int iRet;

    if (fErase)
        FillRect(hdc, lprc, (HBRUSH)(COLOR_3DFACE + 1));

    rcT = *lprc;
    InflateRect(&rcT, -2*m_cxSMBorder, -2*m_cySMBorder);

    switch (uType) {
        case DMDC_CLOSE:
            uType = DFC_CAPTION;
            goto Draw;
        case DMDC_MENU:
            uType = DFC_SCROLL;
Draw:
            // We need to clip the border of the outer edge in order to get the drawing effect we
            // want here...
            if (hrgnWnd = CreateRectRgn(0, 0, 0, 0)) {
                if ((iRet = GetClipRgn(hdc, hrgnWnd)) != -1) {
                    if (hrgnRect = CreateRectRgnIndirect(&rcT)) {
                        SelectClipRgn(hdc, hrgnRect);
                        DeleteObject(hrgnRect);
                    }
                }
            }
    
            DrawFrameControl(hdc, lprc, uType, uState);

            if (hrgnWnd != NULL)
            {
                SelectClipRgn(hdc, (iRet == 1) ? hrgnWnd : NULL);
            }
            if (hrgnWnd)
                DeleteObject(hrgnWnd);
            break;

        case DMDC_FULLSCREEN:
        case DMDC_SPLIT:
        case DMDC_RESTORE:
            {
                if (uState & DFCS_PUSHED)
                    OffsetRect(&rcT, 1, 1);

                DrawEdge(hdc, &rcT, BDR_OUTER, BF_FLAT | BF_MONO | BF_RECT);

#ifndef OLD_CODE
                switch (uType) {
                    case DMDC_RESTORE:
                        rcT.right = rcT.left + (rcT.right - rcT.left) * 3 / 4;
                        rcT.bottom = rcT.top + (rcT.bottom - rcT.top) * 3 / 4;
                        rcT.left += (rcT.right - rcT.left) / 2 + 1;
                        rcT.top  += (rcT.bottom - rcT.top) / 2 + 1;
                        FillRect(hdc, &rcT, (HBRUSH)(COLOR_WINDOWFRAME + 1));
                        break;

                    case DMDC_SPLIT:
                        rcT.top += m_cySMBorder;
                        rcT.left += (rcT.right - rcT.left) * 3 / 10;
                        DrawEdge(hdc, &rcT, BDR_OUTER, BF_FLAT | BF_MONO | BF_TOP | BF_LEFT);
                        break;

                    case DMDC_FULLSCREEN:
                        rcT.top += m_cySMBorder;
                        DrawEdge(hdc, &rcT, BDR_OUTER, BF_FLAT | BF_MONO | BF_TOP);
                        break;
                }
#else
                switch (uType) {
                    case DMDC_RESTORE:
                        rcT.right = rcT.left + (rcT.right - rcT.left) * 3 / 4;
                        rcT.bottom = rcT.top + (rcT.bottom - rcT.top) * 3 / 4;
                        rcT.left += (rcT.right - rcT.left) / 2 + 1;
                        rcT.top  += (rcT.bottom - rcT.top) / 2 + 1;
                        break;
                    case DMDC_SPLIT:
                        rcT.left += (rcT.right - rcT.left) * 3 / 10;
                        break;
                    case DMDC_FULLSCREEN:
                        break;
                }

                FillRect(hdc, &rcT, (HBRUSH)(COLOR_WINDOWFRAME + 1));
#endif
            }
            break;
    }

    // DFCS_FLAT means no border to us
    if (!(uState & DFCS_FLAT))
        DrawEdge(hdc, lprc, ((uState & DFCS_PUSHED) ? BDR_SUNKENOUTER : BDR_RAISEDINNER), BF_RECT);
}

void CDeskMovr::DrawCaption(HDC hdc, UINT uDrawFlags, int x, int y)
{
    RECT rect;
    UINT uState;
    DragMode dmT;

    // Draw the caption
    if (uDrawFlags & DMDC_CAPTION) {
        rect = m_rectCaption;
        OffsetRect(&rect, x, y);
        FillRect( hdc, &rect, (HBRUSH)(COLOR_3DFACE + 1) );
    }

    // Draw the caption frame controls
    for (dmT = dmMenu; dmT < dmMove; dmT = (DragMode)((int)dmT + 1))
    {
        if ((uDrawFlags & DMDCFROMDM(dmT)) && GetCaptionButtonRect(dmT, &rect))
        {
            if (dmT == dmMenu)
                uState = DFCS_SCROLLDOWN;
            else if (dmT == dmClose)
                uState = DFCS_CAPTIONCLOSE;
            else
                uState = 0;

            if ((dmT == dmClose) && SHRestricted(REST_NOCLOSEDESKCOMP))
                uState |= DFCS_INACTIVE | DFCS_FLAT;
            else
            {
                if (m_CaptionState & PUSHED(dmT))
                    uState |= DFCS_PUSHED;
                if (!(m_CaptionState & (TRACKED(dmT) | PUSHED(dmT))))
                    uState |= DFCS_FLAT;
            }
            OffsetRect(&rect, x, y);
            DrawCaptionButton(hdc, &rect, DMDCFROMDM(dmT), uState, !(uDrawFlags & DMDC_CAPTION));
        }
    }
}

HRESULT CDeskMovr::OnDraw(ATL_DRAWINFO& di)
{
    RECT& rc = *(RECT*)di.prcBounds;

    RECT r;
    HBRUSH  hbrush = (HBRUSH)(COLOR_3DFACE + 1);
    
    // top edge
    r.left = rc.left;
    r.top = rc.top;
    r.right = rc.right;
    r.bottom = rc.top + m_cyBorder;
    FillRect( di.hdcDraw, &r, hbrush );
    // left edge
    r.top = rc.top + m_cyBorder;
    r.right = rc.left + m_cxBorder;
    r.bottom = rc.bottom - m_cyBorder;
    FillRect( di.hdcDraw, &r, hbrush );
    // right edge
    r.right = rc.right;
    r.left = rc.right - m_cxBorder;
    FillRect( di.hdcDraw, &r, hbrush );
    // bottom edge
    r.left = rc.left;
    r.top = rc.bottom - m_cyBorder;
    r.right = rc.right;
    r.bottom = rc.bottom;
    FillRect( di.hdcDraw, &r, hbrush );

    if ( m_cyCaption != 0 ) {
        DrawCaption(di.hdcDraw, DMDC_ALL, rc.left, rc.top);
    }

    return S_OK;
}

HRESULT CDeskMovr::GetParentWindow(void)
{
    HRESULT hr = S_OK;

    if (!m_hwndParent)
    {
        if (m_spInPlaceSite) 
            hr = m_spInPlaceSite->GetWindow(&m_hwndParent);
        else 
        {
            IOleInPlaceSiteWindowless * poipsw;

            ASSERT(m_spClientSite);
            if (m_spClientSite &&
                SUCCEEDED(hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&poipsw)))
            {
                hr = poipsw->GetWindow(&m_hwndParent);
                poipsw->Release();
            }
        }

        if (!m_hwndParent)
            hr = S_FALSE;   // We failed to get it.
    }

    return hr;
}

void CDeskMovr::DeactivateMovr(BOOL fDestroy)
{
    TraceMsg(TF_CUSTOM2, "CDeskMovr::DeactivateMovr() m_fTimer=%lx, m_bstrTargetName=%ls", m_fTimer, GEN_DEBUGSTRW(m_bstrTargetName));

    if (fDestroy || (m_uiTimerID == DETECT_TIMER_ID)) {
        if (m_fTimer)
        {
            m_TimerWnd.KillTimer(m_uiTimerID);
            m_fTimer = FALSE;
        }
        if (m_TimerWnd.m_hWnd)
            m_TimerWnd.DestroyWindow();
#ifndef SHDOC401_DLL
        if (m_uiTimerID == ANIMATE_TIMER_ID)
            g_fAnimTimer = FALSE;
#endif
    }

    // DismissSelfNow();

    ATOMICRELEASE( m_pistyle );
    ATOMICRELEASE( m_pistyleTarget );
    ATOMICRELEASE( m_pielemTarget );

    _ChangeCapture(FALSE);
}


HRESULT CDeskMovr::ActivateMovr()
{
    HRESULT           hr;

    // flush out old interface pointers
    DeactivateMovr(FALSE);
    TraceMsg(TF_CUSTOM2, "CDeskMovr::ActivateMovr() m_fTimer=%lx, m_bstrTargetName=%ls", m_fTimer, GEN_DEBUGSTRW(m_bstrTargetName));

    if (m_fEnabled)
    {        
        if (SUCCEEDED(hr = GetOurStyle()))
        {
            if ((m_bstrTargetName != NULL) && (m_lInterval > 0))
            {
                if (!m_TimerWnd.m_hWnd)
                {
                    // create a new timer.
                    RECT rc = {0, 0, 0 , 0};

                    // We attempt to get our parent HWND (m_hwndParent) now.
                    // If we fail (and we will sometimes), then we will get it later when
                    // we need it and Trident is then ready.
                    GetParentWindow();

                    m_TimerWnd.Create(NULL, rc, _T("Timer"), WS_POPUP);
                }
                if (!m_fTimer)
                    m_fTimer = m_TimerWnd.SetTimer(m_uiTimerID, m_lInterval) != 0;
            }
            else
            {
#ifdef HIDE_ALL_HANDLES
                hr = S_FALSE;
#else
                hr = E_FAIL;
#endif
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CDeskMovr::GetOurStyle(void)
{
    HRESULT           hr;
    IOleControlSite   *pictlsite = 0;
    IDispatch         *pidisp = 0;

    // Reach up to get our extender, who is the custodian of our element style
    if (m_spClientSite &&
        EVAL(SUCCEEDED(hr = m_spClientSite->QueryInterface(IID_IOleControlSite, (LPVOID*)&pictlsite))) &&
        EVAL(SUCCEEDED(hr = pictlsite->GetExtendedControl(&pidisp))))
    {
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        VARIANT var;

        VariantInit( &var );

        // Alas, all we have is IDispatch on our extender, so we'll have to use Invoke to get
        // the style object...
        hr = pidisp->Invoke( DISPID_IHTMLELEMENT_STYLE, IID_NULL,
                             LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
                             &dispparamsNoArgs, &var, NULL, NULL );

        if ( SUCCEEDED(hr) ) {
            if ( var.vt == VT_DISPATCH )
                hr = var.pdispVal->QueryInterface( IID_IHTMLStyle, (LPVOID*)&m_pistyle );
            else
                hr = E_FAIL; // Try VariantChangeType?????

            VariantClear( &var );
        }
    }

    ATOMICRELEASE( pictlsite );
    ATOMICRELEASE( pidisp );

    return hr;
}



void CDeskMovr::UpdateCaption(UINT uDrawFlags)
{
    HDC hdc;
    int x = 0, y = 0;

    if (m_bWndLess) {
        if (!m_spInPlaceSite || !SUCCEEDED(m_spInPlaceSite->GetDC(NULL, 0, &hdc)))
            return;
    } else {
        hdc = ::GetDC(m_hWnd);
    }

    _MapPoints(&x, &y);

    DrawCaption(hdc, uDrawFlags, -x, -y);

    if (m_bWndLess) {
        m_spInPlaceSite->ReleaseDC(hdc);
    } else {
        ::ReleaseDC(m_hWnd, hdc);
    }
}

void CDeskMovr::CheckCaptionState(int x, int y)
{
    DragMode dm, dmT;
    UINT uDrawFlags = 0;

    _MapPoints (&x, &y);

    POINT pt = { x, y };

    if (m_fCaptured)
        dm = dmNull;
    else
        dm = DragModeFromPoint( pt );

    if (dm >= dmMenu && dm < dmMove)
    {
        if (!(m_CaptionState & (PUSHED(dm) | TRACKED(dm))))
        {
            m_CaptionState |= TRACKED(dm);
            uDrawFlags |= DMDCFROMDM(dm);
        }
    }

    for (dmT = dmMenu; dmT < dmMove; dmT = (DragMode)((int)dmT + 1))
    {
        if (dm != dmT && (m_CaptionState & (PUSHED(dmT) | TRACKED(dmT))))
        {
            m_CaptionState &= ~(PUSHED(dmT) | TRACKED(dmT));
            uDrawFlags |= DMDCFROMDM(dmT);
        }
    }

    if (uDrawFlags)
        UpdateCaption(uDrawFlags);
}

//=--------------------------------------------------------------------------=
// CDeskMovr::DoMouseDown   [instance method]
//=--------------------------------------------------------------------------=
// Respond to mouse down messages in our control. Initiate move/resize.
//
// Parameters:
//    int                - [in]  mouse message key flags
//    int                - [in]  mouse x location in control coords
//    int                - [in]  mouse y location in control coords
//
// Output:
//    <none>
//
// Notes:
BOOL CDeskMovr::HandleNonMoveSize(DragMode dm)
{
    m_dmCur = dm;
    switch (dm) {
        case dmMenu:
        case dmClose:
        case dmRestore:
        case dmFullScreen:
        case dmSplit:
            if (m_dmCur != dmClose || !SHRestricted(REST_NOCLOSEDESKCOMP)) // Special case for Close, check restriction
            {
                m_CaptionState &= ~(TRACKED(m_dmCur));
                m_CaptionState |= PUSHED(m_dmCur);
                UpdateCaption(DMDCFROMDM(m_dmCur));
                // Perform the operation on the up-click of the mouse...
            }
    
            if (m_dmCur == dmMenu && EVAL(S_OK == GetParentWindow())) // Special case for Menu, invoke on the down click
            {
                _DisplayContextMenu();
            }
            return TRUE;
            break;

        default:
            return FALSE;
            break;
    }
}

LRESULT CDeskMovr::OnMouseDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    int x = (short)LOWORD(lParam);
    int y = (short)HIWORD(lParam);

    _MapPoints(&x, &y);

    TraceMsg(TF_CUSTOM2, "CDeskMovr::OnMouseDown() Mouse=<%d,%d>, Inner=<%d,%d,%d,%d>, Caption=<%d,%d,%d,%d>, m_bstrTargetName=%ls", 
        x, y, m_rectInner.left, m_rectInner.top, m_rectInner.right, m_rectInner.bottom,
        m_rectCaption.left, m_rectCaption.top, m_rectCaption.right, m_rectCaption.bottom, GEN_DEBUGSTRW(m_bstrTargetName));

    POINT pt = { x, y };
    m_dmCur = DragModeFromPoint( pt );

    if (HandleNonMoveSize(m_dmCur))
        return 0;

    switch ( m_dmCur ) {
    case dmMove:
        m_dx = -x;
        m_dy = -y;
        break;

    case dmSizeWHBR:
        m_dx = m_rectInner.right - x;
        m_dy = m_rectInner.bottom - y;
        break;
    case dmSizeWHTL:
        m_dx = m_rectInner.left - x;
        m_dy = m_rectInner.top + m_cyCaption - y;
        break;
    case dmSizeWHTR:
        m_dx = m_rectInner.right - x;
        m_dy = m_rectInner.top + m_cyCaption - y;
        break;
    case dmSizeWHBL:
        m_dx = m_rectInner.left - x;
        m_dy = m_rectInner.bottom - y;
        break;
    case dmSizeTop:
        m_dx = 0;
        m_dy = m_rectInner.top + m_cyCaption - y;
        break;
    case dmSizeBottom:
        m_dx = 0;
        m_dy = m_rectInner.bottom - y;
        break;
    case dmSizeLeft:
        m_dx = m_rectInner.left - x;
        m_dy = 0;
        break;
    case dmSizeRight:
        m_dx = m_rectInner.right - x;
        m_dy = 0;
        break;
    default:
        bHandled = FALSE;
        return 1;
    }

#ifdef DEBUG
    TraceMsg(TF_CUSTOM2, "CDeskMovr::OnMouseDown() New DragMode=""%s""", g_szDragModeStr[m_dmCur]);
#endif // DEBUG

    // NOTE: (seanf, 1/31/97) temporary defense against 17902. We really
    // shouldn't ever be in visible and non-targeted at the same time, but
    // the resize trick we pull in CDeskMovr::ActivateMovr() to get us
    // in-place active exposes a 1X1 pixel area, just big enough for StanTak
    // to click on when we don't have a target, which then kills us when
    // we try to move the non-existent target.
    if ( m_pielemTarget != NULL ) {
        _ChangeCapture(TRUE);

        if (m_fCaptured)
        {
            // Move the target to the top and put ourselves just under it
            VARIANT varZ;

            m_pistyleTarget->get_zIndex(&varZ);

            // Does the component need to be moved to the top?
            if (!CAPTION_ONLY && ((VT_I4 != varZ.vt) || (varZ.lVal != m_zIndexTop)))
            {
                // Yes.
                varZ.vt = VT_I4;
                varZ.lVal = ++m_zIndexTop;
                // Move the DeskMover ActiveX Control on top of everything.
                m_pistyle->put_zIndex(varZ);
    
                // Move the Desktop Item on top of the DeskMover
                varZ.lVal = ++m_zIndexTop;
                m_pistyleTarget->put_zIndex(varZ);
            }
        }
#ifdef DEBUG
        if (!m_fCaptured)
            TraceMsg(TF_CUSTOM2, "CDeskMovr::OnMouseDown() Unable to get capture, tracking will fail!");
#endif

    }

    return 0;
}

//=--------------------------------------------------------------------------=
// CDeskMovr::DoMouseUp   [instance method]
//=--------------------------------------------------------------------------=
// Respond to mouse down messages in our control. Terminate move/resize.
//
// Parameters:
//    int                - [in]  mouse message key flags
//    int                - [in]  mouse x location in control coords
//    int                - [in]  mouse y location in control coords
//    UINT               - [in]  from the DeskMovrParts enum
//
// Output:
//    <none>
//
// Notes:

LRESULT CDeskMovr::OnMouseUp( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    if ( m_fCaptured ) {
        PersistTargetPosition( m_pielemTarget, m_left, m_top, m_width, m_height, m_zIndexTop, FALSE, FALSE, m_ItemState );
        _ChangeCapture(FALSE);
    } else {
        int x = (short)LOWORD(lParam);
        int y = (short)HIWORD(lParam);

        _MapPoints(&x, &y);
    
        POINT pt = { x, y };
        DragMode dm = DragModeFromPoint( pt );

        if ((dm >= dmMenu) && (dm < dmMove) && (m_CaptionState & PUSHED(dm)))
        {
            m_CaptionState &= ~(PUSHED(dm));
            m_CaptionState |= TRACKED(dm);
            UpdateCaption(DMDCFROMDM(dm));

            switch ( dm ) {
                case dmClose:
//                    AnimateToTray(m_hwndParent, m_left, m_top, m_width, m_height);
                    IElemCloseDesktopComp(m_pielemTarget);
                    break;

                case dmRestore:
                    _HandleZoom(IDM_DCCM_RESTORE);
                    break;

                case dmFullScreen:
                    _HandleZoom(IDM_DCCM_FULLSCREEN);
                    break;

                case dmSplit:
                    _HandleZoom(IDM_DCCM_SPLIT);
                    break;
            }

            if (dm != dmMenu)
                DismissSelfNow();
        }
    }

    return 0;
}

//=--------------------------------------------------------------------------=
// CDeskMovrControl::DoMouseMove   [instance method]
//=--------------------------------------------------------------------------=
// Respond to mouse move messages in our control and when moving/sizing.
//
// Parameters:
//
// Output:
//    <none>
//
// Notes:

LRESULT CDeskMovr::OnPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    TraceMsg(TF_CUSTOM2, "CDeskMovr::OnPaint() uMsg=%lx, wParam=%lx, lParam=%lx, m_bstrTargetName=%ls", uMsg, wParam, lParam, GEN_DEBUGSTRW(m_bstrTargetName));
    return CComControl<CDeskMovr>::OnPaint( uMsg, wParam, lParam, bHandled );
}

//=--------------------------------------------------------------------------=
// CDeskMovrControl::DoMouseMove   [instance method]
//=--------------------------------------------------------------------------=
// Respond to mouse move messages in our control and when moving/sizing.
//
// Parameters:
//
// Output:
//    <none>
//
// Notes:

LRESULT CDeskMovr::OnMouseMove( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CheckCaptionState((short)LOWORD(lParam), (short)HIWORD(lParam));

    if (m_fCaptured && EVAL(S_OK == GetParentWindow()))
    {
        // Okay, it's a hit on one of our gadgets.
        // We're only interested in mouse moves and mouse ups if we're in the
        // process of a drag or resize
        HRESULT hr;
        POINT   ptDoc; // location in document window coords
        POINT   ptScreen;
        HWND    hwndParent = m_hwndParent;

        int x = (short)LOWORD(lParam);
        int y = (short)HIWORD(lParam);

        ptScreen.x = x;
        ptScreen.y = y;
        ptDoc = ptScreen;
        if ( !m_bWndLess ) 
            ::MapWindowPoints( m_hWnd, hwndParent, &ptDoc, 1 );

        if ( m_dmCur == dmMove )
            hr = MoveSelfAndTarget( ptDoc.x + m_dx + m_cxBorder, ptDoc.y + m_dy + m_cyBorder + m_cyCaption );
        else if ( m_dmCur > dmMove )
            hr = SizeSelfAndTarget( ptDoc );

        ASSERT(SUCCEEDED(hr));
    }

    // Set m_cSkipTimer so that we delay dismissing the mover...
    m_cSkipTimer = GET_SKIP_COUNT;

    return 0;
}

LRESULT CDeskMovr::OnTimer( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    HRESULT hr;
    IHTMLElement *pielem;
    POINT   ptCursor;
    BOOL    fDidWork = FALSE;

#ifndef SHDOC401_DLL
    /*
     * Check our animation timer first.  If we are able to disable animations then
     * blow away the timer.  Otherwise reset the timer for 60 seconds and keep on
     * looking.
     */
    if (wParam == ANIMATE_TIMER_ID)
    {
        if (CombView_EnableAnimations(FALSE))
        {
            m_TimerWnd.SetTimer(ANIMATE_TIMER_ID, ANIMATE_TIMER_INTERVAL);
        }
        else
        {
            m_TimerWnd.KillTimer(m_uiTimerID);
            m_uiTimerID = DETECT_TIMER_ID;
            g_fAnimTimer = FALSE;
            m_fTimer = FALSE;
        }

        return 0;
    }
#endif

    if (!m_fTimer || g_fIgnoreTimers || !GetCursorPos( &ptCursor ) || !m_pistyle)
        return 0;

    if (ptCursor.x == m_ptMouseCursor.x && ptCursor.y == m_ptMouseCursor.y)
        // Mouse stayed still from last time we did a timer so, do nothing
        return 0;

    pielem = NULL;

    if (S_OK == GetParentWindow())
    {
        HWND hwndParent = m_hwndParent;
        HWND hwndCursor = WindowFromPoint(ptCursor);

        if ((hwndCursor != hwndParent) && !::IsChild(hwndParent, hwndCursor))
        {
            // The mouse has drifted out of our window, so lose our target, if any
            if (m_iSrcTarget >= 0)
            {
                hr = MoveSelfToTarget( NULL, NULL );
                ASSERT(SUCCEEDED(hr));
                if (hr != S_FALSE)
                {
                    fDidWork = TRUE;
                }
            }
            if (GetCurrentThreadId() == g_dwHookThreadId) {
#ifndef SHDOC401_DLL
                // Set ourselves up so we can look to see if our animations can be turned off
                if (!g_fAnimTimer)
                {
                    if (m_fTimer)
                        m_TimerWnd.KillTimer(m_uiTimerID);

                    if (g_fAnimTimer = (m_TimerWnd.SetTimer(ANIMATE_TIMER_ID, ANIMATE_TIMER_INTERVAL / 10) != 0))
                        m_uiTimerID = ANIMATE_TIMER_ID;
                    m_fTimer = g_fAnimTimer;
                }
#endif
                DismissSelfNow();
                DeactivateMovr(FALSE);
                if (!g_hMouseHook)
                    g_hMouseHook = SetWindowsHookEx(WH_MOUSE, DeskMovr_MouseHook, NULL, GetCurrentThreadId());
            }
        }
        else if (!(GetDesktopFlags() & COMPONENTS_LOCKED) && SUCCEEDED(hr = _IsInElement(hwndParent, &ptCursor, &pielem)))
        {
            // See if we need to do anything based on the element under the mouse pointer
            hr = _TrackElement(&ptCursor, pielem, &fDidWork);
            // we're done with this particular interface pointer
            pielem->Release();
        }
        else if (m_iSrcTarget != -1) {
            // Check to see if we should expand border to size border width
            if (TrackCaption ( &ptCursor ))
            {
                TrackTarget(NULL);
            }
        }
    }

    if (!fDidWork)
        m_ptMouseCursor = ptCursor;
    
    return 0;
}

LRESULT CDeskMovr::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    if (!m_bWndLess) {
        RECT rc;
        ::GetClientRect(m_hWnd, &rc);
        FillRect((HDC)wParam, &rc, (HBRUSH)(COLOR_3DFACE + 1));
    }
    bHandled = TRUE;

    return 0;
}

//
// DismissSelfNow - Little helper function to dismiss the mover immediately
//
// Normally dismissal of the mover is desired to be done on a delayed basis.  However,
// there are situations such as when the user clicks on UI or capture is lost etc. where
// it is desirable to dismiss the mover immediately.
//
void CDeskMovr::DismissSelfNow(void)
{
    HRESULT hr;
    m_cSkipTimer = 0;
    hr = MoveSelfToTarget(NULL, NULL);
    ASSERT(SUCCEEDED(hr) && (hr != S_FALSE));
}

LRESULT CDeskMovr::OnCaptureChanged( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    if ( m_fCaptured ) {
        _ChangeCapture(FALSE);
        PersistTargetPosition( m_pielemTarget, m_left, m_top, m_width, m_height, m_zIndexTop, FALSE, FALSE, m_ItemState );
        DismissSelfNow();
    }

    return 0;
}

HRESULT CDeskMovr::InPlaceDeactivate(void)
{
    DeactivateMovr(FALSE);
    TraceMsg(TF_CUSTOM1, "CDeskMovr::InPlaceDeactivate()");
    return CComControl<CDeskMovr>::IOleInPlaceObject_InPlaceDeactivate();
}

LRESULT CDeskMovr::OnSetCursor( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (EVAL(S_OK == GetParentWindow()))
    {
        POINT   ptCursor;
        DragMode dm;

        GetCursorPos( &ptCursor );

        ::ScreenToClient( m_hwndParent, &ptCursor );

        // Get ptCursor into deskmovr local coords
        ptCursor.x -= m_left - (CAPTION_ONLY ? 0 : m_cxBorder);
        ptCursor.y -= m_top - (CAPTION_ONLY ? 0 : (m_cyBorder + m_cyCaption));

        dm = DragModeFromPoint(ptCursor);
        m_hcursor = CursorFromDragMode(dm);

        TraceMsg(TF_CUSTOM2, "CDeskMovr::OnSetCursor() Mouse=<%d,%d>, Inner=<%d,%d,%d,%d>, Caption=<%d,%d,%d,%d>, m_bstrTargetName=%ls", 
            ptCursor.x, ptCursor.y, m_rectInner.left, m_rectInner.top, m_rectInner.right, m_rectInner.bottom,
            m_rectCaption.left, m_rectCaption.top, m_rectCaption.right, m_rectCaption.bottom, GEN_DEBUGSTRW(m_bstrTargetName));

    #ifdef DEBUG
        TraceMsg(TF_CUSTOM2, "CDeskMovr::OnSetCursor() New DragMode=""%s""", g_szDragModeStr[dm]);
    #endif // DEBUG

        if (EVAL(m_hcursor != NULL))
            SetCursor( m_hcursor );
        else
            bHandled = FALSE;
    }

    return !bHandled;
}


void CDeskMovr::TrackTarget(POINT * pptDoc)
{
    HRESULT hr = S_OK;

    if ( m_fEnabled && m_pielemTarget != NULL ) {
        LONG left, top;
        POINT pt;
        VARIANT varZ;
        COMPSTATEINFO CompState;

        varZ.vt = VT_I4;

        CLEANUP_ON_FAILURE(hr = CSSOM_TopLeft(m_pielemTarget, &pt));
        m_top = pt.y;
        m_left = pt.x;

        CLEANUP_ON_FAILURE(hr = m_pielemTarget->get_offsetHeight( &m_height ));
        CLEANUP_ON_FAILURE(hr = m_pielemTarget->get_offsetWidth( &m_width ));
  
        // Hack so we don't get weird painting effect of the window hopping to the new
        // target with the old target's size.
        if (!m_bWndLess && m_cyCaption == 0)
            ::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOACTIVATE);

        // Get our rectangle synced with the target (so TrackCaption works properly)
        SyncRectsToTarget();
        // If we discover we want to display the size-border or caption
        // right now then we need to recalculate our rects.
        if (pptDoc && TrackCaption(pptDoc))
            SyncRectsToTarget();

        CLEANUP_ON_FAILURE(hr = m_pistyleTarget->get_zIndex( &varZ ));
        if (!CAPTION_ONLY || (m_cxBorder == m_cxSMBorder))
            --varZ.lVal;
        else
            ++varZ.lVal;
        CLEANUP_ON_FAILURE(hr = SafeZOrderSet(m_pistyle, varZ.lVal));

        // NTRAID94268-2000/03/14 (stephstm): If this is hosted in a window that
        //         has scrollbars, we don't correctly add the screen to document
        //         offset when changing the location of the component.
        //         This causes us to drag incorrectly.

//  98/10/02 #176729 vtan: Now uses the component left and top to
//  position the caption. Offset the caption if the component is
//  not zoomed. If zoomed then just draw over the component.

        left = m_left;
        top = m_top;
        if (!CAPTION_ONLY)
        {
            left -= m_cxBorder;
            top  -= m_cyBorder;
            top  -= m_cyCaption;
        }
        hr = m_pistyle->put_pixelLeft(left);
        hr = m_pistyle->put_pixelWidth( m_rectOuter.right );
        hr = m_pistyle->put_pixelTop(top);
        hr = m_pistyle->put_pixelHeight( m_rectOuter.bottom );

        hr = m_pistyle->put_visibility((BSTR)s_sstrVisible.wsz);

        // We need to persist the original state of the item out now if the item's current width/height is -1
        // This occurs when we are fitting an image to it's default size, we need to make sure the
        // original size real values so it works properly.
        ObtainSavedStateForElem(m_pielemTarget, &CompState, FALSE);
        if (m_bWndLess && CompState.dwWidth == COMPONENT_DEFAULT_WIDTH && CompState.dwHeight == COMPONENT_DEFAULT_HEIGHT)
            PersistTargetPosition(m_pielemTarget, m_left, m_top, m_width, m_height, varZ.lVal, FALSE, TRUE, CompState.dwItemState);
    }

CleanUp:
    ASSERT(SUCCEEDED(hr));
}

BOOL CDeskMovr::TrackCaption( POINT *pptDoc )
{
    int         cyCaption, cyCaptionNew;
    POINT       ptMovr;
    DragMode    dmNew;
    BOOL        fRetVal = FALSE;

    //TraceMsg(TF_CUSTOM2, "CDeskMovr::TrackCaption() Mouse=<%d,%d>", ptMovr.x, ptMovr.y);

    if (pptDoc)
    {
        ptMovr = *pptDoc;
        // need a hit test of some sort within the deskmovr to control border swelling
        ptMovr.x -= m_left - m_cxBorder;
        ptMovr.y -= m_top - (m_cyBorder + m_cyCaption);

        dmNew = DragModeFromPoint( ptMovr );

        cyCaption = GET_CYCAPTION;

        if (dmNew == dmNull) {
            BOOL fInner;
            int iInflate;
            RECT rc;
            // Treat something near the size border as a size border hit
            // so we expand to the size border as the user nears the edge.
            fInner = PtInRect(&m_rectInner, ptMovr);
    
            if (fInner) {
                rc = m_rectInner;
                iInflate = -cyCaption;
            } else {
                rc = m_rectOuter;
                iInflate = cyCaption;
            }
    
            InflateRect(&rc, iInflate, iInflate);
            if (fInner != PtInRect(&rc, ptMovr))
                dmNew = dmSizeRight;
        }

        if ( (pptDoc->y >= m_top - (m_cyBorder + 2 * m_cyCaption) &&
            pptDoc->y <= (m_top + CAPTIONBAR_HOTAREA(cyCaption, m_cyCaption)) ) )
            cyCaptionNew = cyCaption;
        else
            cyCaptionNew = 0;
    }
    else
    {
        cyCaptionNew = GET_CYCAPTION;
        dmNew = dmSizeRight;
    }

    if ( cyCaptionNew != m_cyCaption ||
        (m_dmTrack != dmNew && !((m_dmTrack > dmMove) && (dmNew > dmMove))) ) {
        m_cyCaption = cyCaptionNew;
        if (m_cyCaption == 0)
            m_CaptionState = 0;
        m_dmTrack = dmNew;
        fRetVal = TRUE;
    } else
        m_cyCaption = cyCaptionNew;

    return fRetVal;
}

int CDeskMovr::CountActiveCaptions()
{
    int iCount = 0;

    if (g_dwHookThreadId == GetCurrentThreadId())
    {
        for (int i = 0; i < CDESKMOVR_TRACK_COUNT; i++) {
            if (g_apDM[i] && g_apDM[i]->m_pistyleTarget)
                iCount++;
        }
    }
    return iCount;
}

HRESULT CDeskMovr::_TrackElement(POINT * ppt, IHTMLElement * pielem, BOOL * fDidWork)
{
    HRESULT hr;
    IHTMLElement *pTargElem = NULL;
    LONG iSrcTarget = -1;

    ASSERT(pielem);

    if ( FFindTargetElement( pielem, &pTargElem ) )
    {
        hr = pTargElem->get_sourceIndex( &iSrcTarget );
        ASSERT(SUCCEEDED(hr));
    }

    // If the m_iSrcTarget isn't the same as the SrcTarget under our cursor,
    // then we should move on top of it.
    if ( m_iSrcTarget != iSrcTarget )
    {
        *fDidWork = TRUE;
    
        if ((CountActiveCaptions() > 1) && (-1 == iSrcTarget))
            m_cSkipTimer = 0;

        // Yes, we need to move on top of it.
        hr = MoveSelfToTarget( pTargElem, ppt );
        ASSERT(SUCCEEDED(hr));
        if (hr != S_FALSE)
            m_iSrcTarget = iSrcTarget;
    } 
    else
    {
        // No, so that means we already have focus...
        if (ppt && TrackCaption(ppt))
        {
            TrackTarget(NULL);
        }
    }

    if ( pTargElem != NULL ) { 
        pTargElem->Release(); // MoveSelfToTarget will have secured our reference
    }

    hr = (m_iSrcTarget == -1) ? S_FALSE : S_OK;

    return hr;
}

//=--------------------------------------------------------------------------=
// CDeskMovr::InitAttributes  [instance method]
//=--------------------------------------------------------------------------=
// Finds out if the element is resizeable in X and Y direction and sets the
// BITBOOLs accordingly.
//
// Also determines what state the element is in and sets m_ItemState.
//
// Parameters:
//    IHTMLElement*     [in] - interface on event source element
//
// Output:
//    HRESULT      - various. S_OK if  operation succeeded.
//
HRESULT CDeskMovr::InitAttributes(IHTMLElement *pielem)
{
    HRESULT hr;
    TCHAR   szMember[MAX_ID_LENGTH];

    ASSERT(pielem);

    m_fCanResizeX = m_fCanResizeY = FALSE;  //Assume "Can't resize!

    // The resizeable member is not required to be specified, only override defaults if present.
    if (SUCCEEDED(GetHTMLElementStrMember(pielem, szMember, SIZECHARS(szMember), (BSTR)(s_sstrResizeableMember.wsz))))
    {
        if(StrChr(szMember, TEXT('X')))
                m_fCanResizeX = TRUE;

        if(StrChr(szMember, TEXT('Y')))
                m_fCanResizeY = TRUE;
    }

    // The ItemState is required, return failure if we fail to find the ID
    if (SUCCEEDED(hr = GetHTMLElementStrMember(pielem, szMember, SIZECHARS(szMember), (BSTR)(s_sstrIDMember.wsz))))
        m_ItemState = GetCurrentState(szMember);

    return hr;
}

//=--------------------------------------------------------------------------=
// CDeskMovr::MoveSelfToTarget   [instance method]
//=--------------------------------------------------------------------------=
// Handles Trident document events as mouse moves over the desktop.
//
// Parameters:
//    IHTMLElement*     [in] - interface on event source element
//    POINT*            [in] - location of mouse (to determine if caption should be displayed)
//
// Output:
//    HRESULT      - various. S_OK if  operation succeeded.
//


HRESULT CDeskMovr::MoveSelfToTarget(IHTMLElement *pielem, POINT * pptDoc)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_CUSTOM2, "CDeskMovr::MoveSelfToTarget(pielem=%lx) %s, m_bstrTargetName=%ls", pielem, (pielem ? "We are GETTING focus." : "We are LOOSING focus."), GEN_DEBUGSTRW(m_bstrTargetName));

    if (!pielem)
    {
        // The m_cSkipTimer variable is used to allow the skipping of timer ticks when determining 
        // if the mover should be dismissed.  By doing this it gives the user more time and thus
        // a better chance to manipulate the target if they are prone to drifting the mouse
        // outside the target by accident.

        // Check the m_cSkipTimer before dismissing the mover.
        if (!m_cSkipTimer)
        {
            _ChangeCapture(FALSE);
            if (m_pistyle)
                hr = m_pistyle->put_visibility((BSTR)s_sstrHidden.wsz);
            ATOMICRELEASE( m_pistyleTarget );
            ATOMICRELEASE( m_pielemTarget );
            m_iSrcTarget = -1;
        }
        else
        {
            m_cSkipTimer--;
            hr = S_FALSE;
        }

        // These are actions we want to happen right away.
        m_hcursor = CursorFromDragMode(dmNull);
        if (m_hcursor != NULL)
            SetCursor(m_hcursor);
    }

    // These are actions we want to happen after the Desktop Item
    // looses focus.
    if (hr != S_FALSE)
    {
        m_cyCaption = 0;
        m_cxBorder = m_cxSMBorder;
        m_cyBorder = m_cySMBorder;
        m_CaptionState = 0;
        m_dmTrack = dmNull;
    }

    if (pielem)
    {
        ASSERT(m_pielemTarget != pielem);

        // exchange our new target ( if any ) for the old target, if any...
        ATOMICRELEASE( m_pistyleTarget );
        ATOMICRELEASE( m_pielemTarget );

        hr = pielem->get_style(&m_pistyleTarget);
        if (SUCCEEDED(hr))
        {
            // We are gaining focus.
            m_pielemTarget = pielem;
            m_pielemTarget->AddRef();

            EVAL(SUCCEEDED(InitAttributes(m_pielemTarget)));

            if (!pptDoc)
                TrackCaption(NULL);
            TrackTarget(pptDoc);
            // Set m_cSkipTimer so that we delay dismissing the mover...
            m_cSkipTimer = GET_SKIP_COUNT;
            if (!m_bWndLess && !m_hWnd)
            {
                // This is all a hack until trident fixes the UIDeactivate stuff, bug 243801
                IOleInPlaceObject_InPlaceDeactivate();
                InPlaceActivate(OLEIVERB_UIACTIVATE);
                SetControlFocus(TRUE);
            }
        }
    }
   
    return hr;
}

//=--------------------------------------------------------------------------=
// CDeskMovrControl::MoveSelfAndTarget   [instance method]
//=--------------------------------------------------------------------------=
// Moves the control and it's target to a new location.
//
// Parameters:
//    LONG    [in] - x location, in document coord's to move to
//    LONG    [in] - y location, in document coord's to move to
//
// Output:
//    HRESULT      - various. S_OK if  operation succeeded.
//
// Notes:
//      We read back the target's location so that we stay consistent with
//      any constraint's Trident might impose on our movement.

HRESULT CDeskMovr::MoveSelfAndTarget( LONG x, LONG y )
{
    HRESULT hr;

    m_top = y;
    CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelTop( y  - m_cyBorder - m_cyCaption )));
    CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelTop( y  )));
    // read it back to catch Trident constraint.
    //CLEANUP_ON_FAILURE((hr = m_pielemTarget->get_docTop( &m_top )));
    //CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelTop( m_top )));

    m_left = x;
    CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelLeft( x - m_cxBorder )));
    CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelLeft( x  )));
    // read it back to catch Trident constraint.
    //CLEANUP_ON_FAILURE((hr = m_pielemTarget->get_docLeft( &m_left )));
    //CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelLeft( m_left )));

    // if ( !m_bWndLess )
    if (EVAL(S_OK == GetParentWindow()))
        ::UpdateWindow(m_hwndParent);

CleanUp:
    return hr;
}

BOOL CDeskMovr::FFindTargetElement( IHTMLElement *pielem, IHTMLElement **ppielem )
{
    *ppielem = NULL;

    if ( pielem != NULL )
    {
        IDeskMovr   *pidm = NULL;       

        // If it is over the mover return the current target, otherwise
        // find out which component if any we are over.
        if ( m_pielemTarget != NULL && 
               SUCCEEDED(pielem->QueryInterface(IID_IDeskMovr, (LPVOID*)&pidm)))
        {
            m_pielemTarget->AddRef();
            *ppielem = m_pielemTarget;
            ATOMICRELEASE(pidm);
        } else {
            HRESULT hr;
            IHTMLElement *pielem2 = pielem;

            pielem2->AddRef();

            do
            {
                VARIANT     var;
    
                VariantInit( &var );
                
                if ( SUCCEEDED(hr = pielem2->getAttribute( (BSTR)s_sstrNameMember.wsz, TRUE, &var)) ) {
                    if ( var.vt == VT_BSTR && var.bstrVal != NULL ) {
                        if ( StrCmpW( var.bstrVal, m_bstrTargetName ) == 0 )
                            hr = S_OK;
                        else
                            hr = S_FALSE;               
                    } else
                        hr = S_FALSE; // Try VariantChangeType?????
                } else
                    hr = S_FALSE; // not here, maybe in parent.
            
                VariantClear( &var );
    
                if ( hr == S_OK ) { // we found it
                    hr = pielem2->QueryInterface( IID_IHTMLElement, (LPVOID*)ppielem );
                } else if ( hr == S_FALSE ) { // not this one, climb up
                    IHTMLElement *pielemParent = NULL;
                
                    pielem2->get_parentElement( &pielemParent );
                    pielem2->Release();     // we're through at this level
                    pielem2 = pielemParent; // may be null, which just means we've reached the top.
                }
    
            } while ( SUCCEEDED(hr) && *ppielem == NULL && pielem2 != NULL );
        
            ATOMICRELEASE(pielem2);
        }
    }

    return *ppielem != NULL;
}

//=--------------------------------------------------------------------------=
// CDeskMovr::DragModeFromPoint   [instance method]
//=--------------------------------------------------------------------------=
// Moves the control and it's target to a new location.
//
// Parameters:
//    POINT        -  point to test, in local coords
//
// Output:
//    DragMode      - drag mode associated with the point
//
// Notes:
//      This is only a hit testing method. It does not alter state.

CDeskMovr::DragMode CDeskMovr::DragModeFromPoint( POINT pt )
{
    enum DragMode dm = dmNull;
    RECT rc;

    if ( PtInRect( &m_rectInner, pt ) ) 
    { // either no-hit, or on caption
        if ( PtInRect( &m_rectCaption, pt ) ) {
            DragMode dmT;

            for (dmT = dmMenu; dmT < dmMove; dmT = (DragMode)((int)dmT + 1)) {
                if (GetCaptionButtonRect(dmT, &rc) && PtInRect(&rc, pt)) {
                    dm = dmT;
                    break;
                }
            }
            if ((dmT == dmMove) && !CAPTION_ONLY)
                dm = dmMove;
        }
    } else {
        if ( PtInRect( &m_rectOuter, pt ) ) {
            if (!CAPTION_ONLY)
            {
                // a resize border hit
                if ( pt.y <= m_sizeCorner.cy ) {
                    // upper edge or corners
                    if ( pt.x <= m_sizeCorner.cx )
                        dm = dmSizeWHTL;
                    else if ( pt.x >= m_rectOuter.right - m_sizeCorner.cx )
                        dm = dmSizeWHTR;
                    else
                        dm = dmSizeTop;
                } else if ( pt.y >= m_rectOuter.bottom - m_sizeCorner.cy ) {
                    // bottom edge or corners
                    if ( pt.x <= m_sizeCorner.cx )
                        dm = dmSizeWHBL;
                    else if ( pt.x >= m_rectOuter.right - m_sizeCorner.cx )
                    dm = dmSizeWHBR;
                    else
                        dm = dmSizeBottom;
                } else {
                    // side edge hit
                    if ( pt.x > m_rectInner.left )
                        dm = dmSizeRight;
                    else 
                        dm = dmSizeLeft;
                }
            } else {
                if (m_cyCaption == 0)
                {
                    if(IS_BIDI_LOCALIZED_SYSTEM())
                    {
                        dm = dmSizeRight;
                    }
                    else
                    {
                        dm = dmSizeLeft;                        
                    }
                }    
                else
                    dm = dmNull;
            }
        }
        //Check if this element can be sized in both the directions.
        if(!m_fCanResizeX)
        {
            if((dm != dmSizeTop) && (dm != dmSizeBottom))
                dm = dmNull;
        }

        if(!m_fCanResizeY)
        {
            if((dm != dmSizeLeft) && (dm != dmSizeRight))
                dm = dmNull;
        }
    }

    return dm;
}

// Align our member RECTs with the dimensions of the target element.
void CDeskMovr::SyncRectsToTarget(void)
{
    // do the swelling thang
    if ( (m_dmTrack > dmMove) || m_cyCaption ) {
        m_cxBorder = GET_CXSIZE;
        m_cyBorder = GET_CYSIZE;
    } else {
        m_cxBorder = m_cxSMBorder;
        m_cyBorder = m_cySMBorder;
    }

    m_rectOuter.top = m_rectOuter.left = 0;

    if (CAPTION_ONLY)
    {
        if (m_cyCaption != 0)
        {
            // Displaying just caption
            m_rectOuter.bottom = m_cyCaption + m_cyBorder;
            m_rectOuter.right = m_width;
        } else {
            // Displaying just left size border
            m_rectOuter.bottom = m_height;
            if(IS_BIDI_LOCALIZED_SYSTEM())
            {
                m_rectOuter.right = m_width;
                m_rectOuter.left = m_rectOuter.right - m_cxBorder;
            }
            else
            {
                m_rectOuter.right = m_cxBorder;
            }    
        }
    } else {
        // Displaying caption and border
        m_rectOuter.bottom = m_height + 2 * m_cyBorder + m_cyCaption;
        m_rectOuter.right = m_width + 2 * m_cxBorder;
    }

    if (CAPTION_ONLY && m_cyCaption == 0)
    {
        // Displaying just left size border
        SetRectEmpty(&m_rectInner);
        SetRectEmpty(&m_rectCaption);
    } else {
        // Displaying caption and possibly border
        m_rectInner = m_rectOuter;
        InflateRect( &m_rectInner, -m_cxBorder, -m_cyBorder );

        m_rectCaption = m_rectInner;
        m_rectCaption.bottom = m_cyBorder + m_cyCaption;

    }

    if ( m_rectOuter.bottom > 2 * m_cyCaption )
        m_sizeCorner.cy = GET_CYCAPTION;
    else
        m_sizeCorner.cy = m_rectOuter.bottom / 2;

   if ( m_rectOuter.right > 2 * m_cyCaption )
        m_sizeCorner.cx = GET_CYCAPTION;
    else
        m_sizeCorner.cx = m_rectOuter.right / 2;


}

HCURSOR CDeskMovr::CursorFromDragMode( DragMode dm )
{   
    ASSERT( dm >= 0 && dm < cDragModes );
    switch (dm) {
        case dmNull:
        case dmMenu:
        case dmClose:
        case dmMove:
        case dmRestore:
        case dmFullScreen:
        case dmSplit:
        default:
            return LoadCursor(NULL, IDC_ARROW);
        case dmSizeWHBR:
        case dmSizeWHTL:
            return LoadCursor(NULL, IDC_SIZENWSE);
        case dmSizeWHTR:
        case dmSizeWHBL:
            return LoadCursor(NULL, IDC_SIZENESW);
        case dmSizeTop:
        case dmSizeBottom:
            return LoadCursor( NULL, IDC_SIZENS );
        case dmSizeLeft:
        case dmSizeRight:
            return LoadCursor( NULL, IDC_SIZEWE );
    }
}

//=--------------------------------------------------------------------------=
// CDeskMovr::SizeSelfAndTarget   [instance method]
//=--------------------------------------------------------------------------=
// Resizes our control and its target element.
//
// Parameters:
//    LONG    [in] - new width
//    LONG    [in] - new height
//
// Output:
//    HRESULT      - various. S_OK if  operation succeeded.
//
// Notes:
//      We read back the target's dimensions so that we stay consistent with
//      any constraint's Trident might impose on our sizing.

HRESULT CDeskMovr::SizeSelfAndTarget( POINT ptDoc )
{
    HRESULT hr;
    int topOld = m_top;
    int leftOld = m_left;
    int heightOld = m_height;
    int widthOld = m_width;
    int cyCaption = GET_CYCAPTION;

    switch ( m_dmCur ) {
    case dmSizeWHBR:
        m_width = (ptDoc.x + m_dx) - m_left;
        m_height = (ptDoc.y + m_dy) - m_top;
        break;
    case dmSizeWHTL:
        m_top = ptDoc.y + m_dy;
        m_height += topOld - m_top;
        m_left = ptDoc.x + m_dx;
        m_width += leftOld - m_left;
        break;
    case dmSizeWHTR:
        m_top = ptDoc.y + m_dy;
        m_height += topOld - m_top;
        m_width = (ptDoc.x + m_dx) - m_left;
        break;
    case dmSizeWHBL:
        m_height = (ptDoc.y + m_dy) - m_top;
        m_left = ptDoc.x + m_dx;
        m_width += leftOld - m_left;
        break;
    case dmSizeTop:
        m_top = ptDoc.y + m_dy;
        m_height += topOld - m_top;
        break;
    case dmSizeBottom:
        m_height = (ptDoc.y + m_dy) - m_top;
        break;
    case dmSizeLeft:
        m_left = ptDoc.x + m_dx;
        m_width += leftOld - m_left;
        break;
    case dmSizeRight:
        m_width = (ptDoc.x + m_dx) - m_left;
        break;
    default:
        ASSERT(FALSE);
        return E_FAIL;
    }

    // limit shrinkage to keep the handle accessible
    if ( m_height < cyCaption ) {
        m_height = cyCaption;
        if ( m_top != topOld )
            m_top = topOld + heightOld - m_height;
    }
 
    // limit shrinkage to keep the handle accessible
    if ( m_width < (4 * cyCaption) ) {
        m_width = 4 * cyCaption;
        if ( m_left != leftOld )
            m_left = leftOld + widthOld - m_width;
    }

    SyncRectsToTarget();

    if ( m_top != topOld ) {
        CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelTop( m_top )));
        CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelTop( m_top - (m_cyBorder + m_cyCaption) )));
    }

    if ( m_left != leftOld ) {
        CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelLeft( m_left )));
        CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelLeft( m_left - (CAPTION_ONLY ? 0 : m_cxBorder) )));
    }
 
    CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelHeight( m_height )));
    // read it back to catch Trident constraint.
    //CLEANUP_ON_FAILURE((hr = m_pielemTarget->get_docHeight( &m_height )));
    CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelHeight( m_rectOuter.bottom )));

    CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelWidth( m_width )));
    // read it back to catch Trident constraint.
    //CLEANUP_ON_FAILURE((hr = m_pielemTarget->get_docWidth( &m_width )));
    CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelWidth( m_rectOuter.right )));

    if(IS_BIDI_LOCALIZED_SYSTEM() && CAPTION_ONLY)
    {
         CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelLeft(m_rectOuter.left )));
         CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelWidth(m_rectOuter.right - m_rectOuter.left )));

    }

    if (EVAL(S_OK == GetParentWindow()))
        ::UpdateWindow(m_hwndParent);

CleanUp:
    return hr;
}


// IQuickActivate
HRESULT CDeskMovr::QuickActivate(QACONTAINER *pQACont, QACONTROL *pQACtrl)
{
    HRESULT hr = IQuickActivate_QuickActivate(pQACont, pQACtrl);

    if (pQACont)
    {
        ClearFlag(pQACtrl->dwViewStatus, VIEWSTATUS_OPAQUE);
    }

    return hr;
}


HRESULT CDeskMovr::_GetHTMLDoc(IOleClientSite * pocs, IHTMLDocument2 ** pphd2)
{
    HRESULT hr;
    IOleContainer * poc = NULL;

    if (!EVAL(pocs) || !EVAL(pphd2))
        return E_INVALIDARG;

    *pphd2 = NULL;
    hr = pocs->GetContainer(&poc);
    if (SUCCEEDED(hr))
    {
         hr = poc->QueryInterface(IID_IHTMLDocument2, (LPVOID*) pphd2);
         poc->Release();
    }

    return hr;
}



HRESULT CDeskMovr::_IsInElement(HWND hwndParent, POINT * ppt, IHTMLElement ** pphe)
{
    HRESULT hr = E_FAIL;
    ASSERT(pphe);

    *pphe = NULL;
    if (!ppt || ::ScreenToClient(hwndParent, ppt))
    {
        IHTMLDocument2 * phd2;

        ASSERT(m_spClientSite);
        hr = _GetHTMLDoc(m_spClientSite, &phd2);
        if (SUCCEEDED(hr))
        {
            if (ppt)
                hr = phd2->elementFromPoint(ppt->x, ppt->y, pphe);
            else
                hr = phd2->get_activeElement(pphe);

            if (!*pphe && SUCCEEDED(hr))
                hr = E_FAIL;    // Sometimes Trident returns S_FALSE on error.

            phd2->Release();
        }
    }

    return hr;
}



HRESULT CDeskMovr::_EnumComponents(LPFNCOMPENUM lpfn, LPVOID lpvData, DWORD dwData)
{
    HRESULT hr = E_FAIL;
    IActiveDesktop * padt = NULL;

    hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC, IID_IActiveDesktop, (LPVOID *)&padt);
    if (SUCCEEDED(hr))
    {
        int nCount;
        int nIndex;

        hr = padt->GetDesktopItemCount(&nCount, 0);

        if (EVAL(SUCCEEDED(hr)))
        {
            COMPONENT comp;

            for (nIndex = 0; nIndex < nCount; nIndex++)
            {
                comp.dwSize = sizeof(COMPONENT);

                hr = padt->GetDesktopItem(nIndex, &comp, 0);
                if (EVAL(SUCCEEDED(hr)))
                {
                    if ((hr = lpfn(&comp, lpvData, dwData)) != S_OK)
                        break;
                }
            }
        }

        padt->Release();
    }

    return hr;
}

HRESULT CDeskMovr::_EnumElements(LPFNELEMENUM lpfn, LPVOID lpvData, DWORD dwData)
{
    HRESULT hr;
    IHTMLDocument2 * phd2;

    ASSERT(m_spClientSite);

    if (SUCCEEDED(hr = _GetHTMLDoc(m_spClientSite, &phd2)))
    {
        IHTMLElementCollection * pelems;

        if (SUCCEEDED(hr = phd2->get_all(&pelems)))
        {
            VARIANT varIndex;
            VARIANT varDummy;
            IDispatch * pidisp;

            VariantInit(&varDummy);
            varIndex.vt = VT_I4;
            varIndex.lVal = 0;

            // Note:  This loop terminates when trident returns SUCCESS - but with a NULL pidisp.
            while (SUCCEEDED(hr = pelems->item(varIndex, varDummy, &pidisp)) && pidisp)
            {
                IHTMLElement * pielem;

                if (SUCCEEDED(hr = pidisp->QueryInterface(IID_IHTMLElement, (LPVOID *)&pielem)))
                {
                    hr = lpfn(pielem, lpvData, dwData);
                    pielem->Release();
                }

                pidisp->Release();

                if (hr != S_OK)
                    break;

                varIndex.lVal++;
            }

            pelems->Release();
        }
        phd2->Release();
    }
    return hr;
}


HRESULT lpfnZOrderCB(COMPONENT * pcomp, LPVOID lpvData, DWORD dwData)
{
    #define LPZORDERSLOT ((LONG *)lpvData)

    if (dwData ? (pcomp->cpPos.izIndex > *LPZORDERSLOT) : (pcomp->cpPos.izIndex < *LPZORDERSLOT))
        *LPZORDERSLOT = pcomp->cpPos.izIndex;

    return S_OK;
}

HRESULT CDeskMovr::_GetZOrderSlot(LONG * plZOrderSlot, BOOL fTop)
{
    HRESULT hr;

    ASSERT(plZOrderSlot);

    *plZOrderSlot = m_bWindowOnly ? 10000 : 5000;

    hr = _EnumComponents(lpfnZOrderCB, (LPVOID)plZOrderSlot, (DWORD)fTop);

    *plZOrderSlot += fTop ? 2 : -2; // Make sure we are above / below.

    return hr;
}


//=--------------------------------------------------------------------------=
// PersistTargetPosition   [helper function]
//=--------------------------------------------------------------------------=
// Update the registry entries that are the persistence of the desktop HTML.
//
// Parameters:
//    <none>
//
// Output:
//    <none>
//
// Notes:
//      If we fail, we do it quietly.
//=--------------------------------------------------------------------------=

void PersistTargetPosition( IHTMLElement *pielem,
                            int left,
                            int top,
                            int width,
                            int height,
                            int zIndex,
                            BOOL fSaveState,
                            BOOL fSaveOriginal,
                            DWORD dwNewState)
{
    // only do this persistence thing if we're in ( or completing ) an operation
    TCHAR szID[MAX_ID_LENGTH];
    BOOL fOK;

    if (SUCCEEDED(GetHTMLElementStrMember(pielem, szID, SIZECHARS(szID), (BSTR)(s_sstrIDMember.wsz))))
    {
        bool        bChangedPosition, bChangedSize;
        COMPPOS     compPos;

        // 99/03/23 #266412 vtan: The user has moved the deskmovr to a new position
        // make sure that it is within the work area of the display monitors.
        // ValidateComponentPosition() will do this for us and tell us whether the
        // the component got moved or resized.

        compPos.dwSize = sizeof(compPos);
        compPos.iLeft = left;
        compPos.iTop = top;
        compPos.dwWidth = width;
        compPos.dwHeight = height;

        ValidateComponentPosition(&compPos, dwNewState, COMP_TYPE_HTMLDOC, &bChangedPosition, &bChangedSize);
        if (bChangedPosition || bChangedSize)
        {
            IHTMLStyle  *pIStyle;

            // If the component got moved or resized then tell the object model
            // where the deskmovr is now.

            left = compPos.iLeft;
            top = compPos.iTop;
            width = compPos.dwWidth;
            height = compPos.dwHeight;
            if (SUCCEEDED(pielem->get_style(&pIStyle)))
            {
                pIStyle->put_pixelLeft(left);
                pIStyle->put_pixelTop(top);
                pIStyle->put_pixelWidth(width);
                pIStyle->put_pixelHeight(height);
                pIStyle->Release();
            }
        }
        fOK = UpdateDesktopPosition(szID, left, top, width, height, zIndex, fSaveState, fSaveOriginal, dwNewState);
    }

    TraceMsg(TF_CUSTOM2, "PersistTargetPosition(pielem=%s, <left=%d, top=%d, wid=%d, h=%d>)", szID, left, top, width, height);

}

void ObtainSavedStateForElem( IHTMLElement *pielem,
                       LPCOMPSTATEINFO pCompState, BOOL fRestoredState)
{
    // only do this persistence thing if we're in ( or completing ) an operation
    TCHAR szID[MAX_ID_LENGTH];
    BOOL fOK;

    if (SUCCEEDED(GetHTMLElementStrMember(pielem, szID, SIZECHARS(szID), (BSTR)(s_sstrIDMember.wsz))))
        fOK = GetSavedStateInfo(szID, pCompState, fRestoredState);

    TraceMsg(TF_CUSTOM2, "ObtainSavedStateForElem(pielem=%s, <left=%d, top=%d, wid=%d, h=%d>)", szID, pCompState->iLeft, pCompState->iTop, pCompState->dwWidth, pCompState->dwHeight);

}

// IOleObject
HRESULT CDeskMovr::GetMiscStatus(DWORD  dwAspect, DWORD *pdwStatus)
{
    if (dwAspect == DVASPECT_CONTENT)
    {
        *pdwStatus = OLEMISMOVR;
        return S_OK;
    }
    else
    {
        return DV_E_DVASPECT;
    }

    // dead code
}


HRESULT CDeskMovr::SetClientSite(IOleClientSite * pClientSite)
{
    if (!pClientSite)
        DeactivateMovr(FALSE);

    return CComControlBase::IOleObject_SetClientSite(pClientSite);
}

void HandleRestore(IHTMLElement * pielem, LONG lData)
{
    VARIANT varZ;
    COMPSTATEINFO csiRestore;
    IHTMLStyle * pistyle;

    if (SUCCEEDED(pielem->get_style(&pistyle)))
    {
        csiRestore.dwSize = sizeof(csiRestore);

        ObtainSavedStateForElem(pielem, &csiRestore, TRUE); // TRUE => Get restored state!

        pistyle->put_pixelLeft(csiRestore.iLeft);
        pistyle->put_pixelTop(csiRestore.iTop);
        pistyle->put_pixelWidth(csiRestore.dwWidth);
        pistyle->put_pixelHeight(csiRestore.dwHeight);

        varZ.vt = VT_I4;
        varZ.lVal = lData;
        pistyle->put_zIndex(varZ);

        PersistTargetPosition(pielem, csiRestore.iLeft, csiRestore.iTop, csiRestore.dwWidth, csiRestore.dwHeight, varZ.lVal, FALSE, FALSE, IS_NORMAL);
        pistyle->Release();
    }
}

HRESULT lpfnRestoreCB(IHTMLElement * pielem, LPVOID lpvData, LONG lData)
{
    HRESULT hres = S_OK;
    TCHAR szID[MAX_ID_LENGTH];

    if (SUCCEEDED(GetHTMLElementStrMember(pielem, szID, SIZECHARS(szID), (BSTR)(s_sstrIDMember.wsz))))
    {
        DWORD dwState = GetCurrentState(szID);

        // Since there is only one in this state we can stop the enumeration if we
        // find a fullscreen/split item on this work area.
        if (dwState & (IS_FULLSCREEN | IS_SPLIT)) {
            POINT pt;
            if (SUCCEEDED(CSSOM_TopLeft(pielem, &pt)) && PtInRect((CONST RECT *)lpvData, pt))
            {
                HandleRestore(pielem, lData);
                hres = S_FALSE;
            }
        }
    }

    return hres;
}


HRESULT CDeskMovr::_HandleZoom(LONG lCommand)
{
    LONG x, y, cx, cy, zIndex;
    VARIANT varZ;
    DWORD   dwOldItemState = m_ItemState, dwNewItemState;
    IHTMLStyle * pistyleTarget = m_pistyleTarget;
    IHTMLElement * pielemTarget = m_pielemTarget;

    // Paranoia
    if (!pistyleTarget || !pielemTarget)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    // Hold on to these guys during this call, they could go away when we yield
    // like during the animation call below.
    pistyleTarget->AddRef();
    pielemTarget->AddRef();

    if (lCommand == IDM_DCCM_RESTORE)
    {
        COMPSTATEINFO   csi;
        csi.dwSize = sizeof(csi);

        // The "Restore" command toggles with the "Reset Original Size" command.
        // Make sure we get the correct Restore or Reset position for the element.
        ObtainSavedStateForElem(pielemTarget, &csi, !ISNORMAL);

        if (ISNORMAL)
        {
            // This is the split case, dont move the item just resize it.
            x = m_left;
            y = m_top;
        }
        else
        {

//  98/07/27 vtan #176721: The following checks restoration of a component
//  position from zoomed to user-specified position. If the component
//  is placed at the default position then it is positioned now using
//  the standard positioning code.

            if ((csi.iLeft == COMPONENT_DEFAULT_LEFT) &&
                (csi.iTop == COMPONENT_DEFAULT_TOP) &&
                (csi.dwWidth == COMPONENT_DEFAULT_WIDTH) &&
                (csi.dwHeight == COMPONENT_DEFAULT_HEIGHT))
            {
                COMPPOS     compPos;

                GetNextComponentPosition(&compPos);
                IncrementComponentsPositioned();
                csi.iLeft = compPos.iLeft;
                csi.iTop  = compPos.iTop;
                csi.dwWidth = compPos.dwWidth;
                csi.dwHeight = compPos.dwHeight;
            }
            // Restore case, go ahead and move it.
            x = csi.iLeft;
            y = csi.iTop;
        }

        cx = csi.dwWidth;
        cy = csi.dwHeight;
        m_ItemState = (m_ItemState & ~IS_VALIDSIZESTATEBITS) | IS_NORMAL;
        dwNewItemState = m_ItemState;

        m_zIndexTop += 2;
        zIndex = m_zIndexTop;
    }
    else
    {
        RECT rcZoom, rcWork;

        GetZoomRect(lCommand == IDM_DCCM_FULLSCREEN, TRUE, m_left, m_top, m_width, m_height, &rcZoom, &rcWork);
        
        x = rcZoom.left;
        y = rcZoom.top;
        cx = rcZoom.right - rcZoom.left;
        cy = rcZoom.bottom - rcZoom.top;

        if (lCommand == IDM_DCCM_FULLSCREEN)
        {
            m_ItemState = (m_ItemState & ~IS_VALIDSIZESTATEBITS) | IS_FULLSCREEN;
            dwNewItemState = m_ItemState;
        }
        else
        {
            m_ItemState = (m_ItemState & ~IS_VALIDSIZESTATEBITS) | IS_SPLIT;
            dwNewItemState = m_ItemState;
        }

        varZ.vt = VT_I4;
        pistyleTarget->get_zIndex(&varZ);

        // We currently only allow 1 component to be either split or full screen per monitor (WorkArea), so
        // restore any other component that is currently in this state.
        _EnumElements(lpfnRestoreCB, (LPVOID)&rcWork, varZ.lVal);

        m_zIndexBottom -= 2;
        zIndex = m_zIndexBottom;
    }

    // We want to do the animation call before we start moving the target, it looks better
    // that way.
    AnimateComponent(m_hwndParent, m_left, m_top, m_width, m_height, x, y, cx, cy);

    pistyleTarget->put_pixelLeft(x);
    pistyleTarget->put_pixelTop(y);
    pistyleTarget->put_pixelWidth(cx);
    pistyleTarget->put_pixelHeight(cy);

    varZ.vt = VT_I4;
    varZ.lVal = zIndex;
    pistyleTarget->put_zIndex(varZ);

    PersistTargetPosition(pielemTarget, x, y, cx, cy, zIndex, 
                            (BOOL)((dwOldItemState & IS_NORMAL) && !(dwNewItemState & IS_NORMAL)),
                            FALSE, dwNewItemState);

    pistyleTarget->Release();
    pielemTarget->Release();

    return S_OK;
}


/************************************************************************\
    FUNCTION: CDeskMovr::_DisplayContextMenu

    PARAMETERS:
        x,y - Coordinates relative to the desktop window.
\************************************************************************/
HRESULT CDeskMovr::_DisplayContextMenu()
{
    HRESULT hr = S_OK;
    HMENU hmenuContext = LoadMenuPopup(MENU_DESKCOMP_CONTEXTMENU);

    TraceMsg(TF_CUSTOM2, "CDeskMovr::DisplayContextMenu(), m_bstrTargetName=%ls", GEN_DEBUGSTRW(m_bstrTargetName));
    if (hmenuContext)
    {
        int nSelection;
        BOOL fSubscribe = FALSE;
        BOOL fRemoveSubscribe = FALSE;
        TCHAR szName[MAX_URL_STRING];
        POINT point;

        if (CAPTION_ONLY)
        {
            point.x = m_left + m_cxBorder;
            point.y = m_top + (m_cyCaption + m_cyBorder) - 4 * m_cySMBorder;
        } else {
            point.x = m_left - m_cxSMBorder;
            point.y = m_top - 4 * m_cySMBorder;
        }

        ::ClientToScreen(m_hwndParent, &point);

        //  This calculation needs to be revisited.  The reason it's so
        //  ugle and HACKy is because to look good, we want the context menu
        //  to appear on top of the 3-D edge below the triangle.


        if (SUCCEEDED(GetHTMLElementStrMember(m_pielemTarget, szName, SIZECHARS(szName), (BSTR)(s_sstrSubSRCMember.wsz))))
        {
            int nScheme = GetUrlScheme(szName);

            if ((URL_SCHEME_FILE == nScheme) || (URL_SCHEME_INVALID == nScheme))
                fRemoveSubscribe = TRUE;
        }

        // check to see if we need to turn some things off or on
        // Mainly because we are disabling features Admins don't want users to have.

        hr = IElemCheckForExistingSubscription(m_pielemTarget);
        if (fRemoveSubscribe || FAILED(hr))    // This object/thing cannot be subscribed to. (Channel Changer, Orenge Blob).
        {
            MENUITEMINFO    menuItemInfo;

            DeleteMenu(hmenuContext, IDM_DCCM_OFFLINE, MF_BYCOMMAND);
            DeleteMenu(hmenuContext, IDM_DCCM_SYNCHRONIZE, MF_BYCOMMAND);
            DeleteMenu(hmenuContext, IDM_DCCM_PROPERTIES, MF_BYCOMMAND);

            // Is the top item in the list a separator?
            menuItemInfo.cbSize = sizeof(menuItemInfo);
            menuItemInfo.fMask = MIIM_TYPE;
            if ((GetMenuItemInfo(hmenuContext, 0, TRUE, &menuItemInfo) != FALSE) &&
                (menuItemInfo.fType == MFT_SEPARATOR))
            {
                // Yes, it is, so remove it.
                DeleteMenu(hmenuContext, 0, MF_BYPOSITION);
            }
        }
        else if (S_FALSE == hr)      // Not subscribed
        {
            DeleteMenu(hmenuContext, IDM_DCCM_SYNCHRONIZE, MF_BYCOMMAND);
            DeleteMenu(hmenuContext, IDM_DCCM_PROPERTIES, MF_BYCOMMAND);
            fSubscribe = TRUE;
        }
        else if (S_OK == hr)
        {
            if (SHRestricted2(REST_NoManualUpdates, NULL, 0))
                DeleteMenu(hmenuContext, IDM_DCCM_SYNCHRONIZE, MF_BYCOMMAND);
            if (SHRestricted(REST_NOEDITDESKCOMP))
                DeleteMenu(hmenuContext, IDM_DCCM_PROPERTIES, MF_BYCOMMAND);

            CheckMenuItem(hmenuContext, IDM_DCCM_OFFLINE, MF_BYCOMMAND |MF_CHECKED);
        }

        if (SHRestricted(REST_NOCLOSEDESKCOMP))
            EnableMenuItem(hmenuContext, IDM_DCCM_CLOSE, MF_BYCOMMAND | MF_GRAYED);

        // If policy is set to lock down active desktop, don't put up the
        //    menu that invokes the web-tab
        if (SHRestricted(REST_NOACTIVEDESKTOPCHANGES) || SHRestricted(REST_NODISPBACKGROUND))
        {
            EnableMenuItem(hmenuContext, IDM_DCCM_CUSTOMIZE, MF_BYCOMMAND | MF_GRAYED);
        }
        
        if (ISNORMAL)
        {
            COMPSTATEINFO CompState;
            LoadString(HINST_THISDLL, IDS_MENU_RESET, szName, ARRAYSIZE(szName));
            ModifyMenu(hmenuContext, IDM_DCCM_RESTORE, MF_BYCOMMAND | MF_STRING, IDM_DCCM_RESTORE, szName);
            ObtainSavedStateForElem(m_pielemTarget, &CompState, FALSE);
            if ((CompState.dwWidth == COMPONENT_DEFAULT_WIDTH && CompState.dwHeight == COMPONENT_DEFAULT_HEIGHT) ||
                (CompState.dwWidth == (DWORD)m_width && CompState.dwHeight == (DWORD)m_height))
                EnableMenuItem(hmenuContext, IDM_DCCM_RESTORE, MF_BYCOMMAND | MF_GRAYED);
        }
        if (ISSPLIT || !m_fCanResizeX || !m_fCanResizeY)
            EnableMenuItem(hmenuContext, IDM_DCCM_SPLIT, MF_BYCOMMAND | MF_GRAYED);
        if (ISFULLSCREEN || !m_fCanResizeX || !m_fCanResizeY)
            EnableMenuItem(hmenuContext, IDM_DCCM_FULLSCREEN, MF_BYCOMMAND | MF_GRAYED);

        g_fIgnoreTimers |= IGNORE_CONTEXTMENU_UP;

        nSelection = TrackPopupMenu(hmenuContext, TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD, point.x, point.y, 0, m_hwndParent, NULL);
        
        DestroyMenu(hmenuContext);

        m_CaptionState &= ~CS_MENUPUSHED;
        UpdateCaption(DMDC_MENU);

        switch (nSelection)
        {
            case IDM_DCCM_OFFLINE:
                if (fSubscribe)
                    hr = IElemSubscribeDialog(m_pielemTarget, m_hWnd);
                else
                    hr = IElemUnsubscribe(m_pielemTarget);
                break;

            case IDM_DCCM_SYNCHRONIZE:
                hr = IElemUpdate(m_pielemTarget);
                break;

            case IDM_DCCM_PROPERTIES:   // Subscriptions Dialog (Don't let the name fool you)
                TraceMsg(TF_CUSTOM2, "CDeskMovr::_DisplayContextMenu() IDM_DCCM_PROPERTIES m_bstrTargetName=%ls.", GEN_DEBUGSTRW(m_bstrTargetName));
                    hr = IElemGetSubscriptionsDialog(m_pielemTarget, NULL);
                break;

            case IDM_DCCM_CUSTOMIZE:   // Show Display Control Panel set to Components Sheet
                LoadString(HINST_THISDLL, IDS_COMPSETTINGS, szName, ARRAYSIZE(szName));
                SHRunControlPanel(szName, NULL);
                hr = S_OK;
                break;

            case IDM_DCCM_CLOSE:
                ASSERT(!SHRestricted(REST_NOCLOSEDESKCOMP));  // We should never be able to get here.
    
                TraceMsg(TF_CUSTOM2, "CDeskMovr::_DisplayContextMenu() IDM_DCCM_CLOSE m_bstrTargetName=%ls", GEN_DEBUGSTRW(m_bstrTargetName));
//                AnimateToTray(m_hwndParent, m_left, m_top, m_width, m_height);
                hr = IElemCloseDesktopComp(m_pielemTarget);
                break;

            case IDM_DCCM_RESTORE:
            case IDM_DCCM_FULLSCREEN:
            case IDM_DCCM_SPLIT:
                hr = _HandleZoom(nSelection);
                break;

            case IDM_DCCM_OPEN:
                {
                    BOOL fShowFrame = (GetKeyState(VK_SHIFT) < 0) ? !(m_fCanResizeX && m_fCanResizeY) : (m_fCanResizeX && m_fCanResizeY);
                    hr = IElemOpenInNewWindow(m_pielemTarget, m_spClientSite, fShowFrame, m_width, m_height);
                }
                break;

        }

        g_fIgnoreTimers &= ~IGNORE_CONTEXTMENU_UP;

        if (nSelection)
            DismissSelfNow();
    }

    return hr;
}

void CDeskMovr::_MapPoints(int * px, int * py)
{
    if (m_bWndLess)
    {
        *px -= m_left - (CAPTION_ONLY ? 0 : m_cxBorder);
        *py -= m_top - (CAPTION_ONLY ? 0 : (m_cyBorder + m_cyCaption));
    }
}

void CDeskMovr::_ChangeCapture(BOOL fSet)
{
    if (m_fCaptured != fSet)
    {
        m_fCaptured = fSet;
        if (fSet)
        {
            ASSERT(m_spInPlaceSite);
            if (m_bWndLess && m_spInPlaceSite)
            {
                m_fCaptured = SUCCEEDED(m_spInPlaceSite->SetCapture(TRUE));
            }
            else
            {
                ::SetCapture( m_hWnd );
                m_fCaptured = (GetCapture() == m_hWnd);
            }
            if (m_fCaptured)
                g_fIgnoreTimers |= IGNORE_CAPTURE_SET;
        }
        else
        {
            ASSERT(m_spInPlaceSite);
            if (m_bWndLess && m_spInPlaceSite)
            {
                m_spInPlaceSite->SetCapture(FALSE);
            }
            else
            {
                ReleaseCapture();
            }
        
            g_fIgnoreTimers &= ~IGNORE_CAPTURE_SET;
        }
    }
}

// Called from our keyboard hook so that we can implement keyboard invocation and dismissal
// of the deskmovr.
void CDeskMovr::OnKeyboardHook(WPARAM wParam, LPARAM lParam)
{
    IHTMLElement * pielem;
    HWND hwndFocus = GetFocus();

    if (!(g_fIgnoreTimers & IGNORE_CONTEXTMENU_UP) && SUCCEEDED(GetParentWindow()) && ((hwndFocus == m_hwndParent) || ::IsChild(m_hwndParent, hwndFocus)))
    {
        switch (wParam) {
            case VK_MENU:
                if (!m_pielemTarget && !(GetDesktopFlags() & COMPONENTS_LOCKED) && SUCCEEDED(SmartActivateMovr(ERROR_SUCCESS)) && SUCCEEDED(_IsInElement(NULL, NULL, &pielem)))
                {
                    BOOL fDummy;
                    _TrackElement(NULL, pielem, &fDummy);
                    pielem->Release();
                }
                break;

            case VK_ESCAPE:
            case VK_TAB:
                if ((lParam >= 0) && m_pielemTarget)  // If key down, dismiss
                    DismissSelfNow();
                break;

            case VK_SPACE:
                if (m_pielemTarget && (GET_CYCAPTION == m_cyCaption) && (HIWORD(lParam) & KF_ALTDOWN))
                {
                    HandleNonMoveSize(dmMenu);
                }
                break;
        }
    }
}


STDAPI CDeskMovr_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppunk)
{
    return CComCreator< CComPolyObject< CDeskMovr > >::CreateInstance( (LPVOID)pUnkOuter, IID_IUnknown, (LPVOID*)ppunk );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\dde.cpp ===
// Handle dde conversations.

#include "stdafx.h"
#pragma hdrstop

#include <iethread.h>
#include <browseui.h>
#include <shlexec.h>        // Window_IsLFNAware

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

STDAPI_(void) ShellExecCommandFile(LPCITEMIDLIST pidl);  // scffile.cpp

// REARCHITECT: should this be done native for each platform?
#ifdef UNICODE
#define CP_WINNATURAL   CP_WINUNICODE
#else
#define CP_WINNATURAL   CP_WINANSI
#endif

#define DDECONV_NONE                                    0x00000000
#define DDECONV_NO_UNC                                  0x00000001
#define DDECONV_FORCED_CONNECTION                       0x00000002
#define DDECONV_REPEAT_ACKS                             0x00000004
#define DDECONV_FAIL_CONNECTS                           0x00000008
#define DDECONV_MAP_MEDIA_RECORDER                      0x00000010
#define DDECONV_NULL_FOR_STARTUP                        0x00000020
#define DDECONV_ALLOW_INVALID_CL                        0x00000040
#define DDECONV_EXPLORER_SERVICE_AND_TOPIC              0x00000080
#define DDECONV_USING_SENDMSG                           0x00000100
#define DDECONV_NO_INIT                                 0x00000200

// PERF: this data is duplicated in all instances of the
// cabinet but is only used by the first instance!

DWORD g_dwDDEInst = 0L;
HSZ   g_hszTopic = 0;
HSZ   g_hszService = 0;
HSZ   g_hszStar = 0;
HSZ   g_hszShell = 0;
HSZ   g_hszAppProps = 0;
HSZ   g_hszFolders = 0;
BOOL  g_LFNGroups = FALSE;
HWND  g_hwndDde = NULL;
UINT_PTR  g_nTimer = 0;
HWND  g_hwndDDEML = NULL;
HWND  g_hwndClient = NULL;
DWORD g_dwAppFlags = DDECONV_NONE;

// From shell32\nothunk.c
STDAPI_(void) SHGlobalDefect(DWORD dwHnd32);

// From Shell32\shlobjs.c
STDAPI_(void) SHAbortInvokeCommand();

#define IDT_REPEAT_ACKS             10


BOOL Net_DisconnectDrive(TCHAR chDrive)
{
    TCHAR szDrive[3];

    // Disconnect the given drive from it's share.
    szDrive[0] = chDrive;
    szDrive[1] = TEXT(':');
    szDrive[2] = TEXT('\0');
    return WNetCancelConnection2(szDrive, 0, FALSE) == WN_SUCCESS;
}


//
// Lets define a simple structure that handles the different converstations
// that might be happening concurently, I don't expect many conversations
// to happen at the same time, so this can be rather simple
//
struct _DDECONV;
typedef struct _DDECONV  DDECONV, * PDDECONV;
struct _DDECONV
{
    DWORD       dwFlags;                // Flags.
    PDDECONV    pddecNext;
    LONG        cRef;
    HCONV       hconv;                  // Handle to the conversation;
    BOOL        fDirty;                 // Has any changes been made;
    IShellLink  *psl;                   // temp link to work with
    TCHAR        szGroup[MAX_PATH];     // Group pathname
    TCHAR        szShare[MAX_PATH];      // Used to override UNC connections.
    TCHAR        chDrive;                // Used to override UNC connections.
};

PDDECONV    g_pddecHead = NULL;         // List of current conversations.
LPTSTR      g_pszLastGroupName = NULL;  // Last group name used for items
                                        // that are created by programs
                                        // that do not setup a context

DDECONV *DDEConv_Create(void)
{
    DDECONV *pddec = (DDECONV *) LocalAlloc(LPTR, sizeof(DDECONV));
    if (pddec)
        pddec->cRef = 1;
    return pddec;
}

LONG DDEConv_AddRef(DDECONV *pddec)
{
    ASSERT(pddec->cRef > 0);
    return InterlockedIncrement(&pddec->cRef);
}

LONG DDEConv_Release(DDECONV *pddec)
{
    ASSERT(pddec->cRef > 0);
    if (InterlockedDecrement(&pddec->cRef))
        return pddec->cRef;

    //  this needs to be deleted
    if (pddec->pddecNext)
        DDEConv_Release(pddec->pddecNext);

    ATOMICRELEASE(pddec->psl);
        
    // Were we forced to create a redirected drive?
    if (pddec->dwFlags & DDECONV_FORCED_CONNECTION)
    {
        // Yep. Clean it up now.
        Net_DisconnectDrive(pddec->chDrive);
    }

    if ((pddec->dwFlags & DDECONV_REPEAT_ACKS) && g_nTimer)
    {
        KillTimer(NULL, g_nTimer);
        g_nTimer = 0;
    }

    LocalFree(pddec);
    return 0;
}


typedef BOOL (*DDECOMMAND)(LPTSTR lpszBuf, UINT * lpwCmd, PDDECONV pddec);
typedef struct _DDECOMMANDINFO
{
    LPCTSTR     pszCommand;
    DDECOMMAND lpfnCommand;
} DDECOMMANDINFO;

DWORD GetDDEAppFlagsFromWindow(HWND hwnd);
UINT* GetDDECommands(LPTSTR lpCmd, const DDECOMMANDINFO *lpsCommands, BOOL fLFN);

BOOL DDE_AddShellServices(void);
void DDE_RemoveShellServices(void);

BOOL DDE_CreateGroup(LPTSTR, UINT *, PDDECONV);
BOOL DDE_ShowGroup(LPTSTR, UINT *, PDDECONV);
BOOL DDE_AddItem(LPTSTR, UINT *, PDDECONV);
BOOL DDE_ExitProgman(LPTSTR, UINT *, PDDECONV);
BOOL DDE_DeleteGroup(LPTSTR, UINT *, PDDECONV);
BOOL DDE_DeleteItem(LPTSTR, UINT *, PDDECONV);
// BOOL NEAR PASCAL DDE_ReplaceItem(LPSTR, UINT *, PDDECONV);
#define DDE_ReplaceItem DDE_DeleteItem
BOOL DDE_Reload(LPTSTR, UINT *, PDDECONV);
BOOL DDE_ViewFolder(LPTSTR, UINT *, PDDECONV);
BOOL DDE_ExploreFolder(LPTSTR, UINT *, PDDECONV);
BOOL DDE_FindFolder(LPTSTR, UINT *, PDDECONV);
BOOL DDE_OpenFindFile(LPTSTR, UINT *, PDDECONV);
BOOL DDE_ConfirmID(LPTSTR lpszBuf, UINT * lpwCmd, PDDECONV pddec);
BOOL DDE_ShellFile(LPTSTR lpszBuf, UINT * lpwCmd, PDDECONV pddec);
#ifdef DEBUG
BOOL DDE_Beep(LPTSTR, UINT *, PDDECONV);
#endif
void MapGroupName(LPCTSTR lpszOld, LPTSTR lpszNew, ULONG cchNew);

TCHAR const c_szGroupGroup[] = TEXT("groups");
#define c_szStarDotStar TEXT("*.*")
 CHAR const c_szCRLF[] = "\r\n";

TCHAR const c_szCreateGroup[]   = TEXT("CreateGroup");
TCHAR const c_szShowGroup[]     = TEXT("ShowGroup");
TCHAR const c_szAddItem[]       = TEXT("AddItem");
TCHAR const c_szExitProgman[]   = TEXT("ExitProgman");
TCHAR const c_szDeleteGroup[]   = TEXT("DeleteGroup");
TCHAR const c_szDeleteItem[]    = TEXT("DeleteItem");
TCHAR const c_szReplaceItem[]   = TEXT("ReplaceItem");
TCHAR const c_szReload[]        = TEXT("Reload");
TCHAR const c_szFindFolder[]    = TEXT("FindFolder");
TCHAR const c_szOpenFindFile[]  = TEXT("OpenFindFile");
#define c_szDotPif TEXT(".pif")
TCHAR const c_szTrioDataFax[]   = TEXT("DDEClient");
TCHAR const c_szTalkToPlus[]    = TEXT("ddeClass");
TCHAR const c_szStartUp[]       = TEXT("StartUp");
TCHAR const c_szCCMail[]        = TEXT("ccInsDDE");
TCHAR const c_szBodyWorks[]     = TEXT("BWWFrame");
TCHAR const c_szMediaRecorder[] = TEXT("DDEClientWndClass");
TCHAR const c_szDiscis[]        = TEXT("BACKSCAPE");
TCHAR const c_szMediaRecOld[]   = TEXT("MediaRecorder");
TCHAR const c_szMediaRecNew[]   = TEXT("Media Recorder");
TCHAR const c_szDialog[]        = TEXT("#32770");
TCHAR const c_szJourneyMan[]    = TEXT("Sender");
TCHAR const c_szCADDE[]         = TEXT("CA_DDECLASS");
TCHAR const c_szFaxServe[]      = TEXT("Install");
TCHAR const c_szMakePMG[]       = TEXT("Make Program Manager Group");
TCHAR const c_szViewFolder[]    = TEXT("ViewFolder");
TCHAR const c_szExploreFolder[] = TEXT("ExploreFolder");
TCHAR const c_szRUCabinet[]     = TEXT("ConfirmCabinetID");
 CHAR const c_szNULLA[] = "";
TCHAR const c_szGetIcon[] = TEXT("GetIcon");
TCHAR const c_szGetDescription[] = TEXT("GetDescription");
TCHAR const c_szGetWorkingDir[] = TEXT("GetWorkingDir");

TCHAR const c_szService[] = TEXT("Progman");
TCHAR const c_szTopic[] = TEXT("Progman");
#define c_szShell TEXT("Shell")
TCHAR const c_szFolders[] = TEXT("Folders");
TCHAR const c_szMapGroups[] = REGSTR_PATH_EXPLORER TEXT("\\MapGroups");
#define c_szStar TEXT("*")
TCHAR const c_szAppProps[] = TEXT("AppProperties");
#define c_szDotLnk TEXT(".lnk")
 CHAR const c_szDesktopIniA[] = STR_DESKTOPINIA;
 CHAR const c_szGroupsA[] = "Groups";
 
TCHAR const c_szShellFile[]     = TEXT("ShellFile");

TCHAR const c_szMrPostman[]     = TEXT("setupPmFrame");

#ifdef DEBUG
TCHAR const c_szBeep[]          = TEXT("Beep");
#endif


DDECOMMANDINFO const c_sDDECommands[] =
{
    { c_szCreateGroup  , DDE_CreateGroup   },
    { c_szShowGroup    , DDE_ShowGroup     },
    { c_szAddItem      , DDE_AddItem       },
    { c_szExitProgman  , DDE_ExitProgman   },
    { c_szDeleteGroup  , DDE_DeleteGroup   },
    { c_szDeleteItem   , DDE_DeleteItem    },
    { c_szReplaceItem  , DDE_ReplaceItem   },
    { c_szReload       , DDE_Reload        },
    { c_szViewFolder   , DDE_ViewFolder    },
    { c_szExploreFolder, DDE_ExploreFolder },
    { c_szFindFolder,    DDE_FindFolder    },
    { c_szOpenFindFile,  DDE_OpenFindFile  },
    { c_szRUCabinet,     DDE_ConfirmID},
    { c_szShellFile,     DDE_ShellFile},
#ifdef DEBUG
    { c_szBeep         , DDE_Beep          },
#endif
    { 0, 0 },
} ;

#define HDDENULL        ((HDDEDATA)NULL)
#define HSZNULL         ((HSZ)NULL)
#define _DdeCreateStringHandle(dwInst, lpsz, nCP)       DdeCreateStringHandle(dwInst, (LPTSTR)lpsz, nCP)
#define _DdeFreeStringHandle(dwInst, hsz)               if (hsz) DdeFreeStringHandle(dwInst, hsz);
#define _LocalReAlloc(h, cb, flags)      (h ? LocalReAlloc(h, cb, flags) : LocalAlloc(LPTR, cb))

//-------------------------------------------------------------------------
#define ITEMSPERROW 7

typedef struct
{
    LPTSTR pszDesc;
    LPTSTR pszCL;
    LPTSTR pszWD;
    LPTSTR pszIconPath;
    int iIcon;
    BOOL fMin;
    WORD wHotkey;
} GROUPITEM, *PGROUPITEM;

STDAPI_(void) OpenGroup(LPCTSTR pszGroup, int nCmdShow)
{
    IETHREADPARAM *piei = SHCreateIETHREADPARAM(NULL, 0, NULL, NULL);
    if (piei) 
    {
        ASSERT(*pszGroup);
        piei->pidl = ILCreateFromPath(pszGroup);
        piei->uFlags = COF_NORMAL | COF_WAITFORPENDING;
        piei->nCmdShow = SW_NORMAL;

        SHOpenFolderWindow(piei);
    }
}


//--------------------------------------------------------------------------
// Returns a pointer to the first non-whitespace character in a string.
LPTSTR SkipWhite(LPTSTR lpsz)
    {
    /* prevent sign extension in case of DBCS */
    while (*lpsz && (TUCHAR)*lpsz <= TEXT(' '))
        lpsz++;

    return(lpsz);
    }

//--------------------------------------------------------------------------
// Reads a parameter out of a string removing leading and trailing whitespace.
// Terminated by , or ).  ] [ and ( are not allowed.  Exception: quoted
// strings are treated as a whole parameter and may contain []() and ,.
// Places the offset of the first character of the parameter into some place
// and NULL terminates the parameter.
// If fIncludeQuotes is false it is assumed that quoted strings will contain single
// commands (the quotes will be removed and anything following the quotes will
// be ignored until the next comma). If fIncludeQuotes is TRUE, the contents of
// the quoted string will be ignored as before but the quotes won't be
// removed and anything following the quotes will remain.
LPTSTR GetOneParameter(LPCTSTR lpCmdStart, LPTSTR lpCmd,
    UINT *lpW, BOOL fIncludeQuotes)
    {
    LPTSTR     lpT;

    switch (*lpCmd)
        {
        case TEXT(','):
            *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
            *lpCmd++ = 0;                /* comma: becomes a NULL string */
            break;

        case TEXT('"'):
            if (fIncludeQuotes)
            {
                TraceMsg(TF_DDE, "GetOneParameter: Keeping quotes.");

                // quoted string... don't trim off "
                *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
                ++lpCmd;
                while (*lpCmd && *lpCmd != TEXT('"'))
                    lpCmd = CharNext(lpCmd);
                if (!*lpCmd)
                    return(NULL);
                lpT = lpCmd;
                ++lpCmd;

                goto skiptocomma;
            }
            else
            {
                // quoted string... trim off "
                ++lpCmd;
                *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
                while (*lpCmd && *lpCmd != TEXT('"'))
                    lpCmd = CharNext(lpCmd);
                if (!*lpCmd)
                    return(NULL);
                *lpCmd++ = 0;
                lpCmd = SkipWhite(lpCmd);

                // If there's a comma next then skip over it, else just go on as
                // normal.
                if (*lpCmd == TEXT(','))
                    lpCmd++;
            }
            break;

        case TEXT(')'):
            return(lpCmd);                /* we ought not to hit this */

        case TEXT('('):
        case TEXT('['):
        case TEXT(']'):
            return(NULL);                 /* these are illegal */

        default:
            lpT = lpCmd;
            *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
skiptocomma:
            while (*lpCmd && *lpCmd != TEXT(',') && *lpCmd != TEXT(')'))
            {
                /* Check for illegal characters. */
                if (*lpCmd == TEXT(']') || *lpCmd == TEXT('[') || *lpCmd == TEXT('(') )
                    return(NULL);

                /* Remove trailing whitespace */
                /* prevent sign extension */
                if ((TUCHAR)*lpCmd > TEXT(' '))
                    lpT = lpCmd;

                lpCmd = CharNext(lpCmd);
            }

            /* Eat any trailing comma. */
            if (*lpCmd == TEXT(','))
                lpCmd++;

            /* NULL terminator after last nonblank character -- may write over
             * terminating ')' but the caller checks for that because this is
             * a hack.
             */

#ifdef UNICODE
            lpT[1] = 0;
#else
            lpT[IsDBCSLeadByte(*lpT) ? 2 : 1] = 0;
#endif
            break;
        }

    // Return next unused character.
    return(lpCmd);
    }


// Extracts an alphabetic string and looks it up in a list of possible
// commands, returning a pointer to the character after the command and
// sticking the command index somewhere.


LPTSTR GetCommandName(LPTSTR lpCmd, const DDECOMMANDINFO * lpsCommands, UINT *lpW)
    {
    TCHAR chT;
    UINT iCmd = 0;
    LPTSTR lpT;

    /* Eat any white space. */
    lpT = lpCmd = SkipWhite(lpCmd);

    /* Find the end of the token. */
    while (IsCharAlpha(*lpCmd))
        lpCmd = CharNext(lpCmd);

    /* Temporarily NULL terminate it. */
    chT = *lpCmd;
    *lpCmd = 0;

    /* Look up the token in a list of commands. */
    *lpW = (UINT)-1;
    while (lpsCommands->pszCommand)
        {
        if (!lstrcmpi(lpsCommands->pszCommand, lpT))
            {
            *lpW = iCmd;
            break;
            } 
        iCmd++;
        ++lpsCommands;
        }

    *lpCmd = chT;

    return(lpCmd);
    }

/*  Called with: pointer to a string to parse and a pointer to a
 *  list of sz's containing the allowed function names.
 *  The function returns a global handle to an array of words containing
 *  one or more command definitions.  A command definition consists of
 *  a command index, a parameter count, and that number of offsets.  Each
 *  offset is an offset to a parameter in lpCmd which is now zero terminated.
 *  The list of command is terminated with -1.
 *  If there was a syntax error the return value is NULL.
 *  Caller must free block.
 */

UINT* GetDDECommands(LPTSTR lpCmd, const DDECOMMANDINFO * lpsCommands, BOOL fLFN)
{
  UINT cParm, cCmd = 0;
  UINT *lpW;
  UINT *lpRet;
  LPCTSTR lpCmdStart = lpCmd;
  BOOL fIncludeQuotes = FALSE;

  lpRet = lpW = (UINT*)GlobalAlloc(GPTR, 512L);
  if (!lpRet)
      return 0;

  while (*lpCmd)
    {
      /* Skip leading whitespace. */
      lpCmd = SkipWhite(lpCmd);

      /* Are we at a NULL? */
      if (!*lpCmd)
        {
          /* Did we find any commands yet? */
          if (cCmd)
              goto GDEExit;
          else
              goto GDEErrExit;
        }

      /* Each command should be inside square brackets. */
      if (*lpCmd != TEXT('['))
          goto GDEErrExit;
      lpCmd++;

      /* Get the command name. */
      lpCmd = GetCommandName(lpCmd, lpsCommands, lpW);
      if (*lpW == (UINT)-1)
          goto GDEErrExit;

      // We need to leave quotes in for the first param of an AddItem.
      if (fLFN && *lpW == 2)
      {
          TraceMsg(TF_DDE, "GetDDECommands: Potential LFN AddItem command...");
          fIncludeQuotes = TRUE;
      }

      lpW++;

      /* Start with zero parms. */
      cParm = 0;
      lpCmd = SkipWhite(lpCmd);

      /* Check for opening '(' */
      if (*lpCmd == TEXT('('))
        {
          lpCmd++;

          /* Skip white space and then find some parameters (may be none). */
          lpCmd = SkipWhite(lpCmd);

          while (*lpCmd != TEXT(')'))
            {
              if (!*lpCmd)
                  goto GDEErrExit;

              // Only the first param of the AddItem command needs to
              // handle quotes from LFN guys.
              if (fIncludeQuotes && (cParm != 0))
                  fIncludeQuotes = FALSE;

              /* Get the parameter. */
              if (!(lpCmd = GetOneParameter(lpCmdStart, lpCmd, lpW + (++cParm), fIncludeQuotes)))
                  goto GDEErrExit;

              /* HACK: Did GOP replace a ')' with a NULL? */
              if (!*lpCmd)
                  break;

              /* Find the next one or ')' */
              lpCmd = SkipWhite(lpCmd);
            }

          // Skip closing bracket.
          lpCmd++;

          /* Skip the terminating stuff. */
          lpCmd = SkipWhite(lpCmd);
        }

      /* Set the count of parameters and then skip the parameters. */
      *lpW++ = cParm;
      lpW += cParm;

      /* We found one more command. */
      cCmd++;

      /* Commands must be in square brackets. */
      if (*lpCmd != TEXT(']'))
          goto GDEErrExit;
      lpCmd++;
    }

GDEExit:
  /* Terminate the command list with -1. */
  *lpW = (UINT)-1;

  return lpRet;

GDEErrExit:
  GlobalFree(lpW);
  return(0);
}


// lpszBuf is the dde command with NULLs between the commands and the
// arguments.
// *lpwCmd is the number of paramaters.
// *(lpwCmd+n) are offsets to those paramters in lpszBuf.




// Make a long group name valid on an 8.3 machine.
// This assumes the name is already a valid LFN.
void _ShortenGroupName(LPTSTR lpName)
{
    LPTSTR pCh = lpName;

    ASSERT(lpName);

    while (*pCh)
    {
        // Spaces?
        if (*pCh == TEXT(' '))
            *pCh = TEXT('_');
        // Next
        pCh = CharNext(pCh);
        // Limit to 8 chars.
        if (pCh-lpName >= 8)
            break;
    }
    // Null term.
    *pCh = TEXT('\0');
}


// This function will convert the name into a valid file name
void FileName_MakeLegal(LPTSTR lpName)
{
    LPTSTR lpT;

    ASSERT(lpName);

    for (lpT = lpName; *lpT != TEXT('\0'); lpT = CharNext(lpT))
    {
        if (!PathIsValidChar(*lpT, g_LFNGroups ? PIVC_LFN_NAME : PIVC_SFN_NAME))
        {
            // Don't Allow invalid chars in names
            *lpT = TEXT('_');
        }
    }

    // Quick check to see if we support long group names.
    if (!g_LFNGroups)
    {
        // Nope, shorten it.
        _ShortenGroupName(lpName);
    }
}


// Given a ptr to a path and a ptr to the start of its filename componenent
// make the filename legal and tack it on the end of the path.
void GenerateGroupName(LPTSTR lpszPath, LPTSTR lpszName)
{
    ASSERT(lpszPath);
    ASSERT(lpszName);

    // Deal with ":" and "\" in the group name before trying to
    // qualify it.
    FileName_MakeLegal(lpszName);
    PathAppend(lpszPath, lpszName);
    PathQualify(lpszPath);
}


// Simple function used by AddItem, DeleteItem, ReplaceItem to make sure
// that our group name has been setup properly.
void _CheckForCurrentGroup(PDDECONV pddec)
{
    // Need a group - if nothing is specified then we default to using
    // the last group name that someone either created or viewed.
    //
    if (!pddec->szGroup[0])
    {
        // We will use the last context that was set...
        // Note: after that point, we will not track the new create
        // groups and the like of other contexts.
        ENTERCRITICAL;
        if (g_pszLastGroupName != NULL) {
            lstrcpy(pddec->szGroup, g_pszLastGroupName);
        } else {
            CABINETSTATE cs;
            if (IsUserAnAdmin() &&
                    (ReadCabinetState(&cs, sizeof(cs)), cs.fAdminsCreateCommonGroups)) {
                SHGetSpecialFolderPath(NULL, pddec->szGroup, CSIDL_COMMON_PROGRAMS, TRUE);
            } else {
                SHGetSpecialFolderPath(NULL, pddec->szGroup, CSIDL_PROGRAMS, TRUE);
            }
        }
        LEAVECRITICAL;
    }
}


// For those apps that do not setup their context for where to
// add items during their processing we need to keep the path
// of the last group that was created (in g_pszLastGroupName).
void _KeepLastGroup(LPCTSTR lpszGroup)
{
    LPTSTR lpGroup;

    ENTERCRITICAL;

    lpGroup = (LPTSTR)_LocalReAlloc(g_pszLastGroupName, (lstrlen(lpszGroup) + 1) * sizeof(TCHAR), LMEM_MOVEABLE|LMEM_ZEROINIT);
    if (lpGroup != NULL) {
        g_pszLastGroupName = lpGroup;
        lstrcpy(g_pszLastGroupName, lpszGroup);
    }

    LEAVECRITICAL;
}


// NB HACK - Lots of setup apps dot lots of Create/Groups and as we're
// more async now we end up showing lots of identical group windows.
// Also, even the time delay in determining that the group is already
// open can cause some setup apps to get confused.
// So, to stop this happening we keep track of the last group created
// or shown and skip the Cabinet_OpenFolder if it's the same guy and we're
// within a X second timeout limit.
BOOL _SameLastGroup(LPCTSTR lpszGroup)
{
    static DWORD dwTimeOut = 0;
    BOOL fRet = FALSE;
    
    if (lpszGroup && g_pszLastGroupName)
    {
        // Too soon?
        if (GetTickCount() - dwTimeOut < 30*1000)
        {
            LPTSTR pszName1 = PathFindFileName(lpszGroup);
            LPTSTR pszName2 = PathFindFileName(g_pszLastGroupName);
            
            // Yep, same group as last time?
            ENTERCRITICAL;
            if (lstrcmpi(pszName1, pszName2) == 0)
            {
                // Yep.
                fRet = TRUE;
            }
            LEAVECRITICAL;
        }
    }
    
    dwTimeOut = GetTickCount();
    return fRet;
}


// Map the group name to a proper path taking care of the startup group and
// app hacks on the way.
void GetGroupPath(LPCTSTR pszName, LPTSTR pszPath, DWORD dwFlags, INT iCommonGroup)
{
    TCHAR  szGroup[MAX_PATH];
    BOOL   bCommonGroup;
    BOOL   bFindPersonalGroup = FALSE;

    if (pszPath)
        *pszPath = TEXT('\0');

    if (!pszName)
        return;

    //
    // Determine which type of group to create.
    //
    if (IsUserAnAdmin()) {
        if (iCommonGroup == 0) {
            bCommonGroup = FALSE;

        } else if (iCommonGroup == 1) {
            bCommonGroup = TRUE;

        } else {
            //
            // Administrators get common groups created by default
            // when the setup application doesn't specificly state
            // what kind of group to create.  This feature can be
            // turned off in the cabinet state flags.
            //
            CABINETSTATE cs;
            ReadCabinetState(&cs, sizeof(cs));
            if (cs.fAdminsCreateCommonGroups) {
                bFindPersonalGroup = TRUE;
                bCommonGroup = FALSE;   // This might get turned on later
                                        // if find is unsuccessful
            } else {
                bCommonGroup = FALSE;
            }
        }
    } else {
        //
        // Regular users can't create common group items.
        //
        bCommonGroup = FALSE;
    }

    // Handle NULL groups for certain apps and map Startup (non-localised)
    // to the startup group.
    if (((dwFlags & DDECONV_NULL_FOR_STARTUP) && !*pszName)
        || (lstrcmpi(pszName, c_szStartUp) == 0))
    {
        if (bCommonGroup) {
            SHGetSpecialFolderPath(NULL, pszPath, CSIDL_COMMON_STARTUP, TRUE);
        } else {
            SHGetSpecialFolderPath(NULL, pszPath, CSIDL_STARTUP, TRUE);
        }
    }
    else
    {
        // Hack for Media Recorder.
        if (dwFlags & DDECONV_MAP_MEDIA_RECORDER)
        {
            if (lstrcmpi(pszName, c_szMediaRecOld) == 0)
                lstrcpy(szGroup, c_szMediaRecNew);
            else
                lstrcpy(szGroup, pszName);
        }
        else
        {
            // Map group name for FE characters which have identical
            // twins in both DBCS/SBCS. Stolen from grpconv's similar
            // function.

            MapGroupName(pszName, szGroup, ARRAYSIZE(szGroup));
        }

        // Possibly find existing group
        if (bFindPersonalGroup)
        {
            SHGetSpecialFolderPath(NULL, pszPath, CSIDL_PROGRAMS, TRUE);
            GenerateGroupName(pszPath, szGroup);
            if (PathFileExistsAndAttributes(pszPath, NULL))
            {
                return;
            }
            bCommonGroup = TRUE;
        }

        // Get the first bit of the path for this group.
        if (bCommonGroup) {
            SHGetSpecialFolderPath(NULL, pszPath, CSIDL_COMMON_PROGRAMS, TRUE);
        } else {
            SHGetSpecialFolderPath(NULL, pszPath, CSIDL_PROGRAMS, TRUE);
        }

        GenerateGroupName(pszPath, szGroup);
    }
}

BOOL IsParameterANumber(LPTSTR lp)
{
  while (*lp) {
      if (*lp < TEXT('0') || *lp > TEXT('9'))
          return(FALSE);
      lp++;
  }
  return(TRUE);
}


// [ CreateGroup ( Group Name [, Group File] [,Common Flag] ) ]
// REVIEW UNDONE Allow the use of a group file to be specified.
BOOL DDE_CreateGroup(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    BOOL bRet;
    INT iCommonGroup = -1;
    TCHAR szGroup[MAX_PATH];     // Group pathname

    DBG_ENTER(FTF_DDE, DDE_CreateGroup);

    if ((*lpwCmd > 3) || (*lpwCmd == 0))
    {
        bRet = FALSE;
        goto Leave;
    }

    if (*lpwCmd >= 2) {

        //
        // Need to check for common group flag
        //
        if (*lpwCmd == 3) {
            if (lpszBuf[*(lpwCmd + 3)] == TEXT('1')) {
                iCommonGroup = 1;
            } else {
                iCommonGroup = 0;
            }
        } else if (*lpwCmd == 2 && IsParameterANumber(lpszBuf + *(lpwCmd+2))) {
            if (lpszBuf[*(lpwCmd + 2)] == TEXT('1')) {
                iCommonGroup = 1;
            } else {
                iCommonGroup = 0;
            }
        }
    }

    lpwCmd++;

    GetGroupPath(&lpszBuf[*lpwCmd], szGroup, pddec->dwFlags, iCommonGroup);

    TraceMsg(TF_DDE, "Create Group %s", (LPTSTR) szGroup);

    // Stop creating lots of identical folders.
    if (!_SameLastGroup(szGroup))
    {
        lstrcpy(pddec->szGroup,szGroup);    // Now working on this group...

        // If it doesn't exist then create it.
        if (!PathFileExistsAndAttributes(pddec->szGroup, NULL))
        {
            if (CreateDirectory(pddec->szGroup, NULL))
            {
                SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, pddec->szGroup, NULL);
            }
            else
            {
                bRet = FALSE;
                goto Leave;
            }
        }

        // Show it.
        OpenGroup(pddec->szGroup, SW_NORMAL);
        _KeepLastGroup(pddec->szGroup);
    }
    else
    {
        TraceMsg(TF_DDE, "Ignoring duplicate CreateGroup");
    }

    bRet = TRUE;

Leave:
    DBG_EXIT_BOOL(FTF_DDE, DDE_CreateGroup, bRet);

    return bRet;
}


// REVIEW HACK - Don't just caste, call GetConvInfo() to get this.
#define _GetDDEWindow(hconv)    ((HWND)hconv)


// Return the hwnd of the guy we're talking too.
HWND _GetDDEPartnerWindow(HCONV hconv)
{
        CONVINFO ci;

        ci.hwndPartner = NULL;
        ci.cb = sizeof(ci);
        DdeQueryConvInfo(hconv, QID_SYNC, &ci);
        return ci.hwndPartner;
}


// [ ShowGroup (group_name, wShowParm) ]
// REVIEW This sets the default group - not neccessarily what progman
// used to do but probably close enough.
BOOL DDE_ShowGroup(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    BOOL bRet;
    int nShowCmd;
    BOOL fUseStartup = FALSE;
    TCHAR szGroup[MAX_PATH];
    INT iCommonGroup = -1;

    DBG_ENTER(FTF_DDE, DDE_ShowGroup);

    if (*lpwCmd < 2 || *lpwCmd > 3)
    {
        bRet = FALSE;
        goto Leave;
    }

    if (*lpwCmd == 3) {

        //
        // Need to check for common group flag
        //

        if (lpszBuf[*(lpwCmd + 3)] == TEXT('1')) {
            iCommonGroup = 1;
        } else {
            iCommonGroup = 0;
        }
    }

    lpwCmd++;

    GetGroupPath(&lpszBuf[*lpwCmd], szGroup, pddec->dwFlags, iCommonGroup);

    // NB VJE-r setup passes an invalid group name to ShowGroup command.
    // Use szGroup and check it before copying it to pddec->szGroup.
    if (!PathFileExistsAndAttributes(szGroup, NULL))
    {
        bRet = FALSE;
        goto Leave;
    }

    // Get the show cmd.
    lpwCmd++;
    nShowCmd = StrToInt(&lpszBuf[*lpwCmd]);
    TraceMsg(TF_DDE, "Showing %s (%d)", (LPTSTR)szGroup, nShowCmd);

    // Stop lots of cabinet windows from appearing without slowing down the dde
    // conversation if we're just doing a ShowNormal/ShowNA of a group we probably
    // just created.
    switch (nShowCmd)
    {
        case SW_SHOWNORMAL:
        case SW_SHOWNOACTIVATE:
        case SW_SHOW:
        case SW_SHOWNA:
        {
            if (_SameLastGroup(szGroup))
            {
                TraceMsg(TF_DDE, "Ignoring duplicate ShowGroup.");
                bRet = TRUE;
                goto Leave;
            }
            break;
        }
        case SW_SHOWMINNOACTIVE:
        {
                nShowCmd = SW_SHOWMINIMIZED;
                break;
        }
    }

    // It's OK to use the new group.
    lstrcpy(pddec->szGroup, szGroup);

    // Else
    _KeepLastGroup(pddec->szGroup);

    OpenGroup(pddec->szGroup, nShowCmd);

    bRet = TRUE;

Leave:
    DBG_EXIT_BOOL(FTF_DDE, DDE_ShowGroup, bRet);

    return bRet;
}



// [ DeleteGroup (group_name) ]
BOOL DDE_DeleteGroup(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    BOOL bRet;
    TCHAR  szGroupName[MAX_PATH];
    INT iCommonGroup = -1;

    DBG_ENTER(FTF_DDE, DDE_DeleteGroup);

    if (*lpwCmd < 1 || *lpwCmd > 3)
    {
        bRet = FALSE;
        goto Leave;
    }

    if (*lpwCmd == 2) {
        //
        // Need to check for common group flag
        //

        if (lpszBuf[*(lpwCmd + 2)] == TEXT('1')) {
            iCommonGroup = 1;
        } else {
            iCommonGroup = 0;
        }
    }

    lpwCmd++;

    GetGroupPath(&lpszBuf[*lpwCmd], szGroupName, pddec->dwFlags, iCommonGroup);

    if (!PathFileExistsAndAttributes(szGroupName, NULL))
    {
        bRet = FALSE;
        goto Leave;
    }

    szGroupName[lstrlen(szGroupName) + 1] = TEXT('\0');     // double NULL terminate

    // Now simply try to delete the group!
    // Use copy engine that will actually move to trash can...
    {
        SHFILEOPSTRUCT sFileOp =
        {
            NULL,
            FO_DELETE,
            szGroupName,
            NULL,
            FOF_RENAMEONCOLLISION | FOF_NOCONFIRMATION | FOF_SILENT,
        } ;

        TraceMsg(TF_DDE, "Deleting group %s.", szGroupName);

        SHFileOperation(&sFileOp);

        TraceMsg(TF_DDE, "Finished deleting");

    }

    // Clear the last group flag so that Create+Delete+Create
    // does the right thing.
    _KeepLastGroup(c_szNULL);
    bRet = TRUE;

Leave:
    DBG_EXIT_BOOL(FTF_DDE, DDE_DeleteGroup, bRet);

    return bRet;
}


// Take the filename part of a path, copy it into lpszName and the pretty it
// up so it can be used as a link name.
void BuildDefaultName(LPTSTR lpszName, LPCTSTR lpszPath)
{
    LPTSTR lpszFilename;

    lpszFilename = PathFindFileName(lpszPath);
    lstrcpy(lpszName, lpszFilename);
    // NB Path remove extension can only remove extensions from filenames
    // not paths.
    PathRemoveExtension(lpszName);
    CharLower(lpszName);
    CharUpperBuff(lpszName, 1);
}


BOOL HConv_PartnerIsLFNAware(HCONV hconv)
{
    HWND hwndPartner = _GetDDEPartnerWindow(hconv);

    // If this is being forwared by the desktop then assume the app isn't
    // LFN aware.
    if (IsDesktopWindow(hwndPartner))
        return FALSE;
    else
        return Window_IsLFNAware(hwndPartner);
}


BOOL PrivatePathStripToRoot(LPTSTR szRoot)
{
    while(!PathIsRoot(szRoot))
    {
        if (!PathRemoveFileSpec(szRoot))
        {
            // If we didn't strip anything off,
            // must be current drive
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL Net_ConnectDrive(LPCTSTR pszShare, TCHAR *pchDrive)
{
    DWORD err;
    NETRESOURCE nr;
    TCHAR szAccessName[MAX_PATH];
    ULONG cbAccessName = sizeof(szAccessName);
    DWORD dwResult;

    // Connect to the given share and return the drive that it's on.
    nr.lpRemoteName = (LPTSTR)pszShare;
    nr.lpLocalName = NULL;
    nr.lpProvider = NULL;
    nr.dwType = RESOURCETYPE_DISK;
    err = WNetUseConnection(NULL, &nr, NULL, NULL, CONNECT_TEMPORARY | CONNECT_REDIRECT,
        szAccessName, &cbAccessName, &dwResult);
    if (err == WN_SUCCESS)
    {
        TraceMsg(TF_DDE, "Net_ConnextDrive: %s %s %x", pszShare, szAccessName, dwResult);
        if (pchDrive)
            *pchDrive = szAccessName[0];
        return TRUE;
    }

    return FALSE;
}


// Convert (\\foo\bar\some\path, X) to (X:\some\path)
void Path_ChangeUNCToDrive(LPTSTR pszPath, TCHAR chDrive)
{
    TCHAR szPath[MAX_PATH];
    LPTSTR pszSpec;

    lstrcpy(szPath, pszPath);
    PrivatePathStripToRoot(szPath);
    pszPath[0] = chDrive;
    pszPath[1] = TEXT(':');
    pszPath[2] = TEXT('\\');
    pszSpec = pszPath + lstrlen(szPath) + 1;
    if (*pszSpec)
        lstrcpy(&pszPath[3],pszSpec);
}


LPITEMIDLIST Pidl_CreateUsingAppPaths(LPCTSTR pszApp)
{
    TCHAR sz[MAX_PATH];
    long cb = sizeof(sz);

    TraceMsg(TF_DDE, "Trying app paths...");

    lstrcpy(sz, REGSTR_PATH_APPPATHS);
    PathAppend(sz, pszApp);
    if (SHRegQueryValue(HKEY_LOCAL_MACHINE, sz, sz, &cb) == ERROR_SUCCESS)
    {
        return ILCreateFromPath(sz);
    }
    return NULL;
}


// [ AddItem (command,name,icopath,index,pointx,pointy, defdir,hotkey,fminimize,fsepvdm) ]
// This adds things to the current group ie what ever's currently in
// the conversations szGroup string
BOOL DDE_AddItem(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    BOOL bRet;
    UINT nParams;

    TCHAR szTmp[MAX_PATH];
    TCHAR szName[MAX_PATH];
    TCHAR szCL[MAX_PATH*2];     // scratch for path + args.
    WCHAR wszPath[MAX_PATH];
    LPTSTR lpszArgs;
    UINT iIcon;
    int nShowCmd;
    BOOL fIconPath = FALSE;
    LPITEMIDLIST pidl;
    IPersistFile *ppf;
    LPTSTR dirs[2];
    TCHAR chDrive;

    DBG_ENTER(FTF_DDE, DDE_AddItem);

    // Make sure group name is setup
    _CheckForCurrentGroup(pddec);

    // Only certain param combinations are allowed.
    nParams = *lpwCmd;
    if (nParams < 1 || nParams == 5 || nParams > 10)
    {
        bRet = FALSE;
        goto Leave;
    }

    // Make a copy and do fixup on the command.
    //
    // This fixing up was needed for Norton Utilities 2.0 which passed
    // unquoted long filenames with spaces.
    //
    *szCL = 0 ;
    lpwCmd++;
    if( lpszBuf && lpszBuf[*lpwCmd] )
    {
        TCHAR szTmp[MAX_PATH * 2];
        int cch;

        lstrcpyn(szTmp, &lpszBuf[*lpwCmd], ARRAYSIZE(szCL));
        cch = lstrlen(szTmp);

        // Is this string inside quotes?
        if ((cch > 1) && (szTmp[0] == TEXT('"')) && (szTmp[cch-1] == TEXT('"')))
        {
            LPTSTR pszChar;

            // HACKHACK (reinerf)
            // some apps pass us quoted strings that contain both the exe and the args (eg lotus cc:mail 8.0)
            // others apps pass a quoted relative path that does NOT have args, but _does_ contain spaces (eg WSFtpPro6).
            // so we only strip off the outside quotes if one of the characters inside is NOT a legal filename character,
            // indicating that there are args in the string
            for (pszChar = &szTmp[1]; pszChar < &szTmp[cch-1]; pszChar = CharNext(pszChar))
            {
                if (!PathIsValidChar(*pszChar, PIVC_LFN_FULLPATH | PIVC_ALLOW_QUOTE))
                {
                    // we found something that isint a legal path character (eg '/'), so we assume that this 
                    // string has args within the quotes and we strip them off (eg ""c:\foo\bar.exe /s /v:1"")
                    PathUnquoteSpaces(szTmp);
                    break;
                }
            }
        }
        
        if( PathProcessCommand( szTmp, szCL, ARRAYSIZE(szCL),
                                PPCF_ADDQUOTES|PPCF_ADDARGUMENTS|PPCF_LONGESTPOSSIBLE ) <= 0 )
            lstrcpyn( szCL, szTmp, ARRAYSIZE(szCL) ) ;
    }
    
    if( !*szCL )
    {
        bRet = FALSE ;
        goto Leave ;
    } 
                            
#ifdef DEBUG
    // Separate the args.
    if (HConv_PartnerIsLFNAware(pddec->hconv))
    {
        // Quotes will have been left in the string.
        TraceMsg(TF_DDE, "Partner is LFN aware.");
    }
    else
    {
        // Quotes will have been removed from the string.
        TraceMsg(TF_DDE, "Partner is not LFN aware.");
    }
#endif

    // We initialize the IDLIst of this shell link to NULL, such that
    // when we set it later it won't mess around with the working directory
    // we may have set.
    pddec->psl->SetIDList(NULL);

    // NB - This can deal with quoted spaces.
    PathRemoveBlanks(szCL);
    lpszArgs = PathGetArgs(szCL);
    if (*lpszArgs)
        *(lpszArgs-1) = TEXT('\0');

    // Win32/Win4.0 setup apps are allowed to use paths with (quoted)
    // spaces in them so we may need to remove them now.
    PathUnquoteSpaces(szCL);

    pddec->psl->SetArguments(lpszArgs);

    // Special case UNC paths.
    if ((pddec->dwFlags & DDECONV_NO_UNC) && PathIsUNC(szCL))
    {
        TCHAR szShare[MAX_PATH];

        // CL is a UNC but we know this app can't handle UNC's, we'll need to
        // fake up a drive for it.
        TraceMsg(TF_DDE, "Mapping UNC to drive.");

        // Get the server/share name.
        StringCchCopy(szShare, ARRAYSIZE(szShare), szCL);   // truncation ok since we strip to root
        PrivatePathStripToRoot(szShare);
        // Do we already have a cached connection to this server share?
        if (lstrcmpi(szShare, pddec->szShare) == 0)
        {
            // Yes
            TraceMsg(TF_DDE, "Using cached connection.");
            // Mangle the path to use the drive instead of the UNC.
            Path_ChangeUNCToDrive(szCL, pddec->chDrive);
        }
        else
        {
            // No
            TraceMsg(TF_DDE, "Creating new connection.");
            // Make a connection.
            if (Net_ConnectDrive(szShare, &chDrive))
            {
                // Store the server/share.
                lstrcpy(pddec->szShare, szShare);
                // Store the drive.
                pddec->chDrive = chDrive;
                // Set the DDECONV_FORCED_CONNECTION flag so we can cleanup later.
                pddec->dwFlags |= DDECONV_FORCED_CONNECTION;
                // Mangle the path to use the drive instead of the UNC.
                Path_ChangeUNCToDrive(szCL, pddec->chDrive);
            }
            else
            {
                TraceMsg(TF_DDE, "Can't create connection.");
            }
        }
        TraceMsg(TF_DDE, "CL changed to %s.", szCL);
    }

    // Is there a name?
    szName[0] = TEXT('\0');
    if (nParams > 1)
    {
        // Yep,
        lpwCmd++;
        lstrcpy(szName, &lpszBuf[*lpwCmd]);
    }

    // Make absolutely sure we have a name.
    if (!szName[0])
        BuildDefaultName(szName, szCL);

    // Make it legal.
    FileName_MakeLegal(szName);

    // NB Skip setting the CL until we get the WD, we may need
    // it.

    // Deal with the icon path.
    if (nParams > 2)
    {
        lpwCmd++;
        lstrcpy(szTmp, &lpszBuf[*lpwCmd]);
        if (*szTmp)
        {
            // Some people try to put arguments on the icon path line.
            lpszArgs = PathGetArgs(szTmp);
            if (*lpszArgs)
                *(lpszArgs-1) = TEXT('\0');
            // Save it.
            fIconPath = TRUE;
        }
    }
    else
    {
        szTmp[0] = TEXT('\0');
    }

    iIcon = 0;
    // Icon index
    if (nParams > 3)
    {
        lpwCmd++;
        // They must have had an icon path for this to make sense.
        if (fIconPath)
        {
            iIcon = StrToInt(&lpszBuf[*lpwCmd]);
            // REVIEW Don't support icon indexs > 666 hack anymore.
            // It used to mark this item as the selected one. This
            // won't work in the new shell.
            if (iIcon >= 666)
            {
                iIcon -= 666;
            }
        }
    }

    pddec->psl->SetIconLocation(szTmp, iIcon);

    // Get the point :-)
    // REVIEW UNDONE ForcePt stuff for ReplaceItem.
    if (nParams > 4)
    {
        POINT ptIcon;
        lpwCmd++;
        ptIcon.x = StrToInt(&lpszBuf[*lpwCmd]);
        lpwCmd++;
        ptIcon.y = StrToInt(&lpszBuf[*lpwCmd]);
    }

    // The working dir. Do we need a default one?
    if (nParams > 6)
    {
        lpwCmd++;
        lstrcpy(szTmp, &lpszBuf[*lpwCmd]);
    }
    else
    {
        szTmp[0] = TEXT('\0');
    }

    // If we don't have a default directory, try to derive one from the
    // given CL (unless it's a UNC).
    if (!szTmp[0])
    {
        // Use the command for this.
        // REVIEW UNDONE It would be better fo the WD and the IP to be
        // moveable like the CL.
        lstrcpyn(szTmp, szCL, ARRAYSIZE(szTmp));
        // Remove the last component.
        PathRemoveFileSpec(szTmp);
    }

    // Don't use UNC paths.
    if (PathIsUNC(szTmp))
        pddec->psl->SetWorkingDirectory(c_szNULL);
    else
        pddec->psl->SetWorkingDirectory(szTmp);

    // Now we have a WD we can deal with the command line better.
    dirs[0] = szTmp;
    dirs[1] = NULL;
    PathResolve(szCL, (LPCTSTR*)dirs, PRF_TRYPROGRAMEXTENSIONS | PRF_VERIFYEXISTS);

    pidl = ILCreateFromPath(szCL);
    if (!pidl)
    {
        TraceMsg(TF_DDE, "Can't create IL from path. Using simple idlist.");
        // REVIEW UNDONE Check that the file doesn't exist.
        pidl = SHSimpleIDListFromPath(szCL);
        // The Family Circle Cookbook tries to create a shortcut
        // to wordpad.exe but since that's now not on the path
        // we can't find it. The fix is to do what ShellExec does
        // and check the App Paths section of the registry.
        if (!pidl)
        {
            pidl = Pidl_CreateUsingAppPaths(szCL);
        }
    }

    if (pidl)
    {
        pddec->psl->SetIDList(pidl);
        ILFree(pidl);
    }
    else
    {
        TraceMsg(TF_DDE, "Can't create idlist for %s", szCL);

        if (pddec->dwFlags & DDECONV_ALLOW_INVALID_CL)
            bRet = TRUE;
        else
            bRet = FALSE;

        goto Leave;
    }

    // Hotkey.
    if (nParams > 7)
    {
        WORD wHotkey;
        lpwCmd++;
        wHotkey = (WORD)StrToInt(&lpszBuf[*lpwCmd]);
        pddec->psl->SetHotkey(wHotkey);
    }
    else
    {
        pddec->psl->SetHotkey(0);
    }

    // Show command
    if (nParams > 8)
    {
        lpwCmd++;
        if (StrToInt(&lpszBuf[*lpwCmd]))
            nShowCmd = SW_SHOWMINNOACTIVE;
        else
            nShowCmd = SW_SHOWNORMAL;
        pddec->psl->SetShowCmd(nShowCmd);
    }
    else
    {
        pddec->psl->SetShowCmd(SW_SHOWNORMAL);
    }
    if (nParams > 9)
    {
        lpwCmd++;
        if (StrToInt(&lpszBuf[*lpwCmd]))
        {
            // FEATURE - BobDay - Handle Setup of Seperate VDM flag!
            // pddec->psl->SetSeperateVDM(pddec->psl, wHotkey);
        }
    }

    pddec->fDirty = TRUE;

    PathCombine(szTmp, pddec->szGroup, szName);
    lstrcat(szTmp, c_szDotLnk);
    PathQualify(szTmp);

    // We need to handle link duplication problems on SFN drives.
    if (!IsLFNDrive(szTmp) && PathFileExistsAndAttributes(szTmp, NULL))
        PathYetAnotherMakeUniqueName(szTmp, szTmp, NULL, NULL);

    pddec->psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf);

    SHTCharToUnicode(szTmp, wszPath, ARRAYSIZE(wszPath));
    ppf->Save(wszPath, TRUE);
    ppf->Release();
    // REVIEW - Sometimes links don't get the right icons. The theory is that
    // a folder in the process of opening (due to a CreateGroup) will pick
    // up a partially written .lnk file. When the link is finally complete
    // we send a SHCNE_CREATE but this will get ignored if defview already has
    // the incomplete item. To hack around this we generate an update item
    // event to force an incomplete link to be re-read.
    TraceMsg(TF_DDE, "Generating events.");

    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szTmp, NULL);
    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szTmp, NULL);

    bRet = TRUE;

Leave:
    DBG_EXIT_BOOL(FTF_DDE, DDE_AddItem, bRet);

    return bRet;
}




// [ DeleteItem (ItemName)]
// This deletes the specified item from a group
BOOL DDE_DeleteItem(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    BOOL bRet;
    TCHAR szPath[MAX_PATH];

    DBG_ENTER(FTF_DDE, DDE_DeleteItem);

    if (*lpwCmd != 1)
    {
        bRet = FALSE;
    }
    else
    {
        lpwCmd++;

        // Make sure group name is setup
        _CheckForCurrentGroup(pddec);

        pddec->fDirty = TRUE;

        // REVIEW IANEL Hardcoded .lnk and .pif
        PathCombine(szPath, pddec->szGroup, &lpszBuf[*lpwCmd]);
        lstrcat(szPath, c_szDotLnk);
        bRet = Win32DeleteFile(szPath);

        PathCombine(szPath, pddec->szGroup, &lpszBuf[*lpwCmd]);
        lstrcat(szPath, c_szDotPif);
        bRet |= DeleteFile(szPath);
    }

    DBG_EXIT_BOOL(FTF_DDE, DDE_DeleteItem, bRet);

    return bRet;
}


// [ ExitProgman (bSaveGroups) ]
// REVIEW This doesn't do anything in the new shell. It's supported to stop
// old installations from barfing.
// REVIEW UNDONE - We should keep track of the groups we've shown
// and maybe hide them now.
BOOL DDE_ExitProgman(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    return TRUE;
}


// [ Reload (???) ]
// REVIEW Just return FALSE
BOOL DDE_Reload(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    return FALSE;
}


PDDECONV DDE_MapHConv(HCONV hconv)
{
    PDDECONV pddec;

    ENTERCRITICAL;
    for (pddec = g_pddecHead; pddec != NULL; pddec = pddec->pddecNext)
    {
        if (pddec->hconv == hconv)
            break;
    }

    if (pddec)
        DDEConv_AddRef(pddec);
        
    LEAVECRITICAL;

    TraceMsg(TF_DDE, "Mapping " SPRINTF_PTR " -> " SPRINTF_PTR , (DWORD_PTR)hconv, (ULONG_PTR)(LPVOID)pddec);
    return(pddec);
}

//
//  This data structure is used to return the error information from
// _GetPIDLFromDDEArgs to its caller. The caller may pop up a message
// box using this information. idMsg==0 indicates there is no such
// information.
//
typedef struct _SHDDEERR {      // sde (Software Design Engineer, Not!)
    UINT idMsg;
    TCHAR szParam[MAX_PATH];
} SHDDEERR, *PSHDDEERR;


// Helper function to convert passed in command parameters into the
// appropriate Id list
LPITEMIDLIST _GetPIDLFromDDEArgs(UINT nArg, LPTSTR lpszBuf, UINT * lpwCmd, PSHDDEERR psde, LPCITEMIDLIST *ppidlGlobal)
{
    LPTSTR lpsz;
    LPITEMIDLIST pidl = NULL;
    
    // Switch from 0-based to 1-based 
    ++nArg;
    if (*lpwCmd < nArg)
    {
        TraceMsg(TF_DDE, "Invalid parameter count of %d", *lpwCmd);
        return NULL;
    }

    // Skip to the right argument
    lpwCmd += nArg;
    lpsz = &lpszBuf[*lpwCmd];

    TraceMsg(TF_DDE, "Converting \"%s\" to pidl", lpsz);
    // REVIEW: all associations will go through here.  this
    // is probably not what we want for normal cmd line type operations

    // A colon at the begining of the path means that this is either
    // a pointer to a pidl (win95 classic) or a handle:pid (all other
    // platforms including win95+IE4).  Otherwise, it's a regular path.

    if (lpsz[0] == TEXT(':'))
    {
        HANDLE hMem;
        DWORD  dwProcId;
        LPTSTR pszNextColon;

        // Convert the string into a pidl.

        hMem =  LongToHandle(StrToLong((LPTSTR)(lpsz+1))) ;
        pszNextColon = StrChr(lpsz+1,TEXT(':'));
        if (pszNextColon)
        {
            LPITEMIDLIST pidlShared;

            dwProcId = (DWORD)StrToLong(pszNextColon+1);
            pidlShared = (LPITEMIDLIST)SHLockShared(hMem,dwProcId);
            if (pidlShared && !IsBadReadPtr(pidlShared,1))
            {
                pidl = ILClone(pidlShared);
                SHUnlockShared(pidlShared);
            }
            else
            {
                TraceMsg(TF_WARNING, "DDE SHMem failed - App probably forgot to pass SEE_MASK_FLAG_DDEWAIT");
            }
            SHFreeShared(hMem,dwProcId);
        }
        else if ( hMem && !IsBadReadPtr( hMem, sizeof(WORD)))
        {
            // this is likely to be browser only mode on win95 with the old pidl arguments which is
            // going to be in shared memory.... (must be cloned into local memory)...
            pidl = ILClone((LPITEMIDLIST) hMem);

            // this will get freed if we succeed.
            ASSERT( ppidlGlobal );
            *ppidlGlobal = (LPITEMIDLIST) hMem;
        }

        return pidl;
    }
    else
    {
        TCHAR tszQual[MAX_PATH];

        // We must copy to a temp buffer because the PathQualify may
        // result in a string longer than our input buffer and faulting
        // seems like a bad way of handling that situation.
        lstrcpyn(tszQual, lpsz, ARRAYSIZE(tszQual));
        lpsz = tszQual;

        // Is this a URL?
        if (!PathIsURL(lpsz))
        {
            // No; qualify it
            PathQualifyDef(lpsz, NULL, PQD_NOSTRIPDOTS);
        }

        pidl = ILCreateFromPath(lpsz);

        if (pidl==NULL && psde) 
        {
            psde->idMsg = IDS_CANTFINDDIR;
            lstrcpyn(psde->szParam, lpsz, ARRAYSIZE(psde->szParam));
        }
        return pidl;
    }
}


LPITEMIDLIST GetPIDLFromDDEArgs(LPTSTR lpszBuf, UINT * lpwCmd, PSHDDEERR psde, LPCITEMIDLIST * ppidlGlobal)
{
    LPITEMIDLIST pidl = _GetPIDLFromDDEArgs(1, lpszBuf, lpwCmd, psde, ppidlGlobal);
    if (!pidl)
    {
        pidl = _GetPIDLFromDDEArgs(0, lpszBuf, lpwCmd, psde, ppidlGlobal);
    }
    
    return pidl;
}

void _FlagsToParams(UINT uFlags, LPTSTR pszParams)
{
    if (uFlags & COF_EXPLORE)
        lstrcat(pszParams, TEXT(",/E"));

    if (uFlags & COF_SELECT)
        lstrcat(pszParams, TEXT(",/SELECT"));

    if (uFlags & COF_CREATENEWWINDOW)
        lstrcat(pszParams, TEXT(",/N"));

    if (uFlags & COF_USEOPENSETTINGS)
        lstrcat(pszParams, TEXT(",/S"));
}


#define SZ_EXPLORER_EXE     TEXT("explorer.exe")

HRESULT GetExplorerPath(LPTSTR pszExplorer, DWORD cchSize)
{
    HRESULT hr = S_OK;

    // This process is either iexplore.exe or explorer.exe.
    // If it's explorer.exe, we want to use it's path also.
    if (GetModuleFileName(NULL, pszExplorer, cchSize))
    {
        LPCTSTR pszFileName = PathFindFileName(pszExplorer);

        // This may not be the explorer.exe process.
        if (0 != StrCmpI(pszFileName, SZ_EXPLORER_EXE))
        {
            StrCpyN(pszExplorer, SZ_EXPLORER_EXE, cchSize);
        }
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
}


BOOL IsDesktopProcess(HWND hwnd)
{
    DWORD dwProcessID;
    DWORD dwDesktopProcessID;

    if (!hwnd)
        return FALSE;

    GetWindowThreadProcessId(GetShellWindow(), &dwDesktopProcessID);
    GetWindowThreadProcessId(hwnd, &dwProcessID);
    return (dwProcessID == dwDesktopProcessID);
}

// lpszBuf is a multi-string containing the various parameters.  

// lpwCmd is an array of indexes, where the first 
// element is the count of parameters, and each element
// after that is the starting offset into lpszBuf
// for the respective parameter.

BOOL DoDDE_ViewFolder(IShellBrowser* psb, HWND hwndParent, LPTSTR pszBuf, UINT *puCmd, BOOL fExplore, DWORD dwHotKey, HMONITOR hMonitor)
{
    // used to support the older win95 (browser only mode) Global passing of pidl pointers..
    LPITEMIDLIST pidlGlobal = NULL;
    LPITEMIDLIST pidl;
    int nCmdShow;
    SHDDEERR sde = { 0 };
    BOOL fSuccess = TRUE;

    if (*puCmd != 3)
        return FALSE;   // Wrong number of arguments

    // The ShowWindow parameter is the third 
    nCmdShow = StrToLong(&pszBuf[*(puCmd+3)]);

    pidl = GetPIDLFromDDEArgs(pszBuf, puCmd, &sde, (LPCITEMIDLIST*)&pidlGlobal);
    if (pidl)
    {
        IETHREADPARAM *pfi = SHCreateIETHREADPARAM(NULL, nCmdShow, NULL, NULL);
        if (pfi)
        {
            pfi->hwndCaller = hwndParent;
            pfi->pidl = ILClone(pidl);
            pfi->wHotkey = (UINT)dwHotKey;
            pfi->uFlags = COF_NORMAL;
            pfi->psbCaller = psb;
            if (psb)
            {
                psb->AddRef();          // for pfi->psbCaller
            }

            psb = NULL;                 // ownership transferred to pfi!

            // Check for a :0 thing. Probably came from the command line.
            if (lstrcmpi(&pszBuf[*(puCmd+2)], TEXT(":0")) != 0)
            {
                // we need to use COF_USEOPENSETTINGS here.  this is where the open
                // from within cabinets happen.  if it's done via the command line
                // then it will esentially turn to COF_NORMAL because the a cabinet
                // window won't be the foreground window.

                pfi->uFlags = COF_USEOPENSETTINGS;
            }

            if (hMonitor != NULL)
            {
                pfi->pidlRoot = reinterpret_cast<LPITEMIDLIST>(hMonitor);
                pfi->uFlags |= COF_HASHMONITOR;
            }

            if (fExplore)
                pfi->uFlags |= COF_EXPLORE;

            // The REST_SEPARATEDESKTOPPROCESS restriction means that all shell windows
            // should be opened in an explorer other then the desktop explorer.exe process.
            // However, shell windows need to be in the same second explorer.exe instance.
            BOOL bSepProcess = FALSE;

            if (IsDesktopProcess(hwndParent))
            {
                bSepProcess = TRUE;

                if (!SHRestricted(REST_SEPARATEDESKTOPPROCESS))
                {
                    SHELLSTATE ss;

                    SHGetSetSettings(&ss, SSF_SEPPROCESS, FALSE);
                    bSepProcess = ss.fSepProcess;
                }
            }
            
            if (bSepProcess)
            {
                TCHAR szExplorer[MAX_PATH];
                TCHAR szCmdLine[MAX_PATH];
                SHELLEXECUTEINFO ei = { sizeof(ei), 0, NULL, NULL, szExplorer, szCmdLine, NULL, SW_SHOWNORMAL};

                DWORD dwProcess = GetCurrentProcessId();
                HANDLE hIdList = NULL;
                
                GetExplorerPath(szExplorer, ARRAYSIZE(szExplorer));
                fSuccess = TRUE;
                if (pfi->pidl)
                {
                    hIdList = SHAllocShared(pfi->pidl, ILGetSize(pfi->pidl), dwProcess);
                    wsprintf(szCmdLine, TEXT("/IDLIST,:%ld:%ld"), hIdList, dwProcess);
                    if (!hIdList)
                        fSuccess = FALSE;
                }
                else
                {
                    lstrcpy(szCmdLine, TEXT("/IDLIST,:0"));
                }

                _FlagsToParams(pfi->uFlags, szCmdLine + lstrlen(szCmdLine));

                if (fSuccess)
                {
                    fSuccess = ShellExecuteEx(&ei);
                }
                if (!fSuccess && hIdList)
                    SHFreeShared(hIdList, dwProcess);

                SHDestroyIETHREADPARAM(pfi);
            }
            else
            {
                //
                // Check if this is a folder or not. If not, we always create
                // a new window (even though we can browse in-place). If you
                // don't like it, please talk to ChristoB. (SatoNa)
                //
                //  I don't like it...  not for the explore case.
                // 
                if (!(pfi->uFlags & COF_EXPLORE))
                {
                    ULONG dwAttr = SFGAO_FOLDER;
                    if (SUCCEEDED(SHGetAttributesOf(pidl, &dwAttr)) && !(dwAttr & SFGAO_FOLDER))
                    {
                        pfi->uFlags |= COF_CREATENEWWINDOW;
                    }
                }
                fSuccess = SHOpenFolderWindow(pfi); // takes ownership of the whole pfi thing
            }

            if (!fSuccess && (GetLastError() == ERROR_OUTOFMEMORY))
                SHAbortInvokeCommand();

            fSuccess = TRUE;    // If we fail we don't want people to try
                                // to create process as this will blow up...
        }
        ILFree(pidl);
    }
    else
    {
        if (sde.idMsg) 
        {
            ShellMessageBox(HINST_THISDLL, hwndParent,
                MAKEINTRESOURCE(sde.idMsg), MAKEINTRESOURCE(IDS_CABINET),
                MB_OK|MB_ICONHAND|MB_SETFOREGROUND, sde.szParam);
        }
        fSuccess = FALSE;
    }

    if (fSuccess)
        ILFree(pidlGlobal);
    
    return fSuccess;
}


BOOL DDE_ViewFolder(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    return DoDDE_ViewFolder(NULL, NULL, lpszBuf, puCmd, FALSE, 0, NULL);
}


// FEATURE ExploreFolder and ViewFolder do the same thing right now, maybe
// they should do something different
BOOL DDE_ExploreFolder(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    return DoDDE_ViewFolder(NULL, NULL, lpszBuf, puCmd, TRUE, 0, NULL);
}


BOOL DDE_FindFolder(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    LPITEMIDLIST pidlGlobal = NULL;
    LPITEMIDLIST pidl = GetPIDLFromDDEArgs(lpszBuf, puCmd, NULL, (LPCITEMIDLIST*)&pidlGlobal);
    if (pidl)
    {
        // A very large hack.  If the pidl is to the network neighborhood,
        // we do a FindComputer instead!
        LPITEMIDLIST pidlNetwork = SHCloneSpecialIDList(NULL, CSIDL_NETWORK, FALSE);
        if (pidlNetwork && ILIsEqual(pidlNetwork, pidl))
            SHFindComputer(pidl, NULL);
        else
            SHFindFiles(pidl, NULL);
        ILFree(pidlNetwork);
        ILFree(pidl);
        ILFree(pidlGlobal);
            
        return TRUE;
    }
    return FALSE;
}



// This processes the Find Folder command.  It is used for both for selecting
// Find on a folders context menu as well as opening a find file.
BOOL DDE_OpenFindFile(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    LPITEMIDLIST pidlGlobal = NULL;
    LPITEMIDLIST pidl = GetPIDLFromDDEArgs(lpszBuf, puCmd, NULL, (LPCITEMIDLIST*)&pidlGlobal);
    if (pidl)
    {
        SHFindFiles(NULL, pidl);
        ILFree( pidlGlobal );
        return TRUE;
    }
    else
        return FALSE;
}


BOOL DDE_ConfirmID(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    BOOL bRet;

    DBG_ENTER(FTF_DDE, DDE_ConfirmID);

    bRet = (*puCmd == 0);

    DBG_EXIT_BOOL(FTF_DDE, DDE_ConfirmID, bRet);
    return bRet;
}


#ifdef DEBUG

BOOL DDE_Beep(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
#if 0
    int i;

    for (i=*puCmd; i>=0; --i)
    {
        MessageBeep(0);
    }
    return(TRUE);
#else
    DWORD dwTime;

    dwTime = GetTickCount();
    TraceMsg(TF_DDE, "Spin...");
    // Spin. Spin. Spin. Huh Huh. Cool.
    while ((GetTickCount()-dwTime) < 4000)
    {
        // Spin.
    }
    TraceMsg(TF_DDE, "Spinning done.");
    return TRUE;
#endif
}
#endif


BOOL DDE_ShellFile(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    LPITEMIDLIST pidlGlobal = NULL;
    LPITEMIDLIST pidl = GetPIDLFromDDEArgs(lpszBuf, puCmd, NULL, (LPCITEMIDLIST*)&pidlGlobal);
    if (pidl) 
    {
        ShellExecCommandFile(pidl);
        
        ILFree(pidl);
        ILFree(pidlGlobal);
        return TRUE;
    }
    return FALSE;
}

VOID CALLBACK TimerProc_RepeatAcks(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    HWND hwndPartner;

    if (g_hwndDde)
    {
        hwndPartner = _GetDDEPartnerWindow((HCONV)g_hwndDde);
        if (hwndPartner)
        {
            TraceMsg(TF_DDE, "DDE partner (%x) appears to be stuck - repeating Ack.", hwndPartner);
            PostMessage(hwndPartner, WM_DDE_ACK, (WPARAM)g_hwndDde, 0);
        }
    }
}


HDDEDATA HandleDDEExecute(HDDEDATA hData, HCONV hconv)
{
    UINT *lpwCmd;
    UINT *lpwCmdTemp;
    UINT wCmd;
    PDDECONV pddec;
    HDDEDATA hddeRet = (HDDEDATA) DDE_FACK;
    UINT nErr;
    LPTSTR pszBuf;
    int cbData;

    DBG_ENTER(FTF_DDE, HandleDDEExecute);

    pddec = DDE_MapHConv(hconv);
    if (pddec == NULL)
    {
        // Could not find conversation
        hddeRet = HDDENULL;
        goto Leave;
    }

    if ((pddec->dwFlags & DDECONV_REPEAT_ACKS) && g_nTimer)
    {
        KillTimer(NULL, g_nTimer);
        g_nTimer = 0;
    }

    // NB Living Books Installer cats all their commands together
    // which requires about 300bytes - better just allocate it on
    // the fly.
    cbData = DdeGetData(hData, NULL, 0, 0L);
    if (cbData == 0)
    {
        // No data?
        hddeRet = HDDENULL;
        goto Leave;
    }

    pszBuf = (LPTSTR)LocalAlloc(LPTR, cbData);
    if (!pszBuf)
    {
        TraceMsg(TF_ERROR, "HandleDDEExecute: Can't allocate buffer (%d)", cbData);
        hddeRet = HDDENULL;
        goto Leave;
    }

    cbData = DdeGetData(hData, (LPBYTE)pszBuf, cbData, 0L);
    if (cbData == 0)
    {
        nErr = DdeGetLastError(g_dwDDEInst);
        TraceMsg(TF_ERROR, "HandleDDEExecute: Data invalid (%d).", nErr);
        ASSERT(0);
        LocalFree(pszBuf);
        hddeRet = HDDENULL;
        goto Leave;
    }

#ifdef UNICODE
    //
    // At this point, we may have ANSI data in pszBuf, but we need UNICODE!
    // !!!HACK alert!!! We're going to poke around in the string to see if it is
    // ansi or unicode.  We know that DDE execute commands should only
    // start with " " or "[", so we use that information...
    //
    // By the way, this only really happens when we get an out of order
    // WM_DDE_EXECUTE (app didn't send WM_DDE_INITIATE -- Computer Associate
    // apps like to do this when they setup).  Most of the time DDEML will
    // properly translate the data for us because they correctly determine
    // ANSI/UNICODE conversions from the WM_DDE_INITIATE message.

    if ((cbData>2) &&
        ((*((LPBYTE)pszBuf)==(BYTE)' ') || (*((LPBYTE)pszBuf)==(BYTE)'[')) &&
        (*((LPBYTE)pszBuf+1)!=0 ))
    {
        // We think that pszBuf is an ANSI string, so convert it
        LPTSTR pszUBuf;

        pszUBuf = (LPTSTR)LocalAlloc(LPTR, cbData * sizeof(WCHAR));
        if (pszUBuf)
        {
            MultiByteToWideChar( CP_ACP, 0, (LPCSTR)pszBuf, -1, pszUBuf, cbData );
            LocalFree(pszBuf);
            pszBuf = pszUBuf;
        }
        else
        {
            // gotos are weak but i dont really want to rewrite this function
            LocalFree(pszBuf);
            hddeRet = HDDENULL;
            goto Leave;
        }
    }
#endif // UNICODE

    if (pszBuf[0] == TEXT('\0'))
    {
        TraceMsg(TF_ERROR, "HandleDDEExecute: Empty execute command.");
        ASSERT(0);
        LocalFree(pszBuf);

        hddeRet = HDDENULL;
        goto Leave;
    }

    TraceMsg(TF_DDE, "Executing %s", pszBuf);

    lpwCmd = GetDDECommands(pszBuf, c_sDDECommands, HConv_PartnerIsLFNAware(hconv));
    if (!lpwCmd)
    {
#ifdef DEBUG
        // [] is allowed since it means "nop" (used alot in ifexec where we have already 
        // passed the info on cmdline since we had do and exec)
        if (lstrcmpi(pszBuf, TEXT("[]")) != 0)
        {
            ASSERTMSG(FALSE, "HandleDDEExecute: recieved a bogus DDECommand %s", pszBuf);
        }
#endif
        LocalFree(pszBuf);

        // Make sure Discis installers get the Ack they're waiting for.
        if ((pddec->dwFlags & DDECONV_REPEAT_ACKS) && !g_nTimer)
        {
            // DebugBreak();
            g_nTimer = SetTimer(NULL, IDT_REPEAT_ACKS, 1000, TimerProc_RepeatAcks);
        }

        hddeRet = HDDENULL;
        goto Leave;
    }

    // Store off lpwCmd so we can free the correect addr later
    lpwCmdTemp = lpwCmd;

    // Execute a command.
    while (*lpwCmd != (UINT)-1)
    {
        wCmd = *lpwCmd++;
        // Subtract 1 to account for the terminating NULL
        if (wCmd < ARRAYSIZE(c_sDDECommands)-1)
        {
            if (!c_sDDECommands[wCmd].lpfnCommand(pszBuf, lpwCmd, pddec))
            {
                hddeRet = HDDENULL;
            }
        }

        // Next command.
        lpwCmd += *lpwCmd + 1;
    }

    // Tidyup...
    GlobalFree(lpwCmdTemp);
    LocalFree(pszBuf);

    // Make sure Discis installers get the Ack they're waiting for.
    if ((pddec->dwFlags & DDECONV_REPEAT_ACKS) && !g_nTimer)
    {
        // DebugBreak();
        g_nTimer = SetTimer(NULL, IDT_REPEAT_ACKS, 1000, TimerProc_RepeatAcks);
    }

Leave:

    if (pddec)
        DDEConv_Release(pddec);

    DBG_EXIT_DWORD(FTF_DDE, HandleDDEExecute, hddeRet);

    return hddeRet;
}


// NOTE: ANSI ONLY

// Used for filtering out hidden, . and .. stuff.

BOOL FindData_FileIsNormalA(WIN32_FIND_DATAA *lpfd)
{
    if ((lpfd->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) ||
        lstrcmpiA(lpfd->cFileName, c_szDesktopIniA) == 0)
    {
        return FALSE;
    }
    else if (lpfd->cFileName[0] == '.')
    {
        if ((lpfd->cFileName[1] == '\0') ||
            ((lpfd->cFileName[1] == '.') && (lpfd->cFileName[2] == '\0')))
        {
            return FALSE;
        }
    }
    return TRUE;
}


HDDEDATA EnumGroups(HSZ hszItem)
{
    TCHAR szGroup[MAX_PATH];
#ifdef UNICODE        
    CHAR  szAGroup[MAX_PATH];
#endif        
    WIN32_FIND_DATAA fd;
    HANDLE hff;
    LPSTR lpszBuf = NULL;
    UINT cbBuf = 0;
    UINT cch;
    HDDEDATA hData;

    // Enumerate all the top level folders in the programs folder.
    SHGetSpecialFolderPath(NULL, szGroup, CSIDL_PROGRAMS, TRUE);
    PathAppend(szGroup, c_szStarDotStar);

    // We do a bunch of DDE work below, all of which is ANSI only.  This is
    // the cleanest point to break over from UNICODE to ANSI, so the conversion
    // is done here.
    // REARCHITECT - BobDay - Is this right? Can't we do all in unicode?

#ifdef UNICODE
    if (0 == WideCharToMultiByte(CP_ACP, 0, szGroup, -1, szAGroup, MAX_PATH, NULL, NULL))
    {
        return NULL;
    }
    hff = FindFirstFileA(szAGroup, &fd);
#else
    hff = FindFirstFile(szGroup, &fd);
#endif

    if (hff != INVALID_HANDLE_VALUE)
    {
        do
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (FindData_FileIsNormalA(&fd)))
            {
                LPSTR lpsz;
                // Data is seperated by \r\n.
                cch = lstrlenA(fd.cFileName) + 2;
                lpsz = (LPSTR)_LocalReAlloc(lpszBuf, cbBuf + (cch + 1) * sizeof(TCHAR), LMEM_MOVEABLE|LMEM_ZEROINIT);
                if (lpsz)
                {
                    // Copy it over.
                    lpszBuf = lpsz;
                    lstrcpyA(lpszBuf + cbBuf, fd.cFileName);
                    lstrcatA(lpszBuf + cbBuf, c_szCRLF);
                    cbBuf = cbBuf + cch ;
                }
                else
                {
                    cbBuf = 0;
                    break;
                }
            }
        } while (FindNextFileA(hff, &fd));
        FindClose(hff);

        //
        // If the user is an admin, then we need to enumerate
        // the common groups also.
        //

        if (IsUserAnAdmin()) {

            SHGetSpecialFolderPath(NULL, szGroup, CSIDL_COMMON_PROGRAMS, TRUE);
            PathAppend(szGroup, c_szStarDotStar);

#ifdef UNICODE
            if (0 == WideCharToMultiByte(CP_ACP, 0, szGroup, -1, szAGroup, MAX_PATH, NULL, NULL))
            {
                return NULL;
            }
            hff = FindFirstFileA(szAGroup, &fd);
#else
            hff = FindFirstFile(szGroup, &fd);
#endif


            if (hff != INVALID_HANDLE_VALUE)
            {
                do
                {
                    if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                            (FindData_FileIsNormalA(&fd)))
                    {
                        LPSTR lpsz;
                         // Data is seperated by \r\n.
                         cch = lstrlenA(fd.cFileName) + 2;
                         lpsz = (LPSTR)_LocalReAlloc(lpszBuf, cbBuf + (cch + 1) * sizeof(TCHAR), LMEM_MOVEABLE|LMEM_ZEROINIT);
                         if (lpsz)
                         {
                             // Copy it over.
                             lpszBuf = lpsz;
                             lstrcpyA(lpszBuf + cbBuf, fd.cFileName);
                             lstrcatA(lpszBuf + cbBuf, c_szCRLF);
                             cbBuf = cbBuf + cch ;
                         }
                         else
                         {
                             cbBuf = 0;
                             break;
                         }
                    }
                } while (FindNextFileA(hff, &fd));
                FindClose(hff);
            }
        }

        // Now package up the data and return.
        if (lpszBuf)
        {
            // Don't stomp on the last crlf, Word hangs while setting up
            // if this isn't present, just stick a null on the end.
            lpszBuf[cbBuf] = TEXT('\0');
            if (hszItem)
            {
                hData = DdeCreateDataHandle(g_dwDDEInst, (LPBYTE)lpszBuf, cbBuf+1, 0, hszItem, CF_TEXT, 0);
            }
            else
            {
                // Handle NULL hszItems (Logitech Fotomans installer does this). We need to create
                // a new hszItem otherwise DDEML gets confused (Null hszItems are only supposed to
                // be for DDE_EXECUTE data handles).
                TraceMsg(TF_WARNING, "EnumGroups: Invalid (NULL) hszItem used in request, creating new valid one.");
                hszItem = _DdeCreateStringHandle(g_dwDDEInst, c_szGroupsA, CP_WINANSI);
                hData = DdeCreateDataHandle(g_dwDDEInst, (LPBYTE)lpszBuf, cbBuf+1, 0, hszItem, CF_TEXT, 0);
                DdeFreeStringHandle(g_dwDDEInst, hszItem);
            }
            LocalFree(lpszBuf);
            return hData;
        }
    }

    // Empty list - Progman returned a single null.

    // (Davepl) I need to cast to LPBYTE since c_szNULLA is const.  If this
    // function doesn't really need to write to the buffer, it should be declared
    // as const.
    // (stephstm) This is a public documented fct, no chance it will change.

    hData = DdeCreateDataHandle(g_dwDDEInst, (LPBYTE)c_szNULLA, 1, 0, hszItem, CF_TEXT, 0);
    return hData;
}

// Crossties 1.0 doesn't like an empty icon path (which couldn't happen in 3.1)
// so we make one here.
void ConstructIconPath(LPTSTR pszIP, LPCTSTR pszCL, LPCTSTR pszWD)
{
    TCHAR sz[MAX_PATH];

    lstrcpy(sz, pszCL);
    PathRemoveArgs(sz);
    PathUnquoteSpaces(sz);
    FindExecutable(sz, pszWD, pszIP);
}

BOOL GroupItem_GetLinkInfo(LPCTSTR lpszGroupPath, PGROUPITEM pgi, LPCITEMIDLIST pidlLink,
    IShellFolder * psf, IShellLink *psl, IPersistFile *ppf)
{
    BOOL fRet = FALSE;
    DWORD dwAttribs;

    ASSERT(pgi);
    ASSERT(pidlLink);
    ASSERT(psf);

    dwAttribs = SFGAO_LINK;
    if (SUCCEEDED(psf->GetAttributesOf(1, &pidlLink, &dwAttribs)))
    {
        if (dwAttribs & SFGAO_LINK)
        {
            STRRET str;
            TCHAR szName[MAX_PATH];

            // Get the relevant data.
            // Copy it.
            // Stick pointers in pgi.
            if (SUCCEEDED(psf->GetDisplayNameOf(pidlLink, SHGDN_NORMAL, &str)) &&
                SUCCEEDED(StrRetToBuf(&str, pidlLink, szName, ARRAYSIZE(szName))))
            {
                TCHAR sz[MAX_PATH], szCL[MAX_PATH];
                WCHAR wszPath[MAX_PATH];

                TraceMsg(TF_DDE, "Link %s", szName);

                pgi->pszDesc = StrDup(szName);
                PathCombine(sz, lpszGroupPath, szName);
                lstrcat(sz, c_szDotLnk);
                SHTCharToUnicode(sz, wszPath, ARRAYSIZE(wszPath));
                // Read the link.
                // "name","CL",def dir,icon path,x,y,icon index,hotkey,minflag.
                ppf->Load(wszPath, 0);
                // Copy all the data.
                szCL[0] = TEXT('\0');
                if (SUCCEEDED(psl->GetPath(szCL, ARRAYSIZE(szCL), NULL, SLGP_SHORTPATH)))
                {
                    // Valid CL?
                    if (szCL[0])
                    {
                        int nShowCmd;
                        TCHAR szArgs[MAX_PATH];

                        // Yep, Uses LFN's?
                        szArgs[0] = 0;
                        psl->GetArguments(szArgs, ARRAYSIZE(szArgs));
                        lstrcpy(sz, szCL);
                        if (szArgs[0])
                        {
                            lstrcat(sz, TEXT(" "));
                            StrCatBuff(sz, szArgs, ARRAYSIZE(sz));
                        }
                        pgi->pszCL = StrDup(sz);
                        TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: CL %s", sz);
                        // WD
                        sz[0] = TEXT('\0');
                        psl->GetWorkingDirectory(sz, ARRAYSIZE(sz));
                        TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: WD %s", sz);
                        if (sz[0])
                        {
                            TCHAR szShortPath[MAX_PATH];
                            if (GetShortPathName(sz, szShortPath, ARRAYSIZE(szShortPath)))
                                lstrcpy(sz, szShortPath);
                        }

                        pgi->pszWD = StrDup(sz);
                        // Now setup the Show Command - Need to map to index numbers...
                        psl->GetShowCmd(&nShowCmd);
                        if (nShowCmd == SW_SHOWMINNOACTIVE)
                        {
                            TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: Show min.");
                            pgi->fMin = TRUE;
                        }
                        else
                        {
                            TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: Show normal.");
                            pgi->fMin = FALSE;
                        }
                        // Icon path.
                        sz[0] = TEXT('\0');
                        pgi->iIcon = 0;
                        psl->GetIconLocation(sz, ARRAYSIZE(sz), &pgi->iIcon);
                        if (pgi->iIcon < 0)
                            pgi->iIcon = 0;
                        if (sz[0])
                            PathGetShortPath(sz);
                        else
                            ConstructIconPath(sz, pgi->pszCL, pgi->pszWD);
                        TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: IL %s %d", sz, pgi->iIcon);
                        pgi->pszIconPath = StrDup(sz);
                        // Hotkey
                        pgi->wHotkey = 0;
                        psl->GetHotkey(&pgi->wHotkey);
                        // Success.
                        fRet = TRUE;
                    }
                    else
                    {
                        // Deal with links to weird things.
                        TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: Invalid command line.");
                    }
                }
            }
        }
    }

    return fRet;
}

int DSA_DestroyGroupCallback(LPVOID p, LPVOID d)
{
    PGROUPITEM pgi = (PGROUPITEM)p;
    LocalFree(pgi->pszDesc);
    LocalFree(pgi->pszCL);
    LocalFree(pgi->pszWD);
    LocalFree(pgi->pszIconPath);
    return 1;
}


// Return the links in a group.
HDDEDATA EnumItemsInGroup(HSZ hszItem, LPCTSTR lpszGroup)
{
    HRESULT hres;
    LPITEMIDLIST pidl, pidlGroup;
    IShellFolder * psf;
    TCHAR sz[MAX_PATH];
    TCHAR szLine[MAX_PATH*4];
    HDDEDATA hddedata = HDDENULL;
    ULONG celt;
    GROUPITEM gi;
    int cItems = 0;
    IPersistFile *ppf;
    IShellLink *psl;
    HDSA hdsaGroup;
    UINT cbDDE;
    UINT cchDDE;
    int x, y;
    LPTSTR pszDDE = NULL;
    PGROUPITEM pgi;
    BOOL fOK = FALSE;
    WIN32_FIND_DATA fd;
    HANDLE hFile;
    BOOL bCommon = FALSE;

    TraceMsg(TF_DDE, "c.eiig: Enumerating %s.", (LPTSTR)lpszGroup);


    //
    // Get personal group location
    //

    if (!SHGetSpecialFolderPath(NULL, sz, CSIDL_PROGRAMS, FALSE)) {
        return NULL;
    }

    PathAddBackslash(sz);
    StrCatBuff(sz, lpszGroup, ARRAYSIZE(sz));

    //
    // Test if the group exists.
    //

    hFile = FindFirstFile (sz, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

       if (SHRestricted(REST_NOCOMMONGROUPS)) {
           return NULL;
       }

       //
       // Personal group doesn't exist.  Try a common group.
       //

       if (!SHGetSpecialFolderPath(NULL, sz, CSIDL_COMMON_PROGRAMS, FALSE)) {
           return NULL;
       }

       PathAddBackslash(sz);
       StrCatBuff(sz, lpszGroup, ARRAYSIZE(sz));
       bCommon = TRUE;

    } else {
        FindClose (hFile);
    }

    hdsaGroup = DSA_Create(sizeof(GROUPITEM), 0);
    if (hdsaGroup)
    {
        // Get the group info.
        pidlGroup = ILCreateFromPath(sz);
        if (pidlGroup)
        {
            IShellFolder* psfDesktop;

            hres = SHGetDesktopFolder(&psfDesktop);
            if (SUCCEEDED(hres))
            {
                hres = psfDesktop->BindToObject(pidlGroup, NULL, IID_IShellFolder, (LPVOID*)&psf);
                if (SUCCEEDED(hres))
                {
                    LPENUMIDLIST penum;
                    hres = psf->EnumObjects(NULL, SHCONTF_NONFOLDERS, &penum);
                    if (S_OK == hres)
                    {
                        hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID*)&psl);
                        if (SUCCEEDED(hres))
                        {
                            psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf);
                            ASSERT(ppf); // nobody checks it below
                            while ((penum->Next(1, &pidl, &celt) == NOERROR) && (celt == 1))
                            {
                                if (GroupItem_GetLinkInfo(sz, &gi, pidl, psf, psl, ppf))
                                {
                                    // Add it to the list
                                    DSA_InsertItem(hdsaGroup, cItems, &gi);
                                    cItems++;
                                }
                                ILFree(pidl);
                            }
                            fOK = TRUE;
                            ppf->Release();
                            psl->Release();
                        }
                        penum->Release();
                    }
                    psf->Release();
                }
                psfDesktop->Release();
            }
            ILFree(pidlGroup);
        }
        else
        {
            TraceMsg(DM_ERROR, "c.eiig: Can't create IDList for path..");
        }

        if (fOK)
        {
            // Create dde data.
            TraceMsg(TF_DDE, "c.eiig: %d links", cItems);

            // "Group Name",path,#items,showcmd
            PathGetShortPath(sz);
            wsprintf(szLine, TEXT("\"%s\",%s,%d,%d,%d\r\n"), lpszGroup, sz, cItems, SW_SHOWNORMAL, bCommon);
            cchDDE = lstrlen(szLine)+1;
            cbDDE = cchDDE * sizeof(TCHAR);
            pszDDE = (LPTSTR)LocalAlloc(LPTR, cbDDE);
            if (pszDDE)
            {
                lstrcpy(pszDDE, szLine);
                cItems--;
                while (cItems >= 0)
                {
                    LPTSTR pszRealloc;
                    pgi = (GROUPITEM*)DSA_GetItemPtr(hdsaGroup, cItems);
                    ASSERT(pgi);
                    // Fake up reasonable coords.
                    x = ((cItems%ITEMSPERROW)*64)+32;
                    y = ((cItems/ITEMSPERROW)*64)+32;
                    // "name","CL",def dir,icon path,x,y,icon index,hotkey,minflag.
                    wsprintf(szLine, TEXT("\"%s\",\"%s\",%s,%s,%d,%d,%d,%d,%d\r\n"), pgi->pszDesc, pgi->pszCL,
                        pgi->pszWD, pgi->pszIconPath, x, y, pgi->iIcon, pgi->wHotkey, pgi->fMin);
                    cchDDE += lstrlen(szLine);
                    cbDDE = cchDDE * sizeof(TCHAR);
                    pszRealloc = (LPTSTR)_LocalReAlloc((HLOCAL)pszDDE, cbDDE + sizeof(TCHAR), LMEM_MOVEABLE|LMEM_ZEROINIT);
                    if (pszRealloc)
                    {
                        pszDDE = pszRealloc;
                        lstrcat(pszDDE, szLine);
                        cItems--;
                    }
                    else
                    {
                        TraceMsg(DM_ERROR, "c.eiig: Unable to realocate DDE line.");
                        break;
                    }
                }

#ifdef UNICODE
                // Multiply by two, for worst case, where every char was a multibyte char
                int cbADDE = lstrlen(pszDDE) * 2;       // Trying to make an ANSI string!!!
                LPSTR pszADDE = (LPSTR)LocalAlloc(LPTR, cbADDE + 2);
                if (pszADDE)
                {
                    WideCharToMultiByte(CP_ACP, 0, pszDDE, -1, pszADDE, cbADDE, NULL, NULL);

                    hddedata = DdeCreateDataHandle(g_dwDDEInst, (LPBYTE)pszADDE, cbADDE, 0, hszItem, CF_TEXT, 0);
                    LocalFree(pszADDE);
                }
                else
                {
                    TraceMsg(DM_ERROR, "c.eiig: Can't allocate ANSI buffer.");
                }
#else
                hddedata = DdeCreateDataHandle(g_dwDDEInst, (LPBYTE)pszDDE, cbDDE+1, 0, hszItem, CF_TEXT, 0);
#endif
                LocalFree(pszDDE);
            }
        }
        else
        {
            TraceMsg(DM_ERROR, "c.eiig: Can't create group list.");
        }
        
        DSA_DestroyCallback(hdsaGroup, DSA_DestroyGroupCallback, 0);
    }

    return hddedata;
}


HDDEDATA DDE_HandleRequest(HSZ hszItem, HCONV hconv)
{
    TCHAR szGroup[MAX_PATH];
    PDDECONV pddec;

    TraceMsg(TF_DDE, "DDEML Request(" SPRINTF_PTR ") - OK.", (DWORD_PTR)hconv);

    pddec = DDE_MapHConv(hconv);
    if (pddec == NULL)
        return HDDENULL;

    DDEConv_Release(pddec);
    
    DdeQueryString(g_dwDDEInst, hszItem, szGroup, ARRAYSIZE(szGroup), CP_WINNATURAL);

    TraceMsg(TF_DDE, "Request for item %s.", (LPTSTR) szGroup);
    // There's a bug in Progman where null data returns the list of groups.
    // Logitech relies on this behaviour.
    if (szGroup[0] == TEXT('\0'))
    {
        return EnumGroups(hszItem);
    }
    // Special case group names of "Groups" or "Progman" and return the list
    // of groups instead.
    else if (lstrcmpi(szGroup, c_szGroupGroup) == 0 || lstrcmpi(szGroup, c_szTopic) == 0)
    {
        return EnumGroups(hszItem);
    }
    // Special case winoldapp properties.
    else if (lstrcmpi(szGroup, c_szGetIcon) == 0 ||
        lstrcmpi(szGroup, c_szGetDescription) == 0 ||
        lstrcmpi(szGroup, c_szGetWorkingDir) == 0)
    {
        return HDDENULL;
    }
    // Assume it's a group name.
    else
    {
        return EnumItemsInGroup(hszItem, szGroup);
    }
}


// Support Disconnect
void DDE_HandleDisconnect(HCONV hconv)
{
    PDDECONV pddecPrev = NULL;
    PDDECONV pddec;

    TraceMsg(TF_DDE, "DDEML Disconnect(" SPRINTF_PTR ") - OK.", (DWORD_PTR)hconv);

    // Find the conversation in the list of them and free it.
    ENTERCRITICAL;
    for (pddec = g_pddecHead; pddec != NULL; pddec = pddec->pddecNext)
    {
        if (pddec->hconv == hconv)
        {
            // Found it, so first unlink it
            // pass the next reference back up the chain.
            if (pddecPrev == NULL)
                g_pddecHead = pddec->pddecNext;
            else
                pddecPrev->pddecNext = pddec->pddecNext;

            pddec->pddecNext = NULL;

            break;

        }
        pddecPrev = pddec;
    }
    LEAVECRITICAL;

    // Now Free it outside of critical section
    if (pddec)
        DDEConv_Release(pddec);

    g_hwndDde = NULL;
}


// Support wildcard topics.
HDDEDATA DDE_HandleWildConnects(void)
{
    HSZPAIR hszpair[4];

    TraceMsg(TF_DDE, "DDEML wild connect.");

    hszpair[0].hszSvc = g_hszService;
    hszpair[0].hszTopic = g_hszTopic;
    hszpair[1].hszSvc = g_hszShell;
    hszpair[1].hszTopic = g_hszAppProps;
    hszpair[2].hszSvc = g_hszFolders;
    hszpair[2].hszTopic = g_hszAppProps;
    hszpair[3].hszSvc = HSZNULL;
    hszpair[3].hszTopic = HSZNULL;

    return DdeCreateDataHandle(g_dwDDEInst, (LPBYTE)&hszpair, sizeof(hszpair), 0, HSZNULL, CF_TEXT, 0);
}


// App hack flags for DDE.
// REVIEW UNDONE - Read these from the registry so we can app hack on the fly.

// Bodyworks.
// Uses PostMessage(-1,...) to talk to the shell and DDEML
// can't handle that level of abuse. By having DDEML ignore the command
// it'll get forwarded through to the desktop which can handle it. Sigh.

// CCMail.
// Can't handle being installed via a UNC but unlike most app that have
// problems with UNC's they appear to set up fine - you'll just have
// lots of problems trying to run the app. We handle this by faking
// up a drive connection for them. We don't want to do this generally
// since the user could easily run out of drive letters.

// Discis. [There are dozens of Discis apps that use the same setup.]
// Can't handle getting activate messages out of order with DDE (which
// happens easily now). They end up spinning in a loop looking for an
// ACK they've already got. We hack around this by detecting them being
// hung and post them another ack. We keep doing that until they wake
// up and start talking to us again.

// Media Recorder.
// Their app wants to be single instance so at init they search for
// windows with the TITLE (!!!) of "MediaRecorder". If you launch
// them from their own folder (which has the title "MediaRecorder" then
// they refuse to run. We fix this by mapping their group name at
// setup time.

// Trio DataFax.
// This app wants to add something to the startup group but doesn't
// know what it's called so it tries to load the Startup string out
// of Progman. If Progman isn't running they try to create a group
// with a NULL title. We detect this case and map them to the new
// startup group name.

// TalkToPlus.
// They try to make a link to Terminal.exe and abort their setup
// if the AddItem fails. We fix this my forcing the AddItem to
// return success.

// Winfax Pro 4.0.
// They use the shell= line in win.ini for the service/topic so
// they end up talking to the shell using Explorer/Explorer!
// They also talk to the LAST responder to the init broadcast
// instead of the first AND they use SendMsg/Free instead of waiting for
// Acks. We fix this by allowing their service/topic to work, and have
// the desktop copy the data before sending it through to DDEML.
// REVIEW We key off the fact that their dde window is a dialog with no
// title - seems a bit broad to me.

// The Journeyman Project.
// This app causes damage to space-time. We fix it by generating a
// small HS-field around their installer.

// CA apps in general.
// Don't bother sending DDE_INIT's before sending the execute commands.
// We fix it by doing the init on the fly if needed.

// Faxserve.
// Broadcasts their EXEC commands. Their class name is "install" which
// is a bit too generic for my liking but since we handle this problem
// by forcing everything to go through the desktop it's not very risky.

struct {
    LPCTSTR pszClass;
    LPCTSTR pszTitle;
    DWORD id;
} const c_DDEApps[] = {
    c_szMrPostman,          NULL,           DDECONV_NO_INIT,
    c_szBodyWorks,          NULL,           DDECONV_FAIL_CONNECTS,
    c_szCCMail,             NULL,           DDECONV_NO_UNC,
    c_szDiscis,             NULL,           DDECONV_REPEAT_ACKS,
    c_szMediaRecorder,      NULL,           DDECONV_MAP_MEDIA_RECORDER,
    c_szTrioDataFax,        NULL,           DDECONV_NULL_FOR_STARTUP,
    c_szTalkToPlus,         NULL,           DDECONV_ALLOW_INVALID_CL,
    c_szDialog,             c_szMakePMG,    DDECONV_REPEAT_ACKS,
    c_szDialog,             c_szNULL,       DDECONV_EXPLORER_SERVICE_AND_TOPIC|DDECONV_USING_SENDMSG,
    c_szJourneyMan,         NULL,           DDECONV_EXPLORER_SERVICE_AND_TOPIC,
    c_szCADDE,              NULL,           DDECONV_NO_INIT,
    c_szFaxServe,           NULL,           DDECONV_FAIL_CONNECTS
};


DWORD GetDDEAppFlagsFromWindow(HWND hwnd)
{
    if (hwnd && !Window_IsLFNAware(hwnd))
    {
        TCHAR szClass[MAX_PATH];

        GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
        for (int i = 0; i < ARRAYSIZE(c_DDEApps); i++)
        {
            // NB Keep this case sensative to narrow the scope a bit.
            if (lstrcmp(szClass, c_DDEApps[i].pszClass) == 0)
            {
                // Do we care about the title?
                if (c_DDEApps[i].pszTitle)
                {
                    TCHAR szTitle[MAX_PATH];

                    GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle));
                    if (lstrcmp(szTitle, c_DDEApps[i].pszTitle) == 0)
                    {
                        TraceMsg(TF_DDE, "App flags 0x%x for %s %s.", c_DDEApps[i].id, c_DDEApps[i].pszClass, c_DDEApps[i].pszTitle);
                        return c_DDEApps[i].id;
                    }
                }
                else
                {
                    // Nope.
                    TraceMsg(TF_DDE, "App flags 0x%x for %s.", c_DDEApps[i].id, c_DDEApps[i].pszClass);
                    return c_DDEApps[i].id;
                }
            }
        }
    }

    return DDECONV_NONE;
}


DWORD GetDDEAppFlags(HCONV hconv)
{
    return GetDDEAppFlagsFromWindow(_GetDDEPartnerWindow(hconv));
}


HDDEDATA DDE_HandleConnect(HSZ hsz1, HSZ hsz2)
{
    if ((hsz1 == g_hszTopic && hsz2 == g_hszService) ||
        (hsz1 == g_hszAppProps && hsz2 == g_hszShell) ||
        (hsz1 == g_hszAppProps && hsz2 == g_hszFolders))
    {
        TraceMsg(TF_DDE, "DDEML Connect.");
        return (HDDEDATA)DDE_FACK;
    }
    else
    {
        // Unknown topic/service.
        TraceMsg(TF_DDE, "DDEML Connect - unknown service/topic.");
        return (HDDEDATA)NULL;
    }
}


// Returns TRUE if the drive where the Programs folder is supports LFNs.
BOOL _SupportLFNGroups(void)
{
    TCHAR szPrograms[MAX_PATH];
    DWORD dwMaxCompLen = 0;
    
    SHGetSpecialFolderPath(NULL, szPrograms, CSIDL_PROGRAMS, TRUE);
    return IsLFNDrive(szPrograms);
}


// REVIEW HACK - Don't just caste, call GetConvInfo() to get this. We can't
// do this as yet because of a bug in the thunk layer.
#define _GetDDEWindow(hconv)    ((HWND)hconv)


HDDEDATA DDE_HandleConnectConfirm(HCONV hconv)
{
    DWORD dwAppFlags = GetDDEAppFlags(hconv);
    PDDECONV pddec;

    if (dwAppFlags & DDECONV_FAIL_CONNECTS)
    {
        DdeDisconnect(hconv);
        return FALSE;
    }

    pddec = DDEConv_Create();
    if (pddec)
    {
        if (SUCCEEDED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (void **)&pddec->psl)))
        {
            pddec->hconv = hconv;
            // pddec->szGroup[0] = '\0';   // implicit
            // pddec->fDirty = FALSE;      // implicit
            // protect access to global list
            ENTERCRITICAL;
            pddec->pddecNext = g_pddecHead;
            g_pddecHead = pddec;
            LEAVECRITICAL;

            TraceMsg(TF_DDE, "DDEML Connect_CONFIRM(" SPRINTF_PTR ") - OK.", (DWORD_PTR)hconv);

            // Do we support LFN groups?
            g_LFNGroups = _SupportLFNGroups();
            // Tell the desktops DDE code we're handling things from here.
            g_hwndDde = _GetDDEWindow(hconv);
            // No conversation yet (wild connect?) - signal it with a hwnd -1.
            if (!g_hwndDde)
                g_hwndDde = (HWND)-1;
            // Keep track of the app hacks.
            pddec->dwFlags = dwAppFlags;

            // Success.
            return (HDDEDATA)DDE_FACK;
        }
        TraceMsg(TF_DDE, "Unable to create IShellLink interface.");

        DDEConv_Release(pddec);
    }
    else
    {
        TraceMsg(TF_ERROR, "Unable to allocate memory for tracking dde conversations.");
    }
    return (HDDEDATA)NULL;
}


HDDEDATA CALLBACK DDECallback(UINT type, UINT fmt, HCONV hconv,
        HSZ hsz1, HSZ hsz2,HDDEDATA  hData, ULONG_PTR dwData1, ULONG_PTR dwData2)
{
    switch (type)
    {
    case XTYP_CONNECT:
        return DDE_HandleConnect(hsz1, hsz2);

    case XTYP_WILDCONNECT:
        return DDE_HandleWildConnects();

    case XTYP_CONNECT_CONFIRM:
        return DDE_HandleConnectConfirm(hconv);

    case XTYP_REGISTER:
    case XTYP_UNREGISTER:
        return (HDDEDATA) NULL;

    case XTYP_ADVDATA:
        return (HDDEDATA) DDE_FACK;

    case XTYP_XACT_COMPLETE:
        return (HDDEDATA) NULL;

    case XTYP_DISCONNECT:
        DDE_HandleDisconnect(hconv);
        return (HDDEDATA) NULL;

    case XTYP_EXECUTE:
        return HandleDDEExecute(hData, hconv);

    case XTYP_REQUEST:
        if (hsz1 == g_hszTopic || hsz1 == g_hszAppProps)
        {
            return DDE_HandleRequest(hsz2, hconv);
        }
        else
        {
            TraceMsg(TF_DDE, "DDEML Request - Invalid Topic.");
            return (HDDEDATA) NULL;
        }

    default:
        return (HDDEDATA) NULL;

    }
}

static BOOL s_bDDEInited = FALSE;
ATOM g_aProgman = 0;

void UnInitialiseDDE(void)
{
    if (g_dwDDEInst)
    {
        DDE_RemoveShellServices();

        DdeNameService(g_dwDDEInst, g_hszFolders,  HSZNULL, DNS_UNREGISTER);

        _DdeFreeStringHandle(g_dwDDEInst, g_hszTopic);
        _DdeFreeStringHandle(g_dwDDEInst, g_hszService);
        _DdeFreeStringHandle(g_dwDDEInst, g_hszStar);
        _DdeFreeStringHandle(g_dwDDEInst, g_hszShell);
        _DdeFreeStringHandle(g_dwDDEInst, g_hszAppProps);
        _DdeFreeStringHandle(g_dwDDEInst, g_hszFolders);

        if (!DdeUninitialize(g_dwDDEInst))
        {
            TraceMsg(TF_DDE, "DDE Un-Initialization failure.");
        }

        g_dwDDEInst = 0;
    }

    if (g_aProgman)
    {
        g_aProgman = GlobalDeleteAtom(g_aProgman);
    }

    s_bDDEInited = FALSE;
}


void InitialiseDDE(void)
{
    DBG_ENTER(FTF_DDE, InitialiseDDE);

    if (s_bDDEInited)
    {
        // No need to do this twice
        return;
    }

    // Hack for Alone In the Dark 2.
    // They do a case sensative comparison of the progman atom and they
    // need it to be uppercase.
    g_aProgman = GlobalAddAtom(TEXT("PROGMAN"));

    if (DdeInitialize(&g_dwDDEInst, DDECallback, CBF_FAIL_POKES | CBF_FAIL_ADVISES, 0L) == DMLERR_NO_ERROR)
    {
        g_hszTopic = _DdeCreateStringHandle(g_dwDDEInst, c_szTopic, CP_WINNATURAL);
        g_hszService = _DdeCreateStringHandle(g_dwDDEInst, c_szService, CP_WINNATURAL);
        g_hszStar = _DdeCreateStringHandle(g_dwDDEInst, c_szStar, CP_WINNATURAL);
        g_hszShell = _DdeCreateStringHandle(g_dwDDEInst, c_szShell, CP_WINNATURAL);
        g_hszAppProps = _DdeCreateStringHandle(g_dwDDEInst, c_szAppProps, CP_WINNATURAL);
        g_hszFolders = _DdeCreateStringHandle(g_dwDDEInst, c_szFolders, CP_WINNATURAL);
    
        if (g_hszTopic && g_hszService && g_hszStar && g_hszShell && g_hszAppProps && g_hszFolders)
        {
            if (DdeNameService(g_dwDDEInst, g_hszFolders,  HSZNULL, DNS_REGISTER) &&
                DDE_AddShellServices())
            {
                s_bDDEInited = TRUE;
            }
        }
    }

    if (!s_bDDEInited)
    {
        UnInitialiseDDE();
    }

    DBG_EXIT(FTF_DDE, InitialiseDDE);
}


BOOL DDE_AddShellServices(void)
{
    // Only register these if we are the shell...
    if (DdeNameService(g_dwDDEInst, g_hszService,  HSZNULL, DNS_REGISTER) &&
        DdeNameService(g_dwDDEInst, g_hszShell,  HSZNULL, DNS_REGISTER))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


void DDE_RemoveShellServices(void)
{
    ASSERT(g_dwDDEInst);

    DdeNameService(g_dwDDEInst, g_hszService,  HSZNULL, DNS_UNREGISTER);
    DdeNameService(g_dwDDEInst, g_hszShell,  HSZNULL, DNS_UNREGISTER);
}



BOOL GetGroupName(LPCTSTR lpszOld, LPTSTR lpszNew, ULONG cchNew)
{
    DWORD dwType;
    DWORD cbNew = cchNew * sizeof(TCHAR);

    return ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szMapGroups, lpszOld, &dwType, (LPVOID)lpszNew, &cbNew);
}

void MapGroupName(LPCTSTR lpszOld, LPTSTR lpszNew, ULONG cchNew)
{
    if (!GetGroupName(lpszOld, lpszNew, cchNew))
    {
        lstrcpyn(lpszNew, lpszOld, cchNew);
    }
}

STDAPI_(BOOL) DDEHandleViewFolderNotify(IShellBrowser* psb, HWND hwnd, LPNMVIEWFOLDER pnm)
{
    BOOL fRet = FALSE;
    UINT *pwCmd = GetDDECommands(pnm->szCmd, c_sDDECommands, FALSE);

    // -1 means there aren't any commands we understand.  Oh, well
    if (pwCmd && (-1 != *pwCmd))
    {
        UINT *pwCmdSave = pwCmd;
        UINT c = *pwCmd++;

        LPCTSTR pszCommand = c_sDDECommands[c].pszCommand;

        ASSERT(c < ARRAYSIZE(c_sDDECommands));

        if (pszCommand == c_szViewFolder || 
            pszCommand == c_szExploreFolder)
        {
            fRet = DoDDE_ViewFolder(psb, hwnd, pnm->szCmd, pwCmd,
                    pszCommand == c_szExploreFolder, pnm->dwHotKey, pnm->hMonitor);
        }
        else if (pszCommand == c_szShellFile)
        {
            fRet = DDE_ShellFile(pnm->szCmd, pwCmd, 0);
        }

        GlobalFree(pwCmdSave);
    }

    return fRet;
} 

STDAPI_(LPNMVIEWFOLDER) DDECreatePostNotify(LPNMVIEWFOLDER pnm)
{
    LPNMVIEWFOLDER pnmPost = NULL;
    TCHAR szCmd[MAX_PATH * 2];
    StrCpyN(szCmd, pnm->szCmd, SIZECHARS(szCmd));
    UINT *pwCmd = GetDDECommands(szCmd, c_sDDECommands, FALSE);

    // -1 means there aren't any commands we understand.  Oh, well
    if (pwCmd && (-1 != *pwCmd))
    {
        LPCTSTR pszCommand = c_sDDECommands[*pwCmd].pszCommand;

        ASSERT(*pwCmd < ARRAYSIZE(c_sDDECommands));

        //
        //  these are the only commands handled by a PostNotify
        if (pszCommand == c_szViewFolder 
        ||  pszCommand == c_szExploreFolder
        ||  pszCommand == c_szShellFile)
        {
            pnmPost = (LPNMVIEWFOLDER)LocalAlloc(LPTR, sizeof(NMVIEWFOLDER));

            if (pnmPost)
                memcpy(pnmPost, pnm, sizeof(NMVIEWFOLDER));
        }

        GlobalFree(pwCmd);
    }

    return pnmPost;
}
   


LRESULT _ForwardDDEMsgs(HWND hwnd, HWND hwndForward, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend)
{
    TraceMsg(TF_DDE, "c.fdm: Forwarding DDE to %x", hwndForward);

    if (hwndForward && IsWindow(hwndForward))
    {
        TraceMsg(TF_DDE, "c.fdm: %lx %lx %lx", uMsg, (WPARAM)hwnd, lParam);
        if (fSend)
            return SendMessage(hwndForward, uMsg, (WPARAM)hwnd, lParam);
        else
            return PostMessage(hwndForward, uMsg, (WPARAM)hwnd, lParam);
    }
    else
    {
        TraceMsg(TF_DDE, "c.fdm: Invalid DDEML window, Can't forward DDE messages.");
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}


// Set/cleared by dde connect/disconnect.
const TCHAR c_szExplorerTopic[] = TEXT("Explorer");
const TCHAR c_szDMGFrame[] = TEXT("DMGFrame");  // This is the 16-bit/Win95 window class name


// Broadcast to all ddeml server windows.

void DDEML_Broadcast(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
    while (hwnd)
    {
        TCHAR szClass[32];
        if (GetClassName(hwnd, szClass, ARRAYSIZE(szClass)))
        {
            if ((lstrcmp(szClass, c_szDMGFrame) == 0) ||
                (lstrcmp(szClass, TEXT("DDEMLMom")) == 0))    // this is the 32-bit NT window class name
                SendMessage(hwnd, uMsg, wParam, lParam);
        }
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }
}



LRESULT _HandleDDEInitiateAndAck(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL g_fInInit = FALSE;
    ATOM aProgman;
    TCHAR szService[32];
    TCHAR szTopic[32];
    TCHAR szClass[32];
    WPARAM uHigh, uLow;
    BOOL fForceAccept = FALSE;

    if (uMsg == WM_DDE_INITIATE)
    {
        TraceMsg(TF_DDE, "c.hdi: Init.");

        // Don't handle DDE messages if we're already using DDEML. This happens when apps
        // broadcast DDE_INIT and don't stop on the first reply. Both our DDEML window and
        // the desktop end up replying. Most apps don't care and just talk to the first or
        // the last one but Ventura gets confused and thinks it's finished doing DDE when it
        // gets the second ACK and destroys it's internal DDE window.
        if (g_hwndDde)
        {
            TraceMsg(TF_DDE, "c.fpwp: Not forwarding DDE, DDEML is handing it.");
            KillTimer(hwnd, IDT_DDETIMEOUT);
        }
        // Are we re-cursing?
        else if (!g_fInInit)
        {
            // Nope, Is this for Progman, Progman or Shell, AppProperties?
            if (lParam)
            {
                GlobalGetAtomName(LOWORD(lParam), szService, ARRAYSIZE(szService));
                GlobalGetAtomName(HIWORD(lParam), szTopic, ARRAYSIZE(szTopic));
            }
            else
            {
                // Progman allowed a null Service & a null Topic to imply Progman, Progman.
                szService[0] = TEXT('\0');
                szTopic[0] = TEXT('\0');
                fForceAccept = TRUE;
            }

            // Keep track of hacks, we reset this on the disconnect.
            g_dwAppFlags = GetDDEAppFlagsFromWindow((HWND)wParam);

            // Hacks for WinFax and Journeyman Project.
            if ((g_dwAppFlags & DDECONV_EXPLORER_SERVICE_AND_TOPIC)
                && (lstrcmpi(szTopic, c_szExplorerTopic) == 0)
                && (lstrcmpi(szService, c_szExplorerTopic) == 0))
            {
                fForceAccept = TRUE;
            }

            if (((lstrcmpi(szTopic, c_szTopic) == 0) && (lstrcmpi(szService, c_szService) == 0)) ||
                fForceAccept)
            {
                TraceMsg(TF_DDE, "c.hdi: Init on [Progman,Progman] - needs forwarding.");
                // Nope go find it.
                // NB This will cause an echo on every DDE_INIT for Progman, Progman after booting.
                // It shouldn't be a problem :-)
                // Keep track of who to send Acks back to.
                g_hwndClient = (HWND)wParam;
                // Now find the real shell.
                aProgman = GlobalAddAtom(c_szService);
                TraceMsg(TF_DDE, "c.d_hdm: Finding shell dde handler...");
                g_fInInit = TRUE;
                // SendMessage(HWND_BROADCAST, WM_DDE_INITIATE, (WPARAM)hwnd, MAKELPARAM(aProgman, aProgman));
                DDEML_Broadcast(WM_DDE_INITIATE, (WPARAM)hwnd, MAKELPARAM(aProgman, aProgman));
                g_fInInit = FALSE;
                TraceMsg(TF_DDE, "c.d_hdm: ...Done");
                GlobalDeleteAtom(aProgman);
            }
            else
            {
                TraceMsg(TF_DDE, "c.hdi: Init on something other than [Progman,Progman] - Ignoring");
                KillTimer(hwnd, IDT_DDETIMEOUT);
            }
        }
        else
        {
            TraceMsg(TF_DDE, "c.hdi: Recursing - Init ignored.");
        }
        return 0;
    }
    else if (uMsg == WM_DDE_ACK)
    {
        TraceMsg(TF_DDE, "c.hdi: Ack.");
        // Is this in response to the DDE_Init above?
        if (g_fInInit)
        {
            // Yep, keep track of who we're talking too.
            GetClassName((HWND)wParam, szClass, ARRAYSIZE(szClass));
            TraceMsg(TF_DDE, "c.d_hdm: Init-Ack from %x (%s).", wParam, szClass);
            g_hwndDDEML = (HWND)wParam;
            // The forward it back (send it, don't post it - Breaks Prodogy).
            return _ForwardDDEMsgs(hwnd, g_hwndClient, uMsg, (WPARAM)hwnd, lParam, TRUE);
        }
        else
        {
            // Nope, just forward it back.

            // Hack for WinFaxPro.
            if (g_dwAppFlags & DDECONV_USING_SENDMSG)
            {
                // We copied the data before sending it on so we can free it here.
                // WinFax ignores the reply so don't bother sending it.
                UnpackDDElParam(uMsg, lParam, &uLow, &uHigh);
                if (uHigh)
                    GlobalFree((HGLOBAL)uHigh);
                return 0;
            }

            return _ForwardDDEMsgs(hwnd, g_hwndClient, uMsg, (WPARAM)hwnd, lParam, FALSE);
        }
    }
    return 0;
}


LRESULT _HandleDDEForwardBiDi(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if ((HWND)wParam == g_hwndDDEML)
        return _ForwardDDEMsgs(hwnd, g_hwndClient, uMsg, wParam, lParam, FALSE);
    else if ((HWND)wParam == g_hwndClient)
        return _ForwardDDEMsgs(hwnd, g_hwndDDEML, uMsg, wParam, lParam, FALSE);
    else
        return 0;
}


LRESULT _HandleDDETerminate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndClient;

    TraceMsg(DM_TRACE, "c.hddet: Terminate.");

    if ((HWND)wParam == g_hwndDDEML)
    {
        // This should be the last message (a terminate from ddeml to the client).
        // Cleanup now.
        KillTimer(hwnd, IDT_DDETIMEOUT);
        TraceMsg(DM_TRACE, "c.hddet: Cleanup.");
        hwndClient = g_hwndClient;
        g_hwndClient = NULL;
        g_hwndDDEML = NULL;
        g_dwAppFlags = DDECONV_NONE;
        return _ForwardDDEMsgs(hwnd, hwndClient, uMsg, wParam, lParam, FALSE);
    }
    else if ((HWND)wParam == g_hwndClient)
    {
        return _ForwardDDEMsgs(hwnd, g_hwndDDEML, uMsg, wParam, lParam, FALSE);
    }
    else
    {
        return 0;
    }
}


LRESULT _HandleDDEExecute(HWND hwnd, HWND hwndForward, UINT uMsg,
        WPARAM wParam, LPARAM lParam, BOOL fSend)
{
    ATOM aApp, aTopic;
    HANDLE hNew;
    LPTSTR pNew, pOld;

    // NB WinFaxPro does a Send/Free which avoids Users DDE hack
    // and means they get to delete the data while we're in
    // the middle of using it so we must copy it here. We'll
    // clean it up on the Ack.
    // NB WinFaxPro re-uses the same 16bit selector for all their
    // messages which the thunk layer can't handle it. We need to
    // defect the 32bit side (and free it) so the next time they
    // send the 16bit handle through the thunk layer they get a
    // new 32bit version.
    if (g_dwAppFlags & DDECONV_USING_SENDMSG)
    {
        SIZE_T cb = GlobalSize((HGLOBAL)lParam);
        hNew = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, cb);
        if (hNew)
        {
            // Copy the old data.
            pNew = (LPTSTR)GlobalLock(hNew);
            pOld = (LPTSTR)GlobalLock((HGLOBAL)lParam);
            hmemcpy(pNew, pOld, cb);
            GlobalUnlock((HGLOBAL)lParam);
            GlobalUnlock(hNew);
            GlobalFree((HGLOBAL)lParam);
            // Use our copy.
            lParam = (LPARAM)hNew;
        }
    }

    // NB CA neglect to send a DDE_INIT, they just start
    // throwing DDE_EXEC's at us so we fake up an init
    // from them to DDEML to get things rolling.
    if (!hwndForward)
    {
        if (!(g_dwAppFlags & DDECONV_NO_INIT))
           g_dwAppFlags = GetDDEAppFlagsFromWindow((HWND)wParam);

        if (g_dwAppFlags & DDECONV_NO_INIT)
        {
            aApp = GlobalAddAtom(c_szService);
            aTopic = GlobalAddAtom(c_szTopic);
            SendMessage(hwnd, WM_DDE_INITIATE, wParam, MAKELPARAM(aApp, aTopic));
            GlobalDeleteAtom(aApp);
            GlobalDeleteAtom(aTopic);
            hwndForward = g_hwndDDEML;
        }
    }

    return _ForwardDDEMsgs(hwnd, hwndForward, uMsg, wParam, lParam, fSend);
}


// hacks to get various apps installed (read: ATM). These are the people
// who do a FindWindow for Progman and then do dde to it directly.
// These people should not be allowed to write code.
STDAPI_(LRESULT) DDEHandleMsgs(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TraceMsg(TF_DDE, "c.fpwp: Forwarding DDE.");

    SetTimer(hwnd, IDT_DDETIMEOUT, 30*1000, NULL);

    switch (uMsg)
    {
    case WM_DDE_INITIATE:
    case WM_DDE_ACK:
        return _HandleDDEInitiateAndAck(hwnd, uMsg, wParam, lParam);
        
    case WM_DDE_TERMINATE:
        return _HandleDDETerminate(hwnd, uMsg, wParam, lParam);
        
    case WM_DDE_DATA:
        return _HandleDDEForwardBiDi(hwnd, uMsg, wParam, lParam);
        
    case WM_DDE_ADVISE:
    case WM_DDE_UNADVISE:
    case WM_DDE_REQUEST:
    case WM_DDE_POKE:
        return _ForwardDDEMsgs(hwnd, g_hwndDDEML, uMsg, wParam, lParam, FALSE);
        
    case WM_DDE_EXECUTE:
        return _HandleDDEExecute(hwnd, g_hwndDDEML, uMsg, wParam, lParam, FALSE);
    }
    return 0;
}


// Some installers (Wep2) forget to Terminate a conversation so we timeout
// after not getting any dde-messages for a while. If we don't, and you run
// a Wep2 install a second time we think the installer is already talking via
// ddeml so we don't reply from the desktop. Wep2 then thinks Progman isn't
// running, does a WinExec of Progman and hangs waiting to talk to it. Progman
// never replies since it is not the shell. Nasty Nasty Nasty.
STDAPI_(void) DDEHandleTimeout(HWND hwnd)
{
    HWND hwndClient, hwndDDEML;

    TraceMsg(DM_TRACE, "c.hdt: DDE Timeout.");

    KillTimer(hwnd, IDT_DDETIMEOUT);

    // Has everything gone away yet?
    if (g_hwndDDEML && g_hwndClient)
    {
        // Nope. Don't want to forward anymore.
        hwndClient = g_hwndClient;
        hwndDDEML = g_hwndDDEML;
        g_hwndClient = NULL;
        g_hwndDDEML = NULL;
        g_dwAppFlags = DDECONV_NONE;
        // Shutdown our ddeml alter-ego.
        // NB If the client window has already gone away (very likely) it's not a
        // problem, ddeml will skip posting the reply but will still do the
        // disconnect callback.
        PostMessage(hwndDDEML, WM_DDE_TERMINATE, (WPARAM)hwnd, 0);
    }
}





// INTERNAL EXPORT FUNCTION:
// This is for explorer to call to initialize and uninitialize SHELL DDE
// services.
void WINAPI ShellDDEInit(BOOL fInit)
{
    if (fInit)
        InitialiseDDE();
    else
        UnInitialiseDDE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\deskmovr.h ===
// DeskMovr.h : Declaration of the CDeskMovr

#ifndef __DESKMOVR_H_
#define __DESKMOVR_H_

#include "resource.h"       // main symbols

#include "admovr2.h"

#include "stdafx.h"

#define IDR_BOGUS_MOVR_REG  23

// Function prototypes
typedef HRESULT (CALLBACK FAR * LPFNCOMPENUM)(COMPONENT * pComp, LPVOID lpvData, DWORD dwData);
typedef HRESULT (CALLBACK FAR * LPFNELEMENUM)(IHTMLElement * pielem, LPVOID lpvData, LONG lData);

/////////////////////////////////////////////////////////////////////////////
// CDeskMovr
class ATL_NO_VTABLE CDeskMovr :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDeskMovr,&CLSID_DeskMovr>,
    public CComControl<CDeskMovr>,
    public IDeskMovr,
    public IOleObjectImpl<CDeskMovr>,
    public IPersistPropertyBag,
    public IOleControlImpl<CDeskMovr>,
    public IOleInPlaceActiveObjectImpl<CDeskMovr>,
    public IViewObjectExImpl<CDeskMovr>,
    public IOleInPlaceObjectWindowlessImpl<CDeskMovr>,
    public IQuickActivateImpl<CDeskMovr>
{
public:
    
    CDeskMovr(void);
    ~CDeskMovr(void);

DECLARE_REGISTRY_RESOURCEID(IDR_BOGUS_MOVR_REG)

DECLARE_WND_CLASS(TEXT("DeskMover"));

BEGIN_COM_MAP(CDeskMovr)
    COM_INTERFACE_ENTRY(IDeskMovr)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDeskMovr)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CDeskMovr)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnMouseDown)
    MESSAGE_HANDLER(WM_LBUTTONUP, OnMouseUp)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_CAPTURECHANGED, OnCaptureChanged)
    MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
ALT_MSG_MAP(1)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
END_MSG_MAP()

    // IOleInPlaceObject
    virtual STDMETHODIMP InPlaceDeactivate(void);

    // IOleObject
    STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);
    virtual STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    // IOleControl method we override to identify a safe time hook up with our partner and
    // party on the Trident OM
    virtual STDMETHODIMP FreezeEvents(BOOL bFreeze);


    // IViewObjectEx
    virtual STDMETHODIMP GetViewStatus(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }


    // IQuickActivate
    virtual STDMETHODIMP QuickActivate(QACONTAINER *pQACont, QACONTROL *pQACtrl);

    void OnKeyboardHook(WPARAM wParam, LPARAM lParam);

public:

    HRESULT OnDraw(ATL_DRAWINFO& di);

    // IPersistPropertyBag
    // IPersist
    virtual STDMETHODIMP GetClassID(CLSID *pClassID)
    {
        *pClassID = CComCoClass<CDeskMovr,&CLSID_DeskMovr>::GetObjectCLSID();
        return S_OK;
    }

    // IPersistPropertyBag
    //
    virtual STDMETHODIMP InitNew()
    {
        ATLTRACE(_T("CDeskMovr::InitNew\n"));
        return S_OK;
    }
    virtual STDMETHODIMP Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    virtual STDMETHODIMP Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, DWORD dwExStyle = 0,
            UINT nID = 0)
    {
        // We override this method inorder to add the WS_CLIPSIBLINGS bit
        // to dwStyle, which is needed to prevent the IFrames from flashing
        // when the windowed control is moved over them.
        ATOM atom = GetWndClassInfo().Register(&m_pfnSuperWindowProc);
        return CWindowImplBase::Create(hWndParent, rcPos, szWindowName, dwStyle, dwExStyle,
            nID, atom);
    }
    HRESULT SmartActivateMovr(HRESULT hrPropagate);

protected:
    void DeactivateMovr(BOOL fDestroy);           // stop timer, release interfaces
    HRESULT ActivateMovr();          // start timer, secure interfaces

    STDMETHODIMP GetOurStyle(void); // get our control extender's style obj

    void _ChangeCapture(BOOL fSet);
    BOOL FFindTargetElement( IHTMLElement *pielem, IHTMLElement **ppielem );

    HRESULT MoveSelfToTarget( IHTMLElement  *pielem, POINT * pptDoc );
    void    TrackTarget(POINT * pptDoc);

    LRESULT OnPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnMouseDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnMouseUp( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnCaptureChanged( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnTimer( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnSetCursor( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    HRESULT MoveSelfAndTarget( LONG x, LONG y );

    BOOL TrackCaption( POINT * pptDoc );
    void DrawCaptionButton(HDC hdc, LPRECT lprc, UINT uType, UINT uState, BOOL fErase);
    void DrawCaption(HDC hdc, UINT uDrawFlags, int x, int y);
    void UpdateCaption(UINT uDrawFlags);
    void CheckCaptionState(int x, int y);
    HRESULT _DisplayContextMenu(void);
    HRESULT _GetHTMLDoc(IOleClientSite * pocs, IHTMLDocument2 ** pphd2);
    HRESULT _IsInElement(HWND hwndParent, POINT * ppt, IHTMLElement ** pphe);
    HRESULT _GetZOrderSlot(LONG * plZOrderSlot, BOOL fTop);
    HRESULT _HandleZoom(LONG lCommand);
    HRESULT _EnumComponents(LPFNCOMPENUM lpfn, LPVOID lpvData, DWORD dwData);
    HRESULT _EnumElements(LPFNELEMENUM lpfn, LPVOID lpvData, DWORD dwData);
    HRESULT _TrackElement(POINT * ppt, IHTMLElement * pielem, BOOL * fDidWork);
    void _MapPoints(int * px, int * py);
    int CountActiveCaptions();

    // private state information.
    //
    BOOL m_fEnabled;
    long m_lInterval;
 
    int     m_cxBorder;
    int     m_cyBorder;
    int     m_cyCaption;
    int     m_cySysCaption;
    int     m_cyCaptionShow;
    int     m_cySMBorder;
    int     m_cxSMBorder;

    CContainedWindow m_TimerWnd;    // if we're timer-driven, we need this in case we're windowless

    enum DragMode {
        dmNull = 0,         // no dragable part
        dmMenu,             // caption drop down button for menu
        dmClose,            // caption button for close
        dmRestore,          // caption button for restore
        dmFullScreen,       // caption button for full screen
        dmSplit,            // caption button for split
                            // all gadgets on the caption bar should appear before dmMove!
        dmMove,             // move the component
        dmSizeWHBR,         // resize width and height from bottom right corner
        dmSizeWHTL,         // resize width and height from top left corner
        dmSizeWHTR,         // resize width and height from top right corner
        dmSizeWHBL,         // resize width and height from bottom left corner
        dmSizeTop,          // resize from the top edge
        dmSizeBottom,       // resize from the bottom edge
        dmSizeLeft,         // resize from the left edge
        dmSizeRight,        // resize from the right edge
        cDragModes          // count of drag modes, including dmNull
    };

    BITBOOL  m_fCanResizeX; // Whether this component can be resized in X Direction?
    BITBOOL  m_fCanResizeY; // Whether this component can be resized in Y Direction?

    HRESULT  InitAttributes(IHTMLElement *pielem);
    HRESULT GetParentWindow(void);

    DragMode m_dmCur;         // current drag mode, or dmNull if none.
    DragMode m_dmTrack;       // last drag mode seen by TrackCaption
    RECT     m_rectInner;     // area inside frame, in local coords
    RECT     m_rectOuter;     // outer bounds of mover, in local coords
    RECT     m_rectCaption;   // rect of our pseudo-caption, in local coords
    SIZE     m_sizeCorner;    // size of the corner areas of the frame


    BOOL GetCaptionButtonRect(DragMode dm, LPRECT lprc);
    void  SyncRectsToTarget(void);

    DragMode DragModeFromPoint( POINT pt );

    HCURSOR  CursorFromDragMode( DragMode dm );

    HRESULT SizeSelfAndTarget(POINT ptDoc);
    void DismissSelfNow(void);

    BOOL HandleNonMoveSize(DragMode dm);

    HCURSOR m_hcursor;

    LONG    m_top;
    LONG    m_left;
    LONG    m_width;
    LONG    m_height;

    BOOL    m_fTimer;         // do we have a timer running?
    UINT    m_uiTimerID;
    POINT   m_ptMouseCursor;  // Mouse cursor at timer
    

    BSTR    m_bstrTargetName;   // name attribute on targetted html elements

    IHTMLStyle         *m_pistyle;          // our control's style object
    IHTMLStyle         *m_pistyleTarget;    // The style object of our current target, also how we ID it
    IHTMLElement       *m_pielemTarget;     // This interface on the target is how we move and resize it
    LONG                m_iSrcTarget;       // get_sourceIndex value for the current target

    BOOL    m_fCaptured;    // true if mouse-capture/ move operation in progress
    LONG    m_dx;           // delta from mouse down to corner of active gadget
    LONG    m_dy;           // delta from mouse down to corner of active gadget};
    DWORD   m_CaptionState;
    HWND    m_hwndParent;
    LONG    m_zIndexTop;
    LONG    m_zIndexBottom;
    LONG    m_cSkipTimer;   // Used to allow the dismissal of the mover to take two timer periods.
    DWORD   m_ItemState;
};

// Defines for DrawCaption
#define DMDC_CAPTION    0x0001
#define DMDC_MENU       0x0002
#define DMDC_CLOSE      0x0004
#define DMDC_RESTORE    0x0008
#define DMDC_FULLSCREEN 0x0010
#define DMDC_SPLIT      0x0020
#define DMDC_ALL      (DMDC_CAPTION | DMDC_MENU | DMDC_CLOSE | DMDC_SPLIT | DMDC_FULLSCREEN | DMDC_RESTORE)

// Defines for CaptionState
#define CS_MENUTRACKED          0x00000001
#define CS_MENUPUSHED           0x00000002
#define CS_CLOSETRACKED         0x00000004
#define CS_CLOSEPUSHED          0x00000008
#define CS_RESTORETRACKED       0x00000010
#define CS_RESTOREPUSHED        0x00000020
#define CS_FULLSCREENTRACKED    0x00000040
#define CS_FULLSCREENPUSHED     0x00000080
#define CS_SPLITTRACKED         0x00000100
#define CS_SPLITPUSHED          0x00000200

#endif //__DESKMOVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\deskhtml.h ===
#ifndef _DESKHTML_H_
#define _DESKHTML_H_

#include <cowsite.h>

class CDeskHtmlProp     : public CObjectCLSID
                        , public IObjectWithSite
                        , public IShellExtInit
                        , public IBasePropPage
                        , public IPropertyBag
{
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IObjectWithSite ***
    virtual STDMETHODIMP SetSite(IN IUnknown * punkSite);
    virtual STDMETHODIMP GetSite(IN REFIID riid, OUT void ** ppvSite);

    // *** IShellExtInit ***
    virtual STDMETHODIMP Initialize(IN LPCITEMIDLIST pidlFolder, IN LPDATAOBJECT lpdobj, IN HKEY hkeyProgID);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNADDPROPSHEETPAGE lpfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN UINT uPageID, IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, IN LPARAM lParam);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

protected:
    // Constructor / Destructor
    CDeskHtmlProp();
    ~CDeskHtmlProp();

    // Instance creator
    friend HRESULT CDeskHtmlProp_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut);

private:
    // Private member variables
    UINT         _cRef;                     // Reference count
    IShellPropSheetExt * _pspseBkgdPage;    // The Background Page


    // Private member functions
    HRESULT _InitBackgroundTab(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\deskstat.h ===
#ifndef _DESKSTAT_H_
#define _DESKSTAT_H_

#include "mshtml.h"



// NOTE: This is NOT a IE4COMPONENTA struct, it is a IE4COMPONENTT struct.
// Note: This is the old COMPONENTA structure used in IE4. It is kept here for compatibility.
typedef struct _tagIE4COMPONENTA
{
    DWORD   dwSize;
    DWORD   dwID; //Don't make this DWORD_PTR. The public version of this struct uses DWORD here.
    int     iComponentType;
    BOOL    fChecked;
    BOOL    fDirty;
    BOOL    fNoScroll;
    COMPPOS cpPos;
    TCHAR   szFriendlyName[MAX_PATH];
    TCHAR   szSource[INTERNET_MAX_URL_LENGTH];
    TCHAR   szSubscribedURL[INTERNET_MAX_URL_LENGTH];
} IE4COMPONENTA;
typedef IE4COMPONENTA *LPIE4COMPONENTA;
typedef const IE4COMPONENTA *LPCIE4COMPONENTA;

// NOTE: This is NOT a COMPONENTA struct, it is a COMPONENTT struct.

// Note: This is the new NT5 COMPONENT structure. The old component structure is kept at the 
// begining of this struct and the new fields are added at the end. The dwSize field is used to 
// distinguish between the old and new structures.
//
typedef struct _tagCOMPONENTA
{
    DWORD   dwSize;
    DWORD   dwID; //Don't make this DWORD_PTR. The public version of this struct uses DWORD here.
    int     iComponentType;
    BOOL    fChecked;
    BOOL    fDirty;
    BOOL    fNoScroll;
    COMPPOS cpPos;
    TCHAR   szFriendlyName[MAX_PATH];
    TCHAR   szSource[INTERNET_MAX_URL_LENGTH];
    TCHAR   szSubscribedURL[INTERNET_MAX_URL_LENGTH];
    // Add the new fields below this point. Everything above must exactly match the 
    // old IE4COMPONENTA structure for compatibility.
    DWORD           dwCurItemState;
    COMPSTATEINFO   csiOriginal;
    COMPSTATEINFO   csiRestored;
} COMPONENTA;
typedef COMPONENTA *LPCOMPONENTA;
typedef const COMPONENTA *LPCCOMPONENTA;

typedef struct _tagTAGENTRYA
{
    LPCSTR pszTag;
    BOOL fSkipPast;
} TAGENTRYA;

typedef struct _tagTAGENTRYW
{
    LPCWSTR pwszTag;
    BOOL fSkipPast;
} TAGENTRYW;

#define c_wszNULL   (L"")

//The following are the possible values for _iCharset field of CReadFileObj
#define ANSI_HTML_CHARSET       1
#define UNICODE_HTML_CHARSET    2

//
//  The following class implements a uniform way to read chars from an ANSI or UNICODE file.
//

class   CReadFileObj 
{
    friend  class CActiveDesktop;
    
    private:
        HANDLE  _hFile;     //File handle
        int     _iCharset;  //ANSI_HTML_CHARSET or UNICODE_HTML_CHARSET

    public:
        //Constructor
        CReadFileObj(LPCTSTR lpszFileName);
        //Destructor
        ~CReadFileObj();
        //Reads the given number of ansi characters, if an ansi file.
        HRESULT FileReadCharsA(LPSTR lpszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead);
        //Reads the given number of UNICODE characters, if a UNICODE file.
        HRESULT FileReadCharsW(LPWSTR lpwszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead);
        //Reads the given number of characters, and convert them if necessary to ANSI or UNICODE based on destCharset.
        HRESULT FileReadAndConvertChars(int iDestCharset, LPWSTR lpwszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead, UINT *puiCharsConverted);
        //Seeks to a given character offset (not byte offset).
        HRESULT FileSeekChars(LONG lCharOffset, DWORD dwOrigin);
        //Gets the offset of the current file pointer from the begining of the file.
        HRESULT FileGetCurCharOffset(LONG  *plCharOffset);
};

interface IShellImageDataFactory;

class CActiveDesktop : public IActiveDesktop, IActiveDesktopP, IADesktopP2, IPropertyBag
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IActiveDesktop ***
    virtual STDMETHODIMP ApplyChanges(DWORD dwFlags);
    virtual STDMETHODIMP GetWallpaper(LPWSTR pwszWallpaper, UINT cchWallpaper, DWORD dwReserved);
    virtual STDMETHODIMP SetWallpaper(LPCWSTR pwszWallpaper, DWORD dwReserved);
    virtual STDMETHODIMP GetWallpaperOptions(LPWALLPAPEROPT pwpo, DWORD dwReserved);
    virtual STDMETHODIMP SetWallpaperOptions(LPCWALLPAPEROPT pwpo, DWORD dwReserved);
    virtual STDMETHODIMP GetPattern(LPWSTR pwszPattern, UINT cchPattern, DWORD dwReserved);
    virtual STDMETHODIMP SetPattern(LPCWSTR pszPattern, DWORD dwReserved);
    virtual STDMETHODIMP GetDesktopItemOptions(LPCOMPONENTSOPT pco, DWORD dwReserved);
    virtual STDMETHODIMP SetDesktopItemOptions(LPCCOMPONENTSOPT pco, DWORD dwReserved);
    virtual STDMETHODIMP AddDesktopItem(LPCCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP AddDesktopItemWithUI(HWND hwnd, LPCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP ModifyDesktopItem(LPCCOMPONENT pcomp, DWORD dwFlags);
    virtual STDMETHODIMP RemoveDesktopItem(LPCCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP GetDesktopItemCount(LPINT lpiCount, DWORD dwReserved);
    virtual STDMETHODIMP GetDesktopItem(int nComponent, LPCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP GetDesktopItemByID(ULONG_PTR dwID, LPCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP GenerateDesktopItemHtml(LPCWSTR pwszFileName, LPCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP AddUrl(HWND hwnd, LPCWSTR pszSource, LPCOMPONENT pcomp, DWORD dwFlags);
    virtual STDMETHODIMP GetDesktopItemBySource(LPCWSTR pszSource, LPCOMPONENT pcomp, DWORD dwReserved);
    // *** IActiveDesktopP ***
    virtual STDMETHODIMP SetSafeMode(DWORD dwFlags);
    virtual STDMETHODIMP EnsureUpdateHTML(void);
    virtual STDMETHODIMP SetScheme(LPCWSTR pwszSchemeName, DWORD dwFlags);
    virtual STDMETHODIMP GetScheme(LPWSTR pwszSchemeName, LPDWORD lpdwcchBuffer, DWORD dwFlags);
    // *** IADesktopP2 ***
    virtual STDMETHODIMP ReReadWallpaper(void);
    virtual STDMETHODIMP GetADObjectFlags(LPDWORD lpdwFlags, DWORD dwMask);
    virtual STDMETHODIMP UpdateAllDesktopSubscriptions();
    virtual STDMETHODIMP MakeDynamicChanges(IOleObject *pOleObj);
    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);
   
    //Some Ansi versions of the methods for Internal Use
    BOOL AddComponentPrivate(COMPONENTA *pcomp, DWORD dwID);
    BOOL UpdateComponentPrivate(int iIndex, COMPONENTA *pcomp);
    BOOL RemoveComponentPrivate(int iIndex, COMPONENTA *pcomp);
    BOOL GetComponentPrivate(int nComponent, COMPONENTA *pcomp);

    CActiveDesktop();

protected:
    DWORD                       _cRef;
    DWORD                       _dwNextID;
    HDSA                        _hdsaComponent;
    TCHAR                       _szSelectedWallpaper[MAX_PATH];
    TCHAR                       _szSelectedWallpaperConverted[MAX_PATH];
    TCHAR                       _szBackupWallpaper[MAX_PATH];
    TCHAR                       _szSelectedPattern[MAX_PATH];
    LPTSTR                      _pszScheme;
    WALLPAPEROPT                _wpo;
    COMPONENTSOPT               _co;
    HANDLE                      _hFileHtml;             //File handle of desktop.htt
    CReadFileObj*               _pReadFileObjHtmlBkgd; //Object used to read the background html wallpaper
    int                         _iDestFileCharset;      //Whether the dest file desktop.htt is ANSI or UNICODE.

    // used for the temp wallpaper
    LPWSTR _pszWallpaperInUse;      // If using a temp file, keep the name in use so we don't stomp it while the user is previewing other files.
    FILETIME _ftLastWrite;          // The date that the original file was last written to.
    LPTSTR _pszOrigLastApplied;     // Same as _pszOriginalFile except it doesn't change until apply is pressed.

    //  put the BOOLs together
    BOOL            _fDirty;
    BOOL            _fWallpaperDirty;
    BOOL            _fWallpaperChangedDuringInit;
    BOOL            _fPatternDirty;
    BOOL            _fSingleItem;
    BOOL            _fInitialized;
    BOOL            _fNeedBodyEnd;
    BOOL            _fNoDeskMovr;
    BOOL            _fBackgroundHtml;
    IStream         *_pStream;          //To generate individual components.
    BOOL            _fUseDynamicHtml;   //Indicates if Dynamic Html can be used to make changes.
    BOOL            _fPolicyForWPName;  // A policy exists for the wallpaper to be used.
    BOOL            _fPolicyForWPStyle; // A policy exists for the wallpaper style to be used.
    BOOL            _fIgnoreAddRemovePolicies; //If this is set, ignore the policy to add remove items.

    ~CActiveDesktop();

    int  _FindComponentIndexByID(DWORD dwID);
    int  _FindComponentBySource(LPTSTR lpszSource, COMPONENTA *pComp);
    int  _FindComponentBySrcUrl(LPTSTR lpszSrcUrl, COMPONENTA *pComp);

    void _ReadComponent(HKEY hkey, LPCTSTR pszComp);
    void _SortAndRationalize(void);
    void _ReadComponents(BOOL fActiveDesktop);
    void _ReadWallpaper(BOOL fActiveDesktop);
    void _ReadPattern(void);
    void _Initialize(void);

    void _SaveComponent(HKEY hkey, int iIndex, COMPONENTA *pcomp);
    void _SaveComponents(void);
    void _SaveWallpaper(void);
    void _SavePattern(DWORD dwFlags);
    void _SaveSettings(DWORD dwFlags);

    void _GenerateHtmlHeader(void);
    void _GenerateHtmlPicture(COMPONENTA *pcomp);
    void _GenerateHtmlDoc(COMPONENTA *pcomp);
    void _GenerateHtmlSite(COMPONENTA *pcomp);
    void _GenerateHtmlControl(COMPONENTA *pcomp);
    void _GenerateHtmlComponent(COMPONENTA *pcomp);
    void _GenerateHtmlFooter(void);
    void _GenerateHtml(void);

    void _WriteHtmlFromString(LPCTSTR psz);
    void _WriteHtmlFromId(UINT uid);
    void _WriteHtmlFromIdF(UINT uid, ...);
    void _WriteHtmlFromFile(LPCTSTR pszContents);
    void _WriteHtmlFromReadFileObj(CReadFileObj *pReadFileObj, int iOffsetStart, int iOffsetEnd);
    void _WriteResizeable(COMPONENTA *pcomp);
    void _WriteHtmlW(LPCWSTR pwstr, UINT cchToWrite, UINT *pcchWritten);

    int _ScanTagEntriesA(CReadFileObj *pReadFileObj, int iOffsetStart, TAGENTRYA *pte, int cte);
    int _ScanTagEntriesW(CReadFileObj *pReadFileObj, int iOffsetStart, TAGENTRYW *pte, int cte);
    int _ScanForTagA(CReadFileObj *pReadFileObj, int iOffsetStart, LPCSTR pwszTag);
    int _ScanForTagW(CReadFileObj *pReadFileObj, int iOffsetStart, LPCWSTR pwszTag);
    void _ParseAnsiInputHtmlFile(LPTSTR szSelectedWallpaper, int *piOffsetBase, int *piOffsetComp);
    HRESULT _CopyComponent(COMPONENTA *pCompDest, COMPONENTA *pCompSrc, DWORD dwFlags);    
    HRESULT _ConvertFileToTempBitmap(IN LPWSTR pszFile, IN int cchSize);
    HRESULT _SaveTempWallpaperSettings(void);

private:
    HRESULT _AddDTIWithUIPrivateA(HWND hwnd, LPCCOMPONENT pComp, DWORD dwFlags);
    BOOL _IsDisplayInSafeMode(void);

    // The following are used for manipulating ActiveDesktop using Dynamic HTML.
    HRESULT _InsertNewDesktopItems(IHTMLDocument2   *pDoc);
    HRESULT _UpdateDesktopItemHtmlElements(IHTMLDocument2 *pDoc);
    HRESULT _UpdateHtmlElement(IHTMLElement *pElem);
    BOOL    _UpdateIdOfElement(IHTMLElement *pElem, LPCOMPONENTA lpCompA);
    void    _UpdateStyleOfElement(IHTMLElement *pElem, LPCOMPONENTA lpCompA);
    void    _GenerateHtmlBStrForComp(COMPONENTA *pComp, BSTR *pbstr);
};

extern IActiveDesktop *g_pActiveDesk;
int GetIntFromSubkey(HKEY hKey, LPCTSTR lpszValueName, int iDefault);
int GetIntFromReg(HKEY hKey, LPCTSTR lpszSubkey, LPCTSTR lpszNameValue, int iDefault);
BOOL GetStringFromReg(HKEY hkey, LPCTSTR lpszSubkey, LPCTSTR lpszValueName, LPCTSTR lpszDefault, LPTSTR lpszValue, DWORD cchSizeofValueBuff);
STDAPI CActiveDesktop_InternalCreateInstance(LPUNKNOWN * ppunk, REFIID riid);
HRESULT GetPerUserFileName(LPTSTR pszOutputFileName, DWORD dwSize, LPTSTR pszPartialFileName);
STDAPI CDeskHtmlProp_RegUnReg(BOOL bReg);

//Function to convert components in either direction.
void ConvertCompStruct(COMPONENTA *pCompDest, COMPONENTA *pCompSrc, BOOL fPubToPriv);
void SetStateInfo(COMPSTATEINFO *pCompStateInfo, COMPPOS *pCompPos, DWORD dwItemState);

#define MultiCompToWideComp(MultiComp, WideComp)  ConvertCompStruct((COMPONENTA *)WideComp, MultiComp, FALSE)
#define WideCompToMultiComp(WideComp, MultiComp)  ConvertCompStruct(MultiComp, (COMPONENTA *)WideComp, TRUE)

#define COMPONENT_TOP_WINDOWLESS (COMPONENT_TOP / 2)
#define IsWindowLessComponent(pcomp) (((pcomp)->iComponentType == COMP_TYPE_PICTURE) || ((pcomp)->iComponentType == COMP_TYPE_HTMLDOC))

#define COMPONENT_DEFAULT_WIDTH   ((DWORD)-1)
#define COMPONENT_DEFAULT_HEIGHT  ((DWORD)-1)

#define DESKMOVR_FILENAME       TEXT("\\Web\\DeskMovr.htt")
#define DESKTOPHTML_FILENAME    TEXT("\\Microsoft\\Internet Explorer\\Desktop.htt")
#define PATTERN_FILENAME        TEXT("\\Microsoft\\Internet Explorer\\Pattern.bmp")

#define SAVE_PATTERN_NAME       0x00000001
#define GENERATE_PATTERN_FILE   0x00000002

//Property names 
#define c_wszPropName_TSPerfBGPolicy  L"TSConnectEvent"
#define c_wszPropName_IgnorePolicies  L"IgnorePolicies"

#define SZ_REGKEY_ACTDESKTOP_TSPERFPOLICY   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Remote")
#define SZ_REGVALUE_ACTDESKTOP_TSPERFPOLICY TEXT("ActiveDesktop")
#define SZ_REGVDATE_ACTDESKTOP_TSPERFPOLICY TEXT("Force Blank")


#define REGSTR_PATH_WP_POLICY   REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_SYSTEM

BOOL ReadPolicyForWallpaper(LPTSTR  lpszPolicyForWallpaper, DWORD dwSizeofBuff);
BOOL ReadPolicyForWPStyle(LPDWORD  lpdwStyle);

#endif // _DESKSTAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\deskstat.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "..\deskfldr.h"
#include "dutil.h"

extern "C" char * __cdecl StrTokEx(char ** pstring, const char * control);

#define DXA_GROWTH_CONST 10
#define ZINDEX_START 1000

#define MAXID_LENGTH    10  //Maximum number of digits in ID string plus 1.

#if 0
#define TF_DESKSTAT     TF_CUSTOM2
#define TF_DYNAMICHTML  TF_CUSTOM1
#else
#define TF_DESKSTAT     0
#define TF_DYNAMICHTML  0
#endif

IActiveDesktop *g_pActiveDesk = NULL;

#define c_szRegStrDesktop REGSTR_PATH_DESKTOP
#define c_szWallpaper  REG_VAL_GENERAL_WALLPAPER
#define c_szBackupWallpaper REG_VAL_GENERAL_BACKUPWALLPAPER
#define c_szPattern TEXT("Pattern")
#define c_szTileWall REG_VAL_GENERAL_TILEWALLPAPER
#define c_szWallpaperStyle REG_VAL_GENERAL_WALLPAPERSTYLE
#define c_szWallpaperTime REG_VAL_GENERAL_WALLPAPERTIME
#define c_szWallpaperLocalTime REG_VAL_GENERAL_WALLPAPERLOCALTIME
#define c_szRefreshDesktop TEXT("RefreshDesktop")
#define c_szBufferedRefresh TEXT("BufferedRefresh")

#define COMP_TYPE               0x00000003
#define COMP_SELECTED           0x00002000
#define COMP_NOSCROLL           0x00004000

#ifdef DEBUG

#define ENTERPROC EnterProcDS
#define EXITPROC ExitProcDS

void EnterProcDS(DWORD dwTraceLevel, LPSTR szFmt, ...);
void ExitProcDS(DWORD dwTraceLevel, LPSTR szFmt, ...);

extern DWORD g_dwDeskStatTrace;

#else
#ifndef CCOVER
#pragma warning(disable:4002)
#define ENTERPROC()
#define EXITPROC()
#else // ccover buildi
// these are needed because of a bug in cl.exe that results in improper processing
// of #pragma when run with cl -P, and then compiling
#define ENTERPROC 1 ? (void) 0 : (void)
#define EXITPROC 1 ? (void) 0 : (void)
#endif //end of ccover 
#endif

MAKE_CONST_BSTR(s_sstrBeforeEnd,       L"BeforeEnd");
MAKE_CONST_BSTR(s_sstrDeskMovr,        L"DeskMovr");
MAKE_CONST_BSTR(s_sstrDeskMovrW,       L"DeskMovrW");
MAKE_CONST_BSTR(s_sstrclassid,         L"classid");
MAKE_CONST_BSTR(s_sstrEmpty,           L"");


STDAPI ParseDesktopComponent(HWND hwndOwner, LPWSTR wszURL, COMPONENT *pInfo);

WCHAR   wUnicodeBOM =  0xfeff; // Little endian unicode Byte Order Mark.First byte:0xff, Second byte: 0xfe.

//extern BOOL  IsWallpaperDesktopV2(LPCTSTR  lpszWallpaper);

CReadFileObj::CReadFileObj(LPCTSTR lpszFileName)
{
    //Open the file 
    if ((_hFile = CreateFile(lpszFileName, GENERIC_READ, FILE_SHARE_READ, 
                            NULL, OPEN_EXISTING, 
                            FILE_ATTRIBUTE_NORMAL, 0)) != INVALID_HANDLE_VALUE)
    {
        WCHAR  wBOM;
        DWORD  dwBytesRead = 0;
        
        if ((ReadFile(_hFile, (LPVOID)&wBOM, sizeof(WCHAR), &dwBytesRead, NULL)) && 
           (dwBytesRead == sizeof(WCHAR)))
        {
            if (wBOM == wUnicodeBOM)
                _iCharset = UNICODE_HTML_CHARSET;
            else
            {
                //Note: Anything other than the little endian unicode file is treated as ansi.
                _iCharset = ANSI_HTML_CHARSET;
                SetFilePointer(_hFile, 0L, NULL, FILE_BEGIN);  //Seek to the begining of the file
            }
        }
    }
}

CReadFileObj::~CReadFileObj()
{
    if (_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hFile);
        _hFile = NULL;
    }
}

//
// This will read and if necessary convert between ANSI and UNICODE
//
HRESULT CReadFileObj::FileReadAndConvertChars(int iDestCharset, LPWSTR lpwszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead, UINT *puiCharsConverted)
{
    HRESULT hres = S_OK;
    DWORD dwCharsRead = 0;
    DWORD dwTotalCharsConverted = 0;
    if (_hFile != INVALID_HANDLE_VALUE)
    {
        if (_iCharset == UNICODE_HTML_CHARSET)
        {
            if (iDestCharset == UNICODE_HTML_CHARSET)
            {
                hres = FileReadCharsW(lpwszBuff, uiCharsToRead, (UINT *)&dwCharsRead);
                dwTotalCharsConverted = dwCharsRead;
            }
            else
            {
                //Destination is ansi; Read the UNICODE source and convert to ANSI.
                WCHAR  wszBuf[INTERNET_MAX_URL_LENGTH + 1];  //Temp buffer to read the UNICODE chars into.
                LPSTR lpszBuff = (LPSTR)lpwszBuff;

                DWORD  dwTotalCharsToRead = (DWORD)uiCharsToRead;
    
                while(dwTotalCharsToRead)
                {
                    DWORD dwCount;
                    DWORD dwActuallyRead;
                    
                    // - 1 to give room for a null character at the end.
                    dwCount = (DWORD)min(dwTotalCharsToRead, (ARRAYSIZE(wszBuf) - 1));
                    if (ReadFile(_hFile, (LPSTR)wszBuf, dwCount*sizeof(WCHAR), &dwActuallyRead, NULL))
                    {
                        DWORD dwConverted;
                        dwActuallyRead = dwActuallyRead/sizeof(WCHAR);
                        
                        //Null terminate the source buffer.
                        wszBuf[dwActuallyRead] = L'\0';  //UNICODE null terminate the source.
                        //Convert what we just read.
                        dwConverted = SHUnicodeToAnsi(wszBuf, lpszBuff, dwActuallyRead+1); //+1 for null termination

                        //Update the count & stuff.
                        lpszBuff += dwConverted - 1;  //Subtract the null.
                        dwTotalCharsToRead -= dwActuallyRead;
                        dwCharsRead += dwActuallyRead;
                        dwTotalCharsConverted += dwConverted - 1; //Subtract the null.
                    
                        if (dwActuallyRead < dwCount)
                            break;  //We have reached the end of file.
                    }
                    else
                    {
                        hres = E_FAIL;
                        break;
                    }
                }
            }
        }
        else
        {
            //Source file is ANSI. Check the Destination.
            if (iDestCharset == ANSI_HTML_CHARSET)
            {
                //Destination is ANSI too! Cool! No need for conversion!
                hres = FileReadCharsA((LPSTR)lpwszBuff, uiCharsToRead, (UINT *)&dwCharsRead);
                dwTotalCharsConverted = dwCharsRead;
            }
            else
            {
                //Destination is UNICODE!  Read the ansi and convert it to UNICODE!
                char  szBuf[INTERNET_MAX_URL_LENGTH + 1];  //Temp buffer to read the ansi chars into.
                DWORD  dwTotalCharsToRead = (DWORD)uiCharsToRead;

                while(dwTotalCharsToRead)
                {
                    DWORD dwCount;
                    DWORD dwActuallyRead;

                    // - 1 to give room for a null character at the end.
                    dwCount = (DWORD)min(dwTotalCharsToRead, (ARRAYSIZE(szBuf) - 1));

                    if (ReadFile(_hFile, (LPSTR)szBuf, dwCount, &dwActuallyRead, NULL))
                    {
                        DWORD dwConverted;
                        //Null terminate the source buffer.
                        szBuf[dwActuallyRead] = '\0';  //ANSI null terminate the source.
                        //Convert what we just read.
                        dwConverted = SHAnsiToUnicode(szBuf, lpwszBuff, dwActuallyRead+1); //+1 for null termination

                        //Update the count & stuff.
                        lpwszBuff += dwConverted - 1;  //Subtract the null.
                        dwTotalCharsToRead -= dwActuallyRead;
                        dwCharsRead += dwActuallyRead;
                        dwTotalCharsConverted += dwConverted - 1; //Subtract the null.
                    
                        if (dwActuallyRead < dwCount)
                            break;  //We have reached the end of file.
                    }
                    else
                    {
                        hres = E_FAIL;
                        break;
                    }
                } //while
            }
        }
    }
    else
        hres = E_FAIL;  //The file handle is bad.

    *puiCharsActuallyRead = (UINT)dwCharsRead;
    *puiCharsConverted = (UINT)dwTotalCharsConverted;
    return hres; 
}


HRESULT CReadFileObj::FileReadCharsA(LPSTR lpszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead)
{
    HRESULT hres = E_FAIL;
    DWORD dwCharsRead = 0;
    
    if ((_hFile != INVALID_HANDLE_VALUE) && 
        (_iCharset == ANSI_HTML_CHARSET) &&
        ReadFile(_hFile, (LPVOID)lpszBuff, (DWORD)(uiCharsToRead), &dwCharsRead, NULL))
    {
        dwCharsRead = dwCharsRead; //get the number of wchars read.
        hres = S_OK;
    }
    *puiCharsActuallyRead = (UINT)dwCharsRead;
    return hres; 
}

//
// NOTE: The uiCharsToRead must be atleast one less than the size of the buffer (lpwszBuff)
// because one null may be written at the end of the buffer by SHAnsiToUnicode().
//
HRESULT CReadFileObj::FileReadCharsW(LPWSTR lpwszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead)
{
    HRESULT hres = E_FAIL;
    DWORD dwCharsRead = 0;
    
    if ((_hFile != INVALID_HANDLE_VALUE) && 
        (_iCharset == UNICODE_HTML_CHARSET) &&
        ReadFile(_hFile, (LPVOID)lpwszBuff, (DWORD)(uiCharsToRead*sizeof(WCHAR)), &dwCharsRead, NULL))
    {
        dwCharsRead = dwCharsRead/sizeof(WCHAR); //get the number of wchars read.
        hres = S_OK;
    }
    *puiCharsActuallyRead = (UINT)dwCharsRead;
    return hres; 
}

HRESULT CReadFileObj::FileSeekChars(LONG  lCharOffset, DWORD dwOrigin)
{
    HRESULT hres = E_FAIL;

    if (_hFile != INVALID_HANDLE_VALUE)
    {
        if (SetFilePointer(_hFile, 
                    lCharOffset*((_iCharset == UNICODE_HTML_CHARSET) ? sizeof(WCHAR) : sizeof(char)),
                    NULL,
                    dwOrigin) != INVALID_SET_FILE_POINTER)
            hres = S_OK;
    }

    return hres;
}

HRESULT CReadFileObj::FileGetCurCharOffset(LONG  *plCharOffset)
{
    HRESULT hres = E_FAIL;
    DWORD   dwByteOffset = 0;

    *plCharOffset = 0;
    if (_hFile != INVALID_HANDLE_VALUE)
    {
        if ((dwByteOffset = SetFilePointer(_hFile, 
                                            0L,
                                            NULL,
                                            FILE_CURRENT)) != INVALID_SET_FILE_POINTER)
        {
            *plCharOffset = dwByteOffset/((_iCharset == UNICODE_HTML_CHARSET) ? sizeof(WCHAR) : sizeof(char));
            hres = S_OK;
        }
    }

    return hres;
}

BOOL GetStringFromReg(HKEY    hkey,
              LPCTSTR lpszSubkey,
              LPCTSTR lpszValueName,
              LPCTSTR lpszDefault,
              LPTSTR  lpszValue,
              DWORD   cchSizeofValueBuff)
{
    DWORD cb = cchSizeofValueBuff * sizeof(lpszValue[0]);
    BOOL fRet = (SHGetValue(hkey, lpszSubkey, lpszValueName, NULL, lpszValue, &cb) == ERROR_SUCCESS);

    // On failure use the default string.
    if (!fRet && lpszDefault)
    {
        StrCpyN(lpszValue, lpszDefault, cchSizeofValueBuff);
    }

    return fRet;
}

void GetWallpaperFileTime(LPCTSTR pszWallpaper, LPFILETIME lpftFileTime)
{
    HANDLE   hFile;
    BOOL fRet = FALSE;

    if ((hFile = CreateFile(pszWallpaper, GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, 0)) != INVALID_HANDLE_VALUE)
    {
        fRet = GetFileTime(hFile, NULL, NULL, lpftFileTime);

        CloseHandle(hFile);
    }

    if (!fRet)
        ZeroMemory(lpftFileTime, sizeof(FILETIME));

    //  no return value
}

BOOL  HasWallpaperReallyChanged(LPCTSTR pszRegKey, LPTSTR pszOldWallpaper, LPTSTR pszBackupWallpaper, DWORD dwOldWallpaperStyle, DWORD dwNewWallpaperStyle)
{
    //  we default to TRUE here.
    
    if ((dwOldWallpaperStyle == dwNewWallpaperStyle)
    && (0 == lstrcmpi(pszOldWallpaper, pszBackupWallpaper)))
    {
        // The wallpaper filename and style hasn't changed. 
        //  But, the content of this file could have changed. 
        //  See if the content has changed by looking at the 
        // last-written date and time stamp on this file.
        FILETIME ftOld, ftBack;
        DWORD cbBack = sizeof(ftBack);

        //  if either of these fail, then they will
        //  remain Zero  so the compare will
        //  be successful.
        GetWallpaperFileTime(pszOldWallpaper, &ftOld);
        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, pszRegKey, c_szWallpaperTime, NULL, &ftBack, &cbBack))
            ZeroMemory(&ftBack, sizeof(ftBack));

        //Get the last written time of the backup wallpaper from registry
        if (0 == CompareFileTime(&ftOld, &ftBack))
            return FALSE;   //  everything is the same!

        // Win2K QFE bug 10689 (AndrewGr)
        // same check, but instead of checking UTC time, check local time converted to UTC time
        // this is because FAT disks store local time, not UTC time
        FILETIME ftLocalBack, ftLocalBackUtc;

            cbBack = sizeof(ftLocalBack);

        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, pszRegKey, c_szWallpaperLocalTime, NULL, &ftLocalBack, &cbBack))
            ZeroMemory(&ftLocalBack, sizeof(ftLocalBack));

        LocalFileTimeToFileTime(&ftLocalBack, &ftLocalBackUtc);
            
        if (ftOld.dwLowDateTime == ftLocalBackUtc.dwLowDateTime
        && (ftOld.dwHighDateTime == ftLocalBackUtc.dwHighDateTime))
            // everything is the same!
            return FALSE;


    }
    
    return TRUE;
}

//-------------------------------------------------------------------------------------------------------------//
//  Function: ReadWallpaperStyleFromReg()
//
// This function reads the "TileWallpaper" and the "WallpaperStyle" from the given location
// in the registry.
//
//-------------------------------------------------------------------------------------------------------------//

int GetIntFromReg(HKEY    hKey,
                  LPCTSTR lpszSubkey,
                  LPCTSTR lpszNameValue,
                  int     iDefault)
{
    TCHAR szValue[20];
    DWORD dwSizeofValueBuff = sizeof(szValue);
    int iRetValue = iDefault;
    DWORD dwType;

    if ((SHGetValue(hKey, lpszSubkey, lpszNameValue, &dwType, szValue,
                   &dwSizeofValueBuff) == ERROR_SUCCESS) && dwSizeofValueBuff)
    {
        if (dwType == REG_SZ)
        {
            iRetValue = (int)StrToInt(szValue);
        }
    }

    return iRetValue;
}

void ReadWallpaperStyleFromReg(LPCTSTR pszRegKey, DWORD *pdwWallpaperStyle, BOOL fIgnorePlatforms)
{
    if (GetIntFromReg(HKEY_CURRENT_USER, pszRegKey, c_szTileWall, WPSTYLE_TILE))
    {
        // "Tile" overrides the "Stretch" style.
        *pdwWallpaperStyle = WPSTYLE_TILE;
    }
    else
    {
        // else, STRETCH or CENTER.
        *pdwWallpaperStyle = GetIntFromReg(HKEY_CURRENT_USER, pszRegKey, c_szWallpaperStyle, WPSTYLE_CENTER);
    }
}

BOOL CActiveDesktop::_IsDisplayInSafeMode(void)
{
    WCHAR wszDisplay[MAX_PATH];
    DWORD dwcch = MAX_PATH;

    return (SUCCEEDED(GetScheme(wszDisplay, &dwcch, SCHEME_GLOBAL | SCHEME_DISPLAY)) 
            && (0 == StrCmpW(wszDisplay, REG_DESKCOMP_SAFEMODE_SUFFIX_L)));
}


BOOL ReadPolicyForWallpaper(LPTSTR  pszPolicy, DWORD cchPolicy)
{
    BOOL fPolicySet = FALSE;
    DWORD cb = cchPolicy * sizeof(pszPolicy[0]);
    if ((SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_WP_POLICY, c_szWallpaper, NULL, pszPolicy, &cb) == ERROR_SUCCESS) && cb)
    {
        //  even if this value was originally REG_SZ it may still
        //  have environment vars in it for legacy reasons!
        PathExpandEnvStringsWrap(pszPolicy, cchPolicy);
        fPolicySet = TRUE;  //Policy is there!
    }
    else
    {
        // See if the TS Perf policy is set to turn it off for perf.
        fPolicySet = (IsTSPerfFlagEnabled(TSPerFlag_NoADWallpaper) || IsTSPerfFlagEnabled(TSPerFlag_NoWallpaper)); //No policy is set!
    }

    return fPolicySet;
}

BOOL GetWallpaperPath(HKEY hKey, LPCTSTR pszKey, LPCTSTR pszValue, LPCTSTR pszFallBack, LPTSTR pszPath, DWORD cchSize)
{
    BOOL fSucceeded = GetStringFromReg(hKey, pszKey, pszValue, pszFallBack, pszPath, cchSize);

    if (fSucceeded)
    {
        PathExpandEnvStringsWrap(pszPath, cchSize);
    }

    return fSucceeded;
}

BOOL ReadPolicyForWPStyle(LPDWORD  lpdwStyle)
{
    DWORD   dwStyle;
    DWORD   dwType;
    TCHAR   szValue[20];
    DWORD   dwSizeofValueBuff = sizeof(szValue);
    BOOL    fRet = FALSE;

    // The caller can passin a NULL, if they are not interested in the actual value and they just
    // want to know if this policy is set or not.
    if (!lpdwStyle)  
        lpdwStyle = &dwStyle;

    if ((SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_WP_POLICY, c_szWallpaperStyle, &dwType, szValue,
                   &dwSizeofValueBuff) == ERROR_SUCCESS) && dwSizeofValueBuff)
    {
        if (dwType == REG_SZ)
        {
            *lpdwStyle = (DWORD)StrToInt(szValue);
            fRet = TRUE;
        }
    }

    return fRet;
}

void CActiveDesktop::_ReadWallpaper(BOOL fActiveDesktop)
{
    ENTERPROC(2, "DS ReadWallpaper()");

    TCHAR lpszDeskcomp[MAX_PATH];

    GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_GENERAL, _pszScheme);

    _fPolicyForWPName = ReadPolicyForWallpaper(_szSelectedWallpaper, ARRAYSIZE(_szSelectedWallpaper));
    _fPolicyForWPStyle = ReadPolicyForWPStyle(&_wpo.dwStyle);
    
    //
    // Read in the wallpaper and style from the appropriate registry location.
    //
    LPCTSTR pszRegKey;
    if (fActiveDesktop)
    {
        pszRegKey = (LPCTSTR)lpszDeskcomp;
        TCHAR   szOldWallpaper[MAX_PATH];
        DWORD   dwOldWallpaperStyle;

        // Read the Wallpaper from the Old location.
        GetWallpaperPath(HKEY_CURRENT_USER, c_szRegStrDesktop, c_szWallpaper, c_szNULL, szOldWallpaper, ARRAYSIZE(szOldWallpaper));

        // Read wallpaper style from the old location.
        ReadWallpaperStyleFromReg((LPCTSTR)c_szRegStrDesktop, &dwOldWallpaperStyle, FALSE);

        // Read the wallpaper from the new location too!
        if ((!_fPolicyForWPName) || (_IsDisplayInSafeMode()))
        {
            if (!GetWallpaperPath(HKEY_CURRENT_USER, pszRegKey, c_szWallpaper, szOldWallpaper, _szSelectedWallpaper, ARRAYSIZE(_szSelectedWallpaper)))
            {
                pszRegKey = c_szRegStrDesktop;
            }
        }

        //Read wallpaper style from the new location too!
        if (!_fPolicyForWPStyle)
            ReadWallpaperStyleFromReg(pszRegKey, &_wpo.dwStyle, FALSE);
        
        //If there is a Safe mode scheme here do NOT attempt to change wallpaper
        if ((!_IsDisplayInSafeMode()) && (!_fPolicyForWPName))
        {
            //Read what is stored as "Backup" wallpaper.
            GetWallpaperPath(HKEY_CURRENT_USER, pszRegKey, c_szBackupWallpaper, szOldWallpaper, _szBackupWallpaper, ARRAYSIZE(_szBackupWallpaper));
            //See if the Old wallpaper is differnet from the backed up wallpaper
            if (HasWallpaperReallyChanged(pszRegKey, szOldWallpaper, _szBackupWallpaper, dwOldWallpaperStyle, _wpo.dwStyle))
            {
                //They are different. This means that some other app has changed the "Old" wallpaper
                //after the last time we backed it up in the registry.
                // Make this wallpaper as the Selected wallpaper!

                lstrcpy(_szSelectedWallpaper, szOldWallpaper);
                _wpo.dwStyle = dwOldWallpaperStyle;

                _fWallpaperDirty = TRUE;
                _fWallpaperChangedDuringInit = TRUE;
            }

        }
        //Make a backup of the "Old" wallpaper
        lstrcpy(_szBackupWallpaper, szOldWallpaper);
    }
    else
    {
        pszRegKey = c_szRegStrDesktop; //Get it from the old location!

        //Since active desktop is not available, read wallpaper from old location.
        if (!_fPolicyForWPName)
        {
            GetWallpaperPath(HKEY_CURRENT_USER, pszRegKey, c_szWallpaper, c_szNULL, _szSelectedWallpaper, ARRAYSIZE(_szSelectedWallpaper));
        }

        //Make a backup of the "Old" wallpaper
        lstrcpy(_szBackupWallpaper, _szSelectedWallpaper);

        //Read the wallpaper style
        if (!_fPolicyForWPStyle)
            ReadWallpaperStyleFromReg(pszRegKey, &_wpo.dwStyle, TRUE);
    }

    EXITPROC(2, "DS ReadWallpaper! (_szSelectedWP=>%s<)", _szSelectedWallpaper);
}

void CActiveDesktop::_ReadPattern(void)
{
    ENTERPROC(2, "DS ReadPattern()");

    GetStringFromReg(HKEY_CURRENT_USER, c_szRegStrDesktop, c_szPattern, c_szNULL, _szSelectedPattern, ARRAYSIZE(_szSelectedPattern));

    EXITPROC(2, "DS ReadPattern! (_szSelectedPattern=>%s<)", _szSelectedPattern);
}

void CActiveDesktop::_ReadComponent(HKEY hkey, LPCTSTR pszComp)
{
    ENTERPROC(2, "DS ReadComponent(hk=%08X,pszComp=>%s<)", hkey, pszComp);

    HKEY hkeyComp;

    if (RegOpenKeyEx(hkey, pszComp, 0, KEY_READ, &hkeyComp) == ERROR_SUCCESS)
    {
        DWORD cbSize;
        COMPONENTA comp;
        comp.dwSize = sizeof(COMPONENTA);

        //
        // Read in the source string.
        //
        cbSize = sizeof(comp.szSource);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_SOURCE, NULL, NULL, (LPBYTE)&comp.szSource, &cbSize) != ERROR_SUCCESS)
        {
            comp.szSource[0] = TEXT('\0');
        }

        //
        // Read in the SubscribedURL string.
        //
        cbSize = sizeof(comp.szSubscribedURL);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_SUBSCRIBED_URL, NULL, NULL, (LPBYTE)&comp.szSubscribedURL, &cbSize) != ERROR_SUCCESS)
        {
            comp.szSubscribedURL[0] = TEXT('\0');
        }

        //
        // Read in the Friendly name string.
        //
        cbSize = sizeof(comp.szFriendlyName);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_NAME, NULL, NULL, (LPBYTE)&comp.szFriendlyName, &cbSize) != ERROR_SUCCESS)
        {
            comp.szFriendlyName[0] = TEXT('\0');
        }

        //
        // Read in and parse the flags.
        //
        DWORD dwFlags;
        cbSize = sizeof(dwFlags);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_FLAGS, NULL, NULL, (LPBYTE)&dwFlags, &cbSize) != ERROR_SUCCESS)
        {
            dwFlags = 0;
        }
        comp.iComponentType = dwFlags & COMP_TYPE;
        comp.fChecked = (dwFlags & COMP_SELECTED) != 0;
        comp.fNoScroll = (dwFlags & COMP_NOSCROLL) != 0;
        comp.fDirty = FALSE;    //Reading it fresh from registry; Can't be dirty!

        //
        // Read in the location.
        //
        cbSize = sizeof(comp.cpPos);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_POSITION, NULL, NULL, (LPBYTE)&comp.cpPos, &cbSize) != ERROR_SUCCESS)
        {
            ZeroMemory(&comp.cpPos, sizeof(comp.cpPos));
        }

        //
        // In IE4.x, we have a very huge positive number (0x7fffffff) as the COMPONENT_TOP;
        // As a result some component's z-index overflowed into the negative range (0x80000003)
        // To fix this, we halved the COMPONENT_TOP (0x3fffffff) and also check for negative z-index
        // values and covert them to postive values.
        if (comp.cpPos.izIndex < 0)
            comp.cpPos.izIndex = COMPONENT_TOP;

        //
        // Make sure the cpPos.dwSize is set to correct value
        //
        comp.cpPos.dwSize = sizeof(COMPPOS);

        //
        //  Read in the current ItemState
        //
        cbSize = sizeof(comp.dwCurItemState);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_CURSTATE, NULL, NULL, (LPBYTE)&comp.dwCurItemState, &cbSize) != ERROR_SUCCESS)
        {
            //If the item state is missing, we must be reading from IE4 machine.
            comp.dwCurItemState = IS_NORMAL;
        }

        //
        //  Read in the Original state info.
        //
        cbSize = sizeof(comp.csiOriginal);
        if ((SHQueryValueEx(hkeyComp, REG_VAL_COMP_ORIGINALSTATEINFO, NULL, NULL, (LPBYTE)&comp.csiOriginal, &cbSize) != ERROR_SUCCESS) ||
            (comp.csiOriginal.dwSize != sizeof(comp.csiOriginal)))
        {
            //If the item state is missing, we must be reading from IE4 machine.
            // Set the OriginalState to the default info.
            SetStateInfo(&comp.csiOriginal, &comp.cpPos, IS_NORMAL);
            comp.csiOriginal.dwHeight = comp.csiOriginal.dwWidth = COMPONENT_DEFAULT_WIDTH;
        }

        //
        //  Read in the Restored state info.
        //
        cbSize = sizeof(comp.csiRestored);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_RESTOREDSTATEINFO, NULL, NULL, (LPBYTE)&comp.csiRestored, &cbSize) != ERROR_SUCCESS)
        {
            //If the item state is missing, we must be reading from IE4 machine.
            // Set the restored State to the default info.
            SetStateInfo(&comp.csiRestored, &comp.cpPos, IS_NORMAL);
        }

        //
        // Add the component to the component list.
        //
        AddComponentPrivate(&comp, StrToInt(pszComp));

        //
        // Increment our counter so we know where to add any new
        // components after we're done.
        //
        _dwNextID++;

        RegCloseKey(hkeyComp);
    }

    EXITPROC(2, "DS ReadComponent!");
}

typedef struct _tagSortStruct {
    int ihdsaIndex;
    int izIndex;
} SORTSTRUCT;

int CALLBACK pfnComponentSort(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    SORTSTRUCT * pss1 = (SORTSTRUCT *)p1;
    SORTSTRUCT * pss2 = (SORTSTRUCT *)p2;

    if (pss1->izIndex > pss2->izIndex)
        return 1;

    if (pss1->izIndex < pss2->izIndex)
        return -1;

    return(0);
}

//
// ModifyZIndex
//
// Little helper function to put the zindex of the windowed and windowless components
// into correct buckets so that zorting will produce a correct order by zindex.
//
// If we don't do this then windowless components may end up zordering above windowed ones.
//
void ModifyZIndex(COMPONENTA * pcomp)
{
    if (pcomp->cpPos.izIndex != COMPONENT_TOP) {
        if (!IsWindowLessComponent(pcomp))
            pcomp->cpPos.izIndex += COMPONENT_TOP_WINDOWLESS;
    }
    else
    {
        if (IsWindowLessComponent(pcomp))
            pcomp->cpPos.izIndex = COMPONENT_TOP_WINDOWLESS;
    }
}

//
// SortAndRationalize
//
// SortAndRationalize will take an unsorted component list and sort it such that the components
// come out in the correct z-index indicated order.  It will also rebase the z-index values at
// a known constant so that the z-index values will not grow endlessly.  SortAndRationalize also
// imposes windowed vs. windowless criteria to the zindex values such that windowless components
// always zorder under windowed ones.
//
void CActiveDesktop::_SortAndRationalize(void)
{
    int icComponents;
    HDPA hdpa;

    if (_hdsaComponent && ((icComponents = DSA_GetItemCount(_hdsaComponent)) > 1) && (hdpa = DPA_Create(0))) {
        COMPONENTA * pcomp;
        SORTSTRUCT * pss;
        int i, iCur = ZINDEX_START;
        BOOL fInsertFailed = FALSE;
        HDSA hdsaOld;

        // Go through each component and insert it's hdsa-index and zindex into the hdpa
        for (i = 0; i < icComponents; i++)
        {
            if (!(pss = (SORTSTRUCT *)LocalAlloc(LPTR, sizeof(SORTSTRUCT))))
                break;

            pcomp = (COMPONENTA *)DSA_GetItemPtr(_hdsaComponent, i);
            ModifyZIndex(pcomp);
            pss->ihdsaIndex = i;
            pss->izIndex = pcomp->cpPos.izIndex;
            if (DPA_AppendPtr(hdpa, (void FAR *)pss) == -1) {
                LocalFree((HANDLE)pss);
                break;
            }
        }

        // Sort the hdpa by zindex
        DPA_Sort(hdpa, pfnComponentSort, 0);

        // Save old values
        hdsaOld = _hdsaComponent;

        // Null out the old hdsa, so AddComponentPrivate will create a new one
        _hdsaComponent = NULL;

        // Now go through the sorted hdpa and update the component zindex with a ZINDEX_START based zindex, then
        // add the component to the new hdsa in sorted order.
        for (i = 0; i < icComponents; i++) {
            if (!(pss = (SORTSTRUCT *)DPA_GetPtr(hdpa, i)))
                break;
            // Get component and update it's zIndex and id
            pcomp = (COMPONENTA *)DSA_GetItemPtr(hdsaOld, pss->ihdsaIndex);
            pcomp->cpPos.izIndex = iCur;
            iCur += 2;

            // Free ptr
            LocalFree((HANDLE)pss);

            // Add to new hdsa in sorted order
            if (!fInsertFailed) {
                fInsertFailed = !AddComponentPrivate(pcomp, pcomp->dwID);
            }
        }

        // If we're completely successfull then destroy the old hdsa.  Otherwise we need
        // to destroy the new one and restore the old one.
        if ((i == icComponents) && !fInsertFailed) {
            DSA_Destroy(hdsaOld);
        } else {
            if (_hdsaComponent)
            DSA_Destroy(_hdsaComponent);
            _hdsaComponent = hdsaOld;
        }

        DPA_Destroy(hdpa);
    }
}

void CActiveDesktop::_ReadComponents(BOOL fActiveDesktop)
{
    ENTERPROC(2, "DS ReadComponents()");

    HKEY hkey;
    TCHAR lpszDeskcomp[MAX_PATH];

    GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_COMPONENTS, _pszScheme);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszDeskcomp, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD cbSize;
        int i = 0;
        TCHAR lpszSubkey[MAX_PATH];

        //
        // Read in the general settings.
        //
        DWORD dwSettings;
        cbSize = sizeof(dwSettings);
        if (SHQueryValueEx(hkey, REG_VAL_COMP_SETTINGS, NULL, NULL, (LPBYTE)&dwSettings, &cbSize) == ERROR_SUCCESS)
        {
            _co.fEnableComponents = (dwSettings & COMPSETTING_ENABLE) != 0;
        }
        _co.fActiveDesktop = fActiveDesktop;

        //
        // Read in all the desktop components
        //
        while (RegEnumKey(hkey, i, lpszSubkey, ARRAYSIZE(lpszSubkey)) == ERROR_SUCCESS)
        {
            _ReadComponent(hkey, lpszSubkey);
            i++;
        }

        _SortAndRationalize();

        RegCloseKey(hkey);
    }

    EXITPROC(2, "DS ReadComponents!");
}

void CActiveDesktop::_Initialize(void)
{
    ENTERPROC(2, "DS Initialize()");

    if (!_fInitialized)
    {
        _fInitialized = TRUE;
        InitDeskHtmlGlobals();

        SHELLSTATE ss = {0};
        SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);
        
        BOOL fActiveDesktop = BOOLIFY(ss.fDesktopHTML);
        
        _co.dwSize = sizeof(_co);
        _wpo.dwSize = sizeof(_wpo);

        //
        // This per-user registry branch may not exist for this user. Or, even if
        // it does exist, it may have some stale info. So ensure that atlreast the 
        // default components are there and that the html version is current for this
        // branch of the registry!
        //  If everything is current, the following function does nothing!
        //
        CDeskHtmlProp_RegUnReg(TRUE);  //TRUE => install.

        _ReadWallpaper(fActiveDesktop);
        _ReadPattern();
        _ReadComponents(fActiveDesktop);

        // If we are in safemode, the we can not use Dynamic Html to make updates because
        // updates involve complete change of background Html.
        if (_IsDisplayInSafeMode())
            _fUseDynamicHtml = FALSE;
        else
            _fUseDynamicHtml = TRUE;        //Any component added after the initialization must go through dynamic html.

        _fDirty = FALSE;
        _fNeedBodyEnd = FALSE;
    }

    EXITPROC(2, "DS Initialize!");
}


void CActiveDesktop::_SaveWallpaper(void)
{
    ENTERPROC(2, "DS SaveWallpaper");
    TCHAR lpszDeskcomp[MAX_PATH];
    BOOL    fNormalWallpaper;

    GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_GENERAL, _pszScheme);

    //
    // Compute tiling string.
    //
    TCHAR szTiled[2];
    lstrcpy(szTiled, TEXT("0"));
    szTiled[0] = szTiled[0] + (TCHAR)(_wpo.dwStyle & WPSTYLE_TILE);

    //
    // Compute the Wallpaper styling string
    //
    TCHAR       szWPStyle[2];
    lstrcpy(szWPStyle, TEXT("0"));
    //
    // NOTE: If WPSTYLE_TILE is set, we still want to say WallpaperStyle="0"; This won't hurt
    // because TileWallpaper="1" will over-ride this anyway.
    // The reason for this hack is that during memphis setup, they put a tiled wallpaper. Then we
    // write WallpaperStyle=1 and TileWallpaper=1 in new and old locations. Then, then change
    // the wallpaper and set TileWallpaper=0. Since the WallpaperStyle continues to be 1, they 
    // get a tiled wallpaper finally. The following is to avoid this problem!
    // 
    szWPStyle[0] = szWPStyle[0] + (TCHAR)(_wpo.dwStyle & WPSTYLE_STRETCH);
    

    //
    // Write out wallpaper settings in new active desktop area.
    //
    if (_fWallpaperDirty || _fWallpaperChangedDuringInit)
    {
        if (!_fPolicyForWPStyle)
        {
            SHSetValue(HKEY_CURRENT_USER, lpszDeskcomp,
                c_szTileWall, REG_SZ, szTiled, CbFromCch(lstrlen(szTiled)+1));
        }

        //
        // Note: We do not write the Wallpaper Style string for older systems because we do not
        // want to over-write what PlusPack writes. However, for newer Operating systems, we 
        // want to write the WallpaperStyle also.
        //
        if (!_fPolicyForWPStyle)
        {
            SHSetValue(HKEY_CURRENT_USER, lpszDeskcomp,
                c_szWallpaperStyle, REG_SZ, szWPStyle, CbFromCch(lstrlen(szWPStyle)+1));
        }

        if (!_fPolicyForWPName)
        {
            SHRegSetPath(HKEY_CURRENT_USER, lpszDeskcomp, c_szWallpaper, _szSelectedWallpaper, 0);
        }
    }

    if (fNormalWallpaper = IsNormalWallpaper(_szSelectedWallpaper))
    {
        lstrcpyn(_szBackupWallpaper, _szSelectedWallpaper, ARRAYSIZE(_szBackupWallpaper));
    }

    if (!_fPolicyForWPName)
    {
        FILETIME ft, ftLocal;
        GetWallpaperFileTime(_szBackupWallpaper, &ft);
        FileTimeToLocalFileTime(&ft, &ftLocal);  // for FAT systems to track across DST changes

        // Backup the "Old type" wallpaper's name here in the new location
        // sothat we can detect when this gets changed by some other app.
        SHRegSetPath(HKEY_CURRENT_USER, lpszDeskcomp, c_szBackupWallpaper, _szBackupWallpaper, 0);

        SHSetValue(HKEY_CURRENT_USER, lpszDeskcomp,
                c_szWallpaperTime, REG_BINARY, &ft,
                sizeof(ft));    

        SHSetValue(HKEY_CURRENT_USER, lpszDeskcomp,
                c_szWallpaperLocalTime, REG_BINARY, &ftLocal,
                sizeof(ftLocal));      // AndrewGr save local time not UTC time   
    }
    
    //
    // Even if this wallpaper is not valid in normal desktop (i.e., even if it is not a .BMP),
    // write it out in normal desktop registry area.
    //
    if (_fWallpaperDirty)
    {
        if (!_fPolicyForWPStyle)
        {
            SHSetValue(HKEY_CURRENT_USER, c_szRegStrDesktop,
                    c_szTileWall, REG_SZ, szTiled, CbFromCch(lstrlen(szTiled)+1));
        }
        //
        // Note: We do not write the Wallpaper Style string for older systems because we do not
        // want to over-write what PlusPack writes. However, for newer Operating systems, we 
        // want to write the WallpaperStyle also.
        //
        if (!_fPolicyForWPStyle)
        {
            SHSetValue(HKEY_CURRENT_USER, c_szRegStrDesktop,
                        c_szWallpaperStyle, REG_SZ, szWPStyle, CbFromCch(lstrlen(szWPStyle)+1));
        }

        if (!_fPolicyForWPName)
        {
            SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, 
                    (fNormalWallpaper ? _szSelectedWallpaper : _szBackupWallpaper),
                    SPIF_UPDATEINIFILE);
        }
    }

    EXITPROC(2, "DS SaveWallpaper");
}

void CActiveDesktop::_SaveComponent(HKEY hkey, int iIndex, COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS SaveComponent(hkey=%08X,iIndex=%d,pcomp=%08X)", hkey, iIndex, pcomp);

    TCHAR szSubKey[8];
    HKEY hkeySub;

    wsprintf(szSubKey, TEXT("%d"), iIndex);
    if (RegCreateKey(hkey, szSubKey, &hkeySub) == ERROR_SUCCESS)
    {
        pcomp->fDirty = FALSE; //Since we are saving in the registry, reset this!
        //
        // Write out the source string and Friendly name string.
        //
        RegSetValueEx(hkeySub, REG_VAL_COMP_SOURCE, 0, REG_SZ, (LPBYTE)pcomp->szSource, (lstrlen(pcomp->szSource)+1)*sizeof(TCHAR));
        RegSetValueEx(hkeySub, REG_VAL_COMP_SUBSCRIBED_URL, 0, REG_SZ, (LPBYTE)pcomp->szSubscribedURL, (lstrlen(pcomp->szSubscribedURL)+1)*sizeof(TCHAR));
        RegSetValueEx(hkeySub, REG_VAL_COMP_NAME, 0, REG_SZ, (LPBYTE)pcomp->szFriendlyName, (lstrlen(pcomp->szFriendlyName)+1)*sizeof(TCHAR));

        //
        // Compute and write out flags.
        //
        DWORD dwFlags = 0;
        dwFlags |= pcomp->iComponentType;
        if (pcomp->fChecked)
        {
            dwFlags |= COMP_SELECTED;
        }
        if (pcomp->fNoScroll)
        {
            dwFlags |= COMP_NOSCROLL;
        }
        RegSetValueEx(hkeySub, REG_VAL_COMP_FLAGS, 0, REG_DWORD, (LPBYTE)&dwFlags, sizeof(dwFlags));

        //
        // Write out the position.
        //
        RegSetValueEx(hkeySub, REG_VAL_COMP_POSITION, 0, REG_BINARY, (LPBYTE)&pcomp->cpPos, sizeof(pcomp->cpPos));

        //  Write out the Current state
        RegSetValueEx(hkeySub, REG_VAL_COMP_CURSTATE, 0, REG_DWORD, (LPBYTE)&pcomp->dwCurItemState, sizeof(pcomp->dwCurItemState));

        //  Write out the Original State Info
        RegSetValueEx(hkeySub, REG_VAL_COMP_ORIGINALSTATEINFO, 0, REG_BINARY, (LPBYTE)&pcomp->csiOriginal, sizeof(pcomp->csiOriginal));
        
        //  Write out the Restored State Info
        RegSetValueEx(hkeySub, REG_VAL_COMP_RESTOREDSTATEINFO, 0, REG_BINARY, (LPBYTE)&pcomp->csiRestored, sizeof(pcomp->csiRestored));

        RegCloseKey(hkeySub);
    }

    EXITPROC(2, "DS SaveComponent!");
}


void CActiveDesktop::_SaveComponents(void)
{
    ENTERPROC(2, "DS SaveComponents");
    DWORD dwFlags = 0, dwDataLength = sizeof(dwFlags);
    int i;
    TCHAR lpszDeskcomp[MAX_PATH];

    GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_COMPONENTS, _pszScheme);

    //
    // We need to preserve the old GENFLAGS, so read them now before we roach them.
    //
    SHGetValue(HKEY_CURRENT_USER, lpszDeskcomp, REG_VAL_COMP_GENFLAGS, NULL,
                            &dwFlags, &dwDataLength);

    //
    // Delete the entire registry key.
    //
    SHDeleteKey(HKEY_CURRENT_USER, lpszDeskcomp);

    //
    // Recreate the registry key.
    //
    HKEY hkey;
    if (RegCreateKey(HKEY_CURRENT_USER, lpszDeskcomp, &hkey) == ERROR_SUCCESS)
    {
        //
        // Write out the version number.
        //
        DWORD dw = CUR_DESKHTML_VERSION;
        RegSetValueEx(hkey, REG_VAL_COMP_VERSION, 0, REG_DWORD, (LPBYTE)(&dw), sizeof(dw));

        dw = CUR_DESKHTML_MINOR_VERSION;
        RegSetValueEx(hkey, REG_VAL_COMP_MINOR_VERSION, 0, REG_DWORD, (LPBYTE)(&dw), sizeof(dw));
    
        //
        // Write out the general settings.
        //
        DWORD dwSettings = 0;
        if (_co.fEnableComponents)
        {
            dwSettings |= COMPSETTING_ENABLE;
        }
        RegSetValueEx(hkey, REG_VAL_COMP_SETTINGS, 0, REG_DWORD, (LPBYTE)&dwSettings, sizeof(dwSettings));

        //
        // Write out the general flags
        //
        RegSetValueEx(hkey, REG_VAL_COMP_GENFLAGS, 0, REG_DWORD, (LPBYTE)&dwFlags, sizeof(dwFlags));

        if (_hdsaComponent)
        {
            //
            // Write out the settings for each component
            //
            for (i=0; i<DSA_GetItemCount(_hdsaComponent); i++)
            {
                COMPONENTA * pcomp;

                if (pcomp = (COMPONENTA *)DSA_GetItemPtr(_hdsaComponent, i))
                {
                    pcomp->dwID = i;
                    _SaveComponent(hkey, i, pcomp);
                }
            }
        }

        RegCloseKey(hkey);
    }

    EXITPROC(2, "DS SaveComponents");
}

void CActiveDesktop::_SavePattern(DWORD dwFlags)
{
    ENTERPROC(2, "DS SavePattern()");

    if (_fPatternDirty && (dwFlags & SAVE_PATTERN_NAME))
    {
        //
        // Write out the pattern to the registry and INI files.
        //
        SystemParametersInfo(SPI_SETDESKPATTERN, 0, _szSelectedPattern, SPIF_UPDATEINIFILE);
    }

    if (IsValidPattern(_szSelectedPattern) && (dwFlags & GENERATE_PATTERN_FILE))
    {
        //
        // Write out the pattern as a BMP file for use in HTML.
        //
        TCHAR szBitmapFile[MAX_PATH];
        HANDLE hFileBitmap = INVALID_HANDLE_VALUE;

        if (SUCCEEDED(GetPerUserFileName(szBitmapFile, ARRAYSIZE(szBitmapFile), PATTERN_FILENAME)))
        {
            hFileBitmap = CreateFile(szBitmapFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, NULL);
        }

        if (hFileBitmap != INVALID_HANDLE_VALUE)
        {
            DWORD cbWritten;

            BITMAPFILEHEADER bmfh = {0};
            bmfh.bfType = 0x4D42;   // 'BM'
            bmfh.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + 2*sizeof(RGBQUAD) + 8*sizeof(DWORD);
            bmfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + 2*sizeof(RGBQUAD);
            WriteFile(hFileBitmap, &bmfh, sizeof(bmfh), &cbWritten, NULL);

            BITMAPINFOHEADER bmih = {0};
            bmih.biSize = sizeof(BITMAPINFOHEADER);
            bmih.biWidth = 8;
            bmih.biHeight = 8;
            bmih.biPlanes = 1;
            bmih.biBitCount = 1;
            bmih.biCompression = BI_RGB;
            WriteFile(hFileBitmap, &bmih, sizeof(bmih), &cbWritten, NULL);

            RGBQUAD argbTable[2] = {0};
            DWORD rgb;
            rgb = GetSysColor(COLOR_BACKGROUND);
            argbTable[0].rgbBlue = GetBValue(rgb);
            argbTable[0].rgbGreen = GetGValue(rgb);
            argbTable[0].rgbRed = GetRValue(rgb);
            rgb = GetSysColor(COLOR_WINDOWTEXT);
            argbTable[1].rgbBlue = GetBValue(rgb);
            argbTable[1].rgbGreen = GetGValue(rgb);
            argbTable[1].rgbRed = GetRValue(rgb);
            WriteFile(hFileBitmap, argbTable, sizeof(argbTable), &cbWritten, NULL);

            DWORD adwBits[8];
            PatternToDwords(_szSelectedPattern, adwBits);
            WriteFile(hFileBitmap, adwBits, sizeof(adwBits), &cbWritten, NULL);

            CloseHandle(hFileBitmap);
        }
    }

    EXITPROC(2, "DS SavePattern!");
}

void CActiveDesktop::_WriteHtmlFromString(LPCTSTR psz)
{
    ENTERPROC(3, "DS WriteHtmlFromString(psz=>%s<)", psz);
    LPCWSTR  pwsz;
    WCHAR   szBuf[INTERNET_MAX_URL_LENGTH];
    UINT    uiLen;
    int     cch;

    if ((_pStream == NULL) && (_iDestFileCharset == ANSI_HTML_CHARSET))
    {
        cch = SHUnicodeToAnsi(psz, (LPSTR)szBuf, ARRAYSIZE(szBuf));
        ASSERT(cch == lstrlenW((LPWSTR)psz)+1);
        pwsz = (LPCWSTR)szBuf;
        uiLen = lstrlenA((LPSTR)szBuf);
    }
    else
    {
        pwsz = psz;
        uiLen = lstrlenW(pwsz);
    }

    UINT cbWritten;

    _WriteHtmlW(pwsz, uiLen, &cbWritten);
    
    EXITPROC(3, "DS WriteHtmlFromString!");
}

void CActiveDesktop::_WriteHtmlFromId(UINT uid)
{
    ENTERPROC(3, "DS WriteHtmlFromId(uid=%d)", uid);

    TCHAR szBuf[INTERNET_MAX_URL_LENGTH];
    LoadString(HINST_THISDLL, uid, szBuf, ARRAYSIZE(szBuf));
    _WriteHtmlFromString(szBuf);

    EXITPROC(3, "DS WriteHtmlFromId!");
}

void CActiveDesktop::_WriteHtmlFromIdF(UINT uid, ...)
{
    ENTERPROC(3, "DS WriteHtmlFromIdF(uid=%d,...)", uid);

    TCHAR szBufFmt[INTERNET_MAX_URL_LENGTH];
    TCHAR szBuf[INTERNET_MAX_URL_LENGTH];

    LoadString(HINST_THISDLL, uid, szBufFmt, ARRAYSIZE(szBufFmt));

    va_list arglist;
    va_start(arglist, uid);
    wvsprintf(szBuf, szBufFmt, arglist);
    va_end(arglist);

    _WriteHtmlFromString(szBuf);

    EXITPROC(3, "DS WriteHtmlFromIdF!");
}

void CActiveDesktop::_WriteHtmlFromFile(LPCTSTR pszContents)
{
    ENTERPROC(3, "DS WriteHtmlFromFile(pszContents=>%s<)", pszContents);
    
    CReadFileObj *pReadFileObj = new CReadFileObj(pszContents);

    if (pReadFileObj)
    {
        if (pReadFileObj->_hFile != INVALID_HANDLE_VALUE)
        {
            WCHAR wcBuf[INTERNET_MAX_URL_LENGTH + 1];
            UINT uiCharCount = ARRAYSIZE(wcBuf) -1; //Leave room for null termination.
            UINT uiCharsRead;
            UINT uiCharsConverted;
            int iDestCharset = (_pStream ? UNICODE_HTML_CHARSET : _iDestFileCharset);
            while (SUCCEEDED(pReadFileObj->FileReadAndConvertChars(iDestCharset, wcBuf, uiCharCount, &uiCharsRead, &uiCharsConverted)) && uiCharsRead)
            {
                UINT cbWritten;
            
                _WriteHtmlW(wcBuf, uiCharsConverted, &cbWritten);
            
                if (uiCharsRead < uiCharCount)
                {
                    break;
                }
            }
        }
        delete pReadFileObj;
    }
    
    EXITPROC(3, "DS WriteHtmlFromFile!");
}

void CActiveDesktop::_WriteHtmlFromReadFileObj(CReadFileObj *pFileObj, int iOffsetStart, int iOffsetEnd)
{
    ENTERPROC(3, "DS WriteHtmlFromReadFileObj(pFileObj=%08X,iOffsetStart=%d,iOffsetEnd=%d)", pFileObj, iOffsetStart, iOffsetEnd);

    if (iOffsetStart != -1)
    {
        pFileObj->FileSeekChars(iOffsetStart, FILE_BEGIN);
    }
    else
    {
        ASSERT(iOffsetEnd == -1);
        iOffsetEnd = -1;
    }

    //Get the number of WIDECHARs to be written
    UINT cchWrite = (iOffsetEnd == -1) ? 0xFFFFFFFF : (iOffsetEnd - iOffsetStart);

    while (cchWrite)
    {
        WCHAR wcBuf[INTERNET_MAX_URL_LENGTH+1];

        //
        // Read a chunk.
        //
        UINT cchTryRead = (UINT)min(cchWrite, (ARRAYSIZE(wcBuf) - 1));
        UINT cchActualRead;
        HRESULT hres;

        //Note: if we are reading ANSI, we still use the unicode buff; but cast it!
        if (_iDestFileCharset == ANSI_HTML_CHARSET)
            hres = pFileObj->FileReadCharsA((LPSTR)wcBuf, cchTryRead, &cchActualRead);
        else
            hres = pFileObj->FileReadCharsW(wcBuf, cchTryRead, &cchActualRead);
            
        if (SUCCEEDED(hres) && cchActualRead)
        {
            //
            // Write a chunk.
            //
            UINT cchWritten;
            
            _WriteHtmlW(wcBuf, cchActualRead, &cchWritten);
            
            if (cchActualRead < cchTryRead)
            {
                //
                // End of file, all done.
                //
                break;
            }

            cchWrite -= cchActualRead;
        }
        else
        {
            //
            // Error reading from file, all done.
            //
            break;
        }
    }

    EXITPROC(3, "DS WriteHtmlFromHfile!");
}

int CActiveDesktop::_ScanForTagA(CReadFileObj *pFileObj, int iOffsetStart, LPCSTR pszTag)
{
    ENTERPROC(2, "DS ScanForTagA(pFileObj=%08X,iOffsetStart=%d,pszTagA=>%s<)",
    pFileObj, iOffsetStart, pszTag);

    int iRet = -1;
    BOOL fDoneReading = FALSE;
    int iOffset;
    DWORD cchTag = lstrlenA(pszTag);

    pFileObj->FileSeekChars(iOffsetStart, FILE_BEGIN);
    iOffset = iOffsetStart;

    DWORD cchBuf = 0;
    while (!fDoneReading)
    {
        char szBuf[INTERNET_MAX_URL_LENGTH+1];

        //
        // Fill in the buffer.
        //
        UINT cchTryRead = ARRAYSIZE(szBuf) - cchBuf - 1;
        UINT cchRead;
        if (SUCCEEDED(pFileObj->FileReadCharsA(&szBuf[cchBuf], cchTryRead, &cchRead)) && cchRead)
        {
            cchBuf += cchRead;

            //
            // Terminate the string.
            //
            szBuf[cchBuf] = '\0';

            //
            // Scan for the tag.
            //
            LPSTR pszTagInBuf = StrStrIA(szBuf, pszTag);

            if (pszTagInBuf)
            {
                //
                // Found the tag, compute the offset.
                //
                iRet = (int) (iOffset + pszTagInBuf - szBuf);
                fDoneReading = TRUE;
            }
            else if (cchRead < cchTryRead)
            {
                //
                // Ran out of file without finding tag.
                //
                fDoneReading = TRUE;
            }
            else
            {
                //
                // Compute how many bytes we want to throw away
                // from this buffer so we can read in more data.
                // We don't want to throw away all the bytes because
                // the tag we want may span two buffers.
                //
                DWORD cchSkip = cchBuf - cchTag;

                //
                // Advance the file offset.
                //
                iOffset += cchSkip;

                //
                // Reduce the buffer size.
                //
                cchBuf -= cchSkip;

                //
                // Move the kept bytes to the beginning of the buffer.
                //
                MoveMemory(szBuf, szBuf + cchSkip, cchBuf);
            }
        }
        else
        {
            fDoneReading = TRUE;
        }
    }

    EXITPROC(2, "DS ScanForTagA=%d", iRet);
    return iRet;
}

int CActiveDesktop::_ScanForTagW(CReadFileObj *pFileObj, int iOffsetStart, LPCWSTR pwszTag)
{
    ENTERPROC(2, "DS ScanForTag(pFileObj=%08X,iOffsetStart=%d,pszTagA=>%s<)",
    pFileObj, iOffsetStart, pwszTag);

    int iRet = -1;
    BOOL fDoneReading = FALSE;
    int iOffset;
    DWORD cchTag = lstrlenW(pwszTag);

    pFileObj->FileSeekChars(iOffsetStart, FILE_BEGIN);
    iOffset = iOffsetStart;

    DWORD cchBuf = 0;
    while (!fDoneReading)
    {
        WCHAR wszBuf[INTERNET_MAX_URL_LENGTH+1];

        //
        // Fill in the buffer.
        //
        UINT cchTryRead = ARRAYSIZE(wszBuf) - cchBuf - 1;
        UINT cchRead;
        if (SUCCEEDED(pFileObj->FileReadCharsW(&wszBuf[cchBuf], cchTryRead, &cchRead)) && cchRead)
        {
            cchBuf += cchRead;

            //
            // Terminate the string.
            //
            wszBuf[cchBuf] = L'\0';

            //
            // Scan for the tag.
            //
            LPWSTR pwszTagInBuf = StrStrIW(wszBuf, pwszTag);

            if (pwszTagInBuf)
            {
                //
                // Found the tag, compute the offset.
                //
                iRet = (int) (iOffset + pwszTagInBuf - wszBuf);
                fDoneReading = TRUE;
            }
            else if (cchRead < cchTryRead)
            {
                //
                // Ran out of file without finding tag.
                //
                fDoneReading = TRUE;
            }
            else
            {
                //
                // Compute how many bytes we want to throw away
                // from this buffer so we can read in more data.
                // We don't want to throw away all the bytes because
                // the tag we want may span two buffers.
                //
                DWORD cchSkip = cchBuf - cchTag;

                //
                // Advance the file offset.
                //
                iOffset += cchSkip;

                //
                // Reduce the buffer size.
                //
                cchBuf -= cchSkip;

                //
                // Move the kept bytes to the beginning of the buffer.
                //
                MoveMemory(wszBuf, wszBuf + cchSkip, cchBuf*sizeof(WCHAR));
            }
        }
        else
        {
            fDoneReading = TRUE;
        }
    }

    EXITPROC(2, "DS ScanForTag=%d", iRet);
    return iRet;
}

int CActiveDesktop::_ScanTagEntriesA(CReadFileObj *pReadFileObj, int iOffsetStart, TAGENTRYA *pte, int cte)
{
    ENTERPROC(2, "DS ScanTagEntriesA(pReadFileObj=%08X,iOffsetStart=%d,pte=%08X,cte=%d)",
                pReadFileObj, iOffsetStart, pte, cte);

    int iRet = -1;
    int i;

    for (i=0; i<cte; i++,pte++)
    {
        iRet = _ScanForTagA(pReadFileObj, iOffsetStart, pte->pszTag);
        if (iRet != -1)
        {
            if (pte->fSkipPast)
            {
                iRet += lstrlenA(pte->pszTag);
            }
            break;
        }
    }

    EXITPROC(2, "DS ScanTagEntriesA=%d", iRet);
    return iRet;
}

int CActiveDesktop::_ScanTagEntriesW(CReadFileObj *pReadFileObj, int iOffsetStart, TAGENTRYW *pte, int cte)
{
    ENTERPROC(2, "DS ScanTagEntriesW(pReadFileObj=%08X,iOffsetStart=%d,pte=%08X,cte=%d)",
                pReadFileObj, iOffsetStart, pte, cte);

    int iRet = -1;
    int i;

    for (i=0; i<cte; i++,pte++)
    {
        iRet = _ScanForTagW(pReadFileObj, iOffsetStart, pte->pwszTag);
        if (iRet != -1)
        {
            if (pte->fSkipPast)
            {
                iRet += lstrlenW(pte->pwszTag);
            }
            break;
        }
    }

    EXITPROC(2, "DS ScanTagEntriesW=%d", iRet);
    return iRet;
}

void CActiveDesktop::_ParseAnsiInputHtmlFile( LPTSTR szSelectedWallpaper, int *piOffsetBase, int *piOffsetComp)
{
    //
    // Figure out where to insert the base href tag.
    //
    int     iOffsetBase = 0, iBaseTagStart;
    BOOL    fUseBaseHref;
    LONG    lOffsetDueToBOM = 0; //Character Offset due to the Byte Order Mark.
                                 //1 for UNICODE and 0 for ANSI files.

//  98/11/11 #248047 vtan: This code looks for a <BASE HREF=...> tag.
//  It used to use a scan for "<BASE" and assume that this was the
//  desired tag. HTML allows a "<BASEFONT>" tag which was being
//  mistaken for a "<BASE HREF=...>" tag. The code now looks for the
//  same string but looks at the character following the "<BASE" to
//  see if it's a white-space character.

    fUseBaseHref = TRUE;
    _pReadFileObjHtmlBkgd->FileGetCurCharOffset(&lOffsetDueToBOM);
    iOffsetBase = (int)lOffsetDueToBOM;
    iBaseTagStart = _ScanForTagA(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, "<BASE");
                
    if (iBaseTagStart != -1)
    {
        UINT   uiCountChars, uiTryToRead;
        char   szBaseTagBuffer[6+1];     // allow for "<BASEx" plus a NULL.

        _pReadFileObjHtmlBkgd->FileSeekChars(iBaseTagStart, FILE_BEGIN);
        uiTryToRead = ARRAYSIZE(szBaseTagBuffer) - 1;
        if (SUCCEEDED(_pReadFileObjHtmlBkgd->FileReadCharsA(szBaseTagBuffer, uiTryToRead, &uiCountChars)) && uiCountChars)
        {
            char    ch;

            ch = szBaseTagBuffer[5];
            fUseBaseHref = ((ch != ' ') &&
                            (ch != '\r') &&
                            (ch != '\n') &&      // this covers the UNIX line break scheme
                            (ch != '\t'));
        }
    }
    if (fUseBaseHref)
    {
        TAGENTRYA rgteBase[] = {
                                   { "<HEAD>", TRUE, },
                                   { "<BODY", FALSE, },
                                   { "<HTML>", TRUE, },
                               };
        iOffsetBase = _ScanTagEntriesA(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, rgteBase, ARRAYSIZE(rgteBase));
        if (iOffsetBase == -1)
        {
            iOffsetBase = (int)lOffsetDueToBOM;
        }
    }

    //
    // Figure out where to insert the components.
    //
    TAGENTRYA rgteComponents[] = {
                                     { "</BODY>", FALSE, },
                                     { "</HTML>", FALSE, },
                                 };
    int iOffsetComponents = _ScanTagEntriesA(_pReadFileObjHtmlBkgd, iOffsetBase, rgteComponents, ARRAYSIZE(rgteComponents));

    //
    // Write out the initial HTML up to the <HEAD> tag.
    //
    _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, iOffsetBase);

    //
    // Write out the base tag.
    //
    if (fUseBaseHref)
    {
        //BASE tag must point to the base "URL". So, don't strip out the filename.
        _WriteHtmlFromIdF(IDS_BASE_TAG, szSelectedWallpaper);
    }

    // Figure out where to insert the DIV clause
    TAGENTRYA rgteBodyStart[] = {
                                    { "<BODY", FALSE, },
                                };
    int iOffsetBodyStart = _ScanTagEntriesA(_pReadFileObjHtmlBkgd, iOffsetBase, rgteBodyStart, ARRAYSIZE(rgteBodyStart));
    // Write out HTML until after the <BODY ......>
    if (iOffsetBodyStart == -1)
    {   // the <BODY> tag is not found, so we need to insert it.
        // Copy over stuff until </HEAD>
        TAGENTRYA rgteHeadEnd[] = {
                                      { "</HEAD>", TRUE, },
                                  };
        int iOffsetHeadEnd = _ScanTagEntriesA(_pReadFileObjHtmlBkgd, iOffsetBase, rgteHeadEnd, ARRAYSIZE(rgteHeadEnd));
        if (iOffsetHeadEnd != -1)
        {
            _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, iOffsetBase, iOffsetHeadEnd);
            iOffsetBase = iOffsetHeadEnd;
        }
        _WriteHtmlFromIdF(IDS_BODY_CENTER_WP2); // "<BODY>"
        _fNeedBodyEnd = TRUE;
    }
    else
    {
        TAGENTRYA rgteBodyEnd[] = {
                                       { ">", TRUE, },
                                  };
        int iOffsetBodyEnd = _ScanTagEntriesA(_pReadFileObjHtmlBkgd, iOffsetBodyStart, rgteBodyEnd, ARRAYSIZE(rgteBodyEnd));
        if (iOffsetBodyEnd == -1)
        {   // An error in the HTML.
            iOffsetBodyEnd = iOffsetBodyStart;  // FEATURE: We need a better recovery idea.
        }
        _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, iOffsetBase, iOffsetBodyEnd);
        iOffsetBase = iOffsetBodyEnd;
    }

    *piOffsetBase = iOffsetBase;
    *piOffsetComp = iOffsetComponents;
}

void CActiveDesktop::_GenerateHtmlHeader(void)
{
    ENTERPROC(2, "DS GenerateHtmlHeader()");

    EnumMonitorsArea ema;
    GetMonitorSettings(&ema);

    RECT rcViewAreas[LV_MAX_WORKAREAS];  // WorkArea minus toolbar/tray areas
    int nViewAreas = ARRAYSIZE(rcViewAreas);
    // Get the ViewAreas
    if (!GetViewAreas(rcViewAreas, &nViewAreas))
    {
        nViewAreas = 0;
    }

    //Assume that the final Deskstat.htt that we generate is going to be in UNICODE.
    //This will change to ANSI only if the background html wallpaper is ANSI (determined later)
    _iDestFileCharset = UNICODE_HTML_CHARSET;
    //
    // Write out the background and color.
    //
    TCHAR szSelectedWallpaper[INTERNET_MAX_URL_LENGTH];
    // If the wallpaper does not have a directory specified (this may happen if other apps. change this value),
    // we have to figure it out.
    GetWallpaperWithPath(_szSelectedWallpaper, szSelectedWallpaper, ARRAYSIZE(szSelectedWallpaper));
    
    BOOL fValidWallpaper = GetFileAttributes(szSelectedWallpaper) != 0xFFFFFFFF;
    if (_fSingleItem || IsWallpaperPicture(szSelectedWallpaper) || !fValidWallpaper)
    {
        //
        //  Write the BOM for UNICODE
        //
        if (_hFileHtml)
        {
            DWORD cbWritten;
            
            WriteFile(_hFileHtml, (LPCSTR)&wUnicodeBOM, sizeof(wUnicodeBOM), &cbWritten, NULL);
        }
    
        // To account for the vagaries of the desktop browser (it's TopLeft starts from the TopLeft
        // of the Desktop ViewArea instead of the TopLeft of the monitor, as might be expected)
        // which happens only in the case of one active monitor systems, we add the width of the
        // tray/toolbars to the co-ordinates of the DIV section of each monitor's wallpaper.
        int iLeft, iTop;
        if (nViewAreas == 1)
        {
            iLeft = rcViewAreas[0].left - ema.rcVirtualMonitor.left;
            iTop = rcViewAreas[0].top - ema.rcVirtualMonitor.top;
        }
        else
        {
            iLeft = 0;
            iTop = 0;
        }

        //
        // Write out the standard header.
        //
        UINT i;
        for (i=IDS_COMMENT_BEGIN; i<IDS_BODY_BEGIN; i++)
        {
            _WriteHtmlFromIdF(i);
        }

        //
        // Write out the body tag, with background bitmap.
        //
        DWORD rgbDesk;
        rgbDesk = GetSysColor(COLOR_DESKTOP);

        TCHAR szBitmapFile[MAX_PATH];
        if (FAILED(GetPerUserFileName(szBitmapFile, ARRAYSIZE(szBitmapFile), PATTERN_FILENAME)))
        {
            szBitmapFile[0] = 0;
        }

        if (!_fSingleItem && _szSelectedWallpaper[0] && fValidWallpaper)
        {
            TCHAR szWallpaperUrl[INTERNET_MAX_URL_LENGTH];
            DWORD cch = ARRAYSIZE(szWallpaperUrl);
            UrlCreateFromPath(szSelectedWallpaper, szWallpaperUrl, &cch, URL_INTERNAL_PATH);

            switch (_wpo.dwStyle)
            {
                case WPSTYLE_TILE:
                    //
                    // Ignore the pattern, tile the wallpaper as background.
                    //
                    _WriteHtmlFromIdF(IDS_BODY_BEGIN2, szWallpaperUrl, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
                    break;

                case WPSTYLE_CENTER:
                    if (IsValidPattern(_szSelectedPattern))
                    {
                        //
                        // Tile the pattern as the main background.
                        //
                        _WriteHtmlFromIdF(IDS_BODY_BEGIN2, szBitmapFile, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
                        if (_fBackgroundHtml)   // We are generating the HTML for preview
                        {
                            _WriteHtmlFromIdF(IDS_BODY_PATTERN_AND_WP, szWallpaperUrl);
                        }
                        else
                        {
                            //
                            // Write out a DIV section for a centered, untiled wallpaper.
                            //
                            // write it out for each monitor.
                            for(int i = 0; i < ema.iMonitors; i++)
                            {
                                _WriteHtmlFromIdF(IDS_BODY_PATTERN_AND_WP2,
                                            ema.rcMonitor[i].left - ema.rcVirtualMonitor.left - iLeft,
                                            ema.rcMonitor[i].top - ema.rcVirtualMonitor.top - iTop,
                                            ema.rcMonitor[i].right - ema.rcMonitor[i].left,
                                            ema.rcMonitor[i].bottom - ema.rcMonitor[i].top,
                                            szWallpaperUrl);
                            }
                        }
                    }
                    else
                    {
                        //
                        // Write out a non-tiled, centered wallpaper as background.
                        //
                        if (_fBackgroundHtml)   // We are generating the HTML for preview
                        {
                            _WriteHtmlFromIdF(IDS_BODY_CENTER_WP, szWallpaperUrl, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
                        }
                        else
                        {
                            _WriteHtmlFromIdF(IDS_BODY_CENTER_WP2, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
                            // write it out for each monitor.
                            for(int i = 0; i < ema.iMonitors; i++)
                            {
                                _WriteHtmlFromIdF(IDS_BODY_PATTERN_AND_WP2,
                                                    ema.rcMonitor[i].left - ema.rcVirtualMonitor.left - iLeft,
                                                    ema.rcMonitor[i].top - ema.rcVirtualMonitor.top - iTop,
                                                    ema.rcMonitor[i].right - ema.rcMonitor[i].left,
                                                    ema.rcMonitor[i].bottom - ema.rcMonitor[i].top,
                                                    szWallpaperUrl);
                            }
                        }
                    }
                    break;

                case WPSTYLE_STRETCH:
                    //
                    // Ignore the pattern, create a DIV section of the wallpaper
                    // stretched to 100% of the screen.
                    //
                    _WriteHtmlFromIdF(IDS_BODY_BEGIN2, c_szNULL, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
                    if (_fBackgroundHtml)   // We are generating the HTML for preview
                    {
                        _WriteHtmlFromIdF(IDS_STRETCH_WALLPAPER, szWallpaperUrl);
                    }
                    else
                    {
                        // stretch it for each monitor.
                        for(int i = 0; i < ema.iMonitors; i++)
                        {
                            _WriteHtmlFromIdF(IDS_DIV_START3, ema.rcMonitor[i].left - ema.rcVirtualMonitor.left - iLeft,
                                                ema.rcMonitor[i].top - ema.rcVirtualMonitor.top - iTop,
                                                ema.rcMonitor[i].right - ema.rcMonitor[i].left,
                                                ema.rcMonitor[i].bottom - ema.rcMonitor[i].top);
                            _WriteHtmlFromIdF(IDS_STRETCH_WALLPAPER, szWallpaperUrl);
                            _WriteHtmlFromId(IDS_DIV_END);
                        }
                    }
                    break;
            }
        }
        else
        {
            //
            // Ignore the wallpaper, generate either a tiled pattern
            // or solid color background.
            //
            _WriteHtmlFromIdF(IDS_BODY_BEGIN2, !_fSingleItem && IsValidPattern(_szSelectedPattern) ? szBitmapFile : c_szNULL, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
        }
    }
    else
    {
        if ((_pReadFileObjHtmlBkgd = new CReadFileObj(szSelectedWallpaper)) &&
            (_pReadFileObjHtmlBkgd->_hFile != INVALID_HANDLE_VALUE))
        {
            //The final Desktop.htt will be in ANSI only if the source html file is also in ansi.
            //So, get the type from the selected wallpaper object.
            _iDestFileCharset = _pReadFileObjHtmlBkgd->_iCharset;
            //
            //  Write the BOM for UNICODE
            //
            if (_hFileHtml && (_iDestFileCharset == UNICODE_HTML_CHARSET))
            {
                DWORD cbWritten;
            
                WriteFile(_hFileHtml, (LPCSTR)&wUnicodeBOM, sizeof(wUnicodeBOM), &cbWritten, NULL);
            }
    
            //
            // Figure out where to insert the base href tag.
            //
            int     iOffsetBase = 0;
            int     iOffsetComponents;
//  98/11/11 #248047 vtan: This code looks for a <BASE HREF=...> tag.
//  It used to use a scan for "<BASE" and assume that this was the
//  desired tag. HTML allows a "<BASEFONT>" tag which was being
//  mistaken for a "<BASE HREF=...>" tag. The code now looks for the
//  same string but looks at the character following the "<BASE" to
//  see if it's a white-space character.

            if (_iDestFileCharset == ANSI_HTML_CHARSET)
            {
                //The following function parses the ANSI input html file and finds various offsets
                _ParseAnsiInputHtmlFile(szSelectedWallpaper, &iOffsetBase, &iOffsetComponents);
            }
            else
            {
                //The following code parses the UNICODE input html wallpaper file.
                int iBaseTagStart;
                BOOL    fUseBaseHref;
                LONG    lOffsetDueToBOM = 0; //Character Offset due to the Byte Order Mark.
                                         //1 for UNICODE and 0 for ANSI files.
                fUseBaseHref = TRUE;
                _pReadFileObjHtmlBkgd->FileGetCurCharOffset(&lOffsetDueToBOM);
                iOffsetBase = (int)lOffsetDueToBOM;
                iBaseTagStart = _ScanForTagW(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, L"<BASE");
                
                if (iBaseTagStart != -1)
                {
                    UINT   uiCountChars, uiTryToRead;
                    WCHAR  wszBaseTagBuffer[6+1];     // allow for "<BASEx" plus a NULL.

                    _pReadFileObjHtmlBkgd->FileSeekChars(iBaseTagStart, FILE_BEGIN);
                    uiTryToRead = ARRAYSIZE(wszBaseTagBuffer) - 1;
                    if (SUCCEEDED(_pReadFileObjHtmlBkgd->FileReadCharsW(wszBaseTagBuffer, uiTryToRead, &uiCountChars)) && uiCountChars)
                    {
                        WCHAR    wc;

                        wc = wszBaseTagBuffer[5];
                        fUseBaseHref = ((wc != L' ') &&
                                        (wc != L'\r') &&
                                        (wc != L'\n') &&      // this covers the UNIX line break scheme
                                        (wc != L'\t'));
                    }
                }
                if (fUseBaseHref)
                {
                    TAGENTRYW rgteBase[] = {
                                            { L"<HEAD>", TRUE, },
                                            { L"<BODY", FALSE, },
                                            { L"<HTML>", TRUE, },
                                           };
                    iOffsetBase = _ScanTagEntriesW(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, rgteBase, ARRAYSIZE(rgteBase));
                    if (iOffsetBase == -1)
                    {
                        iOffsetBase = (int)lOffsetDueToBOM;
                    }
                }

                //
                // Figure out where to insert the components.
                //
                TAGENTRYW rgteComponents[] = {
                                                { L"</BODY>", FALSE, },
                                                { L"</HTML>", FALSE, },
                                             };
                iOffsetComponents = _ScanTagEntriesW(_pReadFileObjHtmlBkgd, iOffsetBase, rgteComponents, ARRAYSIZE(rgteComponents));

                //
                // Write out the initial HTML up to the <HEAD> tag.
                //
                _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, iOffsetBase);

                //
                // Write out the base tag.
                //
                if (fUseBaseHref)
                {
                    //BASE tag must point to the base "URL". So, don't strip out the filename.
                    _WriteHtmlFromIdF(IDS_BASE_TAG, szSelectedWallpaper);
                }

                // Figure out where to insert the DIV clause
                TAGENTRYW rgteBodyStart[] = {
                                                { L"<BODY", FALSE, },
                                            };
                int iOffsetBodyStart = _ScanTagEntriesW(_pReadFileObjHtmlBkgd, iOffsetBase, rgteBodyStart, ARRAYSIZE(rgteBodyStart));
                // Write out HTML until after the <BODY ......>
                if (iOffsetBodyStart == -1)
                {   // the <BODY> tag is not found, so we need to insert it.
                    // Copy over stuff until </HEAD>
                    TAGENTRYW rgteHeadEnd[] = {
                                                { L"</HEAD>", TRUE, },
                                              };
                    int iOffsetHeadEnd = _ScanTagEntriesW(_pReadFileObjHtmlBkgd, iOffsetBase, rgteHeadEnd, ARRAYSIZE(rgteHeadEnd));
                    if (iOffsetHeadEnd != -1)
                    {
                        _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, iOffsetBase, iOffsetHeadEnd);
                        iOffsetBase = iOffsetHeadEnd;
                    }
                    _WriteHtmlFromIdF(IDS_BODY_CENTER_WP2); // "<BODY>"
                    _fNeedBodyEnd = TRUE;
                }
                else
                {
                    TAGENTRYW rgteBodyEnd[] = {
                                                { L">", TRUE, },
                                              };
                    int iOffsetBodyEnd = _ScanTagEntriesW(_pReadFileObjHtmlBkgd, iOffsetBodyStart, rgteBodyEnd, ARRAYSIZE(rgteBodyEnd));
                    if (iOffsetBodyEnd == -1)
                    {   // An error in the HTML.
                        iOffsetBodyEnd = iOffsetBodyStart;  // FEATURE: We need a better recovery idea.
                    }
                    _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, iOffsetBase, iOffsetBodyEnd);
                    iOffsetBase = iOffsetBodyEnd;
                }

            }
            // Insert the DIV clause
            if (ema.iMonitors > 1)
            {
                int         iIndexPrimaryMonitor;
                HMONITOR    hMonitorPrimary;
                MONITORINFO monitorInfo;

                // 99/03/23 #275429 vtan: We used GetViewAreas() to fill in rcViewAreas above.
                // The code here used to assume that [0] ALWAYS referred to the primary monitor.
                // This isn't the case if the monitor settings are changed without a restart.
                // In order to compensate for this and always render the wallpaper into the
                // primary monitor, a search is performed to find a (left, top) that matches
                // one of the work areas and this is used as the primary monitor. If none can
                // be found then default to the old algorithm.

                hMonitorPrimary = GetPrimaryMonitor();
                monitorInfo.cbSize = sizeof(monitorInfo);
                TBOOL(GetMonitorInfo(hMonitorPrimary, &monitorInfo));
                iIndexPrimaryMonitor = -1;
                for (int i = 0; (iIndexPrimaryMonitor < 0) && (i < nViewAreas); ++i)
                {
                    if ((monitorInfo.rcWork.left == rcViewAreas[i].left) && (monitorInfo.rcWork.top == rcViewAreas[i].top))
                    {
                        iIndexPrimaryMonitor = i;
                    }
                }
                if (iIndexPrimaryMonitor < 0)
                    iIndexPrimaryMonitor = 0;
                if ((nViewAreas <= 0) || (rcViewAreas[iIndexPrimaryMonitor].right == rcViewAreas[iIndexPrimaryMonitor].left))
                // The second case could occur on bootup
                {
                    // Some error occured when getting the ViewAreas. Recover from the error by using the workarea.
                    // Get the workarea of the primary monitor, since HTML wallpapers are displayed only there.
                    GetMonitorWorkArea(hMonitorPrimary, &rcViewAreas[iIndexPrimaryMonitor]);
                }
                _WriteHtmlFromIdF(IDS_DIV_START3,
                                  rcViewAreas[iIndexPrimaryMonitor].left - ema.rcVirtualMonitor.left,
                                  rcViewAreas[iIndexPrimaryMonitor].top - ema.rcVirtualMonitor.top,
                                  rcViewAreas[iIndexPrimaryMonitor].right - rcViewAreas[iIndexPrimaryMonitor].left,
                                  rcViewAreas[iIndexPrimaryMonitor].bottom - rcViewAreas[iIndexPrimaryMonitor].top);
            }

            //
            // Write out HTML from after <HEAD> tag to just before </BODY> tag.
            //
            _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, iOffsetBase, iOffsetComponents);

            if (ema.iMonitors > 1)
            {
                _WriteHtmlFromId(IDS_DIV_END);
            }
        }
        else
        {
            if (_pReadFileObjHtmlBkgd)
                delete _pReadFileObjHtmlBkgd;
            _pReadFileObjHtmlBkgd = NULL;
        }
    }

    EXITPROC(2, "DS GenerateHtmlHeader!");
}

void CActiveDesktop::_WriteResizeable(COMPONENTA *pcomp)
{
    TCHAR   szResizeable[3];

    szResizeable[0] = TEXT('\0');

    //If Resize is set, then the comp is resizeable in both X and Y directions!
    if (pcomp->cpPos.fCanResize)
        lstrcat(szResizeable, TEXT("XY"));
    else
    {
        if (pcomp->cpPos.fCanResizeX)
            lstrcat(szResizeable, TEXT("X"));

        if (pcomp->cpPos.fCanResizeY)
            lstrcat(szResizeable, TEXT("Y"));
    }

    _WriteHtmlFromIdF(IDS_RESIZEABLE, szResizeable);
}

void CActiveDesktop::_WriteHtmlW(LPCWSTR wcBuf, UINT cchToWrite, UINT *pcchWritten)
{
    ULONG    cchWritten = 0;
    UINT     uiSize;
    
    if (_pStream)
    {
        uiSize = sizeof(WCHAR);
        _pStream->Write((LPVOID)wcBuf, cchToWrite * uiSize, &cchWritten);
    }
    else
    {
        ASSERT(_hFileHtml);
        uiSize = (_iDestFileCharset == ANSI_HTML_CHARSET) ? sizeof(char) : sizeof(WCHAR);
        WriteFile(_hFileHtml, (LPCVOID)wcBuf, cchToWrite * uiSize, &cchWritten, NULL);
    }
    *pcchWritten = (UINT)(cchWritten/uiSize);  //Convert to number of chars.
}

void CActiveDesktop::_GenerateHtmlPicture(COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS GenerateHtmlPicture(pcomp=%08X)");

    //
    // Write out the image src HTML.
    //
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD cch=ARRAYSIZE(szUrl);
    if (FAILED(UrlCreateFromPath(pcomp->szSource, szUrl, &cch, 0)))
    {
        lstrcpy(szUrl, pcomp->szSource);
    }
    _WriteHtmlFromIdF(IDS_IMAGE_BEGIN2, pcomp->dwID, szUrl);

    //
    // Write out whether this image is resizeable or not!
    //
    _WriteResizeable(pcomp);

    //
    // Write out the URL that must be used for subscription purposes.
    //
    _WriteHtmlFromIdF(IDS_SUBSCRIBEDURL, pcomp->szSubscribedURL);

    //
    // Write out the image location HTML.
    //
    if ((pcomp->cpPos.dwWidth == COMPONENT_DEFAULT_WIDTH) &&
        (pcomp->cpPos.dwHeight == COMPONENT_DEFAULT_HEIGHT))
    {
        _WriteHtmlFromIdF(IDS_IMAGE_LOCATION, _fSingleItem ? 0 : pcomp->cpPos.iLeft, _fSingleItem ? 0 : pcomp->cpPos.iTop, pcomp->cpPos.izIndex);
    }
    else
    {
        _WriteHtmlFromIdF(IDS_IMAGE_SIZE, _fSingleItem ? 0 : pcomp->cpPos.iLeft, _fSingleItem ? 0 : pcomp->cpPos.iTop,
                            pcomp->cpPos.dwWidth, pcomp->cpPos.dwHeight, pcomp->cpPos.izIndex);
    }

    EXITPROC(2, "DS GenerateHtmlPicture!");
}

void CActiveDesktop::_GenerateHtmlDoc(COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS GenerateHtmlDoc(pcomp=%08X)");
    
    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD   dwSize = ARRAYSIZE(szUrl);
    LPTSTR  lpszUrl = szUrl;

    if (FAILED(UrlCreateFromPath(pcomp->szSource, szUrl, &dwSize, 0)))
        lpszUrl = pcomp->szSource;

    //
    // Write out the DIV header HTML.
    //
    _WriteHtmlFromIdF(IDS_DIV_START2, pcomp->dwID, lpszUrl);

    //
    // Write out whether this component is resizeable or not!
    //
    _WriteResizeable(pcomp);

    //
    // Write out the DIV location HTML.
    //
    _WriteHtmlFromIdF(IDS_DIV_SIZE, pcomp->cpPos.dwHeight, _fSingleItem ? 0 : pcomp->cpPos.iLeft,
        _fSingleItem ? 0 : pcomp->cpPos.iTop, pcomp->cpPos.dwWidth, pcomp->cpPos.izIndex);

    //
    // Extract the doc contents directly into the HTML.
    //
    _WriteHtmlFromFile(pcomp->szSource);

    //
    // Close the DIV section.
    //
    _WriteHtmlFromId(IDS_DIV_END);

    EXITPROC(2, "DS GenerateHtmlDoc!");
}

void CActiveDesktop::_GenerateHtmlSite(COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS GenerateHtmlSite(pcomp=%08X)");

    //
    // Write out the frame src HTML.
    //
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD cch=ARRAYSIZE(szUrl);
    if (FAILED(UrlCreateFromPath(pcomp->szSource, szUrl, &cch, 0)))
    {
        lstrcpy(szUrl, pcomp->szSource);
    }

    DWORD   currentURLLength, maximumURLLength;
    TCHAR   *pURL, formatBuffer[0x0100];

//  98/09/29 #211384 vtan: There is a limitation in wvsprintf.
//  It only allows 2048 bytes in its buffer. If the URL is
//  longer than 1024 characters less the IDS_IFRAME_BEGIN2
//  string length less the component ID less "scrolling=no"
//  if the component cannot be scrolled then the URL string
//  will not be correctly inserted into the IDS_IFRAME_BEGIN2
//  string and there will be a missing end-quote and trident
//  will fail to render desktop.htt correctly.

//  To correct against this the followING limits the length of
//  the URL to this maximum and truncates any characters
//  beyond the limit so that the IDS_IFRAME_BEGIN2 string
//  contains its end-quote and trident does not barf.

//  The above condition is a boundary condition and this
//  check is quick so that the calculations that follow do
//  not have to be executed repeatedly.

    currentURLLength = lstrlen(szUrl);
    if (currentURLLength > 768)                                 // a hard-coded limit
    {
        maximumURLLength = 1024;                                // wvsprintf limit
        LoadString(HINST_THISDLL, IDS_IFRAME_BEGIN2, formatBuffer, ARRAYSIZE(formatBuffer));
        maximumURLLength -= lstrlen(formatBuffer);              // IDS_IFRAME_BEGIN2
        maximumURLLength -= 16;                                 // pcomp->dwID
        maximumURLLength -= lstrlen(TEXT("scrolling=no"));      // pcomp->fNoScroll
        if (currentURLLength > maximumURLLength)
            szUrl[maximumURLLength] = static_cast<TCHAR>('\0');
    }
    _WriteHtmlFromIdF(IDS_IFRAME_BEGIN2, pcomp->dwID, szUrl, pcomp->fNoScroll ? TEXT("scrolling=no") : c_szNULL);

    //
    // Write out whether this Component is resizeable or not!
    //
    _WriteResizeable(pcomp);

//  98/09/29 #211384 vtan: See above.

    currentURLLength = lstrlen(pcomp->szSubscribedURL);
    if (currentURLLength > 768)
    {
        lstrcpy(szUrl, pcomp->szSubscribedURL);
        maximumURLLength = 1024;
        LoadString(HINST_THISDLL, IDS_SUBSCRIBEDURL, formatBuffer, ARRAYSIZE(formatBuffer));
        maximumURLLength -= lstrlen(formatBuffer);              // IDS_SUBSCRIBEDURL
        if (currentURLLength > maximumURLLength)
            szUrl[maximumURLLength] = static_cast<TCHAR>('\0');
        pURL = szUrl;
    }
    else
        pURL = pcomp->szSubscribedURL;
    //
    // Write out the URL that must be used for subscription purposes.
    //
    _WriteHtmlFromIdF(IDS_SUBSCRIBEDURL, pURL);

    //
    // Write out the frame location HTML.
    //
    _WriteHtmlFromIdF(IDS_IFRAME_SIZE, _fSingleItem ? 0 : pcomp->cpPos.iLeft, _fSingleItem ? 0 : pcomp->cpPos.iTop,
        pcomp->cpPos.dwWidth, pcomp->cpPos.dwHeight, pcomp->cpPos.izIndex);

    EXITPROC(2, "DS GenerateHtmlSite!");
}

void CActiveDesktop::_GenerateHtmlControl(COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS GenerateHtmlControl(pcomp=%08X)");
    ASSERT(pcomp);
    
    // Did the Administrator restrict "Channel UI"?
    if (SHRestricted2W(REST_NoChannelUI, NULL, 0))
    {
        TCHAR szChannelOCGUID[GUIDSTR_MAX];

        SHStringFromGUID(CLSID_ChannelOC, szChannelOCGUID, ARRAYSIZE(szChannelOCGUID));
        if (!StrCmpNI(pcomp->szSource, &(szChannelOCGUID[1]), lstrlen(pcomp->szSource)-3))
        {
            // Yes, so we need to hide the Channel Desktop Component.
            // Return here before we generate it.
            return;
        }        
    }
    
    //
    // Write out the control HTML.
    //

    // First the control header
    _WriteHtmlFromIdF(IDS_CONTROL_1, pcomp->dwID);
    // then the size
    _WriteHtmlFromIdF(IDS_CONTROL_2, pcomp->cpPos.dwHeight, _fSingleItem ? 0 : pcomp->cpPos.iLeft,
        _fSingleItem ? 0 : pcomp->cpPos.iTop, pcomp->cpPos.dwWidth, pcomp->cpPos.izIndex);
    //
    // Write out whether this Control is resizeable or not!
    //
    _WriteResizeable(pcomp);

    // Finally the rest of the control
    _WriteHtmlFromIdF(IDS_CONTROL_3, pcomp->szSource);

    EXITPROC(2, "DS GenerateHtmlControl!");
}

void CActiveDesktop::_GenerateHtmlComponent(COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS GenerateHtmlComponent(pcomp=%08X)");

    switch(pcomp->iComponentType)
    {
        case COMP_TYPE_PICTURE:
            _GenerateHtmlPicture(pcomp);
            break;

        case COMP_TYPE_HTMLDOC:
            _GenerateHtmlDoc(pcomp);
            break;

        case COMP_TYPE_WEBSITE:
            _GenerateHtmlSite(pcomp);
            break;

        case COMP_TYPE_CONTROL:
            _GenerateHtmlControl(pcomp);
            break;
    }

    EXITPROC(2, "DS GenerateHtmlComponent!");
}

void CActiveDesktop::_GenerateHtmlFooter(void)
{
    ENTERPROC(2, "DS GenerateHtmlFooter()");

    //
    // Write out the deskmovr object.
    //
    if (!_fNoDeskMovr)
    {
        TCHAR szDeskMovrFile[MAX_PATH];

        if (GetWindowsDirectory(szDeskMovrFile, ARRAYSIZE(szDeskMovrFile)) != 0)
        {
            lstrcat(szDeskMovrFile, DESKMOVR_FILENAME);
            _WriteHtmlFromFile(szDeskMovrFile);
        }
    }

    //
    // Write out the concluding HTML tags.
    //
    if (_pReadFileObjHtmlBkgd)
    {
        if (_fNeedBodyEnd)
        {    // We had introduced the <BODY> tag by ourselves.
            _WriteHtmlFromId(IDS_BODY_END2);
            _fNeedBodyEnd = FALSE;
        }
        _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, -1, -1);
        delete _pReadFileObjHtmlBkgd;   //Close the file and cleanup!
        _pReadFileObjHtmlBkgd = NULL;
    }
    else
    {
        _WriteHtmlFromId(IDS_BODY_END);
    }

    EXITPROC(2, "DS GenerateHtmlFooter!");
}

void CActiveDesktop::_GenerateHtml(void)
{
    ENTERPROC(2, "DS GenerateHtml()");

    TCHAR szHtmlFile[MAX_PATH];

    //
    // Compute the filename.
    //
    szHtmlFile[0] = TEXT('\0');

    if (SUCCEEDED(GetPerUserFileName(szHtmlFile, ARRAYSIZE(szHtmlFile), DESKTOPHTML_FILENAME)))
    {
        // Recreate the file.
        _hFileHtml = CreateFile(szHtmlFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, NULL);
        if (_hFileHtml != INVALID_HANDLE_VALUE)
        {
            _GenerateHtmlHeader();

            if (_co.fEnableComponents && _hdsaComponent && DSA_GetItemCount(_hdsaComponent) &&
                !SHRestricted(REST_NODESKCOMP))
            {
                int i;

                for (i=0; i<DSA_GetItemCount(_hdsaComponent); i++)
                {
                    COMPONENTA comp;
                    comp.dwSize = sizeof(COMPONENTA);

                    if ((DSA_GetItem(_hdsaComponent, i, &comp) != -1) && (comp.fChecked))
                    {
                        _GenerateHtmlComponent(&comp);
                    }
                }
            }

            _GenerateHtmlFooter();
            CloseHandle(_hFileHtml);
            SetDesktopFlags(COMPONENTS_DIRTY, 0);
        }
        else
        {

            // 99/05/19 #340772 vtan: If unable to open desktop.htt it's probably
            // in use by another process or task (perhaps trident is trying to
            // render it). In this case mark it dirty so that it will get recreated
            // - yet again but this time with more current data.

            SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);
        }
    }

    EXITPROC(2, "DS GenerateHtml!");
}

HRESULT CActiveDesktop::GenerateDesktopItemHtml(LPCWSTR pwszFileName, COMPONENT *pcomp, DWORD dwReserved)
{
    HRESULT hres = E_FAIL;
    ENTERPROC(2, "DS GenerateComponentHtml(pcomp=%08X)", pcomp);
    LPTSTR  pszFileName;

    //Check for the input parameters
    if (!pwszFileName || (pcomp && (pcomp->dwSize != sizeof(*pcomp)) && (pcomp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    ASSERT(!dwReserved);     // These should be 0

    pszFileName = (LPTSTR)pwszFileName;

    //
    // Create the file.
    //
    _hFileHtml = CreateFile(pszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL, NULL);
    if (_hFileHtml != INVALID_HANDLE_VALUE)
    {
        _fNoDeskMovr = TRUE;
        _fBackgroundHtml = TRUE;
        //Check if we need to add a component
        if (pcomp)
        {
            COMPONENTA  CompA;

            CompA.dwSize = sizeof(CompA);
            WideCompToMultiComp(pcomp, &CompA);

            _fSingleItem = TRUE;
            _GenerateHtmlHeader();

            _GenerateHtmlComponent(&CompA);
            _GenerateHtmlFooter();
            _fSingleItem = FALSE;
        }
        else
        {
            //generate just the header and the footer with proper
            // wallpaper and pattern info!
            _GenerateHtmlHeader();
            _GenerateHtmlFooter();
        }
        _fBackgroundHtml = FALSE;
        _fNoDeskMovr = FALSE;

        CloseHandle(_hFileHtml);

        hres = S_OK;
    }
    _hFileHtml = NULL;

    EXITPROC(2, "DS GenerateComponentHtml=%d", hres);
    return hres;
}

//
// AddUrl
//
//

HRESULT CActiveDesktop::AddUrl(HWND hwnd, LPCWSTR pszSourceW, LPCOMPONENT pcomp, DWORD dwFlags)
{
    LPTSTR pszExt;
    HRESULT fOkay = TRUE;
    BOOL fExtIsCdf,fPathIsUrl;
    BOOL fSubscribed = FALSE;
    COMPONENT   compLocal;
    COMPONENTA  compA;
    TCHAR szSource[INTERNET_MAX_URL_LENGTH];

//  98/08/28 vtan #202777: The following if statement sanitizes parameters
//  passed to AddUrl(). The statements following the "||" are executed
//  despite the for pcomp against NULL. This causes an access violation
//  and an exception to be thrown.

#if     0
    //Check for the input parameters.
    if (!pszSourceW || (pcomp &&
       ((pcomp->dwSize != sizeof(*pcomp)) && (pcomp->dwSize != sizeof(IE4COMPONENT))) ||
       ((pcomp->dwSize == sizeof(*pcomp)) && !VALIDATESTATE(pcomp->dwCurItemState))))
        return E_INVALIDARG;
#else

//  The following performs the same comparison but is spread into three
//  separate comparisons. As performance is not a critical issue here
//  but correctness is this makes the tests clear and understandable.
//  The invalid conditions are described.

//  Validate input parameters. Invalid parameters are:
//      1) NULL pszSourceW
//      2) pcomp->dwSize for a COMPONENT struct but invalid pcomp->dwCurItemState
//      3) pcomp->dwSize is not for a COMPONENT struct nor for a IE4COMPONENT struct

    if (pszSourceW == NULL)
        return(E_INVALIDARG);
    if (pcomp != NULL)
    {
        if ((pcomp->dwSize == sizeof(*pcomp)) && !VALIDATESTATE(pcomp->dwCurItemState))
            return(E_INVALIDARG);
        if ((pcomp->dwSize != sizeof(*pcomp)) && (pcomp->dwSize != sizeof(IE4COMPONENT)))
            return(E_INVALIDARG);
    }
#endif

    // Catch folks that call our API's to add components and prevent them from doing
    // so if the restriction is in place.
    if (SHIsRestricted(NULL, REST_NOADDDESKCOMP))
        return E_ACCESSDENIED;

    if (!pcomp)
    {
        pcomp = &compLocal;
        pcomp->dwSize = sizeof(compLocal);
        pcomp->dwCurItemState = IS_NORMAL;
    }

    // Attempt to come up with a reasonable window handle if none is passed in.  ParseDesktopComponent
    // will fail to attempt to create a subscription if a NULL window handle is passed in.
    if (!hwnd)
        hwnd = GetLastActivePopup(GetActiveWindow());

    compA.dwSize = sizeof(compA);
    compA.dwCurItemState = (pcomp->dwSize != sizeof(IE4COMPONENT)) ? pcomp->dwCurItemState : IS_NORMAL;

    SHUnicodeToTChar(pszSourceW, szSource, ARRAYSIZE(szSource));
    pszExt = PathFindExtension(szSource);
    fExtIsCdf = lstrcmpi(pszExt, TEXT(".CDF")) == 0;
    fPathIsUrl = PathIsURL(szSource) && !UrlIsFileUrl(szSource);

    if (FindComponent(szSource, (g_pActiveDesk ? g_pActiveDesk : this)))
    {
        if (dwFlags & ADDURL_SILENT)  
        {
            lstrcpy(compA.szSource, szSource);
            MultiCompToWideComp(&compA, pcomp);
            RemoveDesktopItem(pcomp, 0);
        }
        else  
        {
            // This is a long string. So,...
            TCHAR szMsg[512];
            TCHAR szMsg2[256];
            TCHAR szTitle[128];
            LoadString(HINST_THISDLL, IDS_COMP_EXISTS, szMsg, ARRAYSIZE(szMsg));
            LoadString(HINST_THISDLL, IDS_COMP_EXISTS_2, szMsg2, ARRAYSIZE(szMsg2));
            StrCatBuff(szMsg, szMsg2, ARRAYSIZE(szMsg));
            LoadString(HINST_THISDLL, IDS_COMP_TITLE, szTitle, ARRAYSIZE(szTitle));
            MessageBox(hwnd, szMsg, szTitle, MB_OK);

            fOkay = FALSE;
        }
    }

    if (fOkay && CheckForExistingSubscription(szSource))
    {
        if ((dwFlags & ADDURL_SILENT) ||
            (ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_COMP_SUBSCRIBED), 
                 MAKEINTRESOURCE(IDS_COMP_TITLE), MB_YESNO) == IDYES))
        {
            DeleteFromSubscriptionList(szSource);
        }
        else
        {
            fOkay = FALSE;
        }
    }

    if (fOkay)
    {
        if (fPathIsUrl || fExtIsCdf)
        {
            HRESULT hr;
            IProgressDialog * pProgressDlg = NULL;
            DECLAREWAITCURSOR;

//  98/12/16 vtan #250938: Cannot add new components that are not
//  local with ICW run to completion. Tell the user and launch ICW.

            if (!IsICWCompleted())
            {
                if ((dwFlags & ADDURL_SILENT) == 0)
                {
                    ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_COMP_ICW_ADD), MAKEINTRESOURCE(IDS_COMP_ICW_TITLE), MB_OK);
                    LaunchICW();
                }
                fOkay = FALSE;
            }
            else
            {
                SetWaitCursor();
                // ParseDesktopComponent can hang for a long time, we need some sort of progress
                // UI up before we call it.
                if (!(dwFlags & ADDURL_SILENT) && !fExtIsCdf)
                {
                    if (pProgressDlg = CProgressDialog_CreateInstance(IDS_COMP_TITLE, IDA_ISEARCH, g_hinst))
                    {
                        TCHAR szConnecting[80];
                        LoadString(HINST_THISDLL, IDS_CONNECTING, szConnecting, ARRAYSIZE(szConnecting));
                        pProgressDlg->SetLine(1, szConnecting, FALSE, NULL);
                        pProgressDlg->SetLine(2, szSource, TRUE, NULL);
                        pProgressDlg->StartProgressDialog(hwnd, NULL, PROGDLG_AUTOTIME | PROGDLG_NOPROGRESSBAR, NULL);
                    }
                }

                hr = ParseDesktopComponent(hwnd, szSource, pcomp);

                if (pProgressDlg)
                {
                    pProgressDlg->StopProgressDialog();
                    fOkay = !pProgressDlg->HasUserCancelled();  //  User may have cancelled the progress dialog
                    pProgressDlg->Release();
                }
                ResetWaitCursor();

                if (hr == S_FALSE) // User cancelled operation via subscription download dialog
                    fOkay = FALSE;

                if (fOkay)
                {
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Convert ed's wide thinggy to multi.
                        //
                        WideCompToMultiComp(pcomp, &compA);
    
                        fSubscribed = TRUE;
                    }
                    else if (!fExtIsCdf)
                    {
                        //
                        // This is some non-CDF url.
                        //
                        CreateComponent(&compA, szSource);
                    }
                    else
                    {
                        //
                        // We barfed on a CDF, bring up an error message.
                        //
                        if (!(dwFlags & ADDURL_SILENT))
                        {
                            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_COMP_BADURL), 
                                            MAKEINTRESOURCE(IDS_COMP_TITLE), MB_OK);
                        }
                        fOkay = FALSE;
                    }
                }
            }
        }
        else
        {
            //
            // This is just some local file.
            //
            CreateComponent(&compA, szSource);
        }
    }

    if (fOkay && fPathIsUrl && !fSubscribed)
    {
        //
        // Run subscription code on URLs if CDF code hasn't already.
        //
        if (dwFlags & ADDURL_SILENT)
        {
            ISubscriptionMgr *psm;

            if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                            CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, (void**)&psm)))
            {
                //We need to zero init this structure except the cbSize field.
                SUBSCRIPTIONINFO siDefault = {sizeof(SUBSCRIPTIONINFO)};
                //This field is already initialized above.
                //siDefault.cbSize = sizeof(siDefault);
                psm->CreateSubscription(hwnd, szSource, szSource, CREATESUBS_NOUI, SUBSTYPE_DESKTOPURL, &siDefault);
                psm->UpdateSubscription(szSource);
                psm->Release();
            }
        }
        else
        {
            HRESULT hres = CreateSubscriptionsWizard(SUBSTYPE_DESKTOPURL, szSource, NULL, hwnd);
            if (!SUCCEEDED(hres))  //Some error, or the user chose Cancel - we should fail.
            {
                ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_COMP_BADSUBSCRIBE), 
                                MAKEINTRESOURCE(IDS_COMP_TITLE), MB_OK);
            }
            fOkay = (hres == S_OK);    //could be S_FALSE, which means CreateSubscription was cancelled
            //so we don't display the above error, but we don't create the DTI
        }
    }

    MultiCompToWideComp(&compA, pcomp);
 
    if (fOkay)
    {
        AddDesktopItem(pcomp, 0);
        return S_OK;
    }
    else  
    {
        return E_FAIL;
    }
}

void CActiveDesktop::_SaveSettings(DWORD dwFlags)
{
    ENTERPROC(2, "DS SaveSettings()");

    if (dwFlags & AD_APPLY_SAVE)
    {
        // Don't ever modify the safemode settings
        TCHAR lpszDeskcomp[MAX_PATH];
        GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_GENERAL, _pszScheme);
        if (!StrStr(lpszDeskcomp, REG_DESKCOMP_SAFEMODE_SUFFIX))
        {
            //
            // Write out registry settings.
            //
            _SaveWallpaper();
            _SaveComponents();
            _SavePattern(SAVE_PATTERN_NAME);
        }
    };

    if (dwFlags & AD_APPLY_HTMLGEN)
    {
        //We need to generate the Patten.bmp file too!
        _SavePattern(GENERATE_PATTERN_FILE);

        //
        // Write out HTML file.
        //
        _GenerateHtml();
    }

// The 3rd largest hang found by WindowsUpdate crash uploader has been that the Desktop hwnd hangs
    // and the display CPYU
#define SENDMESSAGE_TIMEOUT         (10 * 1000)

    if (dwFlags & AD_APPLY_REFRESH)
    {
        HWND    hwndShell = GetShellWindow();
        SHELLSTATE ss = {0};
        DWORD_PTR pdwTemp = 0;

        SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);
        BOOL fWasActiveDesktop = BOOLIFY(ss.fDesktopHTML);
        BOOL fIsActiveDesktop = BOOLIFY(_co.fActiveDesktop);

        if (fIsActiveDesktop && !IsICWCompleted())
            TBOOL(DisableUndisplayableComponents(this));
        if (fIsActiveDesktop != fWasActiveDesktop)
        {
            if (hwndShell)
            {

                SendMessageTimeout(hwndShell, WM_WININICHANGE, SPI_SETDESKWALLPAPER, (LPARAM)TEXT("ToggleDesktop"), SMTO_NORMAL, SENDMESSAGE_TIMEOUT, &pdwTemp);
            }

            //Force a SHRefresh with this dummy call
            SHGetSetSettings(NULL, 0, TRUE);
        }
        else if (fIsActiveDesktop && hwndShell)
        {
            //See if we can simply make the changes dynamically instead of refreshing the whole page

//  98/09/22 #182982 vtan: Use dynamic HTML to refresh only if specifically told by a flag.

            if (_fUseDynamicHtml && (dwFlags & AD_APPLY_DYNAMICREFRESH))
            {
                SendMessageTimeout(hwndShell, DTM_MAKEHTMLCHANGES, (WPARAM)0, (LPARAM)0L, SMTO_NORMAL, SENDMESSAGE_TIMEOUT, &pdwTemp);
            }
            else
            {
                //Can't use dynamic html. We have to refresh the whole page.
                SendMessageTimeout(hwndShell, WM_WININICHANGE, SPI_SETDESKWALLPAPER, 
                    (LPARAM)((dwFlags & AD_APPLY_BUFFERED_REFRESH) ? c_szBufferedRefresh : c_szRefreshDesktop), SMTO_NORMAL, SENDMESSAGE_TIMEOUT, &pdwTemp);
            }
        }

        _fUseDynamicHtml = TRUE;
    }

    //
    // Data is no longer dirty.
    //
    _fDirty = FALSE;
    _fWallpaperDirty = FALSE;
    _fWallpaperChangedDuringInit = FALSE;
    _fPatternDirty = FALSE;

    EXITPROC(2, "DS SaveSettings!");
}

ULONG CActiveDesktop::AddRef(void)
{
    ENTERPROC(1, "DS AddRef()");

    _cRef++;

    EXITPROC(1, "DS AddRef=%d", _cRef);
    return _cRef;
}

// pwzPath: The path where the temp files go (%userprofile%/windows)
// pszFile: The original file name ("Joe's Vacation Picture.jpg")
// pszInUse: The wallpaper in use.
HRESULT _DeleteUnusedTempFiles(IN LPCWSTR pwzPath, IN LPCTSTR pszFile)
{
    HRESULT hr = S_OK;
    TCHAR szTemplate[MAX_PATH];
    WIN32_FIND_DATA findFileData;
    LPCTSTR pszFileName = PathFindFileName(pszFile);

    wnsprintf(szTemplate, ARRAYSIZE(szTemplate), TEXT("%ls\\Wallpaper*.bmp"), pwzPath);
    HANDLE hFindFile = FindFirstFile(szTemplate, &findFileData);

    if (INVALID_HANDLE_VALUE != hFindFile)
    {
        do
        {
            // Is this an old template? (Different name than we are currently using?
            // Also, don't delete the wallpaper that is in use.
            if (StrCmpI(findFileData.cFileName, pszFileName))
            {
                DeleteFile(szTemplate); // Yes so delete it.
            }
        }
        while (FindNextFile(hFindFile, &findFileData));

        FindClose(hFindFile);
    }

    return hr;
}


// nIndex: The file to try.
// pszInUse: This is the file we should skip because it's in use.
// pwzPath: On the way in, this is the selected wallpaper to convert.
//          On the way out, this is is the converted file.
HRESULT _ConvertToTempFile(IN int nIndex, IN LPCWSTR pwzTempPath, IN LPTSTR pwzPath, IN int cchSize)
{
    HRESULT hr = E_FAIL;
    WCHAR wzNewFile[MAX_PATH];
    LPCWSTR pszFileName = PathFindFileName(pwzPath);

    if (pszFileName)
    {
        wnsprintfW(wzNewFile, ARRAYSIZE(wzNewFile), L"%s\\Wallpaper%d.bmp", pwzTempPath, nIndex);

        hr = SHConvertGraphicsFile(pwzPath, wzNewFile, SHCGF_REPLACEFILE);

        // This may fail for one of many reasons, and we just fall back to the old behavior if it fails.
        // This may fail if they don't have write permission of the disk, run out of disk space, or
        // this is a file type that we don't support.
        if (SUCCEEDED(hr))
        {
            StrCpyNW(pwzPath, wzNewFile, cchSize);
        }
    }

    return hr;
}


BOOL _DoFileWriteTimesMatch(IN LPCWSTR pszFile1, IN LPFILETIME pftLastWrite2)
{
    BOOL fMatch = FALSE;
    HANDLE hFile1 = CreateFile(pszFile1, GENERIC_READ, (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE), NULL, OPEN_EXISTING, 0, NULL);

    if (INVALID_HANDLE_VALUE != hFile1)
    {
        FILETIME ftLastWrite1;

        if (GetFileTime(hFile1, NULL, NULL, &ftLastWrite1))
        {
            fMatch = ((0 == CompareFileTime(&ftLastWrite1, pftLastWrite2)) ? TRUE : FALSE);
        }

        CloseHandle(hFile1);
    }

    return fMatch;
}

// pszFile: On the way in, this will contain the full path to the original file.
//          On the way out, if we succeed, it will be modified to the temp file
//          that is the converted equivalent of the file on the way in.
HRESULT CActiveDesktop::_ConvertFileToTempBitmap(IN LPWSTR pszFile, IN int cchSize)
{
    HRESULT hr = E_FAIL;
    WCHAR wzPath[MAX_PATH];

    if (S_OK == SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA, NULL, SHGFP_TYPE_CURRENT, wzPath) &&
        PathAppend(wzPath, TEXT("Microsoft")))
    {
        WCHAR szOriginalFile[MAX_PATH];

        CreateDirectoryW(wzPath, NULL);     // Create this since it may not exist.
        StrCpyNW(szOriginalFile, pszFile, ARRAYSIZE(szOriginalFile));

        // Let's try the modified names to come up with something we can use.
        for (int nIndex = 1; FAILED(hr) && (nIndex < 100); nIndex++)
        {
            hr = _ConvertToTempFile(nIndex, wzPath, pszFile, cchSize);
        }

        if (SUCCEEDED(hr))
        {
            _DeleteUnusedTempFiles(wzPath, pszFile);
        }
    }

    return hr;
}

#define SZ_REGKEY_CONTROLPANEL_DESKTOP      TEXT("Control Panel\\Desktop")
#define SZ_REGVALUE_CONVERTED_WALLPAPER     TEXT("ConvertedWallpaper")
#define SZ_REGVALUE_ORIGINAL_WALLPAPER      TEXT("OriginalWallpaper")               // We store this to find when someone changed the wallpaper around us
#define SZ_REGVALUE_WALLPAPER               TEXT("Wallpaper")
#define SZ_REGVALUE_CONVERTED_WP_LASTWRITE  TEXT("ConvertedWallpaper Last WriteTime")

HRESULT CActiveDesktop::_SaveTempWallpaperSettings(void)
{
    HRESULT hr = E_FAIL;

    // When we converted a non-.BMP wallpaper to a .bmp temp file,
    // we keep the name of the original wallpaper path stored in _szSelectedWallpaper.
    // We need to save that.
    if (_szSelectedWallpaper)
    {
        hr = S_OK;

        DWORD cbSize = sizeof(_szSelectedWallpaper[0]) * (lstrlen(_szSelectedWallpaper) + 1);

        Str_SetPtr(&_pszOrigLastApplied, _szSelectedWallpaper);

        // ISSUE: CONVERTED and ORIGINAL are backwards, but we shipped beta1 like this so we can't change it... blech
        DWORD dwError = SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_CONVERTED_WALLPAPER, REG_SZ, _szSelectedWallpaper, cbSize);
        hr = HRESULT_FROM_WIN32(dwError);

        if (SUCCEEDED(hr))
        {
            Str_SetPtrW(&_pszWallpaperInUse, _szSelectedWallpaper);
            cbSize = sizeof(_szSelectedWallpaperConverted[0]) * (lstrlen(_szSelectedWallpaperConverted) + 1);

            Str_SetPtr(&_pszOrigLastApplied, _szSelectedWallpaper);

            dwError = SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_ORIGINAL_WALLPAPER, REG_SZ, (void *) _szSelectedWallpaperConverted, cbSize);
            hr = HRESULT_FROM_WIN32(dwError);

            if (SUCCEEDED(hr)) 
            {
                dwError = SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_WALLPAPER, REG_SZ, (void *) _szSelectedWallpaperConverted, cbSize);
                hr = HRESULT_FROM_WIN32(dwError);
            }

            // Set date/time stamp of the original file (_szSelectedWallpaper) so we can later determine if the user changed the original.
            if (_szSelectedWallpaper[0])
            {
                HANDLE hFile = CreateFile(_szSelectedWallpaper, GENERIC_READ, (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE), 
                        NULL, OPEN_EXISTING, 0, NULL);

                if (INVALID_HANDLE_VALUE != hFile)
                {
                    if (GetFileTime(hFile, NULL, NULL, &_ftLastWrite))
                    {
                        dwError = SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_CONVERTED_WP_LASTWRITE, REG_BINARY, &_ftLastWrite, sizeof(_ftLastWrite));
                        hr = HRESULT_FROM_WIN32(dwError);
                    }

                    CloseHandle(hFile);
                }
            }
            else
            {
                ULARGE_INTEGER * puli = (ULARGE_INTEGER *) &_ftLastWrite;
                puli->QuadPart = 0;
            }
        }
    }

    return hr;
}

HRESULT CActiveDesktop::ApplyChanges(DWORD dwFlags)
{
    HRESULT hres = E_FAIL;
    ENTERPROC(1, "DS Apply(dwFlags=%08X)", dwFlags);

    BOOL fActiveDesktop = FALSE; // default to disable active desktop

    // determine if we should enable active desktop
    if (SHRestricted(REST_FORCEACTIVEDESKTOPON))
    {
        // if policy requires active desktop, then use that
        fActiveDesktop = TRUE;
    }
    else
    {
        // if desktop components are locked -> active desktop is on
        DWORD dwDesktopFlags = GetDesktopFlags();
        if (dwDesktopFlags & COMPONENTS_LOCKED)
        {        
            fActiveDesktop = TRUE;
        } 
        else
        {        
            // if desktop icons are hidden -> active desktop is on
            SHELLSTATE ss;
            SHGetSetSettings(&ss, SSF_HIDEICONS, FALSE);
            if (ss.fHideIcons)
            {
                fActiveDesktop = TRUE;
            }
        }
    }

    // Convert the background if needed.
    // if background is not a .bmp --> active desktop is on if we can't auto-convert
    if (!IsNormalWallpaper(_szSelectedWallpaper))
    {
        BOOL fBitmapWallpaper = FALSE;
        
        // create the factory
        
        IShellImageDataFactory* pImgFact;
        
        if (SUCCEEDED(CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &pImgFact))))
        {
            IShellImageData * pImage;

            if (SUCCEEDED(pImgFact->CreateImageFromFile(_szSelectedWallpaper, &pImage)))
            {
                // PERF: cache decoded data
                if (SUCCEEDED(pImage->Decode(SHIMGDEC_DEFAULT, 0, 0)))
                {
                    if (S_FALSE == pImage->IsTransparent() &&
                        S_FALSE == pImage->IsAnimated())
                    {
                        StrCpyNW(_szSelectedWallpaperConverted, _szSelectedWallpaper, ARRAYSIZE(_szSelectedWallpaperConverted));
                        HRESULT hrConvert = _ConvertFileToTempBitmap(_szSelectedWallpaperConverted, ARRAYSIZE(_szSelectedWallpaperConverted));
                        if (SUCCEEDED(hrConvert))
                        {
                            if (S_OK == hrConvert) // if we actually had to convert (we may have already done the conversion)
                            {
                                _fDirty = TRUE; // if we converted, then we have changed the background and must persist it
                                _SaveTempWallpaperSettings();
                                StrCpyNW(_szSelectedWallpaper, _szSelectedWallpaperConverted, ARRAYSIZE(_szSelectedWallpaper));
                            }
                            fBitmapWallpaper = TRUE;                                        
                        }
                    }
                }
                pImage->Release();
            }
            pImgFact->Release();
        }

        if (!fBitmapWallpaper)
        {
            fActiveDesktop = TRUE;
        }
    }

    if (!fActiveDesktop)
    {
        // if any elements are checked --> active desktop is on
        if (_hdsaComponent)
        {
            INT cComponents = DSA_GetItemCount(_hdsaComponent);
            for (INT i = 0; i < cComponents; i++)
            {
                COMPONENTA* pComponent = (COMPONENTA*)DSA_GetItemPtr(_hdsaComponent, i);
                if (pComponent && pComponent->fChecked)
                {
                    fActiveDesktop = TRUE;
                    break;
                }                        
            }
        }
    }

    if (_co.fActiveDesktop != fActiveDesktop)
    {
        _co.fActiveDesktop = fActiveDesktop;
        _fDirty = TRUE;
    }

    if (dwFlags & AD_APPLY_FORCE)
    {
        _fDirty = TRUE;
        _fWallpaperDirty = TRUE;
        _fPatternDirty = TRUE;
    }

    if (_fDirty || _fWallpaperChangedDuringInit)
    {
        _SaveSettings(dwFlags);
    }

    hres = S_OK;

    EXITPROC(1, "DS ApplyChanges=%d", hres);

    return hres;
}

ULONG CActiveDesktop::Release(void)
{
    UINT nRet = --_cRef;
    ENTERPROC(1, "DS Release()");

    if (_cRef == 0)
    {
        delete this;
    }

    EXITPROC(1, "DS Release=%d", nRet);
    return nRet;
}

CActiveDesktop::CActiveDesktop()
{
    _cRef = 1;
    _fNoDeskMovr = FALSE;
    _fBackgroundHtml = FALSE;
    _fUseDynamicHtml = TRUE;
    _hdsaComponent = NULL;
    _pszScheme = NULL;

    DllAddRef();
}

CActiveDesktop::~CActiveDesktop()
{
    if (_hdsaComponent)
    {
        DSA_Destroy(_hdsaComponent);
    }
    if (_pszScheme)
    {
        LocalFree((HANDLE)_pszScheme);
    }

    DllRelease();
}

HRESULT CActiveDesktop::GetWallpaper(LPWSTR pwszWallpaper, UINT cchWallpaper, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    ENTERPROC(1, "DS GetWallpaper(pszWallpaper=%08X,cchWallpaper=%d)", pwszWallpaper, cchWallpaper);

    ASSERT(!dwReserved);     // These should be 0

    if (pwszWallpaper && cchWallpaper)
    {
        StrCpyN(pwszWallpaper, _szSelectedWallpaper, cchWallpaper);

        if ( cchWallpaper < wcslen(_szSelectedWallpaper) )
        {
            hres = MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_MORE_DATA );
        }
        else
        {
            hres = S_OK;
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "DS GetWallpaper unable to return wallpaper");
    }

    EXITPROC(1, "DS GetWallpaper=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::SetWallpaper(LPCWSTR pwszWallpaper, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    WCHAR szTemp[MAX_PATH];

    ASSERT(!dwReserved);     // These should be 0

    if (_fPolicyForWPName)    // If a policy exists, the caller can not change the wallpaper.
        return S_FALSE;  
        
    if (pwszWallpaper)
    {
        StrCpyN(szTemp, pwszWallpaper, ARRAYSIZE(szTemp));
        PathExpandEnvStringsWrap(szTemp, ARRAYSIZE(szTemp));    // We unexpand only when we persist.

        if (lstrcmp(_szSelectedWallpaper, szTemp) != 0)
        {
            lstrcpyn(_szSelectedWallpaper, szTemp, ARRAYSIZE(_szSelectedWallpaper));
            _fWallpaperDirty = TRUE;
            _fDirty = TRUE;
            _fUseDynamicHtml = FALSE;  //Setting wallpaper causes a lot of change; So, can't use dynamic html
        }
        
        hres = S_OK;
    }

    ENTERPROC(1, "DS SetWallpaper(pszWallpaper=>%s<)", pwszWallpaper ? szTemp : TEXT("(NULL)"));

    EXITPROC(1, "DS SetWallpaper=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::GetWallpaperOptions(WALLPAPEROPT *pwpo, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    ENTERPROC(1, "DS GetWallpaperOptions(pwpo=%08X)");

    ASSERT(!dwReserved);     // These should be 0

    if ((pwpo) && (pwpo->dwSize == sizeof(*pwpo)))
    {
        *pwpo = _wpo;
        hres = S_OK;
    }
    else
    {
        TraceMsg(TF_WARNING, "DS GetWallpaperOptions could not return options");
    }

    EXITPROC(1, "DS GetWallpaperOptions=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::SetWallpaperOptions(LPCWALLPAPEROPT pwpo, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    ENTERPROC(1, "DS SetWallpaperOptions(pwpo=%08X)", pwpo);

    ASSERT(!dwReserved);     // These should be 0

    if (_fPolicyForWPStyle)  //If a policy exists for wallpaper style, the caller can not change it.
        return S_FALSE;
        

    if ((pwpo) && (pwpo->dwSize == sizeof(*pwpo)))
    {
        _wpo = *pwpo;
        _fWallpaperDirty = TRUE;
        _fDirty = TRUE;
        _fUseDynamicHtml = FALSE; //Changing wallpaper options causes us to regenerate the whole thing.
        hres = S_OK;
    }
    else
    {
        TraceMsg(TF_WARNING, "DS SetWallpaperOptions could not set options");
    }

    EXITPROC(1, "DS SetWallpaperOptions=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::GetPattern(LPWSTR pwszPattern, UINT cchPattern, DWORD dwReserved)
{
    HRESULT hres = S_OK;
    ENTERPROC(1, "DS GetPattern(psz=%08X,cch=%d)", pwszPattern, cchPattern);

    ASSERT(!dwReserved);     // These should be 0

    if (!pwszPattern || (cchPattern == 0))
        return (E_INVALIDARG);

    StrCpyN(pwszPattern, _szSelectedPattern, cchPattern);

    EXITPROC(1, "DS GetPattern=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::SetPattern(LPCWSTR pwszPattern, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    LPCTSTR pszPattern;

    ASSERT(!dwReserved);     // These should be 0

    if (pwszPattern)
    {
        pszPattern = pwszPattern;
        if (lstrcmp(_szSelectedPattern, pszPattern) != 0)
        {
            lstrcpyn(_szSelectedPattern, pszPattern, ARRAYSIZE(_szSelectedPattern));

            _fPatternDirty = TRUE;
            _fDirty = TRUE;
            _fUseDynamicHtml = FALSE; //Setting pattern causes us to regenerate the whole thing.

            hres = S_OK;
        }
        else
            hres = E_FAIL;
    }

    ENTERPROC(1, "DS SetPattern(psz=>%s<)", pwszPattern ? pszPattern : TEXT("(NULL)"));

    EXITPROC(1, "DS SetPattern=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::GetDesktopItemOptions(COMPONENTSOPT *pco, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    ENTERPROC(1, "DS GetComponentsOptions(pco=%08X)", pco);

    ASSERT(!dwReserved);     // These should be 0

    if (pco && (pco->dwSize == sizeof(*pco)))
    {
        *pco = _co;
        hres = S_OK;
    }
    else
    {
        TraceMsg(TF_WARNING, "DS GetComponentsOptions unable to return options");
    }

    EXITPROC(1, "DS GetComponentsOptions=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::SetDesktopItemOptions(LPCCOMPONENTSOPT pco, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    ENTERPROC(1, "DS SetComponentsOptions(pco=%08X)", pco);

    ASSERT(!dwReserved);     // These should be 0

    if (pco && (pco->dwSize == sizeof(*pco)))
    {
        _co = *pco;
        _fDirty = TRUE;
        hres = S_OK;
    }
    else
    {
        TraceMsg(TF_WARNING, "DS SetComponentsOptions unable to set options");
    }

    EXITPROC(1, "DS SetComponentsOptions=%d", hres);
    return hres;
}

//
// SetStateInfo()
//      This function simply sets up the COMPSTATEINFO structure passed using the current
// position and size from the COMPPOS structure and the itemState passed.
//
void SetStateInfo(COMPSTATEINFO *pCompStateInfo, COMPPOS *pCompPos, DWORD dwItemState)
{
    pCompStateInfo->dwSize   = sizeof(*pCompStateInfo);
    pCompStateInfo->iLeft    = pCompPos->iLeft;
    pCompStateInfo->iTop     = pCompPos->iTop;
    pCompStateInfo->dwWidth  = pCompPos->dwWidth;
    pCompStateInfo->dwHeight = pCompPos->dwHeight;
    pCompStateInfo->dwItemState = dwItemState;
}

void ConvertCompStruct(COMPONENTA *pCompDest, COMPONENTA *pCompSrc, BOOL fPubToPriv)
{
    pCompDest -> dwID = pCompSrc -> dwID;
    pCompDest -> iComponentType = pCompSrc -> iComponentType;
    pCompDest -> fChecked = pCompSrc -> fChecked;
    pCompDest -> fDirty = pCompSrc -> fDirty;
    pCompDest -> fNoScroll = pCompSrc -> fNoScroll;
    pCompDest -> cpPos = pCompSrc -> cpPos;

    if (fPubToPriv)
    {
        COMPONENT *pComp = (COMPONENT *)pCompSrc;

        pCompDest->dwSize = sizeof(COMPONENTA);
        SHUnicodeToTChar(pComp->wszSource, pCompDest->szSource, ARRAYSIZE(pCompDest->szSource));
        SHUnicodeToTChar(pComp->wszFriendlyName, pCompDest->szFriendlyName, ARRAYSIZE(pCompDest->szFriendlyName));
        SHUnicodeToTChar(pComp->wszSubscribedURL, pCompDest->szSubscribedURL, ARRAYSIZE(pCompDest->szSubscribedURL));
        
        //Check to see if the public component is from IE4 app (old size)
        if (pCompSrc->dwSize == sizeof(COMPONENT))
        {
            // Since the dest component is the same size as the most current structure, all fields
            // are valid.
            // CAUTION: The following fields are at a different offset in public and private 
            // structures. So, you need to use pcomp instead of pCompSrc for example.
            pCompDest->dwCurItemState = pComp->dwCurItemState;
            pCompDest->csiOriginal = pComp->csiOriginal;
            pCompDest->csiRestored = pComp->csiRestored;
        }
        else
        {
            // Since the size did not match, we assume that this is an older structure.
            // Since the older struct does not have any Original and Restored sizes, let's copy 
            // the default values.
            IE4COMPONENT   *pIE4Comp = (IE4COMPONENT *)pCompSrc;
            pCompDest->dwCurItemState = IS_NORMAL;
            SetStateInfo(&pCompDest->csiOriginal, &pIE4Comp->cpPos, IS_NORMAL);
            SetStateInfo(&pCompDest->csiRestored, &pIE4Comp->cpPos, IS_NORMAL);
        }
    }
    else
    {
        COMPONENT *pComp = (COMPONENT *)pCompDest;
        
        if (pCompDest->dwSize != sizeof(COMPONENT))
            pCompDest->dwSize = sizeof(IE4COMPONENT);
        SHTCharToUnicode(pCompSrc->szSource, pComp->wszSource, ARRAYSIZE(pComp->wszSource));
        SHTCharToUnicode(pCompSrc->szFriendlyName, pComp->wszFriendlyName, ARRAYSIZE(pComp->wszFriendlyName));
        SHTCharToUnicode(pCompSrc->szSubscribedURL, pComp->wszSubscribedURL, ARRAYSIZE(pComp->wszSubscribedURL));
        
        //Check to see if the public component is from IE4 app (old size)
        if (pComp->dwSize == sizeof(COMPONENT))
        {
            // Since the dest component is the same size as the most current structure, all fields
            // are valid.
            // CAUTION: The following fields are at a different offset in public and private 
            // structures. So, you need to use pcomp instead of pCompDest for example.
            pComp->dwCurItemState = pCompSrc->dwCurItemState;
            pComp->csiOriginal = pCompSrc->csiOriginal;
            pComp->csiRestored = pCompSrc->csiRestored;
        }
        // else, the dest component is IE4COMPONENT and the additional fields are not there.
    }
}


HRESULT CActiveDesktop::_AddDTIWithUIPrivateA(HWND hwnd, LPCCOMPONENT pComp, DWORD dwFlags)
{
    HRESULT hres = E_FAIL;
    PCWSTR pszUrl = pComp->wszSource;
    int nScheme = GetUrlScheme(pszUrl);
    DWORD dwCurItemState;
    if ((URL_SCHEME_INVALID == nScheme) || (URL_SCHEME_UNKNOWN == nScheme))
    {
        TCHAR szFullyQualified[INTERNET_MAX_URL_LENGTH];
        DWORD cchSize = ARRAYSIZE(szFullyQualified);

        if (SUCCEEDED(ParseURLFromOutsideSource(pszUrl, szFullyQualified, &cchSize, NULL)))
            nScheme = GetUrlScheme(szFullyQualified);
    }

    // Is this URL valid to subscribe to?  Did the caller specify they want use
    // to try to subscribe to it?
    if ((URL_SCHEME_FILE != nScheme) && (URL_SCHEME_ABOUT != nScheme) && 
        IsFlagSet(dwFlags, DTI_ADDUI_DISPSUBWIZARD) && hwnd)
    {
        //Create a subscription.
        hres = CreateSubscriptionsWizard(SUBSTYPE_DESKTOPURL, pszUrl, NULL, hwnd);
        if (hres != S_OK)
        {
            return hres;
        }
    }

    //
    // Add the component to the registry.
    //

    // PERF: This function creates a second COM objects.  
    //         We need to Inline the functionality.
    if (pComp->dwSize == sizeof(IE4COMPONENT))
        dwCurItemState = IS_NORMAL;
    else
        dwCurItemState = pComp->dwCurItemState;
    hres = AddRemoveDesktopComponentNoUI(TRUE, AD_APPLY_ALL | AD_APPLY_DYNAMICREFRESH, pszUrl, NULL, pComp->iComponentType, 
        pComp->cpPos.iLeft, pComp->cpPos.iTop, pComp->cpPos.dwWidth, pComp->cpPos.dwHeight, TRUE, dwCurItemState) ? S_OK : E_FAIL;

    return hres;
}



#define     STC_DESKTOPCOMPONENT    0x00000002
STDAPI SubscribeToCDF(HWND hwndParent, LPCWSTR pwzUrl, DWORD dwCDFTypes);

HRESULT CActiveDesktop::AddDesktopItemWithUI(HWND hwnd, LPCOMPONENT pComp, DWORD dwFlags)
{
    HRESULT hres = E_FAIL;

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pComp ||
       ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))) ||
       ((pComp->dwSize == sizeof(*pComp)) && !VALIDATESTATE(pComp->dwCurItemState)) ||
       ((pComp->iComponentType < 0) || (pComp->iComponentType > COMP_TYPE_MAX)))  //Validate the component type
        return E_INVALIDARG;

    // Catch folks that call our API's to add components and prevent them from doing
    // so if the restriction is in place.
    if (SHIsRestricted(NULL, REST_NOADDDESKCOMP))
        return E_ACCESSDENIED;

    // Check if the component already exists.
    BOOL fCompExists = FALSE;
    int cComp;
    GetDesktopItemCount(&cComp, 0);
    int i;
    COMPONENT comp;
    comp.dwSize = sizeof(COMPONENT);  //This needs to be initialized for ConvertCompStruc to work!
    COMPONENTA compA;
    TCHAR   szSource[INTERNET_MAX_URL_LENGTH];
    SHUnicodeToTChar(pComp->wszSource, szSource, ARRAYSIZE(szSource));

    for (i=0; i<cComp && !fCompExists; i++)
    {
        compA.dwSize = sizeof(compA);
        if (GetComponentPrivate(i, &compA)
                && lstrcmpi(szSource, compA.szSource) == 0)
        {
            fCompExists = TRUE;
            ConvertCompStruct((COMPONENTA *)&comp, &compA, FALSE);
            break;
        }
    }

    BOOL fAskToInstall;
    if (ZoneCheckUrlW(pComp->wszSource, URLACTION_SHELL_INSTALL_DTITEMS, (PUAF_NOUI), NULL) == S_OK)
    {
        fAskToInstall = TRUE;
    }
    else
    {
        fAskToInstall = FALSE;
    }

    if (S_OK != ZoneCheckUrlW(pComp->wszSource, URLACTION_SHELL_INSTALL_DTITEMS, (hwnd ? (PUAF_FORCEUI_FOREGROUND | PUAF_WARN_IF_DENIED) : PUAF_NOUI), NULL))
        return E_ACCESSDENIED;

    BOOL fCompSubDeleted = FALSE;
    SUBSCRIPTIONINFO si = {sizeof(SUBSCRIPTIONINFO)};
    // si.bstrUserName = NULL;
    // si.bstrPassword = NULL;
    // si.bstrFriendlyName = NULL;
    //
    // Confirmation dialog.
    //
    if (hwnd)
    {
        if (fCompExists)
        {
            //Prompt the user to delete the existing ADI.
            // This is a long string. So,...
            TCHAR szMsg[512];
            TCHAR szMsg2[256];
            TCHAR szTitle[128];
            LoadString(HINST_THISDLL, IDS_COMP_EXISTS, szMsg, ARRAYSIZE(szMsg));
            LoadString(HINST_THISDLL, IDS_COMP_EXISTS_2, szMsg2, ARRAYSIZE(szMsg2));
            lstrcat(szMsg, szMsg2);
            LoadString(HINST_THISDLL, IDS_COMP_TITLE, szTitle, ARRAYSIZE(szTitle));
            MessageBox(hwnd, szMsg, szTitle, MB_OK);

            return E_FAIL;

#if 0

            comp.dwSize = sizeof(comp);

            //Prompt the user to reinstall the ADI.
            if (ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_CONFIRM_ADI_REINSTALL), 
                MAKEINTRESOURCE(IDS_COMP_TITLE), MB_YESNO) != IDYES)
            {
                return E_FAIL; //User choses not to install this desktop component!
            }
            else
            {
                ISubscriptionMgr *psm;
                if (SUCCEEDED(hres = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                        CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, (void**)&psm)))
                {
                    si.cbSize = sizeof(si);
                    si.fUpdateFlags = SUBSINFO_ALLFLAGS;
                    //Backup and remove the subscription also
                    hres = psm->GetSubscriptionInfo(comp.wszSubscribedURL, &si);
                    if (SUCCEEDED(hres))
                    {
                        hres = RemoveDesktopItem(&comp, 0);
                        if (SUCCEEDED(hres))
                        {
                            psm->DeleteSubscription(comp.wszSubscribedURL, NULL);
                            ApplyChanges(AD_APPLY_SAVE);
                            fCompSubDeleted = TRUE;
                            // Set the new component to be enabled
                            pComp->fChecked = TRUE;
                        }
                    }
                    psm->Release();
                }
                else
                {
                    TraceMsg(TF_WARNING, "CActiveDesktop::AddDesktopItemWithUI : CoCreateInstance for CLSID_SubscriptionMgr failed.");
                }
            }
#endif
        }
        else if (fAskToInstall)
        {
            if (ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_CONFIRM_ADD), 
                                MAKEINTRESOURCE(IDS_INTERNET_EXPLORER), MB_YESNO) != IDYES)
            {
                return E_FAIL; //User choses not to install this desktop component!
            }
        }
    }

    hres = SubscribeToCDF(hwnd, pComp->wszSubscribedURL, STC_DESKTOPCOMPONENT);
    switch(hres)
    {
        case E_INVALIDARG:
        {
            // E_UNEXPECTED is returned from SubscribeToCDFUrlA() when the URL doesn't point to
            // a CDF file, so we assume it's a web page.

            hres = _AddDTIWithUIPrivateA(hwnd, pComp, dwFlags);
            if (hres != S_OK && fCompSubDeleted)    // Restore the old component
            {
                hres = AddDesktopItem(&comp, 0);
                if (SUCCEEDED(hres))
                {
                    ISubscriptionMgr *psm;
                    if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                            CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, (void**)&psm)))
                    {
                        si.cbSize = sizeof(si);
                        psm->CreateSubscription(hwnd, comp.wszSubscribedURL, si.bstrFriendlyName, CREATESUBS_NOUI, SUBSTYPE_DESKTOPURL, &si);
                        psm->Release();
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "CActiveDesktop::AddDesktopItemWithUI : CoCreateInstance for CLSID_SubscriptionMgr failed.");
                    }
                }
            }
            ApplyChanges(AD_APPLY_ALL | AD_APPLY_DYNAMICREFRESH);
        }
        break;

        case E_ACCESSDENIED:
            // The file was a CDF but didn't contain Desktop Component Information
            if (hwnd)
            {
                TCHAR szMsg[MAX_PATH];
                TCHAR szTitle[MAX_PATH];

                LoadString(HINST_THISDLL, IDS_ADDCOMP_ERROR_CDFNODTI, szMsg, ARRAYSIZE(szMsg));
                LoadString(HINST_THISDLL, IDS_INTERNET_EXPLORER, szTitle, ARRAYSIZE(szTitle));
                MessageBox(hwnd, szMsg, szTitle, MB_OK);
            }
            break;
        case E_UNEXPECTED:      
            // This was a CDF but it was misauthored.
            if (hwnd)
            {
                TCHAR szMsg[MAX_PATH];
                TCHAR szTitle[MAX_PATH];

                LoadString(HINST_THISDLL, IDS_ADDCOMP_ERROR_CDFINALID, szMsg, ARRAYSIZE(szMsg));
                LoadString(HINST_THISDLL, IDS_INTERNET_EXPLORER, szTitle, ARRAYSIZE(szTitle));
                MessageBox(hwnd, szMsg, szTitle, MB_OK);
            }
            break;
        default:
            break;
    }

    if (hwnd && SUCCEEDED(hres))
    {
        // If the active desktop is currently OFF, we need to turn it ON
        SHELLSTATE ss = {0};
        SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);
        if (!ss.fDesktopHTML)
        {
            COMPONENTSOPT co;
            co.dwSize = sizeof(COMPONENTSOPT);
            GetDesktopItemOptions(&co, 0);
            co.fActiveDesktop = TRUE;
            SetDesktopItemOptions(&co, 0);
            ApplyChanges(AD_APPLY_REFRESH | AD_APPLY_DYNAMICREFRESH);
        }
    }

    if (fCompSubDeleted)
    {
        if (si.bstrUserName)
        {
            SysFreeString(si.bstrUserName);
        }
        if (si.bstrPassword)
        {
            SysFreeString(si.bstrPassword);
        }
        if (si.bstrFriendlyName)
        {
            SysFreeString(si.bstrFriendlyName);
        }
    }
    return hres;
}

void RestoreComponent(HDSA hdsaComponents, COMPONENTA * pcomp)
{
    int i;

    // If we are split then set the bit saying that the listview needs to be adjusted.  This is done
    // when we check the state of desktop.htm in EnsureUpdateHtml.
    //  Note: Do this only if this component is enabled.
    if ((pcomp->dwCurItemState & IS_SPLIT) && (pcomp->fChecked))
    {
        pcomp->dwCurItemState |= IS_ADJUSTLISTVIEW;
        SetDesktopFlags(COMPONENTS_ZOOMDIRTY, COMPONENTS_ZOOMDIRTY);
    }

    for (i = 0; i < DSA_GetItemCount(hdsaComponents); i++)
    {
        COMPONENTA * pcompT;
    
        if (pcompT = (COMPONENTA *)DSA_GetItemPtr(hdsaComponents, i))
        {
            // If this component is split/fullscreen and is different from the source component
            // but it is at the same location then it must be on this monitor (work area) so restore it.
            if (ISZOOMED(pcompT) &&
                lstrcmpi(pcomp->szSource, pcompT->szSource) &&
                (pcomp->cpPos.iTop  == pcompT->cpPos.iTop) &&
                ((pcomp->cpPos.iLeft + pcomp->cpPos.dwWidth) == (pcompT->cpPos.iLeft + pcompT->cpPos.dwWidth)))
                {
                    pcompT->dwCurItemState = pcompT->csiRestored.dwItemState;
                    pcompT->cpPos.iLeft = pcompT->csiRestored.iLeft;
                    pcompT->cpPos.iTop = pcompT->csiRestored.iTop;
                    pcompT->cpPos.dwWidth = pcompT->csiRestored.dwWidth;
                    pcompT->cpPos.dwHeight = pcompT->csiRestored.dwHeight;
                    pcompT->cpPos.izIndex = COMPONENT_TOP;
                    pcompT->fDirty = TRUE;
                    break;
                }
        }
    }
}

HRESULT CActiveDesktop::AddDesktopItem(LPCCOMPONENT pComp, DWORD dwReserved)
{
    HRESULT     hres = E_FAIL;
    COMPONENTA  CompA;
    CompA.dwSize = sizeof(CompA);

    ASSERT(!dwReserved);     // These should be 0

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pComp ||
       ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))) ||
       ((pComp->dwSize == sizeof(*pComp)) && !VALIDATESTATE(pComp->dwCurItemState)))
        return E_INVALIDARG;

    // Catch folks that call our API's to add components and prevent them from doing
    // so if the restriction is in place.
    if ((!_fIgnoreAddRemovePolicies) && (SHIsRestricted(NULL, REST_NOADDDESKCOMP)))
        return E_ACCESSDENIED;

    // Convert the external structure to the internal format
    ConvertCompStruct(&CompA, (COMPONENTA *)pComp, TRUE);
 
    // If the component is already present, then fail the call!
    if (_FindComponentBySource(CompA.szSource, &CompA) > -1) 
        return hres;

    //Make sure that the COMPPOS size field is set before we add it!
    CompA.cpPos.dwSize = sizeof(COMPPOS);

    PositionComponent(&CompA, &CompA.cpPos, CompA.iComponentType, TRUE);

    if (_hdsaComponent && ISZOOMED(&CompA))
        RestoreComponent(_hdsaComponent, &CompA);

    //Make sure the this component's fDirty flag is off.
    CompA.fDirty = FALSE;

    // Set the dummy bit here - this forces folks to do bitwise testing on the dwCurItemState field
    // instead of testing for equality.  This will allow us to expand use of the field down the
    // road without compatibility problems.
    CompA.dwCurItemState |= IS_INTERNALDUMMYBIT;

    if (AddComponentPrivate(&CompA, _dwNextID++))
    {
        // It might be cheaper to attempt to insert the component in the
        // correct z-order but it's less code to just call _SortAndRationalize
        // after the insertion is done.
        _SortAndRationalize();
        hres = S_OK;
    }

    return(hres);
}

BOOL CActiveDesktop::AddComponentPrivate(COMPONENTA *pcomp, DWORD dwID)
{
    BOOL fRet = FALSE;
    ENTERPROC(1, "DS AddComponent(pcomp=%08X)", pcomp);

    if (pcomp)
    {
        if (_hdsaComponent == NULL)
        {
            _hdsaComponent = DSA_Create(sizeof(COMPONENTA), DXA_GROWTH_CONST);
        }

        if (_hdsaComponent)
        {
            pcomp->dwID = dwID;

            if (DSA_AppendItem(_hdsaComponent, pcomp) != -1)
            {
                _fDirty = TRUE;
                fRet = TRUE;
            }
            else
            {
                TraceMsg(TF_WARNING, "DS AddComponent unable to append DSA");
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "DS AddComponent unable to create DSA");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "DS AddComponent unable to add a component");
    }

    EXITPROC(1, "DS AddComponent=%d", fRet);
    return fRet;
}

//
// This finds out if a given component already exists by comparing the szSource
// If so, it fills out the correct dwID and returns the index.
//
int CActiveDesktop::_FindComponentBySource(LPTSTR lpszSource, COMPONENTA *pComp)
{
    int iRet = -1;
    ENTERPROC(2, "DS FindComponentIdBySource(pComp=%8X)", pComp);

    if (_hdsaComponent)
    {
        int i;

        for (i=0; i<DSA_GetItemCount(_hdsaComponent); i++)
        {
            COMPONENTA comp;
            comp.dwSize = sizeof(COMPONENTA);

            if (DSA_GetItem(_hdsaComponent, i, &comp) != -1)
            {
                if (!lstrcmpi(comp.szSource, lpszSource))
                {
                    *pComp = comp;
                    iRet = i;
                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "DS FindComponentIndexByID unable to get a component");
            }
        }
    }

    EXITPROC(2, "DS FindComponentIdBySource=%d", iRet);
    return iRet;
}

int CActiveDesktop::_FindComponentIndexByID(DWORD dwID)
{
    int iRet = -1;
    ENTERPROC(2, "DS FindComponentIndexByID(dwID=%d)", dwID);

    if (_hdsaComponent)
    {
        int i;

        for (i=0; i<DSA_GetItemCount(_hdsaComponent); i++)
        {
            COMPONENTA comp;
            comp.dwSize = sizeof(COMPONENTA);

            if (DSA_GetItem(_hdsaComponent, i, &comp) != -1)
            {
                if (comp.dwID == dwID)
                {
                    iRet = i;
                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "DS FindComponentIndexByID unable to get a component");
            }
        }
    }

    EXITPROC(2, "DS FindComponent=%d", iRet);
    return iRet;
}


//
// This function is to be used only in special situations. Given a Url, it finds a component
// that has the src= pointed to that url. Note that what we have is szSource is something like
// "c:\foo\bar.bmp"; But, what is passed to this function is "file://c:/foo/bar.htm"
//
// Warning: This function does a conversion from Path to Url for every component before
// comparing with the given Url. This is in-efficient. We do it this way because converting
// the given Url ,which was converted to url from path, back to Path may not result in the 
// original path. In other words a round-trip from path to Url and back to path may not result
// in the path that was originally entered by the end-user.
//
int CActiveDesktop::_FindComponentBySrcUrl(LPTSTR lpszSrcUrl, COMPONENTA *pComp)
{
    int iRet = -1;
    ENTERPROC(2, "DS FindComponentBySrcUrl(pComp=%8X)", pComp);

    if (_hdsaComponent)
    {
        int i;

        for (i=0; i<DSA_GetItemCount(_hdsaComponent); i++)
        {
            COMPONENTA comp;
            comp.dwSize = sizeof(COMPONENTA);

            if (DSA_GetItem(_hdsaComponent, i, &comp) != -1)
            {
                TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];
                LPTSTR  lpszUrl = szUrl;
                DWORD   dwSize;

                //Convert the szSource to Url
                dwSize = ARRAYSIZE(szUrl);
                
                if (FAILED(UrlCreateFromPath(comp.szSource, lpszUrl, &dwSize, 0)))
                    lpszUrl = comp.szSource;
                    
                if (!lstrcmpi(lpszUrl, lpszSrcUrl))
                {
                    *pComp = comp;
                    iRet = i;
                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "DS FindComponentBySrcUrl unable to get a component");
            }
        }
    }

    EXITPROC(2, "DS FindComponentBySrcUrl=%d", iRet);
    return iRet;
}

HRESULT CActiveDesktop:: GetDesktopItemByID(ULONG_PTR dwID, COMPONENT *pcomp, DWORD dwReserved)
{
    HRESULT hres = E_FAIL;
    ENTERPROC(1, "DS GetComponentByID(dwID=%d,pcomp=%08X)", dwID, pcomp);
    COMPONENTA  CompA;

    ASSERT(!dwReserved);     // These should be 0

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pcomp || ((pcomp->dwSize != sizeof(*pcomp)) && (pcomp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    if (pcomp)
    {
        int index = _FindComponentIndexByID((DWORD)dwID);
        if (index != -1)
        {
            if (DSA_GetItem(_hdsaComponent, index, &CompA) != -1)
            {
                hres = S_OK;
            }
            else
            {
                TraceMsg(TF_WARNING, "DS GetComponentByID unable to get component");
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "DS GetComponentByID unable to find component");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "DS GetComponentByID given NULL pcomp");
    }

    if (SUCCEEDED(hres))
    {
        MultiCompToWideComp(&CompA, pcomp);
    }

    EXITPROC(1, "DS GetComponentByID=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::RemoveDesktopItem(LPCCOMPONENT pComp, DWORD dwReserved)
{
    COMPONENTA  CompA, CompToDelete;
    int         iIndex;
    HRESULT     hres = E_FAIL;

    ASSERT(!dwReserved);     // These should be 0

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pComp || ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    CompA.dwSize = sizeof(CompA);
    CompToDelete.dwSize = sizeof(CompToDelete);

    //Convert the struct to internal struct.
    ConvertCompStruct(&CompA, (COMPONENTA *)pComp, TRUE);

    // See if the component already exists.
    iIndex = _FindComponentBySource(CompA.szSource, &CompToDelete);

    if (iIndex > -1)
    {
        if (RemoveComponentPrivate(iIndex, &CompToDelete))
        {
            hres = S_OK;
        }
    }

    return(hres);
}

BOOL CActiveDesktop::RemoveComponentPrivate(int iIndex, COMPONENTA *pcomp)
{
    BOOL fRet = FALSE;
    ENTERPROC(1, "DS RemoveComponent(pcomp=%08X)", pcomp);

    if (_hdsaComponent)
    {
        if (iIndex == -1)
            iIndex = _FindComponentIndexByID(pcomp->dwID);
        if (iIndex != -1)
        {
            if (DSA_DeleteItem(_hdsaComponent, iIndex) != -1)
            {
                _fDirty = TRUE;
                fRet = TRUE;
            }
            else
            {
                TraceMsg(TF_WARNING, "DS RemoveComponent could not remove an item");
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "DS RemoveComponent could not find item to remove");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "DS RemoveComponent has no components to remove");
    }

    EXITPROC(1, "DS RemoveComponent=%d", fRet);
    return fRet;
}

HRESULT CActiveDesktop::_CopyComponent(COMPONENTA *pCompDest, COMPONENTA *pCompSrc, DWORD dwFlags)
{
    //Copy only those elements mentioned in the flag!

//    if (dwFlags & COMP_ELEM_ID)
//        pCompDest->dwID = pCompSrc->dwID;
    if (dwFlags & COMP_ELEM_TYPE)
        pCompDest-> iComponentType = pCompSrc->iComponentType;
    if (dwFlags & COMP_ELEM_CHECKED)
        pCompDest-> fChecked = pCompSrc->fChecked;
    if (dwFlags & COMP_ELEM_DIRTY)
        pCompDest-> fDirty = pCompSrc-> fDirty;
    if (dwFlags & COMP_ELEM_NOSCROLL)
        pCompDest-> fNoScroll = pCompSrc-> fNoScroll;
    if (dwFlags & COMP_ELEM_POS_LEFT)
        pCompDest-> cpPos.iLeft= pCompSrc->cpPos.iLeft;
    if (dwFlags & COMP_ELEM_POS_TOP)
        pCompDest-> cpPos.iTop= pCompSrc->cpPos.iTop;
    if (dwFlags & COMP_ELEM_SIZE_WIDTH)
        pCompDest-> cpPos.dwWidth= pCompSrc->cpPos.dwWidth;
    if (dwFlags & COMP_ELEM_SIZE_HEIGHT)
        pCompDest-> cpPos.dwHeight= pCompSrc->cpPos.dwHeight;
    if (dwFlags & COMP_ELEM_POS_ZINDEX)
        pCompDest-> cpPos.izIndex= pCompSrc->cpPos.izIndex;
    if (dwFlags & COMP_ELEM_SOURCE)
        lstrcpy(pCompDest->szSource, pCompSrc->szSource);
    if (dwFlags & COMP_ELEM_FRIENDLYNAME)
        lstrcpy(pCompDest->szFriendlyName, pCompSrc->szFriendlyName);
    if (dwFlags & COMP_ELEM_SUBSCRIBEDURL)
        lstrcpy(pCompDest->szSubscribedURL, pCompSrc->szSubscribedURL);
    if (dwFlags & COMP_ELEM_ORIGINAL_CSI)
        pCompDest->csiOriginal = pCompSrc->csiOriginal;
    if (dwFlags & COMP_ELEM_RESTORED_CSI)
    {
        pCompDest->csiRestored = pCompSrc->csiRestored;

//  98/08/21 vtan #174542: When changing csiRestored using the Active
//  Desktop API and the component is zoomed the csiRestored information
//  needs to be copied to the cpPos field as well as this is where the
//  actual information is stored when the component is restored. This
//  is only applicable to the case when the component is zoomed.

        if (ISZOOMED(pCompDest))
        {
            pCompDest->cpPos.iLeft = pCompSrc->csiRestored.iLeft;
            pCompDest->cpPos.iTop = pCompSrc->csiRestored.iTop;
            pCompDest->cpPos.dwWidth = pCompSrc->csiRestored.dwWidth;
            pCompDest->cpPos.dwHeight = pCompSrc->csiRestored.dwHeight;
        }
    }
    if (dwFlags & COMP_ELEM_CURITEMSTATE)  // Only allow the modification of the public bits - propagate the internal bits unchanged.
        pCompDest->dwCurItemState = (pCompDest->dwCurItemState & IS_VALIDINTERNALBITS) | (pCompSrc->dwCurItemState & ~IS_VALIDINTERNALBITS);

    return(S_OK);
}

HRESULT CActiveDesktop::GetDesktopItemBySource(LPCWSTR lpcwszSource, LPCOMPONENT pComp, DWORD dwFlags)
{
    COMPONENTA CompNew; 
    HRESULT   hres = E_FAIL;
    int       iIndex;

    //Passing a NULL to SHUnicodeToTChar causes a fault. So, let's fail it.
    if (lpcwszSource == NULL)
        return E_INVALIDARG;
        
    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pComp || ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    CompNew.dwSize = sizeof(COMPONENTA);

    SHUnicodeToTChar(lpcwszSource, CompNew.szSource, ARRAYSIZE(CompNew.szSource));

    iIndex = _FindComponentBySource(CompNew.szSource, &CompNew);

    if (iIndex > -1)
    {
        MultiCompToWideComp(&CompNew, pComp);
        hres = S_OK;
    }

    return(hres);
}

HRESULT CActiveDesktop::ModifyDesktopItem(LPCCOMPONENT pComp, DWORD dwFlags)
{
    COMPONENTA  CompA, CompNew;
    HRESULT     hres = E_FAIL;
    int         iIndex = -1;

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pComp || ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    CompA.dwSize = sizeof(COMPONENTA);
    CompNew.dwSize = sizeof(COMPONENTA);

    //Convert public param structure to private param structure.
    ConvertCompStruct(&CompA, (COMPONENTA *)pComp, TRUE);

    //See if this component already exists.
    iIndex = _FindComponentBySource(CompA.szSource, &CompNew);
    if (iIndex > -1)
    {
        _CopyComponent(&CompNew, &CompA, dwFlags);

        if (dwFlags & (COMP_ELEM_POS_LEFT | COMP_ELEM_POS_TOP | COMP_ELEM_SIZE_WIDTH | COMP_ELEM_SIZE_HEIGHT | COMP_ELEM_CHECKED | COMP_ELEM_CURITEMSTATE))
            PositionComponent(&CompNew, &CompNew.cpPos, CompNew.iComponentType, FALSE);
        if (ISZOOMED(&CompNew))
            RestoreComponent(_hdsaComponent, &CompNew);

        CompNew.fDirty = TRUE; //Since the component is modified, we set the dirty bit!
        if (UpdateComponentPrivate(iIndex, &CompNew))
            hres = S_OK;
    }

    return(hres);
}

BOOL CActiveDesktop::UpdateComponentPrivate(int iIndex, COMPONENTA *pcomp)
{
    BOOL fRet = FALSE;
    ENTERPROC(1, "DS UpdateComponentPrivate(pcomp=%08X)", pcomp);

    if (_hdsaComponent)
    {
        if (iIndex == -1)
            iIndex = _FindComponentIndexByID(pcomp->dwID);

        if (iIndex != -1)
        {
            if (DSA_SetItem(_hdsaComponent, iIndex, pcomp) != -1)
            {
                _fDirty = TRUE;
                fRet = TRUE;
            }
            else
            {
                TraceMsg(TF_WARNING, "DS UpdateComponent could not update an item");
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "DS UpdateComponent could not find item to update");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "DS UpdateComponent has no components to update");
    }

    EXITPROC(1, "DS UpdateComponent=%d", fRet);
    return fRet;
}

HRESULT CActiveDesktop::GetDesktopItemCount(LPINT lpiCount, DWORD dwReserved)
{
    if (!lpiCount)
        return (E_INVALIDARG);

    *lpiCount = 0;

    ENTERPROC(1, "DS GetComponentsCount()");

    ASSERT(!dwReserved);     // These should be 0

    if (_hdsaComponent)
    {
        *lpiCount = DSA_GetItemCount(_hdsaComponent);
    }

    EXITPROC(1, "DS GetComponentsCount=%d", *lpiCount);
    return S_OK;
}

HRESULT CActiveDesktop::GetDesktopItem(int nComponent, COMPONENT *pComp, DWORD dwReserved)
{
    COMPONENTA  CompA;

    ASSERT(!dwReserved);     // These should be 0

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if ((nComponent < 0) || !pComp || ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    CompA.dwSize = sizeof(COMPONENTA);

    if (GetComponentPrivate(nComponent, &CompA))
    {
        //Convert the structure to the Public form.
        ConvertCompStruct((COMPONENTA *)pComp, &CompA, FALSE);
        return(S_OK);
    }
    else
        return(E_FAIL);
}

BOOL CActiveDesktop::GetComponentPrivate(int nComponent, COMPONENTA *pcomp)
{
    BOOL fRet = FALSE;
    ENTERPROC(1, "DS GetComponent(nComponent=%d,pcomp=%08X)", nComponent, pcomp);

    if (_hdsaComponent && pcomp && (nComponent < DSA_GetItemCount(_hdsaComponent)))
    {
        if (DSA_GetItem(_hdsaComponent, nComponent, pcomp) != -1)
        {
            fRet = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "DS GetComponent unable to get a component");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "DS GetComponent does not have a DSA");
    }

    EXITPROC(1, "DS GetComponent=%d", fRet);
    return fRet;
}

HRESULT CActiveDesktop::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IActiveDesktop))
    {
        *ppvObj = (IActiveDesktop *)this;
        _Initialize();
    }
    else if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IActiveDesktop *)this;
    }
    else if (IsEqualIID(riid, IID_IActiveDesktopP))
    {
        *ppvObj = (IActiveDesktopP *)this;
    }
    else if (IsEqualIID(riid, IID_IADesktopP2))
    {
        *ppvObj = (IADesktopP2 *)this;
    }
    else if (IsEqualIID(riid, IID_IPropertyBag))
    {
        *ppvObj = (IPropertyBag *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

// Helper function so that it's easy to create one internally
// Actually, it's not ver much help any more...
STDAPI CActiveDesktop_InternalCreateInstance(LPUNKNOWN * ppunk, REFIID riid)
{
    return CActiveDesktop_CreateInstance(NULL, riid, (void **)ppunk);
}

// Our class factory create instance code
STDAPI CActiveDesktop_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    TraceMsg(TF_DESKSTAT, "CActiveDesktop- CreateInstance");

    CActiveDesktop *pad = new CActiveDesktop();

    if (pad)
    {
        HRESULT hres = pad->QueryInterface(riid, ppvOut);
        pad->Release();
        return hres;
    }

    *ppvOut = NULL;
    return E_OUTOFMEMORY;
}


#ifdef DEBUG

//
// FEATURE - Move g_dwDeskStatTrace into ccshell.ini to prevent recompiles.
//
DWORD g_dwDeskStatTrace = 2;
static DWORD g_dwIndent = 0;
static const TCHAR c_szDotDot[] = TEXT("..");

#define MAX_INDENTATION_VALUE    0x20

void EnterProcDS(DWORD dwTraceLevel, LPSTR pszFmt, ...)
{
    TCHAR szFmt[1000];
    TCHAR szOutput[1000];
    va_list arglist;

    SHAnsiToTChar(pszFmt, szFmt, ARRAYSIZE(szFmt));
    if (dwTraceLevel <= g_dwDeskStatTrace)
    {
        szOutput[0] = TEXT('\0');

        for (DWORD i=0; i<g_dwIndent; i++)
        {
            lstrcat(szOutput, c_szDotDot);
        }

        va_start(arglist, pszFmt);
        wvsprintf(szOutput + lstrlen(szOutput), szFmt, arglist);
        va_end(arglist);

        TraceMsg(TF_DESKSTAT, "%s", szOutput);

        // We don't want this value to get out of hand because of 
        // unmatched Enter and Exit calls in functions (which will 
        // trash the stack).
        if (g_dwIndent < MAX_INDENTATION_VALUE)
            g_dwIndent++;
    }
}

void ExitProcDS(DWORD dwTraceLevel, LPSTR pszFmt, ...)
{
    TCHAR szFmt[1000];
    TCHAR szOutput[1000];
    va_list arglist;

    SHAnsiToTChar(pszFmt, szFmt, ARRAYSIZE(szFmt));
    if (dwTraceLevel <= g_dwDeskStatTrace)
    {
        //This can happen if the Enter and Exit procs are unmatched.
        if (g_dwIndent > 0)
            g_dwIndent--;

        szOutput[0] = TEXT('\0');

        for (DWORD i=0; i<g_dwIndent; i++)
        {
            lstrcat(szOutput, c_szDotDot);
        }

        va_start(arglist, pszFmt);
        wvsprintf(szOutput + lstrlen(szOutput), szFmt, arglist);
        va_end(arglist);

        TraceMsg(TF_DESKSTAT, "%s", szOutput);
    }
}

#endif

/*************************************************************************
 *
 *  IActiveDesktopP methods and helper functions
 *
 *  IActiveDesktopP is a private interface used to implement helper
 *  functionality that is used internally by the various shell binaries.
 *
 *  Notes:
 *      Getting an interface to IActiveDesktopP does not initialize the state
 *  of the object such that member functions are able to call IActiveDesktop
 *  member functions.  This is so that it is a more lightweight implementation
 *  and also simplifies the implementation of SetScheme.  If a subsequent QI for
 *  IActiveDesktop is performed then it will initialize properly and any member
 *  function can then be called.
 *
 *************************************************************************/

//
// SetScheme
//
// Used to set the current scheme that the object will read and write to
// when it is initialized.  This method must be called before a subsequent
// QI to IActiveDesktop is made.
//
HRESULT CActiveDesktop::SetScheme(LPCWSTR pwszSchemeName, DWORD dwFlags)
{
    LPTSTR pszSchemeName, pszAlloc;
    int icch;

    // Can't set the local scheme after we've been initialized...we can fix this
    // later if necessary but for now it's simplest this way.
    if (_fInitialized && (dwFlags & SCHEME_LOCAL))
        return E_FAIL;

    // Sanity checks
    if (!pwszSchemeName || ((icch = lstrlenW(pwszSchemeName)) > MAX_PATH - 1))
        return E_INVALIDARG;

    pszSchemeName = (LPTSTR)pwszSchemeName;

    if (dwFlags & SCHEME_CREATE)
    {
        HRESULT hres;
        HKEY hkey, hkey2;

        if (ERROR_SUCCESS == (hres = RegCreateKey(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME_LOCATION, &hkey)))
        {
            if (ERROR_SUCCESS == (hres = RegCreateKey(hkey, pszSchemeName, &hkey2)))
                RegCloseKey(hkey2);
            RegCloseKey(hkey);
        }
        if (FAILED(hres))
            return hres;
    }

    if (dwFlags & SCHEME_LOCAL)
    {
        // The local case is easy - just copy the string to our local variable,
        // it will be used when IActiveDesktop is initialized.
        if (!(pszAlloc = (LPTSTR)LocalAlloc(LPTR, (icch + 1) * sizeof(TCHAR))))
            return E_OUTOFMEMORY;

        if (_pszScheme)
            LocalFree((HANDLE)_pszScheme);

        _pszScheme = pszAlloc;

        lstrcpy(_pszScheme, pszSchemeName);
    }

    if (dwFlags & SCHEME_GLOBAL)
    {
        // Update the registry with the new global scheme value
        if (dwFlags & SCHEME_DISPLAY)
            SHSetValue(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME, REG_VAL_SCHEME_DISPLAY,
                        REG_SZ, pszSchemeName, CbFromCch(lstrlen(pszSchemeName) + 1));
        if (dwFlags & SCHEME_EDIT)
            SHSetValue(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME, REG_VAL_SCHEME_EDIT,
                        REG_SZ, pszSchemeName, CbFromCch(lstrlen(pszSchemeName) + 1));
    }

    if (dwFlags & (SCHEME_REFRESH | SCHEME_UPDATE))
    {
        DWORD dwUpdateFlags = AD_APPLY_FORCE | AD_APPLY_HTMLGEN | AD_APPLY_SAVE;
        if (dwFlags & SCHEME_REFRESH)
            dwUpdateFlags |= (AD_APPLY_REFRESH | AD_APPLY_DYNAMICREFRESH);
        _Initialize();
        _fUseDynamicHtml=FALSE;  
        ApplyChanges(dwUpdateFlags);
    }

    return S_OK;
}


HRESULT GetGlobalScheme(LPWSTR pwszScheme, LPDWORD lpdwcchBuffer, DWORD dwFlags)
{
    DWORD cbScheme = *lpdwcchBuffer * sizeof(pwszScheme[0]);
    LONG lret = SHGetValueW(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME,
                    (dwFlags & SCHEME_EDIT) ? REG_VAL_SCHEME_EDIT : REG_VAL_SCHEME_DISPLAY, NULL,
                    pwszScheme, &cbScheme);
    
    if (ERROR_SUCCESS == lret)
    {
        *lpdwcchBuffer = lstrlenW(pwszScheme);
    }
    return (lret == ERROR_SUCCESS ? S_OK : E_FAIL);
}


//
// GetScheme
//
//
HRESULT CActiveDesktop::GetScheme(LPWSTR pwszSchemeName, LPDWORD lpdwcchBuffer, DWORD dwFlags)
{
    // Sanity checks
    if (!pwszSchemeName || *lpdwcchBuffer == 0)
        return E_INVALIDARG;

    if (dwFlags & SCHEME_LOCAL)
    {
        if (!_pszScheme)
        {
            HRESULT hres;
            // Special case if no local scheme has explicitly been selected yet.
            // The default scheme is the global display scheme in this case.
            if (SUCCEEDED(hres = GetGlobalScheme(pwszSchemeName, lpdwcchBuffer, SCHEME_DISPLAY)))
            {
                hres = SetScheme(pwszSchemeName, SCHEME_LOCAL);
            }
            return hres;
        }

        SHTCharToUnicode(_pszScheme, pwszSchemeName, *lpdwcchBuffer);
        
        *lpdwcchBuffer = lstrlenW(pwszSchemeName);
        return S_OK;
    }


    if (dwFlags & SCHEME_GLOBAL)
    {
        return GetGlobalScheme(pwszSchemeName, lpdwcchBuffer, dwFlags);
    }

    return E_INVALIDARG;
}

BOOL UpdateAllDesktopSubscriptions(IADesktopP2 *);
HRESULT CActiveDesktop::UpdateAllDesktopSubscriptions()
{
    ::UpdateAllDesktopSubscriptions(this);
    return S_OK;
}

void CActiveDesktop::_GenerateHtmlBStrForComp(COMPONENTA *pComp, BSTR *pbstr)
{
    ENTERPROC(2, "DS _GenerateHtmlBstrForComp");
    
    if (_pStream = SHCreateMemStream(NULL, 0)) //Create a mem stream.
    {
        LARGE_INTEGER libMove = {0};
        ULARGE_INTEGER libCurPos;
        // Since _pStream is setup, the following call will generate the component HTML into
        // that stream.
        _GenerateHtmlComponent(pComp);

        //Get the size of the stream generated.
        _pStream->Seek(libMove, STREAM_SEEK_CUR, &libCurPos);

        //Allocare a BSTR big enough to hold our component HTML code.
        if (*pbstr = SysAllocStringLen(NULL, (libCurPos.LowPart)/sizeof(WCHAR)))
        {
            _pStream->Seek(libMove, STREAM_SEEK_SET, NULL);
            _pStream->Read(*pbstr, libCurPos.LowPart, NULL);
        }

        //NOTE: The bStr is released by the caller.
        
        ATOMICRELEASE(_pStream);
    }
    else
        TraceMsg(TF_WARNING, "DS _GenerateHtmlBstrForComp unable to create a mem stream");
        
    EXITPROC(2, "DS _GenerateHtmlBstrForComp");
}


void CActiveDesktop::_UpdateStyleOfElement(IHTMLElement *pElem, LPCOMPONENTA lpCompA)
{
    IHTMLStyle  *pHtmlStyle;
    
    if (SUCCEEDED(pElem->get_style(&pHtmlStyle)))
    {
        long    lPixelVal;
        VARIANT vVal;
        VARIANT vValNew;

        
        if (SUCCEEDED(pHtmlStyle->get_pixelLeft(&lPixelVal)) && (lPixelVal != lpCompA->cpPos.iLeft))
        {
            TraceMsg(TF_DYNAMICHTML, "iLeft changes from %d to %d", lPixelVal, lpCompA->cpPos.iLeft);
            pHtmlStyle->put_pixelLeft((long)(lpCompA->cpPos.iLeft));
        }
        
        if (SUCCEEDED(pHtmlStyle->get_pixelTop(&lPixelVal)) && (lPixelVal != lpCompA->cpPos.iTop))
        {
            TraceMsg(TF_DYNAMICHTML, "iTop changes from %d to %d", lPixelVal, lpCompA->cpPos.iTop);
            pHtmlStyle->put_pixelTop((long)(lpCompA->cpPos.iTop));
        }

        VariantInit(&vVal);
       
        if (SUCCEEDED(pHtmlStyle->get_width(&vVal))) //Get the width as BSTR to see if width attribute exists
        {
            //See if the width attribute exists now.
            if ((vVal.vt == VT_BSTR) && (vVal.bstrVal == NULL))
            {
                // Width attribute does not exist for this element; This means that
                // this element has the default width (may be a picture shown in it's original width).
                if (lpCompA->cpPos.dwWidth != COMPONENT_DEFAULT_WIDTH)
                {
                    //Component's new width is different from the default width. So, set the new width.
                    TraceMsg(TF_DYNAMICHTML, "dwWidth changes from default to %d", lpCompA->cpPos.dwWidth);
                    pHtmlStyle->put_pixelWidth((long)(lpCompA->cpPos.dwWidth));
                }
                //else, nothing to do! (the widths match exactly).
                
            }
            else
            {
                // Width attribute exists! That means that this element has a width other than the
                // default width.
                // See if the new width is the default width.
                if (lpCompA->cpPos.dwWidth == COMPONENT_DEFAULT_WIDTH)
                {
                    // The old width is NOT default; But, the new width is default. So, let's just
                    // remove the width attribute.
                    VariantInit(&vValNew);
                    vValNew.vt = VT_BSTR;
                    vValNew.bstrVal = NULL;
                    pHtmlStyle->put_width(vValNew);

                    VariantClear(&vValNew);
                }
                else
                {
                    //Get the existing width in pixels.
                    if (SUCCEEDED(pHtmlStyle->get_pixelWidth(&lPixelVal)) && (((DWORD)lPixelVal) != lpCompA->cpPos.dwWidth))
                    {
                        TraceMsg(TF_DYNAMICHTML, "dwWidth changes from %d to %d", lPixelVal, lpCompA->cpPos.dwWidth);
                        pHtmlStyle->put_pixelWidth((long)(lpCompA->cpPos.dwWidth));
                    }
                    //else, nothing else to do because the widths match!
                }
                
            }
            VariantClear(&vVal);
        }
        
        if (SUCCEEDED(pHtmlStyle->get_height(&vVal))) //Get the height as BSTR to see if height attribute exists
        {
            // See if the height attribute exists.
            if ((vVal.vt == VT_BSTR) && (vVal.bstrVal == NULL))
            {
                // Height attribute does not exist for this element; This means that
                // this element has the default height (may be a picture shown in it's original height).
                if (lpCompA->cpPos.dwHeight != COMPONENT_DEFAULT_HEIGHT)
                {
                    //Component's new height is different from the default height. So, set the new height.
                    TraceMsg(TF_DYNAMICHTML, "dwHeight changes from default to %d", lpCompA->cpPos.dwHeight);
                    pHtmlStyle->put_pixelHeight((long)(lpCompA->cpPos.dwHeight));
                }
                //else, nothing to do! (the heights match exactly).
                
            }
            else
            {
                // Height attribute exists! That means that this element has a height other than the
                // default height.
                // See if the new height is the default height.
                if (lpCompA->cpPos.dwHeight == COMPONENT_DEFAULT_HEIGHT)
                {
                    // The old height is NOT default; But, the new height is default. So, let's just
                    // remove the height attribute.
                    VariantInit(&vValNew);
                    vValNew.vt = VT_BSTR;
                    vValNew.bstrVal = NULL;
                    pHtmlStyle->put_height(vValNew);  //remove the height attribute!

                    VariantClear(&vValNew);
                }
                else
                {
                    //Get the existing height in pixels and see if it is different.
                    if (SUCCEEDED(pHtmlStyle->get_pixelHeight(&lPixelVal)) && (((DWORD)lPixelVal) != lpCompA->cpPos.dwHeight))
                    {
                        //Since the new height is different, let's use set the new height!
                        TraceMsg(TF_DYNAMICHTML, "dwHeight changes from %d to %d", lPixelVal, lpCompA->cpPos.dwHeight);
                        pHtmlStyle->put_pixelHeight((long)(lpCompA->cpPos.dwHeight));
                    }
                    //else, nothing else to do because the heights match!
                }
                
            }
            VariantClear(&vVal);
        }
        
        
        if (SUCCEEDED(pHtmlStyle->get_zIndex(&vVal)) && (vVal.vt == VT_I4) && (vVal.lVal != lpCompA->cpPos.izIndex))
        {
            TraceMsg(TF_DYNAMICHTML, "ZIndex changes from %d to %d", vVal.lVal, lpCompA->cpPos.izIndex);
            vVal.lVal = lpCompA->cpPos.izIndex;
            pHtmlStyle->put_zIndex(vVal);
        }
        
        VariantClear(&vVal);
        
        pHtmlStyle->Release();
    }

    //FEATURE: Should we check for and set the other attributes like "resizeable" etc.,?
}

BOOL  CActiveDesktop::_UpdateIdOfElement(IHTMLElement *pElem, LPCOMPONENTA lpCompA)
{
    BSTR    bstrId;
    BOOL    fWholeElementReplaced = FALSE;  //Assume that the item id does not change.
            
    //Check if the Id of the component and the element matches.
    if (SUCCEEDED(pElem->get_id(&bstrId)))   //get the old id
    {

        if (((DWORD)StrToIntW(bstrId)) != lpCompA->dwID)
        {
            // The following technic does not work in some versions of MSHTML.DLL
            // because IHTMLElement->put_id() does not work unless the doc
            // is in "design mode".
            TCHAR   szNewId[MAXID_LENGTH];
            BSTR    bstrNewId;
            HRESULT hr = S_OK;

            wsprintf(szNewId, TEXT("%d"), lpCompA->dwID);

#ifdef DEBUG
            {
                TCHAR  szOldId[MAXID_LENGTH];
                wsprintf(szOldId, TEXT("%d"), StrToIntW(bstrId));
                TraceMsg(TF_DYNAMICHTML, "DHTML: Id changes from %s to %s", szOldId, szNewId);
            }
#endif //DEBUG
                
            //The Ids do not match. So, let's set the new ID.
                
            if (bstrNewId = SysAllocStringT(szNewId))
            {
                hr = pElem->put_id(bstrNewId);
                SysFreeString(bstrNewId);
            }

            if (FAILED(hr))
            {
                //Replace the whole element's HTML with the newly generated HTML
                BSTR    bstrComp = 0;
            
                _GenerateHtmlBStrForComp(lpCompA, &bstrComp);
                if (bstrComp)
                {
                    if (FAILED(hr = pElem->put_outerHTML(bstrComp)))
                        TraceMsg(TF_DYNAMICHTML, "DHTML: put_outerHTML failed");
                    fWholeElementReplaced = TRUE;
                    SysFreeString(bstrComp);
                }
                else
                {
                    AssertMsg(FALSE, TEXT("DHTML: Unable to create html for comp"));
                }
            }
        }
        //else the ids match; nothing to do!
        SysFreeString(bstrId);      //free the old id.
    }
    else
    {
        AssertMsg(FALSE, TEXT("DS Unable to get the id of the element"));
    }

    return fWholeElementReplaced;
}

HRESULT CActiveDesktop::_UpdateHtmlElement(IHTMLElement *pElem)
{
    VARIANT vData;
    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR   szSrcPath[INTERNET_MAX_URL_LENGTH];
    LPTSTR  lpszSrcPath;
    COMPONENTA  CompA;
    int         iIndex;

    //If all components are disabled, then we nuke this component from HTML page.
    if (!_co.fEnableComponents)
    {
        TraceMsg(TF_DYNAMICHTML, "DHTML: No item shown in this mode; so, deleting items");
        pElem->put_outerHTML((BSTR)s_sstrEmpty.wsz);
        
        return S_OK; //Nothing else to do!
    }

    VariantInit(&vData);
    
    //First determine if the given element is currently a desktop item. (It could have been deleted)
    //Get the element's "src" attribute.
    if (FAILED(pElem->getAttribute((BSTR)s_sstrSRCMember.wsz, VARIANT_FALSE, &vData)) ||
            (vData.vt == VT_NULL) ||
            (vData.bstrVal == NULL))
    {
        //If the subscribed_url is not present, then it could be an object with a classid.
        if (FAILED(pElem->getAttribute((BSTR)s_sstrclassid.wsz, VARIANT_FALSE, &vData)) ||
            (vData.vt == VT_NULL))
        {
            //This element is does not have "src=" or "classid=" attributes. How did this ever
            // become a desktop item with "name=deskmovr" or "name=deskmovrw"?? Hmmmmmm....!!!
#ifdef DEBUG
            {
                BSTR    bstrHtmlForElem;
                // Get the HTML corresponding to the element that does not have a subscribed URL
                if (SUCCEEDED(pElem->get_outerHTML(&bstrHtmlForElem)))
                {
                    TraceMsg(TF_DYNAMICHTML, "DHTML: Rogue element: %s", bstrHtmlForElem);
                    SysFreeString(bstrHtmlForElem);
                }
            }
            TraceMsg(TF_WARNING, "DHTML: Unable to get the subscribed_url or classid");
#endif
            //Since this element does not seem to be a valid desktop item, let's nuke it!
            pElem->put_outerHTML((BSTR)s_sstrEmpty.wsz);  //delete this element.
            
            return (E_FAIL);  //Nothing else to for this element! It's gone!!! 
        }
        
        if ((vData.vt == VT_NULL) || (vData.bstrVal == NULL))
            return E_FAIL;
            
        ASSERT(vData.vt == VT_BSTR);
        ASSERT(StrCmpNW(vData.bstrVal, L"clsid:", lstrlen(TEXT("clsid:"))) == 0);
        SHUnicodeToTChar(vData.bstrVal + lstrlen(TEXT("clsid:")), szUrl, ARRAYSIZE(szUrl));
        lpszSrcPath = szUrl;  //For classid, the SrcPath and the Url are the same.
    }
    else
    {
        DWORD dwSize; 
        
        if (vData.bstrVal == NULL)
            return (E_FAIL);
            
        ASSERT(vData.vt == VT_BSTR);
        SHUnicodeToTChar(vData.bstrVal, szUrl, ARRAYSIZE(szUrl));

        dwSize = ARRAYSIZE(szSrcPath);
        lpszSrcPath = szSrcPath;
        if (FAILED(PathCreateFromUrl(szUrl, lpszSrcPath, &dwSize, 0)))
        {
            lpszSrcPath = szUrl;
        }
    }

    VariantClear(&vData); //We made a TCHAR copy above. So, ok to free this.

    CompA.dwSize = sizeof(CompA);

    // First use the Source path to Find the component; This is much more efficient because it
    // involves no conversion from Path to Url and vice-versa.
    if ((iIndex = _FindComponentBySource(lpszSrcPath, &CompA)) < 0)
    {
        // Could not find component using SrcPath!
        // Let's try using the SrcUrl; This is less efficient.
        iIndex = _FindComponentBySrcUrl(szUrl, &CompA);
    }
    
    if ((iIndex>= 0) && (CompA.fChecked))
    {
        //The component is found and it is enabled.
        TraceMsg(TF_DYNAMICHTML, "DHTML:Updating desktop item with URL: %s", szUrl);

        // If the id changes, we replace the whole HTML for that element, so, no need to check for
        // the individual styles.
        if (!_UpdateIdOfElement(pElem, &CompA))
            _UpdateStyleOfElement(pElem, &CompA);
        CompA.fDirty = TRUE; //Mark the component sothat we know that it had been updated.
        UpdateComponentPrivate(iIndex, &CompA);
    }
    else
    {
        ASSERT((iIndex == -1) || (!CompA.fChecked));  //Component not found OR it is disabled!

        TraceMsg(TF_DYNAMICHTML, "DHTML: Deleting desktop item with URL: %s, SrcPath:%s", szUrl, lpszSrcPath);

        //The component is not present now. So, delete this element from the html page.
        pElem->put_outerHTML((BSTR)s_sstrEmpty.wsz);
    }

    return S_OK;
}

//
// This code enumerates and then updates all the desktop item elements in the active desktop based 
// on the current status of the active desktop items in the CActiveDesktop object (The current 
// status is initialized by reading from the registry when ActiveDesktop object is initialized).
//
HRESULT CActiveDesktop::_UpdateDesktopItemHtmlElements(IHTMLDocument2 *pDoc)
{
    HRESULT hres = S_OK;
    
    IHTMLElementCollection  *pAllElements;

    TraceMsg(TF_DYNAMICHTML, "DHTML: Updating Desktop html elements dynamically");

    if (!_fInitialized)  //If not yet initialized, initialize now because we need _co.fEnableComponents.
        _Initialize();

    // We need to check for a change in the background color only if there is no wallpaper or
    // the wallpaper is a picture.
    if (IsWallpaperPicture(_szSelectedWallpaper))
    {
        COLORREF    rgbDesktop;
        TCHAR       szRgbDesktop[10];
        VARIANT     vColor;
        
        //Check to see if the background color has changed
        rgbDesktop = GetSysColor(COLOR_DESKTOP);
        wsprintf(szRgbDesktop, TEXT("#%02lx%02lx%02lx"), GetRValue(rgbDesktop), 
                                                         GetGValue(rgbDesktop), 
                                                         GetBValue(rgbDesktop));
        if (SUCCEEDED(pDoc->get_bgColor(&vColor)) && (vColor.vt == VT_BSTR))
        {
            BSTR    bstrNewBgColor = SysAllocStringT(szRgbDesktop);

            //Compare the new and the old strings.
            if (StrCmpW(vColor.bstrVal, bstrNewBgColor))
            {
                BSTR bstrOldBgColor = vColor.bstrVal;  //Save the old bstr.
                //So, the colors are different. Set the new color.
                vColor.bstrVal = bstrNewBgColor;
                bstrNewBgColor = bstrOldBgColor;   //Set it here sothat it is freed later.

                if (FAILED(pDoc->put_bgColor(vColor)))
                {
                    TraceMsg(TF_DYNAMICHTML, "DHTML: Unable to change the background color");
                }
            }

            if (bstrNewBgColor)
                SysFreeString(bstrNewBgColor);
        
            VariantClear(&vColor);
        }
    }

    //Get a collection of All elements in the Document
    if (SUCCEEDED(pDoc->get_all(&pAllElements)))
    {
        VARIANT vName, vIndex;
        IDispatch   *pDisp;
        int     i; 
        long    lItemsEnumerated = 0;
        long    lLength = 0;


#ifdef DEBUG
        pAllElements->get_length(&lLength);
        TraceMsg(TF_DYNAMICHTML, "DHTML: Length of All elements:%d", lLength);
#endif

        for(i = 0; i <= 1; i++)
        {
            //Collect all the elements that have the name="DeskMovr" and then name="DeskMovrW"
            vName.vt = VT_BSTR;
            vName.bstrVal = (BSTR)((i == 0) ? s_sstrDeskMovr.wsz : s_sstrDeskMovrW.wsz);

            VariantInit(&vIndex); //We want to get all elements. So, vIndex is set to VT_EMPTY
        
            if (SUCCEEDED(pAllElements->item(vName, vIndex, &pDisp)) && pDisp) //Collect all elements we want
            {
                IHTMLElementCollection  *pDeskCollection;
                if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLElementCollection, (void **)&pDeskCollection)))
                {
                    IUnknown    *pUnk;
                    IEnumVARIANT    *pEnumVar;
                
                    if (SUCCEEDED(pDeskCollection->get_length(&lLength)))  //Number of elements.
                        lItemsEnumerated += lLength; //Total number of items enumerated.

                    TraceMsg(TF_DYNAMICHTML, "DHTML: Enumerated %d number of elements", lLength);
                    
                    //Get the enumerator
                    if (SUCCEEDED(pDeskCollection->get__newEnum(&pUnk)))
                    {
                        if (SUCCEEDED(pUnk->QueryInterface(IID_IEnumVARIANT, (void **)&pEnumVar)))
                        {
                            VARIANT vElem;
                            long    lEnumCount = 0;
                            DWORD   cElementsFetched;
                        
                            while(SUCCEEDED(pEnumVar->Next(1, &vElem, &cElementsFetched)) && (cElementsFetched == 1))
                            {
                                IHTMLElement *pElem;
                                lEnumCount++;
                                //  Access the element from the variant.....!
                                if ((vElem.vt == VT_DISPATCH) && SUCCEEDED(vElem.pdispVal->QueryInterface(IID_IHTMLElement, (void **)&pElem)))
                                {
                                    _UpdateHtmlElement(pElem); //Update the desktop element's attributes.
                                    pElem->Release();
                                }
                                VariantClear(&vElem);
                            }
                            //Number of items enumerated must be the same as the length
                            ASSERT(lEnumCount == lLength);
                            
                            pEnumVar->Release();
                        }
                        pUnk->Release();
                    }
                
                    pDeskCollection->Release();
                }
                else
                {
                    IHTMLElement    *pElem;
                    
                    // The QI(IID_IHTMLElementCollection) has failed. It may be because only one item 
                    // was returned rather than a collection.
                    if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLElement, (void **)&pElem)))
                    {
                        _UpdateHtmlElement(pElem); //Update the desktop element's attributes.
                        pElem->Release();
                    }
                    else
                        TraceMsg(TF_WARNING, "DHTML: Unable to get a collection or a single element");
                }
                pDisp->Release();
            }
        } // for loop enumeating "DeskMovr" and "DeskMovrW" items.
        
        pAllElements->Release();
    }

    // All the elements already present in the Doc have been updated. Now, let's add the
    // new elements, if any.
    if (_co.fEnableComponents)
        _InsertNewDesktopItems(pDoc);
    else
    {
        TraceMsg(TF_DYNAMICHTML, "DHTML: No components are to be shown in this mode;");
    }

    return hres;
}

HRESULT CActiveDesktop::_InsertNewDesktopItems(IHTMLDocument2  *pDoc)
{
    IHTMLElement    *pBody;
    
    if (SUCCEEDED(pDoc->get_body(&pBody)))
    {
        if (_hdsaComponent)
        {
            int i, iCount;

            iCount = DSA_GetItemCount(_hdsaComponent);
            for (i=0; i<iCount; i++)
            {
                COMPONENTA comp;
                comp.dwSize = sizeof(comp);

                if (DSA_GetItem(_hdsaComponent, i, &comp) != -1)
                {
                    //Check if this is a newly added component AND it is enabled.
                    if ((!comp.fDirty) && comp.fChecked)
                    {
                        TraceMsg(TF_DYNAMICHTML, "DHTML: Inserted comp: %s", comp.szSource);
                        
                        //Yup! This is a newly added component!
                        BSTR  bstrComp = 0;
                        //This is a new component. Generate the HTML for the component.
                        _GenerateHtmlBStrForComp(&comp, &bstrComp);

                        //Insert the component.
                        pBody->insertAdjacentHTML((BSTR)s_sstrBeforeEnd.wsz, (BSTR)bstrComp);

                        //Free the string.
                        SysFreeString(bstrComp);
                    }
                }
                else
                {
                    TraceMsg(TF_WARNING, "DHTML: InsertNewComp: Unable to get component %d.", i);
                }
            }
        }
        
        pBody->Release();
    }

    return S_OK;
}

//
// This function takes a pointer to the ActiveDesktop's ole obj, reads all the changes to be done
// from the registry and makes those changes to the various elements through dynamic HTML interfaces.
//
HRESULT CActiveDesktop::MakeDynamicChanges(IOleObject *pOleObj)
{

    IHTMLDocument2  *pDoc;
    HRESULT         hres = E_FAIL;

    ENTERPROC(2, "MakeDynamicChanges");

    if (pOleObj && SUCCEEDED(pOleObj->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc)))
    {
        // Enumerate all the active desktop components and ensure they are up to date.
        _UpdateDesktopItemHtmlElements(pDoc);

        pDoc->Release();
    }
    else
    {
        TraceMsg(TF_WARNING, "DHTML: MakeDynamicChanges: Unable to get IHTMLDocument2");
    }
    
    EXITPROC(2, "MakeDynamicChanges");

    return(hres);
}

//
// SetSafeMode
//
// Either puts the active desktop in safemode or restores it to the previous
// scheme before safemode was entered.
//
HRESULT CActiveDesktop::SetSafeMode(DWORD dwFlags)
{
    //
    // Make sure we are in active desktop mode.
    //
    SHELLSTATE ss = {0};
    BOOL fSetSafeMode = (dwFlags & SSM_SET) != 0;

    SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);
    if (ss.fDesktopHTML)
    {
        //
        // All we need to do is switch the "display" scheme to "safemode" in order to
        // go into safemode.  To go out, we just switch the "display" scheme back to the
        // previous "edit" scheme.
        //
        WCHAR wszEdit[MAX_PATH];
        WCHAR wszDisplay[MAX_PATH];
        DWORD dwcch = MAX_PATH;

        if (SUCCEEDED(GetScheme(wszEdit, &dwcch, SCHEME_GLOBAL | SCHEME_EDIT)))
        {
            dwcch = MAX_PATH;
            if (SUCCEEDED(GetScheme(wszDisplay, &dwcch, SCHEME_GLOBAL | SCHEME_DISPLAY)))
            {
                BOOL fInSafeMode = (StrCmpW(wszDisplay, REG_DESKCOMP_SAFEMODE_SUFFIX_L) == 0);

                if (fSetSafeMode != fInSafeMode)
                {
                    LPWSTR lpwstr;
                    DWORD dwSchemeFlags = SCHEME_GLOBAL | SCHEME_DISPLAY;
                    if (dwFlags & SSM_REFRESH)
                        dwSchemeFlags |= SCHEME_REFRESH;
                    if (dwFlags & SSM_UPDATE)
                        dwSchemeFlags |= SCHEME_UPDATE;

                    lpwstr = fSetSafeMode ? REG_DESKCOMP_SAFEMODE_SUFFIX_L : wszEdit;

                    SetScheme(lpwstr, dwSchemeFlags);
                }
            }
        }
    }
    return S_OK;
}

//
// EnsureUpdateHTML
//
// Ensures that the current html file present on the disk is in sync
// with the registry information for the current active desktop scheme.  If
// it is not in sync then a fresh copy of the file is generated from the
// registry for the current scheme.
//
HRESULT CActiveDesktop::EnsureUpdateHTML(void)
{
    DWORD dwFlags = 0;
    DWORD dwDataLength = sizeof(DWORD);
    LONG lRet;
    TCHAR lpszDeskcomp[MAX_PATH];
    TCHAR szDesktopFile[MAX_PATH];
    DWORD dwRestrictUpdate;
    DWORD dwRestrict = SHRestricted2W(REST_NoChannelUI, NULL, 0);
    DWORD dwSize = sizeof(dwRestrictUpdate);
    BOOL  fComponentsDirty = FALSE;  //Assume that the components are NOT dirty!
    DWORD dwVersion;
    DWORD dwMinorVersion;
    BOOL  fStaleInfoInReg = FALSE;
    BOOL  fComponentsZoomDirty = FALSE;
    static BOOL s_fNoDeskComp = (BOOL)-1;
    static BOOL s_fNoWallpaper = (BOOL)-1;
    BOOL fNoDeskComp = SHRestricted(REST_NODESKCOMP);
    BOOL fNoWallpaper = SHRestricted(REST_NOHTMLWALLPAPER);
    BOOL fAdminComponent = FALSE;
    HKEY hkey = NULL;
    HKEY hkeyTime;
    FILETIME ftAdminCompKey;


    if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REG_DESKCOMP_COMPONENTS_ROOT, REG_VAL_GENERAL_RESTRICTUPDATE, NULL, &dwRestrictUpdate, &dwSize))
        dwRestrictUpdate = 0;

    GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_COMPONENTS, NULL);

    //See if this branch of registry is old
    if ((lRet = SHGetValue(HKEY_CURRENT_USER, lpszDeskcomp, REG_VAL_COMP_VERSION, NULL,
                            &dwVersion, &dwDataLength)) == ERROR_SUCCESS)
    {
        if (dwVersion < CUR_DESKHTML_VERSION)
            fStaleInfoInReg = TRUE;
        else
        {
            //Major versions are equal. Check minor versions.
            if ((lRet = SHGetValue(HKEY_CURRENT_USER, (LPCTSTR)lpszDeskcomp, REG_VAL_COMP_MINOR_VERSION, NULL,
                                    &dwMinorVersion, &dwDataLength)) == ERROR_SUCCESS)
            {
                if (dwMinorVersion != CUR_DESKHTML_MINOR_VERSION)
                    fStaleInfoInReg = TRUE;
            }
            else
                fStaleInfoInReg = TRUE;
        }
    }
    else
        fStaleInfoInReg = TRUE;

    dwDataLength = sizeof(DWORD);

    //Check the dirty bit to see if we need to re-generate the desktop html
    if ((lRet = SHGetValue(HKEY_CURRENT_USER, (LPCTSTR)lpszDeskcomp, REG_VAL_COMP_GENFLAGS, NULL,
                            &dwFlags, &dwDataLength)) == ERROR_SUCCESS)
    {
        if (IsFlagSet(dwFlags, COMPONENTS_DIRTY))
            fComponentsDirty = TRUE;
        if (IsFlagSet(dwFlags, COMPONENTS_ZOOMDIRTY))
            fComponentsZoomDirty = TRUE;
    }

    // See if we need to add/delete an administrator added desktop component now
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REG_DESKCOMP_ADMINCOMP_ROOT, 0, KEY_READ, &hkey))
    {
        FILETIME ftLast;
        DWORD cbData = SIZEOF(ftLast);
        DWORD dwType;

        ZeroMemory(&ftLast, SIZEOF(ftLast));

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REG_DESKCOMP, 0, KEY_READ, &hkeyTime))
        {
            SHQueryValueEx(hkeyTime, TEXT("LastSyncedTime"), NULL, &dwType, (LPBYTE)&ftLast, &cbData);
            RegCloseKey(hkeyTime);
        }

        RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &ftAdminCompKey);

        if (CompareFileTime(&ftAdminCompKey, &ftLast) == 1) {
            WCHAR wszDisplay[MAX_PATH];
            DWORD dwcch = MAX_PATH;

            if (FAILED(GetScheme(wszDisplay, &dwcch, SCHEME_GLOBAL | SCHEME_DISPLAY)) ||
                     (StrCmpW(wszDisplay, REG_DESKCOMP_SAFEMODE_SUFFIX_L) != 0))
            {
                // We're not in safe mode, it's OK to add the components
                fAdminComponent = TRUE;
            }
        }
    }

    // 99/03/23 #237632 vtan: If the monitor arrangement has been changed from underneath
    // the user (perhaps by another user) then make sure that the components are in valid
    // positions. If not then snap them back into the visible space and mark them as dirty
    // so that the desktop.htt file is regenerated.

    _Initialize();
    if (_hdsaComponent)
    {
        int     i, iComponentCount;;

        iComponentCount = DSA_GetItemCount(_hdsaComponent);
        for (i = 0; i < iComponentCount; ++i)
        {
            COMPONENTA  *pComponent;

            pComponent = reinterpret_cast<COMPONENTA*>(DSA_GetItemPtr(_hdsaComponent, i));
            if (pComponent != NULL)
            {
                bool    bChangedPosition = FALSE, bChangedSize = FALSE;

                if (!SHIsTempDisplayMode()) //Modify the positions only if we are not in a temp mode change.
                    ValidateComponentPosition(&pComponent->cpPos, pComponent->dwCurItemState, pComponent->iComponentType, &bChangedPosition, &bChangedSize);
                if (bChangedPosition || bChangedSize)
                {
                    TBOOL(UpdateComponentPrivate(i, pComponent));
                    fComponentsDirty = true;
                }
            }
        }
    }

    if (FAILED(GetPerUserFileName(szDesktopFile, ARRAYSIZE(szDesktopFile), DESKTOPHTML_FILENAME)))
    {
        szDesktopFile[0] = 0;
    }

    if (fComponentsDirty ||
         fComponentsZoomDirty ||
         fStaleInfoInReg ||
         fAdminComponent ||
         fNoDeskComp != s_fNoDeskComp ||
         fNoWallpaper != s_fNoWallpaper ||
         (dwRestrictUpdate != dwRestrict) ||
         !PathFileExistsAndAttributes(szDesktopFile, NULL))  //See if the file exists!
    {

        // Clear out any html wallpaper if it exists and the restriction is set
        if (fNoWallpaper != s_fNoWallpaper)
        {
            if (fNoWallpaper && !IsWallpaperPicture(_szSelectedWallpaper))
                SetWallpaper(L"", 0);
            s_fNoWallpaper = fNoWallpaper;
        }

        // Disable components if the restriction is set
        if (fNoDeskComp != s_fNoDeskComp)
        {
            // We can't set fEnableComponents to FALSE because there is no way via the UI
            // for the user to turn it back on again if the restriction is lifted.  Instead we add
            // special case code to _GenerateHtml that checks the restriction too.

            // _co.fEnableComponents = !fNoDeskComp; 
            s_fNoDeskComp = fNoDeskComp;
        }

        if (fAdminComponent)
        {
            COMPONENT comp;
            TCHAR pszAdminComp[INTERNET_MAX_URL_LENGTH];
            CHAR szUrl[INTERNET_MAX_URL_LENGTH];
            CHAR * pszUrl;
            CHAR * pszUrlList;
            TCHAR * aszAdminComp[] = {REG_VAL_ADMINCOMP_ADD, REG_VAL_ADMINCOMP_DELETE, NULL};
            int i = 0;

            comp.dwSize = sizeof(comp);
            comp.dwCurItemState = IS_SPLIT | IS_ADJUSTLISTVIEW;

            while (aszAdminComp[i])
            {
                dwDataLength = sizeof(pszAdminComp);
                // The reg value contains an array of space separated urls - currently we support adding and deleting
                // a desktop item via this mechanism.
                if (SHQueryValueEx(hkey, aszAdminComp[i], NULL, NULL, (LPBYTE)pszAdminComp, &dwDataLength) == ERROR_SUCCESS)
                {
                    SHTCharToAnsi(pszAdminComp, szUrl, ARRAYSIZE(szUrl));
                    pszUrlList = szUrl;
                    while (pszUrl = StrTokEx(&pszUrlList, " ")) {
                        SHAnsiToUnicode(pszUrl, comp.wszSource, ARRAYSIZE(comp.wszSource));
                        dwDataLength = ARRAYSIZE(comp.wszSource);
                        ParseURLFromOutsideSourceW(comp.wszSource, comp.wszSource, &dwDataLength, NULL);
                        if (lstrcmp(aszAdminComp[i], REG_VAL_ADMINCOMP_ADD) == 0)
                        {
                            AddUrl(NULL, (LPCWSTR)comp.wszSource, &comp, ADDURL_SILENT);
                            fComponentsZoomDirty = TRUE;
                        }
                        else
                        {
                            RemoveDesktopItem((LPCOMPONENT)&comp, 0);
                        }
                    }
                }
                i++;
            }
            
            SHSetValue(HKEY_CURRENT_USER, REG_DESKCOMP, TEXT("LastSyncedTime"), REG_BINARY, (LPVOID)&ftAdminCompKey, SIZEOF(ftAdminCompKey));

        }

        // Go through the entire list of desktop components and ensure any split/fullscreen
        // components are at their correct size/location.
        if (fComponentsZoomDirty)
        {
            if (_hdsaComponent)
            {
                int i;
                for (i = 0; i < DSA_GetItemCount(_hdsaComponent); i++)
                {
                    COMPONENTA * pcompT;
                
                    if (pcompT = (COMPONENTA *)DSA_GetItemPtr(_hdsaComponent, i))
                    {
                        if (ISZOOMED(pcompT))
                        {
                            BOOL fAdjustListview = (pcompT->dwCurItemState & IS_ADJUSTLISTVIEW);
                            ZoomComponent(&pcompT->cpPos, pcompT->dwCurItemState, fAdjustListview);
                            if (fAdjustListview)
                                pcompT->dwCurItemState &= ~IS_ADJUSTLISTVIEW;
                        }
                    }
                }
                SetDesktopFlags(COMPONENTS_ZOOMDIRTY, 0);
            }
        }

        // NOTE #1: The above initialization would have changed the Z-order because of
        // SortAndRationalize and so we need to APPLY_SAVE here.
        // Warning: APPLY_SAVE changes the dwID field of components. This should not
        // be a problem because we do this just before generating a new HTML file.
        // NOTE #2: Do NOT use AD_APPLY_FORCE here. That sets the _fPatternDirty too and
        // that causes a SystemParametersInfo() call which results in WM_SYSCOLORCHANGE
        // and this causes a refresh. So, we set the dirty bit explicitly here.

        _fDirty = TRUE;  // See Note#2 above.

        ApplyChanges(AD_APPLY_SAVE | AD_APPLY_HTMLGEN);
        lRet = ERROR_SUCCESS;
        if (dwRestrictUpdate != dwRestrict)
            SHSetValue(HKEY_CURRENT_USER, REG_DESKCOMP_COMPONENTS_ROOT, REG_VAL_GENERAL_RESTRICTUPDATE, NULL, &dwRestrict, sizeof(dwRestrict));
    }

    if (hkey)
    {
        RegCloseKey(hkey);
    }

    return (lRet == ERROR_SUCCESS ? S_OK : E_FAIL);
}

//
//  ReReadWallpaper()
//      If the wallpaper was read when the active desktop was disabled, we would have read it from
//  the old location. Now, if the active desktop is turned ON, then we need to re-read the wallpaper
//  from the new location. We need to do this iff the wallpaper has not been changed in the mean-while
//
HRESULT CActiveDesktop::ReReadWallpaper(void)
{
    if ((!_fDirty) || (!_co.fActiveDesktop))  //If nothing has changed OR if active desktop is OFF, 
        return(S_FALSE);                        // then nothing to do!

    //ActiveDesktop is ON in our object. Read current shell state.
    SHELLSTATE ss = {0};
    
    SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);
    if (ss.fDesktopHTML)
        return(S_FALSE);        // Active Desktop state hasn't changed. So, nothing to do!

    //So, Active desktop was originally OFF and now it is turned ON.
    //If if someone changed the wallpaper, we should not mess with it.
    if (_fWallpaperDirty || _fWallpaperChangedDuringInit)
        return(S_FALSE); 

    // No one has changed the wallpaper. So, we must re-read it from the new wallpaper location
    // sothat we get the correct wallpaper for the active desktop mode.
    _ReadWallpaper(TRUE);

    return(S_OK);
}

//
//  GetADObjectFlags()
//
//      Get the Active Desktop object's internal flags
//
HRESULT CActiveDesktop::GetADObjectFlags(LPDWORD lpdwFlags, DWORD dwMask)
{
    ASSERT(lpdwFlags);
    
    *lpdwFlags = 0; //Init the flags
    
    if ((dwMask & GADOF_DIRTY) && _fDirty)
        *lpdwFlags |= GADOF_DIRTY;

    return(S_OK);
}


HRESULT ForceFullRefresh(void)
{
    HWND hwndShell = GetShellWindow();

    //Force a SHRefresh with this dummy call
    SHGetSetSettings(NULL, 0, TRUE);
    SendMessage(hwndShell, DTM_MAKEHTMLCHANGES, (WPARAM)0, (LPARAM)0L);
    //Can't use dynamic html. We have to refresh the whole page.
    SendMessage(hwndShell, WM_WININICHANGE, SPI_SETDESKWALLPAPER, (LPARAM)c_szRefreshDesktop);

    return S_OK;
}


HRESULT CActiveDesktop::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        hr = E_FAIL;

        if (StrCmpIW(pszPropName, c_wszPropName_IgnorePolicies) == 0)
        {
            pVar->vt = VT_BOOL;
            pVar->boolVal = (_fIgnoreAddRemovePolicies ? VARIANT_TRUE : VARIANT_TRUE);
            hr = S_OK;
        }
        else if (StrCmpIW(pszPropName, c_wszPropName_TSPerfBGPolicy) == 0)
        {
            BOOL fPolicySet = (IsTSPerfFlagEnabled(TSPerFlag_NoADWallpaper) || IsTSPerfFlagEnabled(TSPerFlag_NoWallpaper)); //No policy is set!

            pVar->vt = VT_BOOL;
            pVar->boolVal = (fPolicySet ? VARIANT_TRUE : VARIANT_TRUE);
            hr = S_OK;
        }
    }
    
    return hr;
}

HRESULT CActiveDesktop::Write(LPCOLESTR pszPropName, VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        hr = E_FAIL;
    
        if ((StrCmpIW(pszPropName, c_wszPropName_IgnorePolicies) == 0) && (VT_BOOL == pVar->vt))
        {
            _fIgnoreAddRemovePolicies = (VARIANT_TRUE == pVar->boolVal);
            hr = S_OK;
        }
        else if ((StrCmpIW(pszPropName, c_wszPropName_TSPerfBGPolicy) == 0) && (VT_BOOL == pVar->vt))
        {
            ForceFullRefresh();
            hr = S_OK;
        }
    }

    return hr;
}


/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*       copied from iert.lib
*******************************************************************************/

extern "C" char * __cdecl StrTokEx(char ** spstring, const char * scontrol)
{
        unsigned char **pstring = (unsigned char**) spstring;
        unsigned char *control = (unsigned char*) scontrol;

        unsigned char *str;
        const unsigned char *ctrl = control;
        unsigned char map[32];
        int count;

        unsigned char *tokenstr;

        if (*pstring == NULL)
            return NULL;
            
        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = *pstring;
        
        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) ) 
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = str;

        /* Determine if a token has been found. */
        if ( tokenstr == str )
            return NULL;
        else
            return (char*)tokenstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\desktop.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "bitbuck.h"
#include <iethread.h>
#include "apithk.h"
#include "mtpt.h"
#include "..\util.h"
#include "fassoc.h"
#include "..\filetbl.h"

#define DM_FOCUS        0           // focus
#define DM_SHUTDOWN     DM_TRACE    // shutdown 
#define TF_SHDAUTO      0
#define DM_MISC         DM_TRACE    // misc/tmp

#define IDT_STARTBACKGROUNDSHELLTASKS 7
#define IDT_TASKBARWAKEUP 8

#define ENABLE_CHANNELS

#define DESKTOPCLASS        

#ifdef FEATURE_STARTPAGE
typedef BOOL (*PeekMessageEx)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg, void * pvReserved);

PeekMessageEx pPeekEx = NULL;
#endif

STDAPI_(void) CheckWinIniForAssocs();

BOOL GetOldWorkAreas(LPRECT lprc, DWORD* pdwNoOfOldWA);
void SaveOldWorkAreas(LPCRECT lprc, DWORD nOldWA);

BOOL UpdateAllDesktopSubscriptions(IADesktopP2 *);

//This is in deskreg.cpp
BOOL AdjustDesktopComponents(LPCRECT prcNewWorkAreas, int nNewWorkAreas, 
                             LPCRECT prcOldMonitors, LPCRECT prcOldWorkAreas, int nOldWorkAreas);

// in defview.cpp
BOOL IsFolderWindow(HWND hwnd);

// copied from tray.c if changing here, change there also
#define GHID_FIRST 500

#define g_xVirtualScreen GetSystemMetrics(SM_XVIRTUALSCREEN)
#define g_yVirtualScreen GetSystemMetrics(SM_YVIRTUALSCREEN)
#define g_cxVirtualScreen GetSystemMetrics(SM_CXVIRTUALSCREEN)
#define g_cyVirtualScreen GetSystemMetrics(SM_CYVIRTUALSCREEN)
#define g_cxEdge GetSystemMetrics(SM_CXEDGE)
#define g_cyEdge GetSystemMetrics(SM_CYEDGE)

//  TOID_Desktop 6aec6a60-b7a4-11d1-be89-0000f805ca57 is the id for ShellTasks added by the desktop 
const GUID TOID_Desktop = { 0x6aec6a60, 0xb7a4, 0x11d1, {0xbe, 0x89, 0x00, 0x00, 0xf8, 0x05, 0xca, 0x57} };


// these are the CLSIDs that are supported for creating LocalServer thread
// objects.   the shell supports these in the RunDll32 and then the
// invocation of a thread on the desktop object.

CLSID const *c_localServers[] = 
{
    &CLSID_ShellDesktop,
    &CLSID_NetCrawler,
    &CLSID_HWShellExecute,
    &CLSID_ShellAutoplay,
};

typedef struct 
{
    INT iLocalServer;                   // index into the local server table
    DWORD *pdwThreadID;                 // where to stash the thread id
} LOCALSERVERDATA;


// Private interface to talk to explorer.exe
IDeskTray* g_pdtray = NULL;

void FireEventSz(LPCTSTR szEvent)
{
    HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, szEvent);
    if (hEvent)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
}

#define PERF_ENABLESETMARK
#ifdef PERF_ENABLESETMARK
void DoSetMark(LPCSTR pszMark, ULONG cbSz);
#define PERFSETMARK(text)   DoSetMark(text, sizeof(text))
#else
#define PERFSETMARK(text)
#endif  // PERF_ENABLESETMARK


#ifdef PERF_ENABLESETMARK
#include <wmistr.h>
#include <ntwmi.h>  // PWMI_SET_MARK_INFORMATION is defined in ntwmi.h
#include <wmiumkm.h>
#define NTPERF
#include <ntperf.h>

void DoSetMark(LPCSTR pszMark, ULONG cbSz)
{
    PWMI_SET_MARK_INFORMATION MarkInfo;
    HANDLE hTemp;
    ULONG cbBufferSize;
    ULONG cbReturnSize;

    cbBufferSize = FIELD_OFFSET(WMI_SET_MARK_INFORMATION, Mark) + cbSz;

    MarkInfo = (PWMI_SET_MARK_INFORMATION) LocalAlloc(LPTR, cbBufferSize);

    // Failed to init, no big deal
    if (MarkInfo == NULL)
        return;

    BYTE *pMarkBuffer = (BYTE *) (&MarkInfo->Mark[0]);

    memcpy(pMarkBuffer, pszMark, cbSz);

    // WMI_SET_MARK_WITH_FLUSH will flush the working set when setting the mark
    MarkInfo->Flag = PerformanceMmInfoMark;

    hTemp = CreateFile(WMIDataDeviceName,
                           GENERIC_READ | GENERIC_WRITE,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL |
                           FILE_FLAG_OVERLAPPED,
                           NULL);

    if (hTemp != INVALID_HANDLE_VALUE)
    {
        // here's the piece that actually puts the mark in the buffer
        BOOL fIoctlSuccess = DeviceIoControl(hTemp,
                                       IOCTL_WMI_SET_MARK,
                                       MarkInfo,
                                       cbBufferSize,
                                       NULL,
                                       0,
                                       &cbReturnSize,
                                       NULL);

        CloseHandle(hTemp);
    }
    LocalFree(MarkInfo);
}
#endif  // PERF_ENABLESETMARK


// MISC stuff duplicated in browseui {
HRESULT _ConvertPathToPidlW(IBrowserService2 *pbs, HWND hwnd, LPCWSTR pszPath, LPITEMIDLIST * ppidl)
{
    WCHAR wszCmdLine[MAX_URL_STRING]; // must be with pszPath
    TCHAR szFixedUrl[MAX_URL_STRING];
    TCHAR szParsedUrl[MAX_URL_STRING] = {'\0'};
    DWORD dwUrlLen = ARRAYSIZE(szParsedUrl);

    // Copy the command line into a temporary buffer
    // so we can remove the surrounding quotes (if 
    // they exist)
    SHUnicodeToTChar(pszPath, szFixedUrl, ARRAYSIZE(szFixedUrl));
    PathUnquoteSpaces(szFixedUrl);
    
    if (ParseURLFromOutsideSource(szFixedUrl, szParsedUrl, &dwUrlLen, NULL))
        SHTCharToUnicode(szParsedUrl, wszCmdLine, ARRAYSIZE(wszCmdLine));
    else
        StrCpyNW(wszCmdLine, pszPath, ARRAYSIZE(wszCmdLine));
    
    HRESULT hr = pbs->IEParseDisplayName(CP_ACP, wszCmdLine, ppidl);
    pbs->DisplayParseError(hr, wszCmdLine);
    return hr;
}
// END of MISC stuff duplicated in browseui }

// Several places rely on the fact that IShellBrowser is the first interface
// we inherit (and therefore is what we use as our canonical IUnknown).
// Grep for IUnknownIdentity to find them.

class CDesktopBrowser :
    public IShellBrowser
   ,public IServiceProvider
   ,public IOleCommandTarget
   ,public IDockingWindowSite
   ,public IInputObjectSite
   ,public IDropTarget
   ,public IDockingWindowFrame
   ,public IMultiMonitorDockingSite
   ,public IBrowserService2
   ,public IShellBrowserService
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void * *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IShellBrowser (same as IOleInPlaceFrame)
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
    virtual STDMETHODIMP InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    virtual STDMETHODIMP SetMenuSB(HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd);
    virtual STDMETHODIMP RemoveMenusSB(HMENU hmenuShared);
    virtual STDMETHODIMP SetStatusTextSB(LPCOLESTR lpszStatusText);
    virtual STDMETHODIMP EnableModelessSB(BOOL fEnable);
    virtual STDMETHODIMP TranslateAcceleratorSB(LPMSG lpmsg, WORD wID);
    virtual STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);
    virtual STDMETHODIMP GetViewStateStream(DWORD grfMode, LPSTREAM  *ppStrm);
    virtual STDMETHODIMP GetControlWindow(UINT id, HWND * lphwnd);
    virtual STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    virtual STDMETHODIMP QueryActiveShellView(struct IShellView ** ppshv);
    virtual STDMETHODIMP OnViewWindowActive(struct IShellView * ppshv);
    virtual STDMETHODIMP SetToolbarItems(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);

    // IServiceProvider
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IDockingWindowSite (also IOleWindow)
    virtual STDMETHODIMP GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder);
    virtual STDMETHODIMP RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);
    virtual STDMETHODIMP SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);

    // IInputObjectSite
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

    // IDropTarget
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IDockingWindowFrame (also IOleWindow)
    virtual STDMETHODIMP AddToolbar(IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwReserved);
    virtual STDMETHODIMP RemoveToolbar(IUnknown* punkSrc, DWORD dwFlags);
    virtual STDMETHODIMP FindToolbar(LPCWSTR pwszItem, REFIID riid, void **ppvObj);

    // IMultiMonitorDockingSite
    virtual STDMETHODIMP GetMonitor(IUnknown* punkSrc, HMONITOR * phMon);
    virtual STDMETHODIMP RequestMonitor(IUnknown* punkSrc, HMONITOR * phMon);
    virtual STDMETHODIMP SetMonitor(IUnknown* punkSrc, HMONITOR hMon, HMONITOR * phMonOld);
    
    static LRESULT CALLBACK DesktopWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK RaisedWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    void _MessageLoop();
    HWND GetTrayWindow(void) { return _hwndTray; }
    HWND GetDesktopWindow(void) { return _pbbd->_hwnd; }

    // IBrowserService
    // *** IBrowserService specific methods ***
    virtual STDMETHODIMP GetParentSite(IOleInPlaceSite** ppipsite);
    virtual STDMETHODIMP SetTitle(IShellView* psv, LPCWSTR pszName);
    virtual STDMETHODIMP GetTitle(IShellView* psv, LPWSTR pszName, DWORD cchName);
    virtual STDMETHODIMP GetOleObject( IOleObject** ppobjv);
    virtual STDMETHODIMP GetTravelLog(ITravelLog** pptl);
    virtual STDMETHODIMP ShowControlWindow(UINT id, BOOL fShow);
    virtual STDMETHODIMP IsControlWindowShown(UINT id, BOOL *pfShown);
    virtual STDMETHODIMP IEGetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags);
    virtual STDMETHODIMP IEParseDisplayName(UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut);
    virtual STDMETHODIMP DisplayParseError(HRESULT hres, LPCWSTR pwszPath);
    virtual STDMETHODIMP NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF);
    virtual STDMETHODIMP SetNavigateState(BNSTATE bnstate);
    virtual STDMETHODIMP GetNavigateState (BNSTATE *pbnstate);
    virtual STDMETHODIMP NotifyRedirect ( IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse);
    virtual STDMETHODIMP UpdateWindowList ();
    virtual STDMETHODIMP UpdateBackForwardState ();
    virtual STDMETHODIMP SetFlags(DWORD dwFlags, DWORD dwFlagMask);
    virtual STDMETHODIMP GetFlags(DWORD *pdwFlags);
    virtual STDMETHODIMP CanNavigateNow ();
    virtual STDMETHODIMP GetPidl(LPITEMIDLIST *ppidl);
    virtual STDMETHODIMP SetReferrer (LPITEMIDLIST pidl);
    virtual STDMETHODIMP_(DWORD) GetBrowserIndex();
    virtual STDMETHODIMP GetBrowserByIndex(DWORD dwID, IUnknown **ppunk);
    virtual STDMETHODIMP GetHistoryObject(IOleObject **ppole, IStream **pstm, IBindCtx **ppbc);
    virtual STDMETHODIMP SetHistoryObject(IOleObject *pole, BOOL fIsLocalAnchor);
    virtual STDMETHODIMP CacheOLEServer(IOleObject *pole);
    virtual STDMETHODIMP GetSetCodePage(VARIANT* pvarIn, VARIANT* pvarOut);
    virtual STDMETHODIMP OnHttpEquiv(IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut);
    virtual STDMETHODIMP GetPalette( HPALETTE * hpal);
    virtual STDMETHODIMP RegisterWindow(BOOL fUnregister, int swc);
    virtual STDMETHODIMP_(LRESULT) WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP OnSize(WPARAM wParam);
    virtual STDMETHODIMP OnCreate(LPCREATESTRUCT pcs);
    virtual STDMETHODIMP_(LRESULT) OnCommand(WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP OnDestroy();
    virtual STDMETHODIMP_(LRESULT) OnNotify(NMHDR * pnm);
    virtual STDMETHODIMP OnSetFocus();
    virtual STDMETHODIMP OnFrameWindowActivateBS(BOOL fActive);
    virtual STDMETHODIMP ReleaseShellView();
    virtual STDMETHODIMP ActivatePendingView();
    virtual STDMETHODIMP CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd);
    virtual STDMETHODIMP GetBaseBrowserData(LPCBASEBROWSERDATA* ppbd);
    virtual STDMETHODIMP_(LPBASEBROWSERDATA) PutBaseBrowserData();
    virtual STDMETHODIMP SetAsDefFolderSettings() { ASSERT(FALSE); return E_NOTIMPL;}
    virtual STDMETHODIMP SetTopBrowser();
    virtual STDMETHODIMP UpdateSecureLockIcon(int eSecureLock);
    virtual STDMETHODIMP Offline(int iCmd);
    virtual STDMETHODIMP InitializeDownloadManager();
    virtual STDMETHODIMP InitializeTransitionSite();
    virtual STDMETHODIMP GetFolderSetData(struct tagFolderSetData* pfsd) { *pfsd = _fsd; return S_OK; };
    virtual STDMETHODIMP _OnFocusChange(UINT itb);
    virtual STDMETHODIMP v_ShowHideChildWindows(BOOL fChildOnly);
    virtual STDMETHODIMP CreateBrowserPropSheetExt(THIS_ REFIID riid, void **ppvObj);
    virtual STDMETHODIMP SetActivateState(UINT uActivate);
    virtual STDMETHODIMP AllowViewResize(BOOL f);
    virtual STDMETHODIMP _Initialize(HWND hwnd, IUnknown *pauto);
    virtual STDMETHODIMP_(UINT) _get_itbLastFocus();
    virtual STDMETHODIMP _put_itbLastFocus(UINT itbLastFocus);
    virtual STDMETHODIMP _UIActivateView(UINT uState);
    virtual STDMETHODIMP _CancelPendingNavigationAsync();
    virtual STDMETHODIMP _MaySaveChanges(); 
    virtual STDMETHODIMP _PauseOrResumeView(BOOL fPaused);
    virtual STDMETHODIMP _DisableModeless();
    virtual STDMETHODIMP _NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags);
    virtual STDMETHODIMP _TryShell2Rename(IShellView* psv, LPCITEMIDLIST pidlNew);
    virtual STDMETHODIMP _SwitchActivationNow();
    virtual STDMETHODIMP _CancelPendingView();
    virtual STDMETHODIMP _ExecChildren(IUnknown *punkBar, BOOL fBroadcast,
        const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    virtual STDMETHODIMP _SendChildren(HWND hwndBar, BOOL fBroadcast,
        UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP v_MayGetNextToolbarFocus(LPMSG lpMsg, UINT itbNext, int citb, LPTOOLBARITEM * pptbi, HWND * phwnd);
    virtual STDMETHODIMP _SetFocus(LPTOOLBARITEM ptbi, HWND hwnd, LPMSG lpMsg) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP _GetViewBorderRect(RECT* prc);
    virtual STDMETHODIMP _UpdateViewRectSize();
    virtual STDMETHODIMP _ResizeNextBorder(UINT itb);
    virtual STDMETHODIMP _ResizeView();
    virtual STDMETHODIMP _GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon);
    virtual STDMETHODIMP GetCurrentFolderSettings(DEFFOLDERSETTINGS *pdfs, int cbDfs) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP GetViewRect(RECT* prc);
    virtual STDMETHODIMP GetViewWindow(HWND * phwndView);
    virtual STDMETHODIMP InitializeTravelLog(ITravelLog* ptl, DWORD dw);

        //IShellBrowserService
    virtual STDMETHODIMP GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv);

    // Desktop needs to override these:
    virtual STDMETHODIMP_(IStream*) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName);
    
    // Desktop needs access to these:
    virtual STDMETHODIMP_(LRESULT) ForwardViewMsg(UINT uMsg, WPARAM wParam, LPARAM lParam) { ASSERT(FALSE); return 0; };
    virtual STDMETHODIMP SetAcceleratorMenu(HACCEL hacc) { ASSERT(FALSE); return E_FAIL; }
    virtual STDMETHODIMP_(int) _GetToolbarCount(THIS) { ASSERT(FALSE); return 0; }
    virtual STDMETHODIMP_(LPTOOLBARITEM) _GetToolbarItem(THIS_ int itb) { ASSERT(FALSE); return NULL; }
    virtual STDMETHODIMP _SaveToolbars(IStream* pstm) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP _LoadToolbars(IStream* pstm) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP _CloseAndReleaseToolbars(BOOL fClose) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP_(UINT) _FindTBar(IUnknown* punkSrc) { ASSERT(FALSE); return (UINT)-1; };
    virtual STDMETHODIMP v_MayTranslateAccelerator(MSG* pmsg) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP _GetBorderDWHelper(IUnknown* punkSrc, LPRECT lprectBorder, BOOL bUseHmonitor) { ASSERT(FALSE); return E_NOTIMPL; }

    // Shell browser overrides this.
    virtual STDMETHODIMP v_CheckZoneCrossing(LPCITEMIDLIST pidl) {return S_OK;};

    // Desktop and basesb need access to these:
    virtual STDMETHODIMP _ResizeNextBorderHelper(UINT itb, BOOL bUseHmonitor);

    //  it just for us of course!
    void StartBackgroundShellTasks(void);
    void TaskbarWakeup(void);

#ifdef FEATURE_STARTPAGE
    // For Start Page
    HWND GetViewWnd() { return _GetDesktopListview(); }
    void SetStartPageHWND(HWND hwnd) { _hwndStartPage = hwnd; }
#endif

protected:
    CDesktopBrowser();
    ~CDesktopBrowser();

    friend HRESULT CDesktopBrowser_CreateInstance(HWND hwnd, void **ppsb);
    HRESULT SetInner(IUnknown* punk);

    long _cRef;
    
    // cached pointers on inner object
    IUnknown* _punkInner;
    IBrowserService2* _pbsInner;
    IShellBrowser* _psbInner;
    IServiceProvider* _pspInner;
    IOleCommandTarget* _pctInner;
    IDockingWindowSite* _pdwsInner;
    IDockingWindowFrame* _pdwfInner;
    IInputObjectSite* _piosInner;
    IDropTarget* _pdtInner;

    LPCBASEBROWSERDATA _pbbd;

    LRESULT _RaisedWndProc(UINT msg, WPARAM wParam, LPARAM lParam);

    void _SetViewArea();

    void _GetViewBorderRects(int nRects, LPRECT prc);  // does not have the tool bars
    void _SetWorkAreas(int nWorkAreas, RECT * prcWork);
    
    void _SubtractBottommostTray(LPRECT prc);
    void _SaveState();
    void _InitDeskbars();
    void _SaveDesktopToolbars();
    
    void _OnRaise(WPARAM wParam, LPARAM lParam);
    void _SetupAppRan(WPARAM wParam, LPARAM lParam);
    BOOL _QueryHKCRChanged(HWND hwnd, LPDWORD pdwCookie);
    void _Lower();
    void _Raise();
    void _SwapParents(HWND hwndOldParent, HWND hwndNewParent);
    
    BOOL _OnCopyData(PCOPYDATASTRUCT pcds);
    void _OnAddToRecent(HANDLE hMem, DWORD dwProcId);
    BOOL _InitScheduler(void);
    HRESULT _AddDesktopTask(IRunnableTask *ptask, DWORD dwPriority);

    BOOL _PtOnDesktopEdge(POINTL* ppt, LPUINT puEdge);
#ifdef DEBUG
    void _CreateDeskbars();
#endif

    HRESULT _CreateDeskBarForBand(UINT uEdge, IUnknown *punk, POINTL *pptl, IBandSite **pbs);

    virtual void    v_PropagateMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend);
    HRESULT _OnFocusMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    HRESULT _CreateDesktopView();
    HRESULT _GetPropertyBag(LPCITEMIDLIST pidl, DWORD dwFlags, REFIID riid, void** ppv);
    HWND _GetDesktopListview();
    UINT _PeekForAMessage();
    
    void _InitMonitors();  

#ifdef ENABLE_CHANNELS
    void _MaybeLaunchChannelBand(void);
#endif
    
    virtual void    _ViewChange(DWORD dwAspect, LONG lindex);

    HWND _hwndTray;
    int _iWaitCount;
    ULONG _uNotifyID;
    DWORD _dwThreadIdTray; // Used to wakeup tray thread when the machine is really stressed
    int _iTrayPriority;

    
    DWORD _grfKeyState;
    DWORD _dwEffectOnEdge; // what's the drop effect that desktop should return on dragging over the edge
    
    BOOL _fRaised;
    HWND _hwndRaised;  // this is the parent of all of desktop's children when raised

    struct tagFolderSetData _fsd;

    int _nMonitors;                         // number of monitors on this desktop
    HMONITOR _hMonitors[LV_MAX_WORKAREAS]; // the order of these hmonitors need to be preserved
    RECT _rcWorkArea;       // cached work-area
    RECT _rcOldWorkAreas[LV_MAX_WORKAREAS];  // Old work areas before settings change
    DWORD _nOldWork;
    RECT _rcOldMonitors[LV_MAX_WORKAREAS];  // Old monitor sizes before settings change

    //  for _OnAddToRecent()
    IShellTaskScheduler *_psched;

    DWORD _idLocalServerThreads[ARRAYSIZE(c_localServers)];

    DWORD _cChangeEvents;
    HANDLE _rghChangeEvents[2];  // we watch HKCR and HKCR\CLSID 
    DWORD _dwChangeCookie;
    DWORD _rgdwQHKCRCookies[QHKCRID_MAX - QHKCRID_MIN];
    HKEY _hkClsid;

    WCHAR _wzDesktopTitle[64];  // Localized Title 

#ifdef FEATURE_STARTPAGE
    HWND    _hwndStartPage;
#endif
    //  IUnknownIdentity - for uniformity w.r.t. aggregation
    //  We are not aggregatable, so we are our own Outer.
    IUnknown *_GetOuter() { return SAFECAST(this, IShellBrowser*); }

};

HRESULT CDesktopBrowser_CreateInstance(HWND hwnd, void **ppsb)
{
    HRESULT hr = E_OUTOFMEMORY;
    CDesktopBrowser *pdb = new CDesktopBrowser();

    if (pdb)
    {
        hr = pdb->_Initialize(hwnd, NULL);      // aggregation, etc.
        if (FAILED(hr))
            ATOMICRELEASE(pdb);
    }
    
    *ppsb = pdb;
    return hr;
}

CDesktopBrowser::CDesktopBrowser() : _cRef(1)
{
    TraceMsg(TF_LIFE, "ctor CDesktopBrowser %x", this);

    for (INT i = 0; i < ARRAYSIZE(_idLocalServerThreads); i++)
        _idLocalServerThreads[i] = -1;
}

CDesktopBrowser::~CDesktopBrowser()
{
    SaveOldWorkAreas(_rcOldWorkAreas, _nOldWork);

    //  cleanup for QueryHKCRChanged()
    for (int i = 0; i < ARRAYSIZE(_rghChangeEvents); i++)
    {
        if (_rghChangeEvents[i])
            CloseHandle(_rghChangeEvents[i]);
    }

    if (_hkClsid)
        RegCloseKey(_hkClsid);

    // close down the local server threads that may be running 
    for (i = 0; i < ARRAYSIZE(_idLocalServerThreads); i++)
    {
        if (_idLocalServerThreads[i] != -1)
            PostThreadMessage(_idLocalServerThreads[i], WM_QUIT, 0, 0);
    }

    TraceMsg(TF_LIFE, "dtor CDesktopBrowser %x", this);
}


HRESULT CDesktopBrowser::_Initialize(HWND hwnd, IUnknown* pauto)
{
    IUnknown* punk;
    
    HRESULT hres = CoCreateInstance(CLSID_CCommonBrowser, _GetOuter(), CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hres))
    {
        hres = SetInner(punk); // paired w/ Release in outer (TBS::Release)
        if (SUCCEEDED(hres))
        {
            // we must initialize the inner guy BEFORE we call through any of these pointers.
            hres = _pbsInner->_Initialize(hwnd, pauto);
            if (SUCCEEDED(hres))
            {
                _pbsInner->GetBaseBrowserData(&_pbbd);
                ASSERT(_pbbd);
            
                // Restore the old settings from the registry that we persist.
                if (!GetOldWorkAreas(_rcOldWorkAreas, &_nOldWork) || _nOldWork == 0)
                {
                    // We didn't find it in the registry
                    _nOldWork = 0;  // Since this is 0, we don't have to set _rcOldWorkAreas.
                    //We will recover from this in _SetWorkAreas()
                }
            
                SetTopBrowser();
                _put_itbLastFocus(ITB_VIEW);    // focus on desktop (w95 compat)
            
                HACCEL hacc = LoadAccelerators(HINST_THISDLL, MAKEINTRESOURCE(ACCEL_DESKTOP));
                ASSERT(hacc);
                _pbsInner->SetAcceleratorMenu(hacc);
            
                // Perf: never fire events from the desktop.
                ASSERT(_pbbd->_pautoEDS);
                ATOMICRELEASE(const_cast<IExpDispSupport *>(_pbbd->_pautoEDS));
            
                _InitMonitors();
            
                // Initialise _rcOldMonitors
                for (int i = 0; i < _nMonitors; i++)
                {
                    GetMonitorRect(_hMonitors[i], &_rcOldMonitors[i]);
                }
                //  NOTE:  if we have any more keys to watch, then 
                //  we should create a static struct to walk
                //  so that it is easier to add more event/key pairs
                _rghChangeEvents[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
                _rghChangeEvents[1] = CreateEvent(NULL, TRUE, FALSE, NULL);
                if (_rghChangeEvents[0] && _rghChangeEvents[1])
                {
                    if (ERROR_SUCCESS == RegNotifyChangeKeyValue(HKEY_CLASSES_ROOT, TRUE, 
                        REG_NOTIFY_CHANGE_LAST_SET  |REG_NOTIFY_CHANGE_NAME, _rghChangeEvents[0], TRUE))
                    {
                        _cChangeEvents = 1;
                        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, MAXIMUM_ALLOWED, &_hkClsid)
                        &&  ERROR_SUCCESS == RegNotifyChangeKeyValue(_hkClsid, TRUE, REG_NOTIFY_CHANGE_LAST_SET |REG_NOTIFY_CHANGE_NAME, _rghChangeEvents[1], TRUE))
                        {
                            //  we need to leave the key open, 
                            //  or the event is signaled right away
                            _cChangeEvents++;
                        }
                    }
                }
            }

        }
    } 
    
    return hres;
}


//
//  The refcount in the punk is transferred to us.  We do not need to
//  and indeed should not AddRef it.
//
//  If any of these steps fails, we will clean up in our destructor.
//
HRESULT CDesktopBrowser::SetInner(IUnknown* punk)
{
    HRESULT hres;

    ASSERT(_punkInner == NULL);

    _punkInner = punk;

#define INNERCACHE(iid, p) do { \
    hres = SHQueryInnerInterface(_GetOuter(), punk, iid, (void **)&p); \
    if (!EVAL(SUCCEEDED(hres))) return E_FAIL; \
    } while (0)

    INNERCACHE(IID_IBrowserService2, _pbsInner);
    INNERCACHE(IID_IShellBrowser, _psbInner);
    INNERCACHE(IID_IServiceProvider, _pspInner);
    INNERCACHE(IID_IOleCommandTarget, _pctInner);
    INNERCACHE(IID_IDockingWindowSite, _pdwsInner);
    INNERCACHE(IID_IDockingWindowFrame, _pdwfInner);
    INNERCACHE(IID_IInputObjectSite, _piosInner);
    INNERCACHE(IID_IDropTarget, _pdtInner);

#undef INNERCACHE

    return S_OK;
}

ULONG CDesktopBrowser::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDesktopBrowser::Release()
{
    ASSERT(_cRef > 0);
    
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    _cRef = 1000;               // guard against recursion

    RELEASEINNERINTERFACE(_GetOuter(), _pbsInner);
    RELEASEINNERINTERFACE(_GetOuter(), _psbInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pspInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pctInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pdwsInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pdwfInner);
    RELEASEINNERINTERFACE(_GetOuter(), _piosInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pdtInner);

    // this must come last
    ATOMICRELEASE(_punkInner); // paired w/ CCI aggregation
    
    ASSERT(_cRef == 1000);

    delete this;
    return 0;
}

HRESULT CDesktopBrowser::QueryInterface(REFIID riid, void **ppvObj)
{
    // IUnknownIdentity - The interface we use for IUnknown must come first.
    static const QITAB qit[] = {
        QITABENT(CDesktopBrowser, IShellBrowser),
        QITABENT(CDesktopBrowser, IBrowserService2),
        QITABENTMULTI(CDesktopBrowser, IBrowserService, IBrowserService2),
        QITABENTMULTI(CDesktopBrowser, IOleWindow, IShellBrowser),
        QITABENTMULTI2(CDesktopBrowser, SID_SShellDesktop, IShellBrowser), // effectively an IUnknown supported only by this class
        QITABENT(CDesktopBrowser, IServiceProvider),
        QITABENT(CDesktopBrowser, IShellBrowserService),
        QITABENT(CDesktopBrowser, IOleCommandTarget),
        QITABENT(CDesktopBrowser, IDockingWindowSite),
        QITABENT(CDesktopBrowser, IInputObjectSite),
        QITABENT(CDesktopBrowser, IMultiMonitorDockingSite),
        QITABENT(CDesktopBrowser, IDropTarget),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres)) 
    {
        if (_punkInner)
        {
            // don't let these get through to our base class...
            // IID_IOleCommandTarget, IID_IOleInPlaceUIWindow
            // 970414 adp: spoke to SatoNa, these *can* go thru
            // i'll remove this week
            // It's been working like this for a while now.
            if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
            {
                *ppvObj = NULL;
                hres = E_NOINTERFACE;
            }
            else
            {
                hres = _punkInner->QueryInterface(riid, ppvObj);
            }
        }
    }
    
    return hres;
}


void _InitDesktopMetrics(WPARAM wParam, LPCTSTR pszSection)
{
    BOOL fForce = (!pszSection || !*pszSection);

    if (fForce || (wParam == SPI_SETNONCLIENTMETRICS) || !lstrcmpi(pszSection, TEXT("WindowMetrics")))
    {
        FileIconInit(TRUE); // Tell the shell we want to play with a full deck
    }
}

typedef struct
{
    int iMonitors;
    HMONITOR * phMonitors;
} EnumMonitorsData;

BOOL CALLBACK MultiMonEnumCallBack(HMONITOR hMonitor, HDC hdc, LPRECT lprc, LPARAM lData)
{
    EnumMonitorsData * pEmd = (EnumMonitorsData *)lData;
    
    if (pEmd->iMonitors > LV_MAX_WORKAREAS - 1)
        //ignore the other monitors because we can only handle up to LV_MAX_WORKAREAS
        //REARCHITECT: should we dynamically allocated this?
        return FALSE;

    pEmd->phMonitors[pEmd->iMonitors++] = hMonitor;
    return TRUE;
}

// Initialize the number of monitors and the hmonitors array

void CDesktopBrowser::_InitMonitors()
{
    HMONITOR hMonPrimary = GetPrimaryMonitor();
    
    EnumMonitorsData emd;
    emd.iMonitors = 0;
    emd.phMonitors = _hMonitors;

    EnumDisplayMonitors(NULL, NULL, MultiMonEnumCallBack, (LPARAM)&emd);
    _nMonitors = GetNumberOfMonitors();
    
    // Always move the primary monitor to the first location.
    if (_hMonitors[0] != hMonPrimary)
    {
        for (int iMon = 1; iMon < _nMonitors; iMon++)
        {
            if (_hMonitors[iMon] == hMonPrimary)
            {
                _hMonitors[iMon] = _hMonitors[0];
                _hMonitors[0] = hMonPrimary;
                break;
            }
        }
    }
}

// Gets the persisted old work areas, from the registry
BOOL GetOldWorkAreas(LPRECT lprc, DWORD* pdwNoOfOldWA)
{
    BOOL fRet = FALSE;
    *pdwNoOfOldWA = 0;
    HKEY hkey;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_DESKCOMP_OLDWORKAREAS, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD dwType, cbSize = sizeof(*pdwNoOfOldWA);
        // Read in the no of old work areas
        if (SHQueryValueEx(hkey, REG_VAL_OLDWORKAREAS_COUNT, NULL, &dwType, (LPBYTE)pdwNoOfOldWA, &cbSize) == ERROR_SUCCESS)
        {
            // Read in the old work area rects
            cbSize = sizeof(*lprc) * (*pdwNoOfOldWA);
            if (SHQueryValueEx(hkey, REG_VAL_OLDWORKAREAS_RECTS, NULL, &dwType, (LPBYTE)lprc, &cbSize) == ERROR_SUCCESS)
            {
                fRet = TRUE;
            }
        }
        RegCloseKey(hkey);
    }
    return fRet;
}
        
// Saves the old work areas into the registry
void SaveOldWorkAreas(LPCRECT lprc, DWORD nOldWA)
{
    // Recreate the registry key.
    HKEY hkey;
    if (RegCreateKey(HKEY_CURRENT_USER, REG_DESKCOMP_OLDWORKAREAS, &hkey) == ERROR_SUCCESS)
    {
        // Write out the no. of old work areas
        RegSetValueEx(hkey, REG_VAL_OLDWORKAREAS_COUNT, 0, REG_DWORD, (LPBYTE)&nOldWA, sizeof(nOldWA));
        // Write out the no work area rectangles
        RegSetValueEx(hkey, REG_VAL_OLDWORKAREAS_RECTS, 0, REG_BINARY, (LPBYTE)lprc, sizeof(*lprc) * nOldWA);
        // Close out the reg key
        RegCloseKey(hkey);
    }
}

//***   CDesktopBrowser::IOleCommandTarget::* {

STDMETHODIMP CDesktopBrowser::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDesktopBrowser::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) 
    {
        /*NOTHING*/
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        case SHDVID_RAISE:
            // n.b.: DTRF_RAISE/DTRF_LOWER go down; DTRF_QUERY goes up
            ASSERT(pvarargIn != NULL && pvarargIn->vt == VT_I4);
            if (pvarargIn->vt == VT_I4 && pvarargIn->lVal == DTRF_QUERY) 
            {
                ASSERT(pvarargOut != NULL);
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = _fRaised ? DTRF_RAISE : DTRF_LOWER;
                return S_OK;
            }
            // o.w. let parent handle it
            break;

        case SHDVID_UPDATEOFFLINEDESKTOP:
            UpdateAllDesktopSubscriptions(NULL);
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup)) 
    {
        switch (nCmdID)
        {
        case SBCMDID_OPTIONS:
        case SBCMDID_ADDTOFAVORITES:
            return _pctInner->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
    }

    // do *not* forward up to SUPERCLASS::Exec (see QI's cryptic commment
    // about "don't let these get thru to our base class")
    return OLECMDERR_E_NOTSUPPORTED;
}

// }

STDMETHODIMP CDesktopBrowser::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    // Force SBSP_NEWBROWSER, SBSP_ABSOLUTE, and SBSP_NOTRANSFERHIST
    wFlags &= ~(SBSP_DEFBROWSER | SBSP_SAMEBROWSER | SBSP_RELATIVE | SBSP_PARENT);
    wFlags |= (SBSP_NEWBROWSER | SBSP_ABSOLUTE | SBSP_NOTRANSFERHIST);
    return _psbInner->BrowseObject(pidl, wFlags);
}

IStream *GetDesktopViewStream(DWORD grfMode, LPCTSTR pszName)
{
    HKEY hkStreams;

    if (RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\Streams"), &hkStreams) == ERROR_SUCCESS)
    {
        IStream *pstm = OpenRegStream(hkStreams, TEXT("Desktop"), pszName, grfMode);
        RegCloseKey(hkStreams);
        return pstm;
    }
    return NULL;
}

void DeleteDesktopViewStream(LPCTSTR pszName)
{
    SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\Streams\\Desktop"), pszName);
}

IStream *CDesktopBrowser::v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pszName)
{
    return GetDesktopViewStream(grfMode, pszName);
}

HRESULT CDesktopBrowser::_GetPropertyBag(LPCITEMIDLIST pidl, DWORD dwFlags, REFIID riid, void** ppv)
{
    return SHGetViewStatePropertyBag(pidl, VS_BAGSTR_DESKTOP, dwFlags | SHGVSPB_ROAM, riid, ppv);
}

HRESULT CDesktopBrowser::GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv)
{
    HRESULT hr;

    LPITEMIDLIST pidl;
    hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP, &pidl);

    if (SUCCEEDED(hr))
    {
        hr = _GetPropertyBag(pidl, dwFlags, riid, ppv);

        ILFree(pidl);
    }

    return hr;
}

LRESULT CDesktopBrowser::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
    case FCIDM_FINDFILES:
        SHFindFiles(_pbbd->_pidlCur, NULL);
        break;
        
    case FCIDM_REFRESH:
    {
        VARIANT v = {0};
        v.vt = VT_I4;
        v.lVal = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_PROMPTIFOFFLINE;
        // Our Exec is neutered (on purpose), so call our parent
        _pctInner->Exec(NULL, OLECMDID_REFRESH, OLECMDEXECOPT_DONTPROMPTUSER, &v, NULL);
        break;
    }

    case IDC_KBSTART:
    case FCIDM_NEXTCTL:
        if (_hwndTray)
        {
            // n.b. VK_TAB handled this way (among other things)
            SendMessage(_hwndTray, WM_COMMAND, wParam, lParam);
        }
        break;

    case IDM_CLOSE:
        SendMessage(_hwndTray, TM_DOEXITWINDOWS, 0, 0);
        break;

    default:
        _pbsInner->OnCommand(wParam, lParam);
        break;
    }
    
    return S_OK;
}


// Create desktop IShellView instance

HRESULT CDesktopBrowser::_CreateDesktopView()
{
    LPCITEMIDLIST pidl = SHCloneSpecialIDList(NULL, CSIDL_DESKTOP, TRUE);
    if (pidl)
    {
        IPropertyBag* ppb;
        if (0 == GetSystemMetrics(SM_CLEANBOOT) &&
            SUCCEEDED(_GetPropertyBag(pidl, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
        {
            SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_FFLAGS, reinterpret_cast<DWORD*>(&_fsd._fs.fFlags), FWF_DESKTOP | FWF_NOCLIENTEDGE |  FWF_SNAPTOGRID);
            ppb->Release();
        }
        else
        {
            _fsd._fs.fFlags = FWF_DESKTOP | FWF_NOCLIENTEDGE | FWF_SNAPTOGRID;  // default
        }

        _fsd._fs.ViewMode = FVM_ICON;  // can't change this, sorry

        SHELLSTATE ss = {0};
        SHGetSetSettings(&ss, SSF_HIDEICONS, FALSE);
        if (ss.fHideIcons)
            _fsd._fs.fFlags |= FWF_NOICONS;
        else
            _fsd._fs.fFlags &= ~FWF_NOICONS;

        // We keep the active desktop in offline mode!
        ASSERT(_pbbd->_pautoWB2);
        _pbbd->_pautoWB2->put_Offline(TRUE);

        return _psbInner->BrowseObject(pidl, SBSP_SAMEBROWSER);
    }
    else
    {
        TCHAR szYouLoose[256];

        LoadString(HINST_THISDLL, IDS_YOULOSE, szYouLoose, ARRAYSIZE(szYouLoose));
        MessageBox(NULL, szYouLoose, NULL, MB_ICONSTOP);
        return E_FAIL;
    }
}

HRESULT CDesktopBrowser::ActivatePendingView(void)
{
    HRESULT hres = _pbsInner->ActivatePendingView();
    if (SUCCEEDED(hres))
    {
        // calling SetShellWindow will cause the desktop
        // to initially paint white, then the background window.
        // This causes an ugly white trail when you move windows 
        // around until the desktop finally paints.
        // 
        // Calling SetShellWindowEx resolves this problem.
        //
        SHSetShellWindowEx(_pbbd->_hwnd, _GetDesktopListview());
    }
    
    return hres;
}

#ifdef DEBUG

void CDesktopBrowser::_CreateDeskbars()
{
    HRESULT hres;
    BOOL fCreate = FALSE;
    HKEY hkey;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\DeskBar\\Bands"), &hkey)) 
    {
        fCreate = TRUE;
        RegCloseKey(hkey);
    }
    
    if (fCreate) 
    {
        IPersistStreamInit *ppstm;
        hres = CoCreateInstance(CLSID_DeskBarApp, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistStreamInit, &ppstm));
        if (SUCCEEDED(hres)) {
            hres = ppstm->InitNew();
            AddToolbar(ppstm, L"test", NULL);    // "Microsoft.DeskBarApp"
            ppstm->Release();
        }
    }
}
#endif

void CDesktopBrowser::_InitDeskbars()
{
    //
    // Load toolbars
    //

    // 1st, try persisted state
    IStream* pstm = GetDesktopViewStream(STGM_READ, TEXT("Toolbars"));
    HRESULT hres = E_FAIL;
    if (pstm) 
    {
        hres = _pbsInner->_LoadToolbars(pstm);
        pstm->Release();
    }

    // 2nd, if there is none (or if version mismatch or other failure),
    // try settings from setup
    // NOTE: this works fine for ie4 where we have no old toolbars,
    // but for future releases we'll need some kind of merging scheme,
    // so we probably want to change this after ie4-beta-1.
    if (FAILED(hres)) 
    {
        // n.b. HKLM not HKCU
        // like GetDesktopViewStream but for HKLM
        HKEY hk = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("Streams\\Desktop"), TRUE); 
        if (hk)
        {
            pstm = OpenRegStream(hk, NULL, TEXT("Default Toolbars"), STGM_READ);
            if (pstm) 
            {
                hres = _pbsInner->_LoadToolbars(pstm);
                pstm->Release();
            }
            RegCloseKey(hk);
        }
    }

    // o.w., throw up our hands
    if (FAILED(hres)) 
    {
        ASSERT(0);
#ifdef DEBUG
        // but for debug, need a way to bootstrap the entire process
        _CreateDeskbars();
#endif
    }
}

// Handle creation of a new Desktop folder window. Creates everything except
// the viewer part.
// Returns -1 if something goes wrong.
HWND g_hwndTray = NULL;

HRESULT CDesktopBrowser::OnCreate(CREATESTRUCT *pcs)
{
    LRESULT lr;

    g_pdtray->GetTrayWindow(&_hwndTray);
    g_hwndTray = _hwndTray;
    g_pdtray->SetDesktopWindow(_pbbd->_hwnd);

    SetTimer(_pbbd->_hwnd, IDT_ENUMHKCR, 5 * 60 * 1000, NULL);
    //
    // Notify IEDDE that the automation services are now available.
    //
    IEOnFirstBrowserCreation(NULL);

    ASSERT(_hwndTray);

    // REARCHITECT: we need to split out "ie registry settings" into a
    // browser component and a shell component.
    //
    //EnsureWebViewRegSettings();

    if (SUCCEEDED(_CreateDesktopView()))
    {
        lr = _pbsInner->OnCreate(pcs);   // success

        PostMessage(_pbbd->_hwnd, DTM_CREATESAVEDWINDOWS, 0, 0);
        
        return (HRESULT) lr;
    }

    return (LRESULT)-1;   // failure
}

UINT GetDDEExecMsg()
{
    static UINT uDDEExec = 0;

    if (!uDDEExec)
        uDDEExec = RegisterWindowMessage(TEXT("DDEEXECUTESHORTCIRCUIT"));

    return uDDEExec;
}

LRESULT CDesktopBrowser::OnNotify(NMHDR * pnm)
{
    switch (pnm->code) 
    {
    case SEN_DDEEXECUTE:
        if (pnm->idFrom == 0) 
        {
            // short cut notifier around the dde conv.
            
            LPNMVIEWFOLDER pnmPost = DDECreatePostNotify((LPNMVIEWFOLDER)pnm);

            if (pnmPost)
            {
                PostMessage(_pbbd->_hwnd, GetDDEExecMsg(), 0, (LPARAM)pnmPost);
                return TRUE;
            }
        }
        break;

    case NM_STARTWAIT:
    case NM_ENDWAIT:
        _iWaitCount += (pnm->code == NM_STARTWAIT ? 1 :-1);

        ASSERT(_iWaitCount >= 0);

        // Don't let it go negative or we'll never get rid of it.
        if (_iWaitCount < 0)
            _iWaitCount = 0;

        // what we really want is for user to simulate a mouse move/setcursor
        SetCursor(LoadCursor(NULL, _iWaitCount ? IDC_APPSTARTING : IDC_ARROW));
        break;

    default:
        return _pbsInner->OnNotify(pnm);
    }
    return 0;
}

// HACKHACK: this hard codes in that we know a listview is the child
// of the view.
HWND CDesktopBrowser::_GetDesktopListview()
{
    HWND hwndView = _pbbd->_hwndView ? _pbbd->_hwndView : _pbbd->_hwndViewPending;
    
    if (!hwndView)
        return NULL;
    
    return FindWindowEx(hwndView, NULL, WC_LISTVIEW, NULL);
}

#ifndef ENUM_REGISTRY_SETTINGS
#define ENUM_REGISTRY_SETTINGS ((DWORD)-2)
#endif


STDAPI_(BOOL) SHIsTempDisplayMode()
{
    BOOL fTempMode = FALSE;

    DEVMODE dm = {0};
    dm.dmSize = sizeof(dm);

    if (EnumDisplaySettings(NULL, ENUM_REGISTRY_SETTINGS, &dm) &&
        dm.dmPelsWidth > 0 && dm.dmPelsHeight > 0)
    {
        HDC hdc = GetDC(NULL);
        int xres = GetDeviceCaps(hdc, HORZRES);
        int yres = GetDeviceCaps(hdc, VERTRES);
        ReleaseDC(NULL, hdc);

        if (xres != (int)dm.dmPelsWidth || yres != (int)dm.dmPelsHeight)
            fTempMode = TRUE;
    }
    return fTempMode;
}

// NOTE: this is the hack andyp put in
// (dli) Currently, bottommost Tray is really wierd, it is not treated as toolbars.
// In a sense, it has higher priority than those toolbars. So they should be taken 
// off the EffectiveClientArea

void CDesktopBrowser::_SubtractBottommostTray(LPRECT prc)
{
    LRESULT lTmp;
    APPBARDATA abd;
    
    abd.cbSize = sizeof(APPBARDATA);
    abd.hWnd = _hwndTray;

    // lTmp = SHAppBarMessage(ABM_GETSTATE, &abd);
    lTmp = g_pdtray->AppBarGetState();

    if ((lTmp & (ABS_ALWAYSONTOP|ABS_AUTOHIDE)) == 0) {
        // tray is on bottom and takes 'real' space
        RECT rcTray = {0};
        
        GetWindowRect(_hwndTray, &rcTray);
        IntersectRect(&rcTray, prc, &rcTray);
        SubtractRect(prc, prc, &rcTray);
    }   
}

HRESULT CDesktopBrowser::_GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon)
{
    //
    // Cache the work area if
    //  (1) this is the very first call
    //  (2) cached value is blew off by WM_SIZE (in _OnSize)
    //
    if (hmon) {
        GetMonitorWorkArea(hmon, lprectBorder);
    }
    else {
        if (::IsRectEmpty(&_rcWorkArea)) {
            ::SystemParametersInfo(SPI_GETWORKAREA, 0, &_rcWorkArea, 0);
        }
        *lprectBorder = _rcWorkArea;
    }

    _SubtractBottommostTray(lprectBorder);
    MapWindowPoints(NULL, _pbbd->_hwnd, (LPPOINT)lprectBorder, 2);
    return S_OK;
}


BOOL EqualRects(LPRECT prcNew, LPRECT prcOld, int nRects)
{
    int i;
    for (i = 0; i < nRects; i++)
        if (!EqualRect(&prcNew[i], &prcOld[i]))
            return FALSE;
    return TRUE;
}

//
// When Snap-To-Grid is on, we want to reduce the size of gutter space around the primary monitor.
// We achieve that by adding a few pixels to the grid size sothat the gutter size  left out is
// as small as possible.
// Note: This is currently done only for Desktop listview.
//
// fMinimizeCutterSpace == FALSE  => Nothing to do. Just return.
// fMinimizeGutterSpace == TRUE   => We calculate and set the icon spacing so as to minimize gutter.
//
void UpdateGridSizes(BOOL fDesktop, HWND hwndListview, int nWorkAreas, LPRECT prcWork, BOOL fMinimizeGutterSpace)
{
    if(!fDesktop)   //If this is not desktop, we do not change any of this.
        return;

    // Trying to reset the icon spacing to system icon spacing results in ReComputing everything.
    // So, just return without doing anything!
    if(!fMinimizeGutterSpace)
        return;     //If we don't have to minimize the gutter space, nothing to do!
        
    int cxSysIconSpacing = GetSystemMetrics(SM_CXICONSPACING);
    if (cxSysIconSpacing <= 0) cxSysIconSpacing = 1; // avoid div0

    int cySysIconSpacing = GetSystemMetrics(SM_CYICONSPACING);
    if (cySysIconSpacing <= 0) cySysIconSpacing = 1; // avoid div0

    int cxNewIconSpacing = 0, cyNewIconSpacing = 0;

    RECT rcWorkAreas[LV_MAX_WORKAREAS];

    //If the work areas are not given, we need to get them.
    if(prcWork == NULL)
    {
        prcWork = &rcWorkAreas[0];
        ListView_GetNumberOfWorkAreas(hwndListview, &nWorkAreas);
        if(nWorkAreas > 0)
            ListView_GetWorkAreas(hwndListview, nWorkAreas, prcWork);
        else
            ListView_GetViewRect(hwndListview, prcWork);
    }

    //Get the primary work area.
    for(int iPrimary = 0; iPrimary < nWorkAreas; iPrimary++)
    {
        //LATER: Is this check enough! What about when tray is at the top or left?
        if((prcWork[iPrimary].left == 0) && (prcWork[iPrimary].top == 0))
            break;
    }

    if(iPrimary == nWorkAreas)
        iPrimary = 0; //Assume that the first work area is primary work area.

    //Find the number of columns based on current system horizontal icon spacing.
    int nCols = (prcWork[iPrimary].right - prcWork[iPrimary].left)/cxSysIconSpacing;
    if (nCols <= 0) nCols = 1; // avoid div0

    //Divide the remaining pixels and add them to each column to minimize the reminder area.
    cxNewIconSpacing = cxSysIconSpacing + ((prcWork[iPrimary].right - prcWork[iPrimary].left)%cxSysIconSpacing)/nCols;
    if (cxNewIconSpacing <= 0) cxNewIconSpacing = 1; // avoid div0

    //Find the number of Rows based on current system vertical icon spacing.
    int nRows = (prcWork[iPrimary].bottom - prcWork[iPrimary].top)/cySysIconSpacing;
    if (nRows <= 0) nRows = 1; // avoid div0

    //Divide the remaining pixles  and add them to each row to minimize the reminder area.
    cyNewIconSpacing = cySysIconSpacing + ((prcWork[iPrimary].bottom - prcWork[iPrimary].top)%cySysIconSpacing)/nRows;
    if (cyNewIconSpacing <= 0) cyNewIconSpacing = 1; // avoid div0

    //Set the new icon spacing to the desktop's listview.
    ListView_SetIconSpacing(hwndListview, cxNewIconSpacing, cyNewIconSpacing);
}

void CDesktopBrowser::_SetWorkAreas(int nWorkAreas, LPRECT prcWork)
{
    RECT rcListViewWork[LV_MAX_WORKAREAS];
    RECT rcNewWork[LV_MAX_WORKAREAS];
    int  nListViewWork = 0;
    HWND hwndList;
    int  i;

    ASSERT(prcWork);
    ASSERT(nWorkAreas <= LV_MAX_WORKAREAS);
    ASSERT(nWorkAreas > 0);

    if (nWorkAreas <= 0)
        return;

    if (SHIsTempDisplayMode())
        return;
    
    hwndList = _GetDesktopListview();
    ASSERT(IsWindow(hwndList));

    ListView_GetNumberOfWorkAreas(hwndList, &nListViewWork);

    BOOL fUpgradeGridSize = (BOOL)((ListView_GetExtendedListViewStyle(hwndList)) & LVS_EX_SNAPTOGRID);
    BOOL fRedraw = FALSE;

    if (nListViewWork > 0)
    {
        ListView_GetWorkAreas(hwndList, nListViewWork, rcListViewWork);
        // Map these rects back to DESKTOP coordinate
        // We need to convert the following only if WorkAreas > 1
        if (nListViewWork > 1)
        {
            // [msadek]; MapWindowPoints() is mirroring-aware only if you pass two points
            for(i = 0; i < nListViewWork; i++)
            {
                MapWindowPoints(hwndList, HWND_DESKTOP, (LPPOINT)(&rcListViewWork[i]), 2);
            }    
        }    
        if(nListViewWork == nWorkAreas && EqualRects(prcWork, rcListViewWork, nWorkAreas))
            return;
    }
    else if (_nOldWork > 1)
        // In single monitor case, listview workares always starts from (0,0)
        // It will be wrong to set the persisted workarea. 
    {
        for (nListViewWork = 0; nListViewWork < (int)_nOldWork && nListViewWork < LV_MAX_WORKAREAS; nListViewWork++)
            CopyRect(&rcListViewWork[nListViewWork], &_rcOldWorkAreas[nListViewWork]);

        // This may not be needed, because at this point, ListView is in Desktop coordinate
        // [msadek]; MapWindowPoints() is mirroring-aware only if you pass two points
        for(i = 0; i < nListViewWork; i++)
        {
            MapWindowPoints(HWND_DESKTOP, hwndList, (LPPOINT)(&rcListViewWork[i]), 2);
        }    
        //Before setting the WorkAreas, change the grid-size if needed.
        if(fUpgradeGridSize)
        {
            // We set the grid size based on the new work area. This way Recycle-Bin gets snapped
            // to the correct location just once and we don't need to change it later.
            SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
            fRedraw = TRUE;
            UpdateGridSizes(TRUE, hwndList, nWorkAreas, prcWork, TRUE);
            fUpgradeGridSize = FALSE; //Don't need to do it again!
        }
        // This call to SetWorkAreas sets the old work areas in the listview, which is not persisted there.
        ListView_SetWorkAreas(hwndList, nListViewWork, rcListViewWork);
    }
    
    //Make a copy of the new work area array because it gets modified by
    // the MapWindowPoints below.
    for(i = 0; i < nWorkAreas; i++)
        rcNewWork[i] = *(prcWork + i);

    // It's already in ListView coordinate if we just have one monitor
    if (nWorkAreas > 1)
    {
        for(i = 0; i < nWorkAreas; i++)
        {
            MapWindowPoints(HWND_DESKTOP, hwndList, (LPPOINT)(&prcWork[i]), 2);
        }    
    }

    //Because the work areas change, update the grid size to reduce the gutter area.
    if(fUpgradeGridSize) //If we haven't done already!
    {
        SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
        fRedraw = TRUE;
        UpdateGridSizes(TRUE, hwndList, nWorkAreas, prcWork, TRUE);
    }
    
    // We need to set the new work area before we call AdjustDesktopComponents below
    // because that function results in a refresh and that ends up setting
    // the work areas again to the same values.
    ListView_SetWorkAreas(hwndList, nWorkAreas, prcWork);

    if (fRedraw)
        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);

    if (nWorkAreas == 1)
        MapWindowPoints(hwndList, HWND_DESKTOP, (LPPOINT)rcNewWork, 2 * nWorkAreas);

    //Move and size desktop components based on the new work areas.
    AdjustDesktopComponents((LPCRECT)rcNewWork, nWorkAreas, (LPCRECT)_rcOldMonitors, (LPCRECT)_rcOldWorkAreas, _nOldWork);

    // Backup the new Monitor rect's in _rcOldMonitors
    for (i = 0; i < _nMonitors; i++)
    {
        GetMonitorRect(_hMonitors[i], &_rcOldMonitors[i]);
    }
    // Backup the new workareas in _rcOldWorkAreas
    for (i = 0; i < nWorkAreas; i++)
    {
        _rcOldWorkAreas[i] = rcNewWork[i];
    }
    _nOldWork = nWorkAreas;

    static const LPTSTR lpszSubkey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ScreenResFixer");
    static const LPTSTR lpszValue = TEXT("AdjustRecycleBinPosition");
    //Check if we need to change the recycle bin position because of this work-area change
    // 0 => Recycle-bin hasn't been positioned because of resolution fixer.
    // 1 => Recycle-bin needs to be repositioned. It has't happened yet!
    // 2 => Recycle-bin has already been re-positioned. Nothing needs to be done here!
    DWORD dwAdjustPos = 2; //Assume that Recycle-bin has been already positioned.
    DWORD dwSize = sizeof(dwAdjustPos);
    
    SHRegGetUSValue(lpszSubkey, lpszValue, NULL, &dwAdjustPos, &dwSize, FALSE, &dwAdjustPos, dwSize);
    //If the AdjustRecycleBinPosition value has 1, that means we need to reposition recyclebin.
    if(dwAdjustPos == 1)
    {
        //Move the recycle-bin to default position
        SendMessage(_pbbd->_hwndView, WM_DSV_ADJUSTRECYCLEBINPOSITION, 0, 0);
        dwAdjustPos = 2; //We have moved this just now! No need to move it anymore!
        SHRegSetUSValue(lpszSubkey, lpszValue, REG_DWORD, &dwAdjustPos, sizeof(dwAdjustPos), SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
    }
}

// Get all the view border rectangles (not including toolbars) for the monitors
// this is used for multi-monitor case only.  
void CDesktopBrowser::_GetViewBorderRects(int nRects, LPRECT prcBorders)
{
    int iMon;
    HMONITOR hmonTray;
    Tray_GetHMonitor(_hwndTray, &hmonTray);
    for (iMon = 0; iMon < min(_nMonitors, nRects); iMon++)
    {
        GetMonitorWorkArea(_hMonitors[iMon], &prcBorders[iMon]);
        if (hmonTray == _hMonitors[iMon])
        {
            _SubtractBottommostTray(&prcBorders[iMon]);
#ifdef FEATURE_STARTPAGE
            if (_hwndStartPage)
            {
                SetWindowPos(_hwndStartPage, NULL, prcBorders[iMon].left,
                             prcBorders[iMon].top,
                             RECTWIDTH(prcBorders[iMon]),
                             RECTHEIGHT(prcBorders[iMon]),
                             SWP_NOACTIVATE | SWP_NOZORDER);
            }
#endif
        }

        // Extract the border taken by all "frame" toolbars
        for (int itb=0; itb < _pbsInner->_GetToolbarCount(); itb++)
        {
            LPTOOLBARITEM ptbi = _pbsInner->_GetToolbarItem(itb);
            if (ptbi && ptbi->hMon == _hMonitors[iMon])
            {
                prcBorders[iMon].left += ptbi->rcBorderTool.left;
                prcBorders[iMon].top += ptbi->rcBorderTool.top;
                prcBorders[iMon].right -= ptbi->rcBorderTool.right;
                prcBorders[iMon].bottom -= ptbi->rcBorderTool.bottom;
            }
        }       
    }
}
HRESULT  CDesktopBrowser::_UpdateViewRectSize()
{
    HWND hwndView = _pbbd->_hwndView;
    if (!hwndView && ((hwndView = _pbbd->_hwndViewPending) == NULL))
        return S_FALSE;

    _pbsInner->_UpdateViewRectSize();

    if (_nMonitors <= 1)
    {
        RECT rcView, rcWork;
        GetViewRect(&rcView);
        rcWork.top = rcWork.left = 0;
        rcWork.right = RECTWIDTH(rcView);
        rcWork.bottom = RECTHEIGHT(rcView);
#ifdef FEATURE_STARTPAGE
        if (_hwndStartPage)
        {
            SetWindowPos(_hwndStartPage, NULL, rcWork.left,
                         rcWork.top,
                         RECTWIDTH(rcWork),
                         RECTHEIGHT(rcWork),
                         SWP_NOACTIVATE | SWP_NOZORDER);
        }
#endif
        _SetWorkAreas(1, &rcWork);
    }
    else
    {
        RECT rcWorks[LV_MAX_WORKAREAS];
        _GetViewBorderRects(_nMonitors, rcWorks);
        _SetWorkAreas(_nMonitors, rcWorks);
    }   

    return S_OK;
}

void CDesktopBrowser::_SetViewArea()
{
    //
    // Invalidate the cached work area size
    //
    ::SetRectEmpty(&_rcWorkArea);

    v_ShowHideChildWindows(FALSE);
}

// we get called here when new drives come and go;
// things like net connections, hot insertions, etc.

void _OnDeviceBroadcast(HWND hwnd, ULONG_PTR code, DEV_BROADCAST_HDR *pbh)
{
    // do a bunch of this stuff here in desktop so it only happens
    // once...

    switch (code)
    {
    case DBT_DEVICEREMOVECOMPLETE:      // drive or media went away
    case DBT_DEVICEARRIVAL:             // new drive or media (or UNC) has arrived
    case DBT_DEVICEQUERYREMOVE:         // drive or media about to go away
    case DBT_DEVICEQUERYREMOVEFAILED:   // drive or media didn't go away
    {
        BOOL fFilteredOut = FALSE;
        // Don't process if we are being shutdown...
        if (!IsWindowVisible(hwnd))
            break;

        // Filter this one out
        if (DBT_DEVICEARRIVAL == code)
        {
            if (DBT_DEVTYP_NET == pbh->dbch_devicetype)
            {
                LPITEMIDLIST pidl;
                // Tell the hood to update as things have probably changed!
                // PERF: this can be slow in the case of the nethood FS folder
                // no longer exists. this hangs the desktop/tray. this is a robustness bug
                if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_NETHOOD, &pidl)))
                {
                    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidl, NULL);
                    SHFree(pidl);
                }
                // use UNCToNetID(loop if (pbn->dbcn_resource)             

                fFilteredOut = TRUE;
            }
        }

        if (!fFilteredOut)
        {
            CMountPoint::HandleWMDeviceChange(code, pbh);
        }

        break;
    }
    }
}

// Note: this overrides the one in CBaseBrowser
HRESULT CDesktopBrowser::GetViewRect(RECT* prc)
{
    //
    // Check if we are on a multiple-monitor system.  In multiple monitors the
    // view needs to cover all displays (ie the size of _pbbd->_hwnd) while on
    // single-monitor systems the view just needs to cover the work area (like
    // in Win95).
    //
    if (_nMonitors <= 1)
        _pbsInner->GetViewRect(prc);
    else
        GetClientRect(_pbbd->_hwnd, prc);

    return S_OK;
}

HRESULT CDesktopBrowser::ReleaseShellView()
{
    _SaveState();

    return _pbsInner->ReleaseShellView();
}

void CDesktopBrowser::_ViewChange(DWORD dwAspect, LONG lindex)
{
    // do nothing here...
}

void CDesktopBrowser::_SaveDesktopToolbars()
{
    IStream * pstm = GetDesktopViewStream(STGM_WRITE, TEXT("Toolbars"));
    if (pstm) 
    {
        _pbsInner->_SaveToolbars(pstm);
        pstm->Release();
    }
}

void CDesktopBrowser::_SaveState()
{
    // save off the Recycle Bin information to the registry
    SaveRecycleBinInfo();

    if (!SHRestricted(REST_NOSAVESET) && _pbbd->_psv)
    {
        if (0 == GetSystemMetrics(SM_CLEANBOOT))
        {
            FOLDERSETTINGS fs;
            _pbbd->_psv->GetCurrentInfo(&fs);

            IPropertyBag* ppb;
            if (SUCCEEDED(GetPropertyBag(SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
            {
                SHPropertyBag_WriteInt(ppb, VS_PROPSTR_FFLAGS, fs.fFlags);
                ppb->Release();
            }
        }
        _pbbd->_psv->SaveViewState();

        _SaveDesktopToolbars();
    }
}

HRESULT CDesktopBrowser::OnSize(WPARAM wParam)
{
    if (wParam == SIZE_MINIMIZED)
    {
        TraceMsg(DM_TRACE, "c.dwp: Desktop minimized by somebody!");
        // Put it back.
        ShowWindow(_pbbd->_hwnd, SW_RESTORE);
    }
    _SetViewArea();
    
    return S_OK;
}

HRESULT CDesktopBrowser::OnDestroy()
{
    TraceMsg(DM_SHUTDOWN, "cdtb._od (WM_DESTROY)");

    if (_uNotifyID)
    {
        SHChangeNotifyDeregister(_uNotifyID);
        _uNotifyID = 0;
    }

    if (_hwndRaised) 
        DestroyWindow(_hwndRaised);

    //  get rid of the scheduler and the desktop tasks
    if (_psched)
    {
        _psched->RemoveTasks(TOID_Desktop, 0, TRUE);
        ATOMICRELEASE(_psched);
    }

    _pbsInner->OnDestroy();

    _pbsInner->_CloseAndReleaseToolbars(TRUE);
    
    return S_OK;
}

#define DM_SWAP DM_TRACE

void CDesktopBrowser::_SwapParents(HWND hwndOldParent, HWND hwndNewParent)
{
    HWND hwnd = ::GetWindow(hwndOldParent, GW_CHILD);
    while (hwnd) 
    {
        //
        //  Note that we must get the next sibling BEFORE we set the new
        // parent.
        //
        HWND hwndNext = ::GetWindow(hwnd, GW_HWNDNEXT);
        ::SetParent(hwnd, hwndNewParent);
        hwnd = hwndNext;
    }
}

LRESULT CDesktopBrowser::RaisedWndProc(HWND  hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDesktopBrowser *psb = (CDesktopBrowser*)GetWindowLongPtr(hwnd, 0);

    return psb->_RaisedWndProc(uMsg, wParam, lParam);
}

LRESULT CDesktopBrowser::_RaisedWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) 
    {
    case WM_ACTIVATE:
#ifdef FEATURE_STARTPAGE
        // HACK : Replace this with Focus management when DUI resolves their issue.
        if (_hwndStartPage)
            SendMessage(_hwndStartPage, WM_USER + 107, wParam, lParam);
#endif
        break;
        
    case WM_SIZE:
        if (wParam == SIZE_MINIMIZED) 
            ShowWindow(_hwndRaised, SW_RESTORE);
        break;
        
    case WM_NOTIFY:
    case WM_ERASEBKGND:
        goto SendToDesktop;



    default:
        
        if (uMsg >= WM_USER) 
        {
SendToDesktop:
            return SendMessage(_pbbd->_hwnd, uMsg, wParam, lParam);
        } 
        else 
        {
            return ::SHDefWindowProc(_hwndRaised, uMsg, wParam, lParam);
        }
    }
    
    return 0;
}


void CDesktopBrowser::_Raise()
{
    RECT rc;
    HWND hwndDesktop = GetDesktopWindow();
    BOOL fLocked;
    HWND hwndLastActive = GetLastActivePopup(_pbbd->_hwnd);
    
    if (SHIsRestricted(NULL, REST_NODESKTOP))
        return;

    if (hwndLastActive != _pbbd->_hwnd) 
    {
        SetForegroundWindow(hwndLastActive);
        return;
    }

    if (!_hwndRaised)
        _hwndRaised = SHCreateWorkerWindow(RaisedWndProc, NULL, WS_EX_TOOLWINDOW, WS_POPUP | WS_CLIPCHILDREN, NULL, this);

    //SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);
    //rc.left = 0;  // need to always start from 0, 0 to get the wallpaper centered right
    //rc.top = 0;
    fLocked = LockWindowUpdate(hwndDesktop);
    _SwapParents(_pbbd->_hwnd, _hwndRaised);
    
    // set the view window to the bottom of the z order
    SetWindowPos(_pbbd->_hwndView, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    GetWindowRect(_pbbd->_hwnd, &rc);
    SetWindowPos(_hwndRaised, HWND_TOP, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_SHOWWINDOW);
    SetForegroundWindow(_hwndRaised);

    if (fLocked)
        LockWindowUpdate(NULL);

    THR(RegisterDragDrop(_hwndRaised, (IDropTarget *)this));
#ifdef FEATURE_STARTPAGE
    if (_hwndStartPage)
        SetFocus(_hwndStartPage);
    else
#endif
    SetFocus(_pbbd->_hwndView);
    //SetWindowPos(_hwndTray, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);
    _fRaised = TRUE;
}

void CDesktopBrowser::_Lower()
{
    BOOL fLocked;

    fLocked = LockWindowUpdate(_hwndRaised);
    _SwapParents(_hwndRaised, _pbbd->_hwnd);

    // set the view window to the bottom of the z order
    SetWindowPos(_pbbd->_hwndView, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    ShowWindow(_hwndRaised, SW_HIDE);
    if (fLocked)
        LockWindowUpdate(NULL);
    RevokeDragDrop(_hwndRaised);
    _fRaised = FALSE;
}

void CDesktopBrowser::_OnRaise(WPARAM wParam, LPARAM lParam)
{
    VARIANTARG vaIn;

    VariantInit(&vaIn);
    vaIn.vt = VT_I4;
    vaIn.lVal = (DWORD) lParam;

    switch (lParam) {
        
    case DTRF_RAISE:
        _Raise();
        _ExecChildren(NULL, TRUE, &CGID_ShellDocView, SHDVID_RAISE, 0, &vaIn, NULL);
        break;
        
    case DTRF_LOWER:
        _ExecChildren(NULL, TRUE, &CGID_ShellDocView, SHDVID_RAISE, 0, &vaIn, NULL);
        _Lower();
        break;
    }

    VariantClear(&vaIn);

    if (!wParam) {
        wParam = (WPARAM)_hwndTray;
    }
    
    PostMessage((HWND)wParam, TM_DESKTOPSTATE, 0, _fRaised ? DTRF_RAISE : DTRF_LOWER);
}

BOOL CDesktopBrowser::_QueryHKCRChanged(HWND hwnd, DWORD *pdwCookie)
{
    //  we assume that the key has changed if 
    //  we were unable to init correctly
    BOOL fRet = TRUE;

    ASSERT(pdwCookie);
    
    if (_cChangeEvents)
    {
        DWORD dw = WaitForMultipleObjects(_cChangeEvents, _rghChangeEvents, FALSE, 0);

        dw -= WAIT_OBJECT_0;

        // Note: Since "dw" is a DWORD, an underflow in the line above
        // will result in dw becoming a huge value, so the test below will
        // fail.
        if (dw < _cChangeEvents)
        {

            //  this means the key changed...
            ResetEvent(_rghChangeEvents[dw]);
            _dwChangeCookie = GetTickCount();

            PostMessage(hwnd, DTM_SETUPAPPRAN, 0, NULL);
        }

        //
        //  if nothing has changed yet, or if nothing has changed
        //  since the client last checked,
        //  than this client doesnt need to update its cache
        //
        if (!_dwChangeCookie ||  (*pdwCookie && *pdwCookie  == _dwChangeCookie))
            fRet = FALSE;

        //  update the cookie
        *pdwCookie = _dwChangeCookie;
    }

    return fRet;
}

// This msg gets posted to us after a setup application runs so that we can
// fix things up.

void CDesktopBrowser::_SetupAppRan(WPARAM wParam, LPARAM lParam)
{
    // Lotus 123R5 sometimes gets confused when installing over IE4 and
    // they leave their country setting blank. Detect this case and put
    // in USA so that they at least boot.       
    {
        TCHAR szPath[MAX_PATH];
        GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
        if (PathAppend(szPath, TEXT("123r5.ini")) && PathFileExistsAndAttributes(szPath, NULL))
        {
            TCHAR szData[100];
        
            GetPrivateProfileString(TEXT("Country"), TEXT("driver"), TEXT(""), szData, ARRAYSIZE(szData), TEXT("123r5.ini"));
            if (!szData[0])
            {
                WritePrivateProfileString(TEXT("Country"), TEXT("driver"), TEXT("L1WUSF"), TEXT("123r5.ini"));
            }
        }
    }

    //  this location in the registry is a good place to cache info
    //  that needs to be invalided once 
    SHDeleteKey(HKEY_CURRENT_USER, STRREG_DISCARDABLE STRREG_POSTSETUP);

    HKEY hk = SHGetShellKey(SHELLKEY_HKCULM_MUICACHE, NULL, FALSE);
    if (hk)
    {
        SHDeleteKeyA(hk, NULL);
        RegCloseKey(hk);
    }

    //  Take this opportunity to freshen our component categories cache:
    IShellTaskScheduler* pScheduler ;
    if(SUCCEEDED(CoCreateInstance(CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC_SERVER, 
                                     IID_PPV_ARG(IShellTaskScheduler, &pScheduler))))
    {
#ifdef _WIN64
        // Before creating 64-bit component cache, we should delete the 32-bit cache,
        // because we used to erroneously cache 64-bit components in the 32-bit cache,
        // and it won't get rebuilt with correc 32-bit components unless we delete it now.
        SHDeleteKey(HKEY_CURRENT_USER, STRREG_DISCARDABLE STRREG_POSTSETUP TEXT("\\Component Categories"));
#endif
        IRunnableTask* pTask ;
        if(SUCCEEDED(CoCreateInstance(CLSID_ComCatCacheTask, NULL, CLSCTX_INPROC_SERVER,
                                         IID_PPV_ARG(IRunnableTask, &pTask))))
        {
            pScheduler->AddTask(pTask, CLSID_ComCatCacheTask, 0L, ITSAT_DEFAULT_PRIORITY);
            pTask->Release();  // Scheduler has AddRef'd him
        }

        if (SUCCEEDED(CTaskEnumHKCR_Create(&pTask)))
        {   
            pScheduler->AddTask(pTask, CLSID_QueryAssociations, 0L, ITSAT_DEFAULT_PRIORITY);
            pTask->Release();  // Scheduler has AddRef'd him
        }

        pScheduler->Release(); // OK to release global task scheduler.
    }


    // We get this notification from the OS that a setup app ran.
    //  Legacy app support for freshly written entries under [extensions] section;
    //  Scoop these up and shove into registry.   (re: bug 140986)
    CheckWinIniForAssocs();
}


//-----------------------------------------------------------------------------
struct propagatemsg
{
    UINT   uMsg;
    WPARAM wParam;
    LPARAM lParam;
    BOOL   fSend;
};

BOOL PropagateCallback(HWND hwndChild, LPARAM lParam)
{
    struct propagatemsg *pmsg = (struct propagatemsg*)lParam;
    if (pmsg->fSend)
        SendMessage(hwndChild, pmsg->uMsg, pmsg->wParam, pmsg->lParam);
    else
        PostMessage(hwndChild, pmsg->uMsg, pmsg->wParam, pmsg->lParam);

    return TRUE;
}

void PropagateMessage(HWND hwndParent, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend)
{
    if (!hwndParent)
        return;

    struct propagatemsg msg = { uMsg, wParam, lParam, fSend };

    EnumChildWindows(hwndParent, PropagateCallback, (LPARAM)&msg);
}

void CDesktopBrowser::v_PropagateMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend)
{
    // WARNING: We can't propagate the message to a NULL hwnd because it will
    // turn into a broadcast.  This will come back to us and we will re-send it
    // causing an infinite loop.  BryanSt.
    if (_fRaised && _hwndRaised)
        PropagateMessage(_hwndRaised, uMsg, wParam, lParam, fSend);
    else if (_pbbd->_hwnd)
        PropagateMessage(_pbbd->_hwnd, uMsg, wParam, lParam, fSend);
}

//***
// NOTES
//  in the tray case, we actually do SetFocus etc.
HRESULT CDesktopBrowser::v_MayGetNextToolbarFocus(LPMSG lpMsg,
    UINT itbCur, int citb,
    LPTOOLBARITEM * pptbi, HWND * phwnd)
{
    HRESULT hr;

    // _fTrayHack?

    if (itbCur == ITB_VIEW) {
        if (citb == -1) {
            TraceMsg(DM_FOCUS, "cdtb.v_mgntf: ITB_VIEW,-1 => tray");
            goto Ltray;
        }
    }

    hr = _pbsInner->v_MayGetNextToolbarFocus(lpMsg, itbCur, citb, pptbi, phwnd);
    TraceMsg(DM_FOCUS, "cdtb.v_mgntf: SUPER hr=%x", hr);
    if (SUCCEEDED(hr)) {
        // S_OK: we got and handled a candidate
        // S_FALSE: we got a candidate and our parent will finish up
        ASSERT(hr != S_OK);  // currently never happens (but should work)
        return hr;
    }

    // E_xxx: no candidate
    ASSERT(citb == 1 || citb == -1);
    *pptbi = NULL;
    if (citb == 1) {
Ltray:
        *phwnd = _hwndTray;
        // AndyP REVIEW: why do we do this here instead of overriding
        // _SetFocus and letting commonsb call that function? Sure, this
        // is one less override, but why have different code paths?
        SendMessage(_hwndTray, TM_UIACTIVATEIO, TRUE, citb);
        return S_OK;
    }
    else 
    {
//Lview:
        *phwnd = _pbbd->_hwndView;
        return S_FALSE;
    }
    /*NOTREACHED*/
    ASSERT(0);
}

//
// NOTE: Please think before calling this function, in a multi-monitor system this function
// returns TRUE if you are within a certain edge for any monitor, so puEdge means puEdge
// of a certain monitor instead of the whole desktop. -- dli
//
BOOL CDesktopBrowser::_PtOnDesktopEdge(POINTL* ppt, LPUINT puEdge)
{
    RECT rcMonitor;
    POINT pt = {ppt->x, ppt->y};
    HMONITOR hMon = MonitorFromPoint(pt, MONITOR_DEFAULTTONULL);
    // We got this point from drop, so it definitely should belong to a valid monitor -- dli
    ASSERT(hMon);
    GetMonitorRect(hMon, &rcMonitor); 

    // if it's near/on the edge on this monitor
    if (ppt->x < rcMonitor.left + g_cxEdge) {
        *puEdge = ABE_LEFT;
    } else if (ppt->x > rcMonitor.right - g_cxEdge) {
        *puEdge = ABE_RIGHT;
    } else if (ppt->y < rcMonitor.top + g_cyEdge) {
        *puEdge = ABE_TOP;
    } else if (ppt->y > rcMonitor.bottom - g_cyEdge) {
        *puEdge = ABE_BOTTOM;
    } else {
        *puEdge = (UINT)-1;
        return FALSE;
    }
    return TRUE;
}

UINT g_cfDeskBand = 0;

HRESULT CDesktopBrowser::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    ASSERT(pdtobj);
    if (!g_cfDeskBand)
        g_cfDeskBand = RegisterClipboardFormat(TEXT("DeskBand"));

    FORMATETC fmte = { (CLIPFORMAT) g_cfDeskBand, NULL, 0, -1, TYMED_ISTREAM};
    if (pdtobj->QueryGetData(&fmte) == S_OK) {
        _dwEffectOnEdge = DROPEFFECT_COPY | DROPEFFECT_MOVE;
    } else {
        _dwEffectOnEdge = DROPEFFECT_NONE;
    }
    
    _grfKeyState = grfKeyState;

    HRESULT hr;

    if (_pdtInner)
        hr = _pdtInner->DragEnter(pdtobj, grfKeyState, ptl, pdwEffect);
    else
    {
        DAD_DragEnterEx3(_pbbd->_hwndView, ptl, pdtobj);
        hr = S_OK;
    }

    return hr;
}

HRESULT CDesktopBrowser::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    HRESULT hr = S_OK;
    DAD_DragMoveEx(_pbbd->_hwndView, ptl);
    _grfKeyState = grfKeyState;
    
    if (_dwEffectOnEdge != DROPEFFECT_NONE) {
        *pdwEffect &= _dwEffectOnEdge;
        return S_OK;
    }

    if (_pdtInner)
        hr = _pdtInner->DragOver(grfKeyState, ptl, pdwEffect);
    
    return hr;
    
}

HRESULT DeskBarApp_Create(IUnknown** ppunkBar, IUnknown** ppunkBandSite)
{
    IDeskBar* pdb;
    HRESULT hres = CoCreateInstance(CLSID_DeskBarApp, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDeskBar, &pdb));
    *ppunkBar = pdb;
    if (SUCCEEDED(hres)) 
    {
        pdb->GetClient(ppunkBandSite);
    }
    return hres;
}

//***
// ENTRY/EXIT
//  hres        AddBand result on success; o.w. failure code
// NOTES
//  n.b. on success we *must* return AddBand's hres (which is a dwBandID)
HRESULT CDesktopBrowser::_CreateDeskBarForBand(UINT uEdge, IUnknown *punk, POINTL *pptl, IBandSite **ppbsOut)
{
    IBandSite *pbs;
    IUnknown *punkBar;
    IUnknown *punkBandSite;
    HRESULT hres;
#ifdef DEBUG
    HRESULT hresRet = -1;
#endif

    if (ppbsOut)
        *ppbsOut = NULL;

    hres = DeskBarApp_Create(&punkBar, &punkBandSite);
    if (SUCCEEDED(hres))
    {
        IDockingBarPropertyBagInit* ppbi;

        if (SUCCEEDED(CoCreateInstance(CLSID_CDockingBarPropertyBag, NULL, CLSCTX_INPROC_SERVER,
                        IID_PPV_ARG(IDockingBarPropertyBagInit, &ppbi))))
        {
            if ((UINT)uEdge != -1) 
            {
                ppbi->SetDataDWORD(PROPDATA_MODE, WBM_BOTTOMMOST);
                ppbi->SetDataDWORD(PROPDATA_SIDE, uEdge);
            }
            else 
            {
                ppbi->SetDataDWORD(PROPDATA_MODE, WBM_FLOATING);
            }

            ppbi->SetDataDWORD(PROPDATA_X, pptl->x);
            ppbi->SetDataDWORD(PROPDATA_Y, pptl->y);
            
            IPropertyBag * ppb;
            if (SUCCEEDED(ppbi->QueryInterface(IID_PPV_ARG(IPropertyBag, &ppb))))
            {
                SHLoadFromPropertyBag(punkBar, ppb);

                punkBandSite->QueryInterface(IID_PPV_ARG(IBandSite, &pbs));

                if (pbs) 
                {
                    hres = pbs->AddBand(punk);
#ifdef DEBUG
                    hresRet = hres;
#endif
                    AddToolbar(punkBar, L"", NULL);

                    if (ppbsOut) 
                    {
                        // IUnknown_Set (sort of...)
                        *ppbsOut = pbs;
                        (*ppbsOut)->AddRef();
                    }

                    pbs->Release();

                    if (_fRaised) 
                    {
                        VARIANTARG vaIn = { 0 };

                        vaIn.vt = VT_I4;
                        vaIn.lVal = DTRF_RAISE;

                        ASSERT(punkBar != NULL);    // o.w. we'd do a broadcast
                        _ExecChildren(punkBar, FALSE, &CGID_ShellDocView, SHDVID_RAISE, 0, &vaIn, NULL);
                    }
                }

                ppb->Release();
            }

            ppbi->Release();
        }

        punkBandSite->Release();
        punkBar->Release();        
    }
    
    ASSERT(hres == hresRet || FAILED(hres));
    return hres;
}

HRESULT CDesktopBrowser::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    UINT uEdge;
    HRESULT hres = E_FAIL;
    
    if (((_PtOnDesktopEdge(&pt, &uEdge) && (_grfKeyState & MK_LBUTTON)) ||
        (_dwEffectOnEdge != DROPEFFECT_NONE)) && !SHRestricted(REST_NOCLOSE_DRAGDROPBAND)) 
    {
        // if the point is on the edge of the desktop and the item dropped was 
        // a single url object, then create a webbar
        // TODO: (reuse) w/ a little restructuring we might share this code
        // w/ CBandSite::Drop etc.

        FORMATETC fmte = {(CLIPFORMAT)g_cfDeskBand, NULL, 0, -1, TYMED_ISTREAM};
        STGMEDIUM stg;
        LPITEMIDLIST pidl;
        IUnknown* punk = NULL;

        // we can move a band from bar to bar, but we can only copy or link a folder
        // because the creation of a band relies on the source still abeing there
        if ((*pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_MOVE)) &&
            SUCCEEDED(pdtobj->GetData(&fmte, &stg))) 
        {
            // this is a drag of a band from another bar, create it!
            hres = OleLoadFromStream(stg.pstm, IID_PPV_ARG(IUnknown, &punk));
            if (SUCCEEDED(hres)) 
            {
                if (*pdwEffect & DROPEFFECT_COPY)
                    *pdwEffect = DROPEFFECT_COPY;
                else 
                    *pdwEffect = DROPEFFECT_MOVE;
            }
            ReleaseStgMedium(&stg);

        } 
        else if ((*pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_LINK)) &&
                   SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0))) 
        {
            hres = SHCreateBandForPidl(pidl, &punk, (grfKeyState & (MK_CONTROL | MK_SHIFT)) == (MK_CONTROL | MK_SHIFT));
            ILFree(pidl);

            if (SUCCEEDED(hres)) 
            {
                if (*pdwEffect & DROPEFFECT_LINK)
                    *pdwEffect = DROPEFFECT_LINK;
                else
                    *pdwEffect = DROPEFFECT_COPY;
            }

        }

        if (SUCCEEDED(hres)) 
        {
            if (punk) 
            {
                BOOL fCreateRebarWindow = TRUE;

                IDeskBandEx* pdbex;
                if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IDeskBandEx, &pdbex))))
                {
                    fCreateRebarWindow = (pdbex->MoveBand() == S_OK) ? TRUE : FALSE;
                    pdbex->Release();
                }

                if (fCreateRebarWindow)
                {
                    IBandSite *pbs;
                    hres = _CreateDeskBarForBand(uEdge, punk, &pt, &pbs);
                    if (SUCCEEDED(hres)) 
                    {
                        DWORD dwState = IDataObject_GetDeskBandState(pdtobj);
                        pbs->SetBandState(ShortFromResult(hres), BSSF_NOTITLE, dwState & BSSF_NOTITLE);
                        pbs->Release();
                    }
                    punk->Release();
                }
            }

            IDropTarget *pdtView;
            HRESULT hr = E_FAIL;

            //Get the view's drop target 
            if (_pbbd->_psv)
            {
                hr = _pbbd->_psv->QueryInterface(IID_PPV_ARG(IDropTarget, &pdtView));
                if (SUCCEEDED(hr))
                {
                   pdtView->DragLeave();
                   pdtView->Release();
                }
            }
            return hres; 
        }


        // if we failed, pass this on to our child.
        // this allows things like d/d of wallpaper to the edge to do 
        // right thing
    } 
    
    if (_pdtInner)
        hres = _pdtInner->Drop(pdtobj, grfKeyState, pt, pdwEffect);
    
    return hres;
} 

BOOL _GetToken(LPCTSTR *ppszCmdLine, LPTSTR szToken, UINT cchMax)
{
    LPCTSTR pszCmdLine = *ppszCmdLine;

    TCHAR chTerm = ' ';
    if (*pszCmdLine == TEXT('"')) {
        chTerm = TEXT('"');
        pszCmdLine++;
    }

    UINT ichToken = 0;
    TCHAR ch;
    while((ch=*pszCmdLine) && (ch != chTerm)) {
        if (ichToken < cchMax-1) {
            szToken[ichToken++] = ch;
        }
        pszCmdLine++;
    }

    szToken[ichToken] = TEXT('\0');

    if (chTerm == TEXT('"') && ch == TEXT('"')) {
        pszCmdLine++;
    }

    // skip trailing spaces
    while(*pszCmdLine == TEXT(' '))
        pszCmdLine++;

    *ppszCmdLine = pszCmdLine;

    TraceMsg(TF_SHDAUTO, "_GetToken returning %s (+%s)", szToken, pszCmdLine);

    return szToken[0];
}


BOOL CDesktopBrowser::_OnCopyData(PCOPYDATASTRUCT pcds)
{
    IETHREADPARAM *piei = SHCreateIETHREADPARAM(NULL, (ULONG)pcds->dwData, NULL, NULL);
    if (piei)
    {
        LPCWSTR pwszSrc = (LPCWSTR)pcds->lpData;
        LPCWSTR pwszDdeRegEvent = NULL;
        LPCWSTR pwszCloseEvent = NULL;
        DWORD cchSrc = pcds->cbData / sizeof(WCHAR);

        piei->uFlags = COF_NORMAL | COF_WAITFORPENDING | COF_IEXPLORE;

        //
        // Remember where the command line parameters are.
        //
        LPCWSTR pszCmd = pwszSrc;
        int cch = lstrlenW(pwszSrc) + 1;
        pwszSrc += cch;
        cchSrc -= cch;

        TraceMsg(TF_SHDAUTO, "CDB::_OnCopyData got %hs", pszCmd);

        //
        // Get the dde reg event name into piei->szDdeRegEvent.
        //

        // NOTE: this is now conditional because we now launch the channel band from the desktop
        // NOTE: as a fake WM_COPYDATA command
        if (cchSrc)
        {
            ASSERT(cchSrc);
            pwszDdeRegEvent = pwszSrc;
            StrCpyNW(piei->szDdeRegEvent, pwszSrc, ARRAYSIZE(piei->szDdeRegEvent));
            cch = lstrlenW(pwszSrc) + 1;
            pwszSrc += cch;
            cchSrc -= cch;
            piei->uFlags |= COF_FIREEVENTONDDEREG;
            
            //
            // Get the name of the event to fire on close, if any.
            //
            if (cchSrc)
            {
                pwszCloseEvent = pwszSrc;
                StrCpyNW(piei->szCloseEvent, pwszSrc, ARRAYSIZE(piei->szCloseEvent));
                cch = lstrlenW(pwszSrc) + 1;
                pwszSrc += cch;
                cchSrc -= cch;
                piei->uFlags |= COF_FIREEVENTONCLOSE;
                
            }
        }
        
        ASSERT(cchSrc == 0);

        if (pszCmd && pszCmd[0])
        {
            // for compatibility with apps that spawn the browser with a command line
            // tell wininet to refresh its proxy settings. (this is particularly needed
            // for TravelSoft WebEx)
            MyInternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
            
            if (SHParseIECommandLine(&pszCmd, piei))
                piei->uFlags |= COF_NOFINDWINDOW;
            
            if (pszCmd[0] && FAILED(_ConvertPathToPidlW(_pbsInner, _pbbd->_hwnd, pszCmd, &piei->pidl)))
                piei->pidl = NULL;
        }
        else
        {
            piei->fCheckFirstOpen = TRUE;
        }

        // SHOpenFolderWindow takes ownership of piei
        BOOL fRes = SHOpenFolderWindow(piei);
        if (!fRes)
        {
            //
            // Something went wrong creating the browser,
            // let's fire all the events ourselves.
            //
            if (pwszDdeRegEvent) 
                FireEventSz(pwszDdeRegEvent);
            if (pwszCloseEvent) 
                FireEventSz(pwszCloseEvent);
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "OnCopyData unable to create IETHREADPARAM");
    }

    return TRUE;
}

BOOL CDesktopBrowser::_InitScheduler(void)
{
    if (!_psched)
    {
        // get the system background scheduler thread
        CoCreateInstance(CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC,
                         IID_PPV_ARG(IShellTaskScheduler, &_psched));

    }
    return (_psched != NULL);
}
    

HRESULT CDesktopBrowser::_AddDesktopTask(IRunnableTask *ptask, DWORD dwPriority)
{
    if (_InitScheduler())
        return _psched->AddTask(ptask, TOID_Desktop, 0, dwPriority);

    return E_FAIL;
}

void CDesktopBrowser::_OnAddToRecent(HANDLE hMem, DWORD dwProcId)
{
    IRunnableTask *ptask;
    if (SUCCEEDED(CTaskAddDoc_Create(hMem, dwProcId, &ptask)))
    {
        _AddDesktopTask(ptask, ITSAT_DEFAULT_PRIORITY);
        ptask->Release();
    }
}

//
// local server handling
//

DWORD WINAPI _LocalServerThread(void *pv)
{
    LOCALSERVERDATA *ptd = (LOCALSERVERDATA *)pv;
    CLSID clsid = *c_localServers[ptd->iLocalServer];

    IUnknown *punk;
    if (SUCCEEDED(DllGetClassObject(clsid, IID_PPV_ARG(IUnknown, &punk))))
    {
        DWORD dwReg;
        if (SUCCEEDED(CoRegisterClassObject(clsid, punk, CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE, &dwReg)))
        {
            __try 
            {
                MSG msg;
            
                while(GetMessage(&msg, NULL, 0, 0))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                //  we only send the message on an exception,
                //  because otherwise we got a WM_QUIT which 
                //  means the desktop is being destroyed.
                PostMessage(GetShellWindow(), CWM_CREATELOCALSERVER, FALSE, ptd->iLocalServer);
            }

            CoRevokeClassObject(dwReg);
        }
    }

    LocalFree(ptd);
    return 0;
}

DWORD WINAPI _SetThreadID(void *pv)
{
    LOCALSERVERDATA *ptd = (LOCALSERVERDATA *)pv;
    *ptd->pdwThreadID = GetCurrentThreadId();
    return 0;
}


STDAPI_(HWND) SCNGetWindow(BOOL fUseDesktop);

LRESULT CDesktopBrowser::WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INSTRUMENT_WNDPROC(SHCNFI_DESKTOP_WNDPROC, _pbbd->_hwnd, uMsg, wParam, lParam);
    ASSERT(IsWindowTchar(hwnd));

    switch (uMsg)
    {
#ifdef DEBUG
    case WM_QUERYENDSESSION:
        TraceMsg(DM_SHUTDOWN, "cdtb.wp: WM_QUERYENDSESSION");
        goto DoDefault;
#endif

    case WM_ENDSESSION:
        TraceMsg(DM_SHUTDOWN, "cdtb.wp: WM_ENDSESSION wP=%d lP=%d", wParam, lParam);
        if (wParam)
        {
#ifdef DEBUG
            // call out inner an give him a chance to set _fMightBeShuttingDown so we
            // don't assert later on in the case where the system is shutting down
            _pbsInner->WndProcBS(hwnd, uMsg, wParam, lParam);
#endif
            SHELLSTATE ss = {0};
            // When we shut down, if the desktop is in WebView, we leave some temp
            // files undeleted because we never get the WM_DESTROY message below.
            // So, I just destroy the shellview which in turn destroys the temp
            // file here. Note: This is done only if we are in web view.

            SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE); //Get the desktop_html flag
            if (ss.fDesktopHTML)
            {
                ReleaseShellView();
            }

            g_pdtray->SetVar(SVTRAY_EXITEXPLORER, FALSE);   // don't exit process

            // flush log before we exit
            if (StopWatchMode())
            {
                StopWatchFlush();
            }

            // Kill this window so that we free active desktop threads properly
            DestroyWindow(hwnd);
        }
        TraceMsg(DM_SHUTDOWN, "cdtb.wp: WM_ENDSESSION return 0");
        break;

    case WM_ERASEBKGND:
        PaintDesktop((HDC)wParam);
        return 1;

    case WM_TIMER:
        switch (wParam)
        {
        case IDT_DDETIMEOUT:
            DDEHandleTimeout(_pbbd->_hwnd);
            break;

        case IDT_ENUMHKCR:
            KillTimer(_pbbd->_hwnd, IDT_ENUMHKCR);
            {
                IShellTaskScheduler* pScheduler ;
                if(SUCCEEDED(CoCreateInstance(CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC_SERVER, 
                                                 IID_PPV_ARG(IShellTaskScheduler, &pScheduler))))
                {
                    IRunnableTask* pTask ;
                    if (SUCCEEDED(CTaskEnumHKCR_Create(&pTask)))
                    {   
                        pScheduler->AddTask(pTask, CLSID_QueryAssociations, 0L, ITSAT_DEFAULT_PRIORITY);
                        pTask->Release();  // Scheduler has AddRef'd him
                    }

                    pScheduler->Release(); // OK to release global task scheduler.
                }
            }
            break;
        default:
            goto DoDefault;
            break;
        }
        break;

    case WM_SHELLNOTIFY:
        switch(wParam)
        {
        case SHELLNOTIFY_WALLPAPERCHANGED:
            // this is done only to the shell window when someone sets
            // the wall paper but doesn't specify to broadcast
            _pbsInner->ForwardViewMsg(uMsg, wParam, lParam);
            break;
        }
        break;

    case WM_PALETTECHANGED:
    case WM_QUERYNEWPALETTE:
        //
        // in Win95 the desktop wndproc will invalidate the shell window when
        // a palette change occurs so we didn't have to do anything here before
        //
        // in Nashville the desktop can be HTML and needs the palette messages
        //
        // so now we fall through and propagate...
        //
    case WM_ACTIVATEAPP:
        if (!_pbbd->_hwndView)
            goto DoDefault;

        return _pbsInner->ForwardViewMsg(uMsg, wParam, lParam);

    case WM_DEVICECHANGE:
        _pbsInner->ForwardViewMsg(uMsg, wParam, lParam);
        _OnDeviceBroadcast(_pbbd->_hwnd, wParam, (DEV_BROADCAST_HDR *)lParam);
        goto DoDefault;

    case WM_WINDOWPOSCHANGING:
        #define ppos ((LPWINDOWPOS)lParam)
        ppos->x = g_xVirtualScreen;
        ppos->y = g_yVirtualScreen;
        ppos->cx = g_cxVirtualScreen;
        ppos->cy = g_cyVirtualScreen;
        break;

    case WM_HOTKEY:
        // NOTE: forward hotkeys to the tray. This fixes the logitech mouseman who sends 
        // NOTE: hotkeys directly to the desktop. 
        // SPECIAL NOTE: the offset for GHID_FIRST is added because hotkeys that are sent to the
        // SPECIAL NOTE: desktop are not proper hotkeys generated from the keyboard, they are
        // SPECIAL NOTE: sent by an app, and the IDs have changed since win95....
        ASSERT(g_hwndTray);
        ASSERT(wParam < GHID_FIRST);
        PostMessage(g_hwndTray, uMsg, wParam + GHID_FIRST, lParam);
        return 0;
        
    case WM_SYSCOMMAND:
        switch (wParam & 0xFFF0) {
        // NB Dashboard 1.0 sends a WM_SYSCOMMAND SC_CLOSE to the desktop when it starts up.
        // What it was trying to do was to close down any non-shell versions of Progman. The
        // proper shell version would just ignore the close. Under Chicago, they think that
        // the desktop is Progman and send it the close, so we put up the exit windows dialog!
        // Dashboard 2.0 has been fixed to avoid this bogisity.
        case SC_CLOSE:
            break;

        // America alive tries to minimise Progman after installing - they end up minimising
        // the desktop on Chicago!
        case SC_MINIMIZE:
            break;

        default:
            goto DoDefault;
        }
        break;

    case WM_SETCURSOR:
        // REVIEW: is this really needed?
        if (_iWaitCount)
        {
            SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
            return TRUE;
        }
        else
            goto DoDefault;

    case WM_CLOSE:
        SendMessage(_hwndTray, TM_DOEXITWINDOWS, 0, 0);
        return 0;

        // REVIEW: do we need this, can all of these cases be the same?
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
        if (!_pbsInner->ForwardViewMsg(uMsg, wParam, lParam))
            goto DoDefault;
        break;

    case WM_INITMENUPOPUP:
    case WM_ENTERMENULOOP:
    case WM_EXITMENULOOP:
        // let the fsview deal with any popup menus it created
        _pbsInner->ForwardViewMsg(uMsg, wParam, lParam);
        break;

    // Looking at messages to try to capture when the workarea may
    // have changed...
    case WM_DISPLAYCHANGE:
        lParam = 0;
        if (GetNumberOfMonitors() != _nMonitors)
            _InitMonitors();
        
        // fall through

    case WM_WININICHANGE:
        _InitDesktopMetrics(wParam, (LPCTSTR)lParam);

        if (wParam == SPI_SETNONCLIENTMETRICS)
        {
            VARIANTARG varIn;
            VARIANTARG varOut = {0};
            varIn.vt = VT_BOOL;
            varIn.boolVal = VARIANT_TRUE;

            _pctInner->Exec(&CGID_Explorer, SBCMDID_CACHEINETZONEICON, OLECMDEXECOPT_DODEFAULT , &varIn, &varOut);
        }

        if (lParam)
        {
            if (lstrcmpi((LPCTSTR)lParam, TEXT("Extensions")) == 0)
            {
                // Post a message to our selves so we can do more stuff
                // slightly delayed.
                PostMessage(hwnd, DTM_SETUPAPPRAN, 0, 0);
            }
            else if (lstrcmpi((LPCTSTR)lParam, TEXT("ShellState")) == 0)
            {
                //  this should cover external apps changing
                //  our settings.
                SHRefreshSettings();
            }
            else
            {
                // SPI_GETICONTITLELONGFONT is broadcast from IE when the home page is changed.  We look for that so
                // we can be sure to update the MyCurrentHomePage component.
                if((wParam == SPI_SETDESKWALLPAPER) || (wParam == SPI_SETDESKPATTERN) || (wParam == SPI_GETICONTITLELOGFONT))
                {
                    // Some desktop attribute has changed. So, regenerate desktop.
                    if(lstrcmpi((LPCTSTR)lParam, TEXT("ToggleDesktop")) &&
                       lstrcmpi((LPCTSTR)lParam, TEXT("RefreshDesktop")) &&
                       lstrcmpi((LPCTSTR)lParam, TEXT("BufferedRefresh")))
                    {
                        DWORD dwFlags = AD_APPLY_HTMLGEN | AD_APPLY_REFRESH;

                        switch (wParam)
                        {
                            case SPI_SETDESKPATTERN:
                                dwFlags |= (AD_APPLY_FORCE | AD_APPLY_DYNAMICREFRESH);
                                break;
                            case SPI_SETDESKWALLPAPER:
                                dwFlags |= AD_APPLY_SAVE;
                                break;
                            case SPI_GETICONTITLELOGFONT:
                                dwFlags |= AD_APPLY_FORCE;
                                break;
                        }       

                        PokeWebViewDesktop(dwFlags);
                        
                        // If we are not currently in ActiveDesktop Mode, then we need to set the dirty bit
                        // sothat a new HTML file will be generated showing the new wallpaper,
                        // the next time the active desktop is turned ON!
                        if (wParam == SPI_SETDESKWALLPAPER)
                        {
                            SHELLSTATE ss = {0};
                            SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE); //Get the desktop_html flag
                            if (!ss.fDesktopHTML)
                                SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);
                        }
                    }
                }
            }
            
        }

        // control panel applet that allows users to change the
        // environment with-which to spawn new applications.  On NT, we need
        // to pick up that environment change so that anything we spawn in
        // the future will pick up those updated environment values.
        //
        if (lParam && (lstrcmpi((LPTSTR)lParam, TEXT("Environment")) == 0))
        {
            void *pv;
            RegenerateUserEnvironment(&pv, TRUE);
        }

        v_PropagateMessage(uMsg, wParam, lParam, TRUE);
        SetWindowPos(_pbbd->_hwnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER);
        if ((uMsg == WM_DISPLAYCHANGE) || (wParam == SPI_SETWORKAREA))
            _SetViewArea();

        SHSettingsChanged(wParam, lParam);
        break;

    case WM_SYSCOLORCHANGE:
        //
        // In memphis, when apps go into low-res mode, we get this message. We should not re-generate
        // desktop.htt in this scenario, or else the centered wallpaper gets messed up because we do not
        // get the message when the app exists and the resoultion goes up. So, we make the following check.
        //
        if(!SHIsTempDisplayMode())
            OnDesktopSysColorChange();
        //This is done sothat the defview can set the listview in proper
        //colors.
        _pbsInner->ForwardViewMsg(uMsg, wParam, lParam);
        break;

    // Don't go to default wnd proc for this one...
    case WM_INPUTLANGCHANGEREQUEST:
        if (wParam)
            goto DoDefault;
        else
            return 0;

    case WM_COPYDATA:
        return _OnCopyData((PCOPYDATASTRUCT)lParam);

    case CWM_COMMANDLINE:
        SHOnCWMCommandLine(lParam);
        break;

    case CWM_GETSCNWINDOW:
        return (LRESULT) SCNGetWindow(FALSE);
        break;
        
    case CWM_ADDTORECENT:
        _OnAddToRecent((HANDLE)wParam, (DWORD) lParam);
        return 0;

    case CWM_WAITOP:
        SHWaitOp_Operate((HANDLE)wParam, (DWORD)lParam);
        return 0;

    case CWM_CREATELOCALSERVER:
    {
        // wParam = TRUE to create, FALSE to mark as terminated
        // lParam = (INT) index into LocalServer table

        INT i = (INT)lParam;
        if ((i >= 0) && (i < ARRAYSIZE(_idLocalServerThreads)))
        {
            if (wParam)
            {
                if (_idLocalServerThreads[i] == -1)
                {
                    LOCALSERVERDATA *ptd = (LOCALSERVERDATA *)LocalAlloc(LPTR, sizeof(*ptd));
                    if (ptd)
                    {
                        ptd->iLocalServer = i;
                        ptd->pdwThreadID = &_idLocalServerThreads[i];
                        if (!SHCreateThread(_LocalServerThread, ptd, CTF_COINIT, _SetThreadID))
                        {
                            LocalFree(ptd);
                        }
                    }
                }
            }
            else
            {
                _idLocalServerThreads[i] = -1;
            }
        }
        return 0;
    }

    case CWM_SHOWFOLDEROPT:
        switch (wParam)
        {
        case CWMW_FOLDEROPTIONS:  // appwiz.cpl used to send this message to us
                                  // now it's done by FolderOptionsRunDll
            DoGlobalFolderOptions();
            break;

        case CWMW_TASKBAROPTIONS: // TaskbarOptionsRunDll sends this message
            PostMessage(_hwndTray, TM_DOTRAYPROPERTIES, 0, 0);
            break;

        default:
            break;
        }
        return 0;

    case CWM_TASKBARWAKEUP:
        _dwThreadIdTray = (DWORD)wParam;
        if (_dwThreadIdTray)
        {
            _iTrayPriority = HIWORD(lParam);
            SetTimer(hwnd, IDT_TASKBARWAKEUP, LOWORD(lParam), NULL);
        }
        break;

    case DTM_CREATESAVEDWINDOWS:
        _InitDeskbars();
        SHCreateSavedWindows();
#ifdef ENABLE_CHANNELS
        _MaybeLaunchChannelBand();
#endif
        // we need to update the recycle bin icon because the recycle bin
        // is per user on NTFS, and thus the state could change w/ each new user
        // who logs in.
        SHUpdateRecycleBinIcon();
        break;
        
    case DTM_SAVESTATE:
        TraceMsg(DM_SHUTDOWN, "cdtb.wp: DTM_SAVESTATE");
        _SaveState();
        break;

    case DTM_RAISE:
        _OnRaise(wParam, lParam);
        break;
    
#ifdef DEBUG
    case DTM_NEXTCTL:
#endif
    case DTM_UIACTIVATEIO:
    case DTM_ONFOCUSCHANGEIS:
        _OnFocusMsg(uMsg, wParam, lParam);
        break;

    case DTM_SETUPAPPRAN:
        _SetupAppRan(wParam, lParam);
        break;

    case DTM_QUERYHKCRCHANGED:
        //  some clients are out of process, so we
        //  can cache their cookies for them.
        if (!lParam && wParam > QHKCRID_NONE && wParam < QHKCRID_MAX)
            lParam = (LPARAM)&_rgdwQHKCRCookies[wParam - QHKCRID_MIN];
            
        return _QueryHKCRChanged(hwnd, (LPDWORD)lParam);
        
    case DTM_UPDATENOW:
        UpdateWindow(hwnd);
        break;

    case DTM_GETVIEWAREAS:
        {
            // wParam is an in/out param. in - the max. # of areas, out - the actual # of areas.
            // if "in" value < "out" value, lParam is not set.
            // The ViewAreas are already stored in the desktop Listview.
            int* pnViewAreas = (int*) wParam;
            LPRECT lprcViewAreas = (LPRECT) lParam;

            if (pnViewAreas)
            {
                int nMaxAreas = *pnViewAreas;
                HWND hwndList = _GetDesktopListview();

                ASSERT(IsWindow(hwndList));
                ListView_GetNumberOfWorkAreas(hwndList, pnViewAreas);
                if (*pnViewAreas >= 0 && *pnViewAreas <= nMaxAreas && lprcViewAreas)
                {
                    ListView_GetWorkAreas(hwndList, *pnViewAreas, lprcViewAreas);
                    // These are in Listview co-ordinates. We have to map them to screen co-ordinates.
                    // [msadek]; MapWindowPoints() is mirroring-aware only if you pass two points
                    for (int i = 0; i <  *pnViewAreas; i++)
                    {
                        MapWindowPoints(hwndList, HWND_DESKTOP, (LPPOINT)(&lprcViewAreas[i]), 2);
                    }    
                }
            }
        }
        break;

    case DTM_MAKEHTMLCHANGES:
        //Make changes to desktop's HTML using Dynamic HTML
        SendMessage(_pbbd->_hwndView, WM_DSV_DESKHTML_CHANGES, wParam, lParam);
        break;

    case DTM_STARTPAGEONOFF:
        SendMessage(_pbbd->_hwndView, WM_DSV_STARTPAGE_TURNONOFF, wParam, lParam);
        break;

    case DTM_REFRESHACTIVEDESKTOP:
        // This message is posted to refresh active desktop in a delayed fashion.
        REFRESHACTIVEDESKTOP();
        break;

    case DTM_SETAPPSTARTCUR:
        {
            INotifyAppStart * pnasTop;
            HRESULT hr = QueryService(SID_STopLevelBrowser, IID_PPV_ARG(INotifyAppStart, &pnasTop));
            if (SUCCEEDED(hr))
            {
                pnasTop->AppStarting();
                pnasTop->Release();
            }
        }
        break;


    // Handle DDE messages for badly written apps (that assume the shell's
    // window is of class Progman and called Program Manager.
    case WM_DDE_INITIATE:
    case WM_DDE_TERMINATE:
    case WM_DDE_ADVISE:
    case WM_DDE_UNADVISE:
    case WM_DDE_ACK:
    case WM_DDE_DATA:
    case WM_DDE_REQUEST:
    case WM_DDE_POKE:
    case WM_DDE_EXECUTE:
        return DDEHandleMsgs(_pbbd->_hwnd, uMsg, wParam, lParam);
        break;

    default:
        if (uMsg == GetDDEExecMsg())
        {
            ASSERT(lParam && 0 == ((LPNMHDR)lParam)->idFrom);

            DDEHandleViewFolderNotify(NULL, _pbbd->_hwnd, (LPNMVIEWFOLDER)lParam);
            LocalFree((LPNMVIEWFOLDER)lParam);
            return TRUE;
        }

DoDefault:
        return _pbsInner->WndProcBS(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

#ifdef ENABLE_CHANNELS
// launch the channelbar, this is called when the desktop has finished starting up.
const WCHAR c_szwChannelBand[] = L"-channelband";

void CDesktopBrowser::_MaybeLaunchChannelBand()
{
    DWORD dwType = REG_SZ;
    TCHAR  szYesOrNo[20];
    DWORD  cbSize = sizeof(szYesOrNo);
    
    BOOL bLaunchChannelBar = FALSE;
    
    if(SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), TEXT("Show_ChannelBand"),
                           &dwType, (void *)szYesOrNo, &cbSize, FALSE, NULL, 0) == ERROR_SUCCESS)
    {
        bLaunchChannelBar = !lstrcmpi(szYesOrNo, TEXT("yes"));
    }
    // Don't launch by default post IE4
    //else if (IsOS(OS_WINDOWS))
    //{
    //    bLaunchChannelBar = TRUE;    // launch channel bar by default on Memphis and win95
    //}

    if (bLaunchChannelBar)
    {
         // fake up a WM_COPYDATA struct 
        COPYDATASTRUCT cds;
        cds.dwData = SW_NORMAL;
        cds.cbData = sizeof(c_szwChannelBand);
        cds.lpData = (void *) c_szwChannelBand;

        // fake it as if we had launched iexplore.exe, it saves us a whole process doing it this way....
        _OnCopyData(&cds);
    }
}
#endif // ENABLE_CHANNELS

//***
// NOTES
//  REARCHITECT should this be CBaseBrowser::IInputObject::UIActIO etc.?
HRESULT CDesktopBrowser::_OnFocusMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fActivate = (BOOL) wParam;

    switch (uMsg) {
    case DTM_UIACTIVATEIO:
        fActivate = (BOOL) wParam;
        TraceMsg(DM_FOCUS, "cdtb.oxiois: DTM_UIActIO fAct=%d dtb=%d", fActivate, (int) lParam);

        if (fActivate) 
        {
            MSG msg = {_pbbd->_hwnd, WM_KEYDOWN, VK_TAB, 0xf0001};
            BOOL bShift = (GetAsyncKeyState(VK_SHIFT) < 0);
            if (bShift) 
            {
                int cToolbars = _pbsInner->_GetToolbarCount();
                while (--cToolbars >= 0) 
                {
                    // activate last toolbar in tab order
                    LPTOOLBARITEM ptbi = _pbsInner->_GetToolbarItem(cToolbars);
                    if (ptbi && ptbi->ptbar) 
                    {
                        IInputObject* pio;
                        if (SUCCEEDED(ptbi->ptbar->QueryInterface(IID_PPV_ARG(IInputObject, &pio)))) 
                        {
                            pio->UIActivateIO(TRUE, &msg);
                            pio->Release();
                            return S_OK;
                        }
                    }
                }
            }

#ifdef KEYBOARDCUES
            // Since we are Tab or Shift Tab we should turn the focus rect on.
            SendMessage(_pbbd->_hwnd, WM_UPDATEUISTATE, MAKEWPARAM(UIS_CLEAR,
                UISF_HIDEFOCUS), 0);
#endif

            // activate view
            if (bShift && _pbbd->_psv)
            {
                _pbbd->_psv->TranslateAccelerator(&msg);
            }
            else
            {
                _pbsInner->_SetFocus(NULL, _pbbd->_hwndView, NULL);
            }
        }
        else {
Ldeact:
            // if we don't have focus, we're fine;
            // if we do have focus, there's nothing we can do about it...
            /*NOTHING*/
            ;
#ifdef DEBUG
            TraceMsg(DM_FOCUS, "cdtb.oxiois: GetFocus()=%x _pbbd->_hwnd=%x _pbbd->_hwndView=%x", GetFocus(), _pbbd->_hwnd, _pbbd->_hwndView);
#endif
        }

        break;

    case DTM_ONFOCUSCHANGEIS:
        TraceMsg(DM_FOCUS, "cdtb.oxiois: DTM_OnFocChgIS hwnd=%x fAct=%d", (HWND) lParam, fActivate);

        if (fActivate) {
            // someone else is activating, so we need to deactivate
            goto Ldeact;
        }

        break;

    default:
        ASSERT(0);
        break;
    }

    return S_OK;
}

LRESULT CALLBACK CDesktopBrowser::DesktopWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDesktopBrowser *psb = (CDesktopBrowser*)GetWindowLongPtr(hwnd, 0);

    switch(uMsg)
    {
    case WM_CREATE:
#ifdef KEYBOARDCUES
        // Initialize our keyboard cues bits
        SendMessage(hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
#endif

        // Set the localized name of the Desktop so it can be used in Error messages
        // that have the desktop window as the title.
        if (EVAL(LoadStringW(HINST_THISDLL, IDS_DESKTOP, psb->_wzDesktopTitle, ARRAYSIZE(psb->_wzDesktopTitle))))
        {
            EVAL(SetProp(hwnd, TEXT("pszDesktopTitleW"), (HANDLE)psb->_wzDesktopTitle));
        }

        if (psb)
            return psb->WndProcBS(hwnd, uMsg, wParam, lParam);
        else
            return DefWindowProc(hwnd, uMsg, wParam, lParam); // known charset

#ifdef KEYBOARDCUES
    case WM_ACTIVATE:
        if (WA_INACTIVE == LOWORD(wParam))
        {
            SendMessage(hwnd, WM_CHANGEUISTATE,
                MAKEWPARAM(UIS_SET, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
        }

        goto DoDefault;
        break;
#endif

    case WM_NCCREATE:

        ASSERT(psb == NULL);

        CDesktopBrowser_CreateInstance(hwnd, (void **)&psb);

        if (psb)
        {
            SetWindowLongPtr(hwnd, 0, (LONG_PTR)psb);
            goto DoDefault;
        }
        else
        {
            return FALSE;
        }
        break;

    case WM_TIMER:
        if (psb)
        {
            switch(wParam)
            {
                case IDT_STARTBACKGROUNDSHELLTASKS:
                    KillTimer(hwnd, IDT_STARTBACKGROUNDSHELLTASKS);
                    psb->StartBackgroundShellTasks();
                    break;
                case IDT_TASKBARWAKEUP:
                    KillTimer(hwnd, IDT_TASKBARWAKEUP);
                    psb->TaskbarWakeup();
                    break;
                default:
                    return psb->WndProcBS(hwnd, uMsg, wParam, lParam);
                    break;
            }
        }
        break;

    case WM_NCDESTROY:

        if (psb)
        {
            RemoveProp(hwnd, TEXT("pszDesktopTitleW"));
            // In case someone does a get shell window and post a WM_QUIT, we need to 
            //  make sure that we also close down our other thread.
            TraceMsg(DM_SHUTDOWN, "cdtb.wp(WM_NCDESTROY): ?post WM_QUIT hwndTray=%x(IsWnd=%d)", psb->_hwndTray, IsWindow(psb->_hwndTray));
            if (psb->_hwndTray && IsWindow(psb->_hwndTray))
                PostMessage(psb->_hwndTray, WM_QUIT, 0, 0);
            psb->ReleaseShellView();
            psb->Release();
        }

        PostQuitMessage(0); // exit out message loop
        break;

    default:
        if (psb)
            return psb->WndProcBS(hwnd, uMsg, wParam, lParam);
        else {
DoDefault:
            return DefWindowProc(hwnd, uMsg, wParam, lParam); // known charset
        }
    }

    return 0;
}

void RegisterDesktopClass()
{
    WNDCLASS wc = {0};

    wc.style = CS_DBLCLKS;
    wc.lpfnWndProc = CDesktopBrowser::DesktopWndProc;
    //wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(void *);
    wc.hInstance = HINST_THISDLL;
    //wc.hIcon = NULL;
    wc.hCursor = GetClassCursor(GetDesktopWindow());
    wc.hbrBackground = (HBRUSH)(COLOR_DESKTOP + 1);
    //wc.lpszMenuName = NULL;
    wc.lpszClassName = TEXT(STR_DESKTOPCLASS);

    RegisterClass(&wc);
}

#define PEEK_NORMAL     0
#define PEEK_QUIT       1
#define PEEK_CONTINUE   2
#define PEEK_CLOSE      3


// RETURNS BOOL whehter to continue the search or not.
// so FALSE means we've found one.
// TRUE means we haven't.
BOOL CALLBACK FindBrowserWindow_Callback(HWND hwnd, LPARAM lParam)
{
    if (IsExplorerWindow(hwnd) || IsFolderWindow(hwnd) || IsTrayWindow(hwnd)) 
    {
        DWORD dwProcID;
        GetWindowThreadProcessId(hwnd, &dwProcID);
        if (dwProcID == GetCurrentProcessId()) 
        {
            if (lParam)
                *((BOOL*)lParam) = TRUE;    // found one!
            return FALSE;   // stop search
        }
    }
    return TRUE;            // continue search
}

#define IsBrowserWindow(hwnd)  !FindBrowserWindow_Callback(hwnd, NULL)

BOOL CALLBACK CloseWindow_Callback(HWND hwnd, LPARAM lParam)
{
    if (IsBrowserWindow(hwnd)) {
        TraceMsg(DM_SHUTDOWN, "s.cw_cb: post WM_CLOSE hwnd=%x", hwnd);
        PostMessage(hwnd, WM_CLOSE, 0, 0);
    }
    return TRUE;
}


UINT CDesktopBrowser::_PeekForAMessage()
{
    MSG  msg;
    BOOL fPeek;

#ifdef FEATURE_STARTPAGE
    if (pPeekEx)
        fPeek = (*pPeekEx)(&msg, NULL, 0, 0, PM_REMOVE, NULL);
    else
        fPeek = PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
#else 
    fPeek =  PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
#endif

    if (fPeek)
    {
        if (msg.message == WM_QUIT)
        {
            TraceMsg(DM_SHUTDOWN, "cdtb.pfam: WM_QUIT wP=%d [lP=%d]", msg.wParam, msg.lParam);
            if (msg.lParam == 1) 
            {
                return PEEK_CLOSE;
            }
            TraceMsg(DM_TRACE, "c.ml: Got quit message for %#08x", GetCurrentThreadId());
            return PEEK_QUIT;  // break all the way out of the main loop
        }

        if (_pbbd->_hwnd)
        {
            if (S_OK == _pbsInner->v_MayTranslateAccelerator(&msg))
                return PEEK_CONTINUE;
        }

        TranslateMessage(&msg);
        DispatchMessage(&msg);

        return PEEK_CONTINUE;   // Go back and get the next message
    }
    return PEEK_NORMAL;
}

void CDesktopBrowser::_MessageLoop()
{
    for (; ;)
    {
        switch (_PeekForAMessage())
        {
        case PEEK_QUIT:
            return;

        case PEEK_NORMAL:
        {
            static  bool    s_fSignaled = false;

            if (!s_fSignaled)
            {
                FireEventSz(TEXT("msgina: ShellReadyEvent"));
                s_fSignaled = true;
                PERFSETMARK("ExplorerDesktopReady");
            }
            WaitMessage();
            break;
        }
        case PEEK_CONTINUE:
            break;
            
        case PEEK_CLOSE:
            // we need to close all the shell windows too
            TraceMsg(DM_SHUTDOWN, "cdtb._ml: PEEK_CLOSE, close/wait all");
            EnumWindows(CloseWindow_Callback, 0);
            {
#define MAXIMUM_DESKTOP_WAIT 15000
                DWORD iStartTime = GetTickCount();
                // block until all other browser windows are closed
                for (;;) 
                {
                    BOOL f = FALSE;
                    EnumWindows(FindBrowserWindow_Callback, (LPARAM)&f);
                    if (!f || (GetTickCount() - iStartTime > MAXIMUM_DESKTOP_WAIT))
                        return;

                    switch (_PeekForAMessage()) 
                    {
                    case PEEK_NORMAL:
                        // don't do a waitmessage because we want to exit when thelast other window is gone
                        // and we don't get a message to signal that
                        Sleep(100);
                        break;
                    }
                }
            }
            return;
        }
    }
}

HRESULT CDesktopBrowser::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SShellDesktop))
        return QueryInterface(riid, ppvObj);

    return _pspInner->QueryService(guidService, riid, ppvObj);
}

void CDesktopBrowser::StartBackgroundShellTasks(void)
{
    HKEY hkey = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("SharedTaskScheduler"), FALSE);
    if (hkey)
    {
        TCHAR szClass[GUIDSTR_MAX];
        DWORD cchClass, dwType;
        int i = 0;
        while (cchClass = ARRAYSIZE(szClass),
               ERROR_SUCCESS == RegEnumValue(hkey, i++, szClass, &cchClass, NULL, &dwType, NULL, NULL))
        {
            CLSID clsid;
            if (SUCCEEDED(SHCLSIDFromString(szClass, &clsid)))
            {
                IRunnableTask* ptask;
                if (SUCCEEDED(CoCreateInstance(clsid, NULL, CLSCTX_INPROC, IID_PPV_ARG(IRunnableTask, &ptask))))
                {
                    // Personally I think the start menu should have priority
                    // over itbar icon extraction, so set this priority list
                    // a tad lower than the default priority (which start menu is at)
                    _AddDesktopTask(ptask, ITSAT_DEFAULT_PRIORITY-1);
                    ptask->Release();
                }
            }
        }
        RegCloseKey(hkey);
    }
}

void CDesktopBrowser::TaskbarWakeup(void)
{
    if (_dwThreadIdTray)
    {
        HANDLE hThread = OpenThread(THREAD_SET_INFORMATION, FALSE, _dwThreadIdTray);
        SetThreadPriority(hThread, _iTrayPriority);
        CloseHandle(hThread);
        _dwThreadIdTray = 0;
    }
}
    

// create the desktop window and its shell view
DWORD_PTR DesktopWindowCreate(CDesktopBrowser **ppBrowser)
{
    *ppBrowser = NULL;
    DWORD dwExStyle = WS_EX_TOOLWINDOW;

    OleInitialize(NULL);
    RegisterDesktopClass();

    _InitDesktopMetrics(0, NULL);

    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;

    //
    // NB This windows class is Progman and it's title is Program Manager. This makes
    // sure apps (like ATM) think that program is running and don't fail their install.
    //
    HWND hwnd = CreateWindowEx(dwExStyle, TEXT(STR_DESKTOPCLASS), TEXT("Program Manager"),
        WS_POPUP | WS_CLIPCHILDREN,
        g_xVirtualScreen, g_yVirtualScreen,
        g_cxVirtualScreen, g_cyVirtualScreen,
        NULL, NULL, HINST_THISDLL, NULL);

    // The returned hwnd can already be bogus if the system is shutting
    // down and user has somehow already called xxxDestroyWindow on us
    // even though we never even received a WM_NCCREATE!!
    // CreateWindowEx ends up returning a handle to a window that
    // has already been destroyed.  So in that case, act as if
    // CreateWindowEx failed (because it did!)
    if (!IsWindow(hwnd)) hwnd = NULL;

    if (hwnd)
    {
        CDesktopBrowser *psb = (CDesktopBrowser*)GetWindowLongPtr(hwnd, 0);
        ASSERT(psb);

        if (!SHRestricted(REST_NODESKTOP))
        {
            // do this here to avoid painting the desktop, then repainting
            // when the tray appears and causes everything to move
#ifdef FEATURE_STARTPAGE
            if (!SHRegGetBoolUSValue(REGSTR_PATH_EXPLORER, TEXT("FaultID"), FALSE, FALSE))
#endif
            {
                ShowWindow(hwnd, SW_SHOW);
                UpdateWindow(hwnd);
            }
        }

        SetTimer(hwnd, IDT_STARTBACKGROUNDSHELLTASKS, 5 * 1000, NULL);
      
        *ppBrowser = (CDesktopBrowser*)GetWindowLongPtr(hwnd, 0);
    }

    return (DWORD_PTR)hwnd;
}

STDAPI_(HANDLE) SHCreateDesktop(IDeskTray* pdtray)
{
    if (g_dwProfileCAP & 0x00000010)
        StartCAP();

    ASSERT(pdtray);
    ASSERT(g_pdtray==NULL);
    g_pdtray = pdtray;
    pdtray->AddRef();   // this is no-op, but we want to follow the COM rule.

    // put the desktop on the main thread (this is needed for win95 so that
    // the DDeExecuteHack() in user.exe works, it needs the desktop and the 
    // DDE window on the mainthread
    CDesktopBrowser *pBrowser;
    if (DesktopWindowCreate(&pBrowser))
    {
        if (g_dwProfileCAP & 0x00040000)
            StopCAP();
    
        // hack, cast the object to a handle (otherwise we have to export the class
        // declaration so that explorer.exe can use it)
        return (HANDLE) pBrowser;
    }
    return NULL;
}

// nash:49485 (IME focus) and nash:nobug (win95 compat)
// make sure keyboard input goes to the desktop.  this is
// a) win95 compat: where focus was on win95 and
// b) nash:49485: focus was in the empty taskband on login so
// the keys went into the bitbucket
//
// If some other process has stolen the foreground window,
// don't be rude and grab it back.

void FriendlySetForegroundWindow(HWND hwnd)
{
    HWND hwndOld = GetForegroundWindow();
    if (hwndOld)
    {
        DWORD dwProcessId;
        
        GetWindowThreadProcessId(hwndOld, &dwProcessId);
        if (dwProcessId == GetCurrentProcessId())
            hwndOld = NULL;
    }
    if (!hwndOld)
        SetForegroundWindow(hwnd);
}

#ifdef FEATURE_STARTPAGE
STDAPI_(HWND) SetPeekMsgEx(FARPROC fp, HANDLE hDesktop)
{
    HWND hwnd= NULL;
    pPeekEx = (PeekMessageEx)fp;
    CDesktopBrowser *pBrowser = (CDesktopBrowser *) hDesktop;
    if (pBrowser)
    {
        hwnd = pBrowser->GetViewWnd();
    }
    return hwnd;
}

STDAPI_(BOOL) SetStartPageHWND(HANDLE hDesktop, HWND hwnd)
{
    CDesktopBrowser *pBrowser = (CDesktopBrowser *) hDesktop;
    if (pBrowser)
    {
        pBrowser->SetStartPageHWND(hwnd);
    }
    return TRUE;
}
#endif

STDAPI_(BOOL) SHDesktopMessageLoop(HANDLE hDesktop)
{
    CDesktopBrowser *pBrowser = (CDesktopBrowser *) hDesktop;
    if (pBrowser)
    {
        // We must AddRef the pBrowser because _MessageLoop() will
        // Release() it if another app initiated a system shutdown.
        // We will do our own Release() when we don't need the pointer
        // any more.

        pBrowser->AddRef();

        FriendlySetForegroundWindow(pBrowser->GetDesktopWindow());

        pBrowser->_MessageLoop();

        IconCacheSave();

        // In case someone posted us a WM_QUIT message, before terminating
        // the thread, make sure it is properly destroyed so that trident etc
        // gets properly freed up.
        HWND hwnd;
        if (hwnd = pBrowser->GetDesktopWindow())
        {
            DestroyWindow(hwnd);
        }
        pBrowser->Release();
        OleUninitialize();

    }
    return BOOLFROMPTR(pBrowser);
}

void EscapeAccelerators(LPTSTR psz)
{
    LPTSTR pszEscape;
    
    while (pszEscape = StrChr(psz, TEXT('&'))) 
    {
        int iLen = lstrlen(pszEscape)+1;
        MoveMemory(pszEscape+1, pszEscape, iLen * sizeof(TCHAR));
        pszEscape[0] = TEXT('&');
        psz = pszEscape + 2;
    }
}


//
// Whenever we remove the toolbar from the desktop, we persist it.
//
HRESULT CDesktopBrowser::RemoveToolbar(IUnknown* punkSrc, DWORD dwRemoveFlags)
{
    HRESULT hres = E_FAIL;
    UINT itb = _pbsInner->_FindTBar(punkSrc);
    if (itb==(UINT)-1) 
    {
        return E_INVALIDARG;
    }

    LPTOOLBARITEM ptbi = _pbsInner->_GetToolbarItem(itb);
    if (ptbi && ptbi->pwszItem) 
    {
        LPCWSTR szItem = ptbi->pwszItem;
        if (dwRemoveFlags & STFRF_DELETECONFIGDATA) 
        {
            DeleteDesktopViewStream(szItem);
        }
        else
        {
            IStream* pstm = GetDesktopViewStream(STGM_WRITE, szItem);
            if (pstm) 
            {
                IPersistStreamInit* ppstm;
                HRESULT hresT = punkSrc->QueryInterface(IID_PPV_ARG(IPersistStreamInit, &ppstm));
                if (SUCCEEDED(hresT)) {
                    ppstm->Save(pstm, TRUE);
                    ppstm->Release();
                }
                pstm->Release();
            }
        }
    }

    hres = _pdwfInner->RemoveToolbar(punkSrc, dwRemoveFlags);
    _UpdateViewRectSize();
    return hres;
}

HRESULT CDesktopBrowser::GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder)
{
    BOOL bUseHmonitor = (GetNumberOfMonitors() > 1);
    return _pbsInner->_GetBorderDWHelper(punkSrc, lprectBorder, bUseHmonitor);    
}

HRESULT CDesktopBrowser::_ResizeNextBorder(UINT itb)
{
    _ResizeNextBorderHelper(itb, TRUE);
    return S_OK;
}

HRESULT CDesktopBrowser::GetMonitor(IUnknown* punkSrc, HMONITOR * phMon)
{
    ASSERT(phMon);
    *phMon = NULL;              // just in case

    UINT itb = _pbsInner->_FindTBar(punkSrc);
    if (itb==(UINT)-1) {
        return E_INVALIDARG;
    }

    LPTOOLBARITEM ptbi = _pbsInner->_GetToolbarItem(itb);
    if (ptbi) {
        *phMon = ptbi->hMon;
        return S_OK;
    } else {
        return E_FAIL;
    }
}

HRESULT CDesktopBrowser::RequestMonitor(IUnknown* punkSrc, HMONITOR * phMonitor)
{
    UINT itb = _pbsInner->_FindTBar(punkSrc);
    if (itb==(UINT)-1) {
        return E_INVALIDARG;
    }

    ASSERT(phMonitor);
    if (IsMonitorValid(*phMonitor))
        return S_OK;
    else
    {
        *phMonitor = GetPrimaryMonitor();
        return S_FALSE;
    }
}

HRESULT CDesktopBrowser::SetMonitor(IUnknown* punkSrc, HMONITOR hMonNew, HMONITOR * phMonOld)
{
    ASSERT(phMonOld);
    *phMonOld = NULL;           // just in case

    UINT itb = _pbsInner->_FindTBar(punkSrc);
    if (itb==(UINT)-1) {
        return E_INVALIDARG;
    }
    
    LPTOOLBARITEM ptbThis = _pbsInner->_GetToolbarItem(itb);
    if (ptbThis) {
        *phMonOld = ptbThis->hMon;
        ptbThis->hMon = hMonNew;
        return S_OK;
    } else {
        return E_FAIL;
    }
}

///////////////////////////////////////////////////////////////////////
//
// CDesktopBrowser FORWARDERS to commonsb
//

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _psbInner-> _function _args ; }                                            

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IShellBrowser (same as IOleInPlaceFrame)
CALL_INNER_HRESULT(GetWindow, (HWND * lphwnd), (lphwnd));
CALL_INNER_HRESULT(ContextSensitiveHelp, (BOOL fEnterMode), (fEnterMode));
CALL_INNER_HRESULT(InsertMenusSB, (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths), (hmenuShared, lpMenuWidths));
CALL_INNER_HRESULT(SetMenuSB, (HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd), (hmenuShared, holemenu, hwnd));
CALL_INNER_HRESULT(RemoveMenusSB, (HMENU hmenuShared), (hmenuShared));
CALL_INNER_HRESULT(SetStatusTextSB, (LPCOLESTR lpszStatusText), (lpszStatusText));
CALL_INNER_HRESULT(EnableModelessSB, (BOOL fEnable), (fEnable));
CALL_INNER_HRESULT(TranslateAcceleratorSB, (LPMSG lpmsg, WORD wID), (lpmsg, wID));
CALL_INNER_HRESULT(GetViewStateStream, (DWORD grfMode, LPSTREAM  *ppStrm), (grfMode, ppStrm));
CALL_INNER_HRESULT(GetControlWindow, (UINT id, HWND * lphwnd), (id, lphwnd));
CALL_INNER_HRESULT(SendControlMsg, (UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret), (id, uMsg, wParam, lParam, pret));
CALL_INNER_HRESULT(QueryActiveShellView, (struct IShellView ** ppshv), (ppshv));
CALL_INNER_HRESULT(OnViewWindowActive, (struct IShellView * ppshv), (ppshv));
CALL_INNER_HRESULT(SetToolbarItems, (LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags), (lpButtons, nButtons, uFlags));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _pdwsInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IDockingWindowSite
    // TODO: move these up from basesb to commonsb - requires toolbars
CALL_INNER_HRESULT(RequestBorderSpaceDW, (IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths), (punkSrc, pborderwidths));
CALL_INNER_HRESULT(SetBorderSpaceDW, (IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths), (punkSrc, pborderwidths));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }


// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _pdwfInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IDockingWindowFrame
CALL_INNER_HRESULT(AddToolbar, (IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwReserved), (punkSrc, pwszItem, dwReserved));
CALL_INNER_HRESULT(FindToolbar, (LPCWSTR pwszItem, REFIID riid, void **ppvObj), (pwszItem, riid, ppvObj));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _piosInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IInputObjectSite
CALL_INNER_HRESULT(OnFocusChangeIS, (IUnknown* punkSrc, BOOL fSetFocus), (punkSrc, fSetFocus));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _pdtInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // *** IDropTarget ***
CALL_INNER_HRESULT(DragLeave, (void), ());

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _pbsInner-> _function _args ; }                                            

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)
 

// *** IBrowserService2 specific methods ***
CALL_INNER_HRESULT(GetParentSite, ( IOleInPlaceSite** ppipsite), ( ppipsite));
CALL_INNER_HRESULT(SetTitle, (IShellView* psv, LPCWSTR pszName), (psv, pszName));
CALL_INNER_HRESULT(GetTitle, (IShellView* psv, LPWSTR pszName, DWORD cchName), (psv, pszName, cchName));
CALL_INNER_HRESULT(GetOleObject, ( IOleObject** ppobjv), ( ppobjv));

// think about this one.. I'm not sure we want to expose this -- Chee
// My impression is that we won't document this whole interface???
CALL_INNER_HRESULT(GetTravelLog, (ITravelLog** pptl), (pptl));

CALL_INNER_HRESULT(ShowControlWindow, (UINT id, BOOL fShow), (id, fShow));
CALL_INNER_HRESULT(IsControlWindowShown, (UINT id, BOOL *pfShown), (id, pfShown));
CALL_INNER_HRESULT(IEGetDisplayName, (LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags), (pidl, pwszName, uFlags));
CALL_INNER_HRESULT(IEParseDisplayName, (UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut), (uiCP, pwszPath, ppidlOut));
CALL_INNER_HRESULT(DisplayParseError, (HRESULT hres, LPCWSTR pwszPath), (hres, pwszPath));
CALL_INNER_HRESULT(NavigateToPidl, (LPCITEMIDLIST pidl, DWORD grfHLNF), (pidl, grfHLNF));

CALL_INNER_HRESULT(SetNavigateState, (BNSTATE bnstate), (bnstate));
CALL_INNER_HRESULT(GetNavigateState,  (BNSTATE *pbnstate), (pbnstate));

CALL_INNER_HRESULT(NotifyRedirect,  ( IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse), ( psv, pidl, pfDidBrowse));
CALL_INNER_HRESULT(UpdateWindowList,  (), ());

CALL_INNER_HRESULT(UpdateBackForwardState,  (), ());

CALL_INNER_HRESULT(SetFlags, (DWORD dwFlags, DWORD dwFlagMask), (dwFlags, dwFlagMask));
CALL_INNER_HRESULT(GetFlags, (DWORD *pdwFlags), (pdwFlags));

// Tells if it can navigate now or not.
CALL_INNER_HRESULT(CanNavigateNow,  (), ());

CALL_INNER_HRESULT(GetPidl,  (LPITEMIDLIST *ppidl), (ppidl));
CALL_INNER_HRESULT(SetReferrer,  (LPITEMIDLIST pidl), (pidl));
CALL_INNER(DWORD,  GetBrowserIndex ,(), ());
CALL_INNER_HRESULT(GetBrowserByIndex, (DWORD dwID, IUnknown **ppunk), (dwID, ppunk));
CALL_INNER_HRESULT(GetHistoryObject, (IOleObject **ppole, IStream **pstm, IBindCtx **ppbc), (ppole, pstm, ppbc));
CALL_INNER_HRESULT(SetHistoryObject, (IOleObject *pole, BOOL fIsLocalAnchor), (pole, fIsLocalAnchor));

CALL_INNER_HRESULT(CacheOLEServer, (IOleObject *pole), (pole));

CALL_INNER_HRESULT(GetSetCodePage, (VARIANT* pvarIn, VARIANT* pvarOut), (pvarIn, pvarOut));
CALL_INNER_HRESULT(OnHttpEquiv, (IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut), (psv, fDone, pvarargIn, pvarargOut));

CALL_INNER_HRESULT(GetPalette, ( HPALETTE * hpal), ( hpal));

CALL_INNER_HRESULT(OnSetFocus, (), ());
CALL_INNER_HRESULT(OnFrameWindowActivateBS, (BOOL fActive), (fActive));

CALL_INNER_HRESULT(RegisterWindow, (BOOL fUnregister, int swc), (fUnregister, swc));
CALL_INNER_HRESULT(GetBaseBrowserData,(LPCBASEBROWSERDATA* ppbd), (ppbd));
CALL_INNER(LPBASEBROWSERDATA, PutBaseBrowserData,(), ());
CALL_INNER_HRESULT(CreateViewWindow, (IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd), (psvNew, psvOld, prcView, phwnd));;
CALL_INNER_HRESULT(SetTopBrowser, (), ());
CALL_INNER_HRESULT(InitializeDownloadManager, (), ());
CALL_INNER_HRESULT(InitializeTransitionSite, (), ());
CALL_INNER_HRESULT(Offline, (int iCmd), (iCmd));
CALL_INNER_HRESULT(AllowViewResize, (BOOL f), (f));
CALL_INNER_HRESULT(SetActivateState, (UINT u), (u));
CALL_INNER_HRESULT(UpdateSecureLockIcon, (int eSecureLock), (eSecureLock));
CALL_INNER_HRESULT(CreateBrowserPropSheetExt, (REFIID riid, void **ppvObj), (riid, ppvObj));

CALL_INNER_HRESULT(GetViewWindow,(HWND * phwnd), (phwnd));
CALL_INNER_HRESULT(InitializeTravelLog,(ITravelLog* ptl, DWORD dw), (ptl, dw));

CALL_INNER_HRESULT(_UIActivateView, (UINT uState), (uState));

CALL_INNER_HRESULT(_ResizeView,(), ());

CALL_INNER_HRESULT(_ExecChildren, (IUnknown *punkBar, BOOL fBroadcast, const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut),
        (punkBar, fBroadcast, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
CALL_INNER_HRESULT(_SendChildren,
        (HWND hwndBar, BOOL fBroadcast, UINT uMsg, WPARAM wParam, LPARAM lParam),
        (hwndBar, fBroadcast, uMsg, wParam, lParam));

CALL_INNER_HRESULT(_OnFocusChange, (UINT itb), (itb));
CALL_INNER_HRESULT(v_ShowHideChildWindows, (BOOL fChildOnly), (fChildOnly));

CALL_INNER_HRESULT(_GetViewBorderRect, (RECT* prc), (prc));


    // BEGIN REVIEW:  review names and need of each.  
    // 
    // this first set could be basebrowser only members.  no one overrides
CALL_INNER_HRESULT(_CancelPendingNavigationAsync, (), ());
CALL_INNER_HRESULT(_MaySaveChanges, (), ()); 
CALL_INNER_HRESULT(_PauseOrResumeView, (BOOL fPaused), (fPaused));
CALL_INNER_HRESULT(_DisableModeless, (), ());
    
    // rethink these... are all of these necessary?
CALL_INNER_HRESULT(_NavigateToPidl, (LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags), (pidl, grfHLNF, dwFlags));
CALL_INNER_HRESULT(_TryShell2Rename, (IShellView* psv, LPCITEMIDLIST pidlNew), (psv, pidlNew));
CALL_INNER_HRESULT(_SwitchActivationNow, () , ());
CALL_INNER_HRESULT(_CancelPendingView, (), ());

    //END REVIEW:

CALL_INNER(UINT, _get_itbLastFocus, (), ());
CALL_INNER_HRESULT(_put_itbLastFocus, (UINT itbLastFocus), (itbLastFocus));

CALL_INNER_HRESULT(_ResizeNextBorderHelper, (UINT itb, BOOL bUseHmonitor), (itb, bUseHmonitor));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }



// RunDll32 entry point to create a new local server on the desktop
// thread.  We convert the CLSID to the index into the LocalServer list
// and then send it to the desktop, which inturn spins the thread off.

STDAPI_(void) SHCreateLocalServerRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    CLSID clsidLocalServer;
    if (GUIDFromStringA(pszCmdLine, &clsidLocalServer))
    {
        for (int i = 0; i < ARRAYSIZE(c_localServers); i++)
        {
            if (IsEqualCLSID(clsidLocalServer, *c_localServers[i]))
            {
                PostMessage(GetShellWindow(), CWM_CREATELOCALSERVER, (WPARAM)TRUE, (LPARAM)i);
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\dsubscri.h ===
BOOL DeleteFromSubscriptionList(LPCTSTR pszURL);
BOOL CheckForExistingSubscription(LPCTSTR lpcszURL);
BOOL UpdateSubscription(LPCTSTR pszURL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\dutil.h ===
#ifndef _DUTIL_H_
#define _DUTIL_H_

#include "local.h"
#include "deskstat.h"

extern "C" LONG g_cRefThisDll;

typedef struct _EnumMonitorsArea
{
    int iMonitors;
    RECT rcWorkArea[LV_MAX_WORKAREAS];
    RECT rcMonitor[LV_MAX_WORKAREAS];
    RECT rcVirtualMonitor;
    RECT rcVirtualWorkArea;         //Excluding the tray/toolbar areas
} EnumMonitorsArea;

void SaveDefaultFolderSettings();
BOOL GetFileName(HWND hdlg, LPTSTR pszFileName, int iSize, int iTypeId[], DWORD dwFlags[]);
void PatternToDwords(LPTSTR psz, DWORD *pdwBits);
void PatternToWords(LPTSTR psz, WORD *pwBits);
BOOL IsValidPattern(LPCTSTR pszPat);
BOOL IsNormalWallpaper(LPCTSTR pszFileName);
BOOL IsWallpaperPicture(LPCTSTR pszWallpaper);
void CheckAndResolveLocalUrlFile(LPTSTR pszFileName, int cchFileName);
void GetMyCurHomePageStartPos(int *piLeft, int *piTop, DWORD *pdwWidth, DWORD *pdwHeight);
BOOL AddRemoveDesktopComponentNoUI(BOOL fAdd, DWORD dwApplyFlags, LPCTSTR pszUrl, LPCTSTR pszFriendlyName, int iCompType, int iLeft, int iTop, int iWidth, int iHeight, BOOL fChecked, DWORD dwCurItemState, BOOL fNoScroll = FALSE, BOOL fCanResize = TRUE);
void InitDeskHtmlGlobals(void);
HBITMAP LoadMonitorBitmap(void);
void PositionComponent(COMPONENTA *pcomp, COMPPOS *pcp, int iCompType, BOOL fCheckItemState);
BOOL UpdateDesktopPosition(LPTSTR pszCompId, int iLeft, int iTop, DWORD dwWidth, DWORD dwHeight, int izIndex, BOOL fSaveState, BOOL fSaveOriginal, DWORD dwNewState);
BOOL GetSavedStateInfo(LPTSTR pszCompId, LPCOMPSTATEINFO    pCompState, BOOL fRestoredState);
DWORD GetCurrentState(LPTSTR pszCompId);
BOOL UpdateComponentFlags(LPCTSTR pszCompId, DWORD dwMask, DWORD dwNewFlags);
void GetRegLocation(LPTSTR lpszResult, DWORD cchResult, LPCTSTR lpszKey, LPCTSTR lpszScheme);
BOOL ValidateFileName(HWND hwnd, LPCTSTR pszFilename, int iTypeString);

void EnableADifHtmlWallpaper(HWND hwnd);
void GetWallpaperDirName(LPTSTR lpszWallPaperDir, int iBuffSize);
BOOL _AddDesktopComponentA(HWND hwnd, LPCSTR pszUrlA, int iCompType, int iLeft, int iTop, int iWidth, int iHeight, DWORD dwFlags);
void GetMonitorSettings(EnumMonitorsArea* ema);
int GetWorkAreaIndex(COMPPOS *pcp, LPCRECT prect, int crect, LPPOINT lpptVirtualTopLeft);
int GetWorkAreaIndexFromPoint(POINT pt, LPCRECT prect, int crect);
void ReadWallpaperStyleFromReg(LPCTSTR pszRegKey, DWORD *pdwWallpaperStyle, BOOL fIgnorePlatforms);
void GetWallpaperWithPath(LPCTSTR szWallpaper, LPTSTR szWallpaperWithPath, int iBufSize);
BOOL GetViewAreas(LPRECT lprcViewAreas, int* pnViewAreas);
BOOL GetZoomRect(BOOL fFullScreen, BOOL fAdjustListview, int tridentLeft, int tridentTop, DWORD componentWidth, DWORD componentHeight, LPRECT prcZoom, LPRECT prcWork);
void GetNextComponentPosition(COMPPOS *pcp);
void IncrementComponentsPositioned(void);
void ValidateComponentPosition(COMPPOS *pcp, DWORD dwComponentState, int iComponentType, bool *pbChangedPosition, bool *pbChangedSize);
int GetcyCaption();
BOOL IsICWCompleted(void);
void LaunchICW(void);
BOOL IsLocalPicture(LPCTSTR pszURL);
BOOL DisableUndisplayableComponents(IActiveDesktop *pIAD);

void PathUnExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize);
void PathExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize);

// Top level reg keys
#define REG_DESKCOMP                        TEXT("Software\\Microsoft\\Internet Explorer\\Desktop")
#define REG_DESKCOMP_GENERAL                TEXT("Software\\Microsoft\\Internet Explorer\\Desktop%sGeneral")
#define REG_DESKCOMP_GENERAL_SUFFIX         TEXT("General")
#define REG_DESKCOMP_COMPONENTS             TEXT("Software\\Microsoft\\Internet Explorer\\Desktop%sComponents")
#define REG_DESKCOMP_COMPONENTS_SUFFIX      TEXT("Components")
#define REG_DESKCOMP_SAFEMODE               TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\SafeMode")
#define REG_DESKCOMP_SAFEMODE_SUFFIX        TEXT("SafeMode")
#define REG_DESKCOMP_SAFEMODE_SUFFIX_L      L"SafeMode"
#define REG_DESKCOMP_SCHEME                 TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\Scheme")
#define REG_DESKCOMP_SCHEME_LOCATION        TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\Scheme\\Location")
#define REG_DESKCOMP_SCHEME_SUFFIX          TEXT("Scheme")
#define REG_DESKCOMP_COMPONENTS_ROOT        TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\Components")
#define REG_DESKCOMP_GENERAL_ROOT           TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\General")
#define REG_DESKCOMP_OLDWORKAREAS           TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\Old WorkAreas")
#define REG_DESKCOMP_ADMINCOMP_ROOT         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\ActiveDesktop\\AdminComponent")

// values for toplevel (misc)
#define REG_VAL_MISC_CHANNELSIZE            TEXT("ChannelSize")

// values for General
#define REG_VAL_GENERAL_CCOMPPOS            TEXT("ComponentsPositioned")
#define REG_VAL_GENERAL_DESKTOPFILE         TEXT("HTMLFile")
#define REG_VAL_GENERAL_TILEWALLPAPER       TEXT("TileWallpaper")
#define REG_VAL_GENERAL_WALLPAPER           TEXT("Wallpaper")
#define REG_VAL_GENERAL_BACKUPWALLPAPER     TEXT("BackupWallpaper")
#define REG_VAL_GENERAL_WALLPAPERTIME       TEXT("WallpaperFileTime")
#define REG_VAL_GENERAL_WALLPAPERLOCALTIME  TEXT("WallpaperLocalFileTime")
#define REG_VAL_GENERAL_WALLPAPERSTYLE      TEXT("WallpaperStyle")
#define REG_VAL_GENERAL_VISITGALLERY        TEXT("VisitGallery")
#define REG_VAL_GENERAL_RESTRICTUPDATE      TEXT("RestrictChannelUI")

// values for Components
#define REG_VAL_COMP_VERSION                TEXT("DeskHtmlVersion")
#define REG_VAL_COMP_MINOR_VERSION          TEXT("DeskHtmlMinorVersion")
#define REG_VAL_COMP_GENFLAGS               TEXT("GeneralFlags")
#define REG_VAL_COMP_SETTINGS               TEXT("Settings")
#define REG_VAL_COMP_UPGRADED_FROM          TEXT("UpgradedFrom")

// values for each component entry
#define REG_VAL_COMP_FLAGS                  TEXT("Flags")
#define REG_VAL_COMP_NAME                   TEXT("FriendlyName")
#define REG_VAL_COMP_POSITION               TEXT("Position")
#define REG_VAL_COMP_SOURCE                 TEXT("Source")
#define REG_VAL_COMP_SUBSCRIBED_URL         TEXT("SubscribedURL")
#define REG_VAL_COMP_CURSTATE               TEXT("CurrentState")
#define REG_VAL_COMP_ORIGINALSTATEINFO      TEXT("OriginalStateInfo")
#define REG_VAL_COMP_RESTOREDSTATEINFO      TEXT("RestoredStateInfo")

// values for Scheme
#define REG_VAL_SCHEME_DISPLAY              TEXT("Display")
#define REG_VAL_SCHEME_EDIT                 TEXT("Edit")

// values for old work areas
#define REG_VAL_OLDWORKAREAS_COUNT          TEXT("NoOfOldWorkAreas")
#define REG_VAL_OLDWORKAREAS_RECTS          TEXT("OldWorkAreaRects")

// values for Admin Component
#define REG_VAL_ADMINCOMP_ADD               TEXT("Add")
#define REG_VAL_ADMINCOMP_DELETE            TEXT("Delete")

TCHAR g_szNone[];
EXTERN_C const TCHAR c_szPatterns[];
EXTERN_C const TCHAR c_szComponentPreview[];
EXTERN_C const TCHAR c_szRegDeskHtmlProp[];
EXTERN_C const TCHAR c_szBackgroundPreview2[];
EXTERN_C const TCHAR c_szZero[];
EXTERN_C const TCHAR c_szWallpaper[];

#define EnableApplyButton(hdlg) PropSheet_Changed(GetParent(hdlg), hdlg)

// Note: Incrementing the CUR_DESKHTML_VERSION will blow away all the existing
// components already in the registry. So, do this with caution!
#define CUR_DESKHTML_VERSION 0x110

// Note: Incrementing the CUR_DESKHTM_MINOR_VERSION can be used to do two things:
// 1. It will simply set the dirty bit sothat the desktop.htt gets re-generated. 
//    For example, do this whenever template file deskmovr.htt changes.
// 2. It can be used to add a new default component (for example "MyCurrentHome") without
//    destroying any of the existing components in the user's registry.
//
#define CUR_DESKHTML_MINOR_VERSION 0x0005

//The following are the Major and minor version numbers stamped on the registry for IE4.0x
#define IE4_DESKHTML_VERSION        0x010e
#define IE4_DESKHTML_MINOR_VERSION  0x0001

//The following are the Major and minor version numbers stamped on the registry for IE5.0x
#define IE5_DESKHTML_VERSION        0x010f
#define IE5_DESKHTML_MINOR_VERSION  0x0001

//The following are the Major and minor version numbers stamped on the registry for NT5 (W2K)
#define NT5_DESKHTML_VERSION        0x0110
#define NT5_DESKHTML_MINOR_VERSION  0x0003

//The following major & minor version is the only version where desktop v2 was present 
//as a component.
#define DESKV2_DESKHTML_VERSION       0x0110
#define DESKV2_DESKHTML_MINOR_VERSION 0x0004


#define  COMPON_FILENAME              TEXT("\\Web\\Compon.htm")
#define  COMPONENTHTML_FILENAME       TEXT("\\Web\\TryIt.htm")
#define  DESKTOPHTML_DEFAULT_SAFEMODE TEXT("\\Web\\SafeMode.htt")
#define  DESKTOPHTML_DEFAULT_WALLPAPER TEXT("Wallpapr.htm")
#define  DESKTOPHTML_DEFAULT_MEMPHIS_WALLPAPER TEXT("Windows98.htm")
#define  DESKTOPHTML_DEFAULT_NT5_WALLPAPER TEXT("Active Desktop Wallpaper.htm")
//#define  DESKTOPHTML_DEFAULT_NT5_WALLPAPER TEXT("Windows 2000 Wallpaper.bmp")
#define  PREVIEW_PICTURE_FILENAME      TEXT("PrePict.htm")
#define  DESKTOPHTML_WEB_DIR           TEXT("\\Web")

#define GFN_PICTURE         0x00000001
#define GFN_LOCALHTM        0x00000002      // local *.htm and *.html files only
#define GFN_URL             0x00000004
#define GFN_CDF             0x00000008
#define GFN_LOCALMHTML      0x00000010      // local *.mht and *.mhtml files only
#define GFN_ALL             (GFN_PICTURE | GFN_LOCALHTM | GFN_URL | GFN_CDF | GFN_LOCALMHTML)

#define CXYDESKPATTERN 8

// Valid bits for REG_VAL_COMP_SETTINGS
#define COMPSETTING_ENABLE      0x00000001    

//
// Dimensions of the monitor contents in the monitor bitmap.
// Used in the desk property sheet "preview" controls.
//
#define MON_X 16
#define MON_Y 17
#define MON_DX 152
#define MON_DY 112

//
// Attributes of default components.
//
#define EGG_LEFT            130
#define EGG_TOP             180
#define EGG_WIDTH           160
#define EGG_HEIGHT          160

#define CBAR_SOURCE         TEXT("131A6951-7F78-11D0-A979-00C04FD705A2")
#define CBAR_TOP            6
#define CBAR_WIDTH          84
#define CBAR_BUTTON_HEIGHT  35 // height of one button

// My Current Home page component's default values.
#define MY_HOMEPAGE_SOURCE  TEXT("About:Home")
#define MY_HOMEPAGE_SOURCEW L"About:Home"
#define MYCURHOME_TOP       6
#define MYCURHOME_WIDTH     160
#define MYCURHOME_HEIGHT    160

#define COMPONENT_PER_ROW 3
#define COMPONENT_PER_COL 2

int SHLoadString(HINSTANCE hInstance, UINT uID, LPTSTR szBuffer, int nBufferMax);

#define  LoadMenuPopup(id) SHLoadMenuPopup(HINST_THISDLL, id)

#define VALIDATESTATE(x)            ((((x) & ~IS_VALIDSTATEBITS) == 0) && ((((x) & IS_VALIDSIZESTATEBITS) == IS_NORMAL) || (((x) & IS_VALIDSIZESTATEBITS) == IS_SPLIT) || (((x) & IS_VALIDSIZESTATEBITS) == IS_FULLSCREEN)))
#define ISZOOMED(x)                 (((x)->dwCurItemState & IS_SPLIT) || ((x)->dwCurItemState & IS_FULLSCREEN))
#define IsZoomedState(itemState)    ((((itemState) & IS_SPLIT) != 0) || (((itemState) & IS_FULLSCREEN) != 0))

// dvutil.cpp
#include <webcheck.h>
#include <mshtml.h>
typedef struct IHTMLElement IHTMLElement;
HRESULT CSSOM_TopLeft(IHTMLElement * pIElem, POINT * ppt);
HRESULT GetHTMLElementStrMember(IHTMLElement *pielem, LPTSTR pszName, DWORD cchSize, BSTR bstrMember);
HRESULT IElemCheckForExistingSubscription(IHTMLElement *pielem);
HRESULT IElemCloseDesktopComp(IHTMLElement *pielem);
HRESULT IElemGetSubscriptionsDialog(IHTMLElement *pielem, HWND hwnd);
HRESULT IElemSubscribeDialog(IHTMLElement *pielem, HWND hwnd);
HRESULT IElemUnsubscribe(IHTMLElement *pielem);
HRESULT IElemUpdate(IHTMLElement *pielem);
HRESULT IElemOpenInNewWindow(IHTMLElement *pielem, IOleClientSite *piOCSite, BOOL fShowFrame, LONG width, LONG height);
HRESULT ShowSubscriptionProperties(LPCTSTR pszUrl, HWND hwnd);
HRESULT CreateSubscriptionsWizard(SUBSCRIPTIONTYPE subType, LPCTSTR pszUrl, SUBSCRIPTIONINFO *pInfo, HWND hwnd);
BOOL CheckForExistingSubscription(LPCTSTR lpcszURL);
void ZoomComponent(COMPPOS * pcp, DWORD dwItemState, BOOL fAdjustListview);

#define GET_CYCAPTION   (GetcyCaption())
#define GET_CXSIZE      (GetSystemMetrics(SM_CXSIZEFRAME) - GetSystemMetrics(SM_CXBORDER))
#define GET_CYSIZE      (GetSystemMetrics(SM_CYSIZEFRAME) - GetSystemMetrics(SM_CYBORDER))

#endif // _DUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\dvoc.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "stdenum.h"
#include <mshtmdid.h>
#include "..\util.h"

#define SZ_ATL_SHEMBEDDING_WNDCLASS         TEXT("ATL Shell Embedding")

HRESULT MakeSafeForScripting(IUnknown** ppDisp);

class ATL_NO_VTABLE CWebViewFolderContents
                    : public CComObjectRootEx<CComSingleThreadModel>
                    , public CComCoClass<CWebViewFolderContents, &CLSID_WebViewFolderContents>
                    , public CComControl<CWebViewFolderContents>
                    , public IDispatchImpl<IShellFolderViewDual2, &IID_IShellFolderViewDual2, &LIBID_Shell32, 1, 0, CComTypeInfoHolder>
                    , public IProvideClassInfo2Impl<&CLSID_WebViewFolderContents, NULL, &LIBID_Shell32, 1, 0, CComTypeInfoHolder>
                    , public IPersistImpl<CWebViewFolderContents>
                    , public IOleControlImpl<CWebViewFolderContents>
                    , public IOleObjectImpl<CWebViewFolderContents>
                    , public IViewObjectExImpl<CWebViewFolderContents>
                    , public IOleInPlaceActiveObjectImpl<CWebViewFolderContents>
                    , public IDataObjectImpl<CWebViewFolderContents>
                    , public IObjectSafetyImpl<CWebViewFolderContents, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
                    , public IConnectionPointContainer
                    , public IOleInPlaceObject
                    , public IInternetSecurityMgrSite
                    , public IServiceProvider
{
public:
    CWebViewFolderContents();
    ~CWebViewFolderContents();

    DECLARE_POLY_AGGREGATABLE(CWebViewFolderContents);
    DECLARE_NO_REGISTRY();
    DECLARE_WND_CLASS(SZ_ATL_SHEMBEDDING_WNDCLASS)

BEGIN_COM_MAP(CWebViewFolderContents)
    // ATL Uses these in IUnknown::QueryInterface()
    COM_INTERFACE_ENTRY_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY_IID(IID_IOleWindow, IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IShellFolderViewDual)
    COM_INTERFACE_ENTRY(IShellFolderViewDual2)
    COM_INTERFACE_ENTRY(IServiceProvider)
    COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IInternetSecurityMgrSite)
END_COM_MAP()

 
// Declare the default message map
BEGIN_MSG_MAP(CWebViewFolderContents)
    MESSAGE_HANDLER(WM_SIZE, _OnSizeMessage) 
    MESSAGE_HANDLER(WM_NOTIFY, _OnMessageForwarder) 
    MESSAGE_HANDLER(WM_CONTEXTMENU, _OnMessageForwarder)
    MESSAGE_HANDLER(WM_SETCURSOR, _OnMessageForwarder)
    MESSAGE_HANDLER(WM_ERASEBKGND, _OnEraseBkgndMessage)
END_MSG_MAP()


    // IDispatch
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);

    // IProvideClassInfo
    STDMETHODIMP GetClassInfo(ITypeInfo** pptinfo);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    // IInternetSecurityMgrSite
    // STDMETHODIMP GetWindow(HWND * lphwnd);              // Also in IOleWindow
    STDMETHODIMP EnableModeless(BOOL fEnable) { return IOleInPlaceActiveObjectImpl<CWebViewFolderContents>::EnableModeless(fEnable); };     // Also in IOleInPlaceActiveObject

    // IShellFolderViewDual2
    STDMETHODIMP get_Application(IDispatch **ppid);
    STDMETHODIMP get_Parent(IDispatch **ppid);
    STDMETHODIMP get_Folder(Folder **ppid);
    STDMETHODIMP SelectedItems(FolderItems **ppid);
    STDMETHODIMP get_FocusedItem(FolderItem **ppid);
    STDMETHODIMP SelectItem(VARIANT *pvfi, int dwFlags);
    STDMETHODIMP PopupItemMenu(FolderItem * pfi, VARIANT vx, VARIANT vy, BSTR * pbs);
    STDMETHODIMP get_Script(IDispatch **ppid);
    STDMETHODIMP get_ViewOptions(long *plSetting);
    STDMETHODIMP get_CurrentViewMode(UINT *pViewMode);
    STDMETHODIMP put_CurrentViewMode(UINT ViewMode);
    STDMETHODIMP SelectItemRelative(int iRelative);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND * lphwnd) { return IOleInPlaceActiveObjectImpl<CWebViewFolderContents>::GetWindow(lphwnd); };
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return IOleInPlaceActiveObjectImpl<CWebViewFolderContents>::ContextSensitiveHelp(fEnterMode); };

    // IOleObject
    STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite)
    {
        if (pClientSite == NULL)
        {
            // Unadvise
            if (m_spClientSite)
            {
                AtlUnadvise(m_spClientSite, IID_IDispatch, _dwHtmlWindowAdviseCookie);
                _dwHtmlWindowAdviseCookie = 0;
            }
        }

        // Call the default impl first
        HRESULT hr = IOleObjectImpl<CWebViewFolderContents>::SetClientSite(pClientSite);

        if (m_spClientSite && SUCCEEDED(hr))
        {
            CComPtr<IOleContainer> spContainer;
            if (m_spClientSite->GetContainer(&spContainer) == S_OK)
            {
                CComPtr<IHTMLDocument2> spDocument2;
                if (spContainer->QueryInterface(&spDocument2) == S_OK)
                {
                    CComPtr<IHTMLWindow2>   spHTMLWindow2;
                    if (spDocument2->get_parentWindow(&spHTMLWindow2) == S_OK)
                    {
                        // Now we AtlAdvise
                        CComPtr<IUnknown> spUnk;
                        ControlQueryInterface(IID_PPV_ARG(IUnknown, &spUnk));
                        AtlAdvise(spHTMLWindow2, spUnk, IID_IDispatch, &_dwHtmlWindowAdviseCookie);
                    }
                }
            }
        }
        return hr;
    }

    // IOleInPlaceObject
    STDMETHODIMP InPlaceDeactivate(void);
    STDMETHODIMP UIDeactivate(void) { return IOleInPlaceObject_UIDeactivate(); };
    STDMETHODIMP SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect);
    STDMETHODIMP ReactivateAndUndo(void)  { return E_NOTIMPL; };

    // IOleInPlaceActiveObject
    // our frame was activated, better do the activation thing.
    STDMETHODIMP OnFrameWindowActivate(BOOL fActivate)
    {
        if (_hwndLV && fActivate)
            ::SetFocus(_hwndLV);
        return S_OK;
    };
    STDMETHODIMP TranslateAccelerator(LPMSG pMsg);

    // IConnectionPointContainer
    STDMETHODIMP EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP FindConnectionPoint(REFIID riid, IConnectionPoint **ppCP);

    // Over ride ATL functions.
    LRESULT _OnMessageForwarder(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT _OnEraseBkgndMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT _OnSizeMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent);
    HRESULT DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND hwndParent);
    STDMETHODIMP Close(DWORD dwSaveOption);

protected:
    // Helper functions;
    HRESULT _SetupAutomationForwarders(void);
    HRESULT _ReleaseAutomationForwarders(void);
    HRESULT _OnInPlaceActivate(void);
    void _ReleaseWindow(void);
    void _ShowWindowLV(HWND hwndLV);
    void _UnadviseAll();

    class CConnectionPointForwarder : public IConnectionPoint
    {
        // IUnknown methods
        STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IConnectionPoint methods
        STDMETHODIMP GetConnectionInterface(IID * pIID);
        STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer ** ppCPC);
        STDMETHODIMP Advise(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
        STDMETHODIMP Unadvise(DWORD dwCookie);
        STDMETHODIMP EnumConnections(LPENUMCONNECTIONS * ppEnum) { return _pcpAuto->EnumConnections(ppEnum); }

        IConnectionPoint *  _pcpAuto;
        HDSA                _dsaCookies;
        IUnknown*           _punkParent;
        friend class CWebViewFolderContents;
    };
    friend class CConnectionPointForwarder;
    CConnectionPointForwarder m_cpEvents;

    IDefViewFrame3*     _pdvf3;   // defview
    BOOL                _fClientEdge;
    BOOL                _fTabRecieved;
    BOOL                _fCalledOnSizeForThisSize;
    HWND                _hwndLV;
    HWND                _hwndLVParent;

    ITypeInfo *         _pClassTypeInfo; // ITypeInfo of class

    DWORD               _dwHtmlWindowAdviseCookie;

    // stuff added to delegate all of our work up to DefViews automation
    IShellFolderViewDual2 *_pdispAuto;
};


LCID g_lcidLocaleUnicpp = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);


CWebViewFolderContents::CWebViewFolderContents()
{
    DllAddRef();

    // This allocator should have zero inited the memory, so assert the member variables are empty.
    ASSERT(!_pdvf3);
    ASSERT(!_hwndLV);
    ASSERT(!_hwndLVParent);
    ASSERT(!_fClientEdge);
    ASSERT(!_fTabRecieved);
    ASSERT(!_pClassTypeInfo);
    ASSERT(!m_cpEvents._dsaCookies);
    ASSERT(!_fCalledOnSizeForThisSize);
    
    m_bWindowOnly = TRUE;
    m_bEnabled = TRUE;
    m_bResizeNatural = TRUE;
    m_cpEvents._punkParent = SAFECAST(this, IViewObjectEx *);
    GetWndClassInfo().m_wc.style &= ~(CS_HREDRAW|CS_VREDRAW);
}

CWebViewFolderContents::~CWebViewFolderContents()
{
    _UnadviseAll();
    ASSERT(NULL == _pdvf3);
    ASSERT(NULL == _hwndLV);

    if (_pClassTypeInfo)
        _pClassTypeInfo->Release();

    ATOMICRELEASE(_pdvf3);
    _ReleaseAutomationForwarders();

    DllRelease();
}


// ATL maintainence functions
LRESULT CWebViewFolderContents::_OnMessageForwarder(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (_hwndLVParent)
    {
        bHandled = TRUE;
        HWND hwnd = NULL;

        // Forward these messages directly to DefView (don't let MSHTML eat them)
        return ::SendMessage(_hwndLVParent, uMsg, wParam, lParam);
    }
    else
        return 0;
}


LRESULT CWebViewFolderContents::_OnEraseBkgndMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    // This function will just tell the default handler not to do anything and we
    // will handle it.

    // This is done in the case of WM_ERASEBKGND to...
    // Avoid flicker by not erasing the background. This OC doesn't care
    // about design-time issues - just usage on a Web View page.
    bHandled = TRUE;
    return 1;
}


LRESULT CWebViewFolderContents::_OnSizeMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    // Now resize the DefView ListView window because ATL isn't very reliable at it.
    if (_hwndLV)
    {
        // During re-parenting of _hwndLV by Trident, the size of the OC is not known to Trident.
        // So, initially we get this message with 1 and 1 for the width and height, from it.
        // And once Trident knows it's correct dimensions, we again get this message with the proper dim.
        // We get a performance gain by not passing the first no-sense 1 x 1 dimension to _hwndLV.
        //
        if (m_rcPos.right - m_rcPos.left != 1 || m_rcPos.bottom - m_rcPos.top != 1)
        {
            ::SetWindowPos(_hwndLV, 0, 0, 0, m_rcPos.right - m_rcPos.left, m_rcPos.bottom - m_rcPos.top, SWP_NOZORDER);
        }
    }

    bHandled = FALSE;
    return 0;
}


HRESULT CWebViewFolderContents::DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent)
{
    HRESULT hr = IOleObjectImpl<CWebViewFolderContents>::DoVerbUIActivate(prcPosRect, hwndParent);

    if (SUCCEEDED(hr))
    {
        hr = _OnInPlaceActivate();
    }

    if (_hwndLV)
    {
        ::SetFocus(_hwndLV);
    }
    return hr;
}


// move from de-active to in-place-active
HRESULT CWebViewFolderContents::_OnInPlaceActivate(void)
{
    HRESULT hr = S_OK;

    if (_pdvf3 == NULL)
    {
        hr = IUnknown_QueryService(m_spClientSite, SID_DefView, IID_PPV_ARG(IDefViewFrame3, &_pdvf3));
        if (EVAL(SUCCEEDED(hr)))
        {
            HWND hwnd;
            hr = _pdvf3->GetWindowLV(&hwnd);
            if (SUCCEEDED(hr))
            {
                _ShowWindowLV(hwnd); // we got it -- show the listview
            }
        }
    }
    return hr;
}

HRESULT CWebViewFolderContents::DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND hwndParent)
{
    HRESULT hr = IOleObjectImpl<CWebViewFolderContents>::DoVerbInPlaceActivate(prcPosRect, hwndParent);
    if (EVAL(SUCCEEDED(hr)))
    {
        hr = _OnInPlaceActivate();
    }
    return hr;
}

HRESULT CWebViewFolderContents::InPlaceDeactivate(void)
{
    _ReleaseWindow();
    ATOMICRELEASE(_pdvf3);

    return IOleInPlaceObject_InPlaceDeactivate();
}

HRESULT CWebViewFolderContents::SetObjectRects(LPCRECT prcPosRect, LPCRECT prcClipRect)
{

//  WARNING: Do NOT move the EqualRect() comparison to after the
//  IOleInPlaceObject_SetObjectRects declaration. The EqualRect()
//  will always return an equal result then.

    bool    bPositionRectDifferent = (EqualRect(&m_rcPos, prcPosRect) == 0);
    HRESULT hr = IOleInPlaceObject_SetObjectRects(prcPosRect, prcClipRect);

//  99/02/23 #294278 vtan: Trident did not call this routine when
//  marquee selecting but it now does. The jumpy scrolling now
//  manifests. Check that posRect has not changed before making
//  any scroll position adjustments.

    if (_hwndLV && _pdvf3 && (!_fCalledOnSizeForThisSize || bPositionRectDifferent))
    {
        _pdvf3->OnResizeListView();
        _fCalledOnSizeForThisSize = TRUE;
    }

    return hr;
}

// IOleInPlaceActiveObject
HRESULT CWebViewFolderContents::TranslateAccelerator(MSG *pMsg)
{
    HRESULT hr = S_OK;
    if (!_fTabRecieved)
    {
        hr = IOleInPlaceActiveObjectImpl<CWebViewFolderContents>::TranslateAccelerator(pMsg);

        // If we did not handle this and if it is a tab (and we are not getting it in a cycle), forward it to trident, if present.
        if (hr != S_OK && pMsg && (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6) && m_spClientSite)
        {
            IOleControlSite* pocs;
            if (SUCCEEDED(m_spClientSite->QueryInterface(IID_PPV_ARG(IOleControlSite, &pocs))))
            {
                DWORD grfModifiers = 0;
                if (GetKeyState(VK_SHIFT) & 0x8000)
                {
                    grfModifiers |= 0x1;    //KEYMOD_SHIFT
                }
                if (GetKeyState(VK_CONTROL) & 0x8000)
                {
                    grfModifiers |= 0x2;    //KEYMOD_CONTROL;
                }
                if (GetKeyState(VK_MENU) & 0x8000)
                {
                    grfModifiers |= 0x4;    //KEYMOD_ALT;
                }
                _fTabRecieved = TRUE;
                hr = pocs->TranslateAccelerator(pMsg, grfModifiers);
                _fTabRecieved = FALSE;
                pocs->Release();
            }
        }
    }
    return hr;
}

// IProvideClassInfo
HRESULT CWebViewFolderContents::GetClassInfo(ITypeInfo ** ppTI)
{
    if (!_pClassTypeInfo) 
        GetTypeInfoFromLibId(LANGIDFROMLCID(g_lcidLocaleUnicpp), LIBID_Shell32, 1, 0,
            CLSID_WebViewFolderContents, &_pClassTypeInfo);

    if (EVAL(_pClassTypeInfo))
    {
        _pClassTypeInfo->AddRef();
        *ppTI = _pClassTypeInfo;
        return S_OK;
    }

    *ppTI = NULL;
    return E_FAIL;
}

HRESULT CWebViewFolderContents::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo)
{
    HRESULT hr = S_OK;

    *ppITypeInfo = NULL;

    if (0 != itinfo)
        return TYPE_E_ELEMENTNOTFOUND;

    //Load a type lib if we don't have the information already.
    if (NULL == *ppITypeInfo)
    {
        ITypeInfo * pITIDisp;

        hr = GetTypeInfoFromLibId(lcid, LIBID_Shell32, 1, 0,
            IID_IShellFolderViewDual2, &pITIDisp);

        if (SUCCEEDED(hr))
        {
            HREFTYPE hrefType;

            // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
            // returns the ITypeInfo of the IDispatch-part only. We need to
            // find the ITypeInfo for the dual interface-part.
            //
            HRESULT hrT = pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType);
            if (SUCCEEDED(hrT))
                hrT = pITIDisp->GetRefTypeInfo(hrefType, ppITypeInfo);

            ASSERT(SUCCEEDED(hrT));
            pITIDisp->Release();
        }
    }

    return hr;
}

HRESULT CWebViewFolderContents::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
    UINT cNames, LCID lcid, DISPID* rgdispid)
{
    ITypeInfo* pInfo;
    HRESULT hr = GetTypeInfo(0, lcid, &pInfo);

    if (pInfo != NULL)
    {
        hr = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
        pInfo->Release();
    }

    TraceMsg(TF_DEFVIEW, "CWebViewFolderContents::GetIDsOfNames(DISPID=%ls, lcid=%d, cNames=%d) returned hr=%#08lx", *rgszNames, lcid, cNames, hr);
    return hr;
}

HRESULT CWebViewFolderContents::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    HRESULT hr = E_FAIL;
    DISPPARAMS dispparams = {0};

    if (!pdispparams)
        pdispparams = &dispparams;  // otherwise OLE Fails when passed NULL.

    if (dispidMember == DISPID_WINDOWOBJECT)
    {
        IDispatch * pdisp;
        if (SUCCEEDED(get_Script(&pdisp)))
        {
            hr = pdisp->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
            pdisp->Release();
            return hr;
        }
        else
            return DISP_E_MEMBERNOTFOUND;
    }

    // Make sure we are connected up to defviews automation.
    hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);

    return hr;
}

#define DW_MISC_STATUS (OLEMISC_SETCLIENTSITEFIRST | OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT)

HRESULT CWebViewFolderContents::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    *pdwStatus = DW_MISC_STATUS;
    return S_OK;
}
 
void CWebViewFolderContents::_ShowWindowLV(HWND hwndLV)
{
    if (!hwndLV)
        return;
    _hwndLV = hwndLV;
    _hwndLVParent = ::GetParent(_hwndLV);

    SHSetParentHwnd(_hwndLV, m_hWnd);

    LONG lExStyle = ::GetWindowLong(_hwndLV, GWL_EXSTYLE);
    _fClientEdge = lExStyle & WS_EX_CLIENTEDGE ? TRUE : FALSE;

    UINT uFlags = SWP_NOZORDER;
    if (_fClientEdge)
    {
        lExStyle &= ~WS_EX_CLIENTEDGE;
        ::SetWindowLong(_hwndLV, GWL_EXSTYLE, lExStyle);
        uFlags |= SWP_FRAMECHANGED;
    }

    ::SetWindowPos(_hwndLV, 0, 0, 0, m_rcPos.right - m_rcPos.left
                    , m_rcPos.bottom - m_rcPos.top, uFlags);

    _pdvf3->ShowHideListView();
}

void CWebViewFolderContents::_ReleaseWindow()
{
    if (_hwndLV)
    {
        UINT uFlags = SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE;
        if (_fClientEdge)
        {
            SetWindowBits(_hwndLV, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
            uFlags |= SWP_FRAMECHANGED;
        }

        SHSetParentHwnd(_hwndLV, _hwndLVParent);
        ::SetWindowPos(_hwndLV, HWND_BOTTOM, 0, 0, 0, 0, uFlags);
        _pdvf3->ReleaseWindowLV();
        _hwndLV = NULL;
    }
}


// IConnectionPointContainer
HRESULT CWebViewFolderContents::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = CreateInstance_IEnumConnectionPoints(ppEnum, 1, SAFECAST(&m_cpEvents, IConnectionPoint*));

    return hr;
}

HRESULT CWebViewFolderContents::FindConnectionPoint(REFIID iid, IConnectionPoint **ppCP)
{
    *ppCP = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
    {
        if (IsEqualIID(iid, DIID_DShellFolderViewEvents) || IsEqualIID(iid, IID_IDispatch))
        {
            *ppCP = SAFECAST(&m_cpEvents, IConnectionPoint*);
            (*ppCP)->AddRef();
            hr = S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}

// IConnectionPoint
//
// Our IConnectionPoint is really implemented by defview's CFolder's connection point.
// We just need to keep a count of outstanding references so we can force Unadvise
// calls during "implicit unadvise during shutdown" cases like Trident.
// (Is this really the spec?  It doesn't sound very robust...)
//
HRESULT CWebViewFolderContents::CConnectionPointForwarder::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CConnectionPointForwarder, IConnectionPoint),                  // IID_IConnectionPoint
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CWebViewFolderContents::CConnectionPointForwarder::AddRef(void)
{
    return _punkParent->AddRef();
}
STDMETHODIMP_(ULONG) CWebViewFolderContents::CConnectionPointForwarder::Release(void)
{
    return _punkParent->Release();
}
        
HRESULT CWebViewFolderContents::CConnectionPointForwarder::GetConnectionInterface(IID * pIID)
{
    HRESULT hr = _pcpAuto->GetConnectionInterface(pIID);
    if (SUCCEEDED(hr))
    {
        ASSERT(IsEqualIID(*pIID, DIID_DShellFolderViewEvents));
    }
    return hr;
}

HRESULT CWebViewFolderContents::CConnectionPointForwarder::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    return _punkParent->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, ppCPC));
}

HRESULT CWebViewFolderContents::CConnectionPointForwarder::Advise(IUnknown * pUnkSink, DWORD * pdwCookie)
{
    if (!_dsaCookies)
    {
        _dsaCookies = DSA_Create(sizeof(*pdwCookie), 4);
        if (!_dsaCookies)
        {
            *pdwCookie = 0;
            return E_OUTOFMEMORY;
        }
    }

    HRESULT hr = _pcpAuto->Advise(pUnkSink, pdwCookie);

    if (SUCCEEDED(hr))
    {
        if (-1 == DSA_AppendItem(_dsaCookies, pdwCookie))
        {
            _pcpAuto->Unadvise(*pdwCookie);
            *pdwCookie = 0;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CWebViewFolderContents::CConnectionPointForwarder::Unadvise(DWORD dwCookie)
{
    if (_dsaCookies)
    {
        int i = 0;
        DWORD dw;
        while (DSA_GetItem(_dsaCookies, i++, &dw))
        {
            if (dw == dwCookie)
            {
                DSA_DeleteItem(_dsaCookies, --i);
                return _pcpAuto->Unadvise(dwCookie);
            }
        }
    }

    return E_FAIL;
}

void CWebViewFolderContents::_UnadviseAll()
{
    if (m_cpEvents._dsaCookies)
    {
        if (m_cpEvents._pcpAuto)
        {
            DWORD dw;
            for (int i = 0; DSA_GetItem(m_cpEvents._dsaCookies, i, &dw); i++)
            {
                m_cpEvents._pcpAuto->Unadvise(dw);
            }
        }
        DSA_Destroy(m_cpEvents._dsaCookies);
        m_cpEvents._dsaCookies = NULL;
    }
}

HRESULT CWebViewFolderContents::Close(DWORD dwSaveOption)
{
    _UnadviseAll();
    HRESULT hr = IOleObjectImpl<CWebViewFolderContents>::Close(dwSaveOption);
    _ReleaseAutomationForwarders();
    return hr;
}

HRESULT CWebViewFolderContents::_SetupAutomationForwarders(void)
{
    HRESULT hr = S_OK;
    if (!m_cpEvents._pcpAuto)
    {
        IShellView *psv;
        hr = IUnknown_QueryService(m_spClientSite, SID_DefView, IID_PPV_ARG(IShellView, &psv));
        if (SUCCEEDED(hr))
        {
            IDispatch *pdisp;
            hr = psv->GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IDispatch, &pdisp));
            if (SUCCEEDED(hr))
            {
                hr = pdisp->QueryInterface(IID_PPV_ARG(IShellFolderViewDual2, &_pdispAuto));
                if (SUCCEEDED(hr))
                {
                    if (SUCCEEDED(MakeSafeForScripting((IUnknown**)&_pdispAuto)))
                    {
                        IUnknown_SetSite(_pdispAuto, m_spClientSite);

                        // Need to get the right interfaces
                        IConnectionPointContainer* pcpcAuto;
                        hr = _pdispAuto->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pcpcAuto));
                        if (SUCCEEDED(hr))
                        {
                            hr = pcpcAuto->FindConnectionPoint(IID_IDispatch, &m_cpEvents._pcpAuto);
                            pcpcAuto->Release();
                        }

                        if (FAILED(hr))
                        {
                            IUnknown_SetSite(_pdispAuto, NULL);
                            ATOMICRELEASE(_pdispAuto);
                        }
                    }
                }
                pdisp->Release();
            }
            psv->Release();
        }
    }
    return hr;
}

HRESULT CWebViewFolderContents::_ReleaseAutomationForwarders(void)
{
    ATOMICRELEASE(m_cpEvents._pcpAuto);
    IUnknown_SetSite(_pdispAuto, NULL);
    ATOMICRELEASE(_pdispAuto);
    return S_OK;
}

// IShellFolderViewDual2

// We will let the folder object get created and have it maintain that we only have one
// application object (with the site) set properly...

HRESULT CWebViewFolderContents::get_Application(IDispatch **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_Application(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::get_Parent(IDispatch **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_Parent(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::get_Folder(Folder **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_Folder(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::SelectedItems(FolderItems **ppid)
{
    // We need to talk to the actual window under us
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->SelectedItems(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::get_FocusedItem(FolderItem **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_FocusedItem(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::SelectItem(VARIANT *pvfi, int dwFlags)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->SelectItem(pvfi, dwFlags);
    return hr;
}

HRESULT CWebViewFolderContents::PopupItemMenu(FolderItem *pfi, VARIANT vx, VARIANT vy, BSTR * pbs)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->PopupItemMenu(pfi, vx, vy, pbs);
    return hr;
}

HRESULT CWebViewFolderContents::get_Script(IDispatch **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_Script(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::get_ViewOptions(long *plSetting)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_ViewOptions(plSetting);
    return hr;
}


HRESULT CWebViewFolderContents::get_CurrentViewMode(UINT *pViewMode)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_CurrentViewMode(pViewMode);
    return hr;
}

HRESULT CWebViewFolderContents::put_CurrentViewMode(UINT ViewMode)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->put_CurrentViewMode(ViewMode);
    return hr;
}

HRESULT CWebViewFolderContents::SelectItemRelative(int iRelative)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->SelectItemRelative(iRelative);
    return hr;
}

HRESULT CWebViewFolderContents::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    return IUnknown_QueryService(m_spClientSite, SID_DefView, riid, ppv);
}


STDAPI CWebViewFolderContents_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    return CComCreator< CComPolyObject< CWebViewFolderContents > >::CreateInstance((void *) punkOuter, riid, ppvOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\dsubscri.cpp ===
#include "stdafx.h"
#pragma hdrstop

// This function checks if a given URL already has a subscription.
// Returns TRUE: if it aleady has a subscription 
//         FALSE: Otherwise.
//
BOOL CheckForExistingSubscription(LPCTSTR lpcszURL)
{
    HRESULT hr;
    ISubscriptionMgr *psm;
    BOOL    fRet = FALSE;  //Assume failure.

    //Create the subscription Manager.
    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionMgr,
                          (void**)&psm);

    if (SUCCEEDED(hr))
    {
        BSTR bstrURL = SysAllocStringT(lpcszURL);
        if (bstrURL)
        {
            psm->IsSubscribed(bstrURL, &fRet);
            SysFreeString(bstrURL);
        }

        psm->Release();
    }

    return(fRet);
}

BOOL DeleteFromSubscriptionList(LPCTSTR pszURL)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    ISubscriptionMgr *psm;

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionMgr,
                          (void**)&psm);

    if (SUCCEEDED(hr))
    {
        BSTR bstrURL = SysAllocStringT(pszURL);     // Call TSTR version
        if (bstrURL)
        {
            //  Looks like all code paths going through this has already
            //  put up some UI.
            if (SUCCEEDED(psm->DeleteSubscription(bstrURL, NULL)))
            {
                fRet = TRUE;
            }

            SysFreeString(bstrURL);
        }

        psm->Release();
    }

    return(fRet);
}

BOOL UpdateSubscription(LPCTSTR pszURL)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    ISubscriptionMgr *psm;

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionMgr,
                          (void**)&psm);

    if (SUCCEEDED(hr))
    {
        BSTR bstrURL = SysAllocStringT(pszURL);     // Call TSTR version
        if (bstrURL)
        {
            if (SUCCEEDED(psm->UpdateSubscription(bstrURL)))
            {
                fRet = TRUE;
            }

            SysFreeString(bstrURL);
        }

        psm->Release();
    }

    return(fRet);
}

//
//
// This function enumerates the URLs of all the desktop components and then
// calls webcheck to see if they are subcribed to and if so asks webcheck to
// deliver those subscriptions right now.
//
//

BOOL UpdateAllDesktopSubscriptions(IADesktopP2 *padp2)
{
    IActiveDesktop  *pActiveDesktop;
    ISubscriptionMgr *psm;
    int     iCount; //Count of components.
    HRESULT     hres;
    BOOL        fRet = TRUE;  //Assume success!

    if(padp2 == NULL) //Are we provided a pointer already?
    {
        if(FAILED(hres = CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&pActiveDesktop, IID_IActiveDesktop)))
        {
            TraceMsg(TF_WARNING, "Could not instantiate CActiveDesktop COM object");
            return FALSE;
        }
    }
    else
    {
        if(FAILED(hres = (padp2->QueryInterface(IID_PPV_ARG(IActiveDesktop, &pActiveDesktop)))))
        {
            TraceMsg(TF_WARNING, "Could not get IActiveDesktop * from IADesktopP2 *");
            return FALSE;
        }
    }

    pActiveDesktop->GetDesktopItemCount(&iCount, 0);

    if(iCount <= 0)
    {
        TraceMsg(DM_TRACE, "No desktop components to update!");
        return TRUE; //No components to enumerate!
    }

    //Create the subscription Manager.
    hres = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_ISubscriptionMgr,
                            (void**)&psm);

    if(SUCCEEDED(hres))
    {
        int iIndex;
        BSTR bstrURL;

        //Enumerate the desktop components one by one.
        for(iIndex = 0; iIndex < iCount; iIndex++)
        {
            COMPONENT   Comp;   //We are using the public structure here.

            Comp.dwSize = sizeof(COMPONENT);
            if(SUCCEEDED(pActiveDesktop->GetDesktopItem(iIndex, &Comp, 0)) && 
                        Comp.fChecked)  //Is this component enabled?
            {
                BOOL    fSubscribed;

                fSubscribed = FALSE;  //Assume that it is NOT subscribed!

                bstrURL = SysAllocString(Comp.wszSubscribedURL);
                if(!bstrURL)
                {
                    fRet = FALSE;
                    break;  //Out of memory!
                }

                psm->IsSubscribed(bstrURL, &fSubscribed);

                if(fSubscribed)
                    psm->UpdateSubscription(bstrURL);

                SysFreeString(bstrURL);
            }
            else
                TraceMsg(TF_WARNING, "Component# %d either failed or not enabled!", iIndex);
        }
        psm->Release();
    }
    else
    {
        TraceMsg(TF_WARNING, "Could not create CLSID_SubscriptionMgr");
    }
        
    pActiveDesktop->Release();

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\dutil.cpp ===
#include "stdafx.h"
#include "icwcfg.h"
#pragma hdrstop

EXTERN_C const TCHAR c_szPatterns[] = TEXT("patterns");
EXTERN_C const TCHAR c_szBackgroundPreview2[] = TEXT("BackgroundPreview2");
EXTERN_C const TCHAR c_szComponentPreview[] = TEXT("ComponentPreview");
EXTERN_C const TCHAR c_szRegDeskHtmlProp[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\Display\\shellex\\PropertySheetHandlers\\DeskHtmlExt");
EXTERN_C const TCHAR c_szWallPaperDir[] = TEXT("WallPaperDir");

//  98/10/01 vtan: Added local function prototypes.

//  Some of these functions are commented out. The linker may not be smart
//  enough to strip the dead code so this is done manually. These prototypes
//  will allow the code to compile but it won't link. If you get linker
//  errors, uncomment the desired function and recompile. It should then link.

//  Point arithmetic

void    SetPt (POINT& pt, LONG x, LONG y);
void    OffsetPt (POINT& pt, LONG dh, LONG dv);

//  Virtual screen calculation

BOOL    CALLBACK    GDIToTridentEnumProc (HMONITOR hMonitor, HDC hDC, RECT* rcMonitor, LPARAM lpUserData);
void    CalculateVirtualScreen (RECT& rcVirtualScreen);

//  GDI point to Trident point co-ordinate mapping

void    GDIToTrident (int& leftCoordinate, int& topCoordinate);
void    GDIToTrident (POINT& pt);
void    GDIToTrident (RECT& r);
void    GDIToTrident (HRGN hRgn);
void    TridentToGDI (int& leftCoordinate, int& topCoordinate);
void    TridentToGDI (POINT& pt);
void    TridentToGDI (RECT& r);
void    TridentToGDI (HRGN hRgn);

//  Component position validation

BOOL    CALLBACK    ValidateComponentPositionEnumProc (HMONITOR hMonitor, HDC hdcMonitor, RECT* r, LPARAM lParam);

void    GetNextComponentPosition (COMPPOS *pcp)

{
    int     iScreenWidth, iScreenHeight, iBorderSize;
    DWORD   dwComponentPosition, dwComponentLayer, dwRegDataScratch;
    HKEY    hKey;
    RECT    rcScreen;
    TCHAR   lpszDeskcomp[MAX_PATH];

    TBOOL(SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, false));

    // 99/04/13 vtan: A result of zero-width or zero-height occurred on a machine.
    // Make a defensive stand against this and assert that this happened but also
    // handle this cause so that division by zero doesn't happen.

    iScreenWidth = rcScreen.right - rcScreen.left;
    iScreenHeight = rcScreen.bottom - rcScreen.top;
    iBorderSize = GetSystemMetrics(SM_CYSMCAPTION);

    ASSERT(iScreenWidth > 0);       // get vtan
    ASSERT(iScreenHeight > 0);      // if any of
    ASSERT(iBorderSize > 0);        // these occur

    if ((iScreenWidth <= 0) || (iScreenHeight <= 0) || (iBorderSize <= 0))
    {
        pcp->iLeft = pcp->iTop = 0;
        pcp->dwWidth = MYCURHOME_WIDTH;
        pcp->dwHeight = MYCURHOME_HEIGHT;
    }
    else
    {

        // Get the number of components positioned. If no such registry key exists
        // or an error occurs then use 0.

        GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_GENERAL, NULL);
        dwComponentPosition = 0;
        if (RegCreateKeyEx(HKEY_CURRENT_USER, lpszDeskcomp, 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &hKey, &dwRegDataScratch) == ERROR_SUCCESS)
        {
            DWORD   regDataSize;

            regDataSize = sizeof(dwComponentPosition);
            TW32(SHQueryValueEx(hKey, REG_VAL_GENERAL_CCOMPPOS, NULL, &dwRegDataScratch, &dwComponentPosition, &regDataSize));
            TW32(RegCloseKey(hKey));
        }

        // Compute the layer we live on (see below).

        dwComponentLayer = dwComponentPosition / (COMPONENT_PER_ROW * COMPONENT_PER_COL);
        if (((dwComponentLayer * iBorderSize) > (DWORD)(iScreenWidth / (COMPONENT_PER_ROW + 1))) ||
            ((dwComponentLayer * iBorderSize) > (DWORD)(iScreenHeight / (COMPONENT_PER_COL + 1))))
        {
            int     iLayerModulo;

            // 99/04/29 vtan: It's possible for SystemParametersInfo(SPI_GETWORKAREA) to
            // return a work area that's small horizontally. Here's a repro scenario for
            // that.

            // 1. Set screen resolution 1280 x 1024.
            // 2. Move the taskbar to the left of the screen.
            // 3. Grow the taskbar to the right until the center of the screen.
            // 4. Open display control panel.
            // 5. Go to "Settings" tab.
            // 6. Change monitor resolution to 640x480.
            // 7. Click either "OK" or "Apply".
            // 8. BOOM - divide zero.

            iLayerModulo = (iScreenWidth / (COMPONENT_PER_ROW + 1) / iBorderSize);
            if (iLayerModulo != 0)
                dwComponentLayer %= iLayerModulo;
        }

        // Compute the position.  Assuming 3 components per row,
        // and 2 per column, we position components thusly:
        //
        //       +-------+
        //       |x 4 2 0|
        //       |x 5 3 1| <-- screen, divided into 4x3 block coordinates
        //       |x x x x|
        //       +-------+
        //
        // The 6th component sits in a new layer, offset down
        // and to the left of component 0 by the amount iBorder.
        //
        // The first calculation for iLeft and iTop determines the
        // block coordinate value (for instance, component 0 would
        // be at block coordinate value [3,0] and component 1 at [3,1]).
        //
        // The second calculation turns the block coordinate into
        // a screen coordinate.
        //
        // The third calculation adjusts for the border (always down and
        // to the right) and the layers (always down and to the left).

        pcp->iLeft = COMPONENT_PER_ROW - ((dwComponentPosition / COMPONENT_PER_COL) % COMPONENT_PER_ROW); // 3 3 2 2 1 1 3 3 2 2 1 1 ...
        pcp->iLeft *= (iScreenWidth / (COMPONENT_PER_ROW + 1));
        pcp->iLeft += iBorderSize - (dwComponentLayer * iBorderSize);

        pcp->iTop = dwComponentPosition % COMPONENT_PER_COL;  // 0 1 0 1 0 1 ...
        pcp->iTop *= (iScreenHeight / (COMPONENT_PER_COL + 1));
        pcp->iTop += iBorderSize + (dwComponentLayer * iBorderSize);
        pcp->iTop += GET_CYCAPTION;          //vtan: Added this to allow for the title area of the component window

        pcp->dwWidth = (iScreenWidth / (COMPONENT_PER_ROW + 1)) - 2 * iBorderSize;
        pcp->dwHeight = (iScreenHeight / (COMPONENT_PER_COL + 1)) - 2 * iBorderSize;
    }

    if (IS_BIDI_LOCALIZED_SYSTEM())
    {
       pcp->iLeft = iScreenWidth - (pcp->iLeft + pcp->dwWidth);
    }
    
}

void    IncrementComponentsPositioned (void)

{
    DWORD   dwRegDataScratch;
    HKEY    hKey;
    TCHAR   lpszDeskcomp[MAX_PATH];

    // Increment the registry count. If no such count exists create it.

    GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_GENERAL, NULL);
    if (RegCreateKeyEx(HKEY_CURRENT_USER, lpszDeskcomp, 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &hKey, &dwRegDataScratch) == ERROR_SUCCESS)
    {
        DWORD   dwComponentPosition, regDataSize;

        regDataSize = sizeof(dwComponentPosition);
        dwComponentPosition = 0;
        TW32(SHQueryValueEx(hKey, REG_VAL_GENERAL_CCOMPPOS, NULL, &dwRegDataScratch, &dwComponentPosition, &regDataSize));
        ++dwComponentPosition;
        TW32(RegSetValueEx(hKey, REG_VAL_GENERAL_CCOMPPOS, 0, REG_DWORD, reinterpret_cast<unsigned char*>(&dwComponentPosition), sizeof(dwComponentPosition)));
        TW32(RegCloseKey(hKey));
    }
}

//  vtan: Point arithmetic functions. Simple. It may be worth
//  converting these to inline C++ functions or macros if they
//  get used a lot.

void    SetPt (POINT& pt, LONG x, LONG y)

{
    pt.x = x;
    pt.y = y;
}

void    OffsetPt (POINT& pt, LONG dh, LONG dv)

{
    pt.x += dh;
    pt.y += dv;
}

BOOL    CALLBACK    GDIToTridentEnumProc (HMONITOR hMonitor, HDC hDC, RECT* rcMonitor, LPARAM lpUserData)

{
    RECT*   prcNew, rcOld;

    prcNew = reinterpret_cast<RECT*>(lpUserData);

    // Documentation for UnionRect does not specify whether the
    // RECT structures passed must be distinct. To be safe they
    // are passed as distinct structures.

    TBOOL(CopyRect(&rcOld, prcNew));
    TBOOL(UnionRect(prcNew, &rcOld, rcMonitor));
    return(TRUE);
}

void    CalculateVirtualScreen (RECT& rcVirtualScreen)

//  vtan: Calculates the virtual screen in GDI co-ordinates for
//  use in converting co-ordinates from trident scheme to GDI
//  scheme.

{
    TBOOL(SetRectEmpty(&rcVirtualScreen));
    TBOOL(EnumDisplayMonitors(NULL, NULL, GDIToTridentEnumProc, reinterpret_cast<LPARAM>(&rcVirtualScreen)));
}

void    GDIToTrident (int& leftCoordinate, int& topCoordinate)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    leftCoordinate -= rcVirtualScreen.left;
    topCoordinate -= rcVirtualScreen.top;
}

/*
void    GDIToTrident (POINT& pt)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    OffsetPt(pt, -rcVirtualScreen.left, -rcVirtualScreen.top);
}
*/

void    GDIToTrident (RECT& rc)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    TBOOL(OffsetRect(&rc, -rcVirtualScreen.left, -rcVirtualScreen.top));
}

void    GDIToTrident (HRGN hRgn)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    TBOOL(OffsetRgn(hRgn, -rcVirtualScreen.left, -rcVirtualScreen.top));
}

/*
void    TridentToGDI (int& leftCoordinate, int& topCoordinate)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    leftCoordinate += rcVirtualScreen.left;
    topCoordinate += rcVirtualScreen.top;
}
*/

/*
void    TridentToGDI (POINT& pt)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    OffsetPt(pt, +rcVirtualScreen.left, +rcVirtualScreen.top);
}
*/

void    TridentToGDI (RECT& rc)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    TBOOL(OffsetRect(&rc, +rcVirtualScreen.left, +rcVirtualScreen.top));
}

/*
void    TridentToGDI (HRGN hRgn)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    (BOOL)OffsetRgn(hRgn, +rcVirtualScreen.left, +rcVirtualScreen.top);
}
*/

//  98/08/14 vtan #196180, #196185: The following code validates
//  a new component's position within the current desktop area. This
//  allows a component to have co-ordinates that seem to be unusual
//  on a single monitor system (such as negative co-ordinates).

class   CRGN
{
    public:
                CRGN (void)                     {   mRgn = CreateRectRgn(0, 0, 0, 0);                               }
                CRGN (const RECT& rc)           {   mRgn = CreateRectRgnIndirect(&rc);                              }
                ~CRGN (void)                    {   TBOOL(DeleteObject(mRgn));                                      }

                operator HRGN (void)    const   {   return(mRgn);                                                   }
        void    SetRegion (const RECT& rc)      {   TBOOL(SetRectRgn(mRgn, rc.left, rc.top, rc.right, rc.bottom));  }
    private:
        HRGN    mRgn;
};

typedef struct
{
    bool    bAllowEntireDesktopRegion;
    int     iMonitorCount;
    CRGN    hRgn;
    int     iWorkAreaCount;
    RECT    *prcWorkAreaRects;
} tDesktopRegion;

void    ListView_GetWorkAreasAsGDI (HWND hWndListView, int iWorkAreaCount, RECT *prcWorkAreas)

{
    int     i;

    ListView_GetWorkAreas(hWndListView, iWorkAreaCount, prcWorkAreas);
    for (i = 0; i < iWorkAreaCount; ++i)
    {
        TridentToGDI(prcWorkAreas[i]);
    }
}

int     CopyMostSuitableListViewWorkAreaRect (const RECT *pcrcMonitor, int iListViewWorkAreaCount, const RECT *pcrcListViewWorkAreaRects, RECT *prcWorkArea)

{
    int         i, iResult;
    const RECT  *pcrcRects;

    // This function given a rectangle for a GDI monitor (typically the monitor's
    // work area) as well as given the desktop's list view work area rectangle
    // array (obtained by ListView_GetWorkArea()) will search the list view
    // work area array to find a match for the GDI monitor and use the list view
    // work area rectangle instead as this has docked toolbar information which
    // GDI does not have access to.

    // This function works on the principle that the list view rectangle is
    // always a complete subset of the GDI monitor rectangle which is true.
    // The list view rectangle may be smaller but it should never be bigger.

    // It's ok to pass a NULL pcrcListViewWorkAreaRects as long as
    // iListViewWorkAreaCount is 0.

    pcrcRects = pcrcListViewWorkAreaRects;
    iResult = -1;
    i = 0;
    while ((iResult == -1) && (i < iListViewWorkAreaCount))
    {
        RECT    rcIntersection;

        (BOOL)IntersectRect(&rcIntersection, pcrcMonitor, pcrcRects);
        if (EqualRect(&rcIntersection, pcrcRects) != 0)
        {
            iResult = i;
        }
        else
        {
            ++pcrcRects;
            ++i;
        }
    }
    if (iResult < 0)
    {
        TraceMsg(TF_WARNING, "CopyMostSuitableListViewWorkAreaRect() unable to find matching list view rectangle for GDI monitor rectangle");
        TBOOL(CopyRect(prcWorkArea, pcrcMonitor));
    }
    else
    {
        TBOOL(CopyRect(prcWorkArea, &pcrcListViewWorkAreaRects[iResult]));
    }
    return(iResult);
}

BOOL    GetMonitorInfoWithCompensation (int iMonitorCount, HMONITOR hMonitor, MONITORINFO *pMonitorInfo)

{
    BOOL    fResult;

    // 99/05/20 #338585 vtan: Transplanted the logic explained in the
    // comment below for #211510 from GetZoomRect to here so that other
    // functions can share the behavior. Remember that this ONLY applies
    // a single monitor system where there is part of the monitor's
    // rectangle excluded by a docked toolbar on the left or top of the
    // monitor. A very specific case.

    // 98/10/30 #211510 vtan: Oops. If the task bar is at the top of the
    // screen and there is only one monitor then the shell returns a work
    // area starting at (0, 0) instead of (0, 28); the same applies when
    // the task bar is at the left of the screen; this does NOT occur in
    // a multiple monitor setting. In the single monitor case GDI returns
    // a work area starting at (0, 28) so this code checks for the case
    // where there is a single monitor and offsets the GDI information to
    // (0, 0) so that it matches the shell work area which is compared
    // against in the while loop.

    fResult = GetMonitorInfo(hMonitor, pMonitorInfo);
    if ((fResult != 0) && (iMonitorCount == 1))
    {
        TBOOL(OffsetRect(&pMonitorInfo->rcWork, -pMonitorInfo->rcWork.left, -pMonitorInfo->rcWork.top));
    }
    return(fResult);
}

//  MonitorCountEnumProc()'s body is located in adjust.cpp

BOOL    CALLBACK    MonitorCountEnumProc (HMONITOR hMonitor, HDC dc, RECT *rc, LPARAM data);

BOOL    CALLBACK    ValidateComponentPositionEnumProc (HMONITOR hMonitor, HDC hdcMonitor, RECT* prc, LPARAM lpUserData)

{
    HRGN            hRgnDesktop;
    HMONITOR        hMonitorTopLeft, hMonitorTopRight;
    POINT           ptAbove;
    RECT            rcMonitor;
    MONITORINFO     monitorInfo;
    tDesktopRegion  *pDesktopRegion;

    pDesktopRegion = reinterpret_cast<tDesktopRegion*>(lpUserData);
    monitorInfo.cbSize = sizeof(monitorInfo);
    if (GetMonitorInfoWithCompensation(pDesktopRegion->iMonitorCount, hMonitor, &monitorInfo) != 0)
    {
        TINT(CopyMostSuitableListViewWorkAreaRect(&monitorInfo.rcWork, pDesktopRegion->iWorkAreaCount, pDesktopRegion->prcWorkAreaRects, &rcMonitor));
    }
    else
    {
        TBOOL(CopyRect(&rcMonitor, prc));
    }

    // If this monitor does not have a monitor above it then
    // make the monitor rectangle one pixel lower from the
    // top.

    CRGN    hRgnMonitor(rcMonitor);

    if (!pDesktopRegion->bAllowEntireDesktopRegion)
    {

        // This bizarre little algorithm calculates the margins of the current
        // monitor that do not have a monitor above them. The rcExclude is the
        // the final rectangle that contains this information and is one pixel
        // high. This calculation is only valid if the entire desktop region
        // has been DISALLOWED (not zooming a component).

        // Note that the algorithm fails if there is a monitor that is above
        // this one but is contained within the confines of it. For example,
        // this monitor is at 1024x768 and the one above is at 640x480 and
        // centered. In this case it should be possible to drop the component
        // on the exact zero pixel point but this case is disallowed due to
        // this fault. No big deal.

        SetPt(ptAbove, rcMonitor.left, rcMonitor.top - 1);
        hMonitorTopLeft = MonitorFromPoint(ptAbove, MONITOR_DEFAULTTONULL);
        SetPt(ptAbove, rcMonitor.right, rcMonitor.top - 1);
        hMonitorTopRight = MonitorFromPoint(ptAbove, MONITOR_DEFAULTTONULL);
        if ((hMonitorTopLeft == NULL) && (hMonitorTopRight == NULL))
        {

            // No monitor above this one

            ++rcMonitor.top;
            hRgnMonitor.SetRegion(rcMonitor);
        }
        else if (hMonitorTopLeft != hMonitorTopRight)
        {
            RECT    rcExclude;

            // Either one or two different monitors above this one
            // == case is the same monitor completely covers this
            // monitor.

            TBOOL(SetRect(&rcExclude, rcMonitor.left, rcMonitor.top, rcMonitor.right, rcMonitor.top + 1));
            if (hMonitorTopLeft != NULL)
            {
                TBOOL(GetMonitorInfoWithCompensation(pDesktopRegion->iMonitorCount, hMonitorTopLeft, &monitorInfo));
                rcExclude.left = monitorInfo.rcWork.right + 1;
            }
            if (hMonitorTopRight != NULL)
            {
                TBOOL(GetMonitorInfoWithCompensation(pDesktopRegion->iMonitorCount, hMonitorTopRight, &monitorInfo));
                rcExclude.right = monitorInfo.rcWork.left;
            }

            CRGN    hRgnExclude(rcExclude);

            TINT(CombineRgn(hRgnMonitor, hRgnMonitor, hRgnExclude, RGN_DIFF));
        }
    }

    hRgnDesktop = pDesktopRegion->hRgn;
    TINT(CombineRgn(hRgnDesktop, hRgnDesktop, hRgnMonitor, RGN_OR));

    return(true);
}

void    ValidateComponentPosition (COMPPOS *pcp, DWORD dwComponentState, int iComponentType, bool *pbChangedPosition, bool *pbChangedSize)

{
    bool            bChangedPosition, bChangedSize;
    HRGN            hRgnDesktop;
    HWND            hWndDesktopListView, hWndShell, hWndShellChild;
    RECT            rcComponent, rcComponentTop;
    tDesktopRegion  desktopRegion;
    COMPPOS         defaultComponentPosition;

    bChangedPosition = bChangedSize = false;
    GetNextComponentPosition(&defaultComponentPosition);
    GDIToTrident(defaultComponentPosition.iLeft, defaultComponentPosition.iTop);

    // If the component has default left or top then give it the next
    // default component position.

    if ((pcp->iLeft == COMPONENT_DEFAULT_LEFT) && (pcp->iTop == COMPONENT_DEFAULT_TOP))
    {
        pcp->iLeft = defaultComponentPosition.iLeft;
        pcp->iTop = defaultComponentPosition.iTop;
        IncrementComponentsPositioned();
        bChangedPosition = true;
    }

    // If the component has default width or height then give it the
    // next default component size unless it is type COMP_TYPE_PICTURE

    // 98/10/02 #222449 vtan: Only change the size of an unpositioned
    // component if it's not a picture.

    if ((pcp->dwWidth == COMPONENT_DEFAULT_WIDTH) && (pcp->dwHeight == COMPONENT_DEFAULT_HEIGHT) && (iComponentType != COMP_TYPE_PICTURE))
    {
        pcp->dwWidth = defaultComponentPosition.dwWidth;
        pcp->dwHeight = defaultComponentPosition.dwHeight;
        bChangedSize = false;
    }

    // Make sure that the top line of the component is visible or at
    // least one pixel below the top most part of a virtual screen.

    // Check to see if the component has a negative width and height or
    // a width and height that is too small. The only exception to this
    // is if the component is a picture.

    desktopRegion.bAllowEntireDesktopRegion = IsZoomedState(dwComponentState);
    if (iComponentType != COMP_TYPE_PICTURE)
    {
        if (static_cast<int>(pcp->dwWidth) < 10)
        {
            pcp->dwWidth = defaultComponentPosition.dwWidth;
            bChangedSize = false;
        }
        if (static_cast<int>(pcp->dwHeight) < 10)
        {
            pcp->dwHeight= defaultComponentPosition.dwHeight;
            bChangedSize = false;
        }
    }
    TBOOL(SetRect(&rcComponent, pcp->iLeft, pcp->iTop, pcp->iLeft + pcp->dwWidth, pcp->iTop + pcp->dwHeight));
    TBOOL(CopyRect(&rcComponentTop, &rcComponent));
    rcComponentTop.bottom = rcComponentTop.top + 1;

    // Before calculating the desktopRegion as a region by using GDI calls
    // get the List View work area which will have information about docked
    // toolbars in addition to the taskbar which is the only thing that GDI
    // has. This will allow this function to invalidate regions occupied by
    // toolbars also.

    desktopRegion.iWorkAreaCount = 0;
    desktopRegion.prcWorkAreaRects = NULL;

    hWndDesktopListView = NULL;
    hWndShell = GetShellWindow();
    if (hWndShell != NULL)
    {
        hWndShellChild = GetWindow(hWndShell, GW_CHILD);
        if (hWndShellChild != NULL)
        {
            hWndDesktopListView = FindWindowEx(hWndShellChild, NULL, WC_LISTVIEW, NULL);
        }
    }
    if (hWndDesktopListView != NULL)
    {
        DWORD   dwProcessID;

        GetWindowThreadProcessId(hWndDesktopListView, &dwProcessID);
        if (GetCurrentProcessId() == dwProcessID)
        {
            ListView_GetNumberOfWorkAreas(hWndDesktopListView, &desktopRegion.iWorkAreaCount);
            desktopRegion.prcWorkAreaRects = reinterpret_cast<RECT*>(LocalAlloc(GPTR, desktopRegion.iWorkAreaCount * sizeof(desktopRegion.prcWorkAreaRects[0])));
            ListView_GetWorkAreasAsGDI(hWndDesktopListView, desktopRegion.iWorkAreaCount, desktopRegion.prcWorkAreaRects);
        }
    }

    CRGN    hRgnComponentTop(rcComponentTop), hRgnResult;

    desktopRegion.iMonitorCount = 0;
    TBOOL(EnumDisplayMonitors(NULL, NULL, MonitorCountEnumProc, reinterpret_cast<LPARAM>(&desktopRegion.iMonitorCount)));
    TBOOL(EnumDisplayMonitors(NULL, NULL, ValidateComponentPositionEnumProc, reinterpret_cast<LPARAM>(&desktopRegion)));
    hRgnDesktop = desktopRegion.hRgn;
    GDIToTrident(hRgnDesktop);

    // 99/03/23 #266412 vtan: Make sure that the top pixel of the component is within
    // the visible desktop. This allows the deskmovr to be positioned over the
    // component and therefore allows it to be moved. If the deskmovr cannot be
    // positioned over it then "snap" the component back into the visible region
    // to a maximum best fit algorithm.

    if (CombineRgn(hRgnResult, hRgnDesktop, hRgnComponentTop, RGN_AND) == NULLREGION)
    {
        LONG        lDeltaX, lDeltaY;
        HMONITOR    hMonitorNearest;
        RECT        rcComponentGDI, rcMonitorWork, rcIntersection;
        MONITORINFO monitorInfo;

        TBOOL(CopyRect(&rcComponentGDI, &rcComponent));
        TridentToGDI(rcComponentGDI);
        hMonitorNearest = MonitorFromRect(&rcComponentGDI, MONITOR_DEFAULTTONEAREST);
        ASSERT(hMonitorNearest != NULL);
        monitorInfo.cbSize = sizeof(monitorInfo);
        TBOOL(GetMonitorInfoWithCompensation(desktopRegion.iMonitorCount, hMonitorNearest, &monitorInfo));
        TINT(CopyMostSuitableListViewWorkAreaRect(&monitorInfo.rcWork, desktopRegion.iWorkAreaCount, desktopRegion.prcWorkAreaRects, &rcMonitorWork));
        ++rcMonitorWork.top;
        lDeltaX = lDeltaY = 0;
        if (rcComponentGDI.left < rcMonitorWork.left)
            lDeltaX = rcMonitorWork.left - rcComponentGDI.left;
        if (rcComponentGDI.top < rcMonitorWork.top)
            lDeltaY = rcMonitorWork.top - rcComponentGDI.top;
        if (rcComponentGDI.right > rcMonitorWork.right)
            lDeltaX = rcMonitorWork.right - rcComponentGDI.right;
        if (rcComponentGDI.bottom > rcMonitorWork.bottom)
            lDeltaY = rcMonitorWork.bottom - rcComponentGDI.bottom;
        TBOOL(OffsetRect(&rcComponentGDI, lDeltaX, lDeltaY));
        TBOOL(IntersectRect(&rcIntersection, &rcComponentGDI, &rcMonitorWork));
        GDIToTrident(rcIntersection);
        pcp->iLeft = rcIntersection.left;
        pcp->iTop = rcIntersection.top;
        pcp->dwWidth = rcIntersection.right - rcIntersection.left;
        pcp->dwHeight = rcIntersection.bottom - rcIntersection.top;
        bChangedPosition = bChangedSize = true;
    }

    if (desktopRegion.prcWorkAreaRects != NULL)
        LocalFree(desktopRegion.prcWorkAreaRects);

    if (pbChangedPosition != NULL)
        *pbChangedPosition = bChangedPosition;
    if (pbChangedSize != NULL)
        *pbChangedSize = bChangedSize;
}

//  98/12/11 #250938 vtan: these two functions are lifted from
//  SHBrows2.cpp which is part of browseui.dll.

EXTERN_C    DWORD   WINAPI  IsSmartStart (void);


#ifdef NEVER
// For WinMillennium, we do not want to launch the ICW when active desktop is turned on because
// we do not have a "My Current Homepage" desktop component. So, I am disabling the following code
// This is the temporary fix for Mill bug # 98107 also.
BOOL    IsICWCompleted (void)
{
    DWORD   dwICWCompleted, dwICWSize;

    dwICWCompleted = 0;
    dwICWSize = sizeof(dwICWCompleted);
    TW32(SHGetValue(HKEY_CURRENT_USER, TEXT(ICW_REGPATHSETTINGS), TEXT(ICW_REGKEYCOMPLETED), NULL, &dwICWCompleted, &dwICWSize));

    // 99/01/15 #272829 vtan: This is a horrible hack!!! If ICW has
    // not been run but settings have been made manually then values
    // in HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections
    // exists with the values given. Look for the presence of a key
    // to resolve that settings are present but that ICW hasn't been
    // launched.

    // The ideal solution is to get ICW to make this determination
    // for us BUT TO NOT LAUNCH ICWCONN1.EXE IN THE PROCESS.
    // Currently it will only launch. There is no way to get the
    // desired result without a launch.

    // 99/02/01 #280138 vtan: Well the solution put in for #272829
    // doesn't work. So peeking at the CheckConnectionWizard()
    // source in inetcfg\export.cpp shows that it uses a
    // wininet.dll function to determine whether manually configured
    // internet settings exist. It also exports this function so
    // look for it and bind to it dynamically. This uses the
    // DELAY_LOAD macros in dllload.c

    if (dwICWCompleted == 0)
    {
        #define SMART_RUNICW    TRUE
        #define SMART_QUITICW   FALSE

        dwICWCompleted = BOOLIFY(IsSmartStart() == SMART_QUITICW);
    }
    return(dwICWCompleted != 0);
}
#else  //NEVER
BOOL    IsICWCompleted (void)
{
    return TRUE; //For Millennium we want to always return TRUE for this function.
}
#endif //NEVER

void    LaunchICW (void)

{
    static  bool    sbCheckedICW = false;

    if (!sbCheckedICW && !IsICWCompleted())
    {
        HINSTANCE   hICWInst;

        // Prevent an error in finding the ICW from causing this to
        // execute again and again and again.

        sbCheckedICW = true;
        hICWInst = LoadLibrary(TEXT("inetcfg.dll"));
        if (hICWInst != NULL)
        {
            PFNCHECKCONNECTIONWIZARD    pfnCheckConnectionWizard;

            pfnCheckConnectionWizard = reinterpret_cast<PFNCHECKCONNECTIONWIZARD>(GetProcAddress(hICWInst, "CheckConnectionWizard"));
            if (pfnCheckConnectionWizard != NULL)
            {
                DWORD   dwICWResult;

                // If the user cancels ICW then it needs to be launched
                // again. Allow this case.

                sbCheckedICW = false;

                pfnCheckConnectionWizard(ICW_LAUNCHFULL | ICW_LAUNCHMANUAL, &dwICWResult);
            }
            TBOOL(FreeLibrary(hICWInst));
        }
    }
}

BOOL    IsLocalPicture (LPCTSTR pszURL)

{
    return(!PathIsURL(pszURL) && IsUrlPicture(pszURL));
}

BOOL    DisableUndisplayableComponents (IActiveDesktop *pIAD)

{
    bool    bHasVisibleNonLocalPicture;
    int     iItemCount;

    // 98/12/16 vtan #250938: If ICW has not been run to completion then only
    // allow the user to show components that are local pictures of some sort.
    // If any components are not local pictures then hide these components,
    // tell the user why it happened and launch ICW.

    bHasVisibleNonLocalPicture = false;
    if (SUCCEEDED(pIAD->GetDesktopItemCount(&iItemCount, 0)))
    {
        int     i;

        for (i = 0; i < iItemCount; ++i)
        {
            COMPONENT   component;

            component.dwSize = sizeof(component);
            if (SUCCEEDED(pIAD->GetDesktopItem(i, &component, 0)) && (component.fChecked != 0))
            {
               bool    bIsVisibleNonLocalPicture;
               TCHAR   szComponentSource[INTERNET_MAX_URL_LENGTH];

               SHUnicodeToTChar(component.wszSource, szComponentSource, ARRAYSIZE(szComponentSource));
               bIsVisibleNonLocalPicture = !IsLocalPicture(szComponentSource);
               bHasVisibleNonLocalPicture = bHasVisibleNonLocalPicture || bIsVisibleNonLocalPicture;
               if (bIsVisibleNonLocalPicture)
               {
                   component.fChecked = FALSE;
                   THR(pIAD->ModifyDesktopItem(&component, COMP_ELEM_CHECKED));
               }
            }
         }
    }
    if (bHasVisibleNonLocalPicture)
    {

        // Apply the changes. This should recurse to CActiveDesktop::_SaveSettings()
        // but this code path is NOT taken because AD_APPLY_REFRESH is not passed in.
        // CActiveDesktop::_SaveSettings() calls this function!

        bHasVisibleNonLocalPicture = FAILED(pIAD->ApplyChanges(AD_APPLY_SAVE | AD_APPLY_HTMLGEN));

        // Notify the user what happened and launch ICW.

        ShellMessageBox(HINST_THISDLL, NULL, MAKEINTRESOURCE(IDS_COMP_ICW_DISABLE), MAKEINTRESOURCE(IDS_COMP_ICW_TITLE), MB_OK);
        LaunchICW();
    }
    return(bHasVisibleNonLocalPicture);
}

int GetIconCountForWorkArea(HWND hwndLV, LPCRECT prect, int crect, int iWorkAreaIndex)
{
    int iCount;

    iCount = ListView_GetItemCount(hwndLV);

    if (crect > 1) 
    {
        int i, iCountWorkArea = 0;

        for (i = 0; i < iCount; i++)
        {
            POINT pt;
            ListView_GetItemPosition(hwndLV, i, &pt);
            if (iWorkAreaIndex == GetWorkAreaIndexFromPoint(pt, prect, crect))
                iCountWorkArea++;
        }

        iCount = iCountWorkArea;
    }

    return iCount;
}

BOOL GetZoomRect(BOOL fFullScreen, BOOL fAdjustListview, int iTridentLeft, int iTridentTop, DWORD dwComponentWidth, DWORD dwComponentHeight, LPRECT prcZoom, LPRECT prcWork)
{
    HWND hwndShell, hwndLV;
    int icWorkAreas = 0, iWAC;
    RECT rcWork[LV_MAX_WORKAREAS];

    hwndLV = NULL;
    hwndShell = GetShellWindow();
    if (hwndShell != NULL)
    {
        HWND    hwndShellChild;

        hwndShellChild= GetWindow(hwndShell, GW_CHILD);
        if (hwndShellChild != NULL)
        {
            hwndLV = FindWindowEx(hwndShellChild, NULL, WC_LISTVIEW, NULL);
        }
    }

    //
    // First calculate the Work Areas and Work Area index for the component, then perform the
    // particular operation based on lCommand.
    //
    if (hwndLV) {
        DWORD dwpid;
        GetWindowThreadProcessId(hwndLV, &dwpid);
        // The listview doesn't thunk these messages so we can't do
        // this inter-process!
        if (dwpid == GetCurrentProcessId())
        {
            ListView_GetNumberOfWorkAreas(hwndLV, &icWorkAreas);
            if (icWorkAreas <= LV_MAX_WORKAREAS)
                ListView_GetWorkAreas(hwndLV, icWorkAreas, &rcWork);
            else
                hwndLV = NULL;
        } else {
            return FALSE;
        }
    }

    // 98/10/07 vtan: This used to use a variable icWorkAreasAdd.
    // Removed this variable and directly increment icWorkAreas.
    // This doesn't affect the call to ListView_SetWorkAreas()
    // below because in this case hwndLV is NULL.

    if (icWorkAreas == 0)
    {
        RECT rc;

        ++icWorkAreas;
        SystemParametersInfo(SPI_GETWORKAREA, 0, (PVOID)&rc, 0);
        rcWork[0] = rc;
        hwndLV = NULL;
    }

    // 98/10/02 #212654 vtan: Changed the calculation code to find a
    // rectangle to zoom the component to based on GDI co-ordinates.
    // The component is passed in trident co-ordinates which are
    // stored in a RECT and converted to GDI co-ordinates. The system
    // then locates the monitor which the component is on and if it
    // cannot find the monitor then defaults to the primary. The
    // dimensions of the monitor are used before converting back to
    // trident co-ordinates.

    int             i, iMonitorCount;
    HMONITOR        hMonitor;
    RECT            rcComponentRect;
    MONITORINFO     monitorInfo;

    iMonitorCount = 0;
    TBOOL(EnumDisplayMonitors(NULL, NULL, MonitorCountEnumProc, reinterpret_cast<LPARAM>(&iMonitorCount)));
    TBOOL(SetRect(&rcComponentRect, iTridentLeft, iTridentTop, iTridentLeft + dwComponentWidth, iTridentTop + dwComponentHeight));
    TridentToGDI(rcComponentRect);
    hMonitor = MonitorFromRect(&rcComponentRect, MONITOR_DEFAULTTOPRIMARY);
    ASSERT(hMonitor != NULL);
    monitorInfo.cbSize = sizeof(monitorInfo);
    TBOOL(GetMonitorInfoWithCompensation(iMonitorCount, hMonitor, &monitorInfo));
    GDIToTrident(monitorInfo.rcWork);

    // 99/05/19 #340772 vtan: Always try to key off work areas returned
    // by ListView_GetWorkAreas because these take into account docked
    // toolbars which GDI does not. In this case the listview work areas
    // will always be the same rectangle when intersected with the GDI
    // work area. Use this rule to determine which listview work area
    // to use as the basis for the zoom rectangle.

    i = CopyMostSuitableListViewWorkAreaRect(&monitorInfo.rcWork, icWorkAreas, rcWork, prcZoom);
    if (i < 0)
    {
        i = 0;
    }
    if (prcWork != NULL)
    {
        TBOOL(CopyRect(prcWork, prcZoom));
    }
    iWAC = i;

    if (!fFullScreen)
    {
        // For the split case we shrink the work area down temporarily to the smallest rectangle
        // that can bound the current number of icons.  This will force the icons into that rectangle,
        // then restore it back to the way it was before.  Finally, we set the size of the split
        // component to fill the rest of the space.
        if (hwndLV) {
            int iCount, iItemsPerColumn, icxWidth, iRightOld;
            DWORD dwSpacing;

            iCount = GetIconCountForWorkArea(hwndLV, rcWork, icWorkAreas, iWAC);
            // Decrement the count so that rounding works right
            if (iCount)     
                iCount--;

            // Calculate the new width for the view rectangle
            dwSpacing = ListView_GetItemSpacing(hwndLV, FALSE);
            iItemsPerColumn = (rcWork[iWAC].bottom - rcWork[iWAC].top) / (HIWORD(dwSpacing));
            if (iItemsPerColumn)
                icxWidth = ((iCount / iItemsPerColumn) + 1) * (LOWORD(dwSpacing));
            else
                icxWidth = LOWORD(dwSpacing);

            // Don't let it get smaller than half the screen
            if (icxWidth > ((rcWork[iWAC].right - rcWork[iWAC].left) / 2))
                icxWidth = (rcWork[iWAC].right - rcWork[iWAC].left) / 2;

            if (fAdjustListview)
            {
                // Now take the old work area rectangle and shrink it to our new width
                iRightOld = rcWork[iWAC].right;
                rcWork[iWAC].right = rcWork[iWAC].left + icxWidth;
                ListView_SetWorkAreas(hwndLV, icWorkAreas, &rcWork);

                // Finally restore the old work area
                rcWork[iWAC].right = iRightOld;
                ListView_SetWorkAreas(hwndLV, icWorkAreas, &rcWork);
            }

            // Adjust the left coordinate of the zoom rect to reflect our calculated split amount
            // the rest of the screen.
            if (IS_BIDI_LOCALIZED_SYSTEM())
            {
                prcZoom->right -= icxWidth;
            }
            else
            {
                prcZoom->left += icxWidth;
            }
        } else {
            // Fallback case, if there is no listview use 20% of the screen for the icons.
            if (IS_BIDI_LOCALIZED_SYSTEM())
            {
                prcZoom->right -= ((prcZoom->right - prcZoom->left) * 2 / 10);            
            }
            else
            {
                prcZoom->left += ((prcZoom->right - prcZoom->left) * 2 / 10);
            }    
        }
    }

    return TRUE;
}

void ZoomComponent(COMPPOS * pcp, DWORD dwCurItemState, BOOL fAdjustListview)
{
    RECT rcZoom;

    if (GetZoomRect((dwCurItemState & IS_FULLSCREEN), fAdjustListview, pcp->iLeft, pcp->iTop, pcp->dwWidth, pcp->dwHeight, &rcZoom, NULL))
    {
        // Copy the new Zoom rectangle over and put it on the bottom
        pcp->iLeft = rcZoom.left;
        pcp->iTop = rcZoom.top;
        pcp->dwWidth = rcZoom.right - rcZoom.left;
        pcp->dwHeight = rcZoom.bottom - rcZoom.top;
        pcp->izIndex = 0;
    }
    else
    {
        // Failure implies we couldn't get the zoom rectangle through inter-process calls.  Set the
        // COMPONENTS_ZOOMDIRTY bit here so that when the desktop is refreshed we will recalculate
        // the zoom rectangles in-process inside of EnsureUpdateHTML.
        SetDesktopFlags(COMPONENTS_ZOOMDIRTY, COMPONENTS_ZOOMDIRTY);
    }
}

//
// PositionComponent will assign a screen position and
// make sure it fits on the screen.
//

void PositionComponent(COMPONENTA *pcomp, COMPPOS *pcp, int iCompType, BOOL fCheckItemState)

{

//  vtan: Vastly simplified routine. The work is now done in
//  ValidateComponentPosition.

    if (ISZOOMED(pcomp))
    {
        if (fCheckItemState)
        {
            SetStateInfo(&pcomp->csiRestored, pcp, IS_NORMAL);
            SetStateInfo(&pcomp->csiOriginal, pcp, pcomp->dwCurItemState);
        }
        ZoomComponent(pcp, pcomp->dwCurItemState, FALSE);
    }
    else
    {
        ValidateComponentPosition(pcp, pcomp->dwCurItemState, iCompType, NULL, NULL);
        if (fCheckItemState)
            SetStateInfo(&pcomp->csiOriginal, pcp, pcomp->dwCurItemState);
    }
}

typedef struct _tagFILETYPEENTRY {
    DWORD dwFlag;
    int iFilterId;
} FILETYPEENTRY;

FILETYPEENTRY afte[] = {
    { GFN_URL, IDS_URL_FILTER, },
    { GFN_CDF, IDS_CDF_FILTER, },
    { GFN_LOCALHTM, IDS_HTMLDOC_FILTER, },
    { GFN_PICTURE,  IDS_IMAGES_FILTER, },
    { GFN_LOCALMHTML, IDS_MHTML_FILTER, },
};

//
// Opens either an HTML page or a picture.
//
BOOL GetFileName(HWND hdlg, LPTSTR pszFileName, int iSize, int iTypeId[], DWORD dwFlags[])
{
    BOOL fRet = FALSE;

    if (dwFlags)
    {
        int i, iIndex, cchRead;
        TCHAR szFilter[MAX_PATH*4];

        //
        // Set the friendly name.
        //
        LPTSTR pchFilter = szFilter;
        int cchFilter = ARRAYSIZE(szFilter) - 2;    // room for term chars

        for(iIndex = 0; dwFlags[iIndex]; iIndex++)
        {
            cchRead = LoadString(HINST_THISDLL, iTypeId[iIndex], pchFilter, cchFilter);
            pchFilter += cchRead + 1;
            cchFilter -= cchRead + 1;

            //
            // Append the file filters.
            //
            BOOL fAddedToString = FALSE;
            for (i=0; (cchFilter>0) && (i<ARRAYSIZE(afte)); i++)
            {
                if (dwFlags[iIndex] & afte[i].dwFlag)
                {
                    if (fAddedToString)
                    {
                        *pchFilter++ = TEXT(';');
                        cchFilter--;
                    }
                    cchRead = LoadString(HINST_THISDLL, afte[i].iFilterId,
                                     pchFilter, cchFilter);
                    pchFilter += cchRead;
                    cchFilter -= cchRead;
                    fAddedToString = TRUE;
                }
            }
            *pchFilter++ = TEXT('\0');
        }

        //
        // Double-NULL terminate the string.
        //
        *pchFilter = TEXT('\0');

        TCHAR szBrowserDir[MAX_PATH];
        lstrcpy(szBrowserDir, pszFileName);
        PathRemoveFileSpec(szBrowserDir);

        TCHAR szBuf[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_BROWSE, szBuf, ARRAYSIZE(szBuf));

        *pszFileName = TEXT('\0');

        OPENFILENAME ofn = {0};
        ofn.lStructSize       = SIZEOF(ofn);
        ofn.hwndOwner         = hdlg;
        ofn.hInstance         = NULL;
        ofn.lpstrFilter       = szFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nFilterIndex      = 1;
        ofn.nMaxCustFilter    = 0;
        ofn.lpstrFile         = pszFileName;
        ofn.nMaxFile          = iSize;
        ofn.lpstrInitialDir   = szBrowserDir;
        ofn.lpstrTitle        = szBuf;
        ofn.Flags             = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
        ofn.lpfnHook          = NULL;
        ofn.lpstrDefExt       = NULL;
        ofn.lpstrFileTitle    = NULL;

        fRet = GetOpenFileName(&ofn);
    }

    return fRet;
}

//
// Convert a pattern string to a bottom-up array of DWORDs,
// useful for BMP format files.
//
void PatternToDwords(LPTSTR psz, DWORD *pdwBits)
{
    DWORD i, dwVal;

    //
    // Get eight groups of numbers separated by non-numeric characters.
    //
    for (i=0; i<8; i++)
    {
        dwVal = 0;

        if (*psz != TEXT('\0'))
        {
            //
            // Skip over any non-numeric characters.
            //
            while (*psz && (!(*psz >= TEXT('0') && *psz <= TEXT('9'))))
            {
                psz++;
            }

            //
            // Get the next series of digits.
            //
            while (*psz && (*psz >= TEXT('0') && *psz <= TEXT('9')))
            {
                dwVal = dwVal*10 + *psz++ - TEXT('0');
            }
        }

        pdwBits[7-i] = dwVal;
    }
}

//
// Convert a pattern string to a top-down array of WORDs,
// useful for CreateBitmap().
//
void PatternToWords(LPTSTR psz, WORD *pwBits)
{
    WORD i, wVal;

    //
    // Get eight groups of numbers separated by non-numeric characters.
    //
    for (i=0; i<8; i++)
    {
        wVal = 0;

        if (*psz != TEXT('\0'))
        {
            //
            // Skip over any non-numeric characters.
            //
            while (*psz && (!(*psz >= TEXT('0') && *psz <= TEXT('9'))))
            {
                psz++;
            }

            //
            // Get the next series of digits.
            //
            while (*psz && ((*psz >= TEXT('0') && *psz <= TEXT('9'))))
            {
                wVal = wVal*10 + *psz++ - TEXT('0');
            }
        }

        pwBits[i] = wVal;
    }
}

BOOL IsValidPattern(LPCTSTR pszPat)
{
    BOOL fSawANumber = FALSE;

    //
    // We're mainly trying to filter multilingual upgrade cases
    // where the text for "(None)" is unpredictable.
    // 
    // 
    //
    while (*pszPat)
    {
        if ((*pszPat < TEXT('0')) || (*pszPat > TEXT('9')))
        {
            //
            // It's not a number, it better be a space.
            //
            if (*pszPat != TEXT(' '))
            {
                return FALSE;
            }
        }
        else
        {
            fSawANumber = TRUE;
        }

        //
        // We avoid the need for AnsiNext by only advancing on US TCHARs.
        //
        pszPat++;
    }

    //
    // TRUE if we saw at least one digit and there were only digits and spaces.
    //
    return fSawANumber;
}

//
// Determines if the wallpaper can be supported in non-active desktop mode.
//
BOOL IsNormalWallpaper(LPCTSTR pszFileName)
{
    BOOL fRet = TRUE;

    if (pszFileName[0] == TEXT('\0'))
    {
        fRet = TRUE;
    }
    else
    {
        LPTSTR pszExt = PathFindExtension(pszFileName);

        //Check for specific files that can be shown only in ActiveDesktop mode!
        if((StrCmpIC(pszExt, TEXT(".GIF")) == 0) || // 368690: Strange, but we must compare 'i' in both caps and lower case.
           (lstrcmpi(pszExt, TEXT(".JPG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".JPE")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".JPEG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".PNG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTM")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTML")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTT")) == 0))
           return FALSE;

        //Everything else (including *.BMP files) are "normal" wallpapers
    }
    return fRet;
}

//
// Determines if the wallpaper is a picture (vs. HTML).
//
BOOL IsWallpaperPicture(LPCTSTR pszWallpaper)
{
    BOOL fRet = TRUE;

    if (pszWallpaper[0] == TEXT('\0'))
    {
        //
        // Empty wallpapers count as empty pictures.
        //
        fRet = TRUE;
    }
    else
    {
        LPTSTR pszExt = PathFindExtension(pszWallpaper);

        if ((lstrcmpi(pszExt, TEXT(".HTM")) == 0) ||
            (lstrcmpi(pszExt, TEXT(".HTML")) == 0) ||
            (lstrcmpi(pszExt, TEXT(".HTT")) == 0))
        {
            fRet = FALSE;
        }
    }

    return fRet;
}

void OnDesktopSysColorChange(void)
{
    static COLORREF clrBackground = 0xffffffff;
    static COLORREF clrWindowText = 0xffffffff;

    //Get the new colors!
    COLORREF    clrNewBackground = GetSysColor(COLOR_BACKGROUND);
    COLORREF    clrNewWindowText = GetSysColor(COLOR_WINDOWTEXT);

    //Have we initialized these before?
    if(clrBackground != 0xffffffff)  //Have we initialized the statics yet?
    {
        // Our HTML file depends only on these two system colors.
        // Check if either of them has changed!
        // If not, no need to regenerate HTML file. 
        // This avoids infinite loop. And this is a nice optimization.
        if((clrBackground == clrNewBackground) &&
           (clrWindowText == clrNewWindowText))
            return; //No need to do anything. Just return.
    }

    // Remember the new colors in the statics.
    clrBackground = clrNewBackground;
    clrWindowText = clrNewWindowText;

    //
    // The desktop got a WM_SYSCOLORCHANGE.  We need to
    // regenerate the HTML if there are any system colors
    // showing on the desktop.  Patterns and the desktop
    // color are both based on system colors.
    //
    IActiveDesktop *pad;
    if (SUCCEEDED(CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&pad, IID_IActiveDesktop)))
    {
        BOOL fRegenerateHtml = FALSE;
        WCHAR szWallpaperW[INTERNET_MAX_URL_LENGTH];

        if (SUCCEEDED(pad->GetWallpaper(szWallpaperW, ARRAYSIZE(szWallpaperW), 0)))
        {
            if (!*szWallpaperW)
            {
                //
                // No wallpaper means the desktop color
                // or a pattern is showing - we need to
                // regenerate the desktop HTML.
                //
                fRegenerateHtml = TRUE;
            }
            else
            {
                TCHAR *pszWallpaper;
#ifdef UNICODE
                pszWallpaper = szWallpaperW;
#else
                CHAR szWallpaperA[INTERNET_MAX_URL_LENGTH];
                SHUnicodeToAnsi(szWallpaperW, szWallpaperA, ARRAYSIZE(szWallpaperA));
                pszWallpaper = szWallpaperA;
#endif
                if (IsWallpaperPicture(pszWallpaper))
                {
                    WALLPAPEROPT wpo = { SIZEOF(wpo) };
                    if (SUCCEEDED(pad->GetWallpaperOptions(&wpo, 0)))
                    {
                        if (wpo.dwStyle == WPSTYLE_CENTER)
                        {
                            //
                            // We have a centered picture,
                            // the pattern or desktop color
                            // could be leaking around the edges.
                            // We need to regenerate the desktop
                            // HTML.
                            //
                            fRegenerateHtml = TRUE;
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "SYSCLRCHG: Could not get wallpaper options!");
                    }
                }
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "SYSCLRCHG: Could not get selected wallpaper!");
        }

        
        if (fRegenerateHtml)
        {
            DWORD  dwFlags = AD_APPLY_FORCE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH | AD_APPLY_DYNAMICREFRESH;
            WCHAR   wszPattern[MAX_PATH];
            //If we have a pattern, then we need to force a AD_APPLY_COMPLETEREFRESH
            // because we need to re-generate the pattern.bmp file which can not be 
            // done through dynamic HTML.
            if(SUCCEEDED(pad->GetPattern(wszPattern, ARRAYSIZE(wszPattern), 0)))
            {
#ifdef UNICODE
                LPTSTR  szPattern = (LPTSTR)wszPattern;
#else
                CHAR   szPattern[MAX_PATH];
                SHUnicodeToAnsi(wszPattern, szPattern, sizeof(szPattern));
#endif //UNICODE
                if(IsValidPattern(szPattern))           //Does this have a pattern?
                    dwFlags &= ~(AD_APPLY_DYNAMICREFRESH);  //Then force a complete refresh!
                    
            }
            pad->ApplyChanges(dwFlags);
        }

        pad->Release();
    }
    else
    {
        TraceMsg(TF_WARNING, "SYSCLRCHG: Could not create CActiveDesktop!");
    }
}

//
// Convert a .URL file into its target.
//
void CheckAndResolveLocalUrlFile(LPTSTR pszFileName, int cchFileName)
{
    //
    // This function only works on *.URL files.
    //
    if (!PathIsURL(pszFileName))
    {
        LPTSTR pszExt;

        //
        // Check if the extension of this file is *.URL
        //
        pszExt = PathFindExtension(pszFileName);
        if (pszExt && *pszExt)
        {
            TCHAR  szUrl[15];
        
            LoadString(HINST_THISDLL, IDS_URL_EXTENSION, szUrl, ARRAYSIZE(szUrl));

            if (lstrcmpi(pszExt, szUrl) == 0)
            {
                HRESULT  hr;

                IUniformResourceLocator *purl;

                hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                              IID_IUniformResourceLocator,
                              (LPVOID *)&purl);

                if (EVAL(SUCCEEDED(hr)))  // This works for both Ansi and Unicode
                {
                    ASSERT(purl);

                    IPersistFile  *ppf;

                    hr = purl->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
                    if (SUCCEEDED(hr))
                    {
                        WCHAR szFileW[MAX_PATH];
                        LPTSTR pszTemp;

                        SHTCharToUnicode(pszFileName, szFileW, ARRAYSIZE(szFileW));
                        ppf->Load(szFileW, STGM_READ);
                        hr = purl->GetURL(&pszTemp);    // Wow, an ANSI/UNICODE COM interface!
                        if (EVAL(SUCCEEDED(hr)))
                        {
                            StrCpyN(pszFileName, pszTemp, cchFileName);
                            CoTaskMemFree(pszTemp);
                        }
                        ppf->Release();
                    }
                    purl->Release();
                }
            }
        }
    }
}


void GetMyCurHomePageStartPos(int *piLeft, int *piTop, DWORD *pdwWidth, DWORD *pdwHeight)
{
#define INVALID_POS 0x80000000
    HKEY hkey;

    //
    // Assume nothing.
    //
    *piLeft = INVALID_POS;
    *piTop = INVALID_POS;
    *pdwWidth = INVALID_POS;
    *pdwHeight = INVALID_POS;

    //
    // Read from registry first.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main"), 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        DWORD dwType, cbData;

        cbData = SIZEOF(*piLeft);
        SHQueryValueEx(hkey, TEXT("MyCurHome_Left"), NULL, &dwType, (LPBYTE)piLeft, &cbData);

        cbData = SIZEOF(*piTop);
        SHQueryValueEx(hkey, TEXT("MyCurHome_Top"), NULL, &dwType, (LPBYTE)piTop, &cbData);

        cbData = SIZEOF(*pdwWidth);
        SHQueryValueEx(hkey, TEXT("MyCurHome_Width"), NULL, &dwType, (LPBYTE)pdwWidth, &cbData);

        cbData = SIZEOF(*pdwHeight);
        SHQueryValueEx(hkey, TEXT("MyCurHome_Height"), NULL, &dwType, (LPBYTE)pdwHeight, &cbData);

        RegCloseKey(hkey);
    }

    //
    // Fill in defaults when registry provides no info.
    //
    if (*piLeft == INVALID_POS)
    {
        *piLeft = -MYCURHOME_WIDTH;
    }
    if (*piTop == INVALID_POS)
    {
        *piTop = MYCURHOME_TOP;
    }
    if (*pdwWidth == INVALID_POS)
    {
        *pdwWidth = MYCURHOME_WIDTH;
    }
    if (*pdwHeight == INVALID_POS)
    {
        *pdwHeight = MYCURHOME_HEIGHT;
    }

    //
    // Convert negative values into positive ones.
    //
    RECT rect;
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rect, FALSE);
    if (*piLeft < 0)
    {
        *piLeft += (rect.right - rect.left) - *pdwWidth;
    }
    if (*piTop < 0)
    {
        *piTop += (rect.bottom - rect.top) - *pdwHeight;
    }

    // Find the virtual dimensions.
    EnumMonitorsArea ema;
    GetMonitorSettings(&ema);
    // Position it in the primary monitor.
    *piLeft -= ema.rcVirtualMonitor.left;
    *piTop -= ema.rcVirtualMonitor.top;
#undef INVALID_POS

}


//
// Silently adds/removes a specified component to the desktop and use the given
//  apply flags using which you can avoid nested unnecessary HTML generation, 
//  or refreshing which may lead to racing conditions.
// 
//
BOOL AddRemoveDesktopComponentNoUI(BOOL fAdd, DWORD dwApplyFlags, LPCTSTR pszUrl, LPCTSTR pszFriendlyName, int iCompType, int iLeft, int iTop, int iWidth, int iHeight, BOOL fChecked, DWORD dwCurItemState, BOOL fNoScroll, BOOL fCanResize)
{
    COMPONENTA Comp;
    BOOL    fRet = FALSE;
    HRESULT hres;

    //
    // Build the pcomp structure.
    //
    Comp.dwSize = sizeof(COMPONENTA);
    Comp.dwID = -1;
    Comp.iComponentType = iCompType;
    Comp.fChecked = fChecked;
    Comp.fDirty = FALSE;
    Comp.fNoScroll = fNoScroll;
    Comp.cpPos.dwSize = SIZEOF(COMPPOS);
    Comp.cpPos.iLeft = iLeft;
    Comp.cpPos.iTop = iTop;
    Comp.cpPos.dwWidth = iWidth;
    Comp.cpPos.dwHeight = iHeight;
    Comp.cpPos.izIndex = (dwCurItemState & IS_NORMAL) ? COMPONENT_TOP : 0;
    Comp.cpPos.fCanResize = fCanResize;
    Comp.cpPos.fCanResizeX = fCanResize;
    Comp.cpPos.fCanResizeY = fCanResize;
    Comp.cpPos.iPreferredLeftPercent = 0;
    Comp.cpPos.iPreferredTopPercent = 0;
    Comp.dwCurItemState = dwCurItemState;
    lstrcpyn(Comp.szSource, pszUrl, ARRAYSIZE(Comp.szSource));
    lstrcpyn(Comp.szSubscribedURL, pszUrl, ARRAYSIZE(Comp.szSource));
    if (pszFriendlyName)
    {
        lstrcpyn(Comp.szFriendlyName, pszFriendlyName, ARRAYSIZE(Comp.szFriendlyName));
    }
    else
    {
        Comp.szFriendlyName[0] = TEXT('\0');
    }

    IActiveDesktop *pActiveDesk;

    //
    // Add it to the system.
    //
    hres = CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&pActiveDesk, IID_IActiveDesktop);
    if (SUCCEEDED(hres))
    {
        COMPONENT  CompW;

        CompW.dwSize = sizeof(CompW);  //Required for the MultiCompToWideComp to work properly.

        MultiCompToWideComp(&Comp, &CompW);

        if(fAdd)
            pActiveDesk->AddDesktopItem(&CompW, 0);
        else
            pActiveDesk->RemoveDesktopItem(&CompW, 0);
            
        pActiveDesk->ApplyChanges(dwApplyFlags);
        pActiveDesk->Release();
        fRet = TRUE;
    }

    return fRet;
}

//
//  Summary: 
//      On upgrade from W2K, it is possible (under certain conditions) that the Active Desktop  
//  gets turned ON automatically. This is bug #154993. The following function fixes this bug.
//
// Details of why this happens:
//
// In W2K, it is possible to enable active desktop components, hide icons, lock the components
// and then turn off active desktop. But, all the details (like what AD components were ON etc.,)
// was persisted in the registry. When such a machine is upgraded to Whister, bug #154993 surfaces
// because of the following reason:
//  In Whislter, ActiveDesktop is turned on/off silently based on whether any desktop component is 
// on etc., As a result when a W2K machine (with AD off) is upgraded to Whistler, the AD will be
// turned on automatically, if one of the following is true:
//    1. If the desktop icons were off.
//    2. If the active desktop components were locked.
//    3. If any active desktop component is ON; but, not displayed because AD was OFF..
//  Therefore on upgrade from a Win2K or older machine, we check if the AD is OFF. If so, then we 
// need to check for conditions 1, 2 and 3 and change those settings such that AD continues to be 
// OFF even after the upgrade. The following function OnUpgradeDisableActiveDesktopFeatures ()
// does precisely this.
//
// Returns: TRUE, if any setting was modified to keep the active desktop in the turned off state!
//
BOOL   OnUpgradeDisableActiveDesktopFeatures()
{
    IActiveDesktop *pActiveDesk;
    BOOL    fModified = FALSE;

    // Get the ActiveDesktop and HideIcons flags.
    SHELLSTATE  ss = {0};
    SHGetSetSettings(&ss, SSF_DESKTOPHTML | SSF_HIDEICONS, FALSE);

    //Check if ActiveDesktop is already ON.
    if(ss.fDesktopHTML)
        return FALSE;  //ActiveDesktop is already ON. No need to change any settings.

    //Active Desktop is OFF. We may need to change the other settings to be consistent with this!

    // 1. Check if Desktop icons are hidden when ActiveDesktop is on.
    if(ss.fHideIcons)
    {
        //Yes! Turn off this. Otherwise, AD will be turned on to support this!
        ss.fHideIcons = FALSE;
        SHGetSetSettings(&ss, SSF_HIDEICONS, TRUE);
        fModified = TRUE;
    }
    
    // 2. If the ActiveDesktop components are locked, un-lock them.
    DWORD dwDesktopFlags = GetDesktopFlags();
    
    if(dwDesktopFlags & COMPONENTS_LOCKED)
    {
        if(SetDesktopFlags(COMPONENTS_LOCKED, 0)) //Remove the "locked" flag!
            fModified = TRUE;
    }

    // 3. Let's enumerate all active desktop components and make sure they are all off.
    BOOL fModifiedComp = FALSE;

    HRESULT hres = CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&pActiveDesk, IID_IActiveDesktop);
    if (SUCCEEDED(hres))
    {
        int iCount = 0;
        pActiveDesk->GetDesktopItemCount(&iCount, 0);

        for(int i = 0; i < iCount; i++)
        {
            COMPONENT Comp;
            Comp.dwSize = sizeof(Comp);
            if(SUCCEEDED(pActiveDesk->GetDesktopItem(i, &Comp, 0)))
            {
                if(Comp.fChecked)           //If this component is enabled.....
                {
                    Comp.fChecked = FALSE;  //...., then disable it!
                    if(SUCCEEDED(pActiveDesk->ModifyDesktopItem(&Comp, COMP_ELEM_CHECKED)))
                        fModifiedComp = TRUE;
                }
            }
        }

        if(fModifiedComp)
            pActiveDesk->ApplyChanges(AD_APPLY_SAVE); //We just need to save the above changes.

        pActiveDesk ->Release();
    }

    //return whether we modified any setting.
    return (fModified || fModifiedComp);
}



// Little helper function used to change the safemode state
void SetSafeMode(DWORD dwFlags)
{
    IActiveDesktopP * piadp;

    if (SUCCEEDED(CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&piadp, IID_IActiveDesktopP)))
    {
        piadp->SetSafeMode(dwFlags);
        piadp->Release();
    }
}

/****************************************************************************
 *
 *  RefreshWebViewDesktop - regenerates desktop HTML from registry and updates
 *                          the screen
 *
 *  ENTRY:
 *      none
 *
 *  RETURNS:
 *      TRUE on success
 *      
 ****************************************************************************/
BOOL PokeWebViewDesktop(DWORD dwFlags)
{
    IActiveDesktop *pad;
    HRESULT     hres;
    BOOL        fRet = FALSE;

    hres = CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&pad, IID_IActiveDesktop);

    if (SUCCEEDED(hres))
    {
        pad->ApplyChanges(dwFlags);
        pad->Release();

        fRet = TRUE;
    }

    return (fRet);
}

#define CCH_NONE 20 //big enough for "(None)" in german
TCHAR g_szNone[CCH_NONE] = {0};

void InitDeskHtmlGlobals(void)
{
    static fGlobalsInited = FALSE;

    if (fGlobalsInited == FALSE)
    {
        LoadString(HINST_THISDLL, IDS_WPNONE, g_szNone, ARRAYSIZE(g_szNone));

        fGlobalsInited = TRUE;
    }
}

//
// Loads the preview bitmap for property sheet pages.
//
HBITMAP LoadMonitorBitmap(void)
{
    HBITMAP hbm,hbmT;
    BITMAP bm;
    HBRUSH hbrT;
    HDC hdc;
    COLORREF c3df = GetSysColor(COLOR_3DFACE);

    hbm = LoadBitmap(HINST_THISDLL, MAKEINTRESOURCE(IDB_MONITOR));
    if (hbm == NULL)
    {
        return NULL;
    }

    //
    // Convert the "base" of the monitor to the right color.
    //
    // The lower left of the bitmap has a transparent color
    // we fixup using FloodFill
    //
    hdc = CreateCompatibleDC(NULL);
    hbmT = (HBITMAP)SelectObject(hdc, hbm);
    hbrT = (HBRUSH)SelectObject(hdc, GetSysColorBrush(COLOR_3DFACE));

    GetObject(hbm, sizeof(bm), &bm);

    ExtFloodFill(hdc, 0, bm.bmHeight-1, GetPixel(hdc, 0, bm.bmHeight-1), FLOODFILLSURFACE);

    //
    // Round off the corners.
    // The bottom two were done by the floodfill above.
    // The top left is important since SS_CENTERIMAGE uses it to fill gaps.
    // The top right should be rounded because the other three are.
    //
    SetPixel( hdc, 0, 0, c3df );
    SetPixel( hdc, bm.bmWidth-1, 0, c3df );

    //
    // Fill in the desktop here.
    //
    HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, GetSysColorBrush(COLOR_DESKTOP));
    PatBlt(hdc, MON_X, MON_Y, MON_DX, MON_DY, PATCOPY);
    SelectObject(hdc, hbrOld);

    //
    // Clean up after ourselves.
    //
    SelectObject(hdc, hbrT);
    SelectObject(hdc, hbmT);
    DeleteDC(hdc);

    return hbm;
}

STDAPI_(VOID) ActiveDesktop_ApplyChanges()
{
    IActiveDesktop* piad;
    if (SUCCEEDED(CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &piad))))
    {        
        piad->ApplyChanges(AD_APPLY_ALL | AD_APPLY_DYNAMICREFRESH);
        piad->Release();
    }
    
}

STDAPI_(DWORD) GetDesktopFlags(void)
{
    DWORD dwFlags = 0, dwType, cbSize = SIZEOF(dwFlags);
    TCHAR lpszDeskcomp[MAX_PATH];

    GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_COMPONENTS, NULL);

    SHGetValue(HKEY_CURRENT_USER, lpszDeskcomp, REG_VAL_COMP_GENFLAGS, &dwType, &dwFlags, &cbSize);

    return dwFlags;
}

STDAPI_(BOOL) SetDesktopFlags(DWORD dwMask, DWORD dwNewFlags)
{
    BOOL  fRet = FALSE;
    HKEY  hkey;
    DWORD dwDisposition;
    TCHAR lpszDeskcomp[MAX_PATH];

    GetRegLocation(lpszDeskcomp, SIZECHARS(lpszDeskcomp), REG_DESKCOMP_COMPONENTS, NULL);

    if (RegCreateKeyEx(HKEY_CURRENT_USER, (LPCTSTR)lpszDeskcomp, 
                       0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkey,
                       &dwDisposition) == ERROR_SUCCESS)
    {
        DWORD dwFlags;
        DWORD cbSize = SIZEOF(dwFlags);
        DWORD dwType;

        if (SHQueryValueEx(hkey, REG_VAL_COMP_GENFLAGS, NULL, &dwType,
                            (LPBYTE)&dwFlags, &cbSize) != ERROR_SUCCESS)
        {
            dwFlags = 0;
        }

        dwFlags = (dwFlags & ~dwMask) | (dwNewFlags & dwMask);

        if (RegSetValueEx(hkey, REG_VAL_COMP_GENFLAGS, 0, REG_DWORD,
                          (LPBYTE)&dwFlags, sizeof(dwFlags)) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
    
        RegCloseKey(hkey);
    }

    return fRet;
}

BOOL UpdateComponentFlags(LPCTSTR pszCompId, DWORD dwMask, DWORD dwNewFlags)
{
    BOOL fRet = FALSE;
    TCHAR szRegPath[MAX_PATH];
    HKEY hkey;

    GetRegLocation(szRegPath, SIZECHARS(szRegPath), REG_DESKCOMP_COMPONENTS, NULL);

    lstrcat(szRegPath, TEXT("\\"));
    lstrcat(szRegPath, pszCompId);

    //Don't use RegCreateKeyEx here. It will result in Null components to be added.
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szRegPath, 0,
                       KEY_READ | KEY_WRITE, &hkey) == ERROR_SUCCESS)
    {
        DWORD dwType, dwFlags, dwDataLength;

        dwDataLength = sizeof(DWORD);
        if(SHQueryValueEx(hkey, REG_VAL_COMP_FLAGS, NULL, &dwType, (LPBYTE)&dwFlags, &dwDataLength) != ERROR_SUCCESS)
        {
            dwFlags = 0;
        }        

        dwNewFlags = (dwFlags & ~dwMask) | (dwNewFlags & dwMask);

        if (RegSetValueEx(hkey, REG_VAL_COMP_FLAGS, 0, REG_DWORD, (LPBYTE)&dwNewFlags,
                          SIZEOF(DWORD)) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }

        SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);

        RegCloseKey(hkey);
    }
    else
    {
        TraceMsg(TF_WARNING, "DS: Unable to UpdateComponentFlags");
    }

    return fRet;
}

DWORD GetCurrentState(LPTSTR pszCompId)
{
    TCHAR szRegPath[MAX_PATH];
    DWORD cbSize, dwType, dwCurState;

    GetRegLocation(szRegPath, SIZECHARS(szRegPath), REG_DESKCOMP_COMPONENTS, NULL);
    lstrcat(szRegPath, TEXT("\\"));
    lstrcat(szRegPath, pszCompId);

    cbSize = sizeof(dwCurState);

    if (SHGetValue(HKEY_CURRENT_USER, szRegPath, REG_VAL_COMP_CURSTATE, &dwType, &dwCurState, &cbSize) != ERROR_SUCCESS)
        dwCurState = IS_NORMAL;

    return dwCurState;
}

BOOL GetSavedStateInfo(LPTSTR pszCompId, LPCOMPSTATEINFO    pCompState, BOOL  fRestoredState)
{
    BOOL fRet = FALSE;
    TCHAR szRegPath[MAX_PATH];
    HKEY hkey;
    LPTSTR  lpValName = (fRestoredState ? REG_VAL_COMP_RESTOREDSTATEINFO : REG_VAL_COMP_ORIGINALSTATEINFO);

    GetRegLocation(szRegPath, SIZECHARS(szRegPath), REG_DESKCOMP_COMPONENTS, NULL);
    lstrcat(szRegPath, TEXT("\\"));
    lstrcat(szRegPath, pszCompId);

    //No need to use RegCreateKeyEx here. Use RegOpenKeyEx instead.
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szRegPath, 0,
                       KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD   cbSize, dwType;
        
        cbSize = SIZEOF(*pCompState);
        dwType = REG_BINARY;
        
        if (SHQueryValueEx(hkey, lpValName, NULL, &dwType, (LPBYTE)pCompState, &cbSize) != ERROR_SUCCESS)
        {
            //If the item state is missing, read the item current position and
            // and return that as the saved state.
            COMPPOS cpPos;

            cbSize = SIZEOF(cpPos);
            dwType = REG_BINARY;
            if (SHQueryValueEx(hkey, REG_VAL_COMP_POSITION, NULL, &dwType, (LPBYTE)&cpPos, &cbSize) != ERROR_SUCCESS)
            {
                ZeroMemory(&cpPos, SIZEOF(cpPos));
            }            
            SetStateInfo(pCompState, &cpPos, IS_NORMAL);
        }

        RegCloseKey(hkey);
    }
    else
        TraceMsg(TF_WARNING, "DS: Unable to get SavedStateInfo()");

    return fRet;
 }


BOOL UpdateDesktopPosition(LPTSTR pszCompId, int iLeft, int iTop, DWORD dwWidth, DWORD dwHeight, int izIndex,
                            BOOL    fSaveRestorePos, BOOL fSaveOriginal, DWORD dwCurState)
{
    BOOL fRet = FALSE;
    TCHAR szRegPath[MAX_PATH];
    HKEY hkey;

    GetRegLocation(szRegPath, SIZECHARS(szRegPath), REG_DESKCOMP_COMPONENTS, NULL);
    lstrcat(szRegPath, TEXT("\\"));
    lstrcat(szRegPath, pszCompId);

    //Don't use RegCreateKeyEx here; It will result in a NULL component being added.
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szRegPath, 0,
                       KEY_READ | KEY_WRITE, &hkey) == ERROR_SUCCESS)
    {
        COMPPOS         cp;
        DWORD           dwType;
        DWORD           dwDataLength;
        COMPSTATEINFO   csi;

        dwType = REG_BINARY;
        dwDataLength = sizeof(COMPPOS);

        if(SHQueryValueEx(hkey, REG_VAL_COMP_POSITION, NULL, &dwType, (LPBYTE)&cp, &dwDataLength) != ERROR_SUCCESS)
        {
            cp.fCanResize = cp.fCanResizeX = cp.fCanResizeY = TRUE;
            cp.iPreferredLeftPercent = cp.iPreferredTopPercent = 0;
        }

        //Read the current State
        dwType = REG_DWORD;
        dwDataLength = SIZEOF(csi.dwItemState);
        if (SHQueryValueEx(hkey, REG_VAL_COMP_CURSTATE, NULL, &dwType, (LPBYTE)&csi.dwItemState, &dwDataLength) != ERROR_SUCCESS)
        {
            csi.dwItemState = IS_NORMAL;
        }

        if(fSaveRestorePos)
        {
            //We have just read the current position; Let's save it as the restore position.
            SetStateInfo(&csi, &cp, csi.dwItemState);

            //Now that we know the complete current state, save it as the restore state!
            RegSetValueEx(hkey, REG_VAL_COMP_RESTOREDSTATEINFO, 0, REG_BINARY, (LPBYTE)&csi, SIZEOF(csi));
        }

        //Save the current state too!
        if(dwCurState)
            RegSetValueEx(hkey, REG_VAL_COMP_CURSTATE, 0, REG_DWORD, (LPBYTE)&dwCurState, SIZEOF(dwCurState));
            
        cp.dwSize = sizeof(COMPPOS);
        cp.iLeft = iLeft;
        cp.iTop = iTop;
        cp.dwWidth = dwWidth;
        cp.dwHeight = dwHeight;
        cp.izIndex = izIndex;

        if (fSaveOriginal) {
            SetStateInfo(&csi, &cp, csi.dwItemState);
            RegSetValueEx(hkey, REG_VAL_COMP_ORIGINALSTATEINFO, 0, REG_BINARY, (LPBYTE)&csi, SIZEOF(csi));
        }

        if (RegSetValueEx(hkey, REG_VAL_COMP_POSITION, 0, REG_BINARY, (LPBYTE)&cp,
                          SIZEOF(cp)) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }

        // Don't need to mark as dirty if we're just saving the original pos
        if (!fSaveOriginal)
            SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);

        RegCloseKey(hkey);

    }
    else
    {
        TraceMsg(TF_WARNING, "DS: Unable to UpdateDesktopPosition");
    }

    return fRet;
}


HRESULT EnsureFilePathIsPresent(LPCTSTR pszFilePath)
//  Recursively process (in reverse) a path and create the first
//  directory that does not exist and when unwinding the calling
//  chain create each subsequent directory in the path until the
//  whole original path is created.
{
    HRESULT hr = E_INVALIDARG;

    if (pszFilePath && pszFilePath[0])
    {
        TCHAR   szDesktopFileDirectory[MAX_PATH];

        hr = S_OK;
        lstrcpy(szDesktopFileDirectory, pszFilePath);
        ASSERT(lstrlen(szDesktopFileDirectory) > lstrlen(TEXT("C:\\")));      // something wrong if the root directory is hit
        if ((PathRemoveFileSpec(szDesktopFileDirectory) != 0) && (GetFileAttributes(szDesktopFileDirectory) == 0xFFFFFFFF) && (CreateDirectory(szDesktopFileDirectory, NULL) == 0))
        {
            hr = EnsureFilePathIsPresent(szDesktopFileDirectory);
            TBOOL(CreateDirectory(szDesktopFileDirectory, NULL));
        }
    }

    return hr;
}


HRESULT GetPerUserFileName(LPTSTR pszOutputFileName, DWORD dwSize, LPTSTR pszPartialFileName)
{
    LPITEMIDLIST    pidlAppData;

    *pszOutputFileName = TEXT('\0');

    if(dwSize < MAX_PATH)
    {
        ASSERT(FALSE);
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidlAppData);
    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDList(pidlAppData, pszOutputFileName);
        PathAppend(pszOutputFileName, pszPartialFileName);
        ILFree(pidlAppData);

        hr = EnsureFilePathIsPresent(pszOutputFileName);
    }

    return hr;
}


void GetRegLocation(LPTSTR lpszResult, DWORD cchResult, LPCTSTR lpszKey, LPCTSTR lpszScheme)
{
    TCHAR szSubkey[MAX_PATH];
    DWORD dwDataLength = sizeof(szSubkey) - 2 * sizeof(TCHAR);
    DWORD dwType;

    lstrcpy(szSubkey, TEXT("\\"));

    //  use what was given or get it from the registry
    if (lpszScheme)
        StrCatBuff(szSubkey, lpszScheme, SIZECHARS(szSubkey));
    else
        SHGetValue(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME, REG_VAL_SCHEME_DISPLAY, &dwType,
            (LPBYTE)(szSubkey) + sizeof(TCHAR), &dwDataLength);

    if (szSubkey[1])
        StrCatBuff(szSubkey, TEXT("\\"), SIZECHARS(szSubkey));

    wnsprintf(lpszResult, cchResult, lpszKey, szSubkey);
}

BOOL ValidateFileName(HWND hwnd, LPCTSTR pszFilename, int iTypeString)
{
    BOOL fRet = TRUE;

    DWORD dwAttributes = GetFileAttributes(pszFilename);
    if ((dwAttributes != 0xFFFFFFFF) &&
        (dwAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN)))
    {
        TCHAR szType1[64];
        TCHAR szType2[64];

        LoadString(HINST_THISDLL, iTypeString, szType1, ARRAYSIZE(szType1));
        LoadString(HINST_THISDLL, iTypeString+1, szType2, ARRAYSIZE(szType2));
        if (ShellMessageBox(HINST_THISDLL, hwnd,
                            MAKEINTRESOURCE(IDS_VALIDFN_FMT),
                            MAKEINTRESOURCE(IDS_VALIDFN_TITLE),
                            MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2,
                            szType1, szType2) == IDNO)
        {
            fRet = FALSE;
        }
    }

    return fRet;
}

void GetWallpaperDirName(LPTSTR lpszWallPaperDir, int iBuffSize)
{
    TCHAR szExp[MAX_PATH];

    //Compute the default wallpaper name.
    if (GetWindowsDirectory(lpszWallPaperDir, iBuffSize) != 0)
    {
        lstrcat(lpszWallPaperDir, DESKTOPHTML_WEB_DIR);

        //Read it from the registry key, if it is set!
        DWORD dwType;
        DWORD cbData = (DWORD)iBuffSize;
        SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, c_szWallPaperDir, &dwType, (LPVOID)lpszWallPaperDir, &cbData);

        // Maybe we should check if it is REG_EXPAND_SZ, to save a few CPU cycle?
        SHExpandEnvironmentStrings(lpszWallPaperDir, szExp, ARRAYSIZE(szExp));
        lstrcpyn(lpszWallPaperDir, szExp, iBuffSize);
    }
}

BOOL CALLBACK MultiMonEnumAreaCallBack(HMONITOR hMonitor, HDC hdc, LPRECT lprc, LPARAM lData)
{
    EnumMonitorsArea* pEMA = (EnumMonitorsArea*)lData;
    
    if (pEMA->iMonitors > LV_MAX_WORKAREAS - 1)
    {
        //ignore the other monitors because we can only handle up to LV_MAX_WORKAREAS
        //REARCHITECT: should we dynamically allocate this?
        return FALSE;
    }
    GetMonitorRect(hMonitor, &pEMA->rcMonitor[pEMA->iMonitors]);
    GetMonitorWorkArea(hMonitor, &pEMA->rcWorkArea[pEMA->iMonitors]);
    if(pEMA->iMonitors == 0)
    {
        pEMA->rcVirtualMonitor.left = pEMA->rcMonitor[0].left;
        pEMA->rcVirtualMonitor.top = pEMA->rcMonitor[0].top;
        pEMA->rcVirtualMonitor.right = pEMA->rcMonitor[0].right;
        pEMA->rcVirtualMonitor.bottom = pEMA->rcMonitor[0].bottom;

        pEMA->rcVirtualWorkArea.left = pEMA->rcWorkArea[0].left;
        pEMA->rcVirtualWorkArea.top = pEMA->rcWorkArea[0].top;
        pEMA->rcVirtualWorkArea.right = pEMA->rcWorkArea[0].right;
        pEMA->rcVirtualWorkArea.bottom = pEMA->rcWorkArea[0].bottom;
    }
    else
    {
        if(pEMA->rcMonitor[pEMA->iMonitors].left < pEMA->rcVirtualMonitor.left)
        {
            pEMA->rcVirtualMonitor.left = pEMA->rcMonitor[pEMA->iMonitors].left;
        }
        if(pEMA->rcMonitor[pEMA->iMonitors].top < pEMA->rcVirtualMonitor.top)
        {
            pEMA->rcVirtualMonitor.top = pEMA->rcMonitor[pEMA->iMonitors].top;
        }
        if(pEMA->rcMonitor[pEMA->iMonitors].right > pEMA->rcVirtualMonitor.right)
        {
            pEMA->rcVirtualMonitor.right = pEMA->rcMonitor[pEMA->iMonitors].right;
        }
        if(pEMA->rcMonitor[pEMA->iMonitors].bottom > pEMA->rcVirtualMonitor.bottom)
        {
            pEMA->rcVirtualMonitor.bottom = pEMA->rcMonitor[pEMA->iMonitors].bottom;
        }

        if(pEMA->rcWorkArea[pEMA->iMonitors].left < pEMA->rcVirtualWorkArea.left)
        {
            pEMA->rcVirtualWorkArea.left = pEMA->rcWorkArea[pEMA->iMonitors].left;
        }
        if(pEMA->rcWorkArea[pEMA->iMonitors].top < pEMA->rcVirtualWorkArea.top)
        {
            pEMA->rcVirtualWorkArea.top = pEMA->rcWorkArea[pEMA->iMonitors].top;
        }
        if(pEMA->rcWorkArea[pEMA->iMonitors].right > pEMA->rcVirtualWorkArea.right)
        {
            pEMA->rcVirtualWorkArea.right = pEMA->rcWorkArea[pEMA->iMonitors].right;
        }
        if(pEMA->rcWorkArea[pEMA->iMonitors].bottom > pEMA->rcVirtualWorkArea.bottom)
        {
            pEMA->rcVirtualWorkArea.bottom = pEMA->rcWorkArea[pEMA->iMonitors].bottom;
        }
    }
    pEMA->iMonitors++;
    return TRUE;
}

void GetMonitorSettings(EnumMonitorsArea* ema)
{
    ema->iMonitors = 0;

    ema->rcVirtualMonitor.left = 0;
    ema->rcVirtualMonitor.top = 0;
    ema->rcVirtualMonitor.right = 0;
    ema->rcVirtualMonitor.bottom = 0;

    ema->rcVirtualWorkArea.left = 0;
    ema->rcVirtualWorkArea.top = 0;
    ema->rcVirtualWorkArea.right = 0;
    ema->rcVirtualWorkArea.bottom = 0;

    EnumDisplayMonitors(NULL, NULL, MultiMonEnumAreaCallBack, (LPARAM)ema);
}

int _GetWorkAreaIndexWorker(POINT pt, LPCRECT prect, int crect)
{
    int iIndex;

    for (iIndex = 0; iIndex < crect; iIndex++)
    {
        if (PtInRect(&prect[iIndex], pt))
        {
            return iIndex;
        }
    }

    return -1;
}

int GetWorkAreaIndexFromPoint(POINT pt, LPCRECT prect, int crect)
{
    ASSERT(crect);

    // Map to correct coords...
    pt.x += prect[0].left;
    pt.y += prect[0].top;

    return _GetWorkAreaIndexWorker(pt, prect, crect);
}

int GetWorkAreaIndex(COMPPOS *pcp, LPCRECT prect, int crect, LPPOINT lpptVirtualTopLeft)
{
    POINT ptComp;
    ptComp.x = pcp->iLeft + lpptVirtualTopLeft->x;
    ptComp.y = pcp->iTop + lpptVirtualTopLeft->y;

    return _GetWorkAreaIndexWorker(ptComp, prect, crect);
}

// Prepends the Web wallpaper directory or the system directory to szWallpaper, if necessary
// (i.e., if the path is not specified). The return value is in szWallpaperWithPath, which is iBufSize
// bytes long
void GetWallpaperWithPath(LPCTSTR szWallpaper, LPTSTR szWallpaperWithPath, int iBufSize)
{
    if (szWallpaper[0] && lstrcmpi(szWallpaper, g_szNone) != 0 && !StrChr(szWallpaper, TEXT('\\'))
            && !StrChr(szWallpaper, TEXT(':'))) // The file could be d:foo.bmp
    {
        // If the file is a normal wallpaper, we prepend the windows directory to the filename
        if (IsNormalWallpaper(szWallpaper))
        {
            GetWindowsDirectory(szWallpaperWithPath, iBufSize);
        }
        // else we prepend the wallpaper directory to the filename
        else
        {
            GetWallpaperDirName(szWallpaperWithPath, iBufSize);
        }
        PathAppend(szWallpaperWithPath, szWallpaper);
    }
    else
    {
        lstrcpyn(szWallpaperWithPath, szWallpaper, iBufSize);
    }
}

BOOL GetViewAreas(LPRECT lprcViewAreas, int* pnViewAreas)
{
    BOOL bRet = FALSE;
    HWND hwndDesktop = GetShellWindow();    // This is the "normal" desktop
    
    if (hwndDesktop && IsWindow(hwndDesktop))
    {
        DWORD dwProcID, dwCurrentProcID;
        
        GetWindowThreadProcessId(hwndDesktop, &dwProcID);
        dwCurrentProcID = GetCurrentProcessId();
        if (dwCurrentProcID == dwProcID) {
            SendMessage(hwndDesktop, DTM_GETVIEWAREAS, (WPARAM)pnViewAreas, (LPARAM)lprcViewAreas);
            if (*pnViewAreas <= 0)
            {
                bRet = FALSE;
            }
            else
            {
                bRet = TRUE;
            }
        }
        else
        {
            bRet = FALSE;
        }
    }
    return bRet;
}

// We need to enforce a minimum size for the deskmovr caption since it doesn't look
// right drawn any smaller
int GetcyCaption()
{
    int cyCaption = GetSystemMetrics(SM_CYSMCAPTION);

    if (cyCaption < 15)
        cyCaption = 15;

    cyCaption -= GetSystemMetrics(SM_CYBORDER);

    return cyCaption;
}



void PathUnExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize)
{
    TCHAR szTemp[MAX_PATH];

    StrCpyN(szTemp, pszString, ARRAYSIZE(szTemp));
    if (!PathUnExpandEnvStrings(szTemp, pszString, cchSize))
    {
        StrCpyN(pszString, szTemp, cchSize);
    }
}



void PathExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize)
{
    TCHAR szTemp[MAX_PATH];

    StrCpyN(szTemp, pszString, ARRAYSIZE(szTemp));
    if (0 == SHExpandEnvironmentStrings(szTemp, pszString, cchSize))
    {
        StrCpyN(pszString, szTemp, cchSize);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\msstkppg.h ===
//=--------------------------------------------------------------------------=
// MSStkPPg.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for msprop32's property pages.
//
#ifndef _MS_STOCK_PROP_PAGES_H_

// {7EBDAAE0-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockFontPage, 0x7ebdaae0, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE1-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockColorPage, 0x7ebdaae1, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE2-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockPicturePage, 0x7ebdaae2, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

#define _MS_STOCK_PROP_PAGES_H_
#endif // _MS_STOCK_PROP_PAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\hnfblock.h ===
#ifndef HNFBLOCK_H_
#define HNFBLOCK_H_

#include <iethread.h>

DECLARE_HANDLE(HNFBLOCK);

HNFBLOCK ConvertNFItoHNFBLOCK(IETHREADPARAM* pInfo, LPCTSTR pszPath, DWORD dwProcId);
IETHREADPARAM *ConvertHNFBLOCKtoNFI(HNFBLOCK hBlock);
BOOL DesktopOnCommandLine(HNFBLOCK hnf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\fldoppsx.cpp ===
//
// fldoppsx - Folder Options Property Sheet Extension
//

#include "stdafx.h"
#pragma hdrstop

CFolderOptionsPsx::CFolderOptionsPsx() : m_cRef(1)
{
    DllAddRef();
}

CFolderOptionsPsx::~CFolderOptionsPsx()
{
    ATOMICRELEASE(m_pbs2);
    ATOMICRELEASE(m_pgfs);
    DllRelease();
}

ULONG CFolderOptionsPsx::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CFolderOptionsPsx::Release()
{
    ULONG ulResult = InterlockedDecrement(&m_cRef);

    if (ulResult == 0) {
        delete this;
    }

    return ulResult;
}

HRESULT CFolderOptionsPsx::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFolderOptionsPsx, IShellPropSheetExt),
        QITABENT(CFolderOptionsPsx, IShellExtInit),
        QITABENT(CFolderOptionsPsx, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

UINT CALLBACK CFolderOptionsPsx::PropCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    CFolderOptionsPsx *pfolder = (CFolderOptionsPsx *)ppsp->lParam;

    switch (uMsg)
    {
    case PSPCB_RELEASE:
        pfolder->Release();
        break;
    }

    return TRUE;
}



//
//  We add two pages.
//
//  1. "General"    - options.cpp
//  2. "View"       - advanced.cpp
//
//  The rule for IShellPropSheetExt is that AddPages can be called
//  only once, so we don't have to worry about a second call accidentally
//  screwing up our IBrowserService pointer.
//
//
HRESULT CFolderOptionsPsx::AddPages(LPFNADDPROPSHEETPAGE AddPage, LPARAM lParam)
{
    if (!m_pgfs)
    {
        HRESULT hres = CoCreateInstance(CLSID_GlobalFolderSettings, NULL, CLSCTX_INPROC_SERVER, 
            IID_IGlobalFolderSettings, (void **)&m_pgfs);
        if (FAILED(hres))
            return hres;
    }

    /*
     *  We can limp along without an IBrowserService.  It means that
     *  we are only modifying global settings, not per-folder settings.
     */

    if (!m_pbs2) 
    {
        IUnknown_QueryService(_punkSite, SID_SShellBrowser,
                              IID_IBrowserService2, (void **)&m_pbs2);
    }

    PROPSHEETPAGE psp;

    /*
     *  We used to do this only if we aren't a rooted Explorer,
     *  but TOuzts says to do it always.
     *
     *  The lParam is a pointer back to ourselves so the page
     *  can figure out why it was created and so the two pages
     *  can talk to each other.
     */
    psp.dwSize = SIZEOF(psp);
    psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
    psp.hInstance = HINST_THISDLL;
    psp.pfnCallback = CFolderOptionsPsx::PropCallback;
    psp.lParam = (LPARAM)this;


    // "General" page.
    psp.pszTemplate = MAKEINTRESOURCE(IDD_FOLDEROPTIONS);
    psp.pfnDlgProc = FolderOptionsDlgProc;
    HPROPSHEETPAGE hpage = CreatePropertySheetPage(&psp);
    if (hpage)
    {
        AddRef();
        if (!AddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            Release();
        }
    }

    // "View" page.
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADVANCEDOPTIONS);
    psp.pfnDlgProc = AdvancedOptionsDlgProc;

    hpage = CreatePropertySheetPage(&psp);
    if (hpage)
    {
        AddRef();
        if (!AddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            Release();
        }
    }

    return S_OK;
}

HRESULT CFolderOptionsPsx::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    return S_OK;
}

HRESULT CFolderOptionsPsx::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    return S_OK;
}

STDAPI CFolderOptionsPsx_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    CFolderOptionsPsx *pfopt = new CFolderOptionsPsx();
    if (pfopt) 
    {
        HRESULT hres = pfopt->QueryInterface(riid, ppvOut);
        pfopt->Release();
        return hres;
    }

    *ppvOut = NULL;
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\dvutil.cpp ===
// Functions stolen from shdocvw\util.cpp

#include "stdafx.h"
#pragma hdrstop
#include "dsubscri.h"


//+-----------------------------------------------------------------
//
// Helper function for getting the TopLeft point of an element from
//      mshtml.dll, and have the point reported in inside relative
//      coordinates (inside margins, borders and padding.)
//-----------------------------------------------------------------
HRESULT CSSOM_TopLeft(IHTMLElement * pIElem, POINT * ppt) 
{
    HRESULT       hr = E_FAIL;
    IHTMLStyle    *pistyle;

    if (SUCCEEDED(pIElem->get_style(&pistyle)) && pistyle) {
        VARIANT var = {0};

        if (SUCCEEDED(pistyle->get_top(&var)) && var.bstrVal) {
            ppt->y = StrToIntW(var.bstrVal);
            VariantClear(&var);

            if (SUCCEEDED(pistyle->get_left(&var)) && var.bstrVal) {
                ppt->x = StrToIntW(var.bstrVal);
                VariantClear(&var);
                hr = S_OK;
            }
        }

        pistyle->Release();
    }

    return hr;
}

HRESULT GetHTMLElementStrMember(IHTMLElement *pielem, LPTSTR pszName, DWORD cchSize, BSTR bstrMember)
{
    HRESULT hr;
    VARIANT var = {0};

    if (!pielem)
        hr = E_INVALIDARG;
    else if (SUCCEEDED(hr = pielem->getAttribute(bstrMember, TRUE, &var)))
    {
        if ((VT_BSTR == var.vt) && (var.bstrVal))
        {
#ifdef UNICODE          
            StrCpyNW(pszName, (LPCWSTR)var.bstrVal, cchSize);
#else // UNICODE
            SHUnicodeToAnsi((BSTR)var.bstrVal, pszName, cchSize);
#endif // UNICODE
        }
        else
            hr = E_FAIL; // Try VariantChangeType?????

        VariantClear(&var);
    }

    return hr;
}

/******************************************************************\
    FUNCTION: IElemCheckForExistingSubscription()

    RETURN VALUE:
    S_OK    - if the IHTMLElement points to a TAG that has a "subscribed_url" property
              that is subscribed. 
    S_FALSE - if the IHTMLElement points to a TAG that has a
              "subscribed_url" property but the URL is not subscribed.
    E_FAIL  - if the IHTMLElement points to a TAG that does not
              have a  "subscribed_url" property.
\******************************************************************/
HRESULT IElemCheckForExistingSubscription(IHTMLElement *pielem)
{
    HRESULT hr = E_FAIL;
    TCHAR szHTMLElementName[MAX_URL_STRING];

    if (!pielem)
        return E_INVALIDARG;

    if (SUCCEEDED(GetHTMLElementStrMember(pielem, szHTMLElementName, SIZECHARS(szHTMLElementName), (BSTR)(s_sstrSubSRCMember.wsz))))
        hr = (CheckForExistingSubscription(szHTMLElementName) ? S_OK : S_FALSE);

    return hr;
}

HRESULT IElemCloseDesktopComp(IHTMLElement *pielem)
{
    HRESULT hr = E_INVALIDARG;
    TCHAR szHTMLElementID[MAX_URL_STRING];

    ASSERT(pielem);
    if (pielem &&
        SUCCEEDED(hr = GetHTMLElementStrMember(pielem, szHTMLElementID, SIZECHARS(szHTMLElementID), (BSTR)(s_sstrIDMember.wsz))))
    {
        hr = UpdateComponentFlags(szHTMLElementID, COMP_CHECKED | COMP_UNCHECKED, COMP_UNCHECKED) ? S_OK : E_FAIL;
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            //
            // This IElemCloseDesktopComp() is called from DeskMovr code when a component is
            // closed. If this component is the only active desktop component, then calling
            // REFRESHACTIVEDESKTOP() here will result in ActiveDesktop being turned off.
            // This will free the DeskMovr, which is an ActiveX control on the desktop web page.
            // So, when IElemCloseDesktopComp() returns to the caller, the DeskMovr code continues
            // to execute; but the object had been freed and hence a fault occurs soon.
            // The fix for this problem is to avoid refreshing the active desktop until a better
            // time. So, we post a private message to the desktop window. When that window receives
            // this message, we call REFRESHACTIVEDESKTOP().
            
            PostMessage(GetShellWindow(), DTM_REFRESHACTIVEDESKTOP, (WPARAM)0, (LPARAM)0);
        }
    }

    return hr;
}

HRESULT IElemGetSubscriptionsDialog(IHTMLElement *pielem, HWND hwnd)
{
    HRESULT hr;
    TCHAR szHTMLElementName[MAX_URL_STRING];

    ASSERT(pielem);
    if (SUCCEEDED(hr = GetHTMLElementStrMember(pielem, szHTMLElementName, SIZECHARS(szHTMLElementName), (BSTR)(s_sstrSubSRCMember.wsz))))
    {
        ASSERT(CheckForExistingSubscription(szHTMLElementName)); // We should not have gotten this far.
        hr = ShowSubscriptionProperties(szHTMLElementName, hwnd);
    }

    return hr;
}

HRESULT IElemSubscribeDialog(IHTMLElement *pielem, HWND hwnd)
{
    HRESULT hr;
    TCHAR szHTMLElementName[MAX_URL_STRING];

    ASSERT(pielem);
    hr = GetHTMLElementStrMember(pielem, szHTMLElementName, SIZECHARS(szHTMLElementName), (BSTR)(s_sstrSubSRCMember.wsz));
    if (SUCCEEDED(hr))
    {
        ASSERT(!CheckForExistingSubscription(szHTMLElementName)); // We should not have gotten this far.
        hr = CreateSubscriptionsWizard(SUBSTYPE_DESKTOPURL, szHTMLElementName, NULL, hwnd);
    }

    return hr;
}

HRESULT IElemUnsubscribe(IHTMLElement *pielem)
{
    HRESULT hr;
    TCHAR szHTMLElementName[MAX_URL_STRING];

    ASSERT(pielem);
    hr = GetHTMLElementStrMember(pielem, szHTMLElementName, SIZECHARS(szHTMLElementName), (BSTR)(s_sstrSubSRCMember.wsz));
    if (SUCCEEDED(hr))
    {
        ASSERT(CheckForExistingSubscription(szHTMLElementName)); // We should not have gotten this far.
        hr = DeleteFromSubscriptionList(szHTMLElementName) ? S_OK : S_FALSE;
    }

    return hr;
}

HRESULT IElemUpdate(IHTMLElement *pielem)
{
    HRESULT hr;
    TCHAR szHTMLElementName[MAX_URL_STRING];

    ASSERT(pielem);
    hr = GetHTMLElementStrMember(pielem, szHTMLElementName, SIZECHARS(szHTMLElementName), (BSTR)(s_sstrSubSRCMember.wsz));
    if (SUCCEEDED(hr))
    {
        ASSERT(CheckForExistingSubscription(szHTMLElementName)); // We should not have gotten this far.
        hr = UpdateSubscription(szHTMLElementName) ? S_OK : S_FALSE;
    }

    return hr;
}

HRESULT IElemOpenInNewWindow(IHTMLElement *pielem, IOleClientSite *piOCSite, BOOL fShowFrame, LONG width, LONG height)
{
    HRESULT hr;
    TCHAR szTemp[MAX_URL_STRING];
    BSTR bstrURL;

    ASSERT(pielem);

    hr = GetHTMLElementStrMember(pielem, szTemp, SIZECHARS(szTemp), (BSTR)(s_sstrSubSRCMember.wsz));

    if (SUCCEEDED(hr) && (bstrURL = SysAllocStringT(szTemp)))
    {
        IHTMLWindow2 *pihtmlWindow2, *pihtmlWindow2New = NULL;
        BSTR bstrFeatures = 0;

        if (!fShowFrame)
        {
            wnsprintf(szTemp, ARRAYSIZE(szTemp), TEXT("height=%li, width=%li, status=no, toolbar=no, menubar=no, location=no, resizable=no"), height, width);
            bstrFeatures = SysAllocString((OLECHAR FAR *)szTemp);
        }

        hr = IUnknown_QueryService(piOCSite, SID_SHTMLWindow, IID_IHTMLWindow2, (LPVOID*)&pihtmlWindow2);

        if (SUCCEEDED(hr) && pihtmlWindow2)
        {
            pihtmlWindow2->open(bstrURL, NULL, bstrFeatures, NULL, &pihtmlWindow2New);
            pihtmlWindow2->Release();
            ATOMICRELEASE(pihtmlWindow2New);
        }

        SysFreeString(bstrURL);
        if (bstrFeatures)
            SysFreeString(bstrFeatures);
    }

    return hr;
}

HRESULT ShowSubscriptionProperties(LPCTSTR pszUrl, HWND hwnd)
{
    HRESULT hr;
    ISubscriptionMgr *psm;

    if (SUCCEEDED(hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                          CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr,
                          (void**)&psm)))
    {
        WCHAR wszUrl[MAX_URL_STRING];

        SHTCharToUnicode(pszUrl, wszUrl, ARRAYSIZE(wszUrl));

        hr = psm->ShowSubscriptionProperties(wszUrl, hwnd);
        psm->Release();
    }

    return hr;
}

HRESULT CreateSubscriptionsWizard(SUBSCRIPTIONTYPE subType, LPCTSTR pszUrl, SUBSCRIPTIONINFO *pInfo, HWND hwnd)
{
    HRESULT hr;
    ISubscriptionMgr *psm;

    if (SUCCEEDED(hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                          CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr,
                          (void**)&psm)))
    {
        WCHAR wzURL[MAX_URL_STRING];
        LPCWSTR pwzURL = wzURL;

#ifndef UNICODE
        SHAnsiToUnicode(pszUrl, wzURL, ARRAYSIZE(wzURL));
#else // UNICODE
        pwzURL = pszUrl;
#endif // UNICODE

        hr = psm->CreateSubscription(hwnd, pwzURL, pwzURL, CREATESUBS_ADDTOFAVORITES, subType, pInfo);
        psm->UpdateSubscription(pwzURL);
        psm->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\libx.cpp ===
//***   libx.cpp -- 'source library' inclusions
// DESCRIPTION
//  there are some things that we share in source (rather than .obj or .dll)
// form.  this file builds them in the current directory.

#include "stdafx.h"
#pragma hdrstop

#include "..\inc\uassist.cpp"       // 'safe' thunks and cache

#ifdef DEBUG
//#define TF_QISTUB ... see shellprv.h ...
#include "..\inc\qistub.cpp"
#include "..\inc\dbutil.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\local.h ===
//
// Local private header file

#include "deskhtm.h"
#include <regstr.h>
#include "resource.h"
#include "shdocvw.h"

#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH


// Use our private version of the OLE task allocator so we don't pull
// in all of OLE32 just to do LocalAlloc and LocalFree!

#ifndef DEBUG
#define CoTaskMemFree       SHFree
#define CoTaskMemAlloc      SHAlloc
#define CoTaskMemRealloc    SHRealloc
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\mimeflt.cpp ===
// CLSID_CWebViewMimeFilter
//
// Mime filter for Web View (.htt) content. Does substitutions on:
//
//   %TEMPLATEDIR%
//   %THISDIRPATH%
//   %THISDIRNAME%
//

#include "stdafx.h"
#pragma hdrstop

#define MAX_VARIABLE_NAME_SIZE 15 // see _Expand

// urlmon uses a 2K buffer size, so match that in retail. To force
// extra iterations and reallocations, use a smaller buffer size
// in debug. To further save on reallocations, we don't read the
// entire buffer to leave room for growth.
#ifdef DEBUG
#define BUFFER_SIZE 512
#define BUFFER_ALLOC_SIZE BUFFER_SIZE
#else
#define BUFFER_SIZE 0x2000
#define BUFFER_ALLOC_SIZE (BUFFER_SIZE+2*MAX_PATH)
#endif
#define BUFFER_SIZE_INC MAX_VARIABLE_NAME_SIZE*2 // must be > MAX_VARIABLE_NAME_SIZE

#define TF_EXPAND 0 // show strings as they are expanded in our mime filter?

#define MAX_HTML_ESCAPE_SEQUENCE 8  // longest string representation of a 16 bit integer is 65535.  So, entire composite escape string has:
                                    // 2 for "&#" + maximum of 5 digits + 1 for ";" = 8 characters


class CWebViewMimeFilter : public IInternetProtocol
                         , public IInternetProtocolSink
                         , public IServiceProvider
{
public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IInternetProtocol methods
    STDMETHOD(Start)(
            LPCWSTR szUrl,
            IInternetProtocolSink *pProtSink,
            IInternetBindInfo *pOIBindInfo,
            DWORD grfSTI,
            HANDLE_PTR dwReserved);
    STDMETHOD(Continue)(PROTOCOLDATA *pStateInfo);
    STDMETHOD(Abort)(HRESULT hrReason,DWORD dwOptions);
    STDMETHOD(Terminate)(DWORD dwOptions);
    STDMETHOD(Suspend)();
    STDMETHOD(Resume)();
    STDMETHOD(Read)(void *pv,ULONG cb,ULONG *pcbRead);
    STDMETHOD(Seek)(
            LARGE_INTEGER dlibMove,
            DWORD dwOrigin,
            ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(LockRequest)(DWORD dwOptions);
    STDMETHOD(UnlockRequest)();

    // IInternetProtocolSink methods
    STDMETHOD(Switch)(PROTOCOLDATA * pProtocolData);
    STDMETHOD(ReportProgress)(ULONG ulStatusCode, LPCWSTR pwszStatusText);
    STDMETHOD(ReportData)(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax);
    STDMETHOD(ReportResult)(HRESULT hrResult, DWORD dwError, LPCWSTR pwszResult);

    // IServiceProvider methods
    STDMETHOD(QueryService)(REFGUID rsid, REFIID riid, void ** ppvObj);

private:
    CWebViewMimeFilter();
    ~CWebViewMimeFilter();
    friend HRESULT CWebViewMimeFilter_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut);

    int    _StrCmp(LPBYTE pSrc, LPCSTR pAnsi, LPWSTR pUnicode);
    LPBYTE _StrChr(LPBYTE pSrc, char chA, WCHAR chW);
    int    _StrLen(LPBYTE pStr);

    void _QueryForDVCMDID(int dvcmdid, LPBYTE pDst, int cbDst);
    void _EncodeHtml(LPBYTE psz, size_t cbByte);
    HRESULT _IncreaseBuffer(ULONG cbIncrement, LPBYTE * pp1, LPBYTE * pp2);
    int _Expand(LPBYTE pszVar, LPBYTE * ppszExp);
    HRESULT _ReadAndExpandBuffer();

    int _cRef;

    LPBYTE _pBuf;       // our buffer
    ULONG _cbBufSize;   // size of the buffer
    ULONG _nCharSize;   // sizeof(char) or sizeof(WCHAR) depending on data type
    ULONG _cbBuf;       // count of bytes read into the buffer
    ULONG _cbSeek;      // offset to seek position
    BYTE  _szTemplateDirPath[2*MAX_PATH];
    BYTE  _szThisDirPath[MAX_HTML_ESCAPE_SEQUENCE*MAX_PATH];
    BYTE  _szThisDirName[MAX_HTML_ESCAPE_SEQUENCE*MAX_PATH];
    BYTE  _szExpansion[2*MAX_PATH];

    IInternetProtocol*         _pProt;             // incoming
    IInternetProtocolSink*     _pProtSink;         // outgoing
};

CWebViewMimeFilter::CWebViewMimeFilter()
{
    _cRef = 1;
}

CWebViewMimeFilter::~CWebViewMimeFilter()
{
    ATOMICRELEASE(_pProt);

    if (_pBuf)
    {
        LocalFree(_pBuf);
        _pBuf = NULL;
        _cbBufSize = 0;
    }

    ASSERT(NULL == _pProtSink);
}

HRESULT CWebViewMimeFilter_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    // aggregation checking is handled in class factory

    HRESULT hres;
    CWebViewMimeFilter* pObj;

    pObj = new CWebViewMimeFilter();
    if (pObj)
    {
        hres = pObj->QueryInterface(riid, ppvOut);
        pObj->Release();
    }
    else
    {
        *ppvOut = NULL;
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

ULONG CWebViewMimeFilter::AddRef(void)
{
    _cRef++;
    return _cRef;
}


ULONG CWebViewMimeFilter::Release(void)
{
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;

    return 0;
}

HRESULT CWebViewMimeFilter::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CWebViewMimeFilter, IInternetProtocol),
        QITABENTMULTI(CWebViewMimeFilter, IInternetProtocolRoot, IInternetProtocol),
        QITABENT(CWebViewMimeFilter, IInternetProtocolSink),
        QITABENT(CWebViewMimeFilter, IServiceProvider),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

// IInternetProtocol methods
HRESULT CWebViewMimeFilter::Start(
        LPCWSTR szUrl,
        IInternetProtocolSink *pProtSink,
        IInternetBindInfo *pOIBindInfo,
        DWORD grfSTI,
        HANDLE_PTR dwReserved)
{
    HRESULT hr;

    if (!(EVAL(grfSTI & PI_FILTER_MODE)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // get the Prot pointer here
        PROTOCOLFILTERDATA* FiltData = (PROTOCOLFILTERDATA*) dwReserved;
        ASSERT(NULL == _pProt);
        _pProt = FiltData->pProtocol;
        _pProt->AddRef();

        // hold onto the sink as well
        ASSERT(NULL == _pProtSink);
        _pProtSink = pProtSink;
        _pProtSink->AddRef();

        // this filter converts text/webviewhtml to text/html
        _pProtSink->ReportProgress(BINDSTATUS_FILTERREPORTMIMETYPE, L"text/html");

        hr = S_OK;
    }

    return hr;
}
HRESULT CWebViewMimeFilter::Continue(PROTOCOLDATA *pStateInfo)
{
    ASSERT(_pProt);
    return _pProt->Continue(pStateInfo);
}
HRESULT CWebViewMimeFilter::Abort(HRESULT hrReason,DWORD dwOptions)
{
    ATOMICRELEASE(_pProtSink); // probably to remove ref cycle

    ASSERT(_pProt);
    return _pProt->Abort(hrReason, dwOptions);
}
HRESULT CWebViewMimeFilter::Terminate(DWORD dwOptions)
{
    ATOMICRELEASE(_pProtSink); // probably to remove ref cycle

    return _pProt->Terminate(dwOptions);
}
HRESULT CWebViewMimeFilter::Suspend()
{
    return _pProt->Suspend();
}
HRESULT CWebViewMimeFilter::Resume()
{
    return _pProt->Resume();
}

int CWebViewMimeFilter::_StrCmp(LPBYTE pSrc, LPCSTR pAnsi, LPWSTR pUnicode)
{
    if (SIZEOF(char) == _nCharSize)
    {
        return lstrcmpA(pAnsi, (LPSTR)pSrc);
    }
    else
    {
        ASSERT(_nCharSize == SIZEOF(WCHAR));

        return StrCmpW(pUnicode, (LPWSTR)pSrc);
    }
}

LPBYTE CWebViewMimeFilter::_StrChr(LPBYTE pSrc, char chA, WCHAR chW)
{
    if (SIZEOF(char) == _nCharSize)
    {
        return (LPBYTE)StrChrA((LPSTR)pSrc, chA);
    }
    else
    {
        return (LPBYTE)StrChrW((LPWSTR)pSrc, chW);
    }
}

int CWebViewMimeFilter::_StrLen(LPBYTE pStr)
{
    if (SIZEOF(char) == _nCharSize)
    {
        return lstrlenA((LPSTR)pStr);
    }
    else
    {
        return lstrlenW((LPWSTR)pStr);
    }
}

/*
 * UnicodeToHTMLEscapeStringAnsi
 *
 * Takes a unicode string as the input source and translates it into an ansi string that mshtml can process.  Characters > 127 will be
 * translated into an html escape sequence that has the following syntax:  "&#xxxxx;" where xxxxx is the string representation of the decimal
 * integer which is the value for the unicode character.  In this manner we are able to generate HTML text which represent UNICODE characters.
 */
void UnicodeToHTMLEscapeStringAnsi(LPWSTR pstrSrc, LPSTR pstrDest, int cbDest)
{
    while (*pstrSrc && (cbDest > MAX_HTML_ESCAPE_SEQUENCE))
    {
        int iLen;
        ULONG ul = MAKELONG(*pstrSrc, 0);

        // We can optimize the common ansi characters to avoid generating the long escape sequence.  This allows us to fit
        // longer paths in the buffer.
        if (ul < 128)
        {
            *pstrDest = (CHAR)*pstrSrc;
            iLen = 1;
        }
        else
        {
            iLen = wsprintfA(pstrDest, "&#%lu;", ul);
        }
        pstrDest += iLen;
        cbDest -= iLen;
        pstrSrc++;
    }
    *pstrDest = 0;
}

void CWebViewMimeFilter::_QueryForDVCMDID(int dvcmdid, LPBYTE pDst, int cbDst)
{
    IOleCommandTarget * pct;
    if (SUCCEEDED(QueryService(SID_DefView, IID_IOleCommandTarget, (LPVOID*)&pct)))
    {
        VARIANT v = {0};

        if (S_OK == pct->Exec(&CGID_DefView, dvcmdid, 0, NULL, &v))
        {
            if (v.vt == VT_BSTR)
            {
                if (SIZEOF(char) == _nCharSize)
                {
                    UnicodeToHTMLEscapeStringAnsi(v.bstrVal, (LPSTR)pDst, cbDst);
                }
                else
                {
                    ASSERT(_nCharSize == SIZEOF(WCHAR));
            
                    StrCpyNW((LPWSTR)pDst, v.bstrVal, cbDst/sizeof(WCHAR));
                }
            }

            VariantClear(&v);
        }
        pct->Release();
    }
}

void ConvertTCharToBytes(LPCTSTR psz, UINT nCharSize, LPBYTE pBuf, int nBytes)
{
    if (SIZEOF(char) == nCharSize)
    {
        SHTCharToAnsi(psz, (LPSTR)pBuf, nBytes/nCharSize);
    }
    else
    {
        ASSERT(nCharSize == SIZEOF(WCHAR));
        SHTCharToUnicode(psz, (LPWSTR)pBuf, nBytes/nCharSize);
    }
}

void GetMachineTemplateDir(LPBYTE pszTemplateDirPath, int nBytes, UINT nCharSize)
{
    TCHAR szTemplateDir[MAX_PATH];
    szTemplateDir[0] = TEXT('\0');
    SHGetWebFolderFilePath(TEXT(""), szTemplateDir, ARRAYSIZE(szTemplateDir));
    // Remove the trailing back slash, if any
    int len = lstrlen(szTemplateDir);
    if ((len > 0) && (szTemplateDir[len - 1] == TEXT('\\')))
    {
        szTemplateDir[len - 1] = TEXT('\0');
    }

    ConvertTCharToBytes(szTemplateDir, nCharSize, pszTemplateDirPath, nBytes);
}

#define REG_WEBVIEW_TEMPLATE_MACROS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\WebView\\TemplateMacros")

void ConvertBytesToTChar(LPCBYTE pBuf, UINT nCharSize, LPTSTR psz, int cch)
{
    if (SIZEOF(char) == nCharSize)
    {
        SHAnsiToTChar((LPCSTR)pBuf, psz, cch);
    }
    else
    {
        ASSERT(nCharSize == SIZEOF(WCHAR));
        SHUnicodeToTChar((LPCWSTR)pBuf, psz, cch);
    }
}

void ExpandMacro(LPBYTE pszMacro, LPBYTE pszExpansion, int nBytes, UINT nCharSize)
{
    TCHAR szExpansion[MAX_PATH];
    szExpansion[0] = TEXT('\0');
    
    TCHAR szTCharMacro[MAX_PATH];
    ConvertBytesToTChar(pszMacro, nCharSize, szTCharMacro, ARRAYSIZE(szTCharMacro));
    
    TCHAR szKey[MAX_PATH];
    lstrcpyn(szKey, REG_WEBVIEW_TEMPLATE_MACROS, ARRAYSIZE(szKey));
    StrCatBuff(szKey, TEXT("\\"), ARRAYSIZE(szKey));
    StrCatBuff(szKey, szTCharMacro, ARRAYSIZE(szKey));

    HKEY hkMacros;
    if (RegOpenKey(HKEY_CURRENT_USER, szKey, &hkMacros) == ERROR_SUCCESS
            || RegOpenKey(HKEY_LOCAL_MACHINE, szKey, &hkMacros) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD cbData = SIZEOF(szExpansion);
        SHQueryValueEx(hkMacros, NULL, NULL, &dwType, (LPBYTE)szExpansion, &cbData);
        RegCloseKey(hkMacros);
    }
    ConvertTCharToBytes(szExpansion, nCharSize, pszExpansion, nBytes);
}

// Replace the first character of pszDst with the string pszIns.
//
HRESULT StringCchReplaceFirstCharWithStringA(LPSTR psz, size_t cch, LPCSTR pszIns)
{
    HRESULT hr;

    size_t cchIns = lstrlenA(pszIns);

    if (cchIns  < cch )
    {
        MoveMemory(psz + cchIns, psz + 1, cch - cchIns);
        *(psz + cch - 1) = '\0';
        MoveMemory(psz, pszIns, cchIns);
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    return hr;
}

HRESULT StringCchReplaceFirstCharWithStringW(LPWSTR psz, size_t cch, LPCWSTR pszIns)
{
    HRESULT hr;

    size_t cchIns = lstrlenW(pszIns);

    if (cchIns  < cch)
    {
        MoveMemory(psz + cchIns, psz + 1, (cch - cchIns) * sizeof(WCHAR));
        *(psz + cch - 1) = L'\0';
        MoveMemory(psz, pszIns, cchIns * sizeof(WCHAR));
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    return hr;
}

void CWebViewMimeFilter::_EncodeHtml(LPBYTE psz, size_t cb)
{
    HRESULT hr;
    size_t  length;

    if (SIZEOF(char) == _nCharSize)
    {
        while (*psz)
        {
            switch (*psz)
            {
            case '<':
                hr = StringCchReplaceFirstCharWithStringA((LPSTR)psz, cb, "&lt");
                length = 3;
                break;

            case '>':
                hr = StringCchReplaceFirstCharWithStringA((LPSTR)psz, cb, "&gt");
                length = 3;
                break;

            case '"':
                hr = StringCchReplaceFirstCharWithStringA((LPSTR)psz, cb, "&quot");
                length = 5;
                break;

            default:
                hr = S_OK;
                length = 1;
                break;
            }

            if (SUCCEEDED(hr))
            {
                psz += length;
                cb  -= length;
            }
            else
            {
                *psz = '\0';
            }
        }
    }
    else
    {
        ASSERT(sizeof(WCHAR) == _nCharSize);

        WCHAR* pszW = (WCHAR*)psz;
        size_t cchW = cb / sizeof(WCHAR);

        while (*pszW)
        {
            switch (*pszW)
            {
            case L'<':
                hr = StringCchReplaceFirstCharWithStringW(pszW, cchW, L"&lt");
                length = 3;
                break;

            case L'>':
                hr = StringCchReplaceFirstCharWithStringW(pszW, cchW, L"&gt");
                length = 3;
                break;

            case L'"':
                hr = StringCchReplaceFirstCharWithStringW(pszW, cchW, L"&quot");
                length = 5;
                break;

            default:
                hr = S_OK;
                length = 1;
                break;
            }

            if (SUCCEEDED(hr))
            {
                pszW += length;
                cchW -= length;
            }
            else
            {
                *pszW = L'\0';
            }
        }
    }
}

int CWebViewMimeFilter::_Expand(LPBYTE pszVar, LPBYTE * ppszExp)
{
    if (!_StrCmp(pszVar, "TEMPLATEDIR", L"TEMPLATEDIR"))
    {
        if (!_szTemplateDirPath[0])
        {
            GetMachineTemplateDir(_szTemplateDirPath, SIZEOF(_szTemplateDirPath), _nCharSize);
            _EncodeHtml(_szTemplateDirPath, SIZEOF(_szTemplateDirPath));
        }
        *ppszExp = _szTemplateDirPath;
    }
    else if (!_StrCmp(pszVar, "THISDIRPATH", L"THISDIRPATH"))
    {
        if (!_szThisDirPath[0])
        {
            _QueryForDVCMDID(DVCMDID_GETTHISDIRPATH, _szThisDirPath, SIZEOF(_szThisDirPath));
            _EncodeHtml(_szThisDirPath, SIZEOF(_szThisDirPath));
        }
        *ppszExp = _szThisDirPath;
    }
    else if (!_StrCmp(pszVar, "THISDIRNAME", L"THISDIRNAME"))
    {
        if (!_szThisDirName[0])
        {
            _QueryForDVCMDID(DVCMDID_GETTHISDIRNAME, _szThisDirName, SIZEOF(_szThisDirName));
            _EncodeHtml(_szThisDirName, SIZEOF(_szThisDirName));
        }
        *ppszExp = _szThisDirName;
    }
    else
    {
        ExpandMacro(pszVar, _szExpansion, SIZEOF(_szExpansion), _nCharSize);
        _EncodeHtml(_szExpansion, SIZEOF(_szExpansion));
        *ppszExp = _szExpansion;
    }

    return _StrLen(*ppszExp);
}

//
//  Ensure room for at least cbIncrement more bytes at the end of the buffer.
//  If the memory gets moved or realloced, *pp1 and *pp2 are adjusted to
//  point to the corresponding bytes at their new location(s).
//
HRESULT CWebViewMimeFilter::_IncreaseBuffer(ULONG cbIncrement, LPBYTE * pp1, LPBYTE * pp2)
{
    HRESULT hr = S_OK;

    // first check if there's room at the beginning of the buffer
    if (_cbSeek >= cbIncrement)
    {
        MoveMemory(_pBuf, _pBuf + _cbSeek, _cbBuf - _cbSeek);
        _cbBuf -= _cbSeek;

        if (pp1)
            *pp1 = *pp1 - _cbSeek;
        if (pp2)
            *pp2 = *pp2 - _cbSeek;

        _cbSeek = 0;
    }
    else
    {
        // not enough room, so allocate more memory
        LPBYTE p = (LPBYTE)LocalReAlloc(_pBuf, _cbBufSize + cbIncrement, LMEM_MOVEABLE);
        if (!p)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            if (pp1)
                *pp1 = p + (int)(*pp1 - _pBuf);
            if (pp2)
                *pp2 = p + (int)(*pp2 - _pBuf);
    
            _pBuf = p;
            _cbBufSize += cbIncrement;
        }
    }

    return hr;
}

HRESULT CWebViewMimeFilter::_ReadAndExpandBuffer()
{
    HRESULT hr;

    _cbBuf = 0;
    _cbSeek = 0;

    if (!_pBuf)
    {
        _pBuf = (LPBYTE)LocalAlloc(LPTR, BUFFER_ALLOC_SIZE);
        if (!_pBuf)
            return E_OUTOFMEMORY;

        _cbBufSize = BUFFER_ALLOC_SIZE;
    }

    // As strings expand, our buffer grows. If we keep reading in the
    // max amount, we'll keep reallocating the more variable expansions
    // we do. By only reading in BUFFER_SIZE, our _pBuf will grow only
    // a few times and then all the variable expansions should fit
    // in the extra room generated. NOTE: for debug builds, always
    // read the most we can, so we reallocate more often.
#ifdef DEBUG
    #define BUFFER_READ_SIZE (_cbBufSize)
#else
    #define BUFFER_READ_SIZE BUFFER_SIZE
#endif
    hr = _pProt->Read(_pBuf, BUFFER_READ_SIZE-SIZEOF(WCHAR), &_cbBuf); // make sure we have room for NULL
    if (SUCCEEDED(hr) && _cbBuf > 0)
    {
        LPBYTE pchSeek = _pBuf;
        LPBYTE pchEnd;

        if (!_nCharSize)
        {
            // scan buffer and figure out if it's unicode or ansi
            //
            // since we'll always be looking at html and the html header
            // is standard ansi chars, every other byte will be null if
            // we have a unicode buffer. i'm sure 3 checks are enough,
            // so we'll require 8 characters...
            if (_cbBuf > 6 &&
                0 == _pBuf[1] &&
                0 == _pBuf[3] &&
                0 == _pBuf[5])
            {
                TraceMsg(TF_EXPAND, "WebView MIME filter - buffer is UNICODE");
                _nCharSize = SIZEOF(WCHAR);
            }
            else
            {
                TraceMsg(TF_EXPAND, "WebView MIME filter - buffer is ANSI");
                _nCharSize = SIZEOF(char);
            }
        }

        // The string had better be null-terminated, for not only are we
        // going to do a StrChr, but our loop control relies on it!
        // The buffer might have leftover goo from a previous go-round, so
        // ensure that the nulls are there.
        _pBuf[_cbBuf] = _pBuf[_cbBuf+1] = 0;

#ifdef DEBUG
        if (SIZEOF(char)==_nCharSize)
            TraceMsg(TF_EXPAND, "Read A[%hs]", _pBuf);
        else
            TraceMsg(TF_EXPAND, "Read W[%ls]", _pBuf);
#endif

        do {
            LPBYTE pchStart = pchSeek;

            // Assert that the string is still properly null-terminated
            // because we're going to be doing StrChr soon.
            ASSERT(_pBuf[_cbBuf] == 0);
            ASSERT(_pBuf[_cbBuf+1] == 0);

            pchSeek = _StrChr(pchSeek, '%', L'%');
            if (!pchSeek)
                break;

            pchEnd = _StrChr(pchSeek+_nCharSize, '%', L'%');
            if (!pchEnd)
            {
                // no terminator. if there's plenty of space to the end of
                // this buffer then there can't be a clipped variable
                // name to expand.
                if (_cbBuf - (pchSeek - _pBuf) > MAX_VARIABLE_NAME_SIZE*_nCharSize)
                    break;

                // there may be a real variable here we need to expand,
                // so increase our buffer size and read some more data.
                //
                // we may get re-allocated, so update pchStart!
                hr = _IncreaseBuffer(BUFFER_SIZE_INC, &pchStart, NULL);
                if (FAILED(hr))
                    break;
                pchSeek = pchStart;

                // read in more info -- this will be enough to complete
                // any partial variable name expansions
                DWORD dwTmp;
                ASSERT(_cbBufSize - _cbBuf - SIZEOF(WCHAR) > 0);
                hr = _pProt->Read(_pBuf + _cbBuf, _cbBufSize-_cbBuf-SIZEOF(WCHAR), &dwTmp);
                if (FAILED(hr) || dwTmp == 0)
                    break;
                _cbBuf += dwTmp;
                // Ensure proper null termination
                _pBuf[_cbBuf] = _pBuf[_cbBuf+1] = 0;
                continue;
            }


            // figure out what to expand to
            LPBYTE pszExp;
            BYTE b[2];

            b[0] = pchEnd[0];
            b[1] = pchEnd[1];
            pchEnd[0] = 0;
            pchEnd[1] = 0;
            int cbExp = _Expand(pchSeek + _nCharSize, &pszExp);
            pchEnd[0] = b[0];
            pchEnd[1] = b[1];

            if (!cbExp)
            {
                // if it's not a recognized variable, use the bytes as they are
                pchSeek = pchEnd;
                continue;
            }

            // cbVar = number of bytes being replaced (sizeof("%VARNAME%"))
            // pchSeek points to the starting percent sign and pchEnd to
            // the trailing percent sign, so we need to add one more
            // _nCharSize to include the trailing percent sign itself.
            int cbVar = (int)(pchEnd - pchSeek) + _nCharSize;

            if (_cbBuf - cbVar + cbExp  > _cbBufSize - SIZEOF(WCHAR))
            {
                hr = _IncreaseBuffer((_cbBuf - cbVar + cbExp) - (_cbBufSize - SIZEOF(WCHAR)), &pchSeek, &pchEnd);
                if (FAILED(hr))
                    break;
            }

            // move the bytes around!
            // cbSeek = the number of bytes before the first percent sign
            int cbSeek = (int)(pchSeek - _pBuf);
            ASSERT(_cbBuf - cbVar + cbExp <= _cbBufSize - SIZEOF(WCHAR));
            // Move the stuff after the %VARNAME% to its final home
            // Don't forget to move the artificial trailing NULLs too!
            MoveMemory(pchSeek + cbExp, pchEnd + _nCharSize, _cbBuf - cbSeek - cbVar + SIZEOF(WCHAR));

            // Insert the expansion
            MoveMemory(pchSeek, pszExp, cbExp);

            // on to the rest of the buffer...
            pchSeek = pchEnd + _nCharSize;
            _cbBuf = _cbBuf - cbVar + cbExp;

        } while (*pchSeek);

#ifdef DEBUG
        if (SIZEOF(char)==_nCharSize)
            TraceMsg(TF_EXPAND, "---> A[%s]", _pBuf);
        else
            TraceMsg(TF_EXPAND, "---> W[%hs]", _pBuf);
#endif
    }
    else
    {
        // we're at end of stream
        hr = S_FALSE;
    }

    return hr;
}


HRESULT CWebViewMimeFilter::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    HRESULT hr = S_OK;

    if (!_pProt)
    {
        hr = E_FAIL;
    }
    else
    {
        *pcbRead = 0;

        while (cb)
        {
            // if our buffer is empty, fill it
            if (_cbSeek == _cbBuf)
            {
                hr = _ReadAndExpandBuffer();
            }

            // do we have any data to copy?
            int cbLeft = _cbBuf - _cbSeek;
            if (SUCCEEDED(hr) && cbLeft > 0)
            {
                ULONG cbCopy = min(cb, (ULONG)cbLeft);

                memcpy(pv, &_pBuf[_cbSeek], cbCopy);

                pv = (LPVOID)(((LPBYTE)pv) + cbCopy);
                cb -= cbCopy;
                *pcbRead += cbCopy;
                _cbSeek += cbCopy;

                // do not return S_FALSE if some bytes were left unread
                if (cbCopy < (ULONG)cbLeft)
                    hr = S_OK;
            }
            else
            {
                ASSERT(FAILED(hr) || hr == S_FALSE);

                // nothing left to copy
                break;
            }
        }
    }
    return hr;
}
HRESULT CWebViewMimeFilter::Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}
HRESULT CWebViewMimeFilter::LockRequest(DWORD dwOptions)
{
    return S_OK;
}
HRESULT CWebViewMimeFilter::UnlockRequest()
{
    return S_OK;
}

// IInternetProtocolSink methods
HRESULT CWebViewMimeFilter::Switch(PROTOCOLDATA * pProtocolData)
{
    if (_pProtSink)
        return _pProtSink->Switch(pProtocolData);
    return E_FAIL;
}
HRESULT CWebViewMimeFilter::ReportProgress(ULONG ulStatusCode, LPCWSTR pwszStatusText)
{
    if (_pProtSink)
        return _pProtSink->ReportProgress(ulStatusCode, pwszStatusText);
    return E_FAIL;
}
HRESULT CWebViewMimeFilter::ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    if (_pProtSink)
        return _pProtSink->ReportData(grfBSCF, ulProgress, ulProgressMax);
    return E_FAIL;
}
HRESULT CWebViewMimeFilter::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR pwszResult)
{
    if (_pProtSink)
        return _pProtSink->ReportResult(hrResult, dwError, pwszResult);
    return E_FAIL;
}


//IServiceProvider methods
HRESULT CWebViewMimeFilter::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    return IUnknown_QueryService(_pProtSink, rsid, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\propbag.cpp ===
#include "stdafx.h"
#include "stddef.h"
#pragma hdrstop


//
// Exported function for creating a IPropertyBag (or variant of) object.
//

STDAPI SHCreatePropertyBag(REFIID riid, void **ppv)
{
    return SHCreatePropertyBagOnMemory(STGM_READWRITE, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\options.h ===
#ifndef _OPTIONS_H_
#define _OPTIONS_H_

#include <iethread.h>
#include <browseui.h>


#include "cowsite.h"

void DoGlobalFolderOptions(void);

class CFolderOptionsPsx :
        public
               IShellPropSheetExt,
               IShellExtInit,
               CObjectWithSite
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IShellPropSheetExt
    STDMETHOD(AddPages)(THIS_ LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(THIS_ UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    // IShellExtInit
    STDMETHOD(Initialize)(THIS_ LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

    void SetNeedRefresh(BOOL fNeedRefresh) { m_fNeedRefresh = fNeedRefresh; }
    BOOL NeedRefresh() { return m_fNeedRefresh; }

    BOOL HasBrowserService() { return m_pbs2 != NULL; }

    void SetAsDefFolderSettings()
    { if (HasBrowserService()) m_pbs2->SetAsDefFolderSettings(); }

    HRESULT GetDefFolderSettings(DEFFOLDERSETTINGS *pdfs, int cbDfs)
                { return m_pgfs->Get(pdfs, cbDfs); }
    HRESULT SetDefFolderSettings(const DEFFOLDERSETTINGS *pdfs, int cbDfs, UINT flags)
                { return m_pgfs->Set(pdfs, cbDfs, flags); }
    HRESULT ResetDefFolderSettings()
                { IUnknown_Exec(m_pbs2, &CGID_DefView, DVID_RESETDEFAULT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
                  return m_pgfs->Set(NULL, 0, GFSS_SETASDEFAULT); }

private:
    CFolderOptionsPsx();
    ~CFolderOptionsPsx();

    LONG m_cRef;
    BOOL m_fNeedRefresh;
    IBrowserService2 *m_pbs2;
    IGlobalFolderSettings *m_pgfs;

    friend HRESULT CFolderOptionsPsx_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut);
    static UINT CALLBACK PropCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
};

BOOL_PTR CALLBACK FolderOptionsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif // _OPTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\shellprv.h ===
#include "..\shellprv.h"

#define  TF_QISTUB   0x00800000
#ifdef DEBUG
#include "dbutil.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\options.cpp ===
#include "stdafx.h"
#include <trayp.h>
#include "utils.h"
#include "..\deskfldr.h"
#pragma hdrstop

#define SZ_FOLDEROPTSTUBCLASS TEXT("MSGlobalFolderOptionsStub")

void Cabinet_StateChanged(CABINETSTATE *pcs);

const static DWORD aFolderOptsHelpIDs[] = {  // Context Help IDs
    IDC_FCUS_SAME_WINDOW,        IDH_BROWSE_SAME_WINDOW,
    IDC_FCUS_SEPARATE_WINDOWS,   IDH_BROWSE_SEPARATE_WINDOWS,
    IDC_FCUS_WHENEVER_POSSIBLE,  IDH_SHOW_WEB_WHEN_POSSIBLE,
    IDC_FCUS_WHEN_CHOOSE,        IDH_SHOW_WEB_WHEN_CHOOSE,
    IDC_FCUS_SINGLECLICK,        IDH_SINGLE_CLICK_MODE,
    IDC_FCUS_DOUBLECLICK,        IDH_DOUBLE_CLICK_MODE,
    IDC_FCUS_ICON_IE,            IDH_TITLES_LIKE_LINKS,
    IDC_FCUS_ICON_HOVER,         IDH_TITLES_WHEN_POINT,
    IDC_FCUS_ICON_WEBVIEW,       IDH_WEB_VIEW_GEN,
    IDC_FCUS_ICON_WINDOW,        IDH_BROWSE_FOLDERS_GEN,
    IDC_FCUS_ICON_CLICKS,        IDH_ICON_OPEN_GEN,
    IDC_FCUS_RESTORE_DEFAULTS,   IDH_RESTORE_DEFAULTS_GEN,
    IDC_FCUS_WEBVIEW_GROUP_STATIC, -1,         // Suppress help for this item.
    0, 0
};

typedef struct
{
    CABINETSTATE cs;      // Cached "current" CabState.
    CFolderOptionsPsx *ppsx;    // to talk to our propsheet sibling
    // The icons corresponding to the radio button selected are stored here.
    HICON   ahIcon[IDC_FCUS_ICON_MAX - IDC_FCUS_WHENEVER_POSSIBLE + 1];
} FOLDEROPTDATA;

//This functions gets/sets the current Active Desktop value

// if 'set' is true then it takes the value in *pActDesk and sets the ActiveDesktop
// accordingly (TRUE-Active Desktop is On, FALSE-Active Desktop is off)

// if 'set' is false then it gets the ActiveDesktop state  and assigns that value to the
// *pActDesk
void GetSetActiveDesktop(BOOL *pActDesk, BOOL fset)
{
    //This restriction takes precedence over NOACTIVEDESKTOP.
    if (SHRestricted(REST_FORCEACTIVEDESKTOPON))
    {
        *pActDesk = TRUE;
        return;
    }
    else
    {
        if (PolicyNoActiveDesktop())
        {
            *pActDesk = FALSE;
            return;
        }
    }

    IActiveDesktop* pad;
    if (SUCCEEDED(CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &pad))))
    {
        COMPONENTSOPT co;
        co.dwSize = sizeof(COMPONENTSOPT);

        //Get the Current Options
        pad->GetDesktopItemOptions(&co, NULL);

        //Do we have to set new value ?
        if (fset)
        {
            if (co.fActiveDesktop != *pActDesk)
            {
                //Yes? Set the new value
                co.fActiveDesktop = *pActDesk;
                pad->SetDesktopItemOptions(&co, NULL);

                //Apply the change
                pad->ApplyChanges(AD_APPLY_REFRESH | AD_APPLY_DYNAMICREFRESH);
            }
        }
        else
        {
             //No, Get the current state  and return
            *pActDesk  = co.fActiveDesktop;
        }
        pad->Release();
    }
}

// Reads CabinetState and Default Folder Settings
void ReadStateAndSettings(HWND hDlg)
{
    FOLDEROPTDATA *pfod = (FOLDEROPTDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    pfod->ppsx->SetNeedRefresh(FALSE);

    //Get the current Cabinet State
    ReadCabinetState(&pfod->cs, sizeof(pfod->cs));
}

//
// This function selects a given radio button among a set of radio buttons AND it sets the Icon
// image corresponding to the radio button selected.

void CheckRBtnAndSetIcon(HWND hDlg, int idStartBtn, int idEndBtn, int idSelectedBtn, FOLDEROPTDATA *pfod, BOOL fCheckBtn)
{
    //
    //  Check the radio button if required
    //
    if (fCheckBtn)
        CheckRadioButton(hDlg, idStartBtn, idEndBtn, idSelectedBtn);

    // Now, select the Icon corresponding to this selection

    // The following code assumes the order and sequence of the following IDs.
    // So, we verify that no one has broken them inadvertently by doing the following
    // compile time checks.
    COMPILETIME_ASSERT((IDC_FCUS_WHENEVER_POSSIBLE + 1) == IDC_FCUS_WHEN_CHOOSE);
    COMPILETIME_ASSERT((IDC_FCUS_WHEN_CHOOSE + 1)       == IDC_FCUS_SAME_WINDOW);
    COMPILETIME_ASSERT((IDC_FCUS_SAME_WINDOW + 1)       == IDC_FCUS_SEPARATE_WINDOWS);
    COMPILETIME_ASSERT((IDC_FCUS_SEPARATE_WINDOWS + 1)  == IDC_FCUS_SINGLECLICK);
    COMPILETIME_ASSERT((IDC_FCUS_SINGLECLICK + 1)       == IDC_FCUS_DOUBLECLICK);
    COMPILETIME_ASSERT((IDC_FCUS_DOUBLECLICK + 1)       == IDC_FCUS_ICON_IE);
    COMPILETIME_ASSERT((IDC_FCUS_ICON_IE + 1)           == IDC_FCUS_ICON_HOVER);
    COMPILETIME_ASSERT((IDC_FCUS_ICON_HOVER + 1)        == IDC_FCUS_ICON_MAX);

    COMPILETIME_ASSERT((IDI_WEBVIEW_ON + 1)     == IDI_WEBVIEW_OFF);
    COMPILETIME_ASSERT((IDI_WEBVIEW_OFF + 1)    == IDI_SAME_WINDOW);
    COMPILETIME_ASSERT((IDI_SAME_WINDOW + 1)    == IDI_SEPARATE_WINDOW);
    COMPILETIME_ASSERT((IDI_SEPARATE_WINDOW + 1)== IDI_SINGLE_CLICK);
    COMPILETIME_ASSERT((IDI_SINGLE_CLICK + 1)   == IDI_DOUBLE_CLICK);

    COMPILETIME_ASSERT((IDC_FCUS_ICON_WEBVIEW + 1)       == IDC_FCUS_ICON_WINDOW);
    COMPILETIME_ASSERT((IDC_FCUS_ICON_WINDOW + 1)        == IDC_FCUS_ICON_CLICKS);

    ASSERT((IDC_FCUS_ICON_MAX - IDC_FCUS_WHENEVER_POSSIBLE + 1) == ARRAYSIZE(pfod->ahIcon));

    int iIndex = idSelectedBtn - IDC_FCUS_WHENEVER_POSSIBLE; //Calculate the index into the Icon Table

    ASSERT(iIndex < ARRAYSIZE(pfod->ahIcon));

    if (pfod->ahIcon[iIndex] == NULL)
        pfod->ahIcon[iIndex] = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_WEBVIEW_ON + iIndex), IMAGE_ICON, 0,0, LR_DEFAULTSIZE);

    // Set the Icon image corresponding to the Radio button selected.
    // This dialog is broken into sections of radio buttons. Each section has two and only two main
    // radio buttons and a corresponding icon. In order to associate the radio buttons with their
    // corresponding icon, all button ids and all icon ids are kept in order (hence the above COMPILETIME_ASSERTs),
    // such that the first and second radio buttons belong with the first icon, second and third radio buttons
    // belong with the second icon, and so on. Now, given a radio button id, get its position in the list of
    // all the radio buttons (that is the index assigment just above) and shift it right by one bit to get the index
    // of the corresponding icon. The shift is neccesary because there is only one icon every two radio buttons.
    SendDlgItemMessage(hDlg, IDC_FCUS_ICON_WEBVIEW + (iIndex >> 1), STM_SETICON, (WPARAM)(pfod->ahIcon[iIndex]), 0);
}

BOOL_PTR CALLBACK FolderOptionsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fCheckedSingleClickDialog = FALSE;
    static BOOL fCheckedWebStyle = FALSE;
    int idSelectedBtn, i;

    FOLDEROPTDATA *pfod = (FOLDEROPTDATA *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) 
    {
    case WM_INITDIALOG:
    {
        pfod = (FOLDEROPTDATA *)LocalAlloc(LPTR, sizeof(*pfod));
        if (pfod)
        {
            BOOL fClassicShell, fForceActiveDesktopOn;
            SHELLSTATE ss = { 0 };
            //Set the Folder Options data
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pfod);

            PROPSHEETPAGE *pps = (PROPSHEETPAGE *)lParam;
            pfod->ppsx = (CFolderOptionsPsx *)pps->lParam;

            ReadStateAndSettings(hDlg);

            // No need to initialize the array of icons with zeros
            // for(i = 0; i < ARRAYSIZE(pfod->ahIcon); i++)
            //    pfod->ahIcon[i] = NULL;

            fClassicShell = SHRestricted(REST_CLASSICSHELL);
            fForceActiveDesktopOn = SHRestricted(REST_FORCEACTIVEDESKTOPON);
            SHGetSetSettings(&ss, SSF_DOUBLECLICKINWEBVIEW | SSF_WIN95CLASSIC | SSF_WEBVIEW, FALSE);

            // browse folder options
            CheckRBtnAndSetIcon(hDlg,
                         IDC_FCUS_SAME_WINDOW,
                         IDC_FCUS_SEPARATE_WINDOWS,
                         pfod->cs.fNewWindowMode ? IDC_FCUS_SEPARATE_WINDOWS:IDC_FCUS_SAME_WINDOW, pfod, TRUE);

            // show folders as web pages
            CheckRBtnAndSetIcon(hDlg,
                         IDC_FCUS_WHENEVER_POSSIBLE,
                         IDC_FCUS_WHEN_CHOOSE,
                         ss.fWebView && !fClassicShell? IDC_FCUS_WHENEVER_POSSIBLE : IDC_FCUS_WHEN_CHOOSE, pfod, TRUE);

            if (SHRestricted(REST_NOWEBVIEW) || fClassicShell)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_FCUS_WHENEVER_POSSIBLE), FALSE);
                //EnableWindow(GetDlgItem(hDlg, IDC_FCUS_WHEN_CHOOSE), FALSE);
                //EnableWindow(GetDlgItem(hDlg, IDC_FCUS_WEBVIEW_GROUP_STATIC), FALSE);
            }

            // single/double click
            CheckRBtnAndSetIcon(hDlg,
                         IDC_FCUS_SINGLECLICK,IDC_FCUS_DOUBLECLICK,
                         !ss.fWin95Classic
                         ? (ss.fDoubleClickInWebView ? IDC_FCUS_DOUBLECLICK:IDC_FCUS_SINGLECLICK)
                         : IDC_FCUS_DOUBLECLICK, pfod, TRUE);

            if (fClassicShell)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_FCUS_SINGLECLICK), FALSE);
            }
            // gray out icon underline behvaior when not in single click mode
            BOOL fChecked = IsDlgButtonChecked(hDlg, IDC_FCUS_SINGLECLICK);
            EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_IE),    fChecked);
            EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_HOVER), fChecked);

            DWORD dwIconUnderline = ICON_IE;

            if (!fClassicShell)
            {
                DWORD cb = sizeof(dwIconUnderline);

                SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                            TEXT("IconUnderline"),
                            NULL,
                            &dwIconUnderline,
                            &cb,
                            FALSE,
                            &dwIconUnderline,
                            cb);
            }

            // JANK : Fix for MIL bug #105236
            // Since these are sub radio buttons, they do not have an icon and therefore do not need
            // the CheckRBtnAndSetIcon call
            CheckRadioButton(hDlg, IDC_FCUS_ICON_IE, IDC_FCUS_ICON_HOVER,
                         dwIconUnderline == ICON_IE ? IDC_FCUS_ICON_IE : IDC_FCUS_ICON_HOVER);
/*
            CheckRBtnAndSetIcon(hDlg,
                         IDC_FCUS_ICON_IE, IDC_FCUS_ICON_HOVER,
                         dwIconUnderline == ICON_IE ? IDC_FCUS_ICON_IE : IDC_FCUS_ICON_HOVER, pfod, TRUE);
*/

            if (fClassicShell)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_HOVER), FALSE);
            }
        }
        else
        {
            // Can't use EndDialog because we weren't created by DialogBox()
            DestroyWindow(hDlg);
        }
        return TRUE;
    }

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_APPLY:
        {
            SHELLSTATE oldss = {0}, ss = { 0 };

            SHGetSetSettings(&oldss, SSF_DOUBLECLICKINWEBVIEW | SSF_WIN95CLASSIC | SSF_WEBVIEW, FALSE);

            BOOL fOldValue = BOOLIFY(pfod->cs.fNewWindowMode);
            if (IsDlgButtonChecked(hDlg, IDC_FCUS_SAME_WINDOW))
                pfod->cs.fNewWindowMode = FALSE;
            else
                pfod->cs.fNewWindowMode = TRUE;
            if (fOldValue != (pfod->cs.fNewWindowMode ? 1 : 0))
                Cabinet_StateChanged(&pfod->cs);

            if (IsDlgButtonChecked(hDlg, IDC_FCUS_WHENEVER_POSSIBLE))
            {
                ss.fWin95Classic = FALSE;
                ss.fWebView = TRUE;
            }
            else
            {
                ss.fWin95Classic = TRUE;
                ss.fWebView = FALSE;
            }

            if (IsDlgButtonChecked(hDlg, IDC_FCUS_SINGLECLICK))
            {
                ss.fDoubleClickInWebView = FALSE;
                ss.fWin95Classic = FALSE;
            }
            else
            {
                ss.fDoubleClickInWebView = TRUE;
                ss.fWin95Classic = FALSE;
            }

            DWORD dwIconUnderline, dwOldIconUnderline, dwDefaultIconUnderline;
            DWORD cb = sizeof(dwIconUnderline);

            //Get the current settings for "IconUnderline"
            dwDefaultIconUnderline = -1;  // not ICON_IE or will not WM_WININICHANGE
            SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                            TEXT("IconUnderline"), NULL, &dwOldIconUnderline, &cb,
                            FALSE, &dwDefaultIconUnderline, sizeof(dwDefaultIconUnderline));
                                
            if (IsDlgButtonChecked(hDlg, IDC_FCUS_ICON_IE))
                dwIconUnderline = ICON_IE;
            else
                dwIconUnderline = ICON_HOVER;

            if (dwOldIconUnderline != dwIconUnderline) //See if this setting has changed
            {
                cb = sizeof(dwIconUnderline);
                SHRegSetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                                TEXT("IconUnderline"), NULL, &dwIconUnderline, cb,
                                SHREGSET_DEFAULT);

                SHSendMessageBroadcast(WM_WININICHANGE, 0, (LPARAM)TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\IconUnderline"));
            }

            DWORD dwMask = 0;
            if (ss.fWebView != oldss.fWebView)
            {
                dwMask |= SSF_WEBVIEW;
            }
            
            if (ss.fWin95Classic != oldss.fWin95Classic)
            {
                dwMask |= SSF_WIN95CLASSIC;
            }
            
            if (ss.fDoubleClickInWebView != oldss.fDoubleClickInWebView)
            {
                dwMask |= SSF_DOUBLECLICKINWEBVIEW;
            }

            if (dwMask)
            {
                SHGetSetSettings(&ss, dwMask, TRUE);
            }

            if (ss.fWebView != oldss.fWebView)
            {
                Cabinet_RefreshAll(Cabinet_UpdateWebViewEnum, (LPARAM)ss.fWebView);
                // Note: This refreshes as well.
            }
            
            if ((ss.fWin95Classic != oldss.fWin95Classic)
                    || (ss.fDoubleClickInWebView != oldss.fDoubleClickInWebView))
            {
                Cabinet_RefreshAll(Cabinet_RefreshEnum, (LPARAM)0);
            }

            return TRUE;
        }

        case PSN_KILLACTIVE:
            // validate here
            // SetWindowLongPtr(hDlg, DWLP_MSGRESULT, !ValidateLink());   // don't allow close
            return TRUE;

        case PSN_SETACTIVE:
            if (pfod->ppsx->NeedRefresh())
            {
                ReadStateAndSettings(hDlg);
            }
            return TRUE;
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, TEXT(SHELL_HLP),
           HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aFolderOptsHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, TEXT(SHELL_HLP), HELP_CONTEXTMENU,
            (ULONG_PTR)(void *)aFolderOptsHelpIDs);
        break;

    case WM_COMMAND:
        idSelectedBtn = GET_WM_COMMAND_ID(wParam, lParam);
        switch (idSelectedBtn)
        {
        case IDC_FCUS_SINGLECLICK:
        case IDC_FCUS_DOUBLECLICK:
            if (GET_WM_COMMAND_CMD(wParam,lParam) == BN_CLICKED)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_IE),    GET_WM_COMMAND_ID(wParam,lParam) == IDC_FCUS_SINGLECLICK);
                EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_HOVER), GET_WM_COMMAND_ID(wParam,lParam) == IDC_FCUS_SINGLECLICK);
            }
            //Fall through ...
        case IDC_FCUS_WHENEVER_POSSIBLE:
        case IDC_FCUS_WHEN_CHOOSE:
        case IDC_FCUS_SAME_WINDOW:
        case IDC_FCUS_SEPARATE_WINDOWS:
            // We do not need to Check the radio button; It is alreay checked. We just need to
            // set the corresponding Icon. Hence we pass FALSE.
            CheckRBtnAndSetIcon(hDlg, 0, 0, idSelectedBtn, pfod, FALSE);
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
            break;

        case IDC_FCUS_ICON_IE:
        case IDC_FCUS_ICON_HOVER:
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
            break;

        case IDC_FCUS_RESTORE_DEFAULTS:
            //Set the "factory settings" as the default.
            // Don't set the default web view option if web view is disabled via system policy.
            if (0 == SHRestricted(REST_NOWEBVIEW))
            {
                CheckRBtnAndSetIcon(hDlg, IDC_FCUS_WHENEVER_POSSIBLE, IDC_FCUS_WHEN_CHOOSE, IDC_FCUS_WHENEVER_POSSIBLE, pfod, TRUE);
            }
            CheckRBtnAndSetIcon(hDlg, IDC_FCUS_SAME_WINDOW, IDC_FCUS_SEPARATE_WINDOWS, IDC_FCUS_SAME_WINDOW, pfod, TRUE);
            CheckRBtnAndSetIcon(hDlg, IDC_FCUS_SINGLECLICK, IDC_FCUS_DOUBLECLICK, IDC_FCUS_DOUBLECLICK, pfod, TRUE);

            CheckRadioButton(hDlg, IDC_FCUS_ICON_IE, IDC_FCUS_ICON_HOVER, IDC_FCUS_ICON_IE);
            EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_IE),    FALSE); //Disable
            EnableWindow(GetDlgItem(hDlg, IDC_FCUS_ICON_HOVER), FALSE); //Disable

            //Enable the "Apply" button because changes have happened.
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);

            break;
        }
        break;

    case WM_DESTROY:
        if (pfod)
        {
            //Cleanup the Icons array!
            for (i = 0; i < ARRAYSIZE(pfod->ahIcon); i++)
            {
                if (pfod->ahIcon[i])
                    DestroyIcon(pfod->ahIcon[i]);
            }
            SetWindowLongPtr(hDlg, DWLP_USER, 0);
            LocalFree((HANDLE)pfod);
        }
        break;
    }

    return FALSE;
}

// Moved from defview.cpp, which never used these functions

const TCHAR c_szExploreClass[]  = TEXT("ExploreWClass");
const TCHAR c_szIExploreClass[] = TEXT("IEFrame");
const TCHAR c_szCabinetClass[]  = TEXT("CabinetWClass");

BOOL IsNamedWindow(HWND hwnd, LPCTSTR pszClass)
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return lstrcmp(szClass, pszClass) == 0;
}

BOOL IsExplorerWindow(HWND hwnd)
{
    return IsNamedWindow(hwnd, c_szExploreClass);
}

BOOL IsTrayWindow(HWND hwnd)
{
    return IsNamedWindow(hwnd, TEXT(WNDCLASS_TRAYNOTIFY));
}

BOOL IsFolderWindow(HWND hwnd)
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return (lstrcmp(szClass, c_szCabinetClass) == 0) || (lstrcmp(szClass, c_szIExploreClass) == 0);
}

BOOL CALLBACK Cabinet_GlobalStateEnum(HWND hwnd, LPARAM lParam)
{
    if (IsFolderWindow(hwnd) || IsExplorerWindow(hwnd))
    {
        PostMessage(hwnd, CWM_GLOBALSTATECHANGE, 0, 0);
    }

    return TRUE;
}

void Cabinet_StateChanged(CABINETSTATE *pcs)
{
    // Save the new settings away...
    WriteCabinetState(pcs);
    EnumWindows(Cabinet_GlobalStateEnum, 0);
}

HWND CreateGlobalFolderOptionsStubWindow(void)
{
    WNDCLASS wc = {0};
    
    wc.lpfnWndProc   = DefWindowProc;
    wc.hInstance     = HINST_THISDLL;
    wc.hIcon         = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDI_FOLDEROPTIONS));
    wc.lpszClassName = SZ_FOLDEROPTSTUBCLASS;

    RegisterClass(&wc);

    DWORD dwExStyle = WS_EX_TOOLWINDOW;
    if (IS_BIDI_LOCALIZED_SYSTEM()) 
    {
        dwExStyle |= dwExStyleRTLMirrorWnd;
    }
    return CreateWindowEx(dwExStyle, SZ_FOLDEROPTSTUBCLASS, c_szNULL, WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, NULL, NULL, HINST_THISDLL, NULL);
}

BOOL CALLBACK AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAXPROPPAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

void AddPropSheetCLSID(REFCLSID clsid, PROPSHEETHEADER *ppsh)
{
    IShellPropSheetExt *psx;
    HRESULT hres = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellPropSheetExt, &psx));
    if (SUCCEEDED(hres)) 
    {
        psx->AddPages(AddPropSheetPage, (LPARAM)ppsh);
        psx->Release();
    }
}

DWORD CALLBACK GlobalFolderOptPropSheetThreadProc(void *)
{
    HWND hwndStub = CreateGlobalFolderOptionsStubWindow();

    if (!SHRestricted(REST_NOFOLDEROPTIONS))
    {
        PROPSHEETHEADER psh = {0};
        HPROPSHEETPAGE rPages[MAXPROPPAGES];

        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_DEFAULT;
        psh.hInstance = HINST_THISDLL;
        psh.hwndParent = hwndStub;
        psh.pszCaption = MAKEINTRESOURCE(IDS_FOLDEROPT_TITLE);
        psh.phpage = rPages;

        AddPropSheetCLSID(CLSID_ShellFldSetExt, &psh);
        AddPropSheetCLSID(CLSID_FileTypes, &psh);
        AddPropSheetCLSID(CLSID_OfflineFilesOptions, &psh);

        // Display the property sheet.
        PropertySheet(&psh);
    }
    else
    {
        SHRestrictedMessageBox(hwndStub);
    }

    // Clean up stub window.
    DestroyWindow(hwndStub);

    return 0;
}

BOOL CALLBACK FindFolderOptionsEnumProc(HWND hwnd, LPARAM lParam)
{
    BOOL fRet = TRUE;
    HWND *phwnd = (HWND *)lParam;
    TCHAR szClass[MAX_PATH];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));

    if (lstrcmp(szClass, SZ_FOLDEROPTSTUBCLASS) == 0)
    {
        *phwnd = hwnd;
        fRet = FALSE;
    }

    return fRet;
}

void DoGlobalFolderOptions(void)
{
    HWND hwnd = NULL;
    
    EnumWindows(FindFolderOptionsEnumProc, (LPARAM)&hwnd);

    if (hwnd)
    {
        hwnd = GetLastActivePopup(hwnd);
        if (hwnd && IsWindow(hwnd))
        {
            SetForegroundWindow(hwnd);
        }
    }
    else
    {
        SHCreateThread(GlobalFolderOptPropSheetThreadProc, NULL, CTF_COINIT, NULL);
    }
}

// Public entry point for asking Explorer to launch Options stuff

STDAPI_(void) Options_RunDLLA(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    PostMessage(GetShellWindow(), CWM_SHOWFOLDEROPT, StrToIntA(pszCmdLine), (LPARAM)0);
}

STDAPI_(void) Options_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    PostMessage(GetShellWindow(), CWM_SHOWFOLDEROPT,  StrToIntW(pszCmdLine), (LPARAM)0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\schedule.h ===
#ifndef _SCHEDULE_H
#define _SCHEDULE_H

#ifdef __cplusplus
extern "C" {
#endif

void CShellTaskScheduler_CreateThreadPool( void );
void CShellTaskScheduler_FreeThreadPool( void );

// global function for allocating a task scheduler.
// any object that uses it must make sure that its tasks are removed from the queue
// before it exits.
HRESULT SHGetSystemScheduler( LPSHELLTASKSCHEDULER * ppScheduler );
HRESULT SHFreeSystemScheduler( void );

#ifdef DEBUG
VOID SHValidateEmptySystemScheduler(void);
#else
#define SHValidateEmptySystemScheduler()
#endif

#ifdef __cplusplus
};
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\sdmigwiz.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "stdenum.h"
#include <mshtmdid.h>
#include "shdispid.h"


/////////////////////////////////////////////
// Migration Wizard OOBE Automation Object //
/////////////////////////////////////////////
// This object handles automation calls from
// OOBE (Out Of Box Experience) and contains
// the Migration Wizard Engine located in migoobe.dll.
//
// Someday, this code will live inside of migoobe.dll,
// but we didn't have time to generate an entirely new
// typelib for migoobe.dll so we piggybacked on shell32's
// to make the development of the automation quicker to
// satisfy time constraints.
/////////////////////////////////////////////

// {E7562536-2D53-4f63-A749-84F7D4FC93E8}
extern "C" const CLSID CLSID_MigWizEngine = 
{ 0xe7562536, 0x2d53, 0x4f63, { 0xa7, 0x49, 0x84, 0xf7, 0xd4, 0xfc, 0x93, 0xe8 } };

class ATL_NO_VTABLE CMigrationWizardAuto
                    : public CComObjectRootEx<CComSingleThreadModel>
                    , public CComCoClass<CMigrationWizardAuto, &CLSID_MigrationWizardAuto>
                    , public IObjectWithSiteImpl<CMigrationWizardAuto>
                    , public IDispatchImpl<IMigrationWizardAuto, &IID_IMigrationWizardAuto, &LIBID_Shell32>
                    , public IConnectionPointContainerImpl<CMigrationWizardAuto>
                    , public IConnectionPointImpl<CMigrationWizardAuto, &DIID_DMigrationWizardAutoEvents>
                    , public IProvideClassInfo2Impl<&CLSID_MigrationWizardAuto, &DIID_DMigrationWizardAutoEvents, &LIBID_Shell32>
// maybe                    , public IObjectWithSite
{
public:
    CMigrationWizardAuto();
    ~CMigrationWizardAuto();

DECLARE_REGISTRY_RESOURCEID(IDR_MIGWIZAUTO)            
DECLARE_NOT_AGGREGATABLE(CMigrationWizardAuto)


BEGIN_COM_MAP(CMigrationWizardAuto)
    // ATL Uses these in IUnknown::QueryInterface()
    COM_INTERFACE_ENTRY(IMigrationWizardAuto)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)       // maybe nuke _IMPL
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CMigrationWizardAuto)
    CONNECTION_POINT_ENTRY(DIID_DMigrationWizardAutoEvents)
END_CONNECTION_POINT_MAP()

 
    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown * punk);

    // IDispatch
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);

    // IMigrationWizardAuto
    STDMETHODIMP CreateToolDisk(BSTR pszDrivePath, BSTR pszFilesPath, BSTR pszManifest);
    STDMETHODIMP ApplySettings(BSTR pszStore);
    STDMETHODIMP Cancel();


protected:
    HRESULT _InitInner(void);
    //    HRESULT _FireDebug();

private:
    ITypeInfo* m_pTypeInfo;

    IMigrationWizardAuto * m_pInner;
};


LCID g_lcidLocaleUnicppMigWiz = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);

STDAPI CMigrationWizardAuto_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    return CComCreator< CComPolyObject< CMigrationWizardAuto > >::CreateInstance((void *) punkOuter, riid, ppvOut);
}

CMigrationWizardAuto::CMigrationWizardAuto() : m_pTypeInfo(NULL)
{
    IID* pIID = (IID*)&IID_IMigrationWizardAuto;
    GUID* pLIBID = (GUID*)&LIBID_Shell32;
    WORD wMajor = 1;
    WORD wMinor = 0;
    ITypeLib* ptl = 0;
    HRESULT hr = LoadRegTypeLib(*pLIBID, wMajor, wMinor, 0, &ptl);

    m_pInner = NULL;

    if (SUCCEEDED(hr))
    {
        hr = ptl->GetTypeInfoOfGuid(*pIID, &m_pTypeInfo);
        ptl->Release();
    }
    DllAddRef();
}

CMigrationWizardAuto::~CMigrationWizardAuto()
{
    ATOMICRELEASE(m_pInner);

    if (m_pTypeInfo)
    {
        m_pTypeInfo->Release();
    }
    DllRelease();
}

HRESULT CMigrationWizardAuto::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo)
{
    if (itinfo != 0)
    {
        return (*ppITypeInfo = 0), DISP_E_BADINDEX;
    }
    else
    {
        return (*ppITypeInfo = m_pTypeInfo)->AddRef(), S_OK;
    }
}


HRESULT CMigrationWizardAuto::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
    UINT cNames, LCID lcid, DISPID* rgdispid)
{
    return m_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

HRESULT CMigrationWizardAuto::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, 
                                     VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    return m_pTypeInfo->Invoke(static_cast<IMigrationWizardAuto*>(this),
                               dispidMember, wFlags, pdispparams, pvarResult,
                               pexcepinfo, puArgErr);
}



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMigrationWizardAuto::SetSite(IUnknown * punk)
{
    if (m_pInner && !punk)
    {
        // Break back pointer
        IUnknown_SetSite(m_pInner, NULL);
    }

    return IObjectWithSiteImpl<CMigrationWizardAuto>::SetSite(punk);
}


HRESULT CMigrationWizardAuto::_InitInner(void)
{
    HRESULT hr = S_OK;

    if (!m_pInner)
    {
        hr = CoCreateInstance(CLSID_MigWizEngine, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMigrationWizardAuto, &m_pInner));
        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(m_pInner, reinterpret_cast<IUnknown*>(this));
        }
    }

    return hr;
}



STDMETHODIMP CMigrationWizardAuto::CreateToolDisk(BSTR pszDrivePath, BSTR pszFilesPath, BSTR pszManifest)
{
    HRESULT hr = _InitInner();

    if (SUCCEEDED(hr))
    {
        hr = m_pInner->CreateToolDisk(pszDrivePath, pszFilesPath, pszManifest);
        // Done by inner
    }

    return hr;
}

STDMETHODIMP CMigrationWizardAuto::ApplySettings(BSTR pszStore)
{
    HRESULT hr = _InitInner();

    if (SUCCEEDED(hr))
    {
        hr = m_pInner->ApplySettings(pszStore);
        // Done by inner
    }

    return hr;
}

STDMETHODIMP CMigrationWizardAuto::Cancel()
{
    HRESULT hr = _InitInner();

    if (SUCCEEDED(hr))
    {
        hr = m_pInner->Cancel();
        // Done by inner
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\resource.h ===
// copied from shdocvw\resource.h
// values adjusted to not conflict with shell32\ids.h
//


// IE4 shipped with FCIDM_NEXTCTL as 0xA030 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_NEXTCTL       (FCIDM_BROWSERFIRST + 0x30) // explorer browseui shell32

// IE4 shipped with FCIDM_FINDFILES as 0xA0085 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_FINDFILES     (FCIDM_BROWSERFIRST + 0x85)

#define IDD_BACKGROUND                  0x7500
#define IDD_CUSTOMIZE                   0x7501
#define IDD_CUSTOMIZE_WEB               0x7502
#define IDD_ADDCOMPONENT                0x7503
#define IDD_COLORPICK                   0x7504
#define IDD_DESKCLNR                    0x7505

#define IDD_FOLDEROPTIONS               0x7507 
#define IDD_ADVANCEDOPTIONS             0x7508

#define IDI_BACK_NONE                   200 // shell32 id.h goes to 173 for icons
#define IDI_FOLDEROPTIONS               210
#define IDI_FRAME                       0x0200

//Desktop cleaner dialog
#define IDC_DESKCLNR_MOVEUNUSED         0x7540
#define IDC_DESKCLNR_CHECK              0x7541
#define IDC_DESKCLNR_RUNWIZARD          0x7542

#define IDC_BACK_WPLIST                 0x7560
#define IDC_BACK_BROWSE                 0x7561
#define IDC_BACK_WEB                    0x7562
#define IDC_BACK_WPSTYLE                0x7563
#define IDC_BACK_PREVIEW                0x7565
#define IDC_BACK_COLORPICKER            0x7566
#define IDC_BACK_DISPLAY                0x7567
#define IDC_BACK_SELECT                 0x7568
#define IDC_BACK_COLORPICKERLABEL       0x7569

// Desktop Items Dialog
#define IDC_COMP_LIST                   0x7570
#define IDC_COMP_NEW                    0x7571
#define IDC_COMP_DELETE                 0x7572
#define IDC_COMP_PROPERTIES             0x7573
#define IDC_DESKTOP_ICONS               0x7574
#define IDC_COMP_PREVIEW                0x7575
#define IDC_CHANGEICON2                 0x7576
#define IDC_ICONDEFAULT                 0x7577
#define IDC_COMP_DESKCLNR               0x7578
#define IDC_COMP_SYNCHRONIZE            0x7579

#define IDC_CPROP_COMPLIST              0x7579
#define IDC_CPROP_SOURCE                0x757a
#define IDC_CPROP_BROWSE                0x757b
#define IDC_GOTO_GALLERY                0x757c

#define IDC_DESKTOP_ICON_MYDOCS         0x757d
#define IDC_DESKTOP_ICON_MYCOMP         0x757e
#define IDC_DESKTOP_ICON_MYNET          0x7580
#define IDC_DESKTOP_ICON_IE             0x7581

#define IDC_CPDLG_16COLORS              0x7584
#define IDC_CPDLG_COLORETCH             0x7585
#define IDC_CPDLG_COLOROTHER            0x7586
#define IDC_CPDLG_COLORCUST             0x7587

#define IDC_KBSTART                     0x857c

// ids for IDD_FOLDEROPTIONS
// Warning: Do not change the order and sequence of the following IDs.
// The code assumes and asserts if it changes.
#define IDC_FCUS_WHENEVER_POSSIBLE      0x7592
#define IDC_FCUS_WHEN_CHOOSE            (IDC_FCUS_WHENEVER_POSSIBLE + 1)// 0x7593
#define IDC_FCUS_SAME_WINDOW            (IDC_FCUS_WHEN_CHOOSE + 1)      // 0x7594
#define IDC_FCUS_SEPARATE_WINDOWS       (IDC_FCUS_SAME_WINDOW + 1)      // 0x7595
#define IDC_FCUS_SINGLECLICK            (IDC_FCUS_SEPARATE_WINDOWS + 1) // 0x7596
#define IDC_FCUS_DOUBLECLICK            (IDC_FCUS_SINGLECLICK + 1)      // 0x7597
#define IDC_FCUS_ICON_IE                (IDC_FCUS_DOUBLECLICK + 1)      // 0x7598
#define IDC_FCUS_ICON_HOVER             (IDC_FCUS_ICON_IE + 1)          // 0x7599
#define IDC_FCUS_ICON_MAX               (IDC_FCUS_ICON_HOVER + 1)
// End of Warning: Do not change the order and sequence of the above IDC_FCUS_* id values.

#define IDC_FCUS_RESTORE_DEFAULTS       0x759B

// Warning: Do not change the order and sequence of the following IDs.
#define IDC_FCUS_ICON_WEBVIEW           0x759D
#define IDC_FCUS_ICON_WINDOW            (IDC_FCUS_ICON_WEBVIEW + 1)        // 0x759E           
#define IDC_FCUS_ICON_CLICKS            (IDC_FCUS_ICON_WINDOW + 1)         // 0x759F
// End of Warning: Do not change the order and sequence of the above IDC_FOCUS_* 

#define IDC_FCUS_WEBVIEW_GROUP_STATIC   0x7580

#define IDC_COMP_DESKTOPICONS_GROUP       0x7588
#define IDC_COMP_CHANGEDESKTOPICON_LABEL  0x7589
#define IDC_COMP_DESKTOPWEBPAGES_LABEL    0x7590
#define IDC_COMP_DESKTOPWEBPAGES_TITLE1   0x7591
#define IDC_COMP_DESKTOPWEBPAGES_TITLE2   0x7592
#define IDC_COMP_DESKTOPWEBPAGES_CHECK    0x7593

// ids for IDD_CHECKSINGLECLICK
#define IDC_SC_YES                      0x75A0
#define IDC_SC_NO                       0x75A1
#define IDC_SC_MOREINFO                 0x75A2

// ids for IDD_ADVANCEDOPTIONS
#define IDC_ADVO_ADVANCEDTREE           0x75A8
#define IDC_ADVO_ADV_RESTORE_DEF        0x75A9
#define IDC_ADVO_RESETTOORIGINAL        0x75AA
#define IDC_ADVO_USECURRENTFOLDER       0x75AB
#define IDC_ADVO_IMAGEFOLDER            0x75AC
#define IDC_ADVO_ADVANCEDTEXT           0x75AD
#define IDC_ADVO_GROUPBOX               0x75AE
#define IDC_ADVO_STATICTEXT             0x75AF




//
// The constants below came from DESKHTML.DLL
//
#define IDS_SUBSCRIBEDURL               0x7600
#define IDS_RESIZEABLE                  0x7601
#define IDS_BASE_TAG                    0x7602
#define IDS_COMMENT_BEGIN               0x7603
#define IDS_COMMENT1                    0x7604
#define IDS_COMMENT_END                 0x7605
#define IDS_HEADER_BEGIN                0x7606
#define IDS_BODY_BEGIN                  0x7607
#define IDS_DIV_START                   0x7608
#define IDS_DIV_SIZE                    0x7609
#define IDS_IMAGE_BEGIN                 0x760a
#define IDS_IMAGE_LOCATION              0x760b
#define IDS_IMAGE_SIZE                  0x760c
#define IDS_DIV_END                     0x760d
#define IDS_IFRAME_BEGIN                0x760e
#define IDS_IFRAME_SIZE                 0x760f
#define IDS_BODY_END                    0x7610
#define IDS_CONTROL_1                   0x7611
#define IDS_CONTROL_2                   0x7612
#define IDS_CONTROL_3                   0x7613
#define IDS_DIV_START2                  0x7614
#define IDS_DIV_START2W                 0x7615
#define IDS_IMAGE_BEGIN2                0x7616
#define IDS_IFRAME_BEGIN2               0x7617
#define IDS_BODY_BEGIN2                 0x7618
#define IDS_BODY_CENTER_WP              0x7619
#define IDS_BODY_PATTERN_AND_WP         0x761a
#define IDS_STRETCH_WALLPAPER           0x761b
#define IDS_WPSTYLE                     0x761c    // first style string
#define IDS_WPSTYLE_CENTER              (IDS_WPSTYLE)
#define IDS_WPSTYLE_TILE                (IDS_WPSTYLE+1)
#define IDS_WPSTYLE_STRETCH             (IDS_WPSTYLE+2)
#define IDS_COMP_BADURL                 0x7626
#define IDS_COMP_TITLE                  0x7627
#define IDS_COMP_EXISTS                 0x7628
#define IDS_COMP_SUBSCRIBED             0x7629
#define IDS_COMP_BADSUBSCRIBE           0x762a
#define IDS_SAMPLE_COMPONENT            0x762b
#define IDS_CHANNEL_BAR                 0x762c
#define IDS_COMP_CONFIRMDEL             0x762d
#define IDS_VALIDFN_FMT                 0x762e
#define IDS_VALIDFN_TITLE               0x762f
#define IDS_BACK_TYPE1                  0x7630
#define IDS_BACK_TYPE2                  0x7631
#define IDS_COMP_TYPE1                  0x7632
#define IDS_COMP_TYPE2                  0x7633
#define IDS_VISIT_URL                   0x7634
#define IDS_COMP_CONFIRMRESET           0x7635
#define IDS_BACK_FILETYPES              0x7636
#define IDS_COMP_FILETYPES              0x7637
#define IDS_ADDCOMP_ERROR_CDFNODTI      0x7638
#define IDS_ADDCOMP_ERROR_CDFINALID     0x7639
#define IDS_VISITGALLERY_TEXT           0x763a
#define IDS_VISITGALLERY_TITLE          0x763b
#define IDS_CONFIRM_ADI_REINSTALL       0x763d
#define IDS_ADDRBAND_ACCELLERATOR       0x763e
#define IDS_FOLDEROPT_TEXT              0x763f
#define IDS_FOLDEROPT_TITLE             0x7640
#define IDS_FOLDERVIEWS                 0x7643
#define IDS_LIKECURRENT_TEXT            0x7644
#define IDS_RESETALL_TEXT               0x7645
#define IDS_DIV_START3                  0x7646
#define IDS_BODY_PATTERN_AND_WP2        0x7647
#define IDS_BODY_CENTER_WP2             0x7648
#define IDS_BODY_END2                   0x7649
#define IDS_COMP_EXISTS_2               0x764a

#define IDS_HTMLDOCUMENT                0x764b
#define IDS_PICTURE                     0x764c
#define IDS_WEBSITE                     0x764d
#define IDS_ADDTODESKTOP                0x764e
#define IDS_EDITDESKTOPCOMP             0x764f
#define IDS_CDF_FILTER                  0x7650
#define IDS_URL_FILTER                  0x7651
#define IDS_TYPETHENAMESTRING           0x7652
#define IDS_IMAGES_FILTER               0x7653
#define IDS_HTMLDOC_FILTER              0x7654
#define IDS_CONFIRM_ADD                 0x7655
#define IDS_INTERNET_EXPLORER           0x7656
#define IDS_MHTML_FILTER                0x7657

#define IDS_NOHTML_SELECTED             0x7658
#define IDS_URL_EXTENSION               0x7659
#define IDS_CONFIRM_OVERWRITE_SUBSCR    0x765a
#define IDS_CONFIRM_RESET_SAFEMODE      0x765b
#define IDS_WPNONE                      0x765c
#define IDS_CONFIRM_TURNINGON_AD        0x765d // Not for the confirm close dialogs!
#define IDS_MENU_SUBSCRIBE_DESKCOMP     0x765e
#define IDS_YOULOSE                     0x765f

#define IDS_CMTF_COPYTO                 0x7660
#define IDS_CMTF_MOVETO                 0x7661
#define IDS_CMTF_COPY_DLG_TITLE         0x7662 //cmtf <=> CopyMoveToFolder
#define IDS_CMTF_MOVE_DLG_TITLE         0x7663
//#define IDS_CMTF_COPYORMOVE_DLG_TITLE 0x7677
#define IDS_CMTF_ERRORMSG               0x7664

#define IDS_CABINET                     0x7665
#define IDS_CANTFINDDIR                 0x7666

#define ACCEL_DESKTOP           3
#define IDS_MENU_RESET                  0x7667

#define IDS_SENDLINKTO                  0x7668
#define IDS_SENDPAGETO                  0x7669
#define IDS_SENDTO_ERRORMSG             0x766a

#define IDS_NEWMENU             0x766b
#define IDS_NEWFILEPREFIX       0x766c
#define IDS_NEWFOLDER           0x766d
#define IDS_NEWLINK             0x766e
#define IDS_FOLDERTEMPLATE      0x766f
#define IDS_FOLDERLONGPLATE     0x7670
#define IDS_NEWLINKTEMPLATE     0x7671
#define IDS_NEWFILE_ERROR_TITLE 0x7672
#define IDS_MY_CURRENT_HOMEPAGE 0x7673
#define IDS_FIND_MNEMONIC       0x7674  // Old Accelerator -- warning! used by explorer.exe directly
#define IDS_CONNECTING          0x7675 
#define IDS_INFOTIP             0x7676  // Used by the shell automation object
#define IDS_CMTF_COPYORMOVE_DLG_TITLE   0x7677

#define IDS_COMP_ICW_ADD                0x7678
#define IDS_COMP_ICW_DISABLE            0x7679
#define IDS_COMP_ICW_TOGGLE             0x767A
#define IDS_COMP_ICW_TITLE              0x767B

#define IDS_NEWHELP_FIRST       0x767C
#define IDS_NEWHELP_FOLDER      0x767C
#define IDS_NEWHELP_LINK        0x767D


// Start Menu Info Tips.
#define IDS_PROGRAMS_TIP        0x7680
#define IDS_FAVORITES_TIP       0x7681
#define IDS_RECENT_TIP          0x7682
#define IDS_SETTINGS_TIP        0x7683
#define IDS_FIND_TIP            0x7684
#define IDS_HELP_TIP            0x7685
#define IDS_RUN_TIP             0x7686
#define IDS_LOGOFF_TIP          0x7687
#define IDS_EJECT_TIP           0x7688
#define IDS_SHUTDOWN_TIP        0x7689
#define IDS_CONTROL_TIP         0x768A
#define IDS_PRINTERS_TIP        0x768B
#define IDS_TRAYPROP_TIP        0x768C
#define IDS_MYDOCS_TIP          0x768D
#define IDS_NETCONNECT_TIP      0x768E
#define IDS_CHEVRONTIPTITLE     0x768F
#define IDS_CHEVRONTIP          0x7690
#define IDS_ALL_PICTURES        0x76A0
#define IDS_ALL_HTML            0x76A1
#define IDS_HTMLDOC             0x76A2
#define IDS_PROPSHEET_TITLE     0x76A3
//#define UNUSED - RECYCLE ME   0x76A4
#define IDS_MYPICS_TIP          0x76A5
#define IDS_THEMES_SUBDIR       0x76A6

#define IDS_CMTF_COPY_DLG_TITLE2 0x76a7
#define IDS_CMTF_MOVE_DLG_TITLE2 0x76a8
#define IDS_CMTF_COPY_MULTIPLE_DLG_TITLE2 0x76a9
#define IDS_CMTF_MOVE_MULTIPLE_DLG_TITLE2 0x76aa
#define IDS_CMTF_CAPTION_COPY    0x76ab
#define IDS_CMTF_CAPTION_MOVE    0x76ac

#define IDS_FULL                 0x76b0
#define IDS_EMPTY2               0x76b1
#define IDS_MYCOMPUTER           0x76b2
#define IDS_NETNEIGHBOUR         0x76b3
#define IDS_TRASHFULL            0x76b4
#define IDS_TRASHEMPTY           0x76b5
#define IDS_TRASHDEFAULT         0x76b6
#define IDS_MYDOCUMENTS2         0x76b7

#define IDC_COMP_CLEANUP_GROUP   0x7700

// Still more constants moved (and renumbered) from shdocvw\resource.h

//#define IDS_COMPSETTINGS              xxxxxx // already in shell32\resource.h

// More constants moved (and renumbered) from shdocvw\resource.h

#define MENU_DESKCOMP_CONTEXTMENU       400
#define MENU_STARTMENU_MYDOCS           401
#define MENU_STARTMENU_OPENFOLDER       402
// NOTE: raymondc - This used to be at FCIDM_BROWSER_EXPLORE+0x240.
// What does that mean?  Is that number special?  I just gave it a new
// number.
#define IDM_DCCM_FIRST          0xA100
#define DCCM_MENUITEMS          20  //  reserved space for Desktop Component Menu items
#define IDM_DCCM_OPEN           (IDM_DCCM_FIRST+0x01)
#define IDM_DCCM_OFFLINE        (IDM_DCCM_FIRST+0x02)
#define IDM_DCCM_SYNCHRONIZE    (IDM_DCCM_FIRST+0x03)
#define IDM_DCCM_PROPERTIES     (IDM_DCCM_FIRST+0x04)
#define IDM_DCCM_CUSTOMIZE      (IDM_DCCM_FIRST+0x08)
#define IDM_DCCM_CLOSE          (IDM_DCCM_FIRST+0x09)
#define IDM_DCCM_FULLSCREEN     (IDM_DCCM_FIRST+0x0a)
#define IDM_DCCM_SPLIT          (IDM_DCCM_FIRST+0x0b)
#define IDM_DCCM_RESTORE        (IDM_DCCM_FIRST+0x0c)
#define IDM_DCCM_LASTCOMPITEM   (IDM_DCCM_FIRST+DCCM_MENUITEMS)

#define IDM_MYDOCUMENTS         516
#define IDM_OPEN_FOLDER         517
#define IDM_MYPICTURES          518


// Bitmap IDs

#define IDB_MONITOR             0x135
#define IDB_WIZARD              0x136

// These numbers are for CShellDispatch (sdmain.cpp) to send
// messages to the tray.

//The following value is taken from  shdocvw\rcids.h
#ifndef FCIDM_REFRESH
#define FCIDM_REFRESH  0xA220
#endif // FCIDM_REFRESH

#define FCIDM_BROWSER_VIEW      (FCIDM_BROWSERFIRST+0x0060)
#define FCIDM_BROWSER_TOOLS     (FCIDM_BROWSERFIRST+0x0080)

#define FCIDM_STOP              (FCIDM_BROWSER_VIEW + 0x001a)
#define FCIDM_ADDTOFAVNOUI      (FCIDM_BROWSER_VIEW + 0x0021)
#define FCIDM_VIEWITBAR         (FCIDM_BROWSER_VIEW + 0x0022)
#define FCIDM_VIEWSEARCH        (FCIDM_BROWSER_VIEW + 0x0017)
#define FCIDM_CUSTOMIZEFOLDER   (FCIDM_BROWSER_VIEW + 0x0018)
#define FCIDM_VIEWFONTS         (FCIDM_BROWSER_VIEW + 0x0019)
// 1a is FCIDM_STOP
#define FCIDM_THEATER           (FCIDM_BROWSER_VIEW + 0x001b)        
#define FCIDM_JAVACONSOLE       (FCIDM_BROWSER_VIEW + 0x001c)

#define FCIDM_BROWSER_EDIT      (FCIDM_BROWSERFIRST+0x0040)
#define FCIDM_MOVE              (FCIDM_BROWSER_EDIT+0x0001)
#define FCIDM_COPY              (FCIDM_BROWSER_EDIT+0x0002)
#define FCIDM_PASTE             (FCIDM_BROWSER_EDIT+0x0003)
#define FCIDM_SELECTALL         (FCIDM_BROWSER_EDIT+0x0004)
#define FCIDM_LINK              (FCIDM_BROWSER_EDIT+0x0005)     // create shortcut
#define FCIDM_EDITPAGE          (FCIDM_BROWSER_EDIT+0x0006)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\sendto.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include <oleacc.h>     // MSAAMENUINFO stuff
#include <runtask.h>
#include "datautil.h"
#include "idlcomm.h"
#include "stgutil.h"
#include <winnls.h>
#include "filetbl.h"
#include "cdburn.h"
#include "mtpt.h"

#ifndef CMF_DVFILE
#define CMF_DVFILE       0x00010000     // "File" pulldown
#endif

class CSendToMenu : public IContextMenu3, IShellExtInit, IOleWindow
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);
    
    // IContextMenu2
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *lResult);

    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);
    
    // IOleWindow
    STDMETHOD(GetWindow)(HWND *phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode) {return E_NOTIMPL;};

private:    
    CSendToMenu();
    ~CSendToMenu();

    LONG    _cRef;
    HMENU   _hmenu;
    UINT    _idCmdFirst;
    BOOL    _bFirstTime;
    HWND    _hwnd;
    IDataObject *_pdtobj;
    LPITEMIDLIST _pidlLast;

    DWORD _GetKeyState(void);
    HRESULT _DoDragDrop(HWND hwndParent, IDropTarget *pdrop);
    BOOL _CanDrop(IShellFolder *psf, LPCITEMIDLIST pidl);
    HRESULT _MenuCallback(UINT fmm, IShellFolder *psf, LPCITEMIDLIST pidl);
    HRESULT _RemovableDrivesMenuCallback(UINT fmm, IShellFolder *psf, LPCITEMIDLIST pidl);
    static HRESULT CALLBACK s_MenuCallback(UINT fmm, LPARAM lParam, IShellFolder *psf, LPCITEMIDLIST pidl);
    static HRESULT CALLBACK s_RemovableDrivesMenuCallback(UINT fmm, LPARAM lParam, IShellFolder *psf, LPCITEMIDLIST pidl);
    
    friend HRESULT CSendToMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut);
};

CSendToMenu::CSendToMenu() : _cRef(1) 
{
    DllAddRef();
}

CSendToMenu::~CSendToMenu()
{
    if (_hmenu)
        FileMenu_DeleteAllItems(_hmenu);
    
    if (_pdtobj)
        _pdtobj->Release();

    ILFree(_pidlLast);
    DllRelease();
}

HRESULT CSendToMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hr = E_OUTOFMEMORY;
    CSendToMenu *pstm = new CSendToMenu();
    if (pstm) 
    {
        hr = pstm->QueryInterface(riid, ppvOut);
        pstm->Release();
    }
    return hr;
}

HRESULT CSendToMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSendToMenu, IShellExtInit),                     // IID_IShellExtInit
        QITABENT(CSendToMenu, IOleWindow),                        // IID_IOleWindow
        QITABENT(CSendToMenu, IContextMenu3),                     // IID_IContextMenu3
        QITABENTMULTI(CSendToMenu, IContextMenu2, IContextMenu3), // IID_IContextMenu2
        QITABENTMULTI(CSendToMenu, IContextMenu, IContextMenu3),  // IID_IContextMenu
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CSendToMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CSendToMenu::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

HRESULT CSendToMenu::GetWindow(HWND *phwnd)
{
    HRESULT hr = E_INVALIDARG;

    if (phwnd)
    {
        *phwnd = _hwnd;
        hr = S_OK;
    }

    return hr;
}

HRESULT CSendToMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    // if they want the default menu only (CMF_DEFAULTONLY) OR 
    // this is being called for a shortcut (CMF_VERBSONLY)
    // we don't want to be on the context menu
    
    if (uFlags & (CMF_DEFAULTONLY | CMF_VERBSONLY))
        return S_OK;
    
    UINT idMax = idCmdFirst;
    
    _hmenu = CreatePopupMenu();
    if (_hmenu)
    {
        TCHAR szSendLinkTo[80];
        TCHAR szSendPageTo[80];
        MENUITEMINFO mii;
        
        // add a dummy item so we are identified at WM_INITMENUPOPUP time
        
        LoadString(g_hinst, IDS_SENDLINKTO, szSendLinkTo, ARRAYSIZE(szSendLinkTo));
        LoadString(g_hinst, IDS_SENDPAGETO, szSendPageTo, ARRAYSIZE(szSendPageTo));
        
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.dwTypeData = szSendLinkTo;
        mii.wID = idCmdFirst + 1;
        
        if (InsertMenuItem(_hmenu, 0, TRUE, &mii))
        {
            _idCmdFirst = idCmdFirst + 1;   // remember this for later
            
            mii.fType = MFT_STRING;
            mii.dwTypeData = szSendLinkTo;
            mii.wID = idCmdFirst;
            mii.fState = MF_DISABLED | MF_GRAYED;
            mii.fMask = MIIM_TYPE | MIIM_SUBMENU | MIIM_ID;
            mii.hSubMenu = _hmenu;
            
            if (InsertMenuItem(hmenu, indexMenu, TRUE, &mii))
            {
                idMax += 0x40;      // reserve space for this many items
                _bFirstTime = TRUE; // fill this at WM_INITMENUPOPUP time
            }
            else
            {
                _hmenu = NULL;
            }
        }
    }
    _hmenu = NULL;
    return ResultFromShort(idMax - idCmdFirst);
}

DWORD CSendToMenu::_GetKeyState(void)
{
    DWORD grfKeyState = MK_LBUTTON; // default

    if (GetAsyncKeyState(VK_CONTROL) < 0)
        grfKeyState |= MK_CONTROL;

    if (GetAsyncKeyState(VK_SHIFT) < 0)
        grfKeyState |= MK_SHIFT;

    if (GetAsyncKeyState(VK_MENU) < 0)
        grfKeyState |= MK_ALT;          // menu's don't really allow this
    
    return grfKeyState;
}

HRESULT CSendToMenu::_DoDragDrop(HWND hwndParent, IDropTarget *pdrop)
{

    DWORD grfKeyState = _GetKeyState();
    if (grfKeyState == MK_LBUTTON)
    {
        // no modifieres, change default to COPY
        grfKeyState = MK_LBUTTON | MK_CONTROL;
        DataObj_SetDWORD(_pdtobj, g_cfPreferredDropEffect, DROPEFFECT_COPY);
    }

    _hwnd = hwndParent;
    IUnknown_SetSite(pdrop, SAFECAST(this, IOleWindow *));  // Let them have access to our HWND.
    HRESULT hr = SHSimulateDrop(pdrop, _pdtobj, grfKeyState, NULL, NULL);
    IUnknown_SetSite(pdrop, NULL);

    if (hr == S_FALSE)
    {
        ShellMessageBox(g_hinst, hwndParent, 
                        MAKEINTRESOURCE(IDS_SENDTO_ERRORMSG),
                        MAKEINTRESOURCE(IDS_CABINET), 
                        MB_OK|MB_ICONEXCLAMATION);
    }                    
    return hr;
}

HRESULT CSendToMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr;
    
    if (_pdtobj && _pidlLast)
    {
        IDropTarget *pdrop;
        hr = SHGetUIObjectFromFullPIDL(_pidlLast, pici->hwnd, IID_PPV_ARG(IDropTarget, &pdrop));
        if (SUCCEEDED(hr))
        {
            hr = _DoDragDrop(pici->hwnd, pdrop);
            pdrop->Release();
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

HRESULT CSendToMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

HRESULT CSendToMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg, wParam, lParam, NULL);
}

BOOL CSendToMenu::_CanDrop(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    BOOL fCanDrop = FALSE;
    IDropTarget *pdt;
    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&pidl, IID_X_PPV_ARG(IDropTarget, 0, &pdt))))
    {
        POINTL pt = {0};
        DWORD dwEffect = DROPEFFECT_COPY;

        // Do a drag enter, if they return no drop effect then we can't drop
        if (SUCCEEDED(pdt->DragEnter(_pdtobj, _GetKeyState(), pt, &dwEffect)))
        {
            if (dwEffect != DROPEFFECT_NONE)
                fCanDrop = TRUE;  // show it!
            pdt->DragLeave();        
        }
        pdt->Release();
    }
    return fCanDrop;
}

HRESULT CSendToMenu::_MenuCallback(UINT fmm, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    switch (fmm)
    {
    case FMM_ADD:
        hr = _CanDrop(psf, pidl) ? S_OK : S_FALSE;
        break;

    case FMM_SETLASTPIDL:
        Pidl_Set(&_pidlLast, pidl);
        break;

    default:
        hr = E_FAIL;
    }
    return hr;
}

HRESULT CSendToMenu::_RemovableDrivesMenuCallback(UINT fmm, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    switch (fmm)
    {
    case FMM_ADD:
        hr = S_FALSE; // assume we wont show it
        if (_CanDrop(psf, pidl))
        {
            // now we know it's a removable drive.  in general we dont want to display cd-rom drives.
            // we know this is the my computer folder so just get the parsing name, we need it for GetDriveType.
            WCHAR szDrive[MAX_PATH];
            if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_FORPARSING, szDrive, ARRAYSIZE(szDrive))))
            {
                CMountPoint *pmtpt = CMountPoint::GetMountPoint(szDrive);
                if (pmtpt)
                {
                    if (pmtpt->IsCDROM())
                    {
                        // of all cdroms, only the enabled burning folder is okay to put on sendto
                        WCHAR szRecorder[4];
                        if (SUCCEEDED(CDBurn_GetRecorderDriveLetter(szRecorder, ARRAYSIZE(szRecorder))) &&
                            (lstrcmpiW(szRecorder, szDrive) == 0))
                        {
                            hr = S_OK;
                        }
                    }
                    else if (pmtpt->IsFloppy() || pmtpt->IsStrictRemovable() || pmtpt->IsRemovableDevice())
                    {
                        // also put on removable devices.
                        hr = S_OK;
                    }
                    pmtpt->Release();
                }
                else
                {
                    // if this failed it could be a memory condition but its more likely to be that the
                    // parsing name doesnt map to a mountpoint.  in that case fall back to SFGAO_REMOVABLE
                    // to pick up portable audio devices.  if this was because of lowmem its no biggie.
                    if (SHGetAttributes(psf, pidl, SFGAO_REMOVABLE))
                    {
                        hr = S_OK;
                    }
                }
            }
        }
        break;

    case FMM_SETLASTPIDL:
        Pidl_Set(&_pidlLast, pidl);
        break;

    default:
        hr = E_FAIL;
    }
    return hr;
}

HRESULT CSendToMenu::s_MenuCallback(UINT fmm, LPARAM lParam, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return ((CSendToMenu*)lParam)->_MenuCallback(fmm, psf, pidl);
}

HRESULT CSendToMenu::s_RemovableDrivesMenuCallback(UINT fmm, LPARAM lParam, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return ((CSendToMenu*)lParam)->_RemovableDrivesMenuCallback(fmm, psf, pidl);
}

HRESULT GetFolder(int csidl, IShellFolder **ppsf)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, csidl, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, ppsf));
        ILFree(pidl);
    }
    return hr;
}

HRESULT CSendToMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = S_OK;
    LRESULT lRes = 0;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        if (_bFirstTime)
        {
            _bFirstTime = FALSE;
            
            //In case of Shell_MergeMenus
            if (_hmenu == NULL)
                _hmenu = (HMENU)wParam;

            // delete the dummy entry
            DeleteMenu(_hmenu, 0, MF_BYPOSITION);

            FMCOMPOSE fmc = {0};
            if (SUCCEEDED(GetFolder(CSIDL_SENDTO, &fmc.psf)))
            {
                fmc.idCmd = _idCmdFirst;
                fmc.grfFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
                fmc.pfnCallback = s_MenuCallback;
                fmc.lParam = (LPARAM)this;              // not reference counted
                                    
                FileMenu_Compose(_hmenu, FMCM_REPLACE, &fmc);                    
                fmc.psf->Release();
            }
            if (SUCCEEDED(GetFolder(CSIDL_DRIVES, &fmc.psf)))
            {
                fmc.dwMask = FMC_NOEXPAND;
                fmc.idCmd = _idCmdFirst;
                fmc.grfFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
                fmc.pfnCallback = s_RemovableDrivesMenuCallback;
                fmc.lParam = (LPARAM)this;              // not reference counted
                                    
                FileMenu_Compose(_hmenu, FMCM_APPEND, &fmc);                    
                fmc.psf->Release();
            }
        }
        else if (_hmenu != (HMENU)wParam)
        {
            // secondary cascade menu
            FileMenu_InitMenuPopup((HMENU)wParam);
        }
        break;
        
    case WM_DRAWITEM:
        {
            DRAWITEMSTRUCT *pdi = (DRAWITEMSTRUCT *)lParam;
            
            if (pdi->CtlType == ODT_MENU && pdi->itemID == _idCmdFirst) 
            {
                lRes = FileMenu_DrawItem(NULL, pdi);
            }
        }
        break;
        
    case WM_MEASUREITEM:
        {
            MEASUREITEMSTRUCT *pmi = (MEASUREITEMSTRUCT *)lParam;
            
            if (pmi->CtlType == ODT_MENU && pmi->itemID == _idCmdFirst) 
            {
                lRes = FileMenu_MeasureItem(NULL, pmi);
            }
        }
        break;

    case WM_MENUCHAR:
        {
            TCHAR ch = (TCHAR)LOWORD(wParam);
            HMENU hmenu = (HMENU)lParam;
            lRes = FileMenu_HandleMenuChar(hmenu, ch);
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    if (plResult)
        *plResult = lRes;

    return hr;
}

HRESULT CSendToMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);
    return S_OK;
}

#define TARGETMENU
#ifdef TARGETMENU

class CTargetMenu : public IShellExtInit, public IContextMenu3
{
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);
    
    // IContextMenu2
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *lResult);

    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);
    
    HRESULT GetTargetMenu();
    
    ~CTargetMenu();
    CTargetMenu();
    
    LONG _cRef;
    HMENU _hmenu;
    UINT _idCmdFirst;
    BOOL _bFirstTime;
    
    IDataObject *_pdtobj;
    LPITEMIDLIST _pidlTarget;
    IContextMenu *_pcmTarget;
    
    friend HRESULT CTargetMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut);
};

CTargetMenu::CTargetMenu() : _cRef(1) 
{
}

CTargetMenu::~CTargetMenu()
{
    ILFree(_pidlTarget);
    
    if (_pcmTarget)
        _pcmTarget->Release();

    if (_pdtobj)
        _pdtobj->Release();
}

STDMETHODIMP CTargetMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTargetMenu, IShellExtInit),                     // IID_IShellExtInit
        QITABENT(CTargetMenu, IContextMenu3),                     // IID_IContextMenu3
        QITABENTMULTI(CTargetMenu, IContextMenu2, IContextMenu3), // IID_IContextMenu2
        QITABENTMULTI(CTargetMenu, IContextMenu, IContextMenu3),  // IID_IContextMenu
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CTargetMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CTargetMenu::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

STDMETHODIMP CTargetMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);
    return S_OK;
}

HRESULT CTargetMenu::GetTargetMenu()
{
    HRESULT hr = E_FAIL;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(_pdtobj, &medium);
    if (pida)
    {
        IShellFolder *psf;
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, IDA_GetIDListPtr(pida, -1), &psf));
        if (SUCCEEDED(hr))
        {
            IShellLink *psl;
            LPCITEMIDLIST pidl = IDA_GetIDListPtr(pida, 0);
            hr = psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&pidl, IID_X_PPV_ARG(IShellLink, NULL, &psl));
            if (SUCCEEDED(hr))
            {
                ASSERT(NULL == _pidlTarget);
                hr = psl->GetIDList(&_pidlTarget);
                if (SUCCEEDED(hr) && _pidlTarget) 
                {
                    hr = SHGetUIObjectFromFullPIDL(_pidlTarget, NULL, IID_PPV_ARG(IContextMenu, &_pcmTarget));
                }
                else
                    hr = E_FAIL;
                psl->Release();
            }
            psf->Release();
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return hr;
}

#define IDS_CONTENTSMENU    3
#define IDS_TARGETMENU      4

#define IDC_OPENCONTAINER   1
#define IDC_TARGET_LAST     1
#define NUM_TARGET_CMDS     0x40

STDMETHODIMP CTargetMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    if (uFlags & CMF_DEFAULTONLY)
        return S_OK;
    
    UINT idMax = idCmdFirst;
    
    _hmenu = CreatePopupMenu();
    if (_hmenu)
    {
        TCHAR szString[80];
        MENUITEMINFO mii;
        
        // Add an open container menu item...
        lstrcpyn(szString, TEXT("Open Container"), ARRAYSIZE(szString));
        
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.dwTypeData = szString;
        mii.wID = idCmdFirst + IDC_OPENCONTAINER;
        
        if (InsertMenuItem(_hmenu, 0, TRUE, &mii))
        {
            _idCmdFirst = idCmdFirst;
            
            SetMenuDefaultItem(_hmenu, 0, TRUE);
            InsertMenu(hmenu, 1, MF_BYPOSITION | MF_SEPARATOR, (UINT)-1, NULL);
            
            // Insert our context menu....
            lstrcpyn(szString, TEXT("Target"), ARRAYSIZE(szString));
            
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
            mii.fType = MFT_STRING;
            mii.dwTypeData = szString;
            mii.wID = idCmdFirst;
            mii.fState = MF_DISABLED|MF_GRAYED;
            mii.fMask = MIIM_TYPE | MIIM_SUBMENU;
            mii.hSubMenu = _hmenu;
            
            if (InsertMenuItem(hmenu, indexMenu, TRUE, &mii))
            {
                idMax += NUM_TARGET_CMDS;    // reserve space for this many items
                _bFirstTime = TRUE; // fill this at WM_INITMENUPOPUP time
            }
            else
            {
                DestroyMenu(_hmenu);
                _hmenu = NULL;
            }
        }
    }
    return ResultFromShort(idMax - idCmdFirst);
}

STDMETHODIMP CTargetMenu::InvokeCommand(LPCMINVOKECOMMANDINFO lpici) 
{
    UINT idCmd = LOWORD(lpici->lpVerb);
    
    switch (idCmd) 
    {
    case IDC_OPENCONTAINER:
        SHOpenFolderAndSelectItems(_pidlTarget, 0, NULL, 0);
        break;
        
    default:
        CMINVOKECOMMANDINFO ici = {
            sizeof(ici),
                lpici->fMask,
                lpici->hwnd,
                (LPCSTR)MAKEINTRESOURCE(idCmd - IDC_OPENCONTAINER),
                lpici->lpParameters, 
                lpici->lpDirectory,
                lpici->nShow,
        };
        
        return _pcmTarget->InvokeCommand(&ici);
    }
    return S_OK;
}

HRESULT CTargetMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTargetMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg, wParam, lParam, NULL);
}


STDMETHODIMP CTargetMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = S_OK;
    LRESULT lResult = 0;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        if (_hmenu == (HMENU)wParam)
        {
            if (_bFirstTime)
            {
                _bFirstTime = FALSE;
                
                if (SUCCEEDED(GetTargetMenu()))
                {
                    _pcmTarget->QueryContextMenu(_hmenu, IDC_TARGET_LAST, 
                        _idCmdFirst + IDC_TARGET_LAST, 
                        _idCmdFirst - IDC_TARGET_LAST + NUM_TARGET_CMDS, CMF_NOVERBS);
                }
            }
            break;
        }
        
        // fall through... to pass on sub menu WM_INITMENUPOPUPs
        
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
        hr = SHForwardContextMenuMsg(_pcmTarget, uMsg, wParam, lParam, &lResult, TRUE);
        break;

    default:
        hr = E_FAIL;
        break;
    }

    if (plResult)
        *plResult = lResult;

    return hr;
}

HRESULT CTargetMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hr = E_OUTOFMEMORY;
    CTargetMenu *ptm = new CTargetMenu();
    if (ptm) 
    {
        hr = ptm->QueryInterface(riid, ppvOut);
        ptm->Release();
    }
    return hr;
}

#endif  // TARGETMENU


#ifdef CONTENT

#define IDC_ITEMFIRST (IDC_PRESSMOD + 10)
#define MENU_TIMEOUT (1000)

#define DPA_LAST    0x7fffffff

class CHIDA
{
public:
    CHIDA(HGLOBAL hIDA, IUnknown *punk)
    {
        _punk = punk;
        _hIDA = hIDA;
        _pIDA = (LPIDA)GlobalLock(hIDA);
    }
    ~CHIDA() 
    {
        GlobalUnlock(_hObj);
        
        if (_punk) 
            _punk->Release();
        else
            GlobalFree(_hIDA);
        
    }
    
    LPCITEMIDLIST operator [](UINT nIndex)
    {
        if (nIndex > _pIDA->cidl)
            return(NULL);
        
        return (LPCITEMIDLIST)(((BYTE *)_pIDA) + _pIDA->aoffset[nIndex]);
    }
    
private:
    HGLOBAL _hIDA;
    LPIDA _pIDA;
    IUnknown *_punk;
};


class CVoidArray
{
public:
    CVoidArray() : _dpa(NULL), _dsa(NULL) {}
    ~CVoidArray()
    {
        if (_dpa)
        {
            DPA_Destroy(_dpa);
        }
        if (_dsa)
        {
            DSA_Destroy(_dsa);
        }
    }
    
    void *operator[](int i);
    
    BOOL Init(UINT uSize, UINT uJump);
    
    BOOL Add(void *pv);
    
    void Sort(PFNDPACOMPARE pfnCompare, LPARAM lParam)
    {
        _pfnCompare = pfnCompare;
        _lParam = lParam;
        
        DPA_Sort(_dpa, ArrayCompare, (LPARAM)this);
    }
    
private:
    static int CALLBACK ArrayCompare(void *pv1, void *pv2, LPARAM lParam);
    
    HDPA _dpa;
    HDSA _dsa;
    
    PFNDPACOMPARE _pfnCompare;
    LPARAM void *;
};


_lParam CVoidArray::operator[](int i)
{
    if (!_dpa || i>=DPA_GetPtrCount(_dpa))
    {
        return(NULL);
    }
    
    return(DSA_GetItemPtr(_dsa, (int)DPA_GetPtr(_dpa, i)));
}


BOOL CVoidArray::Init(UINT uSize, UINT uJump)
{
    _dpa = DPA_Create(uJump);
    _dsa = DSA_Create(uSize, uJump);
    return(_dpa && _dsa);
}


BOOL CVoidArray::Add(void *pv)
{
    int iItem = DSA_InsertItem(_dsa, DPA_LAST, pv);
    if (iItem < 0)
    {
        return(FALSE);
    }
    
    if (DPA_InsertPtr(_dpa, DPA_LAST, (void *)iItem) < 0)
    {
        DSA_DeleteItem(_dsa, iItem);
        return(FALSE);
    }
    
    return(TRUE);
}


int CALLBACK CVoidArray::ArrayCompare(void *pv1, void *pv2, LPARAM lParam)
{
    CVoidArray *pThis = (CVoidArray *)lParam;
    
    return(pThis->_pfnCompare(DSA_GetItemPtr(pThis->_dsa, (int)pv1),
        DSA_GetItemPtr(pThis->_dsa, (int)pv2), pThis->_lParam));
}


class CContentItemData
{
public:
    CContentItemData() : _dwDummy(0) {Empty();}
    ~CContentItemData() {Free();}
    
    void Free();
    void Empty() {_pidl=NULL; _hbm=NULL;}
    
    // Here to work around a Tray menu bug
    DWORD _dwDummy;
    LPITEMIDLIST _pidl;
    HBITMAP _hbm;
};


void CContentItemData::Free()
{
    if (_pidl) ILFree(_pidl);
    if (_hbm) DeleteObject(_hbm);
    Empty();
}


class CContentItemDataArray : public CVoidArray
{
public:
    CContentItemDataArray(LPCITEMIDLIST pidlFolder) : _pidlFolder(pidlFolder) {}
    ~CContentItemDataArray();
    
    CContentItemData * operator[](int i) {return((CContentItemData*)(*(CVoidArray*)this)[i]);}
    
    HRESULT Init();
    BOOL Add(CContentItemData *pv) {return(CVoidArray::Add((void *)pv));}
    
private:
    static int CALLBACK DefaultSort(void *pv1, void *pv2, LPARAM lParam);
    
    HRESULT GetShellFolder(IShellFolder **ppsf);
    BOOL IsLocal();
    
    LPCITEMIDLIST CContentItemDataArray;
};


CContentItemDataArray::~CContentItemDataArray()
{
    for (int i=0;; ++i)
    {
        CContentItemData *pID = (*this)[i];
        if (!pID)
            break;
        pID->Free();
    }
}


int CALLBACK CContentItemDataArray::DefaultSort(void *pv1, void *pv2, LPARAM lParam)
{
    IShellFolder *psfFolder = (IShellFolder *)lParam;
    CContentItemData *pID1 = (CContentItemData *)pv1;
    CContentItemData *pID2 = (CContentItemData *)pv2;
    
    HRESULT hRes = psfFolder->CompareIDs(0, pID1->_pidl, pID2->_pidl);
    if (FAILED(hRes))
    {
        return(0);
    }
    
    return((short)ShortFromResult(hRes));
}

HRESULT CContentItemDataArray::GetShellFolder(IShellFolder **ppsf)
{
    IShellFolder *psfDesktop;
    HRESULT hRes = CoCreateInstance(CLSID_ShellDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellFolder, &psfDesktop));
    if (FAILED(hRes))
    {
        return hRes;
    }
    CEnsureRelease erDesktop(psfDesktop);
    
    return psfDesktop->BindToObject(_pidlFolder, NULL, IID_PPV_ARG(IShellFolder, ppsf));
}

BOOL CContentItemDataArray::IsLocal()
{
    TCHAR szPath[MAX_PATH];
    
    if (!SHGetPathFromIDList(_pidlFolder, szPath))
    {
        return(FALSE);
    }
    
    CharUpper(szPath);
    return(DriveType(szPath[0]-'A') == DRIVE_FIXED);
}


HRESULT CContentItemDataArray::Init()
{
    if (!IsLocal() && !(GetKeyState(VK_SHIFT)&0x8000))
    {
        return(S_FALSE);
    }
    
    if (!CVoidArray::Init(sizeof(CContentItemData), 16))
    {
        return(E_OUTOFMEMORY);
    }
    
    IShellFolder *psfFolder;
    HRESULT hRes = GetShellFolder(&psfFolder);
    if (FAILED(hRes))
    {
        return(hRes);
    }
    CEnsureRelease erFolder(psfFolder);
    
    IEnumIDList *penumFolder;
    hRes = psfFolder->EnumObjects(NULL,
        SHCONTF_FOLDERS|SHCONTF_NONFOLDERS|SHCONTF_INCLUDEHIDDEN, &penumFolder);
    if (S_OK != hRes)
    {
        return FAILED(hRes) ? hRes : E_FAIL; //in case of S_FALSE enumerator is NULL so nothing will be in the menu, just return failure
    }
    CEnsureRelease erEnumFolder(penumFolder);
    
    ULONG cNum;
    
    DWORD dwStart = 0;
    hRes = S_OK;
    
    for (;;)
    {
        CContentItemData cID;
        if (penumFolder->Next(1, &cID._pidl, &cNum)!=S_OK || cNum!=1)
        {
            // Just in case
            cID.Empty();
            break;
        }
        
        if (!dwStart)
        {
            dwStart = GetTickCount();
        }
        else if (!(GetAsyncKeyState(VK_SHIFT)&0x8000)
            && GetTickCount()-dwStart>MENU_TIMEOUT)
        {
            // Only go for 2 seconds after the first Next call
            hRes = S_FALSE;
            break;
        }
        
        CMenuDraw mdItem(_pidlFolder, cID._pidl);
        cID._hbm = mdItem.CreateBitmap(TRUE);
        if (!cID._hbm)
        {
            continue;
        }
        
        if (!Add(&cID))
        {
            break;
        }
        
        // Like a Detach(); Make sure we do not free stuff
        cID.Empty();
    }
    
    Sort(DefaultSort, (LPARAM)psfFolder);
    
    return(hRes);
}


class CContentItemInfo : public tagMENUITEMINFOA
{
public:
    CContentItemInfo(UINT fMsk) {fMask=fMsk; cbSize=sizeof(MENUITEMINFO);}
    ~CContentItemInfo() {}
    
    BOOL GetMenuItemInfo(HMENU hm, int nID, BOOL bByPos)
    {
        return(::GetMenuItemInfo(hm, nID, bByPos, this));
    }
    
    CContentItemData *GetItemData() {return((CContentItemData*)dwItemData);}
    void SetItemData(CContentItemData *pd) {dwItemData=(DWORD)pd; fMask|=MIIM_DATA;}
    
    HBITMAP GetBitmap() {return(fType&MFT_BITMAP ? dwTypeData : NULL);}
    void SetBitmap(HBITMAP hb) {dwTypeData=(LPSTR)hb; fType|=MFT_BITMAP;}
};

#define CXIMAGEGAP 6
#define CYIMAGEGAP 4

class CWindowDC
{
public:
    CWindowDC(HWND hWnd) : _hWnd(hWnd) {_hDC=GetDC(hWnd);}
    ~CWindowDC() {ReleaseDC(_hWnd, _hDC);}
    
    operator HDC() {return(_hDC);}
    
private:
    HDC _hDC;
    HWND _hWnd;
};


class CDCTemp
{
public:
    CDCTemp(HDC hDC) : _hDC(hDC) {}
    ~CDCTemp() {if (_hDC) DeleteDC(_hDC);}
    
    operator HDC() {return(_hDC);}
    
private:
    HDC _hDC;
};


class CRefMenuFont
{
public:
    CRefMenuFont(CMenuDraw *pmd) {_pmd = pmd->InitMenuFont() ? pmd : NULL;}
    ~CRefMenuFont() {if (_pmd) _pmd->ReleaseMenuFont();}
    
    operator BOOL() {return(_pmd != NULL);}
    
private:
    CMenuDraw *_pmd;
};


BOOL CMenuDraw::InitMenuFont()
{
    if (_cRefFont.GetRef())
    {
        _cRefFont.AddRef();
        return(TRUE);
    }
    
    NONCLIENTMETRICS ncm;
    ncm.cbSize = sizeof(ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm),
        (void far *)(LPNONCLIENTMETRICS)&ncm, FALSE);
    
    _hfMenu = CreateFontIndirect(&ncm.lfMenuFont);
    if (_hfMenu)
    {
        _cRefFont.AddRef();
        return TRUE;
    }
    return FALSE;
}


void CMenuDraw::ReleaseMenuFont()
{
    if (_cRefFont.Release())
    {
        return;
    }
    
    DeleteObject(_hfMenu);
    _hfMenu = NULL;
}


BOOL CMenuDraw::InitStringAndIcon()
{
    if (!_pidlAbs)
    {
        return(FALSE);
    }
    
    if (_pszString)
    {
        return(TRUE);
    }
    
    SHFILEINFO sfi;
    
    if (!SHGetFileInfo((LPCSTR)_pidlAbs, 0, &sfi, sizeof(sfi),
        SHGFI_DISPLAYNAME | SHGFI_ICON | SHGFI_SMALLICON | SHGFI_PIDL))
    {
        return(FALSE);
    }
    
    if (!Str_SetPtr(&_pszString, sfi.szDisplayName))
    {
        DestroyIcon(sfi.hIcon);
    }
    
    _hiItem = sfi.hIcon;
    
    return(TRUE);
}


BOOL CMenuDraw::GetName(LPSTR szName)
{
    if (!InitStringAndIcon())
    {
        return(FALSE);
    }
    
    lstrcpyn(szName, _pszString, MAX_PATH);
    
    return(TRUE);
}


BOOL CMenuDraw::GetExtent(SIZE *pSize, BOOL bFull)
{
    if (!InitStringAndIcon())
    {
        return(FALSE);
    }
    
    CRefMenuFont crFont(this);
    if (!(BOOL)crFont)
    {
        return(FALSE);
    }
    
    HDC hDC = GetDC(NULL);
    HFONT hfOld = (HFONT)SelectObject(hDC, _hfMenu);
    
    BOOL bRet = GetTextExtentPoint32(hDC, _pszString, lstrlen(_pszString), pSize);
    
    if (hfOld)
    {
        SelectObject(hDC, hfOld);
    }
    ReleaseDC(NULL, hDC);
    
    if (bRet)
    {
        int cxIcon = GetSystemMetrics(SM_CXSMICON);
        int cyIcon = GetSystemMetrics(SM_CYSMICON);
        
        pSize->cy = max(pSize->cy, cyIcon);
        
        if (bFull)
        {
            pSize->cx += CXIMAGEGAP + GetSystemMetrics(SM_CXSMICON) + CXIMAGEGAP + CXIMAGEGAP;
            pSize->cy += CYIMAGEGAP;
        }
        else
        {
            pSize->cx = cxIcon;
        }
    }
    
    return(bRet);
}


BOOL CMenuDraw::DrawItem(HDC hDC, RECT *prc, BOOL bFull)
{
    RECT rc = *prc;
    int cxIcon = GetSystemMetrics(SM_CXSMICON);
    int cyIcon = GetSystemMetrics(SM_CYSMICON);
    
    FillRect(hDC, prc, GetSysColorBrush(COLOR_MENU));
    
    if (!InitStringAndIcon())
    {
        return(FALSE);
    }
    
    if (bFull)
    {
        rc.left += CXIMAGEGAP;
    }
    
    DrawIconEx(hDC, rc.left, rc.top + (rc.bottom-rc.top-cyIcon)/2, _hiItem,
        0, 0, 0, NULL, DI_NORMAL);
    
    if (!bFull)
    {
        // All done
        return(TRUE);
    }
    
    CRefMenuFont crFont(this);
    if (!(BOOL)crFont)
    {
        return(FALSE);
    }
    
    rc.left += cxIcon + CXIMAGEGAP;
    HFONT hfOld = SelectObject(hDC, _hfMenu);
    
    COLORREF crOldBk = SetBkColor  (hDC, GetSysColor(COLOR_MENU));
    COLORREF crOldTx = SetTextColor(hDC, GetSysColor(COLOR_MENUTEXT));
    
    DrawText(hDC, _pszString, -1, &rc,
        DT_VCENTER|DT_SINGLELINE|DT_LEFT|DT_NOCLIP);
    
    SetBkColor  (hDC, GetSysColor(crOldBk));
    SetTextColor(hDC, GetSysColor(crOldTx));
    
    if (hfOld)
    {
        SelectObject(hDC, hfOld);
    }
    
    return(TRUE);
}


HBITMAP CMenuDraw::CreateBitmap(BOOL bFull)
{
    SIZE size;
    
    // Reference font here so we do not create it twice
    CRefMenuFont crFont(this);
    if (!(BOOL)crFont)
    {
        return(FALSE);
    }
    
    if (!GetExtent(&size, bFull))
    {
        return(NULL);
    }
    
    CWindowDC wdcScreen(NULL);
    CDCTemp cdcTemp(CreateCompatibleDC(wdcScreen));
    if (!(HDC)cdcTemp)
    {
        return(NULL);
    }
    
    HBITMAP hbmItem = CreateCompatibleBitmap(wdcScreen, size.cx, size.cy);
    if (!hbmItem)
    {
        return(NULL);
    }
    
    HBITMAP hbmOld = (HBITMAP)SelectObject(cdcTemp, hbmItem);
    RECT rc = { 0, 0, size.cx, size.cy };
    BOOL bDrawn = DrawItem(cdcTemp, &rc, bFull);
    
    SelectObject(cdcTemp, hbmOld);
    
    if (!bDrawn)
    {
        DeleteObject(hbmItem);
        hbmItem = NULL;
    }
    
    return(hbmItem);
}


class CContentMenu : public IShellExtInit, public IContextMenu2
{
    CContentMenu();
    ~CContentMenu();
    
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);
    
    // IContextMenu2
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);
    
    static HMENU LoadPopupMenu(UINT id, UINT uSubMenu);
    HRESULT InitMenu();
    
    LPITEMIDLIST _pidlFolder;
    HMENU _hmItems;
    
    friend STDAPI CContentMenu_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
    
    class CContentItemDataArray *_pIDs;
};

CContentMenu::CContentMenu() : _pidlFolder(0), _hmItems(NULL), _pIDs(NULL)
{
}

CContentMenu::~CContentMenu()
{
    if (_pidlFolder)
        ILFree(_pidlFolder);
    
    if (_hmItems)
        DestroyMenu(_hmItems);
    
    if (_pIDs)
        delete _pIDs;
}

HRESULT CContentMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CContentMenu, IShellExtInit),                     // IID_IShellExtInit
        QITABENT(CContentMenu, IContextMenu3),                     // IID_IContextMenu3
        QITABENTMULTI(CContentMenu, IContextMenu2, IContextMenu3), // IID_IContextMenu2
        QITABENTMULTI(CSendToMenu, IContextMenu, IContextMenu3),  // IID_IContextMenu
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CContentMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CContentMenu::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

STDMETHODIMP CContentMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        _pidlFolder = IDA_FullIDList(pida, 0);
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return _pidlFolder ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CContentMenu::QueryContextMenu(HMENU hmenu,
                                            UINT indexMenu,
                                            UINT idCmdFirst,
                                            UINT idCmdLast,
                                            UINT uFlags)
{
    if (uFlags & CMF_DEFAULTONLY)
        return S_OK;

    HRESULE hr = E_OUTOFMEMORY;
    HMENU hmenuSub =  CreatePopupMenu();
    if (hmenuSub)
    {
        char szTitle[80];
        if (LoadString(g_hinst, IDS_CONTENTSMENU, szTitle, sizeof(szTitle)))
        {
            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
            mii.fType = MFT_STRING;
            mii.dwTypeData = szTitle;
            mii.wID = idCmdFirst + IDC_PRESSMOD;
            mii.fState = MF_DISABLED|MF_GRAYED;

            UINT idMax = mii.wID + 1;

            if (SUCCEEDED(InitMenu()))
            {
                UINT idM = Shell_MergeMenus(hmenuSub, _hmItems, 0, idCmdFirst, idCmdLast, 0);
                
                if (GetMenuItemCount(hmenuSub) > 0)
                {
                    mii.fMask = MIIM_TYPE | MIIM_SUBMENU;
                    mii.hSubMenu = hmenuSub;

                    idMax = idM;
                }
            }

            if (InsertMenuItem(hmenu, indexMenu, TRUE, &mii))
            {
                if (mii.fMask & MIIM_SUBMENU)
                {
                }

                hr = ResultFromShort(idMax - idCmdFirst);
            }
        }

        if (FAILED(hr))
            DestroyMenu(hmenuSub);
    }

    return hr;
}


STDMETHODIMP CContentMenu::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        return E_INVALIDARG;
    }
    
    UINT uID = (UINT)LOWORD((DWORD)lpici->lpVerb);
    switch (uID)
    {
    case IDC_PRESSMOD:
        ShellMessageBox(g_hinst, lpici->hwnd, MAKEINTRESOURCE(IDS_PRESSMOD),
            MAKEINTRESOURCE(IDS_THISDLL), MB_OK|MB_ICONINFORMATION);
        break;
        
    case IDC_SHIFTMORE:
        ShellMessageBox(g_hinst, lpici->hwnd, MAKEINTRESOURCE(IDS_SHIFTMORE),
            MAKEINTRESOURCE(IDS_THISDLL), MB_OK|MB_ICONINFORMATION);
        break;
        
    default:
        if (_hmItems)
        {
            CContentItemInfo mii(MIIM_DATA);
            
            if (!mii.GetMenuItemInfo(_hmItems, uID, FALSE))
                return E_INVALIDARG;
            
            CContentItemData *pData = mii.GetItemData();
            if (!pData || !pData->_pidl)
                return E_INVALIDARG;
            
            LPITEMIDLIST pidlAbs = ILCombine(_pidlFolder, pData->_pidl);
            if (!pidlAbs)
                return E_OUTOFMEMORY;
            
            SHELLEXECUTEINFO sei;
            
            sei.cbSize = sizeof(sei);
            sei.fMask = SEE_MASK_INVOKEIDLIST;
            sei.lpVerb = NULL;
            sei.hwnd         = lpici->hwnd;
            sei.lpParameters = lpici->lpParameters;
            sei.lpDirectory  = lpici->lpDirectory;
            sei.nShow        = lpici->nShow;
            sei.lpIDList = (void *)pidlAbs;
            
            ShellExecuteEx(&sei);
            
            ILFree(pidlAbs);
            
            break;
        }
        
        return(E_UNEXPECTED);
    }
    
    return S_OK;
}

STDMETHODIMP CContentMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

STDMETHODIMP CContentMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return E_NOTIMPL;
}

HRESULT CContentMenu::InitMenu()
{
    if (!_pidlFolder)
        return E_UNEXPECTED;
    
    if (_hmItems)
        return S_OK;
    
    if (_pIDs)
        return E_UNEXPECTED;
    
    _pIDs = new CContentItemDataArray(_pidlFolder);
    if (!_pIDs)
        return E_OUTOFMEMORY;
    
    HRESULT hRes = _pIDs->Init();
    if (FAILED(hRes))
        return hRes;
    
    BOOL bGotAll = (hRes == S_OK);
    
    _hmItems = CreatePopupMenu();
    if (!_hmItems)
        return E_OUTOFMEMORY;
    
    UINT cy = 0;
    BOOL bBitmaps = TRUE;
    
    if (!bGotAll)
    {
        HMENU hmenuMerge = LoadPopupMenu(MENU_ITEMCONTEXT, 1);
        if (hmenuMerge)
        {
            Shell_MergeMenus(_hmItems, hmenuMerge, 0, 0, 1000, 0);
            DestroyMenu(hmenuMerge);
        }
        else
            return E_OUTOFMEMORY;
    }
    
    for (int i=0;; ++i)
    {
        CContentItemData * pID = (*_pIDs)[i];
        if (!pID)
        {
            // All done
            break;
        }
        
        UINT id = IDC_ITEMFIRST + i;
        
        BITMAP bm;
        GetObject(pID->_hbm, sizeof(bm), &bm);
        
        cy += bm.bmHeight;
        
        if (i==0 && !bGotAll)
        {
            // Account for the menu item we added above
            cy += cy;
        }
        
        CContentItemInfo mii(MIIM_ID | MIIM_TYPE | MIIM_DATA);
        mii.fType = 0;
        mii.SetItemData(pID);
        mii.wID = id;
        
        if (cy >= (UINT)GetSystemMetrics(SM_CYSCREEN)*4/5)
        {
            // Put in a menu break when we fill 80% the screen
            mii.fType |= MFT_MENUBARBREAK;
            cy = bm.bmHeight;
            // bBitmaps = FALSE;
        }
        
        mii.SetBitmap(pID->_hbm);
        
        if (!InsertMenuItem(_hmItems, DPA_LAST, TRUE, &mii))
        {
            return(E_OUTOFMEMORY);
        }
    }
    
    return(_hmItems ? S_OK: HMENU);
}


HMENU CContentMenu::LoadPopupMenu(UINT id, UINT uSubMenu)
{
    HMENU hmParent = LoadMenu(g_hinst, MAKEINTRESOURCE(id));
    if (!hmParent)
        return(NULL);
    
    HMENU hmPopup = GetSubMenu(hmParent, uSubMenu);
    RemoveMenu(hmParent, uSubMenu, MF_BYPOSITION);
    DestroyMenu(hmParent);
    
    return(hmPopup);
}

// 57D5ECC0-A23F-11CE-AE65-08002B2E1262
DEFINE_GUID(CLSID_ContentMenu, 0x57D5ECC0L, 0xA23F, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);

STDAPI CContentMenu_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    CContentMenu *pmenu = new CContentMenu();
    if (pmenu) 
    {
        *ppunk = SAFECAST(pmenu, IContextMenu2 *);
        return S_OK;
    }
    
    return E_OUTOFMEMORY;
}

#endif // CONTENT

#define CXIMAGEGAP      6

//
//This is included by shell32/shellprv.h I'm not sure where this is in shdocvw
#define CCH_KEYMAX  64

typedef struct 
{
    // Accessibility info must be first
    MSAAMENUINFO msaa;
    TCHAR chPrefix;
    TCHAR szMenuText[CCH_KEYMAX];
    TCHAR szExt[MAX_PATH];
    TCHAR szClass[CCH_KEYMAX];
    DWORD dwFlags;
    int iImage;
    TCHAR szUserFile[CCH_KEYMAX];
} NEWOBJECTINFO;

typedef struct 
{
    int type;
    void *lpData;
    DWORD cbData;
    HKEY hkeyNew;
} NEWFILEINFO;

typedef struct 
{
    ULONG       cbStruct;
    ULONG       ver;
    SYSTEMTIME  lastupdate;
} SHELLNEW_CACHE_STAMP;

// ShellNew config flags
#define SNCF_DEFAULT    0x0000
#define SNCF_NOEXT      0x0001
#define SNCF_USERFILES  0x0002

#define NEWTYPE_DATA    0x0003
#define NEWTYPE_FILE    0x0004
#define NEWTYPE_NULL    0x0005
#define NEWTYPE_COMMAND 0x0006
#define NEWTYPE_FOLDER  0x0007
#define NEWTYPE_LINK    0x0008

#define NEWITEM_FOLDER  0
#define NEWITEM_LINK    1
#define NEWITEM_MAX     2

class CNewMenu : public CObjectWithSite,
                 public IContextMenu3, 
                 public IShellExtInit
{
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);
    
    // IContextMenu2
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    // IContextMenu3
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *lResult);
    
    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);
    
   
    LONG            _cRef;
    HMENU           _hmenu;
    UINT            _idCmdFirst;
    HIMAGELIST      _himlSystemImageList;
    IDataObject    *_pdtobj;
    LPITEMIDLIST    _pidlFolder;
    POINT           _ptNewItem;     // from the view, point of click
    NEWOBJECTINFO  *_pnoiLast;
    HDPA            _hdpaMenuInfo;
    
    CNewMenu();
    ~CNewMenu();
    
    friend HRESULT CNewMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut);

private:
    //Handle Menu messages submitted to HandleMenuMsg
    BOOL DrawItem(DRAWITEMSTRUCT *lpdi);
    LRESULT MeasureItem(MEASUREITEMSTRUCT *pmi);
    BOOL InitMenuPopup(HMENU hMenu);
    
    //Internal Helpers
    NEWOBJECTINFO *GetItemData(HMENU hmenu, UINT iItem);
    HRESULT RunCommand(HWND hwnd, LPCTSTR pszPath, LPCTSTR pszRun);
    HRESULT CopyTemplate(IStream *pStream, NEWFILEINFO *pnfi);

    // Generates it from the Fragment and _pidlFolder
    BOOL _GeneratePidlFromName(LPTSTR pszName, LPITEMIDLIST* ppidl);
    HRESULT _GetItemName(IUnknown *punkFolder, LPWSTR pszItemName, LPWSTR pszPath, UINT cchPath);

    HRESULT _MatchMenuItem(TCHAR ch, LRESULT* plRes);
    BOOL _InsertNewMenuItem(HMENU hmenu, UINT idCmd, NEWOBJECTINFO *pnoiClone);
    
    HRESULT ConsolidateMenuItems(BOOL bForce);

    HANDLE _hMutex, _hEvent;
};

void GetConfigFlags(HKEY hkey, DWORD * pdwFlags)
{
    TCHAR szTemp[MAX_PATH];
    DWORD cbData = ARRAYSIZE(szTemp);
    
    *pdwFlags = SNCF_DEFAULT;
    
    if (SHQueryValueEx(hkey, TEXT("NoExtension"), 0, NULL, (BYTE *)szTemp, &cbData) == ERROR_SUCCESS) 
    {
        *pdwFlags |= SNCF_NOEXT;
    }
}

BOOL GetNewFileInfoForKey(HKEY hkeyExt, NEWFILEINFO *pnfi, DWORD * pdwFlags)
{
    BOOL fRet = FALSE;
    HKEY hKey; // this gets the \\.ext\progid  key
    HKEY hkeyNew;
    TCHAR szProgID[80];
    LONG lSize = sizeof(szProgID);
    
    // open the Newcommand
    if (SHRegQueryValue(hkeyExt, NULL,  szProgID, &lSize) != ERROR_SUCCESS)
    {
        return FALSE;
    }
    
    if (RegOpenKey(hkeyExt, szProgID, &hKey) != ERROR_SUCCESS)
    {
        hKey = hkeyExt;
    }
    
    if (RegOpenKey(hKey, TEXT("ShellNew"), &hkeyNew) == ERROR_SUCCESS)
    {
        DWORD dwType, cbData;
        TCHAR szTemp[MAX_PATH];
        HKEY hkeyConfig;
        
        // Are there any config flags?
        if (pdwFlags)
        {
            
            if (RegOpenKey(hkeyNew, TEXT("Config"), &hkeyConfig) == ERROR_SUCCESS)
            {
                GetConfigFlags(hkeyConfig, pdwFlags);
                RegCloseKey(hkeyConfig);
            }
            else
            {
                *pdwFlags = 0;
            }
        }
        
        if (cbData = sizeof(szTemp), (SHQueryValueEx(hkeyNew, TEXT("FileName"), 0, &dwType, (LPBYTE)szTemp, &cbData) == ERROR_SUCCESS) 
            && ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ))) 
        {
            fRet = TRUE;
            if (pnfi)
            {
                pnfi->type = NEWTYPE_FILE;
                pnfi->hkeyNew = hkeyNew; // store this away so we can find out which one held the file easily
                ASSERT((LPTSTR*)pnfi->lpData == NULL);
                pnfi->lpData = StrDup(szTemp);
                
                hkeyNew = NULL;
            }
        } 
        else if (cbData = sizeof(szTemp), (SHQueryValueEx(hkeyNew, TEXT("command"), 0, &dwType, (LPBYTE)szTemp, &cbData) == ERROR_SUCCESS) 
            && ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ))) 
        {
            
            fRet = TRUE;
            if (pnfi)
            {
                pnfi->type = NEWTYPE_COMMAND;
                pnfi->hkeyNew = hkeyNew; // store this away so we can find out which one held the command easily
                ASSERT((LPTSTR*)pnfi->lpData == NULL);
                pnfi->lpData = StrDup(szTemp);
                hkeyNew = NULL;
            }
        } 
        else if ((SHQueryValueEx(hkeyNew, TEXT("Data"), 0, &dwType, NULL, &cbData) == ERROR_SUCCESS) && cbData) 
        {
            // yes!  the data for a new file is stored in the registry
            fRet = TRUE;
            // do they want the data?
            if (pnfi)
            {
                pnfi->type = NEWTYPE_DATA;
                pnfi->cbData = cbData;
                pnfi->lpData = (void*)LocalAlloc(LPTR, cbData);
                if (pnfi->lpData)
                {
                    if (dwType == REG_SZ)
                    {
                        //  Get the Unicode data from the registry.
                        LPWSTR pszTemp = (LPWSTR)LocalAlloc(LPTR, cbData);
                        if (pszTemp)
                        {
                            SHQueryValueEx(hkeyNew, TEXT("Data"), 0, &dwType, (LPBYTE)pszTemp, &cbData);
                            
                            pnfi->cbData = SHUnicodeToAnsi(pszTemp, (LPSTR)pnfi->lpData, cbData);
                            if (pnfi->cbData == 0)
                            {
                                LocalFree(pnfi->lpData);
                                pnfi->lpData = NULL;
                            }
                            
                            LocalFree(pszTemp);
                        }
                        else
                        {
                            LocalFree(pnfi->lpData);
                            pnfi->lpData = NULL;
                        }
                    }
                    else
                    {
                        SHQueryValueEx(hkeyNew, TEXT("Data"), 0, &dwType, (BYTE*)pnfi->lpData, &cbData);
                    }
                }
            }
        }
        else if (cbData = sizeof(szTemp), (SHQueryValueEx(hkeyNew, TEXT("NullFile"), 0, &dwType, (LPBYTE)szTemp, &cbData) == ERROR_SUCCESS)) 
        {
            fRet = TRUE;
            if (pnfi)
            {
                pnfi->type = NEWTYPE_NULL;
                pnfi->cbData = 0;
                pnfi->lpData = NULL;
            }
        } 
        
        if (hkeyNew)
            RegCloseKey(hkeyNew);
    }
    
    if (hKey != hkeyExt)
    {
        RegCloseKey(hKey);
    }
    return fRet;
}

BOOL GetNewFileInfoForExtension(NEWOBJECTINFO *pnoi, NEWFILEINFO *pnfi, HKEY* phKey, LPINT piIndex)
{
    TCHAR szValue[80];
    LONG lSize = sizeof(szValue);
    HKEY hkeyNew;
    BOOL fRet = FALSE;;
    
    if (phKey && ((*phKey) == (HKEY)-1))
    {
        // we're done
        return FALSE;
    }
    
    // do the ShellNew key stuff if there's no phKey passed in (which means
    // use the info in pnoi to get THE one) and there's no UserFile specified.
    // 
    // if there IS a UserFile specified, then it's a file, and that szUserFile points to it..
    if (!phKey && !pnoi->szUserFile[0] ||
        (phKey && !*phKey)) 
    {
        // check the new keys under the class id (if any)
        TCHAR szSubKey[128];
        wnsprintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\CLSID"), pnoi->szClass);
        lSize = sizeof(szValue);
        if (SHRegQueryValue(HKEY_CLASSES_ROOT, szSubKey, szValue, &lSize) == ERROR_SUCCESS)
        {
            wnsprintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("CLSID\\%s"), szValue);
            lSize = sizeof(szValue);
            if (RegOpenKey(HKEY_CLASSES_ROOT, szSubKey, &hkeyNew) == ERROR_SUCCESS)
            {
                fRet = GetNewFileInfoForKey(hkeyNew, pnfi, &pnoi->dwFlags);
                RegCloseKey(hkeyNew);
            }
        }
        
        // otherwise check under the type extension... do the extension, not the type
        // so that multi-ext to 1 type will work right
        if (!fRet && (RegOpenKey(HKEY_CLASSES_ROOT, pnoi->szExt, &hkeyNew) == ERROR_SUCCESS))
        {
            fRet = GetNewFileInfoForKey(hkeyNew, pnfi, &pnoi->dwFlags);
            RegCloseKey(hkeyNew);
        }
        
        if (phKey)
        {
            // if we're iterating, then we've got to open the key now...
            wnsprintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\%s\\ShellNew\\FileName"), pnoi->szExt, pnoi->szClass);
            if (RegOpenKey(HKEY_CLASSES_ROOT, szSubKey, phKey) == ERROR_SUCCESS)
            {
                *piIndex = 0;
                
                // if we didn't find one of the default ones above, 
                // try it now
                // otherwise just return success or failure on fRet
                if (!fRet)
                {
                    goto Iterate;
                } 
            }
            else
            {
                *phKey = (HKEY)-1;
            }
        }
    }
    else if (!phKey && pnoi->szUserFile[0])
    {
        // there's no key, so just return info about szUserFile
        pnfi->type = NEWTYPE_FILE;
        pnfi->lpData = StrDup(pnoi->szUserFile);
        pnfi->hkeyNew = NULL;
        
        fRet = TRUE;
    }
    else if (phKey)
    {
        DWORD dwSize;
        DWORD dwData;
        DWORD dwType;
        // we're iterating through...
        
Iterate:
        
        dwSize = ARRAYSIZE(pnoi->szUserFile);
        dwData = ARRAYSIZE(pnoi->szMenuText);
        
        if (RegEnumValue(*phKey, *piIndex, pnoi->szUserFile, &dwSize, NULL,
            &dwType, (LPBYTE)pnoi->szMenuText, &dwData) == ERROR_SUCCESS)
        {
            (*piIndex)++;
            // if there's something more than the null..
            if (dwData <= 1)
            { 
                lstrcpyn(pnoi->szMenuText, PathFindFileName(pnoi->szUserFile), ARRAYSIZE(pnoi->szMenuText));
                PathRemoveExtension(pnoi->szMenuText);
            }
            fRet = TRUE;
        }
        else
        {
            RegCloseKey(*phKey);
            *phKey = (HKEY)-1;
            fRet = FALSE;
        }
    }
    
    return fRet;
}

#define SHELLNEW_CONSOLIDATION_MUTEX TEXT("ShellNewConsolidationMutex")
#define SHELLNEW_CONSOLIDATION_EVENT TEXT("ShellNewConsolidationEvent")

CNewMenu::CNewMenu() :
    _cRef(1),
    _hMutex(CreateMutex(NULL, FALSE, SHELLNEW_CONSOLIDATION_MUTEX)),
    _hEvent(CreateEvent(NULL, FALSE, FALSE, SHELLNEW_CONSOLIDATION_EVENT))
{
    DllAddRef();
    ASSERT(_pnoiLast == NULL);
}

CNewMenu::~CNewMenu()
{
    if (_hdpaMenuInfo)
    {
        // we dont own the lifetime of _hmenu, and it gets destroyed before the destructor
        // is called.  thus maintain the lifetime of our NEWOBJECTINFO data in a dpa.
        for (int i = 0; i < DPA_GetPtrCount(_hdpaMenuInfo); i++)
        {
            NEWOBJECTINFO *pNewObjInfo = (NEWOBJECTINFO *)DPA_GetPtr(_hdpaMenuInfo, i);
            LocalFree(pNewObjInfo);
        }
        DPA_Destroy(_hdpaMenuInfo);
    }
    
    ILFree(_pidlFolder);

    if (_pdtobj)
        _pdtobj->Release();

    if (_hMutex)
    {
        CloseHandle(_hMutex);
    }
    if (_hEvent)
    {
        CloseHandle(_hEvent);
    }

    DllRelease();
}

HRESULT CNewMenu_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    // aggregation checking is handled in class factory
    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CNewMenu * pShellNew = new CNewMenu();
    if (pShellNew) 
    {
        if (!pShellNew->_hMutex || !pShellNew->_hEvent)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pShellNew->QueryInterface(riid, ppvOut);
        }
        pShellNew->Release();
    }

    return hr;
}

HRESULT CNewMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CNewMenu, IShellExtInit),                     // IID_IShellExtInit
        QITABENT(CNewMenu, IContextMenu3),                     // IID_IContextMenu3
        QITABENTMULTI(CNewMenu, IContextMenu2, IContextMenu3), // IID_IContextMenu2
        QITABENTMULTI(CNewMenu, IContextMenu, IContextMenu3),  // IID_IContextMenu
        QITABENT(CNewMenu, IObjectWithSite),                   // IID_IObjectWithSite
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CNewMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CNewMenu::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

HRESULT CNewMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    // if they want the default menu only (CMF_DEFAULTONLY) OR 
    // this is being called for a shortcut (CMF_VERBSONLY)
    // we don't want to be on the context menu
    MENUITEMINFO mfi = {0};
    
    if (uFlags & (CMF_DEFAULTONLY | CMF_VERBSONLY))
        return S_OK;
    
    ConsolidateMenuItems(FALSE);

    _idCmdFirst = idCmdFirst+2;
    TCHAR szNewMenu[80];
    LoadString(g_hinst, IDS_NEWMENU, szNewMenu, ARRAYSIZE(szNewMenu));

    // HACK: I assume that they are querying during a WM_INITMENUPOPUP or equivalent
    GetCursorPos(&_ptNewItem);
    
    _hmenu = CreatePopupMenu();
    mfi.cbSize = sizeof(MENUITEMINFO);
    mfi.fMask = MIIM_ID | MIIM_TYPE;
    mfi.wID = idCmdFirst+1;
    mfi.fType = MFT_STRING;
    mfi.dwTypeData = szNewMenu;
    
    InsertMenuItem(_hmenu, 0, TRUE, &mfi);
    
    ZeroMemory(&mfi, sizeof (mfi));
    mfi.cbSize = sizeof(MENUITEMINFO);
    mfi.fMask = MIIM_ID | MIIM_SUBMENU | MIIM_TYPE | MIIM_DATA;
    mfi.fType = MFT_STRING;
    mfi.wID = idCmdFirst;
    mfi.hSubMenu = _hmenu;
    mfi.dwTypeData = szNewMenu;
    mfi.dwItemData = 0;
    
    InsertMenuItem(hmenu, indexMenu, TRUE, &mfi);

    _hmenu = NULL;
    return ResultFromShort(_idCmdFirst - idCmdFirst + 1);
}

// This is almost the same as ILCreatePidlFromPath, but
// uses only the filename from the full path pszPath and
// the _pidlFolder to generate the pidl. This is used because
// when creating an item in Desktop\My Documents, it used to create a
// full pidl c:\documents and Settings\lamadio\My Documents\New folder
// instead of the pidl desktop\my documents\New Folder.
BOOL CNewMenu::_GeneratePidlFromName(LPTSTR pszFile, LPITEMIDLIST* ppidl)
{
    *ppidl = NULL;  // Out param

    IShellFolder* psf;
    if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, _pidlFolder, &psf))))
    {
        LPITEMIDLIST pidlItem;

        if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, pszFile, NULL, &pidlItem, NULL)))
        {
            *ppidl = ILCombine(_pidlFolder, pidlItem);
            ILFree(pidlItem);
        }

        psf->Release();
    }

    return BOOLFROMPTR(*ppidl);
}

HRESULT CNewMenu::_GetItemName(IUnknown *punkFolder, LPWSTR pszItemName, LPWSTR pszPath, UINT cchPath)
{
    // we need to pick up the name by asking the folder about the item,
    // not by pathappending to the folder's path.
    IShellFolder *psf;
    HRESULT hr = punkFolder->QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlFile;
        hr = psf->ParseDisplayName(NULL, NULL, pszItemName, NULL, &pidlFile, NULL);
        if (SUCCEEDED(hr))
        {
            hr = DisplayNameOf(psf, pidlFile, SHGDN_FORPARSING, pszPath, cchPath);
            ILFree(pidlFile);
        }
        psf->Release();
    }
    return hr;
}

const ICIVERBTOIDMAP c_IDMap[] =
{
    { L"NewFolder", "NewFolder", NEWITEM_FOLDER, NEWITEM_FOLDER, },
    { L"link",      "link",      NEWITEM_LINK,   NEWITEM_LINK,   },
};

HRESULT CNewMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;
    DWORD dwFlags;

    if (IS_INTRESOURCE(pici->lpVerb) && _pnoiLast)
        dwFlags = _pnoiLast->dwFlags;
    else
    {
        UINT uID;
        if (SUCCEEDED(SHMapICIVerbToCmdID(pici, c_IDMap, ARRAYSIZE(c_IDMap), &uID)))
        {
            switch (uID)
            {
                case NEWITEM_FOLDER:
                    dwFlags = NEWTYPE_FOLDER;
                    break;
                case NEWITEM_LINK:
                    dwFlags = NEWTYPE_LINK;
                    break;
                default:
                    ASSERTMSG(0, "should not get what we don't put on the menu");
                    return E_FAIL;
            }
        }
    }
    
    TCHAR szFileSpec[MAX_PATH+80];   // Add some slop incase we overflow
    TCHAR szTemp[MAX_PATH+80];       // Add some slop incase we overflow

    //See if the pidl is folder shortcut and if so get the target path.
    SHGetTargetFolderPath(_pidlFolder, szTemp, ARRAYSIZE(szTemp));
    BOOL fLFN = IsLFNDrive(szTemp);

    NEWFILEINFO nfi;
    DWORD dwErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    nfi.lpData = NULL;
    nfi.hkeyNew = NULL;

    switch (dwFlags)
    {
    case NEWTYPE_FOLDER:
        LoadString(g_hinst, fLFN ? IDS_FOLDERLONGPLATE : IDS_FOLDERTEMPLATE, szFileSpec, ARRAYSIZE(szFileSpec));
        break;

    case NEWTYPE_LINK:
        LoadString(g_hinst, IDS_NEWLINKTEMPLATE, szFileSpec, ARRAYSIZE(szFileSpec));
        break;

    default:
        LoadString(g_hinst, IDS_NEWFILEPREFIX, szFileSpec, ARRAYSIZE(szFileSpec));

        //
        // If we are running on a mirrored BiDi localized system,
        // then flip the order of concatenation so that the
        // string is read properly for Arabic. [samera]
        //
        if (IS_BIDI_LOCALIZED_SYSTEM())
        {
            lstrcpyn(szTemp, szFileSpec, ARRAYSIZE(szTemp));
            wnsprintf(szFileSpec, ARRAYSIZE(szFileSpec), TEXT("%s %s"), _pnoiLast->szMenuText, szTemp);
        }
        else
        {
            StrCatBuff(szFileSpec, _pnoiLast->szMenuText, ARRAYSIZE(szFileSpec));
        }
        SHStripMneumonic(szFileSpec);

        if (!(dwFlags & SNCF_NOEXT))
            StrCatBuff(szFileSpec, _pnoiLast->szExt, ARRAYSIZE(szFileSpec));
        break;
    }

    BOOL fCreateStorage = (dwFlags == NEWTYPE_FOLDER);

    //See if the pidl is folder shortcut and if so get the target pidl.
    LPITEMIDLIST pidlTarget;
    hr = SHGetTargetFolderIDList(_pidlFolder, &pidlTarget);
    if (SUCCEEDED(hr))
    {
        IStorage * pStorage;
        hr = StgBindToObject(pidlTarget, STGM_READWRITE, IID_PPV_ARG(IStorage, &pStorage));
        if (SUCCEEDED(hr))
        {
            IStream *pStreamCreated = NULL;
            IStorage *pStorageCreated = NULL;

            STATSTG statstg = { 0 };
            if (fCreateStorage)
            {
                hr = StgMakeUniqueName(pStorage, szFileSpec, IID_PPV_ARG(IStorage, &pStorageCreated));
                if (SUCCEEDED(hr))
                    pStorageCreated->Stat(&statstg, STATFLAG_DEFAULT);
            }
            else
            {
                hr = StgMakeUniqueName(pStorage, szFileSpec, IID_PPV_ARG(IStream, &pStreamCreated));
                if (SUCCEEDED(hr))
                    pStreamCreated->Stat(&statstg, STATFLAG_DEFAULT);
            }

            if (SUCCEEDED(hr))
            {
                switch (dwFlags)
                {
                case NEWTYPE_FOLDER:
                    // we're already done.
                    break;

                case NEWTYPE_LINK:
                    if (statstg.pwcsName)
                    {
                        // Lookup Command in Registry under key HKCR/.lnk/ShellNew/Command
                        TCHAR szCommand[MAX_PATH];
                        DWORD dwLength = sizeof(szCommand);
                        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, 
                            TEXT(".lnk\\ShellNew"), TEXT("Command"), NULL, szCommand, &dwLength))
                        {
                            TCHAR szPath[MAX_PATH];
                            hr = _GetItemName(SAFECAST(pStorage, IUnknown*), statstg.pwcsName, szPath, ARRAYSIZE(szPath));
                            if (SUCCEEDED(hr))
                            {
                                hr = RunCommand(pici->hwnd, szPath, szCommand);
                            }
                        }
                    }
                    break;

                default:
                    if (GetNewFileInfoForExtension(_pnoiLast, &nfi, NULL, NULL))
                    {
                        switch (nfi.type) 
                        {
                        case NEWTYPE_FILE:
                            hr = CopyTemplate(pStreamCreated, &nfi);
                            break;

                        case NEWTYPE_NULL:
                            // already created a zero-length file.
                            break;

                        case NEWTYPE_DATA:
                            ULONG ulWritten;
                            hr = pStreamCreated->Write(nfi.lpData, nfi.cbData, &ulWritten);
                            if (SUCCEEDED(hr))
                            {
                                hr = pStreamCreated->Commit(STGC_DEFAULT);
                            }
                            break;

                        case NEWTYPE_COMMAND:
                            if (statstg.pwcsName)
                            {
                                TCHAR szPath[MAX_PATH];
                                hr = _GetItemName(SAFECAST(pStorage, IUnknown*), statstg.pwcsName, szPath, ARRAYSIZE(szPath));
                                if (SUCCEEDED(hr))
                                {
                                    // oops, we already created the stream, but we actually
                                    // just wanted the filename for the RunCommand, so we
                                    // have to delete it first.
                                    ATOMICRELEASE(pStreamCreated);
                                    hr = pStorage->DestroyElement(statstg.pwcsName);
                                    // flush out any notifications from the destroy (the
                                    // destroy causes notifications).
                                    SHChangeNotifyHandleEvents();

                                    if (SUCCEEDED(hr))
                                    {
                                        hr = RunCommand(pici->hwnd, szPath, (LPTSTR)nfi.lpData);
                                        if (hr == S_FALSE)
                                            hr = S_OK;
                                    }
                                }
                            }
                            break;

                        default:
                            hr = E_FAIL;
                            break;
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
                    }
                    break;
                }

                // these have to be released before _GeneratePidlFromName, since that opens
                // the storage in exclusive mode for other reasons.  but we can't release
                // them earlier because CopyTemplate might need them.
                if (pStorageCreated)
                    pStorageCreated->Release();
                if (pStreamCreated)
                    pStreamCreated->Release();
                if (SUCCEEDED(hr))
                    hr = pStorage->Commit(STGC_DEFAULT);
                pStorage->Release();

                LPITEMIDLIST pidlCreatedItem;
                if (SUCCEEDED(hr) &&
                    _GeneratePidlFromName(statstg.pwcsName, &pidlCreatedItem))
                {
                    SHChangeNotifyHandleEvents();
                    IShellView2 *psv2;
                    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IShellView2, &psv2))))
                    {
                        DWORD dwFlagsSelFlags = SVSI_SELECT | SVSI_POSITIONITEM;

                        if (!(dwFlags & NEWTYPE_LINK))
                            dwFlagsSelFlags |= SVSI_EDIT;

                        psv2->SelectAndPositionItem(ILFindLastID(pidlCreatedItem), dwFlagsSelFlags, NULL);
                        psv2->Release();
                    }
                    ILFree(pidlCreatedItem);
                }

                CoTaskMemFree(statstg.pwcsName);
            }
            else
            {
                pStorage->Release();
            }
        }

        ILFree(pidlTarget);
    }

    if (nfi.lpData)
        LocalFree((HLOCAL)nfi.lpData);
    
    if (nfi.hkeyNew)
        RegCloseKey(nfi.hkeyNew);

    if (FAILED_AND_NOT_CANCELED(hr) && !(pici->fMask & CMIC_MASK_FLAG_NO_UI))
    {
        TCHAR szTitle[MAX_PATH];

        LoadString(g_hinst, (fCreateStorage ? IDS_DIRCREATEFAILED_TITLE : IDS_FILECREATEFAILED_TITLE), szTitle, ARRAYSIZE(szTitle));
        SHSysErrorMessageBox(pici->hwnd, szTitle, fCreateStorage ? IDS_CANNOTCREATEFOLDER : IDS_CANNOTCREATEFILE,
                HRESULT_CODE(hr), szFileSpec, MB_OK | MB_ICONEXCLAMATION);
    }

    SetErrorMode(dwErrorMode);

    return hr;
}

HRESULT CNewMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax)
{
    switch (uType)
    {
    case GCS_HELPTEXT:
        if (idCmd < NEWITEM_MAX)
        {
            LoadString(g_hinst, (UINT)(IDS_NEWHELP_FIRST + idCmd), (LPTSTR)pszName, cchMax);
            return S_OK;
        }
        break;
    case GCS_HELPTEXTA:
        if (idCmd < NEWITEM_MAX)
        {
            LoadStringA(g_hinst, (UINT)(IDS_NEWHELP_FIRST + idCmd), pszName, cchMax);
            return S_OK;
        }
        break;

    case GCS_VERBW:
    case GCS_VERBA:
        return SHMapCmdIDToVerb(idCmd, c_IDMap, ARRAYSIZE(c_IDMap), pszName, cchMax, (GCS_VERBW == uType));
    }

    return E_NOTIMPL;
}

//Defined in fsmenu.obj
BOOL _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand);

HRESULT CNewMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg,wParam,lParam,NULL);
}

HRESULT CNewMenu::_MatchMenuItem(TCHAR ch, LRESULT* plRes)
{
    // If plRes is NULL we're being called on HandleMenuMsg() which
    // doesn't support returning an LRESULT, which is needed for WM_MENUCHAR...
    if (plRes == NULL)
        return S_FALSE;

    int iLastSelectedItem = -1;
    int iNextMatch = -1;
    BOOL fMoreThanOneMatch = FALSE;
    int c = GetMenuItemCount(_hmenu);

    // Pass 1: Locate the Selected Item
    for (int i = 0; i < c; i++) 
    {
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_STATE;
        if (GetMenuItemInfo(_hmenu, i, MF_BYPOSITION, &mii))
        {
            if (mii.fState & MFS_HILITE)
            {
                iLastSelectedItem = i;
                break;
            }
        }
    }

    // Pass 2: Starting from the selected item, locate the first item with the matching name.
    for (i = iLastSelectedItem + 1; i < c; i++) 
    {
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_DATA | MIIM_STATE;
        if (GetMenuItemInfo(_hmenu, i, MF_BYPOSITION, &mii))
        {
            NEWOBJECTINFO *pnoi = (NEWOBJECTINFO *)mii.dwItemData;
            if (pnoi && _MenuCharMatch(pnoi->szMenuText, ch, FALSE))
            {
                _pnoiLast = pnoi;
                
                if (iNextMatch != -1)
                {
                    fMoreThanOneMatch = TRUE;
                    break;                      // We found all the info we need
                }
                else
                {
                    iNextMatch = i;
                }
            }
        }
    }

    // Pass 3: If we did not find a match, or if there was only one match
    // Search from the first item, to the Selected Item
    if (iNextMatch == -1 || fMoreThanOneMatch == FALSE)
    {
        for (i = 0; i <= iLastSelectedItem; i++) 
        {
            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_DATA | MIIM_STATE;
            if (GetMenuItemInfo(_hmenu, i, MF_BYPOSITION, &mii))
            {
                NEWOBJECTINFO *pnoi = (NEWOBJECTINFO *)mii.dwItemData;
                if (pnoi && _MenuCharMatch(pnoi->szMenuText, ch, FALSE))
                {
                    _pnoiLast = pnoi;
                    if (iNextMatch != -1)
                    {
                        fMoreThanOneMatch = TRUE;
                        break;
                    }
                    else
                    {
                        iNextMatch = i;
                    }
                }
            }
        }
    }

    if (iNextMatch != -1)
    {
        *plRes = MAKELONG(iNextMatch, fMoreThanOneMatch? MNC_SELECT : MNC_EXECUTE);
    }
    else
    {
        *plRes = MAKELONG(0, MNC_IGNORE);
    }

    return S_OK;
}

HRESULT CNewMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *plResult)
{
    HRESULT hr = S_OK;
    LRESULT lRes = 0;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        if (_hmenu == NULL)
        {
            _hmenu = (HMENU)wParam;
        }
        
        InitMenuPopup(_hmenu);
        break;
        
    case WM_DRAWITEM:
        DrawItem((DRAWITEMSTRUCT *)lParam);
        break;
        
    case WM_MEASUREITEM:
        lRes = MeasureItem((MEASUREITEMSTRUCT *)lParam);
        break;

    case WM_MENUCHAR:
        hr = _MatchMenuItem((TCHAR)LOWORD(wParam), &lRes);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    if (plResult)
        *plResult = lRes;

    return hr;
}

HRESULT CNewMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    ASSERT(_pidlFolder == NULL);
    _pidlFolder = ILClone(pidlFolder);
   
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);
    return S_OK;
}

BOOL CNewMenu::DrawItem(DRAWITEMSTRUCT *lpdi)
{
    BOOL fFlatMenu = FALSE;
    BOOL fFrameRect = FALSE;

    SystemParametersInfo(SPI_GETFLATMENU, 0, (PVOID)&fFlatMenu, 0);

    if ((lpdi->itemAction & ODA_SELECT) || (lpdi->itemAction & ODA_DRAWENTIRE))
    {
        int x, y;
        SIZE sz;
        NEWOBJECTINFO *pnoi = (NEWOBJECTINFO *)lpdi->itemData;
        
        // Draw the image (if there is one).
        
        GetTextExtentPoint(lpdi->hDC, pnoi->szMenuText, lstrlen(pnoi->szMenuText), &sz);
        
        if (lpdi->itemState & ODS_SELECTED)
        {
            // REVIEW HACK - keep track of the last selected item.
            _pnoiLast = pnoi;
            if (fFlatMenu)
            {
                fFrameRect = TRUE;
                SetBkColor(lpdi->hDC, GetSysColor(COLOR_MENUHILIGHT));
                SetTextColor(lpdi->hDC, GetSysColor(COLOR_MENUTEXT));
                FillRect(lpdi->hDC,&lpdi->rcItem,GetSysColorBrush(COLOR_MENUHILIGHT));
            }
            else
            {
                SetBkColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
                SetTextColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
                FillRect(lpdi->hDC,&lpdi->rcItem,GetSysColorBrush(COLOR_HIGHLIGHT));
            }
        }
        else
        {
            SetTextColor(lpdi->hDC, GetSysColor(COLOR_MENUTEXT));
            FillRect(lpdi->hDC,&lpdi->rcItem,GetSysColorBrush(COLOR_MENU));
        }
        
        RECT rc = lpdi->rcItem;
        rc.left += +2*CXIMAGEGAP+g_cxSmIcon;
        
        
        DrawText(lpdi->hDC,pnoi->szMenuText,lstrlen(pnoi->szMenuText),
            &rc,DT_SINGLELINE|DT_VCENTER);
        if (pnoi->iImage != -1)
        {
            x = lpdi->rcItem.left+CXIMAGEGAP;
            y = (lpdi->rcItem.bottom+lpdi->rcItem.top-g_cySmIcon)/2;
            HIMAGELIST himlSmall;
            Shell_GetImageLists(NULL, &himlSmall);
            ImageList_Draw(himlSmall, pnoi->iImage, lpdi->hDC, x, y, ILD_TRANSPARENT);
        } 
        else 
        {
            x = lpdi->rcItem.left+CXIMAGEGAP;
            y = (lpdi->rcItem.bottom+lpdi->rcItem.top-g_cySmIcon)/2;
        }

        if (fFrameRect)
        {
            HBRUSH hbrFill = (HBRUSH)GetSysColorBrush(COLOR_HIGHLIGHT);
            HBRUSH hbrSave = (HBRUSH)SelectObject(lpdi->hDC, hbrFill);
            int x = lpdi->rcItem.left;
            int y = lpdi->rcItem.top;
            int cx = lpdi->rcItem.right - x - 1;
            int cy = lpdi->rcItem.bottom - y - 1;

            PatBlt(lpdi->hDC, x, y, 1, cy, PATCOPY);
            PatBlt(lpdi->hDC, x + 1, y, cx, 1, PATCOPY);
            PatBlt(lpdi->hDC, x, y + cy, cx, 1, PATCOPY);
            PatBlt(lpdi->hDC, x + cx, y + 1, 1, cy, PATCOPY);

            SelectObject(lpdi->hDC, hbrSave);
        }

        return TRUE;
    }

    return FALSE;
}

LRESULT CNewMenu::MeasureItem(MEASUREITEMSTRUCT *pmi)
{
    LRESULT lres = FALSE;
    NEWOBJECTINFO *pnoi = (NEWOBJECTINFO *)pmi->itemData;
    if (pnoi)
    {
        // Get the rough height of an item so we can work out when to break the
        // menu. User should really do this for us but that would be useful.
        HDC hdc = GetDC(NULL);
        if (hdc)
        {
            // REVIEW cache out the menu font?
            NONCLIENTMETRICS ncm;
            ncm.cbSize = sizeof(ncm);
            if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE))
            {
                HFONT hfont = CreateFontIndirect(&ncm.lfMenuFont);
                if (hfont)
                {
                    SIZE sz;
                    HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);
                    GetTextExtentPoint(hdc, pnoi->szMenuText, lstrlen(pnoi->szMenuText), &sz);
                    pmi->itemHeight = max (g_cySmIcon+CXIMAGEGAP/2, ncm.iMenuHeight);
                    pmi->itemWidth = g_cxSmIcon + 2*CXIMAGEGAP + sz.cx;
                    //pmi->itemWidth = 2*CXIMAGEGAP + sz.cx;
                    SelectObject(hdc, hfontOld);
                    DeleteObject(hfont);
                    lres = TRUE;
                }
            }
            ReleaseDC(NULL, hdc);
        }
    }
    return lres;
}

BOOL GetClassDisplayName(LPTSTR pszClass,LPTSTR pszDisplayName,DWORD cchDisplayName)
{
    DWORD cch;

    return SUCCEEDED(AssocQueryString(0, ASSOCSTR_COMMAND, pszClass, TEXT("open"), NULL, &cch)) && 
           SUCCEEDED(AssocQueryString(0, ASSOCSTR_FRIENDLYDOCNAME, pszClass, NULL, pszDisplayName, &cchDisplayName));
}

//  New Menu item consolidation worker task
class CNewMenuConsolidator : public CRunnableTask
{
public:
    virtual STDMETHODIMP RunInitRT(void);
    static const GUID _taskid;

    static HRESULT CreateInstance(REFIID riid, void **ppv);

private:
    CNewMenuConsolidator();
    ~CNewMenuConsolidator();

    HANDLE _hMutex, _hEvent;
};


CNewMenuConsolidator::CNewMenuConsolidator() :
    CRunnableTask(RTF_DEFAULT),
    _hMutex(CreateMutex(NULL, FALSE, SHELLNEW_CONSOLIDATION_MUTEX)),
    _hEvent(CreateEvent(NULL, FALSE, FALSE, SHELLNEW_CONSOLIDATION_EVENT))
{
    DllAddRef();
}

CNewMenuConsolidator::~CNewMenuConsolidator()
{
    if (_hMutex)
    {
        CloseHandle(_hMutex);
    }
    if (_hEvent)
    {
        CloseHandle(_hEvent);
    }
    DllRelease();
}

//
// Instance generator.
//
HRESULT CNewMenuConsolidator::CreateInstance(REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CNewMenuConsolidator *pnmc = new CNewMenuConsolidator();
    if (pnmc)
    {
        if (!pnmc->_hMutex || !pnmc->_hEvent)
        {
            hr = E_FAIL;
        }
        else
        {
            hr = pnmc->QueryInterface(riid, ppv);
        }
        pnmc->Release();
    }
    return hr;
}



const GUID CNewMenuConsolidator::_taskid = 
    { 0xf87a1f28, 0xc7f, 0x11d2, { 0xbe, 0x1d, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1 } };


#define REGSTR_SESSION_SHELLNEW STRREG_DISCARDABLE STRREG_POSTSETUP TEXT("\\ShellNew")
#define REGVAL_SESSION_SHELLNEW_TIMESTAMP TEXT("~reserved~")
#define REGVAL_SESSION_SHELLNEW_LANG TEXT("Language")

#define SHELLNEW_CACHE_CURRENTVERSION  MAKELONG(1, 1)
             
//  Constructs a current New submenu cache stamp.
void CNewMenu_MakeCacheStamp(SHELLNEW_CACHE_STAMP* pStamp)
{
    pStamp->cbStruct = sizeof(*pStamp);
    pStamp->ver = SHELLNEW_CACHE_CURRENTVERSION;
    GetLocalTime(&pStamp->lastupdate);
}

//   Determines whether the New submenu cache needs to be rebuilt.
BOOL CNewMenu_ShouldUpdateCache(SHELLNEW_CACHE_STAMP* pStamp)
{
    //  Correct version?
    return !(sizeof(*pStamp) == pStamp->cbStruct &&
              SHELLNEW_CACHE_CURRENTVERSION == pStamp->ver);
}

//  Gathers up shellnew entries from HKCR into a distinct registry location 
//  for faster enumeration of the New submenu items.
//
//  We'll do a first time cache initialization only if we have to before showing
//  the menu, but will always rebuild the cache following display of the menu.
HRESULT CNewMenu::ConsolidateMenuItems(BOOL bForce)
{
    HKEY          hkeyShellNew = NULL;
    BOOL          bUpdate = TRUE;   // unless we discover otherwise
    HRESULT       hr = S_OK;

    // make sure that a worker thread isnt currently slamming the registry info we're inspecting.
    // if we timeout, then do nothing, since the worker thread is already working on it.
    if (WAIT_OBJECT_0 == WaitForSingleObject(_hMutex, 0))
    {
        //  If we're not being told to unconditionally update the cache and
        //  we validate that we've already established one, then we get out of doing any
        //  work.
        if (!bForce &&
            ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_SESSION_SHELLNEW,
                                           0, KEY_ALL_ACCESS, &hkeyShellNew))
        {
            SHELLNEW_CACHE_STAMP stamp;
            ULONG cbVal = sizeof(stamp);
            if (ERROR_SUCCESS == SHQueryValueEx(hkeyShellNew, REGVAL_SESSION_SHELLNEW_TIMESTAMP, NULL,
                                                  NULL, (LPBYTE)&stamp, &cbVal) &&
                sizeof(stamp) == cbVal)
            {
                bUpdate = CNewMenu_ShouldUpdateCache(&stamp);
            }

            LCID lcid;
            ULONG cblcid = sizeof(lcid);

            if (!bUpdate &&
                ERROR_SUCCESS == SHQueryValueEx(hkeyShellNew, REGVAL_SESSION_SHELLNEW_LANG, NULL,
                                                  NULL, (LPBYTE)&lcid, &cblcid) &&
                sizeof(lcid) == cblcid)
            {
                bUpdate = (GetUserDefaultUILanguage() != lcid); // if the languages are different, then update
            }
            RegCloseKey(hkeyShellNew);
        }

        // end synchronize
        ReleaseMutex(_hMutex);
    
        if (bUpdate)
        {
            IShellTaskScheduler* pScheduler;
            hr = CoCreateInstance(CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC, 
                                                IID_PPV_ARG(IShellTaskScheduler, &pScheduler));
            if (SUCCEEDED(hr))
            {
                IRunnableTask *pTask;
                hr = CNewMenuConsolidator::CreateInstance(IID_PPV_ARG(IRunnableTask, &pTask));
                if (SUCCEEDED(hr))
                {
                    // the background task will set _hEvent for us when it's done.
                    hr = pScheduler->AddTask(pTask, CNewMenuConsolidator::_taskid, NULL, ITSAT_DEFAULT_PRIORITY);
                    pTask->Release();
                }
                pScheduler->Release();
            }
        }

        if (!bUpdate || FAILED(hr))
        {
            // if the scheduler wont activate the event, we do it ourselves.
            SetEvent(_hEvent);
        }
    }
    
    return hr;
}

//  Consolidation worker.
STDMETHODIMP CNewMenuConsolidator::RunInitRT()
{
    ULONG dwErr = ERROR_SUCCESS;

    // the possible owners of the mutex are
    // - nobody, we'll own it
    // - other worker threads like this one
    // - the guy who checks to see if the cached info is in the registry.

    // if there's another worker thread which owns this mutex, then bail, since that one
    // will do all the work we're going to do.
    // if the guy who checks the cached info has it, then bail, since it'll spawn
    // another one of these soon enough.
    // so use a 0 timeout.
    if (WAIT_OBJECT_0 == WaitForSingleObject(_hMutex, 0))
    {
        HKEY  hkeyShellNew = NULL;
        TCHAR szExt[MAX_PATH];
        ULONG dwDisposition;
        //  Delete the existing cache; we'll build it from scratch each time.
        while (ERROR_SUCCESS == (dwErr = RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_SESSION_SHELLNEW,
                                                         0, NULL, 0, KEY_ALL_ACCESS, NULL, 
                                                         &hkeyShellNew, &dwDisposition)) &&
                REG_CREATED_NEW_KEY != dwDisposition)
        {
            //  Key already existed, so delete it, and loop to reopen.
            RegCloseKey(hkeyShellNew);
            SHDeleteKey(HKEY_CURRENT_USER, REGSTR_SESSION_SHELLNEW);
            hkeyShellNew = NULL;
        }

        if (ERROR_SUCCESS == dwErr)
        {
            // Enumerate each subkey of HKCR, looking for New menu items.
            for (int i = 0; RegEnumKey(HKEY_CLASSES_ROOT, i, szExt, ARRAYSIZE(szExt)) == ERROR_SUCCESS; i++)
            {
                TCHAR szClass[CCH_KEYMAX];
                TCHAR szDisplayName[CCH_KEYMAX];
                LONG  cbVal = sizeof(szClass);

                // find .ext that have proper class descriptions with them.
                if ((szExt[0] == TEXT('.')) &&
                    SHRegQueryValue(HKEY_CLASSES_ROOT, szExt, szClass, &cbVal) == ERROR_SUCCESS 
                    && (cbVal > 0) 
                    && GetClassDisplayName(szClass, szDisplayName, ARRAYSIZE(szDisplayName)))
                {
                    NEWOBJECTINFO noi = {0};
                    HKEY          hkeyIterate = NULL;
                    int           iIndex = 0;

                    lstrcpyn(noi.szExt, szExt, ARRAYSIZE(noi.szExt));
                    lstrcpyn(noi.szClass, szClass, ARRAYSIZE(noi.szClass));
                    lstrcpyn(noi.szMenuText, szDisplayName, ARRAYSIZE(noi.szMenuText));
                    noi.iImage = -1;

                    //  Retrieve all additional information for the key.
                    while (GetNewFileInfoForExtension(&noi, NULL, &hkeyIterate, &iIndex)) 
                    {
                        //  Stick it in the cache.
                        RegSetValueEx(hkeyShellNew, noi.szMenuText, NULL, REG_BINARY, 
                                       (LPBYTE)&noi, sizeof(noi));
                    }
                }
            }

            //  Stamp the cache.
            SHELLNEW_CACHE_STAMP stamp;
            CNewMenu_MakeCacheStamp(&stamp);
            RegSetValueEx(hkeyShellNew, REGVAL_SESSION_SHELLNEW_TIMESTAMP,
                           NULL, REG_BINARY, (LPBYTE)&stamp, sizeof(stamp));
            LCID lcid = GetUserDefaultUILanguage();

            RegSetValueEx(hkeyShellNew, REGVAL_SESSION_SHELLNEW_LANG,
                           NULL, REG_DWORD, (LPBYTE)&lcid, sizeof(lcid));
        }
        if (NULL != hkeyShellNew)
            RegCloseKey(hkeyShellNew);

        // signal the event so InitMenuPopup can proceed.
        SetEvent(_hEvent);
        ReleaseMutex(_hMutex);
    }

    return HRESULT_FROM_WIN32(dwErr);
}

BOOL CNewMenu::_InsertNewMenuItem(HMENU hmenu, UINT idCmd, NEWOBJECTINFO *pnoiClone)
{
    if (pnoiClone->szMenuText[0])
    {
        NEWOBJECTINFO *pnoi = (NEWOBJECTINFO *)LocalAlloc(LPTR, sizeof(NEWOBJECTINFO));
        if (pnoi)
        {
            *pnoi = *pnoiClone;

            pnoi->msaa.dwMSAASignature = MSAA_MENU_SIG;
            if (StrChr(pnoi->szMenuText, TEXT('&')) == NULL)
            {
                pnoi->chPrefix = TEXT('&');
                pnoi->msaa.pszWText = &pnoi->chPrefix;
            }
            else
            {
                pnoi->msaa.pszWText = pnoi->szMenuText;
            }
            pnoi->msaa.cchWText = lstrlen(pnoi->msaa.pszWText);

            MENUITEMINFO mii  = {0};
            mii.cbSize        = sizeof(mii);
            mii.fMask         = MIIM_TYPE | MIIM_DATA | MIIM_ID;
            mii.fType         = MFT_OWNERDRAW;
            mii.fState        = MFS_ENABLED;
            mii.wID           = idCmd;
            mii.dwItemData    = (DWORD_PTR)pnoi;
            mii.dwTypeData    = (LPTSTR)pnoi;

            if (-1 != DPA_AppendPtr(_hdpaMenuInfo, pnoi))
            {
                InsertMenuItem(hmenu, -1, TRUE, &mii);
            }
            else
            {
                LocalFree(pnoi);
                return FALSE;
            }
        }
    }

    return TRUE;
}

//  WM_INITMENUPOPUP handler
BOOL CNewMenu::InitMenuPopup(HMENU hmenu)
{
    UINT iStart = 3;
    NEWOBJECTINFO noi = {0};
    if (GetItemData(hmenu, iStart))  //Position 0 is New Folder, 1 shortcut, 2 sep 
        return FALSE;                //already initialized. No need to do anything
    
    _hdpaMenuInfo = DPA_Create(4);
    if (!_hdpaMenuInfo)
        return FALSE;

    //Remove the place holder.
    DeleteMenu(hmenu,0,MF_BYPOSITION);
    
    //Insert New Folder menu item
    LoadString(g_hinst, IDS_NEWFOLDER, noi.szMenuText, ARRAYSIZE(noi.szMenuText));
    noi.dwFlags = NEWTYPE_FOLDER;
    noi.iImage = Shell_GetCachedImageIndex(TEXT("shell32.dll"), II_FOLDER, 0); //Shange to indicate Folder

    _InsertNewMenuItem(hmenu, _idCmdFirst-NEWITEM_MAX+NEWITEM_FOLDER, &noi);
    
    TCHAR szTemp[MAX_PATH+80];       // Add some slop incase we overflow
    //See if the pidl is folder shortcut and if so get the target path.
    SHGetTargetFolderPath(_pidlFolder, szTemp, ARRAYSIZE(szTemp));
    if (IsLFNDrive(szTemp)) //for short filename servers we don't support anything but new folder
    {
        //Insert New Shortcut menu item
        LoadString(g_hinst, IDS_NEWLINK, noi.szMenuText, ARRAYSIZE(noi.szMenuText));
        noi.iImage = Shell_GetCachedImageIndex(TEXT("shell32.dll"), II_LINK, 0); //Shange to indicate Link
        noi.dwFlags = NEWTYPE_LINK;

        _InsertNewMenuItem(hmenu, _idCmdFirst-NEWITEM_MAX+NEWITEM_LINK, &noi);
    
        //Insert menu item separator
        AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);

        // This may take a while, so put up the hourglass
        DECLAREWAITCURSOR;
        SetWaitCursor();

        //  Retrieve extension menu items from cache:

        //  begin synchronize.
        //
        if (WAIT_OBJECT_0 == WaitForSingleObject(_hEvent, INFINITE))
        {
            HKEY hkeyShellNew;
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_SESSION_SHELLNEW, 
                                               0, KEY_ALL_ACCESS, &hkeyShellNew))
            {
                TCHAR szVal[CCH_KEYMAX];
                ULONG cbVal = ARRAYSIZE(szVal);
                ULONG cbData = sizeof(noi);
                ULONG dwType = REG_BINARY;
            
                for (int i = 0; 
                     ERROR_SUCCESS == RegEnumValue(hkeyShellNew, i, szVal, &cbVal, 0,
                                                    &dwType, (LPBYTE)&noi, &cbData);
                     i++)
                {
                    if (lstrcmp(szVal, REGVAL_SESSION_SHELLNEW_TIMESTAMP) != 0 &&
                        sizeof(noi) == cbData && 
                        REG_BINARY == dwType)
                    {
                        SHFILEINFO sfi;
                        _himlSystemImageList = (HIMAGELIST)SHGetFileInfo(noi.szExt, FILE_ATTRIBUTE_NORMAL,
                                                                         &sfi, sizeof(SHFILEINFO), 
                                                                         SHGFI_USEFILEATTRIBUTES | 
                                                                         SHGFI_SYSICONINDEX | 
                                                                         SHGFI_SMALLICON);
                        if (_himlSystemImageList)
                        {
                            //pnoi->himlSmallIcons = sfi.hIcon;
                            noi.iImage = sfi.iIcon;
                        }
                        else
                        {
                            //pnoi->himlSmallIcons = INVALID_HANDLE_VALUE;
                            noi.iImage = -1;
                        }
                    
                        _InsertNewMenuItem(hmenu, _idCmdFirst, &noi);
                    }
                    cbVal = ARRAYSIZE(szVal);
                    cbData = sizeof(noi);
                    dwType = REG_BINARY;
                }

                RegCloseKey(hkeyShellNew);
            }

            //  consolidate menu items following display.
            ConsolidateMenuItems(TRUE);
        }
        ResetWaitCursor();
    }

    return TRUE;
}

NEWOBJECTINFO *CNewMenu::GetItemData(HMENU hmenu, UINT iItem)
{
    MENUITEMINFO mii;
    
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA | MIIM_STATE;
    mii.cch = 0;     // just in case...
    
    if (GetMenuItemInfo(hmenu, iItem, TRUE, &mii))
        return (NEWOBJECTINFO *)mii.dwItemData;
    
    return NULL;
}

LPTSTR ProcessArgs(LPTSTR szArgs,...)
{
    LPTSTR szRet;
    va_list ArgList;
    va_start(ArgList,szArgs);
    if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        szArgs, 0, 0, (LPTSTR)&szRet, 0, &ArgList))
    {
        return NULL;
    }
    va_end(ArgList);
    return szRet;
}


HRESULT CNewMenu::RunCommand(HWND hwnd, LPCTSTR pszPath, LPCTSTR pszRun)
{
    SHELLEXECUTEINFO ei = { 0 };
    TCHAR szCommand[MAX_PATH];
    TCHAR szRun[MAX_PATH];
    
    SHExpandEnvironmentStrings(pszRun, szCommand, ARRAYSIZE(szCommand));
    lstrcpyn(szRun, szCommand, ARRAYSIZE(szRun));
    PathRemoveArgs(szCommand);
    
    //
    //  Mondo hackitude-o-rama.
    //
    //  Win95, IE3, SDK:  %1 - filename
    //
    //  IE4:              %1 - hwnd, %2 = filename
    //
    //  So IE4 broken Win95 compat and broke compat with the SDK.
    //  For IE5 we restore compat with Win95 and the SDK, while
    //  still generating an IE4-style command if we detect that the
    //  registry key owner tested with IE4 rather than following the
    //  instructions in the SDK.
    //
    //  The algorithm is like this:
    //
    //  If we see a "%2", then use %1 - hwnd, %2 - filename
    //  Otherwise, use             %1 - filename, %2 - hwnd
    //

    LPTSTR pszArgs = PathGetArgs(szRun);
    LPTSTR ptszPercent2 = StrStr(pszArgs, TEXT("%2"));
    if (ptszPercent2 && ptszPercent2[2] != TEXT('!'))
    {
        // App wants %1 = hwnd and %2 = filename
        pszArgs = ProcessArgs(pszArgs, (DWORD_PTR)hwnd, pszPath);
    }
    else
    {
        // App wants %2 = hwnd and %1 = filename
        pszArgs = ProcessArgs(pszArgs, pszPath, (DWORD_PTR)hwnd);
    }

    HRESULT hr;
    
    if (pszArgs) 
    {
        HMONITOR hMon = MonitorFromPoint(_ptNewItem, MONITOR_DEFAULTTONEAREST);
        if (hMon)
        {
            ei.fMask |= SEE_MASK_HMONITOR;
            ei.hMonitor = (HANDLE)hMon;
        }
        ei.hwnd            = hwnd;
        ei.lpFile          = szCommand;
        ei.lpParameters    = pszArgs;
        ei.nShow           = SW_SHOWNORMAL;
        ei.cbSize          = sizeof(ei);

        if (ShellExecuteEx(&ei)) 
            hr = S_FALSE;   // Return S_FALSE because ShellExecuteEx is not atomic
        else
            hr = E_FAIL;
        
        LocalFree(pszArgs);
    } 
    else
        hr = E_OUTOFMEMORY;
    
    return hr;
}


HRESULT CNewMenu::CopyTemplate(IStream *pStream, NEWFILEINFO *pnfi)
{
    TCHAR szSrcFolder[MAX_PATH], szSrc[MAX_PATH];

    szSrc[0] = 0;

    // failure here is OK, we will try CSIDL_COMMON_TEMPLATES too.
    if (SHGetSpecialFolderPath(NULL, szSrcFolder, CSIDL_TEMPLATES, FALSE))
    {
        PathCombine(szSrc, szSrcFolder, (LPTSTR)pnfi->lpData);
        if (!PathFileExistsAndAttributes(szSrc, NULL))
            szSrc[0] = 0;
    }

    if (szSrc[0] == 0)
    {
        if (SHGetSpecialFolderPath(NULL, szSrcFolder, CSIDL_COMMON_TEMPLATES, FALSE))
        {
            PathCombine(szSrc, szSrcFolder, (LPTSTR)pnfi->lpData);
            if (!PathFileExistsAndAttributes(szSrc, NULL))
                szSrc[0] = 0;
        }
    }

    if (szSrc[0] == 0)
    {
        // work around CSIDL_TEMPLATES not being setup right or
        // templates that are left in the old %windir%\shellnew location

        GetWindowsDirectory(szSrcFolder, ARRAYSIZE(szSrcFolder));
        PathAppend(szSrcFolder, TEXT("ShellNew"));

        // note: if the file spec is fully qualified szSrcFolder is ignored
        PathCombine(szSrc, szSrcFolder, (LPTSTR)pnfi->lpData);
    }

    //
    //  we just allow a null file to be created when the copy fails.
    //  this is for appcompat with office97.  they fail to copy winword8.doc
    //  anywhere on the system.  on win2k we succeed anyway with an empty file.
    //
    return SUCCEEDED(StgCopyFileToStream(szSrc, pStream)) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\winnt\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\shfvocx.cpp ===
#include "stdafx.h"
#pragma hdrstop

class CShellFolderViewOC;

class CDViewEvents : public DShellFolderViewEvents
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo,LCID lcid,ITypeInfo **pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID *rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
              DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo,UINT *puArgErr);

    CDViewEvents(CShellFolderViewOC * psfvOC) { _psfvOC = psfvOC; };
    ~CDViewEvents() {};

protected:
    CShellFolderViewOC * _psfvOC;
};

class ATL_NO_VTABLE CShellFolderViewOC
                    : public CComObjectRootEx<CComSingleThreadModel>
                    , public CComCoClass<CShellFolderViewOC, &CLSID_ShellFolderViewOC>
                    , public IDispatchImpl<IFolderViewOC, &IID_IFolderViewOC, &LIBID_Shell32>
                    , public IProvideClassInfo2Impl<&CLSID_ShellFolderView, NULL, &LIBID_Shell32>
                    , public IObjectSafetyImpl<CShellFolderViewOC, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
                    , public IConnectionPointContainerImpl<CShellFolderViewOC>
                    , public IConnectionPointImpl<CShellFolderViewOC, &DIID_DShellFolderViewEvents>
                    , public CComControl<CShellFolderViewOC>
                    , public IPersistStreamInitImpl<CShellFolderViewOC>
                    , public IOleControlImpl<CShellFolderViewOC>
                    , public IOleObjectImpl<CShellFolderViewOC>
                    , public IOleInPlaceActiveObjectImpl<CShellFolderViewOC>
                    , public IOleInPlaceObjectWindowlessImpl<CShellFolderViewOC>
                    , public ICommDlgBrowser
//                  , public IViewObjectExImpl<CShellFolderViewOC>
{
public:
    // DECLARE_POLY_AGGREGATABLE(CShellFolderViewOC);
    DECLARE_NO_REGISTRY();

BEGIN_COM_MAP(CShellFolderViewOC)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IFolderViewOC)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    // COM_INTERFACE_ENTRY(ICommDlgBrowser)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CShellFolderViewOC)
    CONNECTION_POINT_ENTRY(DIID_DShellFolderViewEvents)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CShellFolderViewOC)
    MESSAGE_HANDLER(WM_DESTROY, _ReleaseForwarderMessage) 
END_MSG_MAP()

BEGIN_PROPERTY_MAP(CShellFolderViewOC)
END_PROPERTY_MAP()

    // IOleWindow
    STDMETHODIMP GetWindow(HWND * phwnd) {return IOleInPlaceActiveObjectImpl<CShellFolderViewOC>::GetWindow(phwnd);};
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return IOleInPlaceActiveObjectImpl<CShellFolderViewOC>::ContextSensitiveHelp(fEnterMode); };

    // IOleInPlaceObject
    STDMETHODIMP InPlaceDeactivate(void) {return IOleInPlaceObject_InPlaceDeactivate();};
    STDMETHODIMP UIDeactivate(void) { return IOleInPlaceObject_UIDeactivate(); };
    STDMETHODIMP SetObjectRects(LPCRECT prcPosRect, LPCRECT prcClipRect) { return IOleInPlaceObject_SetObjectRects(prcPosRect, prcClipRect); };
    STDMETHODIMP ReactivateAndUndo(void)  { return E_NOTIMPL; };

    // IObjectWithSite overrides
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    // IFolderViewOC
    STDMETHODIMP SetFolderView(IDispatch *pDisp);

    // IShellBrowser (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pMenuWidths);
    STDMETHOD(SetMenuSB) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHOD(RemoveMenusSB) (THIS_ HMENU hmenuShared);
    STDMETHOD(SetStatusTextSB) (THIS_ LPCOLESTR pszStatusText);
    STDMETHOD(EnableModelessSB) (THIS_ BOOL fEnable);
    STDMETHOD(TranslateAcceleratorSB) (THIS_ LPMSG pmsg, WORD wID);

    // IShellBrowser
    STDMETHOD(BrowseObject)(THIS_ LPCITEMIDLIST pidl, UINT wFlags);
    STDMETHOD(GetViewStateStream)(THIS_ DWORD grfMode, IStream **pStrm);
    STDMETHOD(GetControlWindow)(THIS_ UINT id, HWND *phwnd);
    STDMETHOD(SendControlMsg)(THIS_ UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHOD(QueryActiveShellView)(THIS_ IShellView **ppshv);
    STDMETHOD(OnViewWindowActive)(THIS_ IShellView *pshv);
    STDMETHOD(SetToolbarItems)(THIS_ LPTBBUTTON pButtons, UINT nButtons, UINT uFlags);

    // ICommDlgBrowser
    STDMETHOD(OnDefaultCommand) (THIS_ IShellView *psv);
    STDMETHOD(OnStateChange) (THIS_ IShellView *psv, ULONG uChange);
    STDMETHOD(IncludeObject) (THIS_ IShellView *psv, LPCITEMIDLIST pItem);

    // ICommDlgBrowser2
    // STDMETHOD(Notify) (THIS_ IShellView *psv, DWORD dwNotifyType);
    // STDMETHOD(GetDefaultMenuText) (THIS_ IShellView *psv, WCHAR *pszText, INT cchMax);
    // STDMETHOD(GetViewFlags)(THIS_ DWORD *pdwFlags);

    friend class CDViewEvents;

protected:
    CShellFolderViewOC();
    ~CShellFolderViewOC();

private:
    HRESULT _SetupForwarder(void);
    void    _ReleaseForwarder(void);
    LRESULT _ReleaseForwarderMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);

    IDispatch    *_pFolderView;  // Hold onto ShellFolderView IDispatch
    DWORD        _dwViewEventsCookie;       // Have we installed _dViewEvents in browser?
    CDViewEvents _dViewEvents;
};

CShellFolderViewOC::CShellFolderViewOC() : 
    _dwViewEventsCookie(0), _pFolderView(NULL), _dViewEvents(this)
{
}

CShellFolderViewOC::~CShellFolderViewOC()
{
    ATOMICRELEASE(_pFolderView);
}

// IShellBrowser (same as IOleInPlaceFrame)
STDMETHODIMP CShellFolderViewOC::InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pMenuWidths)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellFolderViewOC::SetMenuSB(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellFolderViewOC::RemoveMenusSB(HMENU hmenuShared)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellFolderViewOC::SetStatusTextSB(LPCOLESTR pwch)
{
    return S_OK;
}

STDMETHODIMP CShellFolderViewOC::EnableModelessSB(BOOL fEnable)
{
    return S_OK;
}

STDMETHODIMP CShellFolderViewOC::TranslateAcceleratorSB(LPMSG pmsg, WORD wID)
{
    return S_FALSE;
}

// IShellBrowser
STDMETHODIMP CShellFolderViewOC::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    return S_OK;
}

STDMETHODIMP CShellFolderViewOC::GetViewStateStream(DWORD grfMode, IStream **pStrm)
{
    *pStrm = NULL;
    return  E_FAIL;
}

STDMETHODIMP CShellFolderViewOC::GetControlWindow(UINT id, HWND *phwnd)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellFolderViewOC::SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellFolderViewOC::QueryActiveShellView(IShellView **ppsv)
{
    *ppsv = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP CShellFolderViewOC::OnViewWindowActive(IShellView *psv)
{
    return S_OK;
}

STDMETHODIMP CShellFolderViewOC::SetToolbarItems(LPTBBUTTON pButtons, UINT nButtons, UINT uFlags)
{
    return S_OK;
}


STDMETHODIMP CShellFolderViewOC::OnDefaultCommand(IShellView *psv)
{
    HRESULT hr = S_FALSE;   // we did not handle it
#if 0
    IShellFolderView *psfv;
    if (SUCCEEDED(psv->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv))))
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(psfv->GetObject(&pidl, (UINT)-2)))
        {
            IShellBrowser *psb;

            if (SUCCEEDED(IUnknown_QueryService(psv, SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
            {
                psb->BrowseObject(pidl, SBSP_RELATIVE | SBSP_OPENMODE);
                psb->Release();
            }
            // note, we don't free pidl as we got an alias
        }
        psfv->Release();
    }
#endif
    return hr;
}

STDMETHODIMP CShellFolderViewOC::OnStateChange(IShellView *psv, ULONG uChange)
{
    switch (uChange)
    {
    case CDBOSC_SETFOCUS:
        break;
    case CDBOSC_KILLFOCUS:
        break;
    case CDBOSC_SELCHANGE:
        break;
    case CDBOSC_RENAME:
        break;
    default:
        return E_NOTIMPL;
    }
    
    return S_OK;
}

STDMETHODIMP CShellFolderViewOC::IncludeObject(IShellView *psv, LPCITEMIDLIST pidl)
{
    return S_OK;
}


// IFolderViewOC

HRESULT CShellFolderViewOC::SetFolderView(IDispatch *pDisp)
{
    HRESULT hr = S_OK;

    _ReleaseForwarder();    // cleanup previous state

    IUnknown_Set((IUnknown **)&_pFolderView, pDisp);
    if (_pFolderView)
        hr = _SetupForwarder();

    return hr;
}

#define SID_CommonDialogBrowser IID_ICommDlgBrowser

STDMETHODIMP CShellFolderViewOC::SetClientSite(IOleClientSite *pClientSite)
{
#if 0
    // setup or tear down our service object
    if (pClientSite)
        IUnknown_ProfferService(pClientSite, SID_CommonDialogBrowser, SAFECAST(this, ICommDlgBrowser *), &_dwServiceCookie);
    else if (m_spClientSite)
    {
        SetFolderView(NULL);    // break circular refs
        IUnknown_ProfferService(m_spClientSite, SID_CommonDialogBrowser, NULL, &_dwServiceCookie);
    }
#endif
    return IOleObjectImpl<CShellFolderViewOC>::SetClientSite(pClientSite);
}


HRESULT CShellFolderViewOC::_SetupForwarder()
{
    return ConnectToConnectionPoint(SAFECAST(&_dViewEvents, IDispatch *), DIID_DShellFolderViewEvents, TRUE, _pFolderView, &_dwViewEventsCookie, NULL);
}

void CShellFolderViewOC::_ReleaseForwarder()
{
    ConnectToConnectionPoint(NULL, DIID_DShellFolderViewEvents, FALSE, _pFolderView, &_dwViewEventsCookie, NULL);
}


// ATL maintainence functions
LRESULT CShellFolderViewOC::_ReleaseForwarderMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    bHandled = FALSE;
    _ReleaseForwarder();
    return 0;
}

STDMETHODIMP CDViewEvents::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI2(CDViewEvents, DIID_DShellFolderViewEvents, DShellFolderViewEvents),
        QITABENTMULTI(CDViewEvents, IDispatch, DShellFolderViewEvents),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CDViewEvents::AddRef()
{
    return SAFECAST(_psfvOC, IFolderViewOC*)->AddRef();
}

ULONG CDViewEvents::Release()
{
    return SAFECAST(_psfvOC, IFolderViewOC*)->Release();
}

STDMETHODIMP CDViewEvents::GetTypeInfoCount(UINT * pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDViewEvents::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDViewEvents::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, 
                                         UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDViewEvents::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                  DISPPARAMS *pdispparams, VARIANT *pvarResult, 
                                  EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    SHINVOKEPARAMS inv;
    inv.flags = 0;
    inv.dispidMember = dispidMember;
    inv.piid = &riid;
    inv.lcid = lcid;
    inv.wFlags = wFlags;
    inv.pdispparams = pdispparams;
    inv.pvarResult = pvarResult;
    inv.pexcepinfo = pexcepinfo;
    inv.puArgErr = puArgErr;

    return IUnknown_CPContainerInvokeIndirect(SAFECAST(_psfvOC, IFolderViewOC *), DIID_DShellFolderViewEvents, &inv);
}

STDAPI CShellFolderViewOC_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    return CComCreator< CComObject< CShellFolderViewOC > >::CreateInstance((void *)punkOuter, riid, ppvOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

BOOL IsExplorerWindow(HWND hwnd);
BOOL IsFolderWindow(HWND hwnd);
BOOL IsTrayWindow(HWND hwnd);

BOOL MyInternetSetOption(HANDLE h, DWORD dw1, LPVOID lpv, DWORD dw2);
STDAPI_(BOOL) IsDesktopWindow(HWND hwnd);
HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType, OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData);

STDAPI IsSafePage(IUnknown *punkSite);
STDAPI SHPropertyBag_WritePunk(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN IUnknown * punk);


BOOL IconSetRegValueString(const CLSID* pclsid, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPCTSTR lpszValue);
BOOL IconGetRegValueString(const CLSID* pclsid, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPTSTR lpszValue, int cchValue);

BOOL CALLBACK Cabinet_RefreshEnum(HWND hwnd, LPARAM lParam);
BOOL CALLBACK Cabinet_UpdateWebViewEnum(HWND hwnd, LPARAM lParam);
void Cabinet_RefreshAll(WNDENUMPROC lpEnumFunc, LPARAM lParam);

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\srccpp.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

!include $(CCSHELL_DIR)\shell32\shell32.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\shell32\shell32.inc

NO_BROWSER_FILE = 1

TARGETNAME      = unicpp
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = \
                  ..\adjust.cpp   \
                  ..\admoveri.cpp \
                  ..\advanced.cpp \
                  ..\colorctrl.cpp \
                  ..\cpymovto.cpp \
                  ..\dback.cpp    \
                  ..\dbackp.cpp   \
                  ..\dcomp.cpp    \
                  ..\dcompp.cpp   \
                  ..\dde.cpp      \
                  ..\deskcls.cpp  \
                  ..\deskhtml.cpp \
                  ..\deskmovr.cpp \
                  ..\deskstat.cpp \
                  ..\desktop.cpp  \
                  ..\dsubscri.cpp \
                  ..\dvoc.cpp     \
                  ..\dvutil.cpp   \
                  ..\dutil.cpp    \
                  ..\dvutil.cpp   \
                  ..\fldoppsx.cpp \
                  ..\libx.cpp     \
                  ..\mimeflt.cpp  \
                  ..\options.cpp  \
                  ..\propbag.cpp  \
                  ..\sendto.cpp   \
                  ..\sdmigwiz.cpp \
                  ..\shfvocx.cpp  \
                  ..\startmnu.cpp \
                  ..\utils.cpp    \


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\utils.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include <mshtml.h>


// let the shell dispatch objects know where to get their type lib
// (this stuff lives here for no better reason than it must be in some cpp file)
EXTERN_C GUID g_guidLibSdspatch = LIBID_Shell32;
EXTERN_C USHORT g_wMajorVerSdspatch = 1;
EXTERN_C USHORT g_wMinorVerSdspatch = 0;

// This isn't a typical delay load since it's called only if wininet
// is already loaded in memory. Otherwise the call is dropped on the floor.
// Defview did it this way I assume to keep WININET out of first boot time.
BOOL MyInternetSetOption(HANDLE h, DWORD dw1, LPVOID lpv, DWORD dw2)
{
    BOOL bRet = FALSE;
    HMODULE hmod = GetModuleHandle(TEXT("wininet.dll"));
    if (hmod)
    {
        typedef BOOL (*PFNINTERNETSETOPTIONA)(HANDLE h, DWORD dw1, LPVOID lpv, DWORD dw2);
        PFNINTERNETSETOPTIONA fp = (PFNINTERNETSETOPTIONA)GetProcAddress(hmod, "InternetSetOptionA");
        if (fp)
        {
            bRet = fp(h, dw1, lpv, dw2);
        }
    }
    return bRet;
}

// REVIEW: maybe just check (hwnd == GetShellWindow())

STDAPI_(BOOL) IsDesktopWindow(HWND hwnd)
{
    TCHAR szName[80];

    GetClassName(hwnd, szName, ARRAYSIZE(szName));
    if (!lstrcmp(szName, TEXT(STR_DESKTOPCLASS)))
    {
        return hwnd == GetShellWindow();
    }
    return FALSE;
}

// returns:
//      S_OK                returned if the .htt (web view template) file associated with the folder we're viewing is trusted
//      S_FALSE or 
//      E_ACCESSDENIED      bad... don't expose local machine access

STDAPI IsSafePage(IUnknown *punkSite)
{
    // Return S_FALSE if we don't have a host site since we have no way of doing a 
    // security check.  This is as far as VB 5.0 apps get.
    if (!punkSite)
        return S_FALSE;

    HRESULT hr = E_ACCESSDENIED;
    WCHAR wszPath[MAX_PATH];
    wszPath[0] = 0;

    // There are two safe cases:
    // 1) we are contained by a signed MD5 hashed defview template.
    // 2) we are contained by a .html file that's on the Local Zone
    //
    // Case 1) find the template path from webview...
    VARIANT vPath = {0};
    hr = IUnknown_QueryServiceExec(punkSite, SID_DefView, &CGID_DefView, DVCMDID_GETTEMPLATEDIRNAME, 0, NULL, &vPath);
    if (SUCCEEDED(hr))
    {
        if (vPath.vt == VT_BSTR && vPath.bstrVal)
        {
            DWORD cchPath = ARRAYSIZE(wszPath);
            if (S_OK != PathCreateFromUrlW(vPath.bstrVal, wszPath, &cchPath, 0))
            {
                // it might not be an URL, in this case it is a file path
                StrCpyNW(wszPath, vPath.bstrVal, ARRAYSIZE(wszPath));
            }

            // it might not be an URL, in this case it is a file path
            // allow intranet if this is hosted under defview
            hr = SHRegisterValidateTemplate(wszPath, SHRVT_VALIDATE | SHRVT_ALLOW_INTRANET | SHRVT_PROMPTUSER | SHRVT_REGISTERIFPROMPTOK);
        }
        VariantClear(&vPath);
    }
    else
    {
        IUnknown* punkToFree = NULL;

        // ask the browser, for example we are in a .HTM doc
        BOOL fFound = FALSE;
        do
        {
            IBrowserService* pbs;
            hr = IUnknown_QueryService(punkSite, SID_SShellBrowser, IID_PPV_ARG(IBrowserService, &pbs));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidl;

                hr = pbs->GetPidl(&pidl);
                if (SUCCEEDED(hr))
                {
                    DWORD dwAttribs = SFGAO_FOLDER;
                    hr = SHGetNameAndFlagsW(pidl, SHGDN_FORPARSING, wszPath, ARRAYSIZE(wszPath), &dwAttribs);
                    if (dwAttribs & SFGAO_FOLDER)
                    {
                        // A folder is not a .HTM file, so continue on up...
                        wszPath[0] = 0;
                        ATOMICRELEASE(punkToFree);
                        hr = IUnknown_GetSite(pbs, IID_PPV_ARG(IUnknown, &punkToFree)); // gotta start with pbs's parent (otherwise you'll get the same pbs again)
                        if (FAILED(hr)) // to get by the weboc you need to explicitly ask for the oc's parent:
                        {
                            hr = IUnknown_QueryService(pbs, SID_QIClientSite, IID_PPV_ARG(IUnknown, &punkToFree));
                        }
                        punkSite = punkToFree;
                    }
                    else
                    {
                        // Found the nearest containing non-folder object.
                        fFound = TRUE;
                        hr = LocalZoneCheckPath(wszPath, punkSite); // check for local zone
                    }

                    ILFree(pidl);
                }
                pbs->Release();
            }
        } while (SUCCEEDED(hr) && !fFound);

        ATOMICRELEASE(punkToFree);
    }

    if (S_OK != hr)
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}


HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType,
                    OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData)
{
    DWORD dwError = SHGetValue(hKey, pszSubKey, pszValue, pdwType, pvData, pcbData);

    return HRESULT_FROM_WIN32(dwError);
}


STDAPI SHPropertyBag_WritePunk(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN IUnknown * punk)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName)
    {
        VARIANT va;

        va.vt = VT_UNKNOWN;
        va.punkVal = punk;

        hr = pPropertyPage->Write(pwzPropName, &va);
    }

    return hr;
}


BOOL _GetRegValueString(HKEY hKey, LPCTSTR pszValName, LPTSTR pszString, int cchSize)
{
    DWORD cbSize = sizeof(pszString[0]) * cchSize;
    DWORD dwType;
    DWORD dwError = RegQueryValueEx(hKey, pszValName, NULL, &dwType, (LPBYTE)pszString, &cbSize);

    return (ERROR_SUCCESS == dwError);
}


//------------------------------------------------------------------------------------
//      SetRegValueString()
//
//      Just a little helper routine that takes string and writes it to the     registry.
//      Returns: success writing to Registry, should be always TRUE.
//------------------------------------------------------------------------------------
BOOL SetRegValueString(HKEY hMainKey, LPCTSTR pszSubKey, LPCTSTR pszRegValue, LPCTSTR pszString)
{
    HKEY hKey;
    DWORD dwDisposition;
    BOOL fSucceeded = FALSE;

    DWORD dwError = RegCreateKeyEx(hMainKey, pszSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hKey, &dwDisposition);
    if (ERROR_SUCCESS == dwError)
    {
        dwError = SHRegSetPath(hKey, NULL, pszRegValue, pszString, 0);
        if (ERROR_SUCCESS == dwError)
        {
            fSucceeded = TRUE;
        }

        RegCloseKey(hKey);
    }

    return fSucceeded;
}


//------------------------------------------------------------------------------------
//
//      SetRegValueInt()
//
//      Just a little helper routine that takes an int and writes it as a string to the
//      registry.
//
//      Returns: success writing to Registry, should be always TRUE.
//
//------------------------------------------------------------------------------------
BOOL SetRegValueInt( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int iValue )
{
    TCHAR szValue[16];

    wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), iValue);
    return SetRegValueString( hMainKey, lpszSubKey, lpszValName, szValue );
}




//------------------------------------------------------------------------------------
//
//      IconSet/GetRegValueString()
//
//      Versions of Get/SetRegValueString that go to the user classes section.
//
//      Returns: success of string setting / retrieval
//
//------------------------------------------------------------------------------------
BOOL IconSetRegValueString(const CLSID* pclsid, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPCTSTR lpszValue)
{
    HKEY hkey;
    if (SUCCEEDED(SHRegGetCLSIDKey(*pclsid, lpszSubKey, TRUE, TRUE, &hkey)))
    {
        DWORD dwRet = SHRegSetPath(hkey, NULL, lpszValName, lpszValue, 0);
        RegCloseKey(hkey);
        return (dwRet == ERROR_SUCCESS);
    }

    return FALSE;
}


BOOL IconGetRegValueString(const CLSID* pclsid, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPTSTR lpszValue, int cchValue)
{
    HKEY hkey;
    if (SUCCEEDED(SHRegGetCLSIDKey(*pclsid, lpszSubKey, TRUE, FALSE, &hkey)) ||
        SUCCEEDED(SHRegGetCLSIDKey(*pclsid, lpszSubKey, FALSE, FALSE, &hkey)))
    {
        BOOL fRet = _GetRegValueString(hkey, lpszValName, lpszValue, cchValue);
        RegCloseKey(hkey);
        return fRet;
    }
    return FALSE;
}

BOOL CALLBACK Cabinet_RefreshEnum(HWND hwnd, LPARAM lParam)
{
    if (IsFolderWindow(hwnd) || IsExplorerWindow(hwnd))
    {
        PostMessage(hwnd, WM_COMMAND, FCIDM_REFRESH, lParam);
    }

    return(TRUE);
}

BOOL CALLBACK Cabinet_UpdateWebViewEnum(HWND hwnd, LPARAM lParam)
{
    if (IsFolderWindow(hwnd) || IsExplorerWindow(hwnd))
    {
        // A value of -1L for lParam will force a refresh by loading the View window
        // with the new VID as specified in the global DefFolderSettings.
        PostMessage(hwnd, WM_COMMAND, SFVIDM_MISC_SETWEBVIEW, lParam);
    }
    return(TRUE);
}

void Cabinet_RefreshAll(WNDENUMPROC lpEnumFunc, LPARAM lParam)
{
    HWND hwnd = FindWindowEx(NULL, NULL, TEXT(STR_DESKTOPCLASS), NULL);
    if (hwnd)
        PostMessage(hwnd, WM_COMMAND, FCIDM_REFRESH, 0L);

    hwnd = FindWindowEx(NULL, NULL, TEXT("Shell_TrayWnd"), NULL);
    if (hwnd)
        PostMessage(hwnd, TM_REFRESH, 0, 0L);

    EnumWindows(lpEnumFunc, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\stdafx.h ===
// Precompiled header for UNICPP

#ifndef _UNICPP_PCH__
#define _UNICPP_PCH__

#include "w4warn.h"
#pragma warning(disable:4131)  // 'CreateInfoFile' : uses old-style declarator
#pragma warning(disable:4702) // unreachable code


#define _SHELL32_

#ifdef WINNT
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
}
#endif

#undef STRICT

#include <shellprv.h>

#include <shlobj.h>

#include <shlwapi.h>
#include <shellp.h>
#include <shellids.h>
#include <shguidp.h>
#include <shlwapip.h>
#include <shsemip.h>
#include <desktopp.h>

#include <InetReg.h>
#include <cplext.h>
#include <dbt.h>        
#include <devioctl.h>
#include <fsmenu.h>
#include <hliface.h>
#include <iethread.h>
#include <inetreg.h>
#include <intshcut.h>
#include <mshtmdid.h>
#include <mshtml.h>

#include <objsafe.h>
#include <oleauto.h>
#include <olectl.h>

#include <regstr.h>
#include <stdarg.h>
#include <stdio.h>
#include <trayp.h>
#include <urlmon.h>
#include <webcheck.h>

#include <objclsid.h>
#include <objwindow.h>

#include "debug.h"
#include "shellp.h"
#include "shlguid.h"
#include "shguidp.h"
#include "clsobj.h"

#include "local.h"
#include "deskstat.h"
#include "dutil.h"

#include "admovr2.h"
#include "advanced.h"
#include "clsobj.h"
#include "dback.h"
#include "dbackp.h"
#include "dcomp.h"
#include "dcompp.h"
#include "deskcls.h"
#include "deskhtm.h"
#include "deskhtml.h"
#include "deskstat.h"
#include "dsubscri.h"
#include "dutil.h"
#include "expdsprt.h"
#include "hnfblock.h"
#include "local.h"
#include "msstkppg.h"
#include "options.h"
#include "resource.h"
#include "schedule.h"
#include "utils.h"
#include "comcat.h"
#include "netview.h"
#include "ids.h"
#include "fldset.h"
#include "recdocs.h"
#include "brfcasep.h"
#include "startids.h"
#include "defview.h"
#include "htmlhelp.h"
#include "uemapp.h"
#include "expdsprt.h"
#include "dspsprt.h"

// The W version of this API has been implemented in shlwapi, so we save code
// and use that version.  If we include w95wraps.h we'll get this definition
// for us, but shell32 isn't single binary yet so we don't use it.
#define ShellMessageBoxW ShellMessageBoxWrapW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\unicpp\startmnu.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include <shlobjp.h>
#include <initguid.h>
#include "apithk.h"
#include "resource.h"
#include <runtask.h>
#include <msi.h>
#include <msip.h>

#define REGSTR_EXPLORER_WINUPDATE REGSTR_PATH_EXPLORER TEXT("\\WindowsUpdate")

#define IDM_TOPLEVELSTARTMENU  0

// StartMenuInit Flags
#define STARTMENU_DISPLAYEDBEFORE       0x00000001
#define STARTMENU_CHEVRONCLICKED        0x00000002

// New item counts for UEM stuff
#define UEM_NEWITEMCOUNT 2


// Menuband per pane user data
typedef struct
{
    BITBOOL _fInitialized;
} SMUSERDATA;

// for g_hdpaDarwinAds
EXTERN_C CRITICAL_SECTION g_csDarwinAds = {0};

#define ENTERCRITICAL_DARWINADS EnterCriticalSection(&g_csDarwinAds)
#define LEAVECRITICAL_DARWINADS LeaveCriticalSection(&g_csDarwinAds)

// The threading concern with this variable is create/delete/add/remove. We will only remove an item 
// and delete the hdpa on the main thread. We will however add and create on both threads.
// We need to serialize access to the dpa, so we're going to grab the shell crisec.
HDPA g_hdpaDarwinAds = NULL;

class CDarwinAd
{
public:
    LPITEMIDLIST    _pidl;
    LPTSTR          _pszDescriptor;
    LPTSTR          _pszLocalPath;
    INSTALLSTATE    _state;

    CDarwinAd(LPITEMIDLIST pidl, LPTSTR psz)
    {
        // I take ownership of this pidl
        _pidl = pidl;
        Str_SetPtr(&_pszDescriptor, psz);
    }

    void CheckInstalled()
    {
        TCHAR szProduct[GUIDSTR_MAX];
        TCHAR szFeature[MAX_FEATURE_CHARS];
        TCHAR szComponent[GUIDSTR_MAX];

        if (MsiDecomposeDescriptor(_pszDescriptor, szProduct, szFeature, szComponent, NULL) == ERROR_SUCCESS)
        {
            _state = MsiQueryFeatureState(szProduct, szFeature);
        }
        else
        {
            _state = INSTALLSTATE_INVALIDARG;
        }

        // Note: Cannot use ParseDarwinID since that bumps the usage count
        // for the app and we're not running the app, just looking at it.
        // Also because ParseDarwinID tries to install the app (eek!)
        //
        // Must ignore INSTALLSTATE_SOURCE because MsiGetComponentPath will
        // try to install the app even though we're just querying...
        TCHAR szCommand[MAX_PATH];
        DWORD cch = ARRAYSIZE(szCommand);

        if (_state == INSTALLSTATE_LOCAL &&
            MsiGetComponentPath(szProduct, szComponent, szCommand, &cch) == _state)
        {
            PathUnquoteSpaces(szCommand);
            Str_SetPtr(&_pszLocalPath, szCommand);
        }
        else
        {
            Str_SetPtr(&_pszLocalPath, NULL);
        }
    }

    BOOL IsAd()
    {
        return _state == INSTALLSTATE_ADVERTISED;
    }

    ~CDarwinAd()
    {
        ILFree(_pidl);
        Str_SetPtr(&_pszDescriptor, NULL);
        Str_SetPtr(&_pszLocalPath, NULL);
    }
};

int GetDarwinIndex(LPCITEMIDLIST pidlFull, CDarwinAd** ppda);

HRESULT GetMyPicsDisplayName(LPTSTR pszBuffer, UINT cchBuffer)
{
    LPITEMIDLIST pidlMyPics = SHCloneSpecialIDList(NULL, CSIDL_MYPICTURES, FALSE);
    if (pidlMyPics)
    {
        HRESULT hRet = SHGetNameAndFlags(pidlMyPics, SHGDN_NORMAL, pszBuffer, cchBuffer, NULL);
        ILFree(pidlMyPics);
        return hRet;
    }
    return E_FAIL;
}


BOOL AreIntelliMenusEnabled()
{
    DWORD dwRest = SHRestricted(REST_INTELLIMENUS);
    if (dwRest != RESTOPT_INTELLIMENUS_USER)
        return (dwRest == RESTOPT_INTELLIMENUS_ENABLED);

    return SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("IntelliMenus"),
                               FALSE, TRUE); // Don't ignore HKCU, Enable Menus by default
}

BOOL FeatureEnabled(LPTSTR pszFeature)
{
    return SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, pszFeature,
                        FALSE, // Don't ignore HKCU
                        FALSE); // Disable this cool feature.
}


// Since we can be presented with an Augmented shellfolder and we need a Full pidl,
// we have been given the responsibility to unwrap it for perf reasons.
LPITEMIDLIST FullPidlFromSMData(LPSMDATA psmd)
{
    LPITEMIDLIST pidlItem;
    LPITEMIDLIST pidlFolder = NULL;
    LPITEMIDLIST pidlFull = NULL;
    IAugmentedShellFolder2* pasf2;
    if (SUCCEEDED(psmd->psf->QueryInterface(IID_PPV_ARG(IAugmentedShellFolder2, &pasf2))))
    {
        if (SUCCEEDED(pasf2->UnWrapIDList(psmd->pidlItem, 1, NULL, &pidlFolder, &pidlItem, NULL)))
        {
            pidlFull = ILCombine(pidlFolder, pidlItem);
            ILFree(pidlFolder);
            ILFree(pidlItem);
        }
        pasf2->Release();
    }

    if (!pidlFolder)
    {
        pidlFull = ILCombine(psmd->pidlFolder, psmd->pidlItem);
    }

    return pidlFull;
}

//
//  Determine whether a namespace pidl in a merged shellfolder came
//  from the specified object GUID.
//
BOOL IsMergedFolderGUID(IShellFolder *psf, LPCITEMIDLIST pidl, REFGUID rguid)
{
    IAugmentedShellFolder* pasf;
    BOOL fMatch = FALSE;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IAugmentedShellFolder, &pasf))))
    {
        GUID guid;
        if (SUCCEEDED(pasf->GetNameSpaceID(pidl, &guid)))
        {
            fMatch = IsEqualGUID(guid, rguid);
        }
        pasf->Release();
    }

    return fMatch;
}

STDMETHODIMP_(int) s_DarwinAdsDestroyCallback(LPVOID pData1, LPVOID pData2)
{
    CDarwinAd* pda = (CDarwinAd*)pData1;
    if (pda)
        delete pda;
    return TRUE;
}


// SHRegisterDarwinLink takes ownership of the pidl
BOOL SHRegisterDarwinLink(LPITEMIDLIST pidlFull, LPWSTR pszDarwinID, BOOL fUpdate)
{
    BOOL fRetVal = FALSE;

    ENTERCRITICAL_DARWINADS;

    if (pidlFull)
    {
        CDarwinAd *pda = NULL;

        if (GetDarwinIndex(pidlFull, &pda) != -1 && pda)
        {
            // We already know about this link; don't need to add it
            fRetVal = TRUE;
        }
        else
        {
            pda = new CDarwinAd(pidlFull, pszDarwinID);
            if (pda)
            {
                pidlFull = NULL;    // take ownership

                // Do we have a global cache?
                if (g_hdpaDarwinAds == NULL)
                {
                    // No; This is either the first time this is called, or we
                    // failed the last time.
                    g_hdpaDarwinAds = DPA_Create(5);
                }

                if (g_hdpaDarwinAds)
                {
                    // DPA_AppendPtr returns the zero based index it inserted it at.
                    if(DPA_AppendPtr(g_hdpaDarwinAds, (void*)pda) >= 0)
                    {
                        fRetVal = TRUE;
                    }

                }
            }
        }

        if (!fRetVal)
        {
            // if we failed to create a dpa, delete this.
            delete pda;
        }
        else if (fUpdate)
        {
            // update the entry if requested
            pda->CheckInstalled();
        }
        ILFree(pidlFull);

    }
    else if (!pszDarwinID)
    {
        // NULL, NULL means "destroy darwin info, we're shutting down"
        HDPA hdpa = g_hdpaDarwinAds;
        g_hdpaDarwinAds = NULL;
        if (hdpa)
            DPA_DestroyCallback(hdpa, s_DarwinAdsDestroyCallback, NULL);
    }

    LEAVECRITICAL_DARWINADS;

    return fRetVal;
}

BOOL ProcessDarwinAd(IShellLinkDataList* psldl, LPCITEMIDLIST pidlFull)
{
    // This function does not check for the existance of a member before adding it,
    // so it is entirely possible for there to be duplicates in the list....
    BOOL fIsLoaded = FALSE;
    BOOL fFreesldl = FALSE;
    BOOL fRetVal = FALSE;

    if (!psldl)
    {
        // We will detect failure of this at use time.
        if (FAILED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC, IID_PPV_ARG(IShellLinkDataList, &psldl))))
        {
            return FALSE;
        }

        fFreesldl = TRUE;

        IPersistFile* ppf;
        OLECHAR sz[MAX_PATH];
        if (SHGetPathFromIDListW(pidlFull, sz))
        {
            if (SUCCEEDED(psldl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
            {
                if (SUCCEEDED(ppf->Load(sz, 0)))
                {
                    fIsLoaded = TRUE;
                }
                ppf->Release();
            }
        }
    }
    else
        fIsLoaded = TRUE;

    CDarwinAd* pda = NULL;
    if (fIsLoaded)
    {
        EXP_DARWIN_LINK* pexpDarwin;

        if (SUCCEEDED(psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin)))
        {
            fRetVal = SHRegisterDarwinLink(ILClone(pidlFull), pexpDarwin->szwDarwinID, TRUE);
            LocalFree(pexpDarwin);
        }
    }

    if (fFreesldl)
        psldl->Release();

    return fRetVal;
}

// This routine creates the IShellFolder and pidl for one of the many
// merged folders on the Start Menu / Start Panel.

typedef struct {
    UINT    csidl;
    UINT    uANSFlags;          // Flags for AddNameSpace
    LPCGUID pguidObj;           // optional object tag
} MERGEDFOLDERINFO, *LPMERGEDFOLDERINFO;
typedef const MERGEDFOLDERINFO *LPCMERGEDFOLDERINFO;

HRESULT GetMergedFolder(IShellFolder **ppsf, LPITEMIDLIST *ppidl,
                        LPCMERGEDFOLDERINFO rgmfi, UINT cmfi)
{
    *ppidl = NULL;
    *ppsf = NULL;

    IShellFolder2 *psf;
    IAugmentedShellFolder2 *pasf;
    HRESULT hr = CoCreateInstance(CLSID_MergedFolder, NULL, CLSCTX_INPROC, IID_PPV_ARG(IAugmentedShellFolder2, &pasf));

    for (UINT imfi = 0; SUCCEEDED(hr) && imfi < cmfi; imfi++)
    {
        // If this is a common group and common groups are restricted, then
        // skip this item
        if ((rgmfi[imfi].uANSFlags & ASFF_COMMON) &&
            SHRestricted(REST_NOCOMMONGROUPS))
        {
            continue;
        }

        psf = NULL;    // in/out param below
        hr = SHCacheTrackingFolder(MAKEINTIDLIST(rgmfi[imfi].csidl), rgmfi[imfi].csidl, &psf);

        if (SUCCEEDED(hr))
        {
            // If this is a Start Menu folder, then apply the
            // "do not enumerate subfolders" restriction if the policy says so.
            // In which case, we cannot use the tracking folder cache.
            // (Perf note: We compare pointers directly.)
            if (rgmfi[imfi].pguidObj == &CLSID_StartMenu)
            {
                if (SHRestricted(REST_NOSTARTMENUSUBFOLDERS))
                {
                    ISetFolderEnumRestriction *prest;
                    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(ISetFolderEnumRestriction, &prest))))
                    {
                        prest->SetEnumRestriction(0, SHCONTF_FOLDERS); // disallow subfolders
                        prest->Release();
                    }
                }
            }
            else
            {
                // If this assert fires, then our perf optimization above failed.
                ASSERT(rgmfi[imfi].pguidObj == NULL ||
                       !IsEqualGUID(*rgmfi[imfi].pguidObj, CLSID_StartMenu));
            }


            hr = pasf->AddNameSpace(rgmfi[imfi].pguidObj, psf, NULL, rgmfi[imfi].uANSFlags);
            if (SUCCEEDED(hr))
            {
                if (rgmfi[imfi].uANSFlags & ASFF_DEFNAMESPACE_DISPLAYNAME)
                {
                    // If this assert fires, it means somebody marked two
                    // folders as ASFF_DEFNAMESPACE_DISPLAYNAME, which is
                    // illegal (you can have only one default)
                    ASSERT(*ppidl == NULL);
                    hr = SHGetIDListFromUnk(psf, ppidl);    // copy out the pidl for this guy
                }
            }

            psf->Release();
        }
    }

    if (SUCCEEDED(hr))
        *ppsf = pasf;   // copy out the ref
    else
        ATOMICRELEASE(pasf);

    return hr;
}

HRESULT CreateMergedFolderHelper(LPCMERGEDFOLDERINFO rgmfi, UINT cmfi, REFIID riid, void **ppv)
{
    IShellFolder *psf;
    LPITEMIDLIST pidl;
    HRESULT hr = GetMergedFolder(&psf, &pidl, rgmfi, cmfi);
    if (SUCCEEDED(hr))
    {
        hr = psf->QueryInterface(riid, ppv);

        if (SUCCEEDED(hr))
        {
            IPersistPropertyBag *pppb;
            if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IPersistPropertyBag, &pppb))))
            {
                IPropertyBag *ppb;
                if (SUCCEEDED(SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb))))
                {
                    // these merged folders have to be told to use new changenotification
                    SHPropertyBag_WriteBOOL(ppb, L"MergedFolder\\ShellView", TRUE);
                    pppb->Load(ppb, NULL);
                    ppb->Release();
                }
                pppb->Release();
            }
        }

        psf->Release();
        ILFree(pidl);
    }
    return hr;
}

const MERGEDFOLDERINFO c_rgmfiStartMenu[] = {
    {   CSIDL_STARTMENU | CSIDL_FLAG_CREATE,    ASFF_DEFNAMESPACE_ALL,  &CLSID_StartMenu },
    {   CSIDL_COMMON_STARTMENU,                 ASFF_COMMON,            &CLSID_StartMenu },
};

const MERGEDFOLDERINFO c_rgmfiProgramsFolder[] = {
    {   CSIDL_PROGRAMS | CSIDL_FLAG_CREATE,     ASFF_DEFNAMESPACE_ALL,  NULL },
    {   CSIDL_COMMON_PROGRAMS,                  ASFF_COMMON,            NULL },
};

#ifdef FEATURE_STARTPAGE
#include <initguid.h>
DEFINE_GUID(CLSID_RecentDocs,           0xc97b1d8c, 0x66a6, 0x4abd, 0xbe,0x58,0x0b,0xbf,0x6b,0xa9,0x90,0x18);//C97B1D8C-66A6-4ABD-BE58-0BBF6BA99018
DEFINE_GUID(CLSID_MergedDesktop,              0xdceecc7e, 0x4840, 0x4f19, 0xb4,0xf8,0x42,0x6c,0x4c,0x43,0x14,0x01);//DCEECC7E-4840-4f19-B4F8-426C4C431401

const MERGEDFOLDERINFO c_rgmfiMoreDocumentsFolder[] = {
    {   CSIDL_PERSONAL | CSIDL_FLAG_CREATE,     ASFF_DEFNAMESPACE_ALL,  &CLSID_MyDocuments },
    {   CSIDL_DESKTOP,                          ASFF_DEFAULT,           &CLSID_MergedDesktop },
    {   CSIDL_RECENT,                           ASFF_DEFAULT,           &CLSID_RecentDocs },
};
#endif

//
//  On the Start Panel, we want the fast items to sort above the Programs,
//  so we mark the Programs folders as ASFF_SORTDOWN so they go to the bottom.
//  We also list the Fast Items first so SMSET_SEPARATEMERGEFOLDER picks
//  them off properly.  And we only want to let Start Menu merge with
//  Common Start Menu (and Programs with Common Programs) so pass
//  ASFF_MERGESAMEGUID.

const MERGEDFOLDERINFO c_rgmfiProgramsFolderAndFastItems[] = {
    {   CSIDL_STARTMENU | CSIDL_FLAG_CREATE,    ASFF_DEFAULT          | ASFF_MERGESAMEGUID,                 &CLSID_StartMenu},
    {   CSIDL_COMMON_STARTMENU,                 ASFF_COMMON           | ASFF_MERGESAMEGUID,                 &CLSID_StartMenu},
    {   CSIDL_PROGRAMS | CSIDL_FLAG_CREATE,     ASFF_DEFNAMESPACE_ALL | ASFF_MERGESAMEGUID | ASFF_SORTDOWN, NULL },
    {   CSIDL_COMMON_PROGRAMS,                  ASFF_COMMON           | ASFF_MERGESAMEGUID | ASFF_SORTDOWN, NULL },
};

STDAPI CStartMenuFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CreateMergedFolderHelper(c_rgmfiStartMenu, ARRAYSIZE(c_rgmfiStartMenu), riid, ppv);
}

STDAPI CProgramsFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CreateMergedFolderHelper(c_rgmfiProgramsFolder, ARRAYSIZE(c_rgmfiProgramsFolder), riid, ppv);
}

#ifdef FEATURE_STARTPAGE
STDAPI CMoreDocumentsFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    UINT uSize = ARRAYSIZE(c_rgmfiMoreDocumentsFolder);

    // Only show recent docs if the reg key says so.
    if (!SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("RecentDocs"), 
        FALSE, FALSE))
    {
        uSize--;
    }

    return CreateMergedFolderHelper(c_rgmfiMoreDocumentsFolder, uSize, riid, ppv);
}
#endif

HRESULT GetFilesystemInfo(IShellFolder* psf, LPITEMIDLIST* ppidlRoot, int* pcsidl)
{
    ASSERT(psf);
    IPersistFolder3* ppf;
    HRESULT hr = E_FAIL;

    *pcsidl = 0;
    *ppidlRoot = 0;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf))))
    {
        PERSIST_FOLDER_TARGET_INFO pfti = {0};

        if (SUCCEEDED(ppf->GetFolderTargetInfo(&pfti)))
        {
            *pcsidl = pfti.csidl;
            if (-1 != pfti.csidl)
                hr = S_OK;

            ILFree(pfti.pidlTargetFolder);
        }

        if (SUCCEEDED(hr))
            hr = ppf->GetCurFolder(ppidlRoot);
            
        ppf->Release();
    }
    return hr;
}

HRESULT ExecStaticStartMenuItem(int idCmd, BOOL fAllUsers, BOOL fOpen)
{
    int csidl = -1;
    HRESULT hr = E_OUTOFMEMORY;
    SHELLEXECUTEINFO shei = {0};
    switch (idCmd)
    {
    case IDM_PROGRAMS:          csidl = fAllUsers ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS; break;
    case IDM_FAVORITES:         csidl = CSIDL_FAVORITES; break;
    case IDM_MYDOCUMENTS:       csidl = CSIDL_PERSONAL; break;
    case IDM_MYPICTURES:        csidl = CSIDL_MYPICTURES; break;
    case IDM_CONTROLS:          csidl = CSIDL_CONTROLS;  break;
    case IDM_PRINTERS:          csidl = CSIDL_PRINTERS;  break;
    case IDM_NETCONNECT:        csidl = CSIDL_CONNECTIONS; break;
    default:
        return E_FAIL;
    }

    if (csidl != -1)
    {
        SHGetFolderLocation(NULL, csidl, NULL, 0, (LPITEMIDLIST*)&shei.lpIDList);
    }

    if (shei.lpIDList)
    {
        shei.cbSize     = sizeof(shei);
        shei.fMask      = SEE_MASK_IDLIST;
        shei.nShow      = SW_SHOWNORMAL;
        shei.lpVerb     = fOpen ? TEXT("open") : TEXT("explore");
        hr = ShellExecuteEx(&shei) ? S_OK: E_FAIL;
        ILFree((LPITEMIDLIST)shei.lpIDList);
    }

    return hr;
}

//
//  Base class for Classic and Personal start menus.
//

class CStartMenuCallbackBase : public IShellMenuCallback,
                               public CObjectWithSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // derived class is expected to implement IShellMenuCallback

    // IObjectWithSite inherited from CObjectWithSite

protected:
    CStartMenuCallbackBase(BOOL fIsStartPanel = FALSE);
    ~CStartMenuCallbackBase();

    void _InitializePrograms();
    HRESULT _FilterPidl(UINT uParent, IShellFolder* psf, LPCITEMIDLIST pidl);
    HRESULT _Promote(LPSMDATA psmd, DWORD dwFlags);
    BOOL _IsTopLevelStartMenu(UINT uParent, IShellFolder *psf, LPCITEMIDLIST pidl);
    HRESULT _HandleNew(LPSMDATA psmd);
    HRESULT _GetSFInfo(SMDATA* psmd, SMINFO* psminfo);
    HRESULT _ProcessChangeNotify(SMDATA* psmd, LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    HRESULT InitializeProgramsShellMenu(IShellMenu* psm);

    virtual DWORD _GetDemote(SMDATA* psmd) { return 0; }
    BOOL _IsDarwinAdvertisement(LPCITEMIDLIST pidlFull);

    void _RefreshSettings();

protected:
    int _cRef;

    DEBUG_CODE( DWORD _dwThreadID; )   // Cache the thread of the object

    LPTSTR          _pszPrograms;
    LPTSTR          _pszWindowsUpdate;
    LPTSTR          _pszConfigurePrograms;
    LPTSTR          _pszAdminTools;

    ITrayPriv2*     _ptp2;

    BOOL            _fExpandoMenus;
    BOOL            _fShowAdminTools;
    BOOL            _fIsStartPanel;
    BOOL            _fInitPrograms;
};

// IShellMenuCallback implementation
class CStartMenuCallback : public CStartMenuCallbackBase
{
public:
    // *** IUnknown methods *** inherited from CStartMenuBase

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** IObjectWithSite methods *** (overriding CObjectWithSite)
    STDMETHODIMP SetSite(IUnknown* punk);
    STDMETHODIMP GetSite(REFIID riid, void** ppvOut);

    CStartMenuCallback();
private:
    virtual ~CStartMenuCallback();

    IContextMenu*   _pcmFind;
    ITrayPriv*      _ptp;
    IUnknown*       _punkSite;
    IOleCommandTarget* _poct;
    BITBOOL         _fAddOpenFolder: 1;
    BITBOOL         _fCascadeMyDocuments: 1;
    BITBOOL         _fCascadePrinters: 1;
    BITBOOL         _fCascadeControlPanel: 1;
    BITBOOL         _fFindMenuInvalid: 1;
    BITBOOL         _fCascadeNetConnections: 1;
    BITBOOL         _fShowInfoTip: 1;
    BITBOOL         _fInitedShowTopLevelStartMenu: 1;
    BITBOOL         _fCascadeMyPictures: 1;

    BITBOOL         _fHasMyDocuments: 1;
    BITBOOL         _fHasMyPictures: 1;

    TCHAR           _szFindMnemonic[2];

    HWND            _hwnd;

    IMruDataList *  _pmruRecent;
    DWORD           _cRecentDocs;

    DWORD           _dwFlags;
    DWORD           _dwChevronCount;
    
    HRESULT _ExecHmenuItem(LPSMDATA psmdata);
    HRESULT _Init(SMDATA* psmdata);
    HRESULT _Create(SMDATA* psmdata, void** pvUserData);
    HRESULT _Destroy(SMDATA* psmdata);
    HRESULT _GetHmenuInfo(SMDATA* psmd, SMINFO*sminfo);
    HRESULT _GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    HRESULT _CheckRestricted(DWORD dwRestrict, BOOL* fRestricted);
    HRESULT _FilterRecentPidl(IShellFolder* psf, LPCITEMIDLIST pidl);
    HRESULT _Demote(LPSMDATA psmd);
    HRESULT _GetTip(LPWSTR pstrTitle, LPWSTR pstrTip);
    DWORD _GetDemote(SMDATA* psmd);
    HRESULT _HandleAccelerator(TCHAR ch, SMDATA* psmdata);
    HRESULT _GetDefaultIcon(LPWSTR psz, int* piIndex);
    void _GetStaticStartMenu(HMENU* phmenu, HWND* phwnd);
    HRESULT _GetStaticInfoTip(SMDATA* psmd, LPWSTR pszTip, int cch);

    // helper functions
    DWORD GetInitFlags();
    void  SetInitFlags(DWORD dwFlags);
    HRESULT _InitializeFindMenu(IShellMenu* psm);
    HRESULT _ExecItem(LPSMDATA, UINT);
    HRESULT VerifyCSIDL(int idCmd, int csidl, IShellMenu* psm);
    HRESULT VerifyMergedGuy(BOOL fPrograms, IShellMenu* psm);
    void _UpdateDocsMenuItemNames(IShellMenu* psm);
    void _UpdateDocumentsShellMenu(IShellMenu* psm);

public: // Make these public to this file. This is for the CreateInstance
    // Sub Menu creation
    HRESULT InitializeFastItemsShellMenu(IShellMenu* psm);
    HRESULT InitializeCSIDLShellMenu(int uId, int csidl, LPTSTR pszRoot, LPTSTR pszValue,
                                 DWORD dwPassInitFlags, DWORD dwSetFlags, BOOL fAddOpen, 
                                 IShellMenu* psm);
    HRESULT InitializeDocumentsShellMenu(IShellMenu* psm);
    HRESULT InitializeSubShellMenu(int idCmd, IShellMenu* psm);
};


class CStartContextMenu : IContextMenu
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);

    CStartContextMenu(int idCmd) : _idCmd(idCmd), _cRef(1) {};
private:
    int _cRef;
    virtual ~CStartContextMenu() {};

    int _idCmd;
};

void CStartMenuCallbackBase::_RefreshSettings()
{
    _fShowAdminTools = FeatureEnabled(TEXT("StartMenuAdminTools"));
}

CStartMenuCallbackBase::CStartMenuCallbackBase(BOOL fIsStartPanel)
    : _cRef(1), _fIsStartPanel(fIsStartPanel)
{
    DEBUG_CODE( _dwThreadID = GetCurrentThreadId() );

    TCHAR szBuf[MAX_PATH];
    DWORD cbSize = sizeof(szBuf); // SHGetValue wants sizeof

    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_EXPLORER_WINUPDATE, TEXT("ShortcutName"),
        NULL, szBuf, &cbSize))
    {
        // Add ".lnk" if the file doesn't have an extension
        PathAddExtension(szBuf, TEXT(".lnk"));
        Str_SetPtr(&_pszWindowsUpdate, szBuf);
    }

    cbSize = sizeof(szBuf); // SHGetValue wants sizeof
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, TEXT("SM_ConfigureProgramsName"),
        NULL, szBuf, &cbSize))
    {
        PathAddExtension(szBuf, TEXT(".lnk"));
        Str_SetPtr(&_pszConfigurePrograms, szBuf);
    }

    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_COMMON_ADMINTOOLS | CSIDL_FLAG_CREATE, NULL, 0, szBuf)))
    {
        Str_SetPtr(&_pszAdminTools, PathFindFileName(szBuf));
    }

    _RefreshSettings();

    SHReValidateDarwinCache();
}

CStartMenuCallback::CStartMenuCallback() : _cRecentDocs(-1)
{
    LoadString(g_hinst, IDS_FIND_MNEMONIC, _szFindMnemonic, ARRAYSIZE(_szFindMnemonic));
}

CStartMenuCallbackBase::~CStartMenuCallbackBase()
{
    ASSERT( _dwThreadID == GetCurrentThreadId() );

    Str_SetPtr(&_pszWindowsUpdate, NULL);
    Str_SetPtr(&_pszConfigurePrograms, NULL);
    Str_SetPtr(&_pszAdminTools, NULL);
    Str_SetPtr(&_pszPrograms, NULL);

    ATOMICRELEASE(_ptp2);
}

CStartMenuCallback::~CStartMenuCallback()
{
    ATOMICRELEASE(_pcmFind);
    ATOMICRELEASE(_ptp);
    ATOMICRELEASE(_pmruRecent);
}

// *** IUnknown methods ***
STDMETHODIMP CStartMenuCallbackBase::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CStartMenuCallbackBase, IShellMenuCallback),
        QITABENT(CStartMenuCallbackBase, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


STDMETHODIMP_(ULONG) CStartMenuCallbackBase::AddRef()
{
    return ++_cRef;
}


STDMETHODIMP_(ULONG) CStartMenuCallbackBase::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CStartMenuCallback::SetSite(IUnknown* punk)
{
    ATOMICRELEASE(_punkSite);
    _punkSite = punk;
    if (punk)
    {
        _punkSite->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CStartMenuCallback::GetSite(REFIID riid, void**ppvOut)
{
    if (_ptp)
        return _ptp->QueryInterface(riid, ppvOut);
    else
        return E_NOINTERFACE;
}

#ifdef DEBUG
void DBUEMQueryEvent(const IID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam)
{
#if 1
    return;
#else
    UEMINFO uei;

    uei.cbSize = sizeof(uei);
    uei.dwMask = ~0;    // UEIM_HIT etc.
    UEMQueryEvent(pguidGrp, eCmd, wParam, lParam, &uei);

    TCHAR szBuf[20];
    wsprintf(szBuf, TEXT("hit=%d"), uei.cHit);
    MessageBox(NULL, szBuf, TEXT("UEM"), MB_OKCANCEL);

    return;
#endif
}
#endif

DWORD CStartMenuCallback::GetInitFlags()
{
    DWORD dwType;
    DWORD cbSize = sizeof(DWORD);
    DWORD dwFlags = 0;
    SHGetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, TEXT("StartMenuInit"), 
            &dwType, (BYTE*)&dwFlags, &cbSize);
    return dwFlags;
}

void CStartMenuCallback::SetInitFlags(DWORD dwFlags)
{
    SHSetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, TEXT("StartMenuInit"), REG_DWORD, &dwFlags, sizeof(DWORD));
}

DWORD GetClickCount()
{

    //This function retrieves the number of times the user has clicked on the chevron item.

    DWORD dwType;
    DWORD cbSize = sizeof(DWORD);
    DWORD dwCount = 1;      // Default to three clicks before we give up.
                            // PMs what it to 1 now. Leaving back end in case they change their mind.
    SHGetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, TEXT("StartMenuChevron"), 
            &dwType, (BYTE*)&dwCount, &cbSize);

    return dwCount;

}

void SetClickCount(DWORD dwClickCount)
{
    SHSetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, TEXT("StartMenuChevron"), REG_DWORD, &dwClickCount, sizeof(DWORD));
}

BOOL CStartMenuCallbackBase::_IsTopLevelStartMenu(UINT uParent, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return uParent == IDM_TOPLEVELSTARTMENU ||
           (uParent == IDM_PROGRAMS && _fIsStartPanel && IsMergedFolderGUID(psf, pidl, CLSID_StartMenu));
};


STDMETHODIMP CStartMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;
    switch (uMsg)
    {

    case SMC_CREATE:
        hr = _Create(psmd, (void**)lParam);
        break;

    case SMC_DESTROY:
        hr = _Destroy(psmd);
        break;

    case SMC_INITMENU:
        hr = _Init(psmd);
        break;

    case SMC_SFEXEC:
        hr = _ExecItem(psmd, uMsg);
        break;

    case SMC_EXEC:
        hr = _ExecHmenuItem(psmd);
        break;

    case SMC_GETOBJECT:
        hr = _GetObject(psmd, (GUID)*((GUID*)wParam), (void**)lParam);
        break;

    case SMC_GETINFO:
        hr = _GetHmenuInfo(psmd, (SMINFO*)lParam);
        break;

    case SMC_GETSFINFOTIP:
        if (!_fShowInfoTip)
            hr = E_FAIL;  // E_FAIL means don't show. S_FALSE means show default
        break;

    case SMC_GETINFOTIP:
        hr = _GetStaticInfoTip(psmd, (LPWSTR)wParam, (int)lParam);
        break;

    case SMC_GETSFINFO:
        hr = _GetSFInfo(psmd, (SMINFO*)lParam);
        break;

    case SMC_BEGINENUM:
        if (psmd->uIdParent == IDM_RECENT)
        {
            ASSERT(_cRecentDocs == -1);
            ASSERT(!_pmruRecent);
            CreateRecentMRUList(&_pmruRecent);

            _cRecentDocs = 0;
            hr = S_OK;
        }
        break;

    case SMC_ENDENUM:
        if (psmd->uIdParent == IDM_RECENT)
        {
            ASSERT(_cRecentDocs != -1);
            ATOMICRELEASE(_pmruRecent);

            _cRecentDocs = -1;
            hr = S_OK;
        }
        break;
    
    case SMC_DUMPONUPDATE:
        if (psmd->uIdParent == IDM_RECENT)
        {
            hr = S_OK;
        }
        break;
    
    case SMC_FILTERPIDL:
        ASSERT(psmd->dwMask & SMDM_SHELLFOLDER);

        if (psmd->uIdParent == IDM_RECENT)
        {
            //  we need to filter out all but the first MAXRECENTITEMS
            //  and no folders allowed!
            hr = _FilterRecentPidl(psmd->psf, psmd->pidlItem);
        }
        else
        {
            hr = _FilterPidl(psmd->uIdParent, psmd->psf, psmd->pidlItem);
        }
        break;

    case SMC_INSERTINDEX:
        ASSERT(lParam && IS_VALID_WRITE_PTR(lParam, int));
        *((int*)lParam) = 0;
        hr = S_OK;
        break;

    case SMC_SHCHANGENOTIFY:
        {
            PSMCSHCHANGENOTIFYSTRUCT pshf = (PSMCSHCHANGENOTIFYSTRUCT)lParam;
            hr = _ProcessChangeNotify(psmd, pshf->lEvent, pshf->pidl1, pshf->pidl2);
        }
        break;

    case SMC_REFRESH:
        if (psmd->uIdParent == IDM_TOPLEVELSTARTMENU)
        {
            hr = S_OK;

            // Refresh is only called on the top level.
            HMENU hmenu;
            IShellMenu* psm;
            _GetStaticStartMenu(&hmenu, &_hwnd);
            if (hmenu && psmd->punk && SUCCEEDED(psmd->punk->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
            {
                hr = psm->SetMenu(hmenu, _hwnd, SMSET_BOTTOM | SMSET_MERGE);
                psm->Release();
            }

            _RefreshSettings();
            _fExpandoMenus = !_fIsStartPanel && AreIntelliMenusEnabled();
            _fCascadeMyDocuments = FeatureEnabled(TEXT("CascadeMyDocuments"));
            _fCascadePrinters = FeatureEnabled(TEXT("CascadePrinters"));
            _fCascadeControlPanel = FeatureEnabled(TEXT("CascadeControlPanel"));
            _fCascadeNetConnections = FeatureEnabled(TEXT("CascadeNetworkConnections"));
            _fAddOpenFolder = FeatureEnabled(TEXT("StartMenuOpen"));
            _fShowInfoTip = FeatureEnabled(TEXT("ShowInfoTip"));
            _fCascadeMyPictures = FeatureEnabled(TEXT("CascadeMyPictures"));
            _fFindMenuInvalid = TRUE;
            _dwFlags = GetInitFlags();
        }
        break;

    case SMC_DEMOTE:
        hr = _Demote(psmd);
        break;

    case SMC_PROMOTE:
        hr = _Promote(psmd, (DWORD)wParam);
        break;

    case SMC_NEWITEM:
        hr = _HandleNew(psmd);
        break;

    case SMC_MAPACCELERATOR:
        hr = _HandleAccelerator((TCHAR)wParam, (SMDATA*)lParam);
        break;

    case SMC_DEFAULTICON:
        ASSERT(psmd->uIdAncestor == IDM_FAVORITES); // This is only valid for the Favorites menu
        hr = _GetDefaultIcon((LPWSTR)wParam, (int*)lParam);
        break;

    case SMC_GETMINPROMOTED:
        // Only do this for the programs menu
        if (psmd->uIdParent == IDM_PROGRAMS)
            *((int*)lParam) = 4;        // 4 was choosen by RichSt 9.15.98
        break;

    case SMC_CHEVRONEXPAND:

        // Has the user already seen the chevron tip enough times? (We set the bit when the count goes to zero.
        if (!(_dwFlags & STARTMENU_CHEVRONCLICKED))
        {
            // No; Then get the current count from the registry. We set a default of 3, but an admin can set this
            // to -1, that would make it so that they user sees it all the time.
            DWORD dwClickCount = GetClickCount();
            if (dwClickCount > 0)
            {
                // Since they clicked, take one off.
                dwClickCount--;

                // Set it back in.
                SetClickCount(dwClickCount);
            }

            if (dwClickCount == 0)
            {
                // Ah, the user has seen the chevron tip enought times... Stop being annoying.
                _dwFlags |= STARTMENU_CHEVRONCLICKED;
                SetInitFlags(_dwFlags);
            }
        }
        hr = S_OK;
        break;

    case SMC_DISPLAYCHEVRONTIP:

        // We only want to see the tip on the top level programs case, no where else. We also don't
        // want to see it if they've had enough.
        if (psmd->uIdParent == IDM_PROGRAMS && 
            !(_dwFlags & STARTMENU_CHEVRONCLICKED) &&
            !SHRestricted(REST_NOSMBALLOONTIP))
        {
            hr = S_OK;
        }
        break;

    case SMC_CHEVRONGETTIP:
        if (!SHRestricted(REST_NOSMBALLOONTIP))
            hr = _GetTip((LPWSTR)wParam, (LPWSTR)lParam);
        break;
    }

    return hr;
}

// For the Favorites menu, since their icon handler is SO slow, we're going to fake the icon
// and have it get the real ones on the background thread...
HRESULT CStartMenuCallback::_GetDefaultIcon(LPWSTR psz, int* piIndex)
{
    DWORD cbSize = MAX_PATH;
    HRESULT hr = AssocQueryString(0, ASSOCSTR_DEFAULTICON, TEXT("InternetShortcut"), NULL, psz, &cbSize);
    if (SUCCEEDED(hr))
    {
        *piIndex = PathParseIconLocation(psz);
    }
    
    return hr;
}

HRESULT CStartMenuCallback::_ExecItem(LPSMDATA psmd, UINT uMsg)
{
    ASSERT( _dwThreadID == GetCurrentThreadId() );
    return _ptp->ExecItem(psmd->psf, psmd->pidlItem);
}

HRESULT CStartMenuCallback::_Demote(LPSMDATA psmd)
{
    //We want to for the UEM to demote pidlFolder, 
    // then tell the Parent menuband (If there is one)
    // to invalidate this pidl.
    HRESULT hr = S_FALSE;

    if (_fExpandoMenus && 
        (psmd->uIdAncestor == IDM_PROGRAMS ||
         psmd->uIdAncestor == IDM_FAVORITES))
    {
        UEMINFO uei;
        uei.cbSize = sizeof(uei);
        uei.dwMask = UEIM_HIT;
        uei.cHit = 0;
        hr = UEMSetEvent(psmd->uIdAncestor == IDM_PROGRAMS? &UEMIID_SHELL : &UEMIID_BROWSER, 
            UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei);
    }
    return hr;
}

// Even if intellimenus are off, fire a UEM event if it was an Exec from
// the More Programs menu of the Start Panel [SMINV_FORCE will be set]
// so we can detect which are the user's most popular apps.

HRESULT CStartMenuCallbackBase::_Promote(LPSMDATA psmd, DWORD dwFlags)
{
    if ((_fExpandoMenus || (_fIsStartPanel && (dwFlags & SMINV_FORCE))) &&
        (psmd->uIdAncestor == IDM_PROGRAMS ||
         psmd->uIdAncestor == IDM_FAVORITES))
    {
        UEMFireEvent(psmd->uIdAncestor == IDM_PROGRAMS? &UEMIID_SHELL : &UEMIID_BROWSER, 
            UEME_RUNPIDL, UEMF_XEVENT, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem);
    }
    return S_OK;
}

HRESULT CStartMenuCallbackBase::_HandleNew(LPSMDATA psmd)
{
    HRESULT hr = S_FALSE;
    if (_fExpandoMenus && 
        (psmd->uIdAncestor == IDM_PROGRAMS ||
         psmd->uIdAncestor == IDM_FAVORITES))
    {
        UEMINFO uei;
        uei.cbSize = sizeof(uei);
        uei.dwMask = UEIM_HIT;
        uei.cHit = UEM_NEWITEMCOUNT;
        hr = UEMSetEvent(psmd->uIdAncestor == IDM_PROGRAMS? &UEMIID_SHELL : &UEMIID_BROWSER, 
            UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei);
    }

    if (psmd->uIdAncestor == IDM_PROGRAMS)
    {
        LPITEMIDLIST pidlFull = FullPidlFromSMData(psmd);
        if (pidlFull)
        {
            ProcessDarwinAd(NULL, pidlFull);
            ILFree(pidlFull);
        }
    }
    return hr;
}

HRESULT ShowFolder(UINT csidl)
{
    LPITEMIDLIST pidl;
    if (SUCCEEDED(SHGetFolderLocation(NULL, csidl, NULL, 0, &pidl)))
    {
        SHELLEXECUTEINFO shei = { 0 };

        shei.cbSize     = sizeof(shei);
        shei.fMask      = SEE_MASK_IDLIST;
        shei.nShow      = SW_SHOWNORMAL;
        shei.lpVerb     = TEXT("open");
        shei.lpIDList   = pidl;
        ShellExecuteEx(&shei);
        ILFree(pidl);
    }
    return S_OK;
}

void _ExecRegValue(LPCTSTR pszValue)
{
    TCHAR szPath[MAX_PATH];
    DWORD cbSize = ARRAYSIZE(szPath);

    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_EXPLORER_ADVANCED, pszValue, 
        NULL, szPath, &cbSize))
    {
        SHELLEXECUTEINFO shei= { 0 };
        shei.cbSize = sizeof(shei);
        shei.nShow  = SW_SHOWNORMAL;
        shei.lpParameters = PathGetArgs(szPath);
        PathRemoveArgs(szPath);
        shei.lpFile = szPath;
        ShellExecuteEx(&shei);
    }
}

HRESULT CStartMenuCallback::_ExecHmenuItem(LPSMDATA psmd)
{
    HRESULT hr = S_FALSE;
    if (IsInRange(psmd->uId, TRAY_IDM_FINDFIRST, TRAY_IDM_FINDLAST) && _pcmFind)
    {
        CMINVOKECOMMANDINFOEX ici = { 0 };
        ici.cbSize = sizeof(CMINVOKECOMMANDINFOEX);
        ici.lpVerb = (LPSTR)MAKEINTRESOURCE(psmd->uId - TRAY_IDM_FINDFIRST);
        ici.nShow = SW_NORMAL;
        
        // record if shift or control was being held down
        SetICIKeyModifiers(&ici.fMask);

        _pcmFind->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
        hr = S_OK;
    }
    else
    {
        switch (psmd->uId)
        {
        case IDM_OPEN_FOLDER:
            switch(psmd->uIdParent)
            {
            case IDM_CONTROLS:
                hr = ShowFolder(CSIDL_CONTROLS);
                break;

            case IDM_PRINTERS:
                hr = ShowFolder(CSIDL_PRINTERS);
                break;

            case IDM_NETCONNECT:
                hr = ShowFolder(CSIDL_CONNECTIONS);
                break;

            case IDM_MYPICTURES:
                hr = ShowFolder(CSIDL_MYPICTURES);
                break;

            case IDM_MYDOCUMENTS:
                hr = ShowFolder(CSIDL_PERSONAL);
                break;
            }
            break;

        case IDM_NETCONNECT:
            hr = ShowFolder(CSIDL_CONNECTIONS);
            break;

        case IDM_MYDOCUMENTS:
            hr = ShowFolder(CSIDL_PERSONAL);
            break;

        case IDM_MYPICTURES:
            hr = ShowFolder(CSIDL_MYPICTURES);
            break;

        case IDM_CSC:
            _ExecRegValue(TEXT("StartMenuSyncAll"));
            break;

        default:
            hr = ExecStaticStartMenuItem(psmd->uId, FALSE, TRUE);
            break;
        }
    }
    return hr;
}

void CStartMenuCallback::_GetStaticStartMenu(HMENU* phmenu, HWND* phwnd)
{
    *phmenu = NULL;
    *phwnd = NULL;

    IMenuPopup* pmp;
    // The first one should be the bar that the start menu is sitting in.
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmp))))
    {
        // Its site should be CStartMenuHost;
        if (SUCCEEDED(IUnknown_GetSite(pmp, IID_PPV_ARG(ITrayPriv, &_ptp))))
        {
            // Don't get upset if this fails
            _ptp->QueryInterface(IID_PPV_ARG(ITrayPriv2, &_ptp2));

            _ptp->GetStaticStartMenu(phmenu);
            IUnknown_GetWindow(_ptp, phwnd);

            if (!_poct)
                _ptp->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_poct));
        }
        else
            TraceMsg(TF_MENUBAND, "CStartMenuCallback::_SetSite : Failed to aquire CStartMenuHost");

        pmp->Release();
    }
}

HRESULT CStartMenuCallback::_Create(SMDATA* psmdata, void** ppvUserData)
{
    *ppvUserData = new SMUSERDATA;

    return S_OK;
}

HRESULT CStartMenuCallback::_Destroy(SMDATA* psmdata)
{
    if (psmdata->pvUserData)
    {
        delete (SMUSERDATA*)psmdata->pvUserData;
        psmdata->pvUserData = NULL;
    }

    return S_OK;
}

void CStartMenuCallbackBase::_InitializePrograms()
{
    if (!_fInitPrograms)
    {
        // We're either initing these, or reseting them.
        TCHAR szTemp[MAX_PATH];
        SHGetFolderPath(NULL, CSIDL_PROGRAMS, NULL, 0, szTemp);
        Str_SetPtr(&_pszPrograms, PathFindFileName(szTemp));

        _fInitPrograms = TRUE;
    }
}



// Given a CSIDL and a Shell menu, this will verify if the IShellMenu
// is pointing at the same place as the CSIDL is. If not, then it will
// update the shell menu to the new location.
HRESULT CStartMenuCallback::VerifyCSIDL(int idCmd, int csidl, IShellMenu* psm)
{
    DWORD dwFlags;
    LPITEMIDLIST pidl;
    IShellFolder* psf;
    HRESULT hr = S_OK;
    if (SUCCEEDED(psm->GetShellFolder(&dwFlags, &pidl, IID_PPV_ARG(IShellFolder, &psf))))
    {
        psf->Release();

        LPITEMIDLIST pidlCSIDL;
        if (SUCCEEDED(SHGetFolderLocation(NULL, csidl, NULL, 0, &pidlCSIDL)))
        {
            // If the pidl of the IShellMenu is not equal to the
            // SpecialFolder Location, then we need to update it so they are...
            if (!ILIsEqual(pidlCSIDL, pidl))
            {
                hr = InitializeSubShellMenu(idCmd, psm);
            }
            ILFree(pidlCSIDL);
        }
        ILFree(pidl);
    }

    return hr;
}

// This code special cases the Programs and Fast items shell menus. It
// understands Merging and will check both shell folders in a merged case
// to verify that the shell folder is still pointing at that location
HRESULT CStartMenuCallback::VerifyMergedGuy(BOOL fPrograms, IShellMenu* psm)
{
    DWORD dwFlags;
    LPITEMIDLIST pidl;
    HRESULT hr = S_OK;
    IAugmentedShellFolder2* pasf;
    if (SUCCEEDED(psm->GetShellFolder(&dwFlags, &pidl, IID_PPV_ARG(IAugmentedShellFolder2, &pasf))))
    {
        IShellFolder* psf;
        // There are 2 things in the merged namespace: CSIDL_PROGRAMS and CSIDL_COMMON_PROGRAMS
        for (int i = 0; i < 2; i++)
        {
            if (SUCCEEDED(pasf->QueryNameSpace(i, 0, &psf)))
            {
                int csidl;
                LPITEMIDLIST pidlFolder;

                if (SUCCEEDED(GetFilesystemInfo(psf, &pidlFolder, &csidl)))
                {
                    LPITEMIDLIST pidlCSIDL;
                    if (SUCCEEDED(SHGetFolderLocation(NULL, csidl, NULL, 0, &pidlCSIDL)))
                    {
                        // If the pidl of the IShellMenu is not equal to the
                        // SpecialFolder Location, then we need to update it so they are...
                        if (!ILIsEqual(pidlCSIDL, pidlFolder))
                        {

                            // Since one of these things has changed,
                            // we need to update the string cache
                            // so that we do proper filtering of 
                            // the programs item.
                            _fInitPrograms = FALSE;
                            if (fPrograms)
                                hr = InitializeProgramsShellMenu(psm);
                            else
                                hr = InitializeFastItemsShellMenu(psm);

                            i = 100;   // break out of the loop.
                        }
                        ILFree(pidlCSIDL);
                    }
                    ILFree(pidlFolder);
                }
                psf->Release();
            }
        }

        ILFree(pidl);
        pasf->Release();
    }

    return hr;
}

void _FixMenuItemName(IShellMenu *psm, UINT uID, LPTSTR pszNewMenuName)
{
    HMENU hMenu;
    ASSERT(NULL != psm);
    if (SUCCEEDED(psm->GetMenu(&hMenu, NULL, NULL)))
    {
        MENUITEMINFO mii = {0};
        TCHAR szMenuName[256];
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_TYPE;
        mii.dwTypeData = szMenuName;
        mii.cch = ARRAYSIZE(szMenuName);
        szMenuName[0] = TEXT('\0');
        if (::GetMenuItemInfo(hMenu, uID, FALSE, &mii))
        {
            if (0 != StrCmp(szMenuName, pszNewMenuName))
            {
                // The mydocs name has changed, update the menu item:
                mii.dwTypeData = pszNewMenuName;
                if (::SetMenuItemInfo(hMenu, uID, FALSE, &mii))
                {
                    SMDATA smd;
                    smd.dwMask = SMDM_HMENU;
                    smd.uId = uID;
                    psm->InvalidateItem(&smd, SMINV_ID | SMINV_REFRESH);
                }
            }
        }
    }
}

void CStartMenuCallback::_UpdateDocumentsShellMenu(IShellMenu* psm)
{
    // Add/Remove My Documents and My Pictures items of menu

    BOOL fMyDocs = !SHRestricted(REST_NOSMMYDOCS);
    if (fMyDocs)
    {
        LPITEMIDLIST pidl;
        fMyDocs = SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &pidl));
        if (fMyDocs)
            ILFree(pidl);
    }

    BOOL fMyPics = !SHRestricted(REST_NOSMMYPICS);
    if (fMyPics)
    {
        LPITEMIDLIST pidl;
        fMyPics = SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_MYPICTURES, NULL, 0, &pidl));
        if (fMyPics)
            ILFree(pidl);
    }

    // Do not update menu if not different than currently have
    if (fMyDocs != (BOOL)_fHasMyDocuments || fMyPics != (BOOL)_fHasMyPictures)
    {
        HMENU hMenu = SHLoadMenuPopup(HINST_THISDLL, MENU_STARTMENU_MYDOCS);
        if (hMenu)
        {
            if (!fMyDocs)
                DeleteMenu(hMenu, IDM_MYDOCUMENTS, MF_BYCOMMAND);
            if (!fMyPics)
                DeleteMenu(hMenu, IDM_MYPICTURES, MF_BYCOMMAND);
            // Reset section of menu
            psm->SetMenu(hMenu, _hwnd, SMSET_TOP);
        }

        // Cache what folders are available
        _fHasMyDocuments = fMyDocs;
        _fHasMyPictures = fMyPics;
    }
}

void CStartMenuCallback::_UpdateDocsMenuItemNames(IShellMenu* psm)
{
    TCHAR szBuffer[MAX_PATH];

    if (_fHasMyDocuments) 
    {
        if ( SUCCEEDED(GetMyDocumentsDisplayName(szBuffer, ARRAYSIZE(szBuffer))) )
            _FixMenuItemName(psm, IDM_MYDOCUMENTS, szBuffer);
    }

    if (_fHasMyPictures) 
    {
        if ( SUCCEEDED(GetMyPicsDisplayName(szBuffer, ARRAYSIZE(szBuffer))) )
            _FixMenuItemName(psm, IDM_MYPICTURES, szBuffer);
    }
}

HRESULT CStartMenuCallback::_Init(SMDATA* psmdata)
{
    HRESULT hr = S_FALSE;
    IShellMenu* psm;
    if (psmdata->punk && SUCCEEDED(hr = psmdata->punk->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
    {
        switch(psmdata->uIdParent)
        {
        case IDM_TOPLEVELSTARTMENU:
        {
            if (psmdata->pvUserData && !((SMUSERDATA*)psmdata->pvUserData)->_fInitialized)
            {
                TraceMsg(TF_MENUBAND, "CStartMenuCallback::_Init : Initializing Toplevel Start Menu");
                ((SMUSERDATA*)psmdata->pvUserData)->_fInitialized = TRUE;

                HMENU hmenu;

                TraceMsg(TF_MENUBAND, "CStartMenuCallback::_Init : First Time, and correct parameters");

                _GetStaticStartMenu(&hmenu, &_hwnd);
                if (hmenu)
                {
                    HMENU   hmenuOld = NULL;
                    HWND    hwnd;
                    DWORD   dwFlags;

                    psm->GetMenu(&hmenuOld, &hwnd, &dwFlags);
                    if (hmenuOld != NULL)
                    {
                        TBOOL(DestroyMenu(hmenuOld));
                    }
                    hr = psm->SetMenu(hmenu, _hwnd, SMSET_BOTTOM);
                    TraceMsg(TF_MENUBAND, "CStartMenuCallback::_Init : SetMenu(HMENU 0x%x, HWND 0x%x", hmenu, _hwnd);
                }

                _fExpandoMenus = !_fIsStartPanel && AreIntelliMenusEnabled();
                _fCascadeMyDocuments = FeatureEnabled(TEXT("CascadeMyDocuments"));
                _fCascadePrinters = FeatureEnabled(TEXT("CascadePrinters"));
                _fCascadeControlPanel = FeatureEnabled(TEXT("CascadeControlPanel"));
                _fCascadeNetConnections = FeatureEnabled(TEXT("CascadeNetworkConnections"));
                _fAddOpenFolder = FeatureEnabled(TEXT("StartMenuOpen"));
                _fShowInfoTip = FeatureEnabled(TEXT("ShowInfoTip"));
                _fCascadeMyPictures = FeatureEnabled(TEXT("CascadeMyPictures"));
                _dwFlags = GetInitFlags();
            }
            else if (!_fInitedShowTopLevelStartMenu)
            {
                _fInitedShowTopLevelStartMenu = TRUE;
                psm->InvalidateItem(NULL, SMINV_REFRESH);
            }

            // Verify that the Fast items is still pointing to the right location
            if (SUCCEEDED(hr))
            {
                hr = VerifyMergedGuy(FALSE, psm);
            }
            break;
        }
        case IDM_MENU_FIND:
            if (_fFindMenuInvalid)
            {
                hr = _InitializeFindMenu(psm);
                _fFindMenuInvalid = FALSE;
            }
            break;

        case IDM_PROGRAMS:
            // Verify the programs menu is still pointing to the right location
            hr = VerifyMergedGuy(TRUE, psm);
            break;

        case IDM_FAVORITES:
            hr = VerifyCSIDL(IDM_FAVORITES, CSIDL_FAVORITES, psm);
            break;

        case IDM_MYDOCUMENTS:
            hr = VerifyCSIDL(IDM_MYDOCUMENTS, CSIDL_PERSONAL, psm);
            break;

        case IDM_MYPICTURES:
            hr = VerifyCSIDL(IDM_MYPICTURES, CSIDL_MYPICTURES, psm);
            break;

        case IDM_RECENT:
            _UpdateDocumentsShellMenu(psm);
            _UpdateDocsMenuItemNames(psm);
            hr = VerifyCSIDL(IDM_RECENT, CSIDL_RECENT, psm);
            break;
        case IDM_CONTROLS:
            hr = VerifyCSIDL(IDM_CONTROLS, CSIDL_CONTROLS, psm);
            break;
        case IDM_PRINTERS:
            hr = VerifyCSIDL(IDM_PRINTERS, CSIDL_PRINTERS, psm);
            break;
        }

        psm->Release();
    }

    return hr;
}


HRESULT CStartMenuCallback::_GetStaticInfoTip(SMDATA* psmd, LPWSTR pszTip, int cch)
{
    if (!_fShowInfoTip)
        return E_FAIL;

    HRESULT hr = E_FAIL;

    const static struct 
    {
        UINT idCmd;
        UINT idInfoTip;
    } s_mpcmdTip[] = 
    {
#if 0   // No tips for the Toplevel. Keep this here because I bet that someone will want them...
       { IDM_PROGRAMS,       IDS_PROGRAMS_TIP },
       { IDM_FAVORITES,      IDS_FAVORITES_TIP },
       { IDM_RECENT,         IDS_RECENT_TIP },
       { IDM_SETTINGS,       IDS_SETTINGS_TIP },
       { IDM_MENU_FIND,      IDS_FIND_TIP },
       { IDM_HELPSEARCH,     IDS_HELP_TIP },        // Redundant?
       { IDM_FILERUN,        IDS_RUN_TIP },
       { IDM_LOGOFF,         IDS_LOGOFF_TIP },
       { IDM_EJECTPC,        IDS_EJECT_TIP },
       { IDM_EXITWIN,        IDS_SHUTDOWN_TIP },
#endif
       // Settings Submenu
       { IDM_CONTROLS,       IDS_CONTROL_TIP },
       { IDM_PRINTERS,       IDS_PRINTERS_TIP },
       { IDM_TRAYPROPERTIES, IDS_TRAYPROP_TIP },
       { IDM_NETCONNECT,     IDS_NETCONNECT_TIP },

       // Recent Folder
       { IDM_MYDOCUMENTS,    IDS_MYDOCS_TIP },
       { IDM_MYPICTURES,     IDS_MYPICS_TIP },
     };


    for (int i = 0; i < ARRAYSIZE(s_mpcmdTip); i++)
    {
        if (s_mpcmdTip[i].idCmd == psmd->uId)
        {
            TCHAR szTip[MAX_PATH];
            if (LoadString(g_hinst, s_mpcmdTip[i].idInfoTip, szTip, ARRAYSIZE(szTip)))
            {
                SHTCharToUnicode(szTip, pszTip, cch);
                hr = S_OK;
            }
            break;
        }
    }

    return hr;
}

typedef struct
{
    WCHAR wszMenuText[MAX_PATH];
    WCHAR wszHelpText[MAX_PATH];
    int   iIcon;
} SEARCHEXTDATA, *LPSEARCHEXTDATA;

HRESULT CStartMenuCallback::_GetHmenuInfo(SMDATA* psmd, SMINFO* psminfo)
{
    const static struct 
    {
        UINT idCmd;
        int  iImage;
    } s_mpcmdimg[] = { // Top level menu
                       { IDM_PROGRAMS,       -IDI_CLASSICSM_PROGS },
                       { IDM_FAVORITES,      -IDI_CLASSICSM_FAVORITES },
                       { IDM_RECENT,         -IDI_CLASSICSM_RECENTDOCS },
                       { IDM_SETTINGS,       -IDI_CLASSICSM_SETTINGS },
                       { IDM_MENU_FIND,      -IDI_CLASSICSM_FIND },
                       { IDM_HELPSEARCH,     -IDI_CLASSICSM_HELP },
                       { IDM_FILERUN,        -IDI_CLASSICSM_RUN },
                       { IDM_LOGOFF,         -IDI_CLASSICSM_LOGOFF },
                       { IDM_EJECTPC,        -IDI_CLASSICSM_UNDOCK },
                       { IDM_EXITWIN,        -IDI_CLASSICSM_SHUTDOWN },
                       { IDM_MU_SECURITY,    II_MU_STSECURITY },
                       { IDM_MU_DISCONNECT,  II_MU_STDISCONN  },
                       { IDM_SETTINGSASSIST, -IDI_CLASSICSM_SETTINGS },
                       { IDM_CONTROLS,       II_STCPANEL },
                       { IDM_PRINTERS,       II_STPRNTRS },
                       { IDM_TRAYPROPERTIES, II_STTASKBR },
                       { IDM_MYDOCUMENTS,    -IDI_MYDOCS},
                       { IDM_CSC,            -IDI_CSC},
                       { IDM_NETCONNECT,     -IDI_NETCONNECT},
                     };


    ASSERT(IS_VALID_WRITE_PTR(psminfo, SMINFO));

    int iIcon = -1;
    DWORD dwFlags = psminfo->dwFlags;
    MENUITEMINFO mii = {0};
    HRESULT hr = S_FALSE;

    if (psminfo->dwMask & SMIM_ICON)
    {
        if (IsInRange(psmd->uId, TRAY_IDM_FINDFIRST, TRAY_IDM_FINDLAST))
        {
            // The find menu extensions pack their icon into their data member of
            // Menuiteminfo....
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_DATA;
            if (GetMenuItemInfo(psmd->hmenu, psmd->uId, MF_BYCOMMAND, &mii))
            {
                LPSEARCHEXTDATA psed = (LPSEARCHEXTDATA)mii.dwItemData;

                if (psed)
                    psminfo->iIcon = psed->iIcon;
                else
                    psminfo->iIcon = -1;

                dwFlags |= SMIF_ICON;
                hr = S_OK;
            }
        }
        else
        {
            if (psmd->uId == IDM_MYPICTURES)
            {
                LPITEMIDLIST pidlMyPics = SHCloneSpecialIDList(NULL, CSIDL_MYPICTURES, FALSE);
                if (pidlMyPics)
                {
                    LPCITEMIDLIST pidlObject;
                    IShellFolder *psf;
                    hr = SHBindToParent(pidlMyPics, IID_PPV_ARG(IShellFolder, &psf), &pidlObject);
                    if (SUCCEEDED(hr))
                    {
                        SHMapPIDLToSystemImageListIndex(psf, pidlObject, &psminfo->iIcon);
                        dwFlags |= SMIF_ICON;
                        psf->Release();
                    }
                    ILFree(pidlMyPics);
                }
            }
            else
            {
                UINT uIdLocal = psmd->uId;
                if (uIdLocal == IDM_OPEN_FOLDER)
                    uIdLocal = psmd->uIdAncestor;

                for (int i = 0; i < ARRAYSIZE(s_mpcmdimg); i++)
                {
                    if (s_mpcmdimg[i].idCmd == uIdLocal)
                    {
                        iIcon = s_mpcmdimg[i].iImage;
                        break;
                    }
                }

                if (iIcon != -1)
                {
                    dwFlags |= SMIF_ICON;
                    psminfo->iIcon = Shell_GetCachedImageIndex(TEXT("shell32.dll"), iIcon, 0);
                    hr = S_OK;
                }
            }
        }
    }

    if (psminfo->dwMask & SMIM_FLAGS)
    {
        psminfo->dwFlags = dwFlags;

        if ( (psmd->uId == IDM_CONTROLS    && _fCascadeControlPanel   ) ||
             (psmd->uId == IDM_PRINTERS    && _fCascadePrinters       ) ||
             (psmd->uId == IDM_MYDOCUMENTS && _fCascadeMyDocuments    ) ||
             (psmd->uId == IDM_NETCONNECT  && _fCascadeNetConnections ) ||
             (psmd->uId == IDM_MYPICTURES  && _fCascadeMyPictures     ) )
        {
            psminfo->dwFlags |= SMIF_SUBMENU;
            hr = S_OK;
        }
        else switch (psmd->uId)
        {
        case IDM_FAVORITES:
        case IDM_PROGRAMS:
            psminfo->dwFlags |= SMIF_DROPCASCADE;
            hr = S_OK;
            break;
        }
    }

    return hr;
}

DWORD CStartMenuCallback::_GetDemote(SMDATA* psmd)
{
    UEMINFO uei;
    DWORD dwFlags = 0;

    uei.cbSize = sizeof(uei);
    uei.dwMask = UEIM_HIT;
    if (SUCCEEDED(UEMQueryEvent(psmd->uIdAncestor == IDM_PROGRAMS? &UEMIID_SHELL : &UEMIID_BROWSER, 
        UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei)))
    {
        if (uei.cHit == 0) 
        {
            dwFlags |= SMIF_DEMOTED;
        }
    }

    return dwFlags;
}

//
//  WARNING!  Since this function returns a pointer from our Darwin cache,
//  it must be called while the Darwin critical section is held.
//
int GetDarwinIndex(LPCITEMIDLIST pidlFull, CDarwinAd** ppda)
{
    int iRet = -1;
    if (g_hdpaDarwinAds)
    {
        int chdpa = DPA_GetPtrCount(g_hdpaDarwinAds);
        for (int ihdpa = 0; ihdpa < chdpa; ihdpa++)
        {
            *ppda = (CDarwinAd*)DPA_FastGetPtr(g_hdpaDarwinAds, ihdpa);
            if (*ppda)
            {
                if (ILIsEqual((*ppda)->_pidl, pidlFull))
                {
                    iRet = ihdpa;
                    break;
                }
            }
        }
    }
    return iRet;
}

BOOL CStartMenuCallbackBase::_IsDarwinAdvertisement(LPCITEMIDLIST pidlFull)
{
    // What this is doing is comparing the passed in pidl with the
    // list of pidls in g_hdpaDarwinAds. That hdpa contains a list of
    // pidls that are darwin ads.

    // If the background thread is not done, then we must assume that
    // it has not processed the shortcut that we are on. That is why we process it
    // in line.


    ENTERCRITICAL_DARWINADS;

    // NOTE: There can be two items in the hdpa. This is ok.
    BOOL fAd = FALSE;
    CDarwinAd* pda = NULL;
    int iIndex = GetDarwinIndex(pidlFull, &pda);
    // Are there any ads?
    if (iIndex != -1 && pda != NULL)
    {
        //This is a Darwin pidl. Is it installed?
        fAd = pda->IsAd();
    }

    LEAVECRITICAL_DARWINADS;

    return fAd;
}

STDAPI SHParseDarwinIDFromCacheW(LPWSTR pszDarwinDescriptor, LPWSTR *ppwszOut)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    if (g_hdpaDarwinAds)
    {
        ENTERCRITICAL_DARWINADS;
        int chdpa = DPA_GetPtrCount(g_hdpaDarwinAds);
        for (int ihdpa = 0; ihdpa < chdpa; ihdpa++)
        {
            CDarwinAd *pda = (CDarwinAd*)DPA_FastGetPtr(g_hdpaDarwinAds, ihdpa);
            if (pda && pda->_pszLocalPath && pda->_pszDescriptor &&
                StrCmpCW(pszDarwinDescriptor, pda->_pszDescriptor) == 0)
            {
                hr = SHStrDupW(pda->_pszLocalPath, ppwszOut);
                break;
            }
        }
        LEAVECRITICAL_DARWINADS;
    }

    return hr;
}


// REARCHITECT (lamadio): There is a duplicate of this helper in browseui\browmenu.cpp
//                   When modifying this, rev that one as well.
void UEMRenamePidl(const GUID *pguidGrp1, IShellFolder* psf1, LPCITEMIDLIST pidl1,
                   const GUID *pguidGrp2, IShellFolder* psf2, LPCITEMIDLIST pidl2)
{
    UEMINFO uei;
    uei.cbSize = sizeof(uei);
    uei.dwMask = UEIM_HIT | UEIM_FILETIME;
    if (SUCCEEDED(UEMQueryEvent(pguidGrp1, 
                                UEME_RUNPIDL, (WPARAM)psf1, 
                                (LPARAM)pidl1, &uei)) &&
                                uei.cHit > 0)
    {
        UEMSetEvent(pguidGrp2, 
            UEME_RUNPIDL, (WPARAM)psf2, (LPARAM)pidl2, &uei);

        uei.cHit = 0;
        UEMSetEvent(pguidGrp1, 
            UEME_RUNPIDL, (WPARAM)psf1, (LPARAM)pidl1, &uei);
    }
}

// REARCHITECT (lamadio): There is a duplicate of this helper in browseui\browmenu.cpp
//                   When modifying this, rev that one as well.
void UEMDeletePidl(const GUID *pguidGrp, IShellFolder* psf, LPCITEMIDLIST pidl)
{
    UEMINFO uei;
    uei.cbSize = sizeof(uei);
    uei.dwMask = UEIM_HIT;
    uei.cHit = 0;
    UEMSetEvent(pguidGrp, UEME_RUNPIDL, (WPARAM)psf, (LPARAM)pidl, &uei);
}

//
//  Sortof safe version of ILIsParent which catches when pidlParent or
//  pidlBelow is NULL.  pidlParent can be NULL on systems that don't
//  have a Common Program Files folder.  pidlBelow should never be NULL
//  but it doesn't hurt to check.
//
STDAPI_(BOOL) SMILIsAncestor(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlBelow)
{
    if (pidlParent && pidlBelow)
        return ILIsParent(pidlParent, pidlBelow, FALSE);
    else
        return FALSE;
}

HRESULT CStartMenuCallbackBase::_ProcessChangeNotify(SMDATA* psmd, LONG lEvent,
                                                 LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    switch (lEvent)
    {
    case SHCNE_ASSOCCHANGED:
        SHReValidateDarwinCache();
        return S_OK;

    case SHCNE_RENAMEFOLDER:
        // NTRAID89654-2000/03/13 (lamadio): We should move the MenuOrder stream as well. 5.5.99
    case SHCNE_RENAMEITEM:
        {
            LPITEMIDLIST pidlPrograms;
            LPITEMIDLIST pidlProgramsCommon;
            LPITEMIDLIST pidlFavorites;
            SHGetFolderLocation(NULL, CSIDL_PROGRAMS, NULL, 0, &pidlPrograms);
            SHGetFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, NULL, 0, &pidlProgramsCommon);
            SHGetFolderLocation(NULL, CSIDL_FAVORITES, NULL, 0, &pidlFavorites);

            BOOL fPidl1InStartMenu =    SMILIsAncestor(pidlPrograms, pidl1) ||
                                        SMILIsAncestor(pidlProgramsCommon, pidl1);
            BOOL fPidl1InFavorites =    SMILIsAncestor(pidlFavorites, pidl1);


            // If we're renaming something from the Start Menu
            if ( fPidl1InStartMenu ||fPidl1InFavorites)
            {
                IShellFolder* psfFrom;
                LPCITEMIDLIST pidlFrom;
                if (SUCCEEDED(SHBindToParent(pidl1, IID_PPV_ARG(IShellFolder, &psfFrom), &pidlFrom)))
                {
                    // Into the Start Menu
                    BOOL fPidl2InStartMenu =    SMILIsAncestor(pidlPrograms, pidl2) ||
                                                SMILIsAncestor(pidlProgramsCommon, pidl2);
                    BOOL fPidl2InFavorites =    SMILIsAncestor(pidlFavorites, pidl2);
                    if (fPidl2InStartMenu || fPidl2InFavorites)
                    {
                        IShellFolder* psfTo;
                        LPCITEMIDLIST pidlTo;

                        if (SUCCEEDED(SHBindToParent(pidl2, IID_PPV_ARG(IShellFolder, &psfTo), &pidlTo)))
                        {
                            // Then we need to rename it
                            UEMRenamePidl(fPidl1InStartMenu ? &UEMIID_SHELL: &UEMIID_BROWSER, 
                                            psfFrom, pidlFrom, 
                                          fPidl2InStartMenu ? &UEMIID_SHELL: &UEMIID_BROWSER, 
                                            psfTo, pidlTo);
                            psfTo->Release();
                        }
                    }
                    else
                    {
                        // Otherwise, we delete it.
                        UEMDeletePidl(fPidl1InStartMenu ? &UEMIID_SHELL : &UEMIID_BROWSER, 
                            psfFrom, pidlFrom);
                    }

                    psfFrom->Release();
                }
            }

            ILFree(pidlPrograms);
            ILFree(pidlProgramsCommon);
            ILFree(pidlFavorites);
        }
        break;

    case SHCNE_DELETE:
        // NTRAID89654-2000/03/13 (lamadio): We should nuke the MenuOrder stream as well. 5.5.99
    case SHCNE_RMDIR:
        {
            IShellFolder* psf;
            LPCITEMIDLIST pidl;

            if (SUCCEEDED(SHBindToParent(pidl1, IID_PPV_ARG(IShellFolder, &psf), &pidl)))
            {
                // NOTE favorites is the only that will be initialized
                UEMDeletePidl(psmd->uIdAncestor == IDM_FAVORITES ? &UEMIID_BROWSER : &UEMIID_SHELL, 
                    psf, pidl);
                psf->Release();
            }

        }
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        {
            IShellFolder* psf;
            LPCITEMIDLIST pidl;

            if (SUCCEEDED(SHBindToParent(pidl1, IID_PPV_ARG(IShellFolder, &psf), &pidl)))
            {
                UEMINFO uei;
                uei.cbSize = sizeof(uei);
                uei.dwMask = UEIM_HIT;
                uei.cHit = UEM_NEWITEMCOUNT;
                UEMSetEvent(psmd->uIdAncestor == IDM_FAVORITES? &UEMIID_BROWSER: &UEMIID_SHELL, 
                    UEME_RUNPIDL, (WPARAM)psf, (LPARAM)pidl, &uei);
                psf->Release();
            }

        }
        break;
    }

    return S_FALSE;
}

HRESULT CStartMenuCallbackBase::_GetSFInfo(SMDATA* psmd, SMINFO* psminfo)
{
    if (psminfo->dwMask & SMIM_FLAGS &&
        (psmd->uIdAncestor == IDM_PROGRAMS ||
         psmd->uIdAncestor == IDM_FAVORITES))
    {
        if (_fExpandoMenus)
        {
            psminfo->dwFlags |= _GetDemote(psmd);
        }

        // This is a little backwards. If the Restriction is On, Then we allow the feature.
        if (SHRestricted(REST_GREYMSIADS) &&
            psmd->uIdAncestor == IDM_PROGRAMS)
        {
            LPITEMIDLIST pidlFull = FullPidlFromSMData(psmd);
            if (pidlFull)
            {
                if (_IsDarwinAdvertisement(pidlFull))
                {
                    psminfo->dwFlags |= SMIF_ALTSTATE;
                }
                ILFree(pidlFull);
            }
        }

        if (_ptp2)
        {
            _ptp2->ModifySMInfo(psmd, psminfo);
        }
    }
    return S_OK;
}

STDAPI_(void) SHReValidateDarwinCache()
{
    if (g_hdpaDarwinAds)
    {
        ENTERCRITICAL_DARWINADS;
        int chdpa = DPA_GetPtrCount(g_hdpaDarwinAds);
        for (int ihdpa = 0; ihdpa < chdpa; ihdpa++)
        {
            CDarwinAd* pda = (CDarwinAd*)DPA_FastGetPtr(g_hdpaDarwinAds, ihdpa);
            if (pda)
            {
                pda->CheckInstalled();
            }
        }
        LEAVECRITICAL_DARWINADS;
    }
}

// Determines if a CSIDL is a child of another CSIDL
// e.g.
//  CSIDL_STARTMENU = c:\foo\bar\Start Menu
//  CSIDL_PROGRAMS  = c:\foo\bar\Start Menu\Programs
//  Return true
BOOL IsCSIDLChild(int csidlParent, int csidlChild)
{
    BOOL fChild = FALSE;
    TCHAR sz1[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPath(NULL, csidlParent, NULL, 0, sz1)))
    {
        TCHAR sz2[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, csidlChild, NULL, 0, sz2)))
        {
            TCHAR szCommonRoot[MAX_PATH];
            if (PathCommonPrefix(sz1, sz2, szCommonRoot) ==
                lstrlen(sz1))
            {
                fChild = TRUE;
            }
        }
    }

    return fChild;
}

//
// Now StartMenuChange value is stored seperately for classic startmenu and new startmenu.
// So, we need to check which one is currently on before we read the value.
//
BOOL IsStartMenuChangeNotAllowed(BOOL fStartPanel)
{
    return(IsRestrictedOrUserSetting(HKEY_CURRENT_USER, REST_NOCHANGESTARMENU, 
                    TEXT("Advanced"), 
                    (fStartPanel ? TEXT("Start_EnableDragDrop") : TEXT("StartMenuChange")), 
                    ROUS_DEFAULTALLOW | ROUS_KEYALLOWS));
}

// Creates the "Start Menu\\Programs" section of the start menu by
// generating a Merged Shell folder, setting the locations into that item
// then sets it into the passed IShellMenu.
HRESULT CStartMenuCallbackBase::InitializeProgramsShellMenu(IShellMenu* psm)
{
    HKEY hkeyPrograms = NULL;
    LPITEMIDLIST pidl = NULL;

    DWORD dwInitFlags = SMINIT_VERTICAL;
    if (!FeatureEnabled(_fIsStartPanel ? TEXT("Start_ScrollPrograms") : TEXT("StartMenuScrollPrograms")))
        dwInitFlags |= SMINIT_MULTICOLUMN;

    if (IsStartMenuChangeNotAllowed(_fIsStartPanel))
        dwInitFlags |= SMINIT_RESTRICT_DRAGDROP | SMINIT_RESTRICT_CONTEXTMENU;

    if (_fIsStartPanel)
        dwInitFlags |= SMINIT_TOPLEVEL;

    HRESULT hr = psm->Initialize(this, IDM_PROGRAMS, IDM_PROGRAMS, dwInitFlags);
    if (SUCCEEDED(hr))
    {
        _InitializePrograms();

        LPCTSTR pszOrderKey = _fIsStartPanel ?
                STRREG_STARTMENU2 TEXT("\\Programs") :
                STRREG_STARTMENU TEXT("\\Programs");

        RegCreateKeyEx(HKEY_CURRENT_USER, pszOrderKey, NULL, NULL,
            REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
            NULL, &hkeyPrograms, NULL);

        IShellFolder* psf;
        BOOL fOptimize = FALSE;
        DWORD dwSmset = SMSET_TOP;

        if (_fIsStartPanel)
        {
            // Start Panel: Menu:  The Programs section is a merge of the
            // Fast Items and Programs folders with a separator between them.
            dwSmset |= SMSET_SEPARATEMERGEFOLDER;
            hr = GetMergedFolder(&psf, &pidl, c_rgmfiProgramsFolderAndFastItems,
                                 ARRAYSIZE(c_rgmfiProgramsFolderAndFastItems));
        }
        else
        {
            // Classic Start Menu:  The Programs section is just the per-user
            // and common Programs folders merged together
            hr = GetMergedFolder(&psf, &pidl, c_rgmfiProgramsFolder,
                                 ARRAYSIZE(c_rgmfiProgramsFolder));

            // We used to register for change notify at CSIDL_STARTMENU and assumed
            // that CSIDL_PROGRAMS was a child of CSIDL_STARTMENU. Since this wasn't always the 
            // case, I removed the optimization.

            // Both panes are registered recursive. So, When CSIDL_PROGRAMS _IS_ a 
            // child of CSIDL_STARTMENU we can enter a code path where when destroying 
            // CSIDL_PROGRAMS, we unregister it. This will flush the change nofiy queue 
            // of CSIDL_STARTMENU, and blow away all of the children, including CSIDL_PROGRAMS, 
            // while we are in the middle of destroying it... See the problem? I have been adding 
            // reentrance "Blockers" but this only delayed where we crashed. 
            // What was needed was to determine if Programs was a child of the Start Menu directory.
            // if it was we need to add the optmimization. If it's not we don't have a problem.

            // WINDOWS BUG 135156(tybeam): If one of the two is redirected, then this will get optimized
            // we can't do better than this because both are registed recursive, and this will fault...
            fOptimize = IsCSIDLChild(CSIDL_STARTMENU, CSIDL_PROGRAMS)
                || IsCSIDLChild(CSIDL_COMMON_STARTMENU, CSIDL_COMMON_PROGRAMS);
            if (fOptimize)
            {
                dwSmset |= SMSET_DONTREGISTERCHANGENOTIFY;
            }
        }

        if (SUCCEEDED(hr))
        {
            // We should have a pidl from CSIDL_Programs
            ASSERT(pidl);

            // We should have a shell folder from the bind.
            ASSERT(psf);

            hr = psm->SetShellFolder(psf, pidl, hkeyPrograms, dwSmset);
            psf->Release();
            ILFree(pidl);                        
        }

        if (FAILED(hr))
            RegCloseKey(hkeyPrograms);
    }

    return hr;
}

HRESULT GetFolderAndPidl(UINT csidl, IShellFolder **ppsf, LPITEMIDLIST *ppidl)
{
    *ppsf = NULL;
    HRESULT hr = SHGetFolderLocation(NULL, csidl, NULL, 0, ppidl);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, *ppidl, ppsf));
        if (FAILED(hr))
        {
            ILFree(*ppidl);
            *ppidl = NULL;
        }
    }
    return hr;
}

// Creates the "Start Menu\\<csidl>" section of the start menu by
// looking up the csidl, generating the Hkey from HKCU\pszRoot\pszValue,
//  Initializing the IShellMenu with dwPassInitFlags, then setting the locations 
// into the passed IShellMenu passing the flags dwSetFlags.
HRESULT CStartMenuCallback::InitializeCSIDLShellMenu(int uId, int csidl, LPTSTR pszRoot, LPTSTR pszValue,
                                                 DWORD dwPassInitFlags, DWORD dwSetFlags, BOOL fAddOpen,
                                                 IShellMenu* psm)
{
    DWORD dwInitFlags = SMINIT_VERTICAL | dwPassInitFlags;

    if (IsStartMenuChangeNotAllowed(_fIsStartPanel))
        dwInitFlags |= SMINIT_RESTRICT_DRAGDROP | SMINIT_RESTRICT_CONTEXTMENU;

    psm->Initialize(this, uId, uId, dwInitFlags);

    LPITEMIDLIST pidl;
    IShellFolder* psfFolder;
    HRESULT hr = GetFolderAndPidl(csidl, &psfFolder, &pidl);
    if (SUCCEEDED(hr))
    {
        HKEY hKey = NULL;

        if (pszRoot)
        {
            TCHAR szPath[MAX_PATH];
            StrCpyN(szPath, pszRoot, ARRAYSIZE(szPath));
            if (pszValue)
            {
                PathAppend(szPath, pszValue);
            }

            RegCreateKeyEx(HKEY_CURRENT_USER, szPath, NULL, NULL,
                REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                NULL, &hKey, NULL);
        }

        // Point the menu to the shellfolder
        hr = psm->SetShellFolder(psfFolder, pidl, hKey, dwSetFlags);
        if (SUCCEEDED(hr))
        {
            if (fAddOpen && _fAddOpenFolder)
            {
                HMENU hMenu = SHLoadMenuPopup(HINST_THISDLL, MENU_STARTMENU_OPENFOLDER);
                if (hMenu)
                {
                    psm->SetMenu(hMenu, _hwnd, SMSET_BOTTOM);
                }
            }
        }
        else
            RegCloseKey(hKey);

        psfFolder->Release();
        ILFree(pidl);
    }

    return hr;
}

// This generates the Recent | My Documents, My Pictures sub menu.
HRESULT CStartMenuCallback::InitializeDocumentsShellMenu(IShellMenu* psm)
{
    HRESULT hr = InitializeCSIDLShellMenu(IDM_RECENT, CSIDL_RECENT, NULL, NULL,
                                SMINIT_RESTRICT_DRAGDROP, SMSET_BOTTOM, FALSE,
                                psm);

    // Initializing, reset cache bits for top part of menu
    _fHasMyDocuments = FALSE;
    _fHasMyPictures = FALSE;

    return hr;
}

HRESULT CStartMenuCallback::InitializeFastItemsShellMenu(IShellMenu* psm)
{
    DWORD dwFlags = SMINIT_TOPLEVEL | SMINIT_VERTICAL;

    if (IsStartMenuChangeNotAllowed(_fIsStartPanel))
        dwFlags |= SMINIT_RESTRICT_DRAGDROP | SMINIT_RESTRICT_CONTEXTMENU;

    HRESULT hr = psm->Initialize(this, 0, ANCESTORDEFAULT, dwFlags);
    if (SUCCEEDED(hr))
    {
        _InitializePrograms();

        // Add the fast item folder to the top of the menu
        IShellFolder* psfFast;
        LPITEMIDLIST pidlFast;
        hr = GetMergedFolder(&psfFast, &pidlFast, c_rgmfiStartMenu, ARRAYSIZE(c_rgmfiStartMenu));
        if (SUCCEEDED(hr))
        {
            HKEY hMenuKey = NULL;   // WARNING: pmb2->Initialize() will always owns hMenuKey, so don't close it

            RegCreateKeyEx(HKEY_CURRENT_USER, STRREG_STARTMENU, NULL, NULL,
                REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                NULL, &hMenuKey, NULL);

            TraceMsg(TF_MENUBAND, "Root Start Menu Key Is %d", hMenuKey);
            hr = psm->SetShellFolder(psfFast, pidlFast, hMenuKey, SMSET_TOP | SMSET_NOEMPTY);

            psfFast->Release();
            ILFree(pidlFast);
        }
    }

    return hr;
}

HRESULT CStartMenuCallback::_InitializeFindMenu(IShellMenu* psm)
{
    HRESULT hr = E_FAIL;

    psm->Initialize(this, IDM_MENU_FIND, IDM_MENU_FIND, SMINIT_VERTICAL);

    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        ATOMICRELEASE(_pcmFind);

        if (_ptp)
        {
            if (SUCCEEDED(_ptp->GetFindCM(hmenu, TRAY_IDM_FINDFIRST, TRAY_IDM_FINDLAST, &_pcmFind)))
            {
                IContextMenu2 *pcm2;
                _pcmFind->QueryInterface(IID_PPV_ARG(IContextMenu2, &pcm2));
                if (pcm2)
                {
                    pcm2->HandleMenuMsg(WM_INITMENUPOPUP, (WPARAM)hmenu, 0);
                    pcm2->Release();
                }
            }

            if (_pcmFind)
            {
                hr = psm->SetMenu(hmenu, NULL, SMSET_TOP);
                // Don't Release _pcmFind
            }
        }

        // Since we failed to create the ShellMenu
        // we need to dispose of this HMENU
        if (FAILED(hr))
            DestroyMenu(hmenu);
    }

    return hr;
}

HRESULT CStartMenuCallback::InitializeSubShellMenu(int idCmd, IShellMenu* psm)
{
    HRESULT hr = E_FAIL;

    switch(idCmd)
    {
    case IDM_PROGRAMS:
        hr = InitializeProgramsShellMenu(psm);
        break;

    case IDM_RECENT:
        hr = InitializeDocumentsShellMenu(psm);
        break;

    case IDM_MENU_FIND:
        hr = _InitializeFindMenu(psm);
        break;

    case IDM_FAVORITES:
        hr = InitializeCSIDLShellMenu(IDM_FAVORITES, CSIDL_FAVORITES, STRREG_FAVORITES,
                             NULL, 0, SMSET_HASEXPANDABLEFOLDERS | SMSET_USEBKICONEXTRACTION, FALSE,
                             psm);
        break;
    
    case IDM_CONTROLS:
        hr = InitializeCSIDLShellMenu(IDM_CONTROLS, CSIDL_CONTROLS, STRREG_STARTMENU,
                             TEXT("ControlPanel"), 0, 0,  TRUE,
                             psm);
        break;

    case IDM_PRINTERS:
        hr = InitializeCSIDLShellMenu(IDM_PRINTERS, CSIDL_PRINTERS, STRREG_STARTMENU,
                             TEXT("Printers"), 0, 0,  TRUE,
                             psm);
        break;

    case IDM_MYDOCUMENTS:
        hr = InitializeCSIDLShellMenu(IDM_MYDOCUMENTS, CSIDL_PERSONAL, STRREG_STARTMENU,
                             TEXT("MyDocuments"), 0, 0,  TRUE,
                             psm);
        break;

    case IDM_MYPICTURES:
        hr = InitializeCSIDLShellMenu(IDM_MYPICTURES, CSIDL_MYPICTURES, STRREG_STARTMENU,
                             TEXT("MyPictures"), 0, 0,  TRUE,
                             psm);
        break;

    case IDM_NETCONNECT:
        hr = InitializeCSIDLShellMenu(IDM_NETCONNECT, CSIDL_CONNECTIONS, STRREG_STARTMENU,
                             TEXT("NetConnections"), 0, 0,  TRUE,
                             psm);
        break;
    }

    return hr;
}

HRESULT CStartMenuCallback::_GetObject(LPSMDATA psmd, REFIID riid, void** ppvOut)
{
    HRESULT hr = E_FAIL;
    UINT    uId = psmd->uId;

    ASSERT(ppvOut);
    ASSERT(IS_VALID_READ_PTR(psmd, SMDATA));

    *ppvOut = NULL;

    if (IsEqualGUID(riid, IID_IShellMenu))
    {
        IShellMenu* psm = NULL;
        hr = CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC, IID_PPV_ARG(IShellMenu, &psm));
        if (SUCCEEDED(hr))
        {
            hr = InitializeSubShellMenu(uId, psm);
 
            if (FAILED(hr))
            {
                psm->Release();
                psm = NULL;
            }
        }

        *ppvOut = psm;
    }
    else if (IsEqualGUID(riid, IID_IContextMenu))
    {
        //
        //  NOTE - we dont allow users to open the recent folder this way - ZekeL - 1-JUN-99
        //  because this is really an internal folder and not a user folder.
        //
        
        switch (uId)
        {
        case IDM_PROGRAMS:
        case IDM_FAVORITES:
        case IDM_MYDOCUMENTS:
        case IDM_MYPICTURES:
        case IDM_CONTROLS:
        case IDM_PRINTERS:
        case IDM_NETCONNECT:
            {
                CStartContextMenu* pcm = new CStartContextMenu(uId);
                if (pcm)
                {
                    hr = pcm->QueryInterface(riid, ppvOut);
                    pcm->Release();
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

//
//  Return S_OK to remove the pidl from enumeration
//
HRESULT CStartMenuCallbackBase::_FilterPidl(UINT uParent, IShellFolder* psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;
    
    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));
    
    if (uParent == IDM_PROGRAMS || uParent == IDM_TOPLEVELSTARTMENU)
    {
        TCHAR szChild[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szChild, ARRAYSIZE(szChild))))
        {
            // HACKHACK (lamadio): This code assumes that the Display name
            // of the Programs and Commons Programs folders are the same. It
            // also assumes that the "programs" folder in the Start Menu folder
            // is the same name as the one pointed to by CSIDL_PROGRAMS.
            // Filter from top level start menu:
            //      Programs, Windows Update, Configure Programs
            if (_IsTopLevelStartMenu(uParent, psf, pidl))
            {
                if ((_pszPrograms && (0 == lstrcmpi(szChild, _pszPrograms))) ||
                    (SHRestricted(REST_NOUPDATEWINDOWS) && _pszWindowsUpdate && (0 == lstrcmpi(szChild, _pszWindowsUpdate))) ||
                    (SHRestricted(REST_NOSMCONFIGUREPROGRAMS) && _pszConfigurePrograms && (0 == lstrcmpi(szChild, _pszConfigurePrograms))))
                {
                    hr = S_OK;
                }
            }
            else
            {
                // IDM_PROGRAMS
                // Filter from Programs:  Administrative tools.
                if (!_fShowAdminTools && _pszAdminTools && lstrcmpi(szChild, _pszAdminTools) == 0)
                {
                    hr = S_OK;
                }
            }
        }
    }
    return hr;
}

BOOL LinkGetInnerPidl(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlOut, DWORD *pdwAttr)
{
    *ppidlOut = NULL;

    IShellLink *psl;
    HRESULT hr = psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IShellLink, NULL, &psl));
    if (SUCCEEDED(hr))
    {
        psl->GetIDList(ppidlOut);

        if (*ppidlOut)
        {
            if (FAILED(SHGetAttributesOf(*ppidlOut, pdwAttr)))
            {
                ILFree(*ppidlOut);
                *ppidlOut = NULL;
            }
        }
        psl->Release();
    }
    return (*ppidlOut != NULL);
}


//
//  _FilterRecentPidl() 
//  the Recent Documents folder can now (NT5) have more than 15 or 
//  so documents, but we only want to show the 15 most recent that we always have on
//  the start menu.  this means that we need to filter out all folders and 
//  anything more than MAXRECENTDOCS
//
HRESULT CStartMenuCallback::_FilterRecentPidl(IShellFolder* psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;

    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(_cRecentDocs != -1);
    
    ASSERT(_cRecentDocs <= MAXRECENTDOCS);
    
    //  if we already reached our limit, dont go over...
    if (_pmruRecent && (_cRecentDocs < MAXRECENTDOCS))
    {
        //  we now must take a looksee for it...
        int iItem;
        DWORD dwAttr = SFGAO_FOLDER | SFGAO_BROWSABLE;
        LPITEMIDLIST pidlTrue;

        //  need to find out if the link points to a folder...
        //  because we dont want
        if (SUCCEEDED(_pmruRecent->FindData((BYTE *) pidl, ILGetSize(pidl), &iItem))
        && LinkGetInnerPidl(psf, pidl, &pidlTrue, &dwAttr))
        {
            if (!(dwAttr & SFGAO_FOLDER))
            {
                //  we have a link to something that isnt a folder 
                hr = S_FALSE;
                _cRecentDocs++;
            }

            ILFree(pidlTrue);
        }
    }
                
    //  return S_OK if you dont want to show this item...

    return hr;
}


HRESULT CStartMenuCallback::_HandleAccelerator(TCHAR ch, SMDATA* psmdata)
{
    // Since we renamed the 'Find' menu to 'Search' the PMs wanted to have
    // an upgrade path for users (So they can continue to use the old accelerator
    // on the new menu item.)
    // To enable this, when toolbar detects that there is not an item in the menu
    // that contains the key that has been pressed, then it sends a TBN_ACCL.
    // This is intercepted by mnbase, and translated into SMC_ACCEL. 
    if (CharUpper((LPTSTR)ch) == CharUpper((LPTSTR)_szFindMnemonic[0]))
    {
        psmdata->uId = IDM_MENU_FIND;
        return S_OK;
    }

    return S_FALSE;
}

HRESULT CStartMenuCallback::_GetTip(LPWSTR pstrTitle, LPWSTR pstrTip)
{
    if (pstrTitle == NULL || 
        pstrTip == NULL)
    {
        return S_FALSE;
    }

    LoadString(HINST_THISDLL, IDS_CHEVRONTIPTITLE, pstrTitle, MAX_PATH);
    LoadString(HINST_THISDLL, IDS_CHEVRONTIP, pstrTip, MAX_PATH);

    // Why would this fail?
    ASSERT(pstrTitle[0] != L'\0' && pstrTip[0] != L'\0');
    return S_OK;
}

STDAPI CStartMenu_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hr = E_FAIL;
    IMenuPopup* pmp = NULL;

    *ppvOut = NULL;

    CStartMenuCallback* psmc = new CStartMenuCallback();
    if (psmc)
    {
        IShellMenu* psm;

        hr = CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellMenu, &psm));
        if (SUCCEEDED(hr))
        {
            hr = CoCreateInstance(CLSID_MenuDeskBar, punkOuter, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMenuPopup, &pmp));
            if (SUCCEEDED(hr)) 
            {
                IBandSite* pbs;
                hr = CoCreateInstance(CLSID_MenuBandSite, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBandSite, &pbs));
                if (SUCCEEDED(hr)) 
                {
                    hr = pmp->SetClient(pbs);
                    if (SUCCEEDED(hr)) 
                    {
                        IDeskBand* pdb;
                        hr = psm->QueryInterface(IID_PPV_ARG(IDeskBand, &pdb));
                        if (SUCCEEDED(hr))
                        {
                           hr = pbs->AddBand(pdb);
                           pdb->Release();
                        }
                    }
                    pbs->Release();
                }
                // Don't free pmp. We're using it below.
            }

            if (SUCCEEDED(hr))
            {
                // This is so the ref counting happens correctly.
                hr = psm->Initialize(psmc, 0, 0, SMINIT_VERTICAL | SMINIT_TOPLEVEL);
                if (SUCCEEDED(hr))
                {
                    // if this fails, we don't get that part of the menu
                    // this is okay since it can happen if the start menu is redirected
                    // to where we dont have access.
                    psmc->InitializeFastItemsShellMenu(psm);
                }
            }

            psm->Release();
        }
        psmc->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = pmp->QueryInterface(riid, ppvOut);
    }
    else
    {
        // We need to do this so that it does a cascading delete
        IUnknown_SetSite(pmp, NULL);        
    }

    if (pmp)
        pmp->Release();

    return hr;
}

// IUnknown
STDMETHODIMP CStartContextMenu::QueryInterface(REFIID riid, void **ppvObj)
{

    static const QITAB qit[] = 
    {
        QITABENT(CStartContextMenu, IContextMenu),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CStartContextMenu::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CStartContextMenu::Release(void)
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

// IContextMenu
STDMETHODIMP CStartContextMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr = E_FAIL;
    HMENU hmenuStartMenu = SHLoadMenuPopup(HINST_THISDLL, MENU_STARTMENUSTATICITEMS);

    if (hmenuStartMenu)
    {
        TCHAR szCommon[MAX_PATH];
        BOOL fAddCommon = (S_OK == SHGetFolderPath(NULL, CSIDL_COMMON_STARTMENU, NULL, 0, szCommon));

        if (fAddCommon)
            fAddCommon = IsUserAnAdmin();

        // Since we don't show this on the start button when the user is not an admin, don't show it here... I guess...
        if (_idCmd != IDM_PROGRAMS || !fAddCommon)
        {
            DeleteMenu(hmenuStartMenu, SMCM_OPEN_ALLUSERS, MF_BYCOMMAND);
            DeleteMenu(hmenuStartMenu, SMCM_EXPLORE_ALLUSERS, MF_BYCOMMAND);
        }

        if (Shell_MergeMenus(hmenu, hmenuStartMenu, 0, indexMenu, idCmdLast, uFlags))
        {
            SetMenuDefaultItem(hmenu, 0, MF_BYPOSITION);
            _SHPrettyMenu(hmenu);
            hr = ResultFromShort(GetMenuItemCount(hmenuStartMenu));
        }

        DestroyMenu(hmenuStartMenu);
    }
    
    return hr;
}

STDMETHODIMP CStartContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    HRESULT hr = E_FAIL;
    if (HIWORD64(lpici->lpVerb) == 0)
    {
        BOOL fAllUsers = FALSE;
        BOOL fOpen = TRUE;
        switch(LOWORD(lpici->lpVerb))
        {
        case SMCM_OPEN_ALLUSERS:
            fAllUsers = TRUE;
        case SMCM_OPEN:
            // fOpen = TRUE;
            break;

        case SMCM_EXPLORE_ALLUSERS:
            fAllUsers = TRUE;
        case SMCM_EXPLORE:
            fOpen = FALSE;
            break;

        default:
            return S_FALSE;
        }

        hr = ExecStaticStartMenuItem(_idCmd, fAllUsers, fOpen);
    }

    // Ahhh Don't handle verbs!!!
    return hr;

}

STDMETHODIMP CStartContextMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

//****************************************************************************
//
//  CPersonalStartMenuCallback

class CPersonalProgramsMenuCallback : public CStartMenuCallbackBase
{
public:
    CPersonalProgramsMenuCallback() : CStartMenuCallbackBase(TRUE) { }

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** IObjectWithSite methods *** (overriding CObjectWithSite)
    STDMETHODIMP SetSite(IUnknown* punk);

public:
    HRESULT Initialize(IShellMenu *psm)
        { return InitializeProgramsShellMenu(psm); }

private:
    void _UpdateTrayPriv();

};

//
//  Throw away any previous TrayPriv2 and try to find a new one.
//
//  Throwing it away is important to break circular reference loops.
//
//  Trying to find it will typically fail at SetSite since when we are
//  given our site, CDesktopHost hasn't connected at the top yet so
//  we are unable to find him.  But he will be there by the time
//  SMC_INITMENU arrives, so we try again then.
//
void CPersonalProgramsMenuCallback::_UpdateTrayPriv()
{
    ATOMICRELEASE(_ptp2);
    IObjectWithSite *pows;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IObjectWithSite, &pows))))
    {
        pows->GetSite(IID_PPV_ARG(ITrayPriv2, &_ptp2));
        pows->Release();
    }
}

STDMETHODIMP CPersonalProgramsMenuCallback::SetSite(IUnknown* punk)
{
    HRESULT hr = CObjectWithSite::SetSite(punk);
    _UpdateTrayPriv();
    return hr;
}

STDMETHODIMP CPersonalProgramsMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;

    switch (uMsg)
    {

    case SMC_INITMENU:
        _UpdateTrayPriv();
        break;

    case SMC_GETSFINFO:
        hr = _GetSFInfo(psmd, (SMINFO*)lParam);
        break;

    case SMC_NEWITEM:
        hr = _HandleNew(psmd);
        break;

    case SMC_FILTERPIDL:
        ASSERT(psmd->dwMask & SMDM_SHELLFOLDER);
        hr = _FilterPidl(psmd->uIdParent, psmd->psf, psmd->pidlItem);
        break;

    case SMC_GETSFINFOTIP:
        if (!FeatureEnabled(TEXT("ShowInfoTip")))
            hr = E_FAIL;  // E_FAIL means don't show. S_FALSE means show default
        break;

    case SMC_PROMOTE:
        hr = _Promote(psmd, (DWORD)wParam);
        break;

    case SMC_SHCHANGENOTIFY:
        {
            PSMCSHCHANGENOTIFYSTRUCT pshf = (PSMCSHCHANGENOTIFYSTRUCT)lParam;
            hr = _ProcessChangeNotify(psmd, pshf->lEvent, pshf->pidl1, pshf->pidl2);
        }
        break;

    case SMC_REFRESH:
        _RefreshSettings();
        break;
    }

    return hr;
}


STDAPI CPersonalStartMenu_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hr;

    *ppvOut = NULL;

    IShellMenu *psm;
    hr = CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER,
                          IID_PPV_ARG(IShellMenu, &psm));
    if (SUCCEEDED(hr))
    {
        CPersonalProgramsMenuCallback *psmc = new CPersonalProgramsMenuCallback();
        if (psmc)
        {
            hr = psmc->Initialize(psm);
            if (SUCCEEDED(hr))
            {
                // SetShellFolder takes ownership of hkCustom
                hr = psm->QueryInterface(riid, ppvOut);
            }
            psmc->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        psm->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shelldrt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shelldrt.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shelldrt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	shelldrt.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shelldrt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BB950521_F3D6_4DC5_B6EA_F761B87417DE__INCLUDED_)
#define AFX_STDAFX_H__BB950521_F3D6_4DC5_B6EA_F761B87417DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>

#define INCLUDE_SHTL_SOURCE 1
#define USE_SHELL_AUTOPTR   1

#define _LOCALE_        // isdigit is redefined, I don't know why


#include <windows.h>

inline void * __cdecl operator new(
    size_t size
    )
{
    void *pv = LocalAlloc(LMEM_FIXED, size);
    if (NULL == pv)
    {
        DebugBreak();
        ExitProcess(0);
    }

    return pv;
}

inline void __cdecl operator delete(void *pv)
{
    LocalFree((HLOCAL)pv);
}

#include <shtl.h>
#include <autoptr.h>
#include <tstring.h>

#undef max              // stl doesn't want the old C version of this

// NEW operator that aborts if memory allocation fails.  DRT driver will
// assume allocations never fail, and if they do, user is advised and
// test aborted.


#endif // !defined(AFX_STDAFX_H__BB950521_F3D6_4DC5_B6EA_F761B87417DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\aboutinf.cpp ===
#include <string.h>
#include <ntverp.h>
#include "priv.h"
#include "ids.h"

#define SECURITY_WIN32
#include <schnlsp.h> //for UNISP_NAME_A
#include <sspi.h> //for SCHANNEL.dll api -- to obtain encryption key size

#include <mluisupp.h>
#include <wininet.h>    // INTERNET_MAX_URL_LENGTH

#define MAX_REG_VALUE   256

// Some Static strings that we use to read from the registry

#ifdef UNIX
#define VERSION         "IEUNIX Version"
#define UNIX_IE_PRODUCT_ID TEXT("86139-999-2001594-12504")
#ifndef ux10
#define UNIX_IE_PRODUCT_FILE TEXT("%MWDEV%/ie/setup/sunos5/.iepid")
#else
#define UNIX_IE_PRODUCT_FILE TEXT("%MWDEV%/ie/setup/ux10/.iepid")
#endif
#endif

typedef PSecurityFunctionTable (APIENTRY *INITSECURITYINTERFACE_FN_A) (VOID);

// Returns the maximum cipher strength
DWORD GetCipherStrength()
{
    DWORD                           dwKeySize = 0;
    HINSTANCE                       hSecurity;
    INITSECURITYINTERFACE_FN_A      pfnInitSecurityInterfaceA;
    PSecurityFunctionTable          pSecFuncTable;

    //
    // Can't go directly to schannel on NT5.  (Note that g_bRunningOnNT5OrHigher
    // may not be initialized when fUseSChannel is initialized!)
    //
    static BOOL fUseSChannel = TRUE;
    if (fUseSChannel && !g_bRunningOnNT5OrHigher)
    {
        //
        // This is better for performance. Rather than call through
        // SSPI, we go right to the DLL doing the work.
        //
        hSecurity = LoadLibrary("schannel");
    }
    else
    {
        //
        // Use SSPI
        //
        if (g_bRunningOnNT)
        {
            hSecurity = LoadLibrary("security");
        }
        else
        {
            hSecurity = LoadLibrary("secur32");
        }
    }

    if (hSecurity == NULL)
    {
        return 0;
    }

    //
    // Get the SSPI dispatch table
    //
    pfnInitSecurityInterfaceA =
        (INITSECURITYINTERFACE_FN_A)GetProcAddress(hSecurity, "InitSecurityInterfaceA");

    if (pfnInitSecurityInterfaceA == NULL)
    {
        goto exit;
    }

    pSecFuncTable = (PSecurityFunctionTable)((*pfnInitSecurityInterfaceA)());
    if (pSecFuncTable == NULL)
    {
        goto exit;
    }

    if (pSecFuncTable->AcquireCredentialsHandleA && pSecFuncTable->QueryCredentialsAttributesA)
    {
        TimeStamp  tsExpiry;
        CredHandle chCred;
        SecPkgCred_CipherStrengths cs;

        if (SEC_E_OK == (*pSecFuncTable->AcquireCredentialsHandleA)(NULL,
                          UNISP_NAME_A, // Package
                          SECPKG_CRED_OUTBOUND,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          &chCred,      // Handle
                          &tsExpiry ))
        {
            if (SEC_E_OK == (*pSecFuncTable->QueryCredentialsAttributesA)(&chCred, SECPKG_ATTR_CIPHER_STRENGTHS, &cs))
            {
                dwKeySize = cs.dwMaximumCipherStrength;
            }

            // Free the handle if we can
            if (pSecFuncTable->FreeCredentialsHandle)
            {
                (*pSecFuncTable->FreeCredentialsHandle)(&chCred);
            }
        }
    }

exit:
    FreeLibrary(hSecurity);

    if (dwKeySize == 0 && fUseSChannel)
    {
        // Failed, so retry using SSPI
        fUseSChannel = FALSE;
        dwKeySize = GetCipherStrength();
    }
    return dwKeySize;
}


BOOL SHAboutInfoA(LPSTR lpszInfo, DWORD cchSize)
{
    HKEY        hkey;
    char        szVersion[64];
    char        szUserName[MAX_REG_VALUE];
    char        szCompanyName[MAX_REG_VALUE];
    char        szKeySize[11];
    char        szProductId[MAX_REG_VALUE];
    char        szUpdateUrl[INTERNET_MAX_URL_LENGTH];
    char        szIEAKStr[MAX_REG_VALUE];
    LPSTR       lpszAboutKey;
    DWORD       dwKeySize = 0;
    DWORD       cb;
    DWORD       dwType;
	BOOL        fIEOrShell = TRUE;

    lpszInfo[0]    = '\0';
    szKeySize[0]   = '\0';

#ifndef UNIX
	// Are we in the explorer or IE process?
	fIEOrShell = GetModuleHandle("EXPLORER.EXE") || GetModuleHandle("IEXPLORE.EXE");
	
    if (g_bRunningOnNT)
        lpszAboutKey = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
    else
#endif
        lpszAboutKey = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion";

    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, lpszAboutKey, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        // get the encription key size
        dwKeySize = GetCipherStrength();
        wsprintf(szKeySize, "~%d", dwKeySize);

        // get the custom IEAK update url
        // (always get from Windows\CurrentVersion because IEAK policy file must be platform
        // independent

        cb = sizeof(szUpdateUrl);
        if(SHGetValueA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion",
            "IEAKUpdateUrl", &dwType, (LPBYTE)szUpdateUrl, &cb) != ERROR_SUCCESS)
            szUpdateUrl[0] = '\0';

#ifndef UNIX
        // Extra Whistler/IE6 code to get the VBL version info
        {
            char szVBLVersion[64];
            char* pszBuildLabKey;
            DWORD cbSize;
            DWORD dwType;

            if (g_bRunningOnNT)
            {
                pszBuildLabKey = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
            }
            else
            {
                pszBuildLabKey = "SOFTWARE\\Microsoft\\Internet Explorer";
            }

            cbSize = sizeof(szVBLVersion);
            if ((SHGetValueA(HKEY_LOCAL_MACHINE,
                             pszBuildLabKey,
                             "BuildLab",
                             &dwType,
                             szVBLVersion,
                             &cbSize) == ERROR_SUCCESS) && (dwType == REG_SZ))
            {
                // Now szVBLVersion contains the VBL buildnumber in the format: "2204.reinerf.010700"
                // Since we are only interested in the latter part, we remove the build # (first 4 digits)
                memmove((void*)szVBLVersion, (void*)&szVBLVersion[4], (lstrlenA(szVBLVersion) + 1) * sizeof(char));
            }
            else
            {
                szVBLVersion[0] = '\0';
            }

            // get the Version number (version string is in the following format 5.00.xxxx.x)
            szVersion[0] = '\0';
            cb = sizeof(szVersion);
            if (ERROR_SUCCESS == SHGetValueA(HKEY_LOCAL_MACHINE,
                                             "SOFTWARE\\Microsoft\\Internet Explorer",
                                             "Version", &dwType, (LPVOID)szVersion, &cb))
            {
                DWORD dwLen;

                // if we have a szVBLVersion, tack it onto the end of the IE major/minor version string
                if (*szVBLVersion)
                {
                    lstrcatnA(szVersion, szVBLVersion, ARRAYSIZE(szVersion));
                }

                // added by pritobla on 9/1/98
                // CustomizedVersion contains a 2-letter code that identifies what mode was used
                // (CORP, ICP, ISP, etc.) in building this version IE using the IEAK.
                dwLen = lstrlenA(szVersion);
                cb = sizeof(szVersion) - (dwLen * sizeof(char));
                SHGetValueA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Internet Explorer",
                                               "CustomizedVersion", &dwType, (LPVOID)&szVersion[dwLen], &cb);
            }
        }
#else
        // Get the version details from ntverp.h / ieverp.h
        sprintf(szVersion, "%s.%04d.%04d",VER_PRODUCTVERSION_STRING,
                                      VER_PRODUCTBUILD,
                                      VER_PRODUCTBUILD_QFE);
#endif // UNIX

        if (!fIEOrShell)
        {
	        // Not in the explorer or iexplore process so we are doing some side by side stuff so
	        // reflect this in the version string. Maybe we should get the version out of MSHTML
	        // but not sure since this still doesn't reflect IE4 or IE5 properly anyway.
	        MLLoadString(IDS_SIDEBYSIDE, szVersion, ARRAYSIZE(szVersion));
        }
		
        // get the custom IEAK branded help string
        cb = sizeof(szIEAKStr);
        if(RegQueryValueExA(hkey, "IEAKHelpString", 0, &dwType, (LPBYTE)szIEAKStr, &cb) != ERROR_SUCCESS)
            szIEAKStr[0] = '\0';

        // get the User name.
        cb = sizeof(szUserName);
        if(RegQueryValueExA(hkey, "RegisteredOwner", 0, &dwType, (LPBYTE)szUserName, &cb) != ERROR_SUCCESS)
            szUserName[0] = '\0';

        // get the Organization name.
        cb = sizeof(szCompanyName);
        if(RegQueryValueExA(hkey, "RegisteredOrganization", 0, &dwType, (LPBYTE)szCompanyName, &cb) != ERROR_SUCCESS)
            szCompanyName[0] = '\0';

#ifndef UNIX
        cb = sizeof(szProductId);
        if (SHGetValueA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Internet Explorer\\Registration", "ProductId", &dwType, (LPVOID)szProductId, &cb) != ERROR_SUCCESS)
        {
            szProductId[0] = '\0';
        }
#else
        HANDLE hPidFile;
        char szPidFileName[MAX_PATH];
        DWORD dwRead;
        SHExpandEnvironmentStrings(UNIX_IE_PRODUCT_FILE, szPidFileName, MAX_PATH);
        if ((hPidFile = CreateFileA(szPidFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))
            == INVALID_HANDLE_VALUE)
        {
            sprintf(szProductId, "%s", UNIX_IE_PRODUCT_ID);
        }
        else
        {
            ReadFile(hPidFile, (LPVOID)szProductId, 23, &dwRead, NULL);
            szProductId[dwRead] = 0;
        }

        CloseHandle(hPidFile);
#endif
        lstrcatn(lpszInfo, szVersion, cchSize);
        lstrcatn(lpszInfo, "~", cchSize);
        lstrcatn(lpszInfo, szUserName, cchSize);
        lstrcatn(lpszInfo, "~", cchSize);
        lstrcatn(lpszInfo, szCompanyName, cchSize);
        lstrcatn(lpszInfo, szKeySize, cchSize);
        lstrcatn(lpszInfo, "~", cchSize);
        lstrcatn(lpszInfo, szProductId, cchSize);
        lstrcatn(lpszInfo, "~", cchSize);
        lstrcatn(lpszInfo, szUpdateUrl, cchSize);
        lstrcatn(lpszInfo, "~", cchSize);
        lstrcatn(lpszInfo, szIEAKStr, cchSize);

        RegCloseKey(hkey);
    }
    else
        return FALSE;

    return TRUE;
}

BOOL SHAboutInfoW(LPWSTR lpszInfo, DWORD cchSize)
{
    LPSTR   lpszTmp;
    BOOL    bRet = FALSE;

    lpszInfo[0] = L'\0';

    if(NULL != (lpszTmp = (LPSTR)LocalAlloc(LPTR, cchSize)))
        if(SHAboutInfoA(lpszTmp, cchSize))
            if(MultiByteToWideChar(CP_ACP, 0, lpszTmp, -1, lpszInfo, cchSize) != 0)
                bRet = TRUE;

    if(lpszTmp)
        LocalFree(lpszTmp);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\apithk.h ===
//
//  APITHK.H
//
#ifndef _APITHK_H_
#define _APITHK_H_

#define PrivateSM_REMOTESESSION 0x1000

#define PrivateWM_CHANGEUISTATE     0x0127
#define PrivateWM_UPDATEUISTATE     0x0128
#define PrivateWM_QUERYUISTATE      0x0129

#define PrivateUIS_SET              1
#define PrivateUIS_CLEAR            2
#define PrivateUIS_INITIALIZE       3

#define PrivateUISF_HIDEFOCUS       0x1
#define PrivateUISF_HIDEACCEL       0x2

#if (WINVER >= 0x0500)

#if SM_REMOTESESSION != PrivateSM_REMOTESESSION
#error Incorrect definition of PrivateSM_REMOTESESSION
#endif

#if WM_CHANGEUISTATE != PrivateWM_CHANGEUISTATE || \
    WM_UPDATEUISTATE != PrivateWM_UPDATEUISTATE || \
    WM_QUERYUISTATE  != PrivateWM_QUERYUISTATE
#error Inconsistent definition of PrivateWM_xxxUISTATE
#endif

#if UIS_SET        != PrivateUIS_SET        || \
    UIS_CLEAR      != PrivateUIS_CLEAR      || \
    UIS_INITIALIZE != PrivateUIS_INITIALIZE
#error Inconsistent definition of PrivateUIS_xxx
#endif

#if UISF_HIDEFOCUS != PrivateUISF_HIDEFOCUS || \
    UISF_HIDEACCEL != PrivateUISF_HIDEACCEL
#error Inconsistent definition of PrivateUISF_xxx
#endif

#else

#define SM_REMOTESESSION PrivateSM_REMOTESESSION

#define WM_CHANGEUISTATE        PrivateWM_CHANGEUISTATE
#define WM_UPDATEUISTATE        PrivateWM_UPDATEUISTATE
#define WM_QUERYUISTATE         PrivateWM_QUERYUISTATE      

#define UIS_SET                 PrivateUIS_SET              
#define UIS_CLEAR               PrivateUIS_CLEAR            
#define UIS_INITIALIZE          PrivateUIS_INITIALIZE       

#define UISF_HIDEFOCUS          PrivateUISF_HIDEFOCUS       
#define UISF_HIDEACCEL          PrivateUISF_HIDEACCEL       

#endif // WINVER >= 0x0500

STDAPI_(BOOL) MyGetLastWriteTime (LPCWSTR pszPath, FILETIME *pft);
STDAPI_(BOOL) NT5_ExpandEnvironmentStringsForUserW (HANDLE hToken, LPCWSTR lpSrc, LPWSTR lpDest, DWORD dwSize);
STDAPI_(BOOL) NT5_SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistance, PLARGE_INTEGER pliNewPos, DWORD dwMoveMethod);
STDAPI_(LONG) NT5_RegOpenCurrentUser(REGSAM sam, HKEY *phk);

STDAPI_(HANDLE) XP_CreateAndActivateContext(ULONG_PTR* pul);
STDAPI_(void) XP_DeactivateAndDestroyContext(HANDLE hActCtx, ULONG_PTR ul);


#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shelldrt\shelldrt.cpp ===
#include "stdafx.h"
#include "shelldrt.h"

// g_aTestDlls
//
// The array of tests that we are available to be run

vector<SHTESTDESCRIPTOR> g_aTests;
vector<HMODULE>          g_ahTestDlls;

// usage
//
// Displays program usage instructions.  Does NOT exit on its own.

void usage()
{
    _ftprintf(stderr, TEXT("\nSHELLDRT: Shell Developer Regression Tests\n")
                    TEXT("---------------------------------------------------------------------\n")
                    TEXT("Usage: SHELLDRT -h [[testdll1] ...]\n")
                    TEXT("\n")
                    TEXT("Where: -h           Help (this list)\n"));
}

// AddTestsFromDll
//
// Given the name of a test dll, loads it and queries it for the tests it contains,
// adding them to the mix.

bool AddTestsFromDll(LPCTSTR pszDllName)
{
    HMODULE hMod = LoadLibrary(pszDllName);
    if (!hMod)
        return false;
    
    g_ahTestDlls.push_back( hMod );
    
    SHTESTLISTPROC pfnListTests = (SHTESTLISTPROC) GetProcAddress(hMod, "ListTestProcs");
    if (!pfnListTests)
    {
        _ftprintf(stderr, TEXT("SHELLDRT: Test dll %s does not expose the ListTestProcs entry point.\n"), pszDllName);
        return false;
    }

    DWORD cTests = pfnListTests(NULL);
    if (!cTests)
    {
        _ftprintf(stderr, TEXT("SHELLDRT: Test dll %s exposes no tests.\n"), pszDllName);
        return false;
    }

    AutoPtr<SHTESTDESCRIPTOR> spDescriptors = new SHTESTDESCRIPTOR[cTests];

    if (cTests != pfnListTests(spDescriptors))
    {
        fprintf(stderr, "SHELLDRT: Test dll %s advertised %d tests but did not supply them all.\n", pszDllName, cTests);
        return false;
    }

    for (DWORD i = 0; i < cTests; i++)
        g_aTests.push_back(spDescriptors[i]);        

    return true;
}

// AddTestsFromLocalDir
//
// Looks in the current directory for test dlls and adds them to the array

void AddTestsFromLocalDir()
{
    WIN32_FIND_DATA finddata;
    AutoFindHandle spFindHandle;
    BOOL fHaveFile = TRUE;
    
    for (spFindHandle = FindFirstFile(TEXT("shdrt-*.dll"), &finddata); (INVALID_HANDLE_VALUE != spFindHandle) && fHaveFile;
        fHaveFile = FindNextFile(spFindHandle, &finddata))
    {
       if (!AddTestsFromDll(finddata.cFileName))
       {
            _ftprintf(stderr, TEXT("SHELLDRT: Cannot load test dll %s [Err: %08dX]\n"), finddata.cFileName, GetLastError());
            ExitProcess(0);
       }
    }
}

// RunTests
//
// Loops through the loaded tests and 

bool RunTests()
{
    for (DWORD i = 0; i < g_aTests.size(); i++)
    {
        _ftprintf(stdout,     TEXT("Starting Test : %s\n"), g_aTests[i]._pszTestName);
        if (g_aTests[i]._pfnTestProc())
        {
            _ftprintf(stdout, TEXT("Success       : %s\n"), g_aTests[i]._pszTestName);
        }
        else
        {
            _ftprintf(stderr, TEXT("** FAILURE ** : %s\n"), g_aTests[i]._pszTestName);
            return false;
        }
    }
    _ftprintf(stdout, TEXT("++ SUCCESS ++\n"));
    return true;
}

// main
//
// Program entry point
 
#ifdef UNICODE
extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
#else
int __cdecl main(int argc, char* argv[])
{
#endif
    LPTSTR p;

    argc--;
    argv++;

    while ( argc-- > 0 ) 
    {
        p  = *argv++;
        if ( *p == '-' || *p == '/' ) 
        {
            p++;
            switch ( tolower(*p) ) 
            {
                case 'h':
                    usage();
                    ExitProcess(0);

                default:
                    usage();
                    ExitProcess(0);
            }
        } 
        else 
        {
            if (!AddTestsFromDll(p))
            {
                _ftprintf(stderr, TEXT("SHELLDRT: Cannot load test dll %s [Err: %08dX]\n"), p, GetLastError());
                ExitProcess(0);
            }
        }
    }

    // If no tests were specified manually on the command line, look for
    // them in the current directory

    if (0 == g_aTests.size())
        AddTestsFromLocalDir();

    // If still no tests, there's nothing to do 

    if (0 == g_aTests.size())
    {
        _ftprintf(stderr, TEXT("SHELLDRT: No tests specified and none found in current directory.\n"));
        usage();
        ExitProcess(0);
    }
    
    return RunTests();
}
#ifdef UNICODE
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow shlwapi to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//


#include "priv.h"       // Don't use precompiled header here
#define _USERENV_       // Disable the declspec(dllimport)
#include <userenv.h>    // for ExpandEnvironmentStringsForUser

// the IsOS code is now centralized in shell\inc since shlwapi and those who cannot
// link to shlwapi.dll both need to include it.
#include <isos.c>


typedef BOOL (* PFNGFAXW) (LPCWSTR, GET_FILEEX_INFO_LEVELS, LPVOID );

STDAPI_(BOOL) MyGetLastWriteTime (LPCWSTR pszPath, FILETIME *pft)
{
    if (g_bRunningOnNT5OrHigher)
    {
        static PFNGFAXW s_pfn = NULL;
        WIN32_FILE_ATTRIBUTE_DATA fad;

        if (!s_pfn)
        {
            s_pfn = (PFNGFAXW) GetProcAddress(GetModuleHandle(TEXT("kernel32")), "GetFileAttributesExW");
        }

        ASSERT(s_pfn);
        
        if (s_pfn && s_pfn(pszPath, GetFileExInfoStandard, &fad))
        {
            *pft = fad.ftLastWriteTime;
            return TRUE;
        }
    }
    else
    {
        HANDLE hFile = CreateFileW(pszPath, GENERIC_READ, FILE_SHARE_READ,
                NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, 0);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            GetFileTime(hFile, NULL, NULL, pft);

            CloseHandle(hFile);
            return TRUE;
        }
    }
    return FALSE;
}

STDAPI_(BOOL) NT5_ExpandEnvironmentStringsForUserW (HANDLE hToken, LPCWSTR lpSrc, LPWSTR lpDest, DWORD dwSize)
{
    RIPMSG(g_bRunningOnNT5OrHigher, "Cannot invoke NT5_ExpandEnvironmentStringsForUserW when not on NT5 or higher");
    return(ExpandEnvironmentStringsForUserW(hToken, lpSrc, lpDest, dwSize));
}

typedef BOOL (* PFNSETFILEPOINTEREX) (HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD);

STDAPI_(BOOL) NT5_SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistance, PLARGE_INTEGER pliNewPos, DWORD dwMoveMethod)
{
    static PFNSETFILEPOINTEREX s_pfn = (PFNSETFILEPOINTEREX)-1;

    if (s_pfn == (PFNSETFILEPOINTEREX)-1)
    {
        s_pfn = (PFNSETFILEPOINTEREX) GetProcAddress(GetModuleHandle(TEXT("kernel32")), "SetFilePointerEx");
    }

    if (s_pfn)
    {
        return s_pfn(hFile, liDistance, pliNewPos, dwMoveMethod);
    }
    else
    {
        DWORD dwCurrent = SetFilePointer(hFile, liDistance.LowPart, NULL, dwMoveMethod);

        if (pliNewPos)
        {
            pliNewPos->LowPart = dwCurrent;
            pliNewPos->HighPart = 0;
        }

        // Because the high value is null, this return indicates failure.
        if (dwCurrent == INVALID_SET_FILE_POINTER)
        {
            return FALSE;
        }
    }

    return TRUE;
}

typedef LONG (* PFNREGOPENCURRENTUSER) (REGSAM, HKEY *);

STDAPI_(LONG) NT5_RegOpenCurrentUser(REGSAM sam, HKEY *phk)
{
    static PFNREGOPENCURRENTUSER s_pfn = (PFNREGOPENCURRENTUSER)-1;

    if (s_pfn == (PFNREGOPENCURRENTUSER)-1)
    {
        if (g_bRunningOnNT5OrHigher)
            s_pfn = (PFNREGOPENCURRENTUSER) GetProcAddress(GetModuleHandle(TEXT("advapi32")), "RegOpenCurrentUser");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
    {
        return s_pfn(sam, phk);
    }
    else
    {
        *phk = NULL;
        return ERROR_CAN_NOT_COMPLETE;
    }
}


typedef BOOL (__stdcall *PFNACTCTX)(HANDLE, ULONG_PTR *);
typedef BOOL (__stdcall *PFNDEACTCTX)(DWORD, ULONG_PTR );
typedef HANDLE (__stdcall *PFNCREATECTX)(ACTCTX*);
typedef void (__stdcall *PFNRELCTX)(HANDLE);

static PFNACTCTX s_pfnAct = (PFNACTCTX)-1;
static PFNDEACTCTX s_pfnDeact = (PFNDEACTCTX)-1;
static PFNCREATECTX s_pfnCreateact = (PFNCREATECTX)-1;
static PFNRELCTX s_pfnReleaseact = (PFNRELCTX)-1;

HANDLE XP_CreateActCtx(ACTCTX* p)
{
    if (s_pfnCreateact == (PFNCREATECTX)-1)
    {
#ifdef UNICODE
        s_pfnCreateact = (PFNCREATECTX)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "CreateActCtxW");
#else
        s_pfnCreateact = (PFNCREATECTX)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "CreateActCtxA");
#endif

    }

    if (s_pfnCreateact)
        return s_pfnCreateact(p);

    return NULL;
}

void XP_ReleaseActCtx(HANDLE h)
{
    if (s_pfnReleaseact == (PFNRELCTX)-1)
    {
        s_pfnReleaseact = (PFNRELCTX)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "ReleaseActCtx");
    }

    if (s_pfnReleaseact)
        s_pfnReleaseact(h);
}

BOOL XP_ActivateActCtx(HANDLE h, ULONG_PTR* p)
{
    if (s_pfnAct == (PFNACTCTX)-1)
    {
        s_pfnAct = (PFNACTCTX)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "ActivateActCtx");
    }

    *p = 0;

    if (s_pfnAct)
    {
        return s_pfnAct(h, p);
    }

    return TRUE;
}

BOOL XP_DeactivateActCtx(ULONG_PTR p)
{
    if (s_pfnDeact == (PFNDEACTCTX)-1)
    {
        s_pfnDeact = (PFNDEACTCTX)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "DeactivateActCtx");
    }

    if (s_pfnDeact && p)
        return s_pfnDeact(0, p);

    return TRUE;
}



STDAPI_(HANDLE) XP_CreateAndActivateContext(ULONG_PTR* pul)
{
    HANDLE hActCtx;
    ACTCTX act = {0};
    TCHAR szPath[MAX_PATH];

    GetModuleFileName(g_hinst, szPath, ARRAYSIZE(szPath));

    act.cbSize = sizeof(act);
    act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
    act.lpResourceName = MAKEINTRESOURCE(123);
    act.lpSource = szPath;

    hActCtx = XP_CreateActCtx(&act);

    if (hActCtx)
    {
        XP_ActivateActCtx(hActCtx, pul);
    }

    return hActCtx;

}

STDAPI_(void) XP_DeactivateAndDestroyContext(HANDLE hActCtx, ULONG_PTR ul)
{
    if (hActCtx != INVALID_HANDLE_VALUE)
    {
        if (ul != 0)
            XP_DeactivateActCtx(ul);

        XP_ReleaseActCtx(hActCtx);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shelldrt\shelldrt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File: shelldrt.h  -  Type and structure defs for shell drts
//
//--------------------------------------------------------------------------

#pragma once

// SHTESTPROC
//
// Function type of a shell drt

typedef BOOL (CALLBACK * SHTESTPROC)();

// SHTESTDESCRIPTOR
//
// Description, entry point, and option attributes for a shell drt

typedef struct
{
    DWORD        _cbSize;
    LPCTSTR      _pszTestName;
    SHTESTPROC   _pfnTestProc;
    DWORD        _dwAttribs;
} SHTESTDESCRIPTOR, * LPSHTESTDESCRIPTOR;

// SHTESTLISTPROC
//
// Each test dll exports this function, which describes the tests
// it contains (or returns just a count if the arg passed to is is null

typedef DWORD (CALLBACK * SHTESTLISTPROC)(LPSHTESTDESCRIPTOR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\assoc.h ===
//  assoc.h
HRESULT AssocCreateW2k(REFIID riid, LPVOID *ppvOut);
HRESULT AssocCreateElement(REFCLSID clsid, REFIID riid, void **ppv);

BOOL _PathAppend(PCWSTR pszBase, PCWSTR pszAppend, PWSTR pszOut, DWORD cchOut);
BOOL _PathIsFile(PCWSTR pszPath);
void _MakeAppPathKey(PCWSTR pszApp, PWSTR pszKey, DWORD cchKey);
void _MakeApplicationsKey(LPCWSTR pszApp, LPWSTR pszKey, DWORD cchKey);

HRESULT _AssocOpenRegKey(HKEY hk, PCWSTR pszSub, HKEY *phkOut, BOOL fCreate = FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\apithk.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\shlwapi\shlwapi.inc

NO_BROWSER_FILE = 1

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\shlwapi\shlwapi.inc

TARGETNAME      = apithk
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\apithk.c

# We don't use a precompiled header until there are enough files to
# merit it.
#PRECOMPILED_INCLUDE = ..\priv.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\color.c ===
#include "priv.h"

// Copied mostly from Desk.cpl.
#define  RANGE   240            // range of values for HLS scrollbars 
                                // HLS-RGB conversions work best when
                                // RANGE is divisible by 6 
#define  HLSMAX   RANGE
#define  RGBMAX   255
#define UNDEFINED (HLSMAX*2/3)  //Hue is undefined if Saturation is 0 (grey-scale)



//-------------------------------------------------------------------------
// ColorRGBToHLS
//
// Purpose: Convert RGB to HLS
//
// A point of reference for the algorithms is Foley and Van Dam, pp. 618-19.
// Their algorithm is in floating point.  CHART implements a less general
// (hardwired ranges) integral algorithm.


// There are potential roundoff errors lurking throughout here.
//   (0.5 + x/y) without floating point,
//      (x/y) phrased ((x + (y/2))/y)
//   yields very small roundoff error.
//   This makes many of the following divisions look funny.

// H,L, and S vary over 0-HLSMAX
// R,G, and B vary over 0-RGBMAX
// HLSMAX BEST IF DIVISIBLE BY 6
// RGBMAX, HLSMAX must each fit in a byte. 

STDAPI_(void) ColorRGBToHLS(COLORREF clrRGB, WORD* pwHue, WORD* pwLuminance, WORD* pwSaturation)
{
    int R,G,B;                /* input RGB values */
    WORD cMax,cMin;        /* max and min RGB values */
    WORD cSum,cDif;
    int  Rdelta,Gdelta,Bdelta;  /* intermediate value: % of spread from max */
    int H, L, S;

    /* get R, G, and B out of DWORD */
    R = GetRValue(clrRGB);
    G = GetGValue(clrRGB);
    B = GetBValue(clrRGB);

    /* calculate lightness */
    cMax = max( max(R,G), B);
    cMin = min( min(R,G), B);
    cSum = cMax + cMin;
    L = (WORD)(((cSum * (DWORD)HLSMAX) + RGBMAX )/(2*RGBMAX));

    cDif = cMax - cMin;
    if (!cDif)   	/* r=g=b --> achromatic case */
    {
        S = 0;                         /* saturation */
        H = UNDEFINED;                 /* hue */
    }
    else                           /* chromatic case */
    {
        /* saturation */
        if (L <= (HLSMAX/2))
            S = (WORD) (((cDif * (DWORD) HLSMAX) + (cSum / 2) ) / cSum);
        else
            S = (WORD) ((DWORD) ((cDif * (DWORD) HLSMAX) + (DWORD)((2*RGBMAX-cSum)/2) )
                                                 / (2*RGBMAX-cSum));
        /* hue */
        Rdelta = (int) (( ((cMax-R)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);
        Gdelta = (int) (( ((cMax-G)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);
        Bdelta = (int) (( ((cMax-B)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);

        if ((WORD) R == cMax)
            H = Bdelta - Gdelta;
        else if ((WORD) G == cMax)
            H = (HLSMAX/3) + Rdelta - Bdelta;
        else /* B == cMax */
            H = ((2*HLSMAX)/3) + Gdelta - Rdelta;

        if (H < 0)
            H += HLSMAX;
        if (H > HLSMAX)
            H -= HLSMAX;
    }

   ASSERT( pwHue && pwLuminance && pwSaturation );
   *pwHue = (WORD) H;
   *pwLuminance = (WORD) L;
   *pwSaturation = (WORD) S;
}


/* utility routine for HLStoRGB */
WORD HueToRGB(WORD n1, WORD n2, WORD hue)
{

   /* range check: note values passed add/subtract thirds of range */

   /* The following is redundant for WORD (unsigned int) */

   if (hue > HLSMAX)
      hue -= HLSMAX;

   /* return r,g, or b value from this tridrant */
   if (hue < (HLSMAX/6))
      return ( n1 + (((n2-n1)*hue+(HLSMAX/12))/(HLSMAX/6)) );
   if (hue < (HLSMAX/2))
      return ( n2 );
   if (hue < ((HLSMAX*2)/3))
      return ( n1 + (((n2-n1)*(((HLSMAX*2)/3)-hue)+(HLSMAX/12)) / (HLSMAX/6)) );
   else
      return ( n1 );
}


//-------------------------------------------------------------------------
// ColorHLSToRGB
//
// Purpose: Convert HLS to RGB

STDAPI_(COLORREF) ColorHLSToRGB(WORD wHue, WORD wLuminance, WORD wSaturation)
{
    WORD R,G,B;                      /* RGB component values */
    WORD  Magic1,Magic2;       /* calculated magic numbers (really!) */

    if (wSaturation == 0)                /* achromatic case */
    {
        R = G = B = (wLuminance * RGBMAX) / HLSMAX;
        if (wHue != UNDEFINED)
        {
            R = G = B = 0;
        }
    }
    else                         /* chromatic case */
    {
        /* set up magic numbers */
        if (wLuminance <= (HLSMAX/2))
          Magic2 = (WORD)((wLuminance * ((DWORD)HLSMAX + wSaturation) + (HLSMAX/2))/HLSMAX);
        else
          Magic2 = wLuminance + wSaturation - (WORD)(((wLuminance*wSaturation) + (DWORD)(HLSMAX/2))/HLSMAX);
        Magic1 = 2*wLuminance-Magic2;

        /* get RGB, change units from HLSMAX to RGBMAX */
        R = (WORD)((HueToRGB(Magic1,Magic2,(WORD)(wHue+(WORD)(HLSMAX/3)))*(DWORD)RGBMAX + (HLSMAX/2))) / (WORD)HLSMAX;
        G = (WORD)((HueToRGB(Magic1,Magic2,wHue)*(DWORD)RGBMAX + (HLSMAX/2))) / HLSMAX;
        B = (WORD)((HueToRGB(Magic1,Magic2,(WORD)(wHue-(WORD)(HLSMAX/3)))*(DWORD)RGBMAX + (HLSMAX/2))) / (WORD)HLSMAX;
    }

    return(RGB(R,G,B));
}


//-------------------------------------------------------------------------
// ColorAdjustLuma
//
// Purpose: Adjusts the luma of an RGB value

STDAPI_(COLORREF) ColorAdjustLuma(COLORREF clrRGB, int n, BOOL fScale)
{
    WORD H, L, S;

    if (n == 0)
        return clrRGB;

    ColorRGBToHLS(clrRGB, &H, &L, &S);

    if (fScale)
    {
        if (n > 0)
        {
            return ColorHLSToRGB((WORD)H, (WORD)(((long)L * (1000 - n) + (RANGE + 1l) * n) / 1000), (WORD)S);
        }
        else
        {
            return ColorHLSToRGB((WORD)H, (WORD)(((long)L * (n + 1000)) / 1000), (WORD)S);
        }
    }

    L += (int)((long)n * RANGE / 1000);

    if (L < 0)
        L = 0;
    if (L > HLSMAX)
        L = HLSMAX;

    return ColorHLSToRGB((WORD)H, (WORD)L, (WORD)S);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\datablok.cpp ===
#include "priv.h"
#include "stream.h"

#define _DBLNext(pdbList) ((LPDBLIST)(((LPBYTE)(pdbList)) + (pdbList)->cbSize ))
#define DBSIG_WRAP ((DWORD)-1)

STDAPI SHWriteDataBlockList(IStream* pstm, LPDBLIST pdbList)
{
    HRESULT hr = S_OK;

    if (pdbList)
    {
        for ( ; pdbList->cbSize; pdbList = _DBLNext(pdbList))
        {
            LPDATABLOCK_HEADER pdb;
            ULONG cbBytes;

            pdb = pdbList;
            if (DBSIG_WRAP == pdb->dwSignature)
                pdb++;

            TraceMsg(TF_DBLIST, "Writing extra data block, size:%x sig:%x", pdb->cbSize, pdb->dwSignature);
    
            if (FAILED(hr = ((CMemStream*)pstm)->Write((LPBYTE)pdb, pdb->cbSize, &cbBytes)))
                break;
    
            if (cbBytes != pdb->cbSize)
            {
                hr = STG_E_MEDIUMFULL;
                break;
            }
        }
    }

    // NULL terminate the list
    if (SUCCEEDED(hr))
    {
        DWORD dwData = 0;
        DWORD cbBytes;
        hr = ((CMemStream*)pstm)->Write(&dwData, sizeof(dwData), &cbBytes);
    }

    return(hr);
}

STDAPI SHReadDataBlockList(IStream* pstm, LPDBLIST * ppdbList)
{
    HRESULT hr;
    BYTE buf[200]; // all blocks today fit in this size (tested at 5)
    LPDATABLOCK_HEADER lpBuf = (LPDATABLOCK_HEADER)buf;
    DWORD cbBuf = sizeof(buf);
    DWORD dwSizeToRead, cbBytes;

    if (*ppdbList)
    {
        LocalFree((HLOCAL)(*ppdbList));
        *ppdbList = NULL;
    }

    while (TRUE)
    {
        DWORD cbSize;
        dwSizeToRead = sizeof(cbSize);
        hr = ((CMemStream*)pstm)->Read(&cbSize, dwSizeToRead, &cbBytes);
        if (SUCCEEDED(hr) && (cbBytes == dwSizeToRead))
        {

            // Windows 95 and NT 4 shipped a CShellLink that did NOT
            // NULL terminate the data it wrote out to the stream.
            // If more data was persisted after the CShellLink then
            // we will read in garbage. No real harm comes of this (*)
            // (because it is unlikely we'll get a dwSignature match)
            // but if the first dword is huge, we'll allocate a ton
            // of memory and page it in. This can take MINUTES on Win95.
            // Assume anything over 64K is from one of these
            // bogus streams.
            //
            // (*) actually, real harm comes because we don't leave the
            // stream in the correct place. Forms^3 put a work-around
            // in for this bug.
            //
            if (cbSize > 0x0000FFFF)
            {
                ULARGE_INTEGER liStart;
                LARGE_INTEGER liMove;

                // We read a DWORD of data that wasn't ours, back up.
                // NOTE: all of our stream implementations assume
                //       HighPart == 0
                //
                liMove.HighPart = liMove.LowPart = 0;
                if (SUCCEEDED(((CMemStream*)pstm)->Seek(liMove, STREAM_SEEK_CUR, &liStart)))
                {
                    ASSERT(liStart.HighPart == 0);
                    ASSERT(liStart.LowPart >= sizeof(cbSize));
                    liMove.LowPart = liStart.LowPart - sizeof(cbSize);

                    ((CMemStream*)pstm)->Seek(liMove, STREAM_SEEK_SET, NULL);
                }

                TraceMsg(TF_DBLIST, "ASSUMING NO NULL TERMINATION (FOR SIZE 0x%x)", cbSize);
                cbSize = 0;
            }

            // If we hit the 0 terminator, we're done.
            //
            if (cbSize < sizeof(DATABLOCK_HEADER))
                break;

            // Make sure we can read this block in.
            //
            if (cbSize > cbBuf)
            {
                HLOCAL pTemp;

                if (lpBuf == (LPDATABLOCK_HEADER)buf)
                    pTemp = LocalAlloc(LPTR, cbSize);
                else
                    pTemp = LocalReAlloc((HLOCAL)lpBuf, cbSize, LMEM_ZEROINIT | LMEM_MOVEABLE);

                if (pTemp)
                {
                    lpBuf = (LPDATABLOCK_HEADER)pTemp;
                    cbBuf = cbSize;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }

            // Read in data block
            //
            lpBuf->cbSize = cbSize;
            dwSizeToRead = cbSize - sizeof(cbSize);
            hr = ((CMemStream*)pstm)->Read((LPBYTE)&(lpBuf->dwSignature), dwSizeToRead, &cbBytes);
            if (SUCCEEDED(hr) && (cbBytes == dwSizeToRead))
            {
                TraceMsg(TF_DBLIST, "Reading extra data block, size:%x sig:%x", lpBuf->cbSize, lpBuf->dwSignature);

                SHAddDataBlock(ppdbList, lpBuf);
            }
            else
                break;
        }
        else
            break;
    }

    // Free any allocated buffer
    //
    if (lpBuf != (LPDATABLOCK_HEADER)buf)
    {
        LocalFree((HLOCAL)lpBuf);
    }

    return hr;
}

STDAPI_(void) SHFreeDataBlockList(LPDBLIST pdbList)
{
    if (pdbList)
    {
        LocalFree((HLOCAL)pdbList);
    }
}

STDAPI_(BOOL) SHAddDataBlock(LPDBLIST * ppdbList, LPDATABLOCK_HEADER pdb)
{
    LPDBLIST pdbCopyTo = NULL;
    DWORD dwSize;

    // Don't let anyone use our special signature
    //
    if (DBSIG_WRAP == pdb->dwSignature ||
        pdb->cbSize < sizeof(*pdb))
    {
        TraceMsg(TF_DBLIST, "SHAddDataBlock invalid datablock! (sig:%x size:%x)", pdb->dwSignature, pdb->cbSize);
        return FALSE;
    }

    // Figure out how much space we need to hold this block
    //
    dwSize = pdb->cbSize;
    if (pdb->cbSize & 0x3)
    {
        dwSize = ((dwSize + 3) & ~0x3) + sizeof(DATABLOCK_HEADER);

        TraceMsg(TF_DBLIST, "Adding non-DWORD data block, size:%x sig:%x", pdb->cbSize, pdb->dwSignature);
    }
    else
    {
        TraceMsg(TF_DBLIST, "Adding data block, size:%x sig:%x", pdb->cbSize, pdb->dwSignature);
    }

    // Allocate the space
    //
    if (!*ppdbList)
    {
        *ppdbList = (LPDBLIST)LocalAlloc(LPTR, dwSize + sizeof(DWORD)); // include NULL terminator
        pdbCopyTo = *ppdbList;
    }
    else
    {
        DWORD dwTotalSize = 0;
        LPDBLIST pdbList;
        HLOCAL lpTmp;

        for (pdbList = *ppdbList ; pdbList->cbSize ; pdbList = _DBLNext(pdbList))
            dwTotalSize += pdbList->cbSize;

        lpTmp = LocalReAlloc((HLOCAL)*ppdbList, dwTotalSize + dwSize + sizeof(DWORD), // include NULL terminator
                             LMEM_ZEROINIT | LMEM_MOVEABLE);
        if (lpTmp)
        {
            *ppdbList = (LPDBLIST)lpTmp;
            pdbCopyTo = (LPDBLIST)(((LPBYTE)lpTmp) + dwTotalSize);
        }
    }

    // Copy the data block
    //
    if (pdbCopyTo)
    {
        LPBYTE pTmp = (LPBYTE)pdbCopyTo;

        // This block would cause other blocks to be
        // unaligned, wrap it
        //
        ASSERT(0 == (dwSize & 0x3));
        if (dwSize != pdb->cbSize)
        {
            pdbCopyTo->cbSize = dwSize;
            pdbCopyTo->dwSignature = DBSIG_WRAP;
            pTmp = (LPBYTE)(pdbCopyTo + 1);
        }
        CopyMemory(pTmp, pdb, pdb->cbSize);

        // NULL terminate the list
        _DBLNext(pdbCopyTo)->cbSize = 0;

        return TRUE;
    }

    return FALSE;
}

STDAPI_(BOOL) SHRemoveDataBlock(LPDBLIST * ppdbList, DWORD dwSignature)
{
    LPDBLIST pdbRemove = NULL;

    // Can't call SHFindDataBlock because that returnes the
    // block that was wrapped, we want the block that wraps.
    //
    if (*ppdbList)
    {
        LPDBLIST pdbList = *ppdbList;

        for ( ; pdbList->cbSize ; pdbList = _DBLNext(pdbList))
        {
            if (dwSignature == pdbList->dwSignature)
            {
                TraceMsg(TF_DBLIST, "Removing data block, size:%x sig:%x ptr:%x", pdbList->cbSize, pdbList->dwSignature, pdbList);
                pdbRemove = pdbList;
                break;
            }
            else if (DBSIG_WRAP == pdbList->dwSignature)
            {
                LPDBLIST pdbWrap = pdbList + 1;
                if (dwSignature == pdbWrap->dwSignature)
                {
                    TraceMsg(TF_DBLIST, "Removing non-DWORD data block, size:%x sig:%x ptr:", pdbWrap->cbSize, pdbWrap->dwSignature, pdbWrap);
                    pdbRemove = pdbList;
                    break;
                }
            }
        }
    }

    if (pdbRemove)
    {
        LPDBLIST pdbNext = _DBLNext(pdbRemove);
        LPDBLIST pdbEnd;
        DWORD dwSizeOfBlockToRemove;
        LONG lNewSize;

        for (pdbEnd = pdbNext ; pdbEnd->cbSize ; pdbEnd = _DBLNext(pdbEnd))
            ;

        dwSizeOfBlockToRemove = pdbRemove->cbSize;

        // Move remaining memory down
        MoveMemory(pdbRemove, pdbNext, (DWORD_PTR)pdbEnd - (DWORD_PTR)pdbNext + sizeof(DWORD));

        // Shrink our buffer
        lNewSize = (LONG) LocalSize(*ppdbList ) - dwSizeOfBlockToRemove;
        if (lNewSize > sizeof(DWORD))
        {
            void *lpVoid = LocalReAlloc( (HLOCAL)*ppdbList, lNewSize, LMEM_ZEROINIT | LMEM_MOVEABLE );
            if (NULL != lpVoid)
            {
                *ppdbList = (LPDBLIST)lpVoid;
            }
        }
        else
        {
            // We've removed the last section, delete the whole deal
            LocalFree( (HLOCAL)(*ppdbList) );
            *ppdbList = NULL;

        }

        return TRUE;
    }

    return FALSE;
}

STDAPI_(void *) SHFindDataBlock(LPDBLIST pdbList, DWORD dwSignature)
{
    if (pdbList)
    {
        for ( ; pdbList->cbSize ; pdbList = _DBLNext(pdbList))
        {
            if (dwSignature == pdbList->dwSignature)
            {
                TraceMsg(TF_DBLIST, "Found data block, size:%x sig:%x ptr:%x", pdbList->cbSize, pdbList->dwSignature, pdbList);

                return (void *)pdbList;
            }
            else if (DBSIG_WRAP == pdbList->dwSignature)
            {
                LPDBLIST pdbWrap = pdbList + 1;
                if (dwSignature == pdbWrap->dwSignature)
                {
                    TraceMsg(TF_DBLIST, "Found non-DWORD data block, size:%x sig:%x ptr:%x", pdbWrap->cbSize, pdbWrap->dwSignature, pdbWrap);

                    return (void *)pdbWrap;
                }
            }
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\connect.cpp ===
//
// IConnectionPoint/IDispatch helper functions
//
#include "priv.h"
#include <shlobj.h>

//
//  IDispatch helper functions

//
//  Takes a variable number of parameters for IDispatch, packages
//  them up.
//
//  pdispparams  - The DISPPARAMS structure that receives the result
//                 of the packaging.
//
//  rgvarg       - Array of length cArgs.
//                 It will be used to hold the parameters.
//
//  cArgs        - Number of pairs of generic arguments.
//
//  ap           - va_list of parameters to package.  We package up the
//                 first (2 * cArgs) of them.  See SHPackDispParams
//                 for details.

typedef struct FAKEBSTR {
    ULONG cb;
    WCHAR wsz[1];
} FAKEBSTR;

const FAKEBSTR c_bstrNULL = { 0, L"" };

LWSTDAPI SHPackDispParamsV(DISPPARAMS *pdispparams, VARIANTARG *rgvarg, UINT cArgs, va_list ap)
{
    HRESULT hr = S_OK;

    ZeroMemory(rgvarg, cArgs * SIZEOF(VARIANTARG));

    // fill out DISPPARAMS structure
    pdispparams->rgvarg = rgvarg;
    pdispparams->rgdispidNamedArgs = NULL;
    pdispparams->cArgs = cArgs;
    pdispparams->cNamedArgs = 0;

    // parameters are ordered in ap with the right-most parameter
    // at index zero and the left-most parameter at the highest index; essentially,
    // the parameters are pushed from right to left.  Put the first argument we
    // encounter at the highest index.

    // pVarArg points to the argument structure in the array we are currently
    // filling in.  Initialize this to point at highest argument (zero-based,
    // hence the -1).  For each passed-in argument we process, *decrement*
    // the pVarArg pointer to achieve the "push from right-to-left" effect.
    VARIANTARG * pVarArg = &rgvarg[cArgs - 1];

    int nCount = cArgs;
    while (nCount) 
    {
        VARENUM vaType = va_arg(ap,VARENUM);

        // We don't have to call VariantInit because we zerod out
        // the entire array before entering this loop

        V_VT(pVarArg) = vaType;

        // the next field is a union, so we can be smart about filling it in
        //
        if (vaType & VT_BYREF)
        {
            // All byrefs can be packed the same way
            V_BYREF(pVarArg) = va_arg(ap, LPVOID);
        }
        else
        {
            switch (vaType)
            {
            case VT_BSTR:
            {
                // parameter is a BSTR
                // MFC doesn't like it when you pass NULL for a VT_BSTR type
                V_BSTR(pVarArg) = va_arg(ap, BSTR);
                if (V_BSTR(pVarArg) == NULL)
                    V_BSTR(pVarArg) =(BSTR)c_bstrNULL.wsz;
#ifdef DEBUG
                // Check if this BSTR is a valid BSTR
                FAKEBSTR *bstr = CONTAINING_RECORD(V_BSTR(pVarArg), FAKEBSTR, wsz);
                ASSERT(bstr->cb == lstrlenW(bstr->wsz) * SIZEOF(WCHAR));
#endif
                break;
            }
    
            case VT_BOOL:
                V_BOOL(pVarArg) = va_arg(ap, VARIANT_BOOL);
                break;

            case VT_DISPATCH:
                V_DISPATCH(pVarArg) = va_arg(ap, LPDISPATCH);
                break;

            case VT_UNKNOWN:
                V_UNKNOWN(pVarArg) = va_arg(ap, LPUNKNOWN);
                break;

            default:
                AssertMsg(0, TEXT("Packing unknown variant type 0x%x as VT_I4"), vaType);
                // if we don't know what it is treat it as VT_I4.
                // Hopefully it's not a pointer or a VT_R8 or that sort of
                // thing, or we're in trouble.
                V_VT(pVarArg) = VT_I4;

            case VT_I4:
                V_I4(pVarArg) = va_arg(ap, LONG);
                break;

            } 
        }

        nCount--;
        pVarArg--;
    }

    return hr;
}

//
//  Takes a variable number of generic parameters, packages
//  them up.
//
//  pdispparams  - The DISPPARAMS structure that receives the result
//                 of the packaging.
//
//  rgvarg       - Array of length cArgs.
//                 It will be used to hold the parameters.
//
//  cArgs        - Number of pairs of generic arguments (below).
//
//  ...          - A collection of (VARNUM, LPVOID) pairs of arguments.
//                 The first is the type of the argument, and the
//                 second is the corresponding value.
//
//                 As a special case, a null VT_BSTR can be passed
//                 as a NULL pointer and we will turn it into a
//                 genuine null BSTR.
//
//  The following VARENUMs are supported:
//
//      VT_BYREF        - Anything that is VT_BYREF is okay
//      VT_BSTR
//      VT_BOOL
//      VT_DISPATCH
//      VT_UNKNOWN
//      VT_I4
//
//  Any other type will be packaged randomly, so don't do that.
//
//  Example:
//
//      DISPPARAMS dispparams;
//      VARIANTARG args[4];                     // room for 4 parameters
//      SHPackDispParams(&dispparams, args, 4,  // and here they are
//                       VT_BSTR,   bstrURL,
//                       VT_I4,     dwFlags,
//                       VT_BSTR,   NULL,       // no post data
//                       VT_BSTR,   bstrHeaders);
//

LWSTDAPI SHPackDispParams(DISPPARAMS *pdispparams, VARIANTARG *rgvarg, UINT cArgs, ...)
{
    va_list ap;
    va_start(ap, cArgs);

    HRESULT hr = SHPackDispParamsV(pdispparams, rgvarg, cArgs, ap);

    va_end(ap);
    return hr;
}

//=============================================================================
//
//  IConnectionPoint helper functions


//-----------------------------------------------------------------------------
//
//  INVOKECALLBACK
//
//  Allows clients to customize the the invoke process.  The callback
//  receives the following parameters:
//
//  pdisp       - The IDispatch that is about to receive an invoke.
//
//  pinv        - SHINVOKEPARAMS structure that describes the invoke
//                that is about to occur.
//
//  The callback function is called before each sink is dispatched.
//  The callback can return any of the following values:
//
//  S_OK          Proceed with the invoke
//  S_FALSE       Skip this invoke but keep invoking others
//  E_FAIL        Stop invoking
//
//  A client can do lazy-evaluation of dispatch arguments by installing
//  a callback that sets up the dispatch arguments on the first callback.
//
//  A client can support a "Cancel" flag by returning E_FAIL once the
//  cancel has occurred.
//
//  A client can pre-validate an IDispatch for compatibility reasons
//  and either touch up the arguments and return S_OK, or decide that
//  the IDispatch should be skipped and return S_FALSE.
//
//  A client can append custom information to the end of the SHINVOKEPARAMS
//  structure to allow it to determine additional context.
//
//  A client can do post-invoke goo by doing work on the pre-invoke
//  of the subsequent callback (plus one final bout of work when the
//  entire enumeration completes).
//

//
//  Obtaining a connection point sink is supposed to be easy.  You just
//  QI for the interface.  Unfortunately, too many components are buggy.
//
//  mmc.exe faults if you QI for IDispatch
//  and punkCB is non-NULL.  And if you do pass in NULL,
//  it returns S_OK but fills punkCB with NULL anyway.
//  Somebody must've had a rough day.
//
//  Java responds only to its dispatch ID and not IID_IDispatch, even
//  though the dispatch ID is derived from IID_IDispatch.
//
//  The Explorer Band responds only to IID_IDispatch and not to
//  the dispatch ID.
//

HRESULT GetConnectionPointSink(IUnknown *pUnk, const IID *piidCB, IUnknown **ppunkCB)
{
    HRESULT hr = E_NOINTERFACE;
    *ppunkCB = NULL;                // Pre-zero it to work around MMC
    if (piidCB)                     // Optional interface (Java/ExplBand)
    {                   
        hr = pUnk->QueryInterface(*piidCB, (void **) ppunkCB);
        if (*ppunkCB == NULL)       // Clean up behind MMC
            hr = E_NOINTERFACE;
    }
    return hr;
}


//
//  Enumerate the connection point sinks, calling the callback for each one
//  found.
//
//  The callback function is called once for each sink.  The IUnknown is
//  whatever interface we could get from the sink (either piidCB or piidCB2).
//

typedef HRESULT (CALLBACK *ENUMCONNECTIONPOINTSPROC)(
    /* [in, iid_is(*piidCB)] */ IUnknown *psink, LPARAM lParam);

HRESULT EnumConnectionPointSinks(
    IConnectionPoint *pcp,              // IConnectionPoint victim
    const IID *piidCB,                  // Interface for callback
    const IID *piidCB2,                 // Alternate interface for callback
    ENUMCONNECTIONPOINTSPROC EnumProc,  // Callback procedure
    LPARAM lParam)                      // Refdata for callback
{
    HRESULT hr;
    IEnumConnections * pec;

    if (pcp)
        hr = pcp->EnumConnections(&pec);
    else
        hr = E_NOINTERFACE;

    if (SUCCEEDED(hr))
    {
        CONNECTDATA cd;
        ULONG cFetched;

        while (S_OK == (hr = pec->Next(1, &cd, &cFetched)))
        {
            IUnknown *punkCB;

            ASSERT(1 == cFetched);

            hr = GetConnectionPointSink(cd.pUnk, piidCB, &punkCB);
            if (FAILED(hr))
                hr = GetConnectionPointSink(cd.pUnk, piidCB2, &punkCB);

            if (EVAL(SUCCEEDED(hr)))
            {
                hr = EnumProc(punkCB, lParam);
                punkCB->Release();
            }
            else
            {
                hr = S_OK;      // Pretend callback succeeded
            }
            cd.pUnk->Release();
            if (FAILED(hr)) break; // Callback asked to stop
        }
        pec->Release();
        hr = S_OK;
    }

    return hr;
}

//
//  Send out the callback (if applicable) and then do the invoke if the
//  callback said that was a good idea.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be Invoke()d.
//                      If this parameter is NULL, the function does nothing.
//      pinv         -  Structure containing parameters to INVOKE.

HRESULT CALLBACK EnumInvokeCallback(IUnknown *psink, LPARAM lParam)
{
    IDispatch *pdisp = (IDispatch *)psink;
    LPSHINVOKEPARAMS pinv = (LPSHINVOKEPARAMS)lParam;
    HRESULT hr;

    if (pinv->Callback)
    {
        // Now see if the callback wants to do pre-vet the pdisp.
        // It can return S_FALSE to skip this callback or E_FAIL to
        // stop the invoke altogether
        hr = pinv->Callback(pdisp, pinv);
        if (hr != S_OK) return hr;
    }

    pdisp->Invoke(pinv->dispidMember, *pinv->piid, pinv->lcid,
                  pinv->wFlags, pinv->pdispparams, pinv->pvarResult,
                  pinv->pexcepinfo, pinv->puArgErr);

    return S_OK;
}

//
//  IConnectionPoint_InvokeIndirect
//
//  Given a connection point, call the IDispatch::Invoke for each
//  connected sink.
//
//  The return value merely indicates whether the command was dispatched.
//  If any particular sink fails the IDispatch::Invoke, we will still
//  return S_OK, since the command was indeed dispatched.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be Invoke()d.
//                      If this parameter is NULL, the function does nothing.
//      pinv         -  Structure containing parameters to INVOKE.
//                      The pdispparams field can be NULL; we will turn it
//                      into a real DISPPARAMS for you.
//
//  The SHINVOKEPARAMS.flags field can contain the following flags.
//
//      IPFL_USECALLBACK    - The callback field contains a callback function
//                            Otherwise, it will be set to NULL.
//      IPFL_USEDEFAULT     - Many fields in the SHINVOKEPARAMS will be set to
//                            default values to save the caller effort:
//
//                  riid            =   IID_NULL
//                  lcid            =   0
//                  wFlags          =   DISPATCH_METHOD
//                  pvarResult      =   NULL
//                  pexcepinfo      =   NULL
//                  puArgErr        =   NULL
//

LWSTDAPI IConnectionPoint_InvokeIndirect(
    IConnectionPoint *pcp,
    SHINVOKEPARAMS *pinv)
{
    HRESULT hr;
    DISPPARAMS dp = { 0 };
    IID iidCP;

    if (pinv->pdispparams == NULL)
        pinv->pdispparams = &dp;

    if (!(pinv->flags & IPFL_USECALLBACK))
    {
        pinv->Callback = NULL;
    }

    if (pinv->flags & IPFL_USEDEFAULTS)
    {
        pinv->piid            =  &IID_NULL;
        pinv->lcid            =   0;
        pinv->wFlags          =   DISPATCH_METHOD;
        pinv->pvarResult      =   NULL;
        pinv->pexcepinfo      =   NULL;
        pinv->puArgErr        =   NULL;
    }

    // Try both the interface they actually connected on,
    // as well as IDispatch.  Apparently Java responds only to
    // the connecting interface, and ExplBand responds only to
    // IDispatch, so we have to try both.  (Sigh.  Too many buggy
    // components in the system.)

    hr = EnumConnectionPointSinks(pcp,
                                  (pcp->GetConnectionInterface(&iidCP) == S_OK) ? &iidCP : NULL,
                                  &IID_IDispatch,
                                  EnumInvokeCallback,
                                  (LPARAM)pinv);

    // Put the original NULL back so the caller can re-use the SHINVOKEPARAMS.
    if (pinv->pdispparams == &dp)
        pinv->pdispparams = NULL;

    return hr;
}

//
//  Wrapper around IConnectionPoint_InvokeIndirect with special Cancel
//  semantics.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be Invoke()d.
//                      If this parameter is NULL, the function does nothing.
//      dispid       -  The DISPID to invoke
//      pdispparams  -  The DISPPARAMS for the invoke
//      pfCancel     -  Optional BOOL to cancel the invoke
//      ppvCancel    -  Optional LPVOID to cancel the invoke
//
//  If either *pfCancel or *ppvCancel is nonzero/non-NULL, we stop the invoke
//  process.  This allows a sink to "handle" the event and prevent other
//  sinks from receiving it.  The ppvCancel parameter is for dispid's which
//  are queries that are asking for somebody to create an object and return it.
//
//  It is the caller's responsibility to check the values of *pfCancel
//  and/or *ppvCancel to determine if the operation was cancelled.
//

typedef struct INVOKEWITHCANCEL {
    SHINVOKEPARAMS inv;
    LPBOOL pfCancel;
    void **ppvCancel;
} INVOKEWITHCANCEL;

HRESULT CALLBACK InvokeWithCancelProc(IDispatch *psink, SHINVOKEPARAMS *pinv)
{
    INVOKEWITHCANCEL *piwc = CONTAINING_RECORD(pinv, INVOKEWITHCANCEL, inv);

    if ((piwc->pfCancel && *piwc->pfCancel) ||
        (piwc->ppvCancel && *piwc->ppvCancel))
        return E_FAIL;

    return S_OK;
}

LWSTDAPI IConnectionPoint_InvokeWithCancel(
    IConnectionPoint *pcp,
    DISPID dispidMember,
    DISPPARAMS * pdispparams,
    LPBOOL pfCancel,
    void **ppvCancel)
{
    INVOKEWITHCANCEL iwc;

    iwc.inv.flags = IPFL_USECALLBACK | IPFL_USEDEFAULTS;
    iwc.inv.dispidMember = dispidMember;
    iwc.inv.pdispparams = pdispparams;
    iwc.inv.Callback = InvokeWithCancelProc;
    iwc.pfCancel = pfCancel;
    iwc.ppvCancel = ppvCancel;

    return IConnectionPoint_InvokeIndirect(pcp, &iwc.inv);
}

//
//  Wrapper around IConnectionPoint_InvokeIndirect with IPFL_USEDEFAULTS.
//

LWSTDAPI IConnectionPoint_SimpleInvoke(IConnectionPoint *pcp, DISPID dispidMember, DISPPARAMS *pdispparams)
{
    SHINVOKEPARAMS inv;

    inv.flags = IPFL_USEDEFAULTS;
    inv.dispidMember = dispidMember;
    inv.pdispparams = pdispparams;

    return IConnectionPoint_InvokeIndirect(pcp, &inv);
}

//
//  Takes a variable number of parameters for IDispatch, packages
//  them up, and invokes them.
//
//  The parameters to the IDispatch::Invoke will be
//
//      dispidMember    -   dispidMember
//      riid            -   IID_NULL
//      lcid            -   0
//      wFlags          -   DISPATCH_METHOD
//      pdispparams     -   <parameters to this function>
//      pvarResult      -   NULL
//      pexcepinfo      -   NULL
//      puArgErr        -   NULL
//
//  The parameters to this function are
//
//  pcp          - IConnectionPoint whose sinks should be Invoke()d.
//                 If this parameter is NULL, the function does nothing.
//  dispidMember - The DISPID to invoke.
//  rgvarg       - Array of length cArgs.
//                 It will be used to hold the parameters.
//  cArgs        - Number of pairs of generic arguments (below).
//
//  ap           - va_list of parameters to package.  We package up the
//                 first (2 * cArgs) of them.  See SHPackDispParams
//                 for details.
//

LWSTDAPI IConnectionPoint_InvokeParamV(IConnectionPoint *pcp, DISPID dispidMember, 
                                       VARIANTARG *rgvarg, UINT cArgs, va_list ap)
{
    HRESULT hr;

    if (pcp)
    {
        DISPPARAMS dp;
        hr = SHPackDispParamsV(&dp, rgvarg, cArgs, ap);
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = IConnectionPoint_SimpleInvoke(pcp, dispidMember, &dp);
        }
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}

//
//  Worker function for many classes of IConnectionPoint_Invoke
//  clients.  Just pass the parameters and we'll pack them up for you.
//
//  The parameters to the IDispatch::Invoke will be
//
//      dispidMember    -   dispidMember
//      riid            -   IID_NULL
//      lcid            -   0
//      wFlags          -   DISPATCH_METHOD
//      pdispparams     -   <parameters to this function>
//      pvarResult      -   NULL
//      pexcepinfo      -   NULL
//      puArgErr        -   NULL
//
//  The parameters to this function are
//
//  pcp          - IConnectionPoint whose sinks should be Invoke()d.
//                 If this parameter is NULL, the function does nothing.
//
//  dispidMember - The DISPID to invoke.
//
//  rgvarg       - Array of length cArgs.
//                 It will be used to hold the parameters.
//
//  cArgs        - Number of pairs of generic arguments (below).
//
//  ...          - A collection of (VARENUM, blah) pairs of arguments.
//                 See SHPackDispParams for details.
//
//  Example:
//
//      VARIANTARG args[1];
//      IConnectionPoint_InvokeParam(pcp, DISPID_PROPERTYCHANGE,
//                                   args, 1,
//                                   VT_BSTR, bstrProperty);

LWSTDAPIV IConnectionPoint_InvokeParam(IConnectionPoint *pcp, DISPID dispidMember, 
                                       VARIANTARG *rgvarg, UINT cArgs, ...)
{
    HRESULT hr;
    va_list ap;

    va_start(ap, cArgs);

    hr = IConnectionPoint_InvokeParamV(pcp, dispidMember, rgvarg, cArgs, ap);

    va_end(ap);

    return hr;
}

//
//  Given a connection point that represents IPropertyNotifySink,
//  call the IPropertyNotifySink::OnChanged for each connected sink.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be notified.
//                      If this parameter is NULL, the function does nothing.
//      dispid       -  To pass to IPropertyNotifySink::OnChanged.

HRESULT CALLBACK OnChangedCallback(IUnknown *psink, LPARAM lParam)
{
    IPropertyNotifySink *pns = (IPropertyNotifySink *)psink;
    DISPID dispid = (DISPID)lParam;

    pns->OnChanged(dispid);

    return S_OK;
}

LWSTDAPI IConnectionPoint_OnChanged(IConnectionPoint *pcp, DISPID dispid)
{
#ifdef DEBUG
    // Make sure it really is an IPropertyNotifySink connection point.
    if (pcp)
    {
        IID iid;
        HRESULT hr = pcp->GetConnectionInterface(&iid);
        ASSERT(SUCCEEDED(hr) && iid == IID_IPropertyNotifySink);
    }
#endif
    return EnumConnectionPointSinks(pcp, &IID_IPropertyNotifySink, NULL,
                                    OnChangedCallback, (LPARAM)dispid);
}

//=============================================================================
//
//  IConnectionPointContainer helper functions

//
//  QI's for IConnectionPointContainer and then does the FindConnectionPoint.
//
//  Parameters:
//
//      punk         -  The object who might be an IConnectionPointContainer.
//                      This parameter may be NULL, in which case the
//                      operation fails.
//      riidCP       -  The connection point interface to locate.
//      pcpOut       -  Receives the IConnectionPoint, if any.

LWSTDAPI IUnknown_FindConnectionPoint(IUnknown *punk, REFIID riidCP, 
                                      IConnectionPoint **pcpOut)
{
    HRESULT hr;

    *pcpOut = NULL;

    if (punk)
    {
        IConnectionPointContainer *pcpc;
        hr = punk->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpc);
        if (SUCCEEDED(hr))
        {
            hr = pcpc->FindConnectionPoint(riidCP, pcpOut);
            pcpc->Release();
        }
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}

//
//  Given an IUnknown, query for its connection point container,
//  find the corresponding connection point, package up the
//  invoke parameters, and call the IDispatch::Invoke for each
//  connected sink.
//
//  See IConnectionPoint_InvokeParam for additional semantics.
//
//  Parameters:
//
//      punk         -  Object that might be an IConnectionPointContainer
//      riidCP       -  ConnectionPoint interface to request
//      pinv         -  Arguments for the Invoke.
//

LWSTDAPI IUnknown_CPContainerInvokeIndirect(IUnknown *punk, REFIID riidCP,
                SHINVOKEPARAMS *pinv)
{
    IConnectionPoint *pcp;
    HRESULT hr = IUnknown_FindConnectionPoint(punk, riidCP, &pcp);
    if (SUCCEEDED(hr))
    {
        hr = IConnectionPoint_InvokeIndirect(pcp, pinv);
        pcp->Release();
    }
    return hr;
}

//
//  This is the ultimate in one-stop shopping.
//
//  Given an IUnknown, query for its connection point container,
//  find the corresponding connection point, package up the
//  invoke parameters, and call the IDispatch::Invoke for each
//  connected sink.
//
//  See IConnectionPoint_InvokeParam for additional semantics.
//
//  Parameters:
//
//      punk         -  Object that might be an IConnectionPointContainer
//      riidCP       -  ConnectionPoint interface to request
//      dispidMember -  The DISPID to invoke.
//      rgvarg       -  Array of length cArgs.
//                      It will be used to hold the parameters.
//      cArgs        -  Number of pairs of generic arguments (below).
//      ...          -  A collection of (VARNUM, LPVOID) pairs of arguments.
//                      See SHPackDispParams for details.
//
//  Example:
//
//      IUnknown_CPContainerInvokeParam(punk, DIID_DShellFolderViewEvents,
//                                      DISPID_SELECTIONCHANGED, NULL, 0);

LWSTDAPIV IUnknown_CPContainerInvokeParam(
    IUnknown *punk, REFIID riidCP,
    DISPID dispidMember, VARIANTARG *rgvarg, UINT cArgs, ...)
{
    IConnectionPoint *pcp;
    HRESULT hr = IUnknown_FindConnectionPoint(punk, riidCP, &pcp);

    if (SUCCEEDED(hr))
    {
        va_list ap;
        va_start(ap, cArgs);
        hr = IConnectionPoint_InvokeParamV(pcp, dispidMember, rgvarg, cArgs, ap);
        va_end(ap);
        pcp->Release();
    }

    return hr;
}

//
//  Given an IUnknown, query for its connection point container,
//  find the corresponding connection point, and call the
//  IPropertyNotifySink::OnChanged for each connected sink.
//
//  Parameters:
//
//      punk         -  Object that might be an IConnectionPointContainer
//      dispid       -  To pass to IPropertyNotifySink::OnChanged.

LWSTDAPI IUnknown_CPContainerOnChanged(IUnknown *punk, DISPID dispid)
{
    IConnectionPoint *pcp;
    HRESULT hr = IUnknown_FindConnectionPoint(punk, IID_IPropertyNotifySink, &pcp);
    if (SUCCEEDED(hr))
    {
        hr = IConnectionPoint_OnChanged(pcp, dispid);
        pcp->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\assocapi.cpp ===
//
//
//  assocapi.cpp
//
//     Association APIs
//
//
//


#include "priv.h"
#include "apithk.h"
#include <shstr.h>

#ifdef _X86_
#include <w95wraps.h>
#endif

#include <msi.h>
#include "assoc.h"
#include <filetype.h>

BOOL _PathAppend(LPCTSTR pszBase, LPCTSTR pszAppend, LPTSTR pszOut, DWORD cchOut);
void _MakeAppPathKey(LPCTSTR pszApp, LPTSTR pszKey, DWORD cchKey)
{
    if (_PathAppend(REGSTR_PATH_APPPATHS, pszApp, pszKey, cchKey))
    {
        // Currently we will only look up .EXE if an extension is not
        // specified
        if (*PathFindExtension(pszApp) == 0)
        {
            StrCatBuff(pszKey, TEXT(".exe"), cchKey);
        }
    }
}

void _MakeApplicationsKey(LPCWSTR pszApp, LPWSTR pszKey, DWORD cchKey)
{
    if (_PathAppend(TEXT("Applications"), pszApp, pszKey, cchKey))
    {
        // Currently we will only look up .EXE if an extension is not
        // specified
        if (*PathFindExtension(pszApp) == 0)
        {
            StrCatBuff(pszKey, TEXT(".exe"), cchKey);
        }
    }
}

HRESULT _AssocOpenRegKey(HKEY hk, LPCTSTR pszSub, HKEY *phkOut, BOOL fCreate)
{
    ASSERT(phkOut);
    *phkOut = NULL;
    if (!hk)
        return HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
        
    DWORD err;
    if (!fCreate)
        err = RegOpenKeyEx(hk, pszSub, 0, MAXIMUM_ALLOWED, phkOut);
    else
        err = RegCreateKeyEx(hk, pszSub, 0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, phkOut, NULL);

    if (ERROR_SUCCESS != err)
    {
        ASSERT(!*phkOut);
        return HRESULT_FROM_WIN32(err);
    }
    return S_OK;
}
        
LWSTDAPI AssocCreate(CLSID clsid, REFIID riid, LPVOID *ppvOut)
{
    HRESULT hr = E_INVALIDARG;

    if (ppvOut)
    {
        if (IsEqualGUID(clsid, CLSID_QueryAssociations) 
             || IsEqualGUID(clsid, IID_IQueryAssociations))
        {
            if (IsOS(OS_WHISTLERORGREATER))
                hr = SHCoCreateInstance(NULL, &CLSID_QueryAssociations, NULL, riid, ppvOut);
            else
            {
                hr = AssocCreateW2k(riid, ppvOut);
            }
        }
        else
            hr = AssocCreateElement(clsid, riid, ppvOut);
    }
    return hr;
}

#define ASSOCF_INIT_ALL      (ASSOCF_INIT_BYEXENAME | ASSOCF_INIT_DEFAULTTOFOLDER | ASSOCF_INIT_DEFAULTTOSTAR | ASSOCF_INIT_NOREMAPCLSID)

LWSTDAPI AssocQueryStringW(ASSOCF flags, ASSOCSTR str, LPCWSTR pszAssoc, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut)
{
    IQueryAssociations *passoc;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (LPVOID *)&passoc);
    if (SUCCEEDED(hr))
    {
        hr = passoc->Init(flags & ASSOCF_INIT_ALL, pszAssoc, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = passoc->GetString(flags, str, pszExtra, pszOut, pcchOut);

        passoc->Release();
    }
    return hr;
}

LWSTDAPI AssocQueryStringA(ASSOCF flags, ASSOCSTR str, LPCSTR pszAssoc, LPCSTR pszExtra, LPSTR pszOut, DWORD *pcchOut)
{
    if (!pcchOut)
        return E_INVALIDARG;
        
    HRESULT hr = E_OUTOFMEMORY;
    SHSTRW strAssoc, strExtra;

    if (SUCCEEDED(strAssoc.SetStr(pszAssoc))
    &&  SUCCEEDED(strExtra.SetStr(pszExtra)))
    {
        SHSTRW strOut;
        DWORD cchIn = IS_INTRESOURCE(pcchOut) ? PtrToUlong(pcchOut) : *pcchOut;
        DWORD cch;
        LPTSTR pszTemp = NULL;

        if (pszOut)
        {
            strOut.SetSize(cchIn);
            cch = strOut.GetSize();
            pszTemp = strOut.GetInplaceStr();            
        }

        hr = AssocQueryStringW(flags, str, strAssoc, strExtra, pszTemp, &cch);

        if (SUCCEEDED(hr))
        {
            cch = SHUnicodeToAnsi(strOut, pszOut, cchIn);

            if (!IS_INTRESOURCE(pcchOut))
                *pcchOut = cch;
        }
    }

    return hr;
}

LWSTDAPI AssocQueryStringByKeyW(ASSOCF flags, ASSOCSTR str, HKEY hkAssoc, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut)
{
    IQueryAssociations *passoc;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (LPVOID *)&passoc);
    if (SUCCEEDED(hr))
    {
        hr = passoc->Init(flags & ASSOCF_INIT_ALL, NULL, hkAssoc, NULL);

        if (SUCCEEDED(hr))
            hr = passoc->GetString(flags, str, pszExtra, pszOut, pcchOut);

        passoc->Release();
    }

    return hr;
}

LWSTDAPI AssocQueryStringByKeyA(ASSOCF flags, ASSOCSTR str, HKEY hkAssoc, LPCSTR pszExtra, LPSTR pszOut, DWORD *pcchOut)
{
    if (!pcchOut)
        return E_INVALIDARG;
        
    HRESULT hr = E_OUTOFMEMORY;
    SHSTRW strExtra;

    if (SUCCEEDED(strExtra.SetStr(pszExtra)))
    {
        SHSTRW strOut;
        DWORD cchIn = IS_INTRESOURCE(pcchOut) ? PtrToUlong(pcchOut) : *pcchOut;
        DWORD cch;
        LPWSTR pszTemp = NULL;

        if (pszOut)
        {
            strOut.SetSize(cchIn);
            cch = strOut.GetSize();
            pszTemp = strOut.GetInplaceStr();            
        }

        hr = AssocQueryStringByKeyW(flags, str, hkAssoc, strExtra, pszTemp, &cch);

        if (SUCCEEDED(hr))
        {
            cch = SHUnicodeToAnsi(strOut, pszOut, cchIn);

            if (!IS_INTRESOURCE(pcchOut))
                *pcchOut = cch;
        }
    }

    return hr;
}

LWSTDAPI AssocQueryKeyW(ASSOCF flags, ASSOCKEY key, LPCWSTR pszAssoc, LPCWSTR pszExtra, HKEY *phkey)
{
    IQueryAssociations *passoc;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (LPVOID *)&passoc);
    if (SUCCEEDED(hr))
    {
        hr = passoc->Init(flags & ASSOCF_INIT_ALL, pszAssoc, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = passoc->GetKey(flags, key, pszExtra, phkey);

        passoc->Release();
    }

    return hr;
}

LWSTDAPI AssocQueryKeyA(ASSOCF flags, ASSOCKEY key, LPCSTR pszAssoc, LPCSTR pszExtra, HKEY *phkey)
{
        
    HRESULT hr = E_OUTOFMEMORY;
    SHSTRW strAssoc, strExtra;

    if (SUCCEEDED(strAssoc.SetStr(pszAssoc))
    &&  SUCCEEDED(strExtra.SetStr(pszExtra)))
    {
        hr = AssocQueryKeyW(flags, key, strAssoc, strExtra, phkey);

    }

    return hr;
}

#define ISQUOTED(s)   (TEXT('"') == *(s) && TEXT('"') == *((s) + lstrlen(s) - 1))

BOOL _TrySubst(SHSTR& str, LPCTSTR psz)
{
    BOOL fRet = FALSE;
    TCHAR szVar[MAX_PATH];
    DWORD cch = GetEnvironmentVariable(psz, szVar, SIZECHARS(szVar));

    if (cch && cch <= SIZECHARS(szVar))
    {
        if (0 == StrCmpNI(str, szVar, cch))
        {
            //  we got a match. 
            //  size the buffer for the env var... +3 = (% + % + \0)
            SHSTR strT;
            if (S_OK == strT.SetStr(str.GetStr() + cch)                
                && S_OK == str.SetSize(str.GetLen() - cch + lstrlen(psz) + 3)

               )
            {
                wnsprintf(str.GetInplaceStr(), str.GetSize(), TEXT("%%%s%%%s"), psz, strT.GetStr());
                fRet = TRUE;
            }
        }
    }
    return fRet;
}
    
BOOL _TryEnvSubst(SHSTR& str)
{
    static LPCTSTR rgszEnv[] = {
        TEXT("USERPROFILE"),
        TEXT("ProgramFiles"),
        TEXT("SystemRoot"),
        TEXT("SystemDrive"),
        TEXT("windir"),
        NULL
    };

    LPCTSTR *ppsz = rgszEnv;
    BOOL fRet = FALSE;

    while (*ppsz && !fRet)
    {
        fRet = _TrySubst(str, *ppsz++);
    }

    return fRet;
}

HRESULT _MakeCommandString(ASSOCF *pflags, LPCTSTR pszExe, LPCTSTR pszArgs, SHSTR& str)
{
    SHSTR strArgs;
    HRESULT hr;
    
    if (!pszArgs || !*pszArgs)
    {
        //  default to just passing the 
        //  file name right in.
        //  NOTE 16bit apps might have a problem with
        //  this, but i request that the caller
        //  specify that this is the case....
        pszArgs = TEXT("\"%1\"");
    }
    //  else NO _ParseCommand()

    hr = str.SetStr(pszExe);

    if (S_OK == hr)
    {
        //  check for quotes before doing env subst
        BOOL fNeedQuotes = (!ISQUOTED(str.GetStr()) && PathIsLFNFileSpec(str));
        
        //  this will put environment vars into the string...
        if ((*pflags & ASSOCMAKEF_SUBSTENV) && _TryEnvSubst(str))
        {
            *pflags |= ASSOCMAKEF_USEEXPAND;
        }

        str.Trim();

        if (fNeedQuotes)
        {
            //  3 = " + " + \0
            if (S_OK == str.SetSize(str.GetLen() + 3))
                PathQuoteSpaces(str.GetInplaceStr());
        }

        hr = str.Append(TEXT(' '));

        if (S_OK == hr)
        {
            hr = str.Append(pszArgs);
        }
    }

    return hr;
}
        
HRESULT _AssocMakeCommand(ASSOCMAKEF flags, HKEY hkVerb, LPCWSTR pszExe, LPCWSTR pszArgs)
{                    
    ASSERT(hkVerb && pszExe);
    SHSTR str;
    HRESULT hr = _MakeCommandString(&flags, pszExe, pszArgs, str);

    if (S_OK == hr)
    {
        DWORD dw = (flags & ASSOCMAKEF_USEEXPAND) ? REG_EXPAND_SZ : REG_SZ;

        DWORD err = SHSetValue(hkVerb, TEXT("command"), NULL, dw, (LPVOID) str.GetStr(), CbFromCch(str.GetLen() +1));

        hr = HRESULT_FROM_WIN32(err);
    }

    return hr;
}

LWSTDAPI AssocMakeShell(ASSOCMAKEF flags, HKEY hkProgid, LPCWSTR pszApplication, ASSOCSHELL *pShell)
{
    HRESULT hr = E_INVALIDARG;

    if (hkProgid && pszApplication && pShell)
    {
        for (DWORD c = 0; c < pShell->cVerbs; c++)
        {
            ASSOCVERB *pverb = &pShell->rgVerbs[c];

            if (pverb->pszVerb)
            {
                TCHAR szVerbKey[MAX_PATH];
                HKEY hkVerb;
                
                _PathAppend(TEXT("shell"), pverb->pszVerb, szVerbKey, SIZECHARS(szVerbKey));
                
                if (c == pShell->iDefaultVerb) 
                    SHSetValue(hkProgid, TEXT("shell"), NULL, REG_SZ, pverb->pszVerb, CbFromCch(lstrlen(pverb->pszVerb) +1));

                //  ASSOCMAKEF_FAILIFEXIST check if its ok to overwrite
                if (SUCCEEDED(_AssocOpenRegKey(hkProgid, szVerbKey, &hkVerb, FALSE)))
                {
                    RegCloseKey(hkVerb);
                    SHDeleteKey(hkProgid, szVerbKey);
                }

                if (SUCCEEDED(_AssocOpenRegKey(hkProgid, szVerbKey, &hkVerb, TRUE)))
                {
                    if (pverb->pszTitle)
                        SHSetValue(hkVerb, NULL, NULL, REG_SZ, pverb->pszTitle, CbFromCch(lstrlen(pverb->pszTitle) +1));

                    hr = _AssocMakeCommand(flags, hkVerb, pverb->pszApplication ? pverb->pszApplication : pszApplication , pverb->pszParams);

                    // if (SUCCEEDED(hr) && pverb->pDDEExec)
                    //    hr = _AssocMakeDDEExec(flags, hkVerb, pverb->pDDEExec);

                    RegCloseKey(hkVerb);
                }
            }
        }
    }
    return hr;
}

HRESULT _OpenClasses(HKEY *phkOut)
{
    *phkOut = NULL;

    DWORD err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\classes"), 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, phkOut, NULL);
    if (err)
        err = RegCreateKeyEx(HKEY_CURRENT_USER, TEXT("Software\\classes"), 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, phkOut, NULL);

    return HRESULT_FROM_WIN32(err);
}

LWSTDAPI AssocMakeProgid(ASSOCMAKEF flags, LPCWSTR pszApplication, ASSOCPROGID *pProgid, HKEY *phkProgid)
{
    HRESULT hr = E_INVALIDARG;

    if (pszApplication 
    && pProgid 
    && pProgid->cbSize >= sizeof(ASSOCPROGID) 
    && pProgid->pszProgid 
    && *pProgid->pszProgid)
    {
        HKEY hkRoot;
        if ((!(flags & ASSOCMAKEF_VERIFY)  || PathFileExists(pszApplication))
        && SUCCEEDED(_OpenClasses(&hkRoot)))
        {
            HKEY hkProgid;
            //  need to add support for ASSOCMAKEF_VOLATILE...
            hr = _AssocOpenRegKey(hkRoot, pProgid->pszProgid, &hkProgid, TRUE);

            if (SUCCEEDED(hr))
            {
                if (pProgid->pszFriendlyDocName)
                    SHSetValue(hkProgid, NULL, NULL, REG_SZ, pProgid->pszFriendlyDocName, CbFromCch(lstrlen(pProgid->pszFriendlyDocName) +1));

                if (pProgid->pszDefaultIcon)
                    SHSetValue(hkProgid, TEXT("DefaultIcon"), NULL, REG_SZ, pProgid->pszDefaultIcon, CbFromCch(lstrlen(pProgid->pszDefaultIcon) +1));

                if (pProgid->pShellKey)
                    hr = AssocMakeShell(flags, hkProgid, pszApplication, pProgid->pShellKey);

                if (SUCCEEDED(hr) && pProgid->pszExtensions)
                {
                    LPCTSTR psz = pProgid->pszExtensions;
                    DWORD err = NOERROR;
                    while (*psz && NOERROR == err)
                    {
                        err = SHSetValue(hkRoot, psz, NULL, REG_SZ, pProgid->pszProgid, CbFromCch(lstrlen(pProgid->pszProgid) + 1));
                        psz += lstrlen(psz) + 1;
                    }

                    if (NOERROR != err)
                        HRESULT_FROM_WIN32(err);
                }

                if (SUCCEEDED(hr) && phkProgid)
                    *phkProgid = hkProgid;
                else
                    RegCloseKey(hkProgid);
            }

            RegCloseKey(hkRoot);
        }
    }

    return hr;
}

HRESULT _AssocCopyVerb(HKEY hkSrc, HKEY hkDst, LPCTSTR pszVerb)
{
    HRESULT hr = S_OK;
    TCHAR szKey[MAX_PATH];
    HKEY hkVerb;
    DWORD dwDisp;

    //  only copy the verb component
    wnsprintf(szKey, SIZECHARS(szKey), TEXT("shell\\%s"), pszVerb);

    RegCreateKeyEx(hkDst, szKey, 0, NULL, 0,
        MAXIMUM_ALLOWED, NULL, &hkVerb, &dwDisp);

    //  create a failure state here...
    if (hkVerb)
    {
        //  we avoid overwriting old keys by checking the dwDisp
        if ((dwDisp == REG_CREATED_NEW_KEY) && SHCopyKey(hkSrc, pszVerb, hkVerb, 0L))
            hr = E_UNEXPECTED;

        RegCloseKey(hkVerb);
    }

    return hr;
}

typedef BOOL (*PFNALLOWVERB)(LPCWSTR psz, LPARAM param);

LWSTDAPI _AssocCopyVerbs(HKEY hkSrc, HKEY hkDst, PFNALLOWVERB pfnAllow, LPARAM lParam)
{
    HRESULT hr = E_INVALIDARG;
    HKEY hkEnum;
    
    if (SUCCEEDED(_AssocOpenRegKey(hkSrc, TEXT("shell"), &hkEnum, FALSE)))
    {
        TCHAR szVerb[MAX_PATH];
        DWORD cchVerb = SIZECHARS(szVerb);

        for (DWORD i = 0
            ; (NOERROR == RegEnumKeyEx(hkEnum, i, szVerb, &cchVerb, NULL, NULL, NULL, NULL))
            ; (cchVerb = SIZECHARS(szVerb)), i++)
        {
            if (!pfnAllow || pfnAllow(szVerb, lParam))
                hr = _AssocCopyVerb(hkEnum, hkDst, szVerb);
        }

        //  switch to cbVerb here
        cchVerb = sizeof(szVerb);
        if (NOERROR == SHGetValue(hkEnum, NULL, NULL, NULL, szVerb, &cchVerb))
        {
            SHSetValue(hkDst, TEXT("shell"), NULL, REG_SZ, szVerb, cchVerb);
        }
        
        RegCloseKey(hkEnum);
    }

    return hr;
}

LWSTDAPI AssocCopyVerbs(HKEY hkSrc, HKEY hkDst)
{
    return _AssocCopyVerbs(hkSrc, hkDst, NULL, NULL);
}

BOOL _IsMSIPerUserInstall(IQueryAssociations *pqa, ASSOCF flags, LPCWSTR pszVerb)
{
    WCHAR sz[MAX_PATH];
    DWORD cb = sizeof(sz);
    
    if (SUCCEEDED(pqa->GetData(flags, ASSOCDATA_MSIDESCRIPTOR, pszVerb, sz, &cb)))
    {
        WCHAR szOut[3];  // bit enough for "1" or "0"
        cb = SIZECHARS(szOut);
        
        if (NOERROR == MsiGetProductInfoW(sz, INSTALLPROPERTY_ASSIGNMENTTYPE, szOut, &cb))
        {
            //  The string "1" for the value represents machine installations, 
            //  while "0" represents user installations.

            if (0 == StrCmpW(szOut, L"0"))
                return TRUE;
        }

    }

    return FALSE;
}
    
typedef struct {
    IQueryAssociations *pqa;
    ASSOCF Qflags;
    LPCWSTR pszExe;
    BOOL fAllowPerUser;
} QUERYEXECB;

BOOL _AllowExeVerb(LPCWSTR pszVerb, QUERYEXECB *pqcb)
{
    BOOL fRet = FALSE;
    WCHAR sz[MAX_PATH];
    if (SUCCEEDED(pqcb->pqa->GetString(pqcb->Qflags, ASSOCSTR_EXECUTABLE, pszVerb,
        sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
    {
        if (0 == StrCmpIW(PathFindFileNameW(sz), pqcb->pszExe))
        {
            // 
            //  EXEs match so we should copy this verb.
            //  but we need to block per-user installs by darwin being added to the 
            //  applications key, since other users wont be able to use them
            //
            if (_IsMSIPerUserInstall(pqcb->pqa, pqcb->Qflags, pszVerb))
                fRet = pqcb->fAllowPerUser;
            else
                fRet = TRUE;
        }
    }
    //  todo  mask off DARWIN per-user installs

    return fRet;
}

HRESULT _AssocCreateAppKey(LPCWSTR pszExe, BOOL fPerUser, HKEY *phk)
{
    WCHAR szKey[MAX_PATH];
    wnsprintf(szKey, SIZECHARS(szKey), L"software\\classes\\applications\\%s", pszExe);

    if (*PathFindExtension(pszExe) == 0)
    {
        StrCatBuff(szKey, TEXT(".exe"), SIZECHARS(szKey));
    }

    return _AssocOpenRegKey((IsOS(OS_NT) && fPerUser) ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE, szKey, phk, TRUE);
}

LWSTDAPI AssocMakeApplicationByKeyW(ASSOCMAKEF flags, HKEY hkSrc, LPCWSTR pszVerb)
{
    WCHAR szPath[MAX_PATH];
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
    ASSOCF Qflags = (flags & ASSOCMAKEF_VERIFY) ? ASSOCF_VERIFY : 0;
    IQueryAssociations *pqa;
    AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (LPVOID *)&pqa);

    if (!pqa)
        return E_OUTOFMEMORY;

    if (SUCCEEDED(pqa->Init(0, NULL, hkSrc, NULL)))
    {
        
        if (SUCCEEDED(pqa->GetString(Qflags, ASSOCSTR_EXECUTABLE, pszVerb, 
            szPath, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szPath))))
            && (0 != StrCmpW(szPath, TEXT("%1"))))
        {
            LPCWSTR pszExe = PathFindFileNameW(szPath);
            BOOL fPerUser = _IsMSIPerUserInstall(pqa, Qflags, pszVerb);
            HKEY hkDst;
            
            ASSERT(pszExe && *pszExe);
            //  we have an exe to use

            //  check to see if this Application already has
            //  this verb installed
            DWORD cch;
            hr = AssocQueryString(Qflags | ASSOCF_OPEN_BYEXENAME, ASSOCSTR_COMMAND, pszExe,
                pszVerb, NULL, &cch);

            if (FAILED(hr) && SUCCEEDED(_AssocCreateAppKey(pszExe, fPerUser, &hkDst)))
            {
                QUERYEXECB qcb = {pqa, Qflags, pszExe, fPerUser};
                
                if (pszVerb)
                {
                    if (_AllowExeVerb(pszVerb, &qcb))
                    {
                        HKEY hkSrcVerbs;
    
                        if (SUCCEEDED(_AssocOpenRegKey(hkSrc, TEXT("shell"), &hkSrcVerbs, FALSE)))
                        {
                            hr = _AssocCopyVerb(hkSrcVerbs, hkDst, pszVerb);
                            RegCloseKey(hkSrcVerbs);
                        }
                        else
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                }
                else
                {
                    hr = _AssocCopyVerbs(hkSrc, hkDst, (PFNALLOWVERB)_AllowExeVerb, (LPARAM)&qcb);
                }

                RegCloseKey(hkDst);
            }
            
            //  init the friendly name for later
            if ((flags & ASSOCMAKEF_VERIFY) && SUCCEEDED(hr))
            {
                AssocQueryString(ASSOCF_OPEN_BYEXENAME | Qflags, ASSOCSTR_FRIENDLYAPPNAME, 
                    pszExe, NULL, NULL, &cch);
            }
        }

        pqa->Release();
    }
    
    return hr;
}

LWSTDAPI AssocMakeApplicationByKeyA(ASSOCMAKEF flags, HKEY hkAssoc, LPCSTR pszVerb)
{
    // convert pszVerb to wide char but preserve difference
    // between NULL and "" for AssocMakeApplicationByKeyW

    if (! pszVerb)
        return AssocMakeApplicationByKeyW(flags, hkAssoc, NULL);

    SHSTRW strVerb;
    HRESULT hr = strVerb.SetStr(pszVerb);

    if (SUCCEEDED(hr))
        hr = AssocMakeApplicationByKeyW(flags, hkAssoc, strVerb);

    return hr;
}

// This list needs to continue to be updated and we should try to keep parity with Office
const LPCTSTR c_arszUnsafeExts[]  =
{
    TEXT(".ade"), TEXT(".adp"), TEXT(".asp"), TEXT(".bas"), TEXT(".bat"), TEXT(".chm"), 
    TEXT(".cmd"), TEXT(".com"), TEXT(".cpl"), TEXT(".crt"), TEXT(".exe"), TEXT(".hlp"), 
    TEXT(".hta"), TEXT(".inf"), TEXT(".ins"), TEXT(".isp"), TEXT(".its"), TEXT(".js"),  
    TEXT(".jse"), TEXT(".lnk"), TEXT(".mdb"), TEXT(".mde"), TEXT(".mdt"), TEXT(".mdw"), 
    TEXT(".msc"), TEXT(".msi"), TEXT(".msp"), TEXT(".mst"), TEXT(".pcd"), TEXT(".pif"), 
    TEXT(".reg"), TEXT(".scr"), TEXT(".sct"), TEXT(".shb"), TEXT(".shs"), TEXT(".tmp"),
    TEXT(".url"), TEXT(".vb"),  TEXT(".vbe"), TEXT(".vbs"), TEXT(".vsd"), TEXT(".vsmacros"),          
    TEXT(".vss"), TEXT(".vst"), TEXT(".vsw"), TEXT(".ws"),  TEXT(".wsc"), TEXT(".wsf"), TEXT(".wsh"), 
};

typedef BOOL (*PFNSAFERIISEXECUTABLEFILETYPE)(LPCWSTR szFullPathname, BOOLEAN bFromShellExecute);

LWSTDAPI_(BOOL) AssocIsDangerous(PCWSTR pszType)
{
#ifdef DEBUG
    //  make sure our sort is good.
    static BOOL fCheckedUnsafe = FALSE;
    if (!fCheckedUnsafe)
    {
        for (int i = 1; i < ARRAYSIZE(c_arszUnsafeExts); i++)
        {
            ASSERT(0 > StrCmpIW(c_arszUnsafeExts[i-1], c_arszUnsafeExts[i]));
        }
        fCheckedUnsafe = TRUE;
    }
#endif // DEBUG    

    BOOL fDangerous = IsTypeInList(pszType, c_arszUnsafeExts, ARRAYSIZE(c_arszUnsafeExts));
    if (!fDangerous && pszType)
    {
        IQueryAssociations *passoc;
        HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &passoc));
        if (SUCCEEDED(hr))
        {
            hr = passoc->Init(NULL, pszType, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                DWORD dwEditFlags;
                ULONG cb = sizeof(dwEditFlags);
                hr = passoc->GetData(NULL, ASSOCDATA_EDITFLAGS, NULL, &dwEditFlags, &cb);
                if (SUCCEEDED(hr))
                {
                    fDangerous = dwEditFlags & FTA_AlwaysUnsafe;
                }
            }
            passoc->Release();
        }

        if (!fDangerous && IsOS(OS_WHISTLERORGREATER) && *pszType)
        {
            HMODULE hmod = LoadLibrary(TEXT("advapi32.dll"));
            if (hmod)
            {
                PFNSAFERIISEXECUTABLEFILETYPE pfnSaferiIsExecutableFileType = 
                    (PFNSAFERIISEXECUTABLEFILETYPE)GetProcAddress(hmod, "SaferiIsExecutableFileType");
                if (pfnSaferiIsExecutableFileType)
                    fDangerous = pfnSaferiIsExecutableFileType(pszType, TRUE);
                FreeLibrary(hmod);
            }
        }
    }

    return fDangerous;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\assocw2k.cpp ===
//
//
//  assocapi.cpp
//
//     Association APIs
//
//
//


#include "priv.h"
#include "apithk.h"
#include <shstr.h>
#include <w95wraps.h>
#include <msi.h>
#include "ids.h"
#include "assoc.h"

#define ISEXTENSION(psz)   (TEXT('.') == *(psz))
#define ISGUID(psz)        (TEXT('{') == *(psz))

inline BOOL IsEmptyStr(SHSTR &str)
{
    return (!*(LPCTSTR)str);
}
        
HRESULT _AssocGetRegString(HKEY hk, LPCTSTR pszSub, LPCTSTR pszVal, SHSTR &strOut)
{
    if (!hk)
    {
        return HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
    }

    DWORD cbOut = CbFromCch(strOut.GetSize());
    DWORD err = SHGetValue(hk, pszSub, pszVal, NULL, strOut.GetInplaceStr(), &cbOut);

    if (err == ERROR_SUCCESS)
        return S_OK;

    // else try to resize the buffer
    if (cbOut > CbFromCch(strOut.GetSize()))
    {
        strOut.SetSize(cbOut / sizeof(TCHAR));
        err = SHGetValue(hk, pszSub, pszVal, NULL, strOut.GetInplaceStr(), &cbOut);
    }

    return HRESULT_FROM_WIN32(err);
}

HRESULT _AssocGetRegUIString(HKEY hk, LPCTSTR pszSub, LPCTSTR pszVal, SHSTR &strOut)
{
    if (!hk)
        return HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);

    HKEY hkSub;
    DWORD err;
    HRESULT hres;

    err = RegOpenKeyEx(hk, pszSub, 0, MAXIMUM_ALLOWED, &hkSub);
    if (err == ERROR_SUCCESS)
    {
        // Unfortunately, SHLoadRegUIString doesn't have a way to query the
        // buffer size, so we just have to assume INFOTIPSIZE is good enough.
        LPTSTR pszOut = strOut.GetModifyableStr(INFOTIPSIZE);
        if (pszOut == NULL)
            pszOut = strOut.GetInplaceStr();

        hres = SHLoadRegUIString(hkSub, pszVal, pszOut, strOut.GetSize());
        RegCloseKey(hkSub);
    }
    else
    {
        hres = HRESULT_FROM_WIN32(err);
    }

    return hres;

}

HRESULT _AssocGetRegData(HKEY hk, LPCTSTR pszSubKey, LPCTSTR pszValue, LPDWORD pdwType, LPBYTE pbOut, LPDWORD pcbOut)
{
    if (!hk)
        return HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
    
    DWORD err;

    if (pszSubKey || pbOut || pcbOut || pdwType)
        err = SHGetValue(hk, pszSubKey, pszValue, pdwType, pbOut, pcbOut);
    else
        err = RegQueryValueEx(hk, pszValue, NULL, NULL, NULL, NULL);
        
    return HRESULT_FROM_WIN32(err);
}


BOOL _GetAppPath(LPCTSTR pszApp, SHSTR& strPath)
{
    TCHAR sz[MAX_PATH];
    _MakeAppPathKey(pszApp, sz, SIZECHARS(sz));

    return SUCCEEDED(_AssocGetRegString(HKEY_LOCAL_MACHINE, sz, NULL, strPath));
}



//
//  THE NEW WAY!
//

class CAssocW2k : public IQueryAssociations
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();

    // IQueryAssociations methods
    STDMETHODIMP Init(ASSOCF flags, LPCTSTR pszAssoc, HKEY hkProgid, HWND hwnd);
    STDMETHODIMP GetString(ASSOCF flags, ASSOCSTR str, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut);
    STDMETHODIMP GetKey(ASSOCF flags, ASSOCKEY, LPCWSTR pszExtra, HKEY *phkeyOut);
    STDMETHODIMP GetData(ASSOCF flags, ASSOCDATA data, LPCWSTR pszExtra, LPVOID pvOut, DWORD *pcbOut);
    STDMETHODIMP GetEnum(ASSOCF flags, ASSOCENUM assocenum, LPCWSTR pszExtra, REFIID riid, LPVOID *ppvOut);

    CAssocW2k();



protected:
    virtual ~CAssocW2k();

    //  static methods
    static HRESULT _CopyOut(BOOL fNoTruncate, SHSTR& str, LPTSTR psz, DWORD *pcch);
    static void _DefaultShellVerb(HKEY hk, LPTSTR pszVerb, DWORD cchVerb, HKEY *phkOut);

    typedef enum {
        KEYCACHE_INVALID = 0,
        KEYCACHE_HKCU    = 1,
        KEYCACHE_HKLM,
        KEYCACHE_APP,
        KEYCACHE_FIXED,
        PSZCACHE_BASE,
        PSZCACHE_HKCU    = PSZCACHE_BASE + KEYCACHE_HKCU,
        PSZCACHE_HKLM,
        PSZCACHE_APP,
        PSZCACHE_FIXED,
    } KEYCACHETYPE;

    typedef struct {
        LPTSTR pszCache;
        HKEY hkCache;
        LPTSTR psz;
        KEYCACHETYPE type;
    } KEYCACHE;
    
    static BOOL _CanUseCache(KEYCACHE &kc, LPCTSTR psz, KEYCACHETYPE type);
    static void _CacheFree(KEYCACHE &kc);
    static void _CacheKey(KEYCACHE &kc, HKEY hkCache, LPCTSTR pszName, KEYCACHETYPE type);
    static void _CacheString(KEYCACHE &kc, LPCTSTR pszCache, LPCTSTR pszName, KEYCACHETYPE type);

    void _Reset(void);

    BOOL _UseBaseClass(void);
    //
    //  retrieve the appropriate cached keys
    //
    HKEY _RootKey(BOOL fForceLM);
    HKEY _AppKey(LPCTSTR pszApp, BOOL fCreate = FALSE);
    HKEY _ExtensionKey(BOOL fForceLM);
    HKEY _OpenProgidKey(LPCTSTR pszProgid);
    HKEY _ProgidKey(BOOL fDefaultToExtension);
    HKEY _UserProgidKey(void);
    HKEY _ClassKey(BOOL fForceLM);
    HKEY _ShellVerbKey(HKEY hkey, KEYCACHETYPE type, LPCTSTR pszVerb);
    HKEY _ShellVerbKey(BOOL fForceLM, LPCTSTR pszVerb);
    HKEY _ShellNewKey(HKEY hkExt);
    HKEY _ShellNewKey(BOOL fForceLM);
    HKEY _DDEKey(BOOL fForceLM, LPCTSTR pszVerb);

    //
    //  actual worker routines
    //
    HRESULT _GetCommandString(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut);
    HRESULT _ParseCommand(ASSOCF flags, LPCTSTR pszCommand, SHSTR& strExe, PSHSTR pstrArgs);
    HRESULT _GetExeString(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut);
    HRESULT _GetFriendlyAppByVerb(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut);
    HRESULT _GetFriendlyAppByApp(LPCTSTR pszApp, ASSOCF flags, SHSTR& strOut);
    HRESULT _GetFriendlyAppString(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut);
    HRESULT _GetTipString(LPCWSTR pwszValueName, BOOL fForceLM, SHSTR& strOut);
    HRESULT _GetInfoTipString(BOOL fForceLM, SHSTR& strOut);
    HRESULT _GetQuickTipString(BOOL fForceLM, SHSTR& strOut);
    HRESULT _GetTileInfoString(BOOL fForceLM, SHSTR& strOut);
    HRESULT _GetWebViewDisplayPropsString(BOOL fForceLM, SHSTR& strOut);
    HRESULT _GetShellNewValueString(BOOL fForceLM, BOOL fQueryOnly, LPCTSTR pszValue, SHSTR& strOut);
    HRESULT _GetDDEApplication(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut);
    HRESULT _GetDDETopic(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut);
    HRESULT _GetContentType(SHSTR& strOut);
    HRESULT _GetMSIDescriptor(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, LPBYTE pbOut, LPDWORD pcbOut);

    HRESULT _GetShellExecKey(ASSOCF flags, BOOL fForceLM, LPCWSTR pszVerb, HKEY *phkey);
    HRESULT _CloneKey(HKEY hk, HKEY *phkey);
    HRESULT _GetShellExtension(ASSOCF flags, BOOL fForceLM, LPCTSTR pszShellEx, SHSTR& strOut);
    HRESULT _GetFriendlyDocName(SHSTR& strOut);



    //
    //  Members
    //
    LONG _cRef;
    TCHAR _szInit[MAX_PATH];
    ASSOCF _assocfBaseClass;
    HWND _hwndInit;

    BITBOOL _fInited:1;
    BITBOOL _fAppOnly:1;
    BITBOOL _fAppPath:1;
    BITBOOL _fInitedBaseClass:1;
    BITBOOL _fIsClsid:1;
    BITBOOL _fNoRemapClsid:1;
    BITBOOL _fBaseClassOnly:1;

    HKEY _hkFileExtsCU;
    HKEY _hkExtensionCU;
    HKEY _hkExtensionLM;

    KEYCACHE _kcProgid;
    KEYCACHE _kcShellVerb;
    KEYCACHE _kcApp;
    KEYCACHE _kcCommand;
    KEYCACHE _kcExecutable;
    KEYCACHE _kcShellNew;
    KEYCACHE _kcDDE;

    IQueryAssociations *_pqaBaseClass;
};

CAssocW2k::CAssocW2k() : _cRef(1)
{
};

HRESULT CAssocW2k::Init(ASSOCF flags, LPCTSTR pszAssoc, HKEY hkProgid, HWND hwnd)
{
    //
    //  pszAssoc can be:
    //  .Ext        //  Detectable
    //  {Clsid}     //  Detectable
    //  Progid      //  Ambiguous 
    //                    Default!
    //  ExeName     //  Ambiguous
    //                    Requires ASSOCF_OPEN_BYEXENAME
    //  MimeType    //  Ambiguous
    //                    NOT IMPLEMENTED...
    //  


    if (!pszAssoc && !hkProgid) 
        return E_INVALIDARG;
    
    HKEY hk = NULL;

    if (_fInited)
        _Reset();
        
    if (pszAssoc)
    {
        _fAppOnly = BOOLIFY(flags & ASSOCF_OPEN_BYEXENAME);

        if (StrChr(pszAssoc, TEXT('\\')))
        {
            // this is a path
            if (_fAppOnly)
                _fAppPath = TRUE;
            else 
            {
                //  we need the extension
                pszAssoc = PathFindExtension(pszAssoc);

                if (!*pszAssoc)
                    pszAssoc = NULL;
            }
            
        }

        if (pszAssoc && *pszAssoc)
        {
            if (ISGUID(pszAssoc))
            {
                _PathAppend(TEXT("CLSID"), pszAssoc, _szInit, SIZECHARS(_szInit));
                _fIsClsid = TRUE;

                // for legacy reasons we dont always 
                //  want to remap the clsid.
                if (flags & ASSOCF_INIT_NOREMAPCLSID)
                    _fNoRemapClsid = TRUE;
            }
            else
            {
                StrCpyN(_szInit , pszAssoc, SIZECHARS(_szInit));

                //  if we initializing to folder dont default to folder.
                if (0 == StrCmpI(_szInit, TEXT("Folder")))
                    flags &= ~ASSOCF_INIT_DEFAULTTOFOLDER;
            }
            hk = _ClassKey(FALSE);
        }
        else if (flags & ASSOCF_INIT_DEFAULTTOSTAR)
        {
            //  this is a file without an extension 
            //  but we still allow file association on HKCR\.
            _szInit[0] = '.';
            _szInit[1] = 0;
            hk = _ClassKey(FALSE);
        }
    }
    else
    {
        ASSERT(hkProgid);
        hk = SHRegDuplicateHKey(hkProgid);
        if (hk)
            _CacheKey(_kcProgid, hk, NULL, KEYCACHE_FIXED);
    }

    _assocfBaseClass = (flags & (ASSOCF_INIT_DEFAULTTOFOLDER | ASSOCF_INIT_DEFAULTTOSTAR));

    //  
    //  NOTE - we can actually do some work even if 
    //  we were unable to create the applications
    //  key.  so we want to succeed in the case
    //  of an app only association.
    //
    if (hk || _fAppOnly)
    {
        _fInited = TRUE;

        return S_OK;
    }
    else if (_UseBaseClass())
    {
        _fBaseClassOnly = TRUE;
        _fInited = TRUE;
        
        return S_OK;
    }
    
    return HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
}

CAssocW2k::~CAssocW2k()
{
    _Reset();
}

#define REGFREE(hk)    if (hk) { RegCloseKey(hk); (hk) = NULL; } else { }

void CAssocW2k::_Reset(void)
{
    _CacheFree(_kcProgid);
    _CacheFree(_kcApp);
    _CacheFree(_kcShellVerb);
    _CacheFree(_kcCommand);
    _CacheFree(_kcExecutable);
    _CacheFree(_kcShellNew);
    _CacheFree(_kcDDE);

    REGFREE(_hkFileExtsCU);
    REGFREE(_hkExtensionCU);
    REGFREE(_hkExtensionLM);

    *_szInit = 0;
    _assocfBaseClass = 0;
    _hwndInit = NULL;

    _fInited = FALSE;
    _fAppOnly = FALSE;
    _fAppPath = FALSE;
    _fInitedBaseClass = FALSE;
    _fIsClsid = FALSE;
    _fBaseClassOnly = FALSE;
    
    ATOMICRELEASE(_pqaBaseClass);
}

STDMETHODIMP CAssocW2k::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAssocW2k, IQueryAssociations),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CAssocW2k::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CAssocW2k::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

BOOL CAssocW2k::_UseBaseClass(void)
{
    if (!_pqaBaseClass && !_fInitedBaseClass)
    {
        //  try to init the base class
        IQueryAssociations *pqa;
        AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
        if (pqa)
        {
            SHSTR strBase;
            if (_fInited && SUCCEEDED(_AssocGetRegString(_ClassKey(TRUE), NULL, TEXT("BaseClass"), strBase)))
            {
                if (SUCCEEDED(pqa->Init(_assocfBaseClass, strBase, NULL, _hwndInit)))
                    _pqaBaseClass = pqa;
            }

            if (!_pqaBaseClass)
            {
                if ((_assocfBaseClass & ASSOCF_INIT_DEFAULTTOFOLDER)
                && (SUCCEEDED(pqa->Init(0, L"Folder", NULL, _hwndInit))))
                    _pqaBaseClass = pqa;
                else if ((_assocfBaseClass & ASSOCF_INIT_DEFAULTTOSTAR)
                && (SUCCEEDED(pqa->Init(0, L"*", NULL, _hwndInit))))
                    _pqaBaseClass = pqa;
            }

            //  if we couldnt init the BaseClass, then kill the pqa
            if (!_pqaBaseClass)
                pqa->Release();
        }

        _fInitedBaseClass = TRUE;
    }

    return (_pqaBaseClass != NULL);
}
        
HRESULT CAssocW2k::_CopyOut(BOOL fNoTruncate, SHSTR& str, LPTSTR psz, DWORD *pcch)
{
    //  if caller doesnt want any return size, 
    //  the incoming pointer is actually the size of the buffer
    
    ASSERT(pcch);
    ASSERT(psz || !IS_INTRESOURCE(pcch));
    
    HRESULT hr;
    DWORD cch = IS_INTRESOURCE(pcch) ? PtrToUlong(pcch) : *pcch;
    DWORD cchStr = str.GetLen();

    if (psz)
    {
        if (!fNoTruncate || cch > cchStr)
        {
            StrCpyN(psz, str, cch);
            hr = S_OK;
        }
        else
            hr = E_POINTER;
    }
    else
        hr = S_FALSE;
    
    //  return the number of chars written/required
    if (!IS_INTRESOURCE(pcch))
        *pcch = (hr == S_OK) ? lstrlen(psz) + 1 : cchStr + 1;

    return hr;
}


BOOL CAssocW2k::_CanUseCache(KEYCACHE &kc, LPCTSTR psz, KEYCACHETYPE type)
{
    if (KEYCACHE_FIXED == kc.type)
        return TRUE;
        
    if (KEYCACHE_INVALID != kc.type && type == kc.type)
    {
        return ((!psz && !kc.psz)
            || (psz && kc.psz && 0 == StrCmpC(psz, kc.psz)));
    }
    
    return FALSE;
}

void CAssocW2k::_CacheFree(KEYCACHE &kc)
{
    if (kc.pszCache)
        LocalFree(kc.pszCache);
    if (kc.hkCache)
        RegCloseKey(kc.hkCache);
    if (kc.psz)
        LocalFree(kc.psz);

    ZeroMemory(&kc, sizeof(kc));
}

void CAssocW2k::_CacheKey(KEYCACHE &kc, HKEY hkCache, LPCTSTR pszName, KEYCACHETYPE type)
{
    _CacheFree(kc);
    ASSERT(hkCache);

    kc.hkCache = hkCache;

    if (pszName)
        kc.psz = StrDup(pszName);
        
    if (!pszName || kc.psz)
        kc.type = type;
}

void CAssocW2k::_CacheString(KEYCACHE &kc, LPCTSTR pszCache, LPCTSTR pszName, KEYCACHETYPE type)
{
    _CacheFree(kc);
    ASSERT(pszCache && *pszCache);

    kc.pszCache = StrDup(pszCache);
    if (kc.pszCache)
    {
        if (pszName)
            kc.psz = StrDup(pszName);

        if (!pszName || kc.psz)
            kc.type = type;
    }
}

void CAssocW2k::_DefaultShellVerb(HKEY hk, LPTSTR pszVerb, DWORD cchVerb, HKEY *phkOut)
{
    //  default to "open"
    BOOL fDefaultSpecified = FALSE;
    TCHAR sz[MAX_PATH];
    DWORD cb = sizeof(sz);
    *phkOut = NULL;

    //  see if something is specified...
    if (ERROR_SUCCESS == SHGetValue(hk, TEXT("shell"), NULL, NULL, (LPVOID)sz, &cb) && *sz)
        fDefaultSpecified = TRUE;
    else
        StrCpy(sz, TEXT("open"));
        
    HKEY hkShell;
    if (SUCCEEDED(_AssocOpenRegKey(hk, TEXT("shell"), &hkShell)))
    {
        HKEY hkVerb;
        if (FAILED(_AssocOpenRegKey(hkShell, sz, &hkVerb)))
        {
            if (fDefaultSpecified)
            {
                // try to find one of the ordered verbs
                int c = StrCSpn(sz, TEXT(" ,"));
                sz[c] = 0;
                _AssocOpenRegKey(hkShell, sz, &hkVerb);
            }
            else
            {
                // otherwise just use the first key we find....
                cb = SIZECHARS(sz);
                if (ERROR_SUCCESS == RegEnumKeyEx(hkShell, 0, sz, &cb, NULL, NULL, NULL, NULL))
                    _AssocOpenRegKey(hkShell, sz, &hkVerb);
            }
        }

        if (hkVerb)
        {
            if (phkOut)
                *phkOut = hkVerb;
            else
                RegCloseKey(hkVerb);
        }
        
        RegCloseKey(hkShell);
    }

    if (pszVerb)
        StrCpyN(pszVerb, sz, cchVerb);

}

HKEY CAssocW2k::_RootKey(BOOL fForceLM)
{
    //
    //  this is one of the few places where there is no fallback to LM
    //  if there is no CU, then we return NULL
    //  we need to use a local for CU, but we can use a global for LM
    //

    if (!fForceLM)
    {
        if (!_hkFileExtsCU)
        {
            _AssocOpenRegKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts"), &_hkFileExtsCU);
        }
        
        return _hkFileExtsCU;
    }

    return HKEY_CLASSES_ROOT;

}

HKEY CAssocW2k::_AppKey(LPCTSTR pszApp, BOOL fCreate)
{
    //  right now we should only get NULL for the pszApp 
    //  when we are initialized with an EXE.
    ASSERT(_fAppOnly || pszApp);
    // else if (!_fAppOnly) TODO: handle getting it from default verb...or not
    
    if (!pszApp)
        pszApp = _fAppPath ? PathFindFileName(_szInit) : _szInit;

    if (_CanUseCache(_kcApp, pszApp, KEYCACHE_APP))
        return _kcApp.hkCache;
    else 
    {
        HKEY hk;
        TCHAR sz[MAX_PATH];
    
        _MakeApplicationsKey(pszApp, sz, SIZECHARS(sz));

        _AssocOpenRegKey(HKEY_CLASSES_ROOT, sz, &hk, fCreate);

        if (hk)
        {
            _CacheKey(_kcApp, hk, pszApp, KEYCACHE_APP);
        }

        return hk;
    }
}

HKEY CAssocW2k::_ExtensionKey(BOOL fForceLM)
{
    if (_fAppOnly)
        return _AppKey(NULL);
    if (!ISEXTENSION(_szInit) && !_fIsClsid)
        return NULL;

    if (!fForceLM)
    {
        if (!_hkExtensionCU)
            _AssocOpenRegKey(_RootKey(FALSE), _szInit, &_hkExtensionCU);

        //  NOTE there is no fallback here
        return _hkExtensionCU;
    }

    if (!_hkExtensionLM)
        _AssocOpenRegKey(_RootKey(TRUE), _szInit, &_hkExtensionLM);

    return _hkExtensionLM;
}

HKEY CAssocW2k::_OpenProgidKey(LPCTSTR pszProgid)
{
    HKEY hkOut;
    if (SUCCEEDED(_AssocOpenRegKey(_RootKey(TRUE), pszProgid, &hkOut)))
    {
        // Check for a newer version of the ProgID
        TCHAR sz[MAX_PATH];
        DWORD cb = sizeof(sz);

        //
        //  APPCOMPAT LEGACY - Quattro Pro 2000 and Excel 2000 dont get along - ZekeL - 7-MAR-2000
        //  mill bug #129525.  the problem is if Quattro is installed
        //  first, then excel picks up quattro's CurVer key for some
        //  reason.  then we end up using Quattro.Worksheet as the current
        //  version of the Excel.Sheet.  this is bug in both of their code.
        //  since quattro cant even open the file when we give it to them,
        //  they never should take the assoc in the first place, and when excel
        //  takes over it shouldnt have preserved the CurVer key from the
        //  previous association.  we could add some code to insure that the 
        //  CurVer key follows the OLE progid naming conventions and that it must
        //  be derived from the same app name as the progid in order to take 
        //  precedence but for now we will block CurVer from working whenever
        //  the progid is excel.sheet.8 (excel 2000)
        //
        if (StrCmpI(TEXT("Excel.Sheet.8"), pszProgid)
        && ERROR_SUCCESS == SHGetValue(hkOut, TEXT("CurVer"), NULL, NULL, sz, &cb) 
        && (cb > sizeof(TCHAR)))
        {
            //  cache this bubby
            HKEY hkTemp = hkOut;            
            if (SUCCEEDED(_AssocOpenRegKey(_RootKey(TRUE), sz, &hkOut)))
            {
                //
                //  APPCOMPAT LEGACY - order of preference - ZekeL - 22-JUL-99
                //  this is to support associations that installed empty curver
                //  keys, like microsoft project.
                //
                //  1.  curver with shell subkey
                //  2.  progid with shell subkey
                //  3.  curver without shell subkey
                //  4.  progid without shell subkey
                //
                HKEY hkShell;

                if (SUCCEEDED(_AssocOpenRegKey(hkOut, TEXT("shell"), &hkShell)))
                {
                    RegCloseKey(hkShell);
                    RegCloseKey(hkTemp);    // close old ProgID key
                }
                else if (SUCCEEDED(_AssocOpenRegKey(hkTemp, TEXT("shell"), &hkShell)))
                {
                    RegCloseKey(hkShell);
                    RegCloseKey(hkOut);
                    hkOut = hkTemp;
                }
                else
                    RegCloseKey(hkTemp);
                
            }
            else  // reset!
                hkOut = hkTemp;
        }
    }

    return hkOut;
}

//  we only need to build this once, so build it for 
//  the lowest common denominator...
HKEY CAssocW2k::_ProgidKey(BOOL fDefaultToExtension)
{
    HKEY hkExt = _ExtensionKey(TRUE);
    TCHAR sz[MAX_PATH];
    ULONG cb = sizeof(sz);
    LPCTSTR psz;
    HKEY hkRet = NULL;

    if (!hkExt && !ISEXTENSION(_szInit))
    {
        psz = _szInit;
    }
    else if (!_fNoRemapClsid && hkExt && (ERROR_SUCCESS == SHGetValue(hkExt, _fIsClsid ? TEXT("ProgID") : NULL, NULL, NULL, sz, &cb))
        && (cb > sizeof(TCHAR)))
    {
        psz = sz;
    }
    else
        psz = NULL;

    if (psz && *psz)
    {
        hkRet = _OpenProgidKey(psz);
    }

    if (!hkRet && fDefaultToExtension && hkExt)
        hkRet = SHRegDuplicateHKey(hkExt);

    return hkRet;
}

HKEY CAssocW2k::_UserProgidKey(void)
{
    SHSTR strApp;
    if (SUCCEEDED(_AssocGetRegString(_ExtensionKey(FALSE), NULL, TEXT("Application"), strApp)))
    {
        HKEY hkRet = _AppKey(strApp);

        if (hkRet)
            return SHRegDuplicateHKey(hkRet);
    }

    return NULL;
}

HKEY CAssocW2k::_ClassKey(BOOL fForceLM)
{
    //  REARCHITECT - we are not supporting clsids correctly here.
    HKEY hkRet = NULL;
    if (_fAppOnly)
        return _AppKey(NULL);
    else
    {
        KEYCACHETYPE type;
        if (!fForceLM)
            type = KEYCACHE_HKCU;
        else
            type = KEYCACHE_HKLM;

        if (_CanUseCache(_kcProgid, NULL, type))
            hkRet = _kcProgid.hkCache;
        else
        {
            if (!fForceLM)
                hkRet = _UserProgidKey();

            if (!hkRet)
                hkRet = _ProgidKey(TRUE);

            //  cache the value off
            if (hkRet)
                _CacheKey(_kcProgid, hkRet, NULL, type);
            
        }
    }
    return hkRet;
}

HKEY CAssocW2k::_ShellVerbKey(HKEY hkey, KEYCACHETYPE type, LPCTSTR pszVerb)
{
    HKEY hkRet = NULL;
    //  check our cache
    if (_CanUseCache(_kcShellVerb, pszVerb, type))
        hkRet = _kcShellVerb.hkCache;
    else if (hkey)
    {
        //  NO cache hit
        if (!pszVerb)
            _DefaultShellVerb(hkey, NULL, 0, &hkRet);
        else
        {
            TCHAR szKey[MAX_PATH];

            _PathAppend(TEXT("shell"), pszVerb, szKey, SIZECHARS(szKey));
            _AssocOpenRegKey(hkey, szKey, &hkRet);
        }
        
        // only replace the cache if we got something
        if (hkRet)
            _CacheKey(_kcShellVerb, hkRet, pszVerb, type);
    }

    return hkRet;
}

HKEY CAssocW2k::_ShellVerbKey(BOOL fForceLM, LPCTSTR pszVerb)
{
    HKEY hk = NULL;

    if (!fForceLM)
    {
        hk = _ShellVerbKey(_ClassKey(FALSE), KEYCACHE_HKCU, pszVerb);
        if (!hk && _szInit[0]) // szInit[0] = NULL, if Iqa is inited by key.
            hk = _ShellVerbKey(_ExtensionKey(FALSE), KEYCACHE_HKCU, pszVerb);
    }
    if (!hk) 
    {
        KEYCACHETYPE type = (_fAppOnly) ? KEYCACHE_APP : KEYCACHE_HKLM;
        hk = _ShellVerbKey(_ClassKey(TRUE), type, pszVerb);
        if (!hk && _szInit[0]) // szInit[0] = NULL, if Iqa is inited by key.
            hk = _ShellVerbKey(_ExtensionKey(TRUE), type, pszVerb);
    }
    
    return hk;
}

HKEY CAssocW2k::_ShellNewKey(HKEY hkExt)
{
    //  
    //  shellnew keys look like this
    //  \.ext
    //      @ = "progid"
    //      \progid
    //          \shellnew
    //  -- OR --
    //  \.ext 
    //      \shellnew
    //
    HKEY hk = NULL;
    SHSTR strProgid;
    if (SUCCEEDED(_AssocGetRegString(hkExt, NULL, NULL, strProgid)))
    {
        strProgid.Append(TEXT("\\shellnew"));
        
        _AssocOpenRegKey(hkExt, TEXT("shellnew"), &hk);
    }
    
    if (!hk)
        _AssocOpenRegKey(hkExt, TEXT("shellnew"), &hk);

    return hk;
}

HKEY CAssocW2k::_ShellNewKey(BOOL fForceLM)
{
    ASSERT(!_fAppOnly);

    if (_CanUseCache(_kcShellNew, NULL, KEYCACHE_HKLM))
        return _kcShellNew.hkCache;

    HKEY hk = _ShellNewKey(_ExtensionKey(TRUE));
        

    if (hk)
        _CacheKey(_kcShellNew, hk, NULL, KEYCACHE_HKLM);

    return hk;
}

HRESULT CAssocW2k::_GetCommandString(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut)
{
    HRESULT hr = E_INVALIDARG;
    KEYCACHETYPE type;

    if (!fForceLM)
        type = PSZCACHE_HKCU;
    else if (_fAppOnly) 
        type = PSZCACHE_APP;
    else
        type = PSZCACHE_HKLM;

    if (pszVerb && !*pszVerb) 
        pszVerb = NULL;

    if (_CanUseCache(_kcCommand, pszVerb, type))
    {
        hr = strOut.SetStr(_kcCommand.pszCache);
    }
    
    if (FAILED(hr))    
    {
        hr = _AssocGetRegString(_ShellVerbKey(fForceLM, pszVerb), TEXT("command"), NULL, strOut);

        if (SUCCEEDED(hr))
        {
            _CacheString(_kcCommand, strOut, pszVerb, type);
        }
    }

    return hr;
}

BOOL _PathIsFile(LPCTSTR pszPath)
{
    DWORD attrs = GetFileAttributes(pszPath);

    return ((DWORD)-1 != attrs && !(attrs & FILE_ATTRIBUTE_DIRECTORY));
}
    
HRESULT CAssocW2k::_ParseCommand(ASSOCF flags, LPCTSTR pszCommand, SHSTR& strExe, PSHSTR pstrArgs)
{
    //  we just need to find where the params begin, and the exe ends...

    LPTSTR pch = PathGetArgs(pszCommand);

    if (*pch)
        *(--pch) = TEXT('\0');
    else
        pch = NULL;

    HRESULT hr = strExe.SetStr(pszCommand);

    //  to prevent brace proliferation
    if (S_OK != hr)
        goto quit;

    strExe.Trim();
    PathUnquoteSpaces(strExe.GetInplaceStr());

    //
    //  WARNING:  Expensive disk hits all over!
    //
    // We check for %1 since it is what appears under (for example) HKCR\exefile\shell\open\command
    // This will save us a chain of 35 calls to _PathIsFile("%1") when launching or getting a 
    // context menu on a shortcut to an .exe or .bat file.
    if ((ASSOCF_VERIFY & flags) 
        && (0 != StrCmp(strExe, TEXT("%1")))
        && (!_PathIsFile(strExe)) )
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        if (PathIsFileSpec(strExe))
        {
            if (_GetAppPath(strExe, strExe))
            {
                if (_PathIsFile(strExe))
                    hr = S_OK;
            }
            else
            {
                LPTSTR pszTemp = strExe.GetModifyableStr(MAX_PATH);
                if (pszTemp == NULL)
                    hr = E_OUTOFMEMORY;
                else
                {
                    if (PathFindOnPathEx(pszTemp, NULL, PFOPEX_DEFAULT | PFOPEX_OPTIONAL))
                    {
                       //  the find does a disk check for us...
                       hr = S_OK;
                    }
                }
            }
        }
        else             
        {
            //
            //  sometimes the path is not properly quoted.
            //  these keys will still work because of the
            //  way CreateProcess works, but we need to do
            //  some fiddling to figure that out.
            //

            //  if we found args, put them back...
            //  and try some different args
            while (pch)
            {
                *pch++ = TEXT(' ');

                if (pch = StrChr(pch, TEXT(' ')))
                    *pch = TEXT('\0');

                if (S_OK == strExe.SetStr(pszCommand))
                {
                    strExe.Trim();

                    if (_PathIsFile(strExe))
                    {
                        hr = S_FALSE;

                        //  this means that we found something
                        //  but the command line was kinda screwed
                        break;

                    }
                    //  this is where we loop again
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }//  while (pch)
        }
    }

    if (SUCCEEDED(hr) && pch)
    {
        //  currently right before the args, on a NULL terminator
        ASSERT(!*pch);
        pch++;
        
        if ((ASSOCF_REMAPRUNDLL & flags) 
        && 0 == StrCmpNIW(PathFindFileName(strExe), TEXT("rundll"), SIZECHARS(TEXT("rundll")) -1))
        {
            LPTSTR pchComma = StrChr(pch, TEXT(','));
            //  make the comma the beginning of the args
            if (pchComma)
                *pchComma = TEXT('\0');

            if (!*(PathFindExtension(pch)) 
            && lstrlen(++pchComma) > SIZECHARS(TEXT(".dll")))
                StrCat(pch, TEXT(".dll"));

            //  recurse :P
            hr = _ParseCommand(flags, pch, strExe, pstrArgs);
        }
        //  set the args if we got'em
        else if (pstrArgs)
            pstrArgs->SetStr(pch);
    }
    
quit:
    return hr;
}

HRESULT CAssocW2k::_GetFriendlyDocName(SHSTR& strOut)
{
    HRESULT hr = E_FAIL;
    HKEY hkProgId = _ProgidKey(_fIsClsid);
    if (hkProgId)
    {
        //  first try the MUI friendly version of the string
        //  if that fails fall back to the default value of the progid.
        hr = _AssocGetRegUIString(hkProgId, NULL, L"FriendlyTypeName", strOut);
        if (FAILED(hr))
            hr = _AssocGetRegString(hkProgId, NULL, NULL, strOut);
            
        RegCloseKey(hkProgId);
    }

    if (FAILED(hr) || IsEmptyStr(strOut))
    {
        hr = E_FAIL;
        if (!_fIsClsid)
        {
            //  fallback code
            TCHAR szDesc[MAX_PATH];
            *szDesc = 0;
            
            if (_assocfBaseClass & ASSOCF_INIT_DEFAULTTOFOLDER || 0 == StrCmpIW(L"Folder", _szInit))
            {
                //  load the folder description "Folder"
                LoadString(HINST_THISDLL, IDS_FOLDERTYPENAME, szDesc, ARRAYSIZE(szDesc));
            }
            else if (ISEXTENSION(_szInit) && _szInit[1])
            {
                TCHAR szTemplate[128];   // "%s File"
                CharUpper(_szInit);
                LoadString(HINST_THISDLL, IDS_EXTTYPETEMPLATE, szTemplate, ARRAYSIZE(szTemplate));
                wnsprintf(szDesc, ARRAYSIZE(szDesc), szTemplate, _szInit + 1);
            }
            else if (_assocfBaseClass & ASSOCF_INIT_DEFAULTTOSTAR)
            {
                //  load the file description "File"
                LoadString(HINST_THISDLL, IDS_FILETYPENAME, szDesc, ARRAYSIZE(szDesc));
            }
            else if (_szInit[0])
            {
                StrCpyN(szDesc, _szInit, ARRAYSIZE(szDesc));
                CharUpper(szDesc);
            }
            
            if (*szDesc)
                hr = strOut.SetStr(szDesc);
        }            
    }
    return hr;
}

HRESULT CAssocW2k::_GetExeString(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut)
{
    HRESULT hr = E_FAIL;
    KEYCACHETYPE type;

    if (!fForceLM)
        type = PSZCACHE_HKCU;
    else if (_fAppOnly) 
        type = PSZCACHE_APP;
    else
        type = PSZCACHE_HKLM;

    if (_CanUseCache(_kcExecutable, pszVerb, type))
        hr = strOut.SetStr(_kcExecutable.pszCache);

    if (FAILED(hr))
    {
        SHSTR strCommand;

        hr = _GetCommandString(flags, fForceLM, pszVerb, strCommand);
        
        if (S_OK == hr)
        {
            SHSTR strArgs;

            strCommand.Trim();
            hr = _ParseCommand(flags | ASSOCF_REMAPRUNDLL, strCommand, strOut, &strArgs);
            
            if (S_FALSE == hr)
            {
                hr = S_OK;

//                if (!ASSOCF_NOFIXUPS & flags)
//                    AssocSetCommandByKey(ASSOCF_SET_SUBSTENV, hkey, pszVerb, strExe.GetStr(), strArgs.GetStr());
            }
        }

        if (SUCCEEDED(hr))
            _CacheString(_kcExecutable, strOut, pszVerb, type);
    }

    return hr;
}    

HRESULT _AssocGetDarwinProductString(LPCTSTR pszDarwinCommand, SHSTR& strOut)
{
    DWORD cch = strOut.GetSize();
    UINT err = MsiGetProductInfo(pszDarwinCommand, INSTALLPROPERTY_PRODUCTNAME, strOut.GetInplaceStr(), &cch);

    if (err == ERROR_MORE_DATA  && cch > strOut.GetSize())
    {
        if (SUCCEEDED(strOut.SetSize(cch)))
            err = MsiGetProductInfo(pszDarwinCommand, INSTALLPROPERTY_PRODUCTNAME, strOut.GetInplaceStr(), &cch);
        else 
            return E_OUTOFMEMORY;
    }

    if (err)
        return HRESULT_FROM_WIN32(err);
    return ERROR_SUCCESS;
}

HRESULT CAssocW2k::_GetFriendlyAppByVerb(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut)
{
    if (pszVerb && !*pszVerb) 
        pszVerb = NULL;

    HKEY hk = _ShellVerbKey(fForceLM, pszVerb);

    if (hk)
    {
        HRESULT hr = _AssocGetRegUIString(hk, NULL, TEXT("FriendlyAppName"), strOut);

        if (FAILED(hr))
        {
            SHSTR str;
            //  check the appkey, for this executeables friendly
            //  name.  this should be the most common case
            hr = _GetExeString(flags, fForceLM, pszVerb, str);

            if (SUCCEEDED(hr))
            {
                hr = _GetFriendlyAppByApp(str, flags, strOut);
            }

            //  if the EXE isnt on the System, then Darwin might
            //  be able to tell us something about it...
            if (FAILED(hr))
            {
                hr = _AssocGetRegString(hk, TEXT("command"), TEXT("command"), str);
                if (SUCCEEDED(hr))
                {
                    hr = _AssocGetDarwinProductString(str, strOut);
                }
            }
        }


        return hr;
    }

    return E_FAIL;
}

HRESULT _GetFriendlyAppByCache(HKEY hkApp, LPCTSTR pszApp, BOOL fVerifyCache, BOOL fNoFixUps, SHSTR& strOut)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    if (pszApp)
    {
        FILETIME ftCurr;
        if (MyGetLastWriteTime(pszApp, &ftCurr))
        {
            if (fVerifyCache)
            {
                FILETIME ftCache = {0};
                DWORD cbCache = sizeof(ftCache);
                SHGetValue(hkApp, TEXT("shell"), TEXT("FriendlyCacheCTime"), NULL, &ftCache, &cbCache);

                if (0 == CompareFileTime(&ftCurr, &ftCache))
                    hr = S_OK;
            }

            if (FAILED(hr))
            {
                //  need to get this from the file itself
                LPTSTR pszOut = strOut.GetModifyableStr(MAX_PATH); // How big is big enough?
                UINT cch = strOut.GetSize();

                if (pszOut == NULL)
                    pszOut = strOut.GetInplaceStr();
                if (SHGetFileDescription(pszApp, NULL, NULL, pszOut, &cch))
                    hr = S_OK;

                if (SUCCEEDED(hr) && !(fNoFixUps))
                {
                    SHSetValue(hkApp, TEXT("shell"), TEXT("FriendlyCache"), REG_SZ, strOut, CbFromCch(strOut.GetLen() +1));
                    SHSetValue(hkApp, TEXT("shell"), TEXT("FriendlyCacheCTime"), REG_BINARY, &ftCurr, sizeof(ftCurr));
                }
            }
        }
    }
    return hr;
}

HRESULT CAssocW2k::_GetFriendlyAppByApp(LPCTSTR pszApp, ASSOCF flags, SHSTR& strOut)
{
    HKEY hk = _AppKey(pszApp ? PathFindFileName(pszApp) : NULL, TRUE);
    HRESULT hr = _AssocGetRegUIString(hk, NULL, TEXT("FriendlyAppName"), strOut);

    ASSERT(hk == _kcApp.hkCache);
    
    if (FAILED(hr))
    {
        //  we have now tried the default
        //  we need to try our private cache
        hr = _AssocGetRegUIString(hk, TEXT("shell"), TEXT("FriendlyCache"), strOut);

        if (flags & ASSOCF_VERIFY)
        {
            SHSTR strExe;
  
            if (!pszApp)
            {
                ASSERT(_fAppOnly);
                if (_fAppPath)
                {
                    pszApp = _szInit;
                }
                else if (SUCCEEDED(_GetExeString(flags, FALSE, NULL, strExe)))
                {
                    pszApp = strExe;
                }
            }

            hr = _GetFriendlyAppByCache(hk, pszApp, SUCCEEDED(hr), (flags & ASSOCF_NOFIXUPS), strOut);
        }
    }
    return hr;
}
        
HRESULT CAssocW2k::_GetFriendlyAppString(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut)
{
    // Algorithm:
    //     if there is a named value "friendly", return its value;
    //     if it is a darwin app, return darwin product name;
    //     if there is app key, return its named value "friendly"
    //     o/w, get friendly name from the exe, and cache it in its app key
    
    //  check the verb first.  that overrides the
    //  general exe case
    HRESULT hr; 

    if (_fAppOnly)
    {
        hr = _GetFriendlyAppByApp(NULL, flags, strOut);
    }
    else
    {
        hr = _GetFriendlyAppByVerb(flags, fForceLM, pszVerb, strOut);
    }

    return hr;
}

HRESULT CAssocW2k::_GetShellExtension(ASSOCF flags, BOOL fForceLM, LPCTSTR pszShellEx, SHSTR& strOut)
{

    HRESULT hr = E_FAIL;
    if (pszShellEx && *pszShellEx)
    {
        // Try to get the extension handler under ProgID first.
        HKEY hk = _ClassKey(fForceLM);
        TCHAR szHandler[140] = TEXT("ShellEx\\");
        StrCatBuff(szHandler, pszShellEx, ARRAYSIZE(szHandler));
 
        if (hk)
        {
            hr = _AssocGetRegString(hk, szHandler, NULL, strOut);
        }

        // Else try to get the extension handler under file extension.
        if (FAILED(hr) && _szInit[0]) // szInit[0] = NULL, if Iqa is inited by key.
        {
            //  reuse hk here
            hk = _ExtensionKey(fForceLM);
            if (hk)
            {
                hr = _AssocGetRegString(hk, szHandler, NULL, strOut);
            }            
        }
        
    }        
    return hr;
}

HRESULT CAssocW2k::_GetTipString(LPCWSTR pwszValueName, BOOL fForceLM, SHSTR& strOut)
{
    HRESULT hr = _AssocGetRegUIString(_ClassKey(fForceLM), NULL, pwszValueName, strOut);
    if (FAILED(hr))
        hr = _AssocGetRegUIString(_ExtensionKey(fForceLM), NULL, pwszValueName, strOut);
    if (FAILED(hr) && !fForceLM)
        hr = _AssocGetRegUIString(_ExtensionKey(TRUE), NULL, pwszValueName, strOut);
    return hr;
}

HRESULT CAssocW2k::_GetInfoTipString(BOOL fForceLM, SHSTR& strOut)
{
    return _GetTipString(L"InfoTip", fForceLM, strOut);
}

HRESULT CAssocW2k::_GetQuickTipString(BOOL fForceLM, SHSTR& strOut)
{
    return _GetTipString(L"QuickTip", fForceLM, strOut);
}

HRESULT CAssocW2k::_GetTileInfoString(BOOL fForceLM, SHSTR& strOut)
{
    return _GetTipString(L"TileInfo", fForceLM, strOut);
}

HRESULT CAssocW2k::_GetWebViewDisplayPropsString(BOOL fForceLM, SHSTR& strOut)
{
    return _GetTipString(L"WebViewDisplayProperties", fForceLM, strOut);
}


HRESULT CAssocW2k::_GetShellNewValueString(BOOL fForceLM, BOOL fQueryOnly, LPCTSTR pszValue, SHSTR& strOut)
{
    HRESULT hr = E_FAIL;
    HKEY hk = _ShellNewKey(fForceLM);

    if (hk)
    {
        TCHAR sz[MAX_PATH];
        if (!pszValue)
        {
            //  get the default value....
            DWORD cch = SIZECHARS(sz);
            //  we want a pszValue....
            if (ERROR_SUCCESS == RegEnumValue(hk, 0, sz, &cch, NULL, NULL, NULL, NULL))
                pszValue = sz;
        }

        hr = _AssocGetRegString(hk, NULL, pszValue, strOut);
    }
    
    return hr;
}

HKEY CAssocW2k::_DDEKey(BOOL fForceLM, LPCTSTR pszVerb)
{
    HKEY hkRet = NULL;
    KEYCACHETYPE type;

    if (!fForceLM)
    {
        type = KEYCACHE_HKCU;
    }
    else
    {
        type = KEYCACHE_HKLM;
    }

    if (_CanUseCache(_kcDDE, pszVerb, type))
    {
        hkRet = _kcDDE.hkCache;
    }
    else
    {
        if (SUCCEEDED(_AssocOpenRegKey(_ShellVerbKey(fForceLM, pszVerb), TEXT("ddeexec"), &hkRet)))
        {
            _CacheKey(_kcDDE, hkRet, pszVerb, type);
        }
    }

    return hkRet;
}

HRESULT CAssocW2k::_GetDDEApplication(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut)
{
    HRESULT hr = E_FAIL;
    HKEY hk = _DDEKey(fForceLM, pszVerb);

    if (hk)
    {
        hr = _AssocGetRegString(hk, TEXT("Application"), NULL, strOut);

        if (FAILED(hr) || IsEmptyStr(strOut))
        {
            hr = E_FAIL;
            //  this means we should figure it out
            if (SUCCEEDED(_GetExeString(flags, fForceLM, pszVerb, strOut)))
            {
                PathRemoveExtension(strOut.GetInplaceStr());
                PathStripPath(strOut.GetInplaceStr());

                if (!IsEmptyStr(strOut))
                {
                    //  we have a useful app name
                    hr = S_OK;
                    
                    if (!(flags & ASSOCF_NOFIXUPS))
                    {
                        //  lets put it back!
                        SHSetValue(_DDEKey(fForceLM, pszVerb), TEXT("Application"), NULL, REG_SZ, strOut.GetStr(), CbFromCch(strOut.GetLen() +1));
                    }
                }
            }
        }
    }
    
    return hr;
}

HRESULT CAssocW2k::_GetDDETopic(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, SHSTR& strOut)
{
    HRESULT hr = E_FAIL;
    HKEY hk = _DDEKey(fForceLM, pszVerb);

    if (hk)
    {
        hr = _AssocGetRegString(hk, TEXT("Topic"), NULL, strOut);

        if (FAILED(hr) || IsEmptyStr(strOut))
            hr = strOut.SetStr(TEXT("System"));
    }
    
    return hr;
}

HRESULT CAssocW2k::_GetContentType(SHSTR& strOut)
{
    HRESULT hr = E_FAIL;
    if (ISEXTENSION(_szInit))
    {
        HKEY hk = _ExtensionKey(TRUE);

        if (hk)
        {
            hr = _AssocGetRegString(hk, NULL, TEXT("Content Type"), strOut);
        }
    }
    return hr;
}
 

HRESULT CAssocW2k::GetString(ASSOCF flags, ASSOCSTR str, LPCTSTR pszExtra, LPTSTR pszOut, DWORD *pcchOut)
{
    RIP(_fInited);
    if (!_fInited)
        return E_UNEXPECTED;
        
    HRESULT hr = E_INVALIDARG;
    SHSTR strOut;

    if (str && str < ASSOCSTR_MAX && pcchOut && (pszOut || !IS_INTRESOURCE(pcchOut)))
    {
        BOOL fForceLM = (_fAppOnly) || (flags & ASSOCF_NOUSERSETTINGS);

        if (!_fBaseClassOnly || ASSOCSTR_FRIENDLYDOCNAME == str)
        {
            switch(str)
            {
            case ASSOCSTR_COMMAND:
                hr = _GetCommandString(flags, fForceLM, pszExtra, strOut);
                break;

            case ASSOCSTR_EXECUTABLE:
                hr = _GetExeString(flags, fForceLM, pszExtra, strOut);
                break;

            case ASSOCSTR_FRIENDLYAPPNAME:
                hr = _GetFriendlyAppString(flags, fForceLM, pszExtra, strOut);
                break;

            case ASSOCSTR_SHELLNEWVALUE:
                if (!_fAppOnly)
                    hr = _GetShellNewValueString(fForceLM, (pszOut == NULL), pszExtra, strOut);
                break;
                
            case ASSOCSTR_NOOPEN:
                if (!_fAppOnly)
                    hr = _AssocGetRegString(_ClassKey(fForceLM), NULL, TEXT("NoOpen"), strOut);
                break;

            case ASSOCSTR_FRIENDLYDOCNAME:
                if (!_fAppOnly)
                    hr = _GetFriendlyDocName(strOut);
                break;

            case ASSOCSTR_DDECOMMAND:
                hr = _AssocGetRegString(_DDEKey(fForceLM, pszExtra), NULL, NULL, strOut);
                break;
                
            case ASSOCSTR_DDEIFEXEC:
                hr = _AssocGetRegString(_DDEKey(fForceLM, pszExtra), TEXT("IfExec"), NULL, strOut);
                break;

            case ASSOCSTR_DDEAPPLICATION:
                hr = _GetDDEApplication(flags, fForceLM, pszExtra, strOut);
                break;

            case ASSOCSTR_DDETOPIC:
                hr = _GetDDETopic(flags, fForceLM, pszExtra, strOut);
                break;

            case ASSOCSTR_INFOTIP:
                hr = _GetInfoTipString(fForceLM, strOut);
                break;

            case ASSOCSTR_QUICKTIP:
                hr = _GetQuickTipString(fForceLM, strOut);
                break;

            case ASSOCSTR_TILEINFO:
                hr = _GetTileInfoString(fForceLM, strOut);
                break;

            case ASSOCSTR_CONTENTTYPE:
                hr = _GetContentType(strOut);
                break;

             case ASSOCSTR_DEFAULTICON:
                hr = _AssocGetRegString(_ClassKey(fForceLM), TEXT("DefaultIcon"), NULL, strOut);
                break;

            case ASSOCSTR_SHELLEXTENSION:
                hr = _GetShellExtension(flags, fForceLM, pszExtra, strOut);
                if (FAILED(hr) && !fForceLM)
                    hr = _GetShellExtension(flags, TRUE, pszExtra, strOut);
                break;

            default:
                //
                // Turn off this assert message until we have a clean way to support new ASSOCSTR types 
                // in both shell32 and shlwapi
                //
#if 0
                AssertMsg(FALSE, TEXT("CAssocW2k::GetString() mismatched headers - ZekeL"));
#endif
                hr = E_INVALIDARG;
                break;
            }
        }
        
        if (SUCCEEDED(hr))
            hr = _CopyOut(flags & ASSOCF_NOTRUNCATE, strOut, pszOut, pcchOut);
        else if (!(flags & ASSOCF_IGNOREBASECLASS) && _UseBaseClass())
        {
            HRESULT hrT = _pqaBaseClass->GetString(flags, str, pszExtra, pszOut, pcchOut);
            if (SUCCEEDED(hrT))
                hr = hrT;
        }
    }
    
    return hr;
}

HRESULT CAssocW2k::_GetMSIDescriptor(ASSOCF flags, BOOL fForceLM, LPCTSTR pszVerb, LPBYTE pbOut, LPDWORD pcbOut)
{
    // what do we do with A/W thunks of REG_MULTI_SZ

    // the darwin ID is always a value name that is the same as the name of the parent key,
    // so instead of reading the default value we read the value with the name of the
    // parent key.
    //
    //  shell
    //    |
    //    -- Open
    //         |
    //         -- Command
    //              (Default)   =   "%SystemRoot%\system32\normal_app.exe"      <-- this is the normal app value
    //              Command     =   "[DarwinID] /c"                             <-- this is the darwin ID value
    //
    //  HACK!  Access 95 (shipping product) creates a "Command" value under
    //  the Command key but it is >>not<< a Darwin ID.  I don't know what
    //  they were smoking.  So we also check the key type and it must be
    //  REG_MULTI_SZ or we will ignore it.
    //
    //
    DWORD dwType;
    HRESULT hr = _AssocGetRegData(_ShellVerbKey(fForceLM, pszVerb), TEXT("command"), TEXT("command"), &dwType, pbOut, pcbOut);

    if (SUCCEEDED(hr) && dwType != REG_MULTI_SZ)
        hr = E_UNEXPECTED;

    return hr;
}

HRESULT CAssocW2k::GetData(ASSOCF flags, ASSOCDATA data, LPCWSTR pszExtra, LPVOID pvOut, DWORD *pcbOut)
{
    RIP(_fInited);
    if (!_fInited)
        return E_UNEXPECTED;
        
    HRESULT hr = E_INVALIDARG;

    if (data && data < ASSOCSTR_MAX)
    {
        BOOL fForceLM = (_fAppOnly) || (flags & ASSOCF_NOUSERSETTINGS);
        DWORD cbReal;
        if (pcbOut && IS_INTRESOURCE(pcbOut))
        {
            cbReal = PtrToUlong(pcbOut);
            pcbOut = &cbReal;
        }

        if (!_fBaseClassOnly)
        {
            switch(data)
            {
            case ASSOCDATA_MSIDESCRIPTOR:
                hr = _GetMSIDescriptor(flags, fForceLM, pszExtra, (LPBYTE)pvOut, pcbOut);
                break;

            case ASSOCDATA_NOACTIVATEHANDLER:
                hr = _AssocGetRegData(_DDEKey(fForceLM, pszExtra), NULL, TEXT("NoActivateHandler"), NULL, (LPBYTE) pvOut, pcbOut);
                break;

            case ASSOCDATA_QUERYCLASSSTORE:
                hr = _AssocGetRegData(_ClassKey(fForceLM), NULL, TEXT("QueryClassStore"), NULL, (LPBYTE) pvOut, pcbOut);                
                break;

            case ASSOCDATA_HASPERUSERASSOC:
                {
                    HKEY hk = _UserProgidKey();
                    if (hk && _ShellVerbKey(hk, KEYCACHE_HKCU, pszExtra))
                        hr = S_OK;
                    else
                        hr = S_FALSE;

                    REGFREE(hk);
                }
                break;

            case ASSOCDATA_EDITFLAGS:
                hr = _AssocGetRegData(_ClassKey(fForceLM), NULL, TEXT("EditFlags"), NULL, (LPBYTE) pvOut, pcbOut);                               
                break;
                
            default:
                AssertMsg(FALSE, TEXT("CAssocW2k::GetString() mismatched headers - ZekeL"));
                hr = E_INVALIDARG;
                break;
            }
        }

        if (FAILED(hr) && !(flags & ASSOCF_IGNOREBASECLASS) && _UseBaseClass())
        {
            HRESULT hrT = _pqaBaseClass->GetData(flags, data, pszExtra, pvOut, pcbOut);
            if (SUCCEEDED(hrT))
                hr = hrT;
        }
    }
    
    return hr;
}

HRESULT CAssocW2k::GetEnum(ASSOCF flags, ASSOCENUM assocenum, LPCTSTR pszExtra, REFIID riid, LPVOID *ppvOut)
{
    return E_NOTIMPL;
}

HRESULT CAssocW2k::_GetShellExecKey(ASSOCF flags, BOOL fForceLM, LPCWSTR pszVerb, HKEY *phkey)
{
    HKEY hkProgid = NULL;

    if (pszVerb && !*pszVerb) 
        pszVerb = NULL;

    if (!fForceLM)
    {
        hkProgid = _ClassKey(FALSE);
        if (hkProgid && (!(flags & ASSOCF_VERIFY) || _ShellVerbKey(hkProgid, KEYCACHE_HKCU, pszVerb)))
            *phkey = SHRegDuplicateHKey(hkProgid);
    }

    if (!*phkey) 
    {
        KEYCACHETYPE type = (_fAppOnly) ? KEYCACHE_APP : KEYCACHE_HKLM;
        hkProgid = _ClassKey(TRUE);
        if (hkProgid && (!(flags & ASSOCF_VERIFY) || _ShellVerbKey(hkProgid, type, pszVerb)))
            *phkey = SHRegDuplicateHKey(hkProgid);
    }

    return *phkey ? S_OK : HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
}
    
HRESULT CAssocW2k::_CloneKey(HKEY hk, HKEY *phkey)
{
    if (hk)
        *phkey = SHRegDuplicateHKey(hk);

    return *phkey ? S_OK : HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
}

HRESULT CAssocW2k::GetKey(ASSOCF flags, ASSOCKEY key, LPCTSTR pszExtra, HKEY *phkey)
{
    RIP(_fInited);
    if (!_fInited)
        return E_UNEXPECTED;

    HRESULT hr = E_INVALIDARG;
    
    if (key && key < ASSOCKEY_MAX && phkey)
    {
        BOOL fForceLM = (_fAppOnly) || (flags & ASSOCF_NOUSERSETTINGS);
        *phkey = NULL;

        if (!_fBaseClassOnly)
        {
            switch (key)
            {
            case ASSOCKEY_SHELLEXECCLASS:
                hr = _GetShellExecKey(flags, fForceLM, pszExtra, phkey);
                break;

            case ASSOCKEY_APP:
                hr = _fAppOnly ? _CloneKey(_AppKey(NULL), phkey) : E_INVALIDARG;
                break;

            case ASSOCKEY_CLASS:
                hr = _CloneKey(_ClassKey(fForceLM), phkey);
                break;

            case ASSOCKEY_BASECLASS:
                //  fall through and it is handled by the BaseClass handling
                break;
                
            default:
                AssertMsg(FALSE, TEXT("CAssocW2k::GetKey() mismatched headers - ZekeL"));
                hr = E_INVALIDARG;
                break;
            }
        }
        
        if (FAILED(hr) && !(flags & ASSOCF_IGNOREBASECLASS) && _UseBaseClass())
        {
            //  it is possible to indicate the depth of the 
            //  base class by pszExtra being an INT
            if (key == ASSOCKEY_BASECLASS)
            {
                int depth = IS_INTRESOURCE(pszExtra) ? LOWORD(pszExtra) : 0;
                if (depth)
                {
                    //  go deeper than this
                    depth--;
                    hr = _pqaBaseClass->GetKey(flags, key, MAKEINTRESOURCE(depth), phkey);
                }
                else
                {
                    //  just return this baseclass
                    hr = _pqaBaseClass->GetKey(flags, ASSOCKEY_CLASS, pszExtra, phkey);
                }
            }
            else
            {
                //  forward to the base class
                hr = _pqaBaseClass->GetKey(flags, key, pszExtra, phkey);
            }
        }
        
    }

    return hr;
}

HRESULT AssocCreateW2k(REFIID riid, LPVOID *ppvOut)
{
    HRESULT hr = E_OUTOFMEMORY;
    CAssocW2k *passoc = new CAssocW2k();
    if (passoc)
    {
        hr = passoc->QueryInterface(riid, ppvOut);
        passoc->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\assocelem.cpp ===
#include "priv.h"
#include "ids.h"
#include "assoc.h"
#include <memt.h>

BOOL _GetAppPath(PCWSTR pszApp, PWSTR pszExe, DWORD cchExe)
{
    WCHAR sz[MAX_PATH];
    _MakeAppPathKey(pszApp, sz, SIZECHARS(sz));

    DWORD cb = CbFromCchW(cchExe);
    return ERROR_SUCCESS == SHGetValueW(HKEY_LOCAL_MACHINE, sz, NULL, NULL, pszExe, &cb);
}

inline HRESULT _QuerySourceCreateFromKey(HKEY hk, PCWSTR pszSub, BOOL fCreate, IQuerySource **ppqs)
{
    return QuerySourceCreateFromKey(hk, pszSub, fCreate, IID_PPV_ARG(IQuerySource, ppqs));
}

typedef struct QUERYKEYVAL
{
    ASSOCQUERY query;
    PCWSTR pszKey;
    PCWSTR pszVal;
} QUERYKEYVAL;

#define MAKEQKV(q, k, v) { q, k, v}

static const QUERYKEYVAL s_rgqkvVerb[] = 
{
    MAKEQKV(AQVS_COMMAND, L"command", NULL),
    MAKEQKV(AQVS_DDECOMMAND, L"ddeexec", NULL),
    MAKEQKV(AQVS_DDEIFEXEC, L"ddeexec\\ifexec", NULL),
    MAKEQKV(AQVS_DDEAPPLICATION, L"ddeexec\\application", NULL),
    MAKEQKV(AQVS_DDETOPIC, L"ddeexec\\topic", NULL),
    MAKEQKV(AQV_NOACTIVATEHANDLER, L"ddeexec", L"NoActivateHandler"),
    MAKEQKV(AQVD_MSIDESCRIPTOR, L"command", L"command"),
    MAKEQKV(AQVS_APPLICATION_FRIENDLYNAME, NULL, L"FriendlyAppName"),
};

static const QUERYKEYVAL s_rgqkvShell[] = 
{
    MAKEQKV(AQS_FRIENDLYTYPENAME, NULL, L"FriendlyTypeName"),
    MAKEQKV(AQS_DEFAULTICON, L"DefaultIcon", NULL),
    MAKEQKV(AQS_CLSID, L"Clsid", NULL),
    MAKEQKV(AQS_PROGID, L"Progid", NULL),
    MAKEQKV(AQNS_SHELLEX_HANDLER, L"ShellEx\\%s", NULL),
};

static const QUERYKEYVAL s_rgqkvExt[] = 
{
    MAKEQKV(AQNS_SHELLEX_HANDLER, L"ShellEx\\%s", NULL),
    MAKEQKV(AQS_CONTENTTYPE, NULL, L"Content Type"),
};

static const QUERYKEYVAL s_rgqkvApp[] = 
{
    MAKEQKV(AQVS_APPLICATION_FRIENDLYNAME, NULL, L"FriendlyAppName"),
};

const QUERYKEYVAL *_FindKeyVal(ASSOCQUERY query, const QUERYKEYVAL *rgQkv, UINT cQkv)
{
    for (UINT i = 0; i < cQkv; i++)
    {
        if (rgQkv[i].query == query)
        {
            return &rgQkv[i];
        }
    }
    return NULL;
}

HRESULT _SHAllocMUI(LPWSTR *ppsz)
{
    WCHAR sz[INFOTIPSIZE];
    HRESULT hr = SHLoadIndirectString(*ppsz, sz, ARRAYSIZE(sz), NULL);
    CoTaskMemFree(*ppsz);
    if (SUCCEEDED(hr))
        hr = SHStrDupW(sz, ppsz);
    else
        *ppsz = 0;
    return hr;
}

HRESULT CALLBACK _QuerySourceString(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, PWSTR *ppsz)
{
    HRESULT hr = pqs->QueryValueString(pszKey, pszValue, ppsz);
    if (SUCCEEDED(hr) && (query & AQF_MUISTRING))
    {
        //  NOTE - this sucks for stack usage.
        //  since there is currently no way to get
        //  the size of the target.
        hr = _SHAllocMUI(ppsz);
    }
    return hr;
}

HRESULT CALLBACK _QuerySourceDirect(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, FLAGGED_BYTE_BLOB **ppblob)
{
    return pqs->QueryValueDirect(pszKey, pszValue, ppblob);
}

HRESULT CALLBACK _QuerySourceExists(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, void *pv)
{
    return pqs->QueryValueExists(pszKey, pszValue);
}

HRESULT CALLBACK _QuerySourceDword(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, DWORD *pdw)
{
    return pqs->QueryValueDword(pszKey, pszValue, pdw);
}

class CAssocElement : public IObjectWithQuerySource,
                      public IAssociationElement
{
public:
    CAssocElement() : _cRef(1), _pqs(0) {}
    virtual ~CAssocElement() { ATOMICRELEASE(_pqs); }

    //  IUnknown refcounting
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void)
    {
       return ++_cRef;
    }

    STDMETHODIMP_(ULONG) Release(void)
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    //  IObjectWithQuerySource 
    STDMETHODIMP SetSource(IQuerySource *pqs)
    {
        if (!_pqs)
        {
            _pqs = pqs;
            _pqs->AddRef();
            return S_OK;
        }
        return E_UNEXPECTED;
    }

    STDMETHODIMP GetSource(REFIID riid, void **ppv)
    {
        if (_pqs)
        {
            return _pqs->QueryInterface(riid, ppv);
        }
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    //  IAssociationElement
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz)
        {
            *ppsz = 0;
            return _QuerySourceAny(_QuerySourceString, _pqs, (ASSOCQUERY)(AQF_DIRECT | AQF_STRING), query, pszCue, ppsz);
        }

    STDMETHODIMP QueryDword(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        DWORD *pdw)
        {
            return _QuerySourceAny(_QuerySourceDword, _pqs, (ASSOCQUERY)(AQF_DIRECT | AQF_DWORD), query, pszCue, pdw);
        }

    STDMETHODIMP QueryExists(
        ASSOCQUERY query, 
        PCWSTR pszCue)
        {
            return _QuerySourceAny(_QuerySourceExists, _pqs, (ASSOCQUERY)(AQF_DIRECT | AQF_EXISTS), query, pszCue, (void*)NULL);
        }

    STDMETHODIMP QueryDirect(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        FLAGGED_BYTE_BLOB **ppblob)
        {
            *ppblob = 0;
            return _QuerySourceAny(_QuerySourceDirect, _pqs, AQF_DIRECT, query, pszCue, ppblob);
        }

    STDMETHODIMP QueryObject(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        REFIID riid,
        void **ppv)
        {
            *ppv = 0;
            return E_NOTIMPL;
        }

protected:
    template<class T> HRESULT _QueryKeyValAny(HRESULT (CALLBACK *pfnAny)(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, T *pData), const QUERYKEYVAL *rgQkv, UINT cQkv, IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszCue, T *pData)
    {
        HRESULT hr = E_INVALIDARG;
        const QUERYKEYVAL *pqkv = _FindKeyVal(query, rgQkv, cQkv);
        if (pqkv)
        {
            WCHAR szKey[128];
            PCWSTR pszKey = pqkv->pszKey;
            if (query & AQF_CUEIS_NAME)
            {
                if (pqkv->pszKey)
                {
                    wnsprintfW(szKey, ARRAYSIZE(szKey), pqkv->pszKey, pszCue);
                    pszKey = szKey;
                }
                // wnsprintf(szVal, ARRAYSIZE(szVal), pqkv->pszVal, pszCue);
            }
            hr = pfnAny(pqs, query, pszKey, pqkv->pszVal, pData);
        }
        return hr;
    }
    
    template<class T> HRESULT _QuerySourceAny(HRESULT (CALLBACK *pfnAny)(IQuerySource *pqs, ASSOCQUERY query, PCWSTR pszKey, PCWSTR pszValue, T *pData), IQuerySource *pqs, ASSOCQUERY mask, ASSOCQUERY query, PCWSTR pszCue, T *pData)
    {
        HRESULT hr = E_INVALIDARG;
        if (pqs)
        {
            if (query == AQN_NAMED_VALUE || query == AQNS_NAMED_MUI_STRING)
            {
                hr = pfnAny(pqs, query, NULL, pszCue, pData);
            }
            else if ((query & (mask)) == (mask))
            {
                const QUERYKEYVAL *rgQkv;
                UINT cQkv = _GetQueryKeyVal(&rgQkv);
                if (cQkv)
                {
                    hr = _QueryKeyValAny(pfnAny, rgQkv, cQkv, pqs, query, pszCue, pData);
                }
            }
        }
        return hr;
    }

    virtual UINT _GetQueryKeyVal(const QUERYKEYVAL **prgQkv) { *prgQkv = 0; return 0; }

protected:
    LONG _cRef;
    IQuerySource *_pqs;
};

HRESULT CAssocElement::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAssocElement, IAssociationElement),
        QITABENT(CAssocElement, IObjectWithQuerySource),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

HRESULT _QueryString(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    return pae->QueryString(query, pszCue, ppsz);
}

HRESULT _QueryDirect(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, FLAGGED_BYTE_BLOB **ppblob)
{
    return pae->QueryDirect(query, pszCue, ppblob);
}

HRESULT _QueryDword(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, DWORD *pdw)
{
    return pae->QueryDword(query, pszCue, pdw);
}

HRESULT _QueryExists(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, void *pv)
{
    return pae->QueryExists(query, pszCue);
}

class CAssocShellElement : public CAssocElement, public IPersistString2
{
public:
    virtual ~CAssocShellElement() { if (_pszInit && _pszInit != _szInit) LocalFree(_pszInit);}

    //  IUnknown refcounting
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void)
    {
       return ++_cRef;
    }

    STDMETHODIMP_(ULONG) Release(void)
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocShellElement; return S_OK;}

    //  IPersistString2
    STDMETHODIMP SetString(PCWSTR psz)
    {
        if (!_pszInit)
        {
            DWORD cch = lstrlenW(psz);
            if (cch < ARRAYSIZE(_szInit))
                _pszInit = _szInit;
            else
                SHLocalAlloc(CbFromCchW(cch + 1), &_pszInit);
            
            if (_pszInit)
            {
                StrCpyW(_pszInit, psz);
                return _InitSource();
            }
        }
        return E_UNEXPECTED;
    }
    
    STDMETHODIMP GetString(PWSTR *ppsz)
        { return SHStrDupW(_pszInit, ppsz); }

    //  IAssociationElement
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz)
        {
            if (AQF_CUEIS_SHELLVERB & query)
                return _QueryVerbAny(_QueryString, query, pszCue, ppsz);
            else
                return CAssocElement::QueryString(query, pszCue, ppsz);
        }
        
    STDMETHODIMP QueryDword(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        DWORD *pdw)
        {
            if (AQF_CUEIS_SHELLVERB & query)
                return _QueryVerbAny(_QueryDword, query, pszCue, pdw);
            else
                return CAssocElement::QueryDword(query, pszCue, pdw);
        }

    STDMETHODIMP QueryExists(
        ASSOCQUERY query, 
        PCWSTR pszCue)
        {
            if (AQF_CUEIS_SHELLVERB & query)
                return _QueryVerbAny(_QueryExists, query, pszCue, (void*)NULL);
            else
                return CAssocElement::QueryExists(query, pszCue);
        }

    STDMETHODIMP QueryDirect(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        FLAGGED_BYTE_BLOB **ppblob)
        {
            if (AQF_CUEIS_SHELLVERB & query)
                return _QueryVerbAny(_QueryDirect, query, pszCue, ppblob);
            else
                return CAssocElement::QueryDirect(query, pszCue, ppblob);
        }

    STDMETHODIMP QueryObject(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        REFIID riid,
        void **ppv);

protected:
    template<class T> HRESULT _QueryVerbAny(HRESULT (CALLBACK *pfnAny)(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, T pData), ASSOCQUERY query, PCWSTR pszCue, T pData)
    {
        IAssociationElement *pae;        
        HRESULT hr = _GetVerbDelegate(pszCue, &pae);
        if (SUCCEEDED(hr))
        {
            hr = pfnAny(pae, query, NULL, pData);
            pae->Release();
        }
        return hr;
    }

    //  from CAssocElement
    virtual UINT _GetQueryKeyVal(const QUERYKEYVAL **prgQkv) 
        { *prgQkv = s_rgqkvShell; return ARRAYSIZE(s_rgqkvShell); }

    //  defaults for our subclasses
    virtual BOOL _UseEnumForDefaultVerb() 
        { return FALSE;}
    virtual HRESULT _InitSource()
        { return _QuerySourceCreateFromKey(HKEY_CLASSES_ROOT, _pszInit, FALSE, &_pqs); }
    virtual BOOL _IsAppSource() 
        { return FALSE; }

    HRESULT _GetVerbDelegate(PCWSTR pszVerb, IAssociationElement **ppae);
    HRESULT _DefaultVerbSource(IQuerySource **ppqsVerb);
    HRESULT _QueryShellExtension(PCWSTR pszShellEx, PWSTR *ppsz);

protected:
    PWSTR _pszInit;
    WCHAR _szInit[64];
};

HRESULT CAssocShellElement::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAssocShellElement, IAssociationElement),
        QITABENT(CAssocShellElement, IObjectWithQuerySource),
        QITABENT(CAssocShellElement, IPersistString2),
        QITABENTMULTI(CAssocShellElement, IPersist, IPersistString2),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

class CAssocProgidElement : public CAssocShellElement 
{
public:
    virtual ~CAssocProgidElement()  { ATOMICRELEASE(_pqsExt); }
    //  then we handle fallback for IAssociationElement
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocProgidElement; return S_OK;}


protected:  // methods
    HRESULT _InitSource();  
    HRESULT _DefaultVerbSource(IQuerySource **ppqsVerb);
    BOOL _UseEnumForDefaultVerb() 
        { return TRUE; }

protected:  // members
    IQuerySource *_pqsExt;
};

HRESULT _QuerySourceCreateFromKey2(HKEY hk, PCWSTR pszSub1, PCWSTR pszSub2, IQuerySource **ppqs)
{
    WCHAR szKey[MAX_PATH];
    _PathAppend(pszSub1, pszSub2, szKey, SIZECHARS(szKey));
    return _QuerySourceCreateFromKey(hk, szKey, FALSE, ppqs);
}

class CAssocClsidElement : public CAssocShellElement 
{
public:
    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocClsidElement; return S_OK;}

protected:
    virtual HRESULT _InitSource()
        { return _QuerySourceCreateFromKey2(HKEY_CLASSES_ROOT, L"CLSID", _pszInit, &_pqs);}
};

class CAssocSystemExtElement : public CAssocShellElement  
{
public:
    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocSystemElement; return S_OK;}

protected:
    virtual HRESULT _InitSource()
        { return _QuerySourceCreateFromKey2(HKEY_CLASSES_ROOT, L"SystemFileAssociations", _pszInit, &_pqs);}
};

class CAssocPerceivedElement : public CAssocShellElement 
{
public:
    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocPerceivedElement; return S_OK;}
        
protected:    
    virtual HRESULT _InitSource();
    //  maybe _GetVerbDelegate() to support Accepts filters
};

class CAssocApplicationElement : public CAssocShellElement 
{
public:
    //  need to fallback to the pszInit for FriendlyAppName
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz); 
    
    STDMETHODIMP QueryObject(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        REFIID riid,
        void **ppv);

    //  IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocApplicationElement; return S_OK;}

protected:    
    virtual HRESULT _InitSource();
    virtual UINT _GetQueryKeyVal(const QUERYKEYVAL **prgQkv) 
        { *prgQkv = s_rgqkvApp; return ARRAYSIZE(s_rgqkvApp); }
    virtual BOOL _IsAppSource() 
        { return TRUE; }
    BOOL _UseEnumForDefaultVerb() 
        { return TRUE; }

    HRESULT _GetAppDisplayName(PWSTR *ppsz);
    
protected:
    BOOL _fIsPath;
};

HRESULT CAssocApplicationElement::_GetAppDisplayName(PWSTR *ppsz)
{
    HRESULT hr;
    PWSTR pszPath;
    if (_fIsPath)
    {
        hr = S_OK;
        pszPath = _pszInit;
        ASSERT(pszPath);
    }
    else
        hr = QueryString(AQVS_APPLICATION_PATH, NULL, &pszPath);

    if (SUCCEEDED(hr))
    {
        WCHAR sz[MAX_PATH];
        DWORD cb = sizeof(sz);
        hr = SKGetValueW(SHELLKEY_HKCULM_MUICACHE, NULL, pszPath, NULL, sz, &cb);
        if (FAILED(hr))
        {
            UINT cch = ARRAYSIZE(sz);
            if (SHGetFileDescriptionW(pszPath, NULL, NULL, sz, &cch))
            {
                hr = S_OK;
                SKSetValueW(SHELLKEY_HKCULM_MUICACHE, NULL, pszPath, REG_SZ, sz, CbFromCchW(lstrlenW(sz) + 1));
            }
        }

        if (SUCCEEDED(hr))
            hr = SHStrDupW(sz, ppsz);

        if (pszPath != _pszInit)
            CoTaskMemFree(pszPath);
    }

        
    return hr;
}


HRESULT CAssocApplicationElement::_InitSource()
{
    WCHAR sz[MAX_PATH];
    PCWSTR pszName = PathFindFileNameW(_pszInit);
    _MakeApplicationsKey(pszName, sz, ARRAYSIZE(sz));
    HRESULT hr = _QuerySourceCreateFromKey(HKEY_CLASSES_ROOT, sz, FALSE, &_pqs);
    _fIsPath = pszName != _pszInit;
    if (FAILED(hr))
    {
        if (_fIsPath && PathFileExistsW(_pszInit))
            hr = S_FALSE;
    }
    return hr;
}

HRESULT CAssocApplicationElement::QueryObject(ASSOCQUERY query, PCWSTR pszCue, REFIID riid, void **ppv)
{
    if (query == AQVO_APPLICATION_DELEGATE)
    {
        return QueryInterface(riid, ppv);
    }
    return CAssocShellElement::QueryObject(query, pszCue, riid, ppv);
}
        

HRESULT CAssocApplicationElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{ 
    HRESULT hr = CAssocShellElement::QueryString(query, pszCue, ppsz);
    if (FAILED(hr))
    {
        switch (query)
        {
        case AQVS_APPLICATION_FRIENDLYNAME:
            hr = _GetAppDisplayName(ppsz);
            break;
            
        }
    }
    return hr;
}
    
class CAssocShellVerbElement : public CAssocElement
{
public:
    CAssocShellVerbElement(BOOL fIsApp) : _fIsApp(fIsApp) {}
    
    //  overload QS to return default DDEExec strings
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz);

    STDMETHODIMP QueryObject(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        REFIID riid,
        void **ppv);

protected:    
    virtual UINT _GetQueryKeyVal(const QUERYKEYVAL **prgQkv) 
        { *prgQkv = s_rgqkvVerb; return ARRAYSIZE(s_rgqkvVerb); }
    HRESULT _GetAppDelegate(REFIID riid, void **ppv);

protected:
    BOOL _fIsApp;
};

class CAssocFolderElement : public CAssocShellElement  
{
public:
    //  overload QS to return default MUI strings
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocFolderElement; return S_OK;}

protected:    
    virtual HRESULT _InitSource()
        { return _QuerySourceCreateFromKey(HKEY_CLASSES_ROOT, L"Folder", FALSE, &_pqs); }
};

class CAssocStarElement : public CAssocShellElement  
{
public:
    //  overload QS to return default MUI strings
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocStarElement; return S_OK;}

protected:    
    virtual HRESULT _InitSource()
        { return _QuerySourceCreateFromKey(HKEY_CLASSES_ROOT, L"*", FALSE, &_pqs); }
};

HRESULT CAssocShellElement::_DefaultVerbSource(IQuerySource **ppqsVerb)
{
    IQuerySource *pqsShell;
    HRESULT hr = _pqs->OpenSource(L"shell", FALSE, &pqsShell);
    if (SUCCEEDED(hr))
    {
        PWSTR pszFree = NULL;
        PCWSTR pszVerb;
        //  see if something is specified...
        if (SUCCEEDED(pqsShell->QueryValueString(NULL, NULL, &pszFree)))
        {
            pszVerb = pszFree;
        }
        else
        {
            //  default to "open"
            pszVerb = L"open";
        }

        hr = pqsShell->OpenSource(pszVerb, FALSE, ppqsVerb);
        if (FAILED(hr))
        {
            if (pszFree)
            {
                // try to find one of the ordered verbs
                int c = StrCSpnW(pszFree, L" ,");
                if (c != lstrlenW(pszFree))
                {
                    pszFree[c] = 0;
                    hr = pqsShell->OpenSource(pszFree, FALSE, ppqsVerb);
                }
            }
            else if (_UseEnumForDefaultVerb())
            {
                //  APPCOMPAT - regitems need to have the open verb - ZekeL - 30-JAN-2001
                //  so that the IQA and ICM will behave the same,
                //  and regitem folders will always default to 
                //  folder\shell\open unless they implement open 
                //  or specify default verbs.
                //
                // everything else, just use the first key we find....
                IEnumString *penum;
                if (SUCCEEDED(pqsShell->EnumSources(&penum)))
                {
                    ULONG c;
                    CSmartCoTaskMem<OLECHAR> spszEnum;
                    if (S_OK == penum->Next(1, &spszEnum, &c))
                    {
                        hr = pqsShell->OpenSource(spszEnum, FALSE, ppqsVerb);
                    }
                    penum->Release();
                }
            }
        }

        if (pszFree)
            CoTaskMemFree(pszFree);
        pqsShell->Release();
    }
    return hr;
}

HRESULT QSOpen2(IQuerySource *pqs, PCWSTR pszSub1, PCWSTR pszSub2, BOOL fCreate, IQuerySource **ppqs)
{
    WCHAR szKey[MAX_PATH];
    _PathAppend(pszSub1, pszSub2, szKey, SIZECHARS(szKey));
    return pqs->OpenSource(szKey, fCreate, ppqs);
}

HRESULT CAssocShellElement::_GetVerbDelegate(PCWSTR pszVerb, IAssociationElement **ppae)
{
    HRESULT hr = _pqs ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        //  we will recalc each time.
        //  the array will cache appropriately
        IQuerySource *pqs;
        if (pszVerb)
        {
            hr = QSOpen2(_pqs, L"shell", pszVerb, FALSE, &pqs);
        }
        else
        {
            hr = _DefaultVerbSource(&pqs);
        }

        if (SUCCEEDED(hr))
        {
            CAssocShellVerbElement *pave = new CAssocShellVerbElement(_IsAppSource());
            if (pave)
            {
                hr = pave->SetSource(pqs);
                // this cant fail...
                ASSERT(SUCCEEDED(hr));
                *ppae = pave;
            }
            else
                hr = E_OUTOFMEMORY;
            pqs->Release();            
        }
    }

    return hr;
}

HRESULT CAssocShellElement::QueryObject(ASSOCQUERY query, PCWSTR pszCue, REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    if (AQF_CUEIS_SHELLVERB & query)
    {
        IAssociationElement *pae;        
        hr = _GetVerbDelegate(pszCue, &pae);
        if (SUCCEEDED(hr))
        {
            if (AQVO_SHELLVERB_DELEGATE == query)
                hr = pae->QueryInterface(riid, ppv);
            else
                hr = pae->QueryObject(query, NULL, riid, ppv);
            pae->Release();
        }
    }

    return hr;
}

HKEY _OpenProgidKey(PCWSTR pszProgid)
{
    HKEY hkOut;
    if (SUCCEEDED(_AssocOpenRegKey(HKEY_CLASSES_ROOT, pszProgid, &hkOut)))
    {
        // Check for a newer version of the ProgID
        WCHAR sz[64];
        DWORD cb = sizeof(sz);

        //
        //  APPCOMPAT LEGACY - Quattro Pro 2000 and Excel 2000 dont get along - ZekeL - 7-MAR-2000
        //  mill bug #129525.  the problem is if Quattro is installed
        //  first, then excel picks up quattro's CurVer key for some
        //  reason.  then we end up using Quattro.Worksheet as the current
        //  version of the Excel.Sheet.  this is bug in both of their code.
        //  since quattro cant even open the file when we give it to them,
        //  they never should take the assoc in the first place, and when excel
        //  takes over it shouldnt have preserved the CurVer key from the
        //  previous association.  we could add some code to insure that the 
        //  CurVer key follows the OLE progid naming conventions and that it must
        //  be derived from the same app name as the progid in order to take 
        //  precedence but for now we will block CurVer from working whenever
        //  the progid is excel.sheet.8 (excel 2000)
        //
        if (StrCmpIW(L"Excel.Sheet.8", pszProgid)
        && ERROR_SUCCESS == SHGetValueW(hkOut, L"CurVer", NULL, NULL, sz, &cb) 
        && (cb > sizeof(WCHAR)))
        {
            //  cache this bubby
            HKEY hkTemp = hkOut;            
            if (SUCCEEDED(_AssocOpenRegKey(HKEY_CLASSES_ROOT, sz, &hkOut)))
            {
                //
                //  APPCOMPAT LEGACY - order of preference - ZekeL - 22-JUL-99
                //  this is to support associations that installed empty curver
                //  keys, like microsoft project.
                //
                //  1.  curver with shell subkey
                //  2.  progid with shell subkey
                //  3.  curver without shell subkey
                //  4.  progid without shell subkey
                //
                HKEY hkShell;

                if (SUCCEEDED(_AssocOpenRegKey(hkOut, L"shell", &hkShell)))
                {
                    RegCloseKey(hkShell);
                    RegCloseKey(hkTemp);    // close old ProgID key
                }
                else if (SUCCEEDED(_AssocOpenRegKey(hkTemp, L"shell", &hkShell)))
                {
                    RegCloseKey(hkShell);
                    RegCloseKey(hkOut);
                    hkOut = hkTemp;
                }
                else
                    RegCloseKey(hkTemp);
                
            }
            else  // reset!
                hkOut = hkTemp;
        }
    }

    return hkOut;
}

HRESULT CAssocProgidElement::_InitSource()
{
    HRESULT hr = S_OK;
    //  we need to init from an extension or Progid.
    //  we also support redirection
    LPWSTR pszProgid;    
    if (_pszInit[0] == L'.')
    {
        hr = _QuerySourceCreateFromKey(HKEY_CLASSES_ROOT, _pszInit, FALSE, &_pqsExt);
        if (SUCCEEDED(hr))
            hr = _pqsExt->QueryValueString(NULL, NULL, &pszProgid);
    }
    else
        pszProgid = _pszInit;

    if (SUCCEEDED(hr))
    {
        HKEY hk = _OpenProgidKey(pszProgid);
        if (hk)
        {
            hr = _QuerySourceCreateFromKey(hk, NULL, FALSE, &_pqs);
            RegCloseKey(hk);
        }
        else
            hr = E_UNEXPECTED;

        if (pszProgid != _pszInit)
            CoTaskMemFree(pszProgid);
    }

    //  for legacy compat reasons, we support 
    //  falling back to "HKEY_CLASSES_ROOT\.ext"
    if (FAILED(hr) && _pqsExt)
    {
        _pqs = _pqsExt;
        _pqsExt = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CAssocProgidElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    HRESULT hr = CAssocShellElement::QueryString(query, pszCue, ppsz);
    if (FAILED(hr))
    {
        if ((AQF_QUERY_INITCLASS & query) && _pqsExt)
            hr = _QueryKeyValAny(_QuerySourceString, s_rgqkvExt, ARRAYSIZE(s_rgqkvExt), _pqsExt, query, pszCue, ppsz);
        else if (_pqs)
        {
            switch (query)
            {
            case AQS_FRIENDLYTYPENAME:
                //  we like to query the default value
                hr = _pqs->QueryValueString(NULL, NULL, ppsz);
                break;
            }
        }
    }
    return hr;
}

STDAPI _SHAllocLoadString(HINSTANCE hinst, int ids, PWSTR *ppsz)
{
    WCHAR sz[MAX_PATH];
    LoadStringW(hinst, ids, sz, ARRAYSIZE(sz));
    return SHStrDupW(sz, ppsz);
}
    
HRESULT CAssocFolderElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    if (query == AQS_FRIENDLYTYPENAME)
        return  _SHAllocLoadString(HINST_THISDLL, IDS_FOLDERTYPENAME, ppsz);
    else
        return CAssocShellElement::QueryString(query, pszCue, ppsz);
}

HRESULT _GetFileTypeName(PWSTR pszExt, PWSTR *ppsz)
{
    if (pszExt && pszExt[0] == L'.' && pszExt[1])
    {
        WCHAR sz[MAX_PATH];
        WCHAR szTemplate[128];   // "%s File"
        CharUpperW(pszExt);
        LoadStringW(HINST_THISDLL, IDS_EXTTYPETEMPLATE, szTemplate, ARRAYSIZE(szTemplate));
        wnsprintfW(sz, ARRAYSIZE(sz), szTemplate, pszExt + 1);
        return SHStrDupW(sz, ppsz);
    }
    else 
    {
        //  load the file description "File"
        return _SHAllocLoadString(HINST_THISDLL, IDS_FILETYPENAME, ppsz);
    }
}

HRESULT CAssocStarElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    if (query == AQS_FRIENDLYTYPENAME)
        return  _GetFileTypeName(_pszInit, ppsz);
    else
        return CAssocShellElement::QueryString(query, pszCue, ppsz);
}

HRESULT _ExeFromCmd(PWSTR  pszCommand, PWSTR  *ppsz)
{
    //  we just need to find where the params begin, and the exe ends...
    HRESULT hr = S_OK;
    PWSTR pch = PathGetArgsW(pszCommand);
    WCHAR szExe[MAX_PATH];

    if (*pch)
        *(--pch) = 0;
    else
        pch = NULL;

    StrCpyNW(szExe, pszCommand, ARRAYSIZE(szExe));
    StrTrimW(szExe, L" \t");
    PathUnquoteSpacesW(szExe);

    //
    //  WARNING:  Expensive disk hits all over!
    //
    // We check for %1 since it is what appears under (for example) HKEY_CLASSES_ROOT\exefile\shell\open\command
    // This will save us a chain of 35 calls to _PathIsFile("%1") when launching or getting a 
    // context menu on a shortcut to an .exe or .bat file.
    if (0 == StrCmpW(szExe, L"%1"))
        hr = S_FALSE;
    else if (!_PathIsFile(szExe))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        if (PathIsFileSpecW(szExe))
        {
            if (_GetAppPath(szExe, szExe, ARRAYSIZE(szExe)))
            {
                if (_PathIsFile(szExe))
                    hr = S_OK;
            }
            else if (PathFindOnPathExW(szExe, NULL, PFOPEX_DEFAULT | PFOPEX_OPTIONAL))
            {
               //  the find does a disk check for us...
               hr = S_OK;
            }
        }
        else             
        {
            //
            //  sometimes the path is not properly quoted.
            //  these keys will still work because of the
            //  way CreateProcess works, but we need to do
            //  some fiddling to figure that out.
            //

            //  if we found args, put them back...
            //  and try some different args
            while (pch)
            {
                *pch++ = L' ';

                if (pch = StrChrW(pch, L' '))
                    *pch = 0;

                StrCpyNW(szExe, pszCommand, ARRAYSIZE(szExe));
                StrTrimW(szExe, L" \t");
                if (_PathIsFile(szExe))
                {
                    hr = S_OK;

                    //  this means that we found something
                    //  but the command line was kinda screwed
                    break;

                }
            }//  while (pch)
        }
    }

    if (S_OK == hr && pch)
    {
        //  currently right before the args, on a NULL terminator
        ASSERT(!*pch);
        pch++;
        
        if (0 == StrCmpNIW(PathFindFileNameW(szExe), L"rundll", ARRAYSIZE(L"rundll") -1))
        {
            PWSTR pchComma = StrChrW(pch, L',');
            //  make the comma the beginning of the args
            if (pchComma)
                *pchComma = 0;

            if (!*(PathFindExtensionW(pch)) 
            && lstrlenW(++pchComma) > SIZECHARS(L".dll"))
            {
                StrCatW(pch, L".dll");
            }
            
            //  can we instead just do PFOPX()
            //  cuz i think that rundll just checks for 
            //  the comma
            StrCpyNW(szExe, pch, ARRAYSIZE(szExe));
            StrTrimW(szExe, L" \t");

            if (_PathIsFile(szExe)
            || PathFindOnPathExW(szExe, NULL, 0))
            {
                hr = S_OK;
            }
        }
    }

    if (SUCCEEDED(hr))
        hr = SHStrDupW(szExe, ppsz);

    return hr;
}

HRESULT CAssocShellVerbElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    HRESULT hr = CAssocElement::QueryString(query, pszCue, ppsz);
    if (FAILED(hr))
    {
        //  we havent scored yet
        switch (query)
        {
        case AQVS_DDEAPPLICATION:
            //  we make one up
            hr = QueryString(AQVS_APPLICATION_PATH, NULL, ppsz);
            if (SUCCEEDED(hr))
            {
                PathRemoveExtensionW(*ppsz);
                PathStripPathW(*ppsz);
                ASSERT(**ppsz);
            }
            break;

        case AQVS_DDETOPIC:
            hr = SHStrDupW(L"System", ppsz);
            break;

        case AQVS_APPLICATION_FRIENDLYNAME:
            //  need to delegate to the application element
            if (!_fIsApp)
            {
                IAssociationElement *pae;
                hr = _GetAppDelegate(IID_PPV_ARG(IAssociationElement, &pae));
                if (SUCCEEDED(hr))
                {
                    hr = pae->QueryString(AQVS_APPLICATION_FRIENDLYNAME, NULL, ppsz);
                    pae->Release();
                }
            }
            break;
            
        case AQVS_APPLICATION_PATH:
            {
                CSmartCoTaskMem<OLECHAR> spszCmd;
                hr = CAssocElement::QueryString(AQVS_COMMAND, NULL, &spszCmd);
                if (SUCCEEDED(hr))
                {
                    hr = _ExeFromCmd(spszCmd, ppsz);
                }
            }
        }
    }
    return hr;
}

HRESULT CAssocShellVerbElement::QueryObject(ASSOCQUERY query, PCWSTR pszCue, REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    if (query == AQVO_APPLICATION_DELEGATE)
    {
        hr = _GetAppDelegate(riid, ppv);
    }
    return hr;
}

HRESULT CAssocShellVerbElement::_GetAppDelegate(REFIID riid, void **ppv)
{
    CSmartCoTaskMem<OLECHAR> spszApp;
    HRESULT hr = QueryString(AQVS_APPLICATION_PATH, NULL, &spszApp);
    if (SUCCEEDED(hr))
    {
        IPersistString2 *pips;
        hr = AssocCreateElement(CLSID_AssocApplicationElement, IID_PPV_ARG(IPersistString2, &pips));
        if (SUCCEEDED(hr))
        {
            hr = pips->SetString(spszApp);
            if (SUCCEEDED(hr))
                hr = pips->QueryInterface(riid, ppv);
            pips->Release();
        }
    }
    return hr;
}

HRESULT CAssocPerceivedElement::_InitSource()
{
    //  maybe support Content Type?
    WCHAR sz[64];
    DWORD cb = sizeof(sz);
    if (ERROR_SUCCESS == SHGetValueW(HKEY_CLASSES_ROOT, _pszInit, L"PerceivedType", NULL, sz, &cb))
    {
        return _QuerySourceCreateFromKey2(HKEY_CLASSES_ROOT, L"SystemFileAssociations", sz, &_pqs);
    }
    return E_FAIL;
}

class CAssocClientElement : public CAssocShellElement
{
public:
    //  overload QS to return default MUI strings
    STDMETHODIMP QueryString(
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) 
        { *pclsid = CLSID_AssocClientElement; return S_OK;}

protected:    
    virtual HRESULT _InitSource();

private:
    HRESULT _InitSourceFromKey(HKEY hkRoot, LPCWSTR pszKey);
    HRESULT _FixNetscapeRegistration();
    BOOL    _CreateRepairedNetscapeRegistration(HKEY hkNSCopy);
};

HRESULT CAssocClientElement::QueryString(ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz)
{
    HRESULT hr;
    switch (query)
    {
    case AQS_FRIENDLYTYPENAME:
        // First try LocalizedString; if that fails, then use the default value
        // for backwards compatibility.
        hr = CAssocShellElement::QueryString(AQNS_NAMED_MUI_STRING, L"LocalizedString", ppsz);
        if (FAILED(hr))
        {
            hr = CAssocShellElement::QueryString(AQN_NAMED_VALUE, NULL, ppsz);
        }
        break;

    case AQS_DEFAULTICON:
        // First try DefaultIcon; if that fails then use the first icon of the EXE
        // associated with the "open" verb.
        hr = CAssocShellElement::QueryString(AQS_DEFAULTICON, pszCue, ppsz);
        if (FAILED(hr))
        {
            hr = CAssocShellElement::QueryString(AQVS_APPLICATION_PATH, L"open", ppsz);
        }
        break;


    default:
        hr = CAssocShellElement::QueryString(query, pszCue, ppsz);
        break;
    }
    return hr;
}

HRESULT CAssocClientElement::_InitSourceFromKey(HKEY hkRoot, LPCWSTR pszKey)
{
    DWORD dwType, cbSize;
    WCHAR szClient[80];
    cbSize = sizeof(szClient);
    LONG lRc = SHGetValueW(hkRoot, pszKey, NULL, &dwType, szClient, &cbSize);
    if (lRc == ERROR_SUCCESS && dwType == REG_SZ && szClient[0])
    {
        // Client info is kept in HKLM
        HRESULT hr = _QuerySourceCreateFromKey2(HKEY_LOCAL_MACHINE, pszKey, szClient, &_pqs);

        //
        //  If this is the Mail client and the client is Netscape Messenger,
        //  then we need to do extra work to detect the broken Netscape
        //  Navigator 4.75 mail client and fix its registration because
        //  Netscape registered incorrectly.  They always registered
        //  incorrectly, but since the only access point before Windows XP
        //  was an obscure menu option under IE/Tools/Mail and News, they
        //  never noticed that it was wrong.
        //
        if (SUCCEEDED(hr) &&
            StrCmpICW(_pszInit, L"mail") == 0 &&
            StrCmpICW(szClient, L"Netscape Messenger") == 0 &&
            FAILED(QueryExists(AQVS_COMMAND, L"open")))
        {
            hr = _FixNetscapeRegistration();
        }

        return hr;
    }
    else
    {
        return E_FAIL;          // no registered client
    }
}

//  Create a volatile copy of the Netscape registration and repair it.
//  We don't touch the original registration because...
//
//  1.  Its existence may break the Netscape uninstaller, and
//  2.  We may be running as non-administrator so don't have write access
//      anyway.

HRESULT CAssocClientElement::_FixNetscapeRegistration()
{
    HKEY hkMail;
    HRESULT hr = E_FAIL;

    if (ERROR_SUCCESS == RegCreateKeyExW(HKEY_CURRENT_USER, L"Software\\Clients\\Mail",
                                         0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                                         &hkMail, NULL))
    {
        HKEY hkNSCopy;
        DWORD dwDisposition;
        if (ERROR_SUCCESS == RegCreateKeyExW(hkMail, L"Netscape Messenger",
                                             0, NULL, REG_OPTION_VOLATILE, KEY_ALL_ACCESS, NULL,
                                             &hkNSCopy, &dwDisposition))
        {
            if (dwDisposition == REG_OPENED_EXISTING_KEY ||
                _CreateRepairedNetscapeRegistration(hkNSCopy))
            {
                // Now swap in the good registration for the bad one
                _pqs->Release();
                hr = _QuerySourceCreateFromKey(hkNSCopy, NULL, FALSE, &_pqs);
            }
            RegCloseKey(hkNSCopy);
        }
        if (FAILED(hr))
        {
            SHDeleteKeyW(hkMail, L"Netscape Messenger");
        }

        RegCloseKey(hkMail);
    }
    return hr;
}

LONG _RegQueryString(HKEY hk, PCWSTR pszSub, LPWSTR pszBuf, LONG cbBuf)
{
    return RegQueryValueW(hk, pszSub, pszBuf, &cbBuf);
}

LONG _RegSetVolatileString(HKEY hk, PCWSTR pszSub, LPCWSTR pszBuf)
{
    HKEY hkSub;
    LONG lRc;
    if (!pszSub || pszSub[0] == L'\0')
    {
        lRc = RegOpenKeyEx(hk, NULL, 0, KEY_WRITE, &hkSub);
    }
    else
    {

        lRc = RegCreateKeyExW(hk, pszSub,
                               0, NULL, REG_OPTION_VOLATILE, KEY_WRITE, NULL,
                               &hkSub, NULL);
    }
    if (lRc == ERROR_SUCCESS)
    {
        lRc = RegSetValueW(hkSub, NULL, REG_SZ, pszBuf, (lstrlenW(pszBuf) + 1) * sizeof(pszBuf[0]));
        RegCloseKey(hkSub);
    }
    return lRc;
}

BOOL CAssocClientElement::_CreateRepairedNetscapeRegistration(HKEY hkNSCopy)
{
    BOOL fSuccess = FALSE;
    HKEY hkSrc;

    // Sadly, we cannot use SHCopyKey because SHCopyKey does not work
    // on volatile keys.  So we just copy the keys we care about.

    WCHAR szBuf[MAX_PATH];

    if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                      L"Software\\Clients\\Mail\\Netscape Messenger",
                      0, KEY_READ, &hkSrc))
    {
        // Copy default icon but don't panic if it's not there.
        if (ERROR_SUCCESS == _RegQueryString(hkSrc, L"Protocols\\mailto\\DefaultIcon", szBuf, ARRAYSIZE(szBuf)))
        {
            // Great, Netscape also registers the wrong icon so we have to fix that too.
            PathParseIconLocationW(szBuf);
            StrCatBuffW(szBuf, L",-1349", ARRAYSIZE(szBuf));
            _RegSetVolatileString(hkNSCopy, L"DefaultIcon", szBuf);
        }

        // Copy friendly name
        if (ERROR_SUCCESS == _RegQueryString(hkSrc, NULL, szBuf, ARRAYSIZE(szBuf)) &&
            ERROR_SUCCESS == _RegSetVolatileString(hkNSCopy, NULL, szBuf))
        {
            PWSTR pszExe;
            // Copy command line, but with a new command line parameter
            if (ERROR_SUCCESS == _RegQueryString(hkSrc, L"Protocols\\mailto\\shell\\open\\command", szBuf, ARRAYSIZE(szBuf)) &&
                SUCCEEDED(_ExeFromCmd(szBuf, &pszExe)))
            {
                lstrcpynW(szBuf, pszExe, ARRAYSIZE(szBuf));
                SHFree(pszExe);
                PathQuoteSpacesW(szBuf);
                StrCatBuffW(szBuf, L" -mail", ARRAYSIZE(szBuf));
                if (ERROR_SUCCESS == _RegSetVolatileString(hkNSCopy, L"shell\\open\\command", szBuf))
                {
                    fSuccess = TRUE;
                }
            }
        }

        RegCloseKey(hkSrc);
    }
    return fSuccess;
}

HRESULT CAssocClientElement::_InitSource()
{
    // First try HKCU; if that doesn't work (no value set in HKCU or
    // the value in HKCU is bogus), then try again with HKLM.

    WCHAR szKey[MAX_PATH];
    wnsprintfW(szKey, ARRAYSIZE(szKey), L"Software\\Clients\\%s", _pszInit);

    HRESULT hr = _InitSourceFromKey(HKEY_CURRENT_USER, szKey);
    if (FAILED(hr))
    {
        hr = _InitSourceFromKey(HKEY_LOCAL_MACHINE, szKey);
    }

    return hr;
}

HRESULT AssocCreateElement(REFCLSID clsid, REFIID riid, void **ppv)
{
    IAssociationElement *pae = NULL;
    if (clsid == CLSID_AssocShellElement)
        pae = new CAssocShellElement();
    else if (clsid == CLSID_AssocProgidElement)
        pae = new CAssocProgidElement();
    else if (clsid == CLSID_AssocClsidElement)
        pae = new CAssocClsidElement();
    else if (clsid == CLSID_AssocSystemElement)
        pae = new CAssocSystemExtElement();
    else if (clsid == CLSID_AssocPerceivedElement)
        pae = new CAssocPerceivedElement();
    else if (clsid == CLSID_AssocApplicationElement)
        pae = new CAssocApplicationElement();
    else if (clsid == CLSID_AssocFolderElement)
        pae = new CAssocFolderElement();
    else if (clsid == CLSID_AssocStarElement)
        pae = new CAssocStarElement();
    else if (clsid == CLSID_AssocClientElement)
        pae = new CAssocClientElement();

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
    if (pae)
    {
        hr = pae->QueryInterface(riid, ppv);
        pae->Release();
    }
    else
        *ppv = 0;
    return hr;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\debug.c ===
#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shlwapi"
#define SZ_MODULE           "SHLWAPI"
#define DECLARE_DEBUG
#include <debug.h>


#ifdef DEBUG

/*
 * macro for simplifying result to string translation, assumes result string
 * pointer pcsz
 */

#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


#if 0
//
//  Debug value-to-string mapping functions
//


/*----------------------------------------------------------
Purpose: Return the string form of the clipboard format.

Returns: pointer to a static string
Cond:    --
*/
LPCTSTR 
Dbg_GetCFName(
    UINT ucf)
{
    LPCTSTR pcsz;
    static TCHAR s_szCFName[MAX_PATH];

    switch (ucf)
    {
        STRING_CASE(CF_TEXT);
        STRING_CASE(CF_BITMAP);
        STRING_CASE(CF_METAFILEPICT);
        STRING_CASE(CF_SYLK);
        STRING_CASE(CF_DIF);
        STRING_CASE(CF_TIFF);
        STRING_CASE(CF_OEMTEXT);
        STRING_CASE(CF_DIB);
        STRING_CASE(CF_PALETTE);
        STRING_CASE(CF_PENDATA);
        STRING_CASE(CF_RIFF);
        STRING_CASE(CF_WAVE);
        STRING_CASE(CF_UNICODETEXT);
        STRING_CASE(CF_ENHMETAFILE);
        STRING_CASE(CF_HDROP);
        STRING_CASE(CF_LOCALE);
        STRING_CASE(CF_MAX);
        STRING_CASE(CF_OWNERDISPLAY);
        STRING_CASE(CF_DSPTEXT);
        STRING_CASE(CF_DSPBITMAP);
        STRING_CASE(CF_DSPMETAFILEPICT);
        STRING_CASE(CF_DSPENHMETAFILE);

    default:
        if (! GetClipboardFormatName(ucf, s_szCFName, SIZECHARS(s_szCFName)))
            lstrcpy(s_szCFName, TEXT("UNKNOWN CLIPBOARD FORMAT"));
        pcsz = s_szCFName;
        break;
    }

    ASSERT(pcsz);

    return(pcsz);
}


LPCTSTR 
Dbg_GetHRESULTName(
    HRESULT hr)
{
    LPCTSTR pcsz;
    static TCHAR s_rgchHRESULT[] = TEXT("0x12345678");

    switch (hr)
        {
        STRING_CASE(S_OK);
        STRING_CASE(S_FALSE);

        STRING_CASE(DRAGDROP_S_CANCEL);
        STRING_CASE(DRAGDROP_S_DROP);
        STRING_CASE(DRAGDROP_S_USEDEFAULTCURSORS);

        STRING_CASE(E_UNEXPECTED);
        STRING_CASE(E_NOTIMPL);
        STRING_CASE(E_OUTOFMEMORY);
        STRING_CASE(E_INVALIDARG);
        STRING_CASE(E_NOINTERFACE);
        STRING_CASE(E_POINTER);
        STRING_CASE(E_HANDLE);
        STRING_CASE(E_ABORT);
        STRING_CASE(E_FAIL);
        STRING_CASE(E_ACCESSDENIED);

        STRING_CASE(CLASS_E_NOAGGREGATION);

        STRING_CASE(CO_E_NOTINITIALIZED);
        STRING_CASE(CO_E_ALREADYINITIALIZED);
        STRING_CASE(CO_E_INIT_ONLY_SINGLE_THREADED);

        STRING_CASE(DV_E_DVASPECT);
        STRING_CASE(DV_E_LINDEX);
        STRING_CASE(DV_E_TYMED);
        STRING_CASE(DV_E_FORMATETC);

#ifdef __INTSHCUT_H__

        STRING_CASE(E_FLAGS);

        STRING_CASE(URL_E_INVALID_SYNTAX);
        STRING_CASE(URL_E_UNREGISTERED_PROTOCOL);

        STRING_CASE(IS_E_EXEC_FAILED);

        STRING_CASE(E_FILE_NOT_FOUND);
        STRING_CASE(E_PATH_NOT_FOUND);

#endif

    default:
        wsprintf(s_rgchHRESULT, TEXT("%#lx"), hr);
        pcsz = s_rgchHRESULT;
        break;
        }

    ASSERT(IS_VALID_STRING_PTR(pcsz, -1));

    return(pcsz);
}


#define STRING_RIID(val)               { &val, TEXT(#val) }

struct 
    {
    REFIID riid;
    LPCTSTR psz;
    } const c_mpriid[] = 
        {
        STRING_RIID(IID_IUnknown),
        STRING_RIID(IID_IEnumUnknown),
        STRING_RIID(IID_IShellBrowser),
        STRING_RIID(IID_IShellView),
        STRING_RIID(IID_IContextMenu),
        STRING_RIID(IID_IShellFolder),
        STRING_RIID(IID_IShellExtInit),
        STRING_RIID(IID_IShellPropSheetExt),
        STRING_RIID(IID_IPersistFolder),
        STRING_RIID(IID_IExtractIcon),
        STRING_RIID(IID_IShellLink),
        STRING_RIID(IID_IDataObject),
        STRING_RIID(IID_IContextMenu2),
        STRING_RIID(IID_INewShortcutHook),
        STRING_RIID(IID_IPersist),
        STRING_RIID(IID_IPersistStream),
        STRING_RIID(IID_IUniformResourceLocator),
        };


LPCTSTR
Dbg_GetREFIIDName(
    REFIID riid)
{
    int i;

    for (i = 0; i < ARRAYSIZE(c_mpriid); i++)
        {
        if (IsEqualIID(riid, c_mpriid[i].riid))
            return c_mpriid[i].psz;
        }

    return TEXT("Unknown REFIID");
}

#endif

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\dll.c ===
/***************************************************************************
 *  dll.c
 *
 *  Standard DLL entry-point functions
 *
 ***************************************************************************/

#include "priv.h"
#include <ntverp.h>

//
// Downlevel delay load support (need to link to dload.lib)
//
#include <delayimp.h>

EXTERN_C
FARPROC
WINAPI
Downlevel_DelayLoadFailureHook(
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    );

PfnDliHook __pfnDliFailureHook = Downlevel_DelayLoadFailureHook;
HANDLE BaseDllHandle;

#define MLUI_INIT
#include <mluisupp.h>

BOOL g_bRunningOnNT = FALSE;
BOOL g_bRunningOnNT5OrHigher = FALSE;
BOOL g_bRunningOnMemphis = FALSE;
HINSTANCE g_hinst = NULL;
CRITICAL_SECTION g_csDll = {0};
DWORD g_TpsTls = (UINT)-1;
DWORD g_tlsThreadRef  = (UINT)-1;
DWORD g_tlsOtherThreadsRef  = (UINT)-1;
BOOL g_bDllTerminating = FALSE;

#ifdef DEBUG
//#define PROOFREAD_PARSES
#endif

#ifdef PROOFREAD_PARSES
enum
{
    PP_COMPARE,
    PP_ORIGINAL_ONLY,
    PP_NEW_ONLY
};


DWORD g_dwProofMode = PP_COMPARE;

#endif // PROOFREAD_PARSES

void TermPalette();
void DeinitPUI();
void FreeViewStatePropertyBagCache();
void FreeDynamicLibraries();
STDAPI_(void) FreeGlobalSecurityAttributes();
STDAPI_(void) InitTimerQueue();

//
//  Table of all window classes we register so we can unregister them
//  at DLL unload.
//
//  Since we are single-binary, we have to play it safe and do
//  this cleanup (needed only on NT, but harmless on Win95).
//
const LPCTSTR c_rgszClasses[] = {
    TEXT("WorkerA"),                        // util.cpp
    TEXT("WorkerW"),                        // util.cpp
    TEXT("WorkerW"),                        // util.cpp
};

//
// Global DCs used during mirroring an Icon.
//
HDC g_hdc = NULL, g_hdcMask = NULL;
BOOL g_bMirroredOS = FALSE;

STDAPI_(void) InitShellKeys(BOOL fInit);
#ifndef NO_ETW_TRACING
ULONG UnRegisterTracing();
#endif

BOOL APIENTRY DllMain(IN HANDLE hDll, IN DWORD dwReason, IN LPVOID lpReserved)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);

#ifdef DEBUG
        CcshellGetDebugFlags();
#endif
        InitializeCriticalSection(&g_csDll);   // for later use

        BaseDllHandle = hDll;   // for delayload
        g_hinst = hDll;
        MLLoadResources(g_hinst, TEXT("shlwaplc.dll"));
        g_bRunningOnNT = IsOS(OS_NT);
        g_bRunningOnNT5OrHigher = IsOS(OS_WIN2000ORGREATER);
        g_bRunningOnMemphis = IsOS(OS_WIN98ORGREATER);

        InitStopWatchMode();    // See if perf mode is enabled
        InitTimerQueue();

        // Check if we are running on a system that supports the mirroring APIs
        // i.e. (NT5 or Memphis/BiDi)
        //
        g_bMirroredOS = IS_MIRRORING_ENABLED();
        g_TpsTls = TlsAlloc();
        g_tlsThreadRef = TlsAlloc();
        g_tlsOtherThreadsRef = TlsAlloc();

        InitShellKeys(TRUE);
        
#ifdef PROOFREAD_PARSES
        {
            DWORD dwSize = sizeof(g_dwProofMode);
            if (ERROR_SUCCESS != SHGetValue( HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                TEXT("Verify URLCombine"), NULL, &g_dwProofMode, &dwSize) ||
                (g_dwProofMode > PP_NEW_ONLY))
            {
                g_dwProofMode = PP_COMPARE;
            }
        }
#endif
        break;

    case DLL_PROCESS_DETACH:
        g_bDllTerminating = TRUE;
        MLFreeResources(g_hinst);
        if (lpReserved == NULL)
        {
            DeinitPUI();            // free up plug ui resource hinstance dpa table
            FreeViewStatePropertyBagCache();
        }

        //
        // Icon mirroring stuff (see mirror.c)
        // Cleanup cached DCs. No need to synchronize the following section of
        // code since it is only called in DLL_PROCESS_DETACH which is
        // synchronized by the OS Loader.
        //
        if (g_bMirroredOS)
        {
            if (g_hdc)
                DeleteDC(g_hdc);

            if (g_hdcMask)
                DeleteDC(g_hdcMask);

            g_hdc = g_hdcMask = NULL;
        }
        
        FreeGlobalSecurityAttributes();
        TermPalette();
        if (StopWatchMode()) {
            StopWatchFlush();   // Flush the performance timing data to disk
#ifndef NO_ETW_TRACING
            // If any event tracing controls are enabled, this cleans them up.
            UnRegisterTracing();
#endif
        }
        DeleteCriticalSection(&g_csDll);

        if (lpReserved == NULL) 
        {
            SHTerminateThreadPool();
            SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses));
#ifdef I_WANT_WIN95_TO_CRASH
            // If you call FreeLibrary during PROCESS_ATTACH, Win95 will crash
            FreeDynamicLibraries();
#endif
        }

        if (g_TpsTls != (UINT)-1)
            TlsFree(g_TpsTls);

        if (g_tlsThreadRef != (UINT)-1)
            TlsFree(g_tlsThreadRef);

        if (g_tlsOtherThreadsRef != (UINT)-1)
            TlsFree(g_tlsOtherThreadsRef);

        InitShellKeys(FALSE);

        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        ASSERT(0);  // We shouldn't get these because we called DisableThreadLibraryCalls().
        break;

    default:
        break;
    }

    return TRUE;
}


// DllGetVersion
//
// All we have to do is declare this puppy and CCDllGetVersion does the rest
//
DLLVER_SINGLEBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\fstream.cpp ===
#include "priv.h"
#include "apithk.h"

#ifdef _X86_
#include <w95wraps.h>
#endif

class CFileStream : public IStream
{
public:
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // IStream
    STDMETHOD(Read) (THIS_ void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write) (THIS_ void const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo) (THIS_ IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags);
    STDMETHOD(Revert) (THIS);
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat) (THIS_ STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(THIS_ IStream **ppstm);

    CFileStream(HANDLE hf, DWORD grfMode, LPCWSTR pszName);

private:
    ~CFileStream();
    HRESULT InternalCommit(DWORD grfCommitFlags, BOOL fSendChange);

    LONG        _cRef;           // Reference count
    HANDLE      _hFile;          // the file.
    DWORD       _grfMode;        // The mode that we opened the file in.
    BOOL        _fLastOpWrite;   // The last operation was a write.

    ULONG       _iBuffer;        // Index in Buffer
    ULONG       _cbBufLen;       // length of buffer if reading
    BYTE        _bBuffer[4096];  // buffer

    WCHAR       _szName[MAX_PATH]; // file name in case someone calls Stat
};

CFileStream::CFileStream(HANDLE hf, DWORD grfMode, LPCWSTR pszName) : _cRef(1), _hFile(hf), _grfMode(grfMode)
{
    ASSERT(_cbBufLen == 0);
    ASSERT(_iBuffer == 0);
    ASSERT(_fLastOpWrite == FALSE);

    StrCpyNW(_szName, pszName, ARRAYSIZE(_szName));
}

CFileStream::~CFileStream()
{
    if (_fLastOpWrite)
    {
        InternalCommit(0, TRUE);
    }

    ASSERT(_hFile != INVALID_HANDLE_VALUE);
    CloseHandle(_hFile);
}

STDMETHODIMP CFileStream::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CFileStream, IStream),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFileStream::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFileStream::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CFileStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    ULONG cbReadRequestSize = cb;
    ULONG cbT, cbRead;
    HRESULT hr = S_OK;

    // Have we write since our last read?
    if (_fLastOpWrite == TRUE)
    {
        hr = InternalCommit(0, FALSE);
        if (FAILED(hr))
        {
            if (pcbRead)
                *pcbRead = 0;
            return hr;
        }
    }

    _fLastOpWrite = FALSE;

    while (cb > 0)
    {
        // Assert if we are beyond the bufferlen and Not sizeof(_bBuffer) which
        // would imply a seek happened...
        ASSERT((_iBuffer <= _cbBufLen) || (_iBuffer == sizeof(_bBuffer)));

        if (_iBuffer < _cbBufLen)
        {
            cbT = _cbBufLen - _iBuffer;

            if (cbT > cb)
                cbT = cb;

            memcpy(pv, &_bBuffer[_iBuffer], cbT);
            _iBuffer += cbT;
            cb -= cbT;

            if (cb == 0)
                break;

            (BYTE *&)pv += cbT;
        }

        // Buffer's empty.  Handle rest of large reads directly...
        //
        if (cb > sizeof(_bBuffer))
        {
            cbT = cb - cb % sizeof(_bBuffer);
            if (!ReadFile(_hFile, pv, cbT, &cbRead, NULL))
            {
                DebugMsg(DM_TRACE, TEXT("Stream read IO error %d"), GetLastError());
                hr = ResultFromLastError();
                break;
            }

            cb -= cbRead;
            (BYTE *&)pv += cbRead;

            if (cbT != cbRead)
                break;          // end of file
        }

        if (cb == 0)
            break;

        // was the last read a partial read?  if so we are done
        //
        if (_cbBufLen > 0 && _cbBufLen < sizeof(_bBuffer))
        {
            // DebugMsg(DM_TRACE, "Stream is empty");
            break;
        }

        // Read an entire buffer's worth.  We may try to read past EOF,
        // so we must only check for != 0...
        //
        if (!ReadFile(_hFile, _bBuffer, sizeof(_bBuffer), &cbRead, NULL))
        {
            DebugMsg(DM_TRACE, TEXT("Stream read IO error 2 %d"), GetLastError());
            hr = ResultFromLastError();
            break;
        }

        if (cbRead == 0)
            break;

        _iBuffer = 0;
        _cbBufLen = cbRead;
    }

    if (pcbRead)
        *pcbRead = cbReadRequestSize - cb;

    if (cb != 0)
    {
        // DebugMsg(DM_TRACE, "CFileStream::Read() incomplete read");
        hr = S_FALSE; // still success! but not completely
    }

    return hr;
}

STDMETHODIMP CFileStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
    ULONG cbRequestedWrite = cb;
    ULONG cbT;
    HRESULT hr = S_OK;

    if (!((_grfMode & STGM_WRITE) || (_grfMode & STGM_READWRITE)))
    {
        // Can't write to a stream that we didn't open for write access
        return STG_E_ACCESSDENIED;
    }

    // Have we read since our last write?
    if (_fLastOpWrite == FALSE && _iBuffer < _cbBufLen)
    {
        // Need to reset the file pointer so that this write goes to the right spot
        SetFilePointer(_hFile, -(int)(_cbBufLen - _iBuffer), NULL, STREAM_SEEK_CUR);
        _iBuffer = 0;
        _cbBufLen = 0;
    }

    while (cb > 0)
    {
        if (_iBuffer < sizeof(_bBuffer))
        {
            cbT = min((ULONG)(sizeof(_bBuffer) - _iBuffer), cb);

            memcpy(&_bBuffer[_iBuffer], pv, cbT);
            _iBuffer += cbT;
            cb -= cbT;

            _fLastOpWrite = TRUE;

            if (cb == 0)
                break;

            (BYTE *&)pv += cbT;
        }

        hr = InternalCommit(0, FALSE);
        if (FAILED(hr))
            break;

        if (cb > sizeof(_bBuffer))
        {
            ULONG cbWrite;

            cbT = cb - cb % sizeof(_bBuffer);

            if (!WriteFile(_hFile, pv, cbT, &cbWrite, NULL))
            {
                DebugMsg(DM_TRACE, TEXT("Stream write IO error 2, %d"), GetLastError());
                hr = ResultFromLastError();
                break;
            }

            cb -= cbWrite;
            (BYTE *&)pv += cbWrite;

            if (cbWrite != cbT)
                break;          // media full, we are done
        }
    }

    if (pcbWritten)
        *pcbWritten = cbRequestedWrite - cb;

    if ((cb != 0) && (hr == S_OK))
    {
        DebugMsg(DM_TRACE, TEXT("CFileStream::Write() incomplete"));
        hr = S_FALSE; // still success! but not completely
    }

    return hr;
}

STDMETHODIMP CFileStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    COMPILETIME_ASSERT(FILE_BEGIN   == STREAM_SEEK_SET);
    COMPILETIME_ASSERT(FILE_CURRENT == STREAM_SEEK_CUR);
    COMPILETIME_ASSERT(FILE_END     == STREAM_SEEK_END);

    HRESULT hr = S_OK;
    LARGE_INTEGER liOut;

    // Have we written since our last read?
    if (_fLastOpWrite == TRUE)
    {
        hr = InternalCommit(0, FALSE);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (_iBuffer < _cbBufLen)
    {
        // Need to reset the file pointer to point to the right place
        SetFilePointer(_hFile, -(int)(_cbBufLen - _iBuffer), NULL, STREAM_SEEK_CUR);
    }

    // Invalidate the buffer because we may move the file pointer
    _iBuffer = 0;
    _cbBufLen = 0;     // Say we have not read it yet.

    if (NT5_SetFilePointerEx(_hFile, dlibMove, &liOut, dwOrigin))
    {
        // Some callers pass NULL for the plibNewPosition parameter
        // in the IStream::Seek() call.  \shell32\filetbl.c, _IconCacheSave()
        // is an example.
        if (plibNewPosition)
        {
            // SetFilePointerEx takes a LARGE_INTEGER, but Seek takes a ULARGE_INTEGER, Why the difference?
            plibNewPosition->QuadPart = liOut.QuadPart;
        }
    }
    else
    {
        hr = ResultFromLastError();
    }

    return hr;
}

STDMETHODIMP CFileStream::SetSize(ULARGE_INTEGER libNewSize)
{
    if (IsOS(OS_WHISTLERORGREATER))
    {
        HRESULT hr = E_FAIL;
        // First save away the pointer's position
        LARGE_INTEGER pos, test;
        LARGE_INTEGER zero = {0};
        if (NT5_SetFilePointerEx(_hFile, zero, &pos, FILE_CURRENT))
        {
            if (libNewSize.HighPart != 0)
            {
                hr = STG_E_INVALIDFUNCTION;
            }
            else
            {
                // Now set the size
                LARGE_INTEGER largeint;
                largeint.HighPart = 0;
                largeint.LowPart = libNewSize.LowPart;
                if (NT5_SetFilePointerEx(_hFile, largeint, &test, FILE_BEGIN) &&
                    SetEndOfFile(_hFile))
                {
                    // Reset the file pointer position
                    if (NT5_SetFilePointerEx(_hFile, pos, &test, FILE_BEGIN))
                    {
                        hr = S_OK;
                    }
                }
            }
        }
        return hr;
    }
    else
        return E_NOTIMPL;
}

//
// REVIEW: this could use the internal buffer in the stream to avoid
// extra buffer copies.
//
STDMETHODIMP CFileStream::CopyTo(IStream *pstmTo, ULARGE_INTEGER cb,
             ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    HRESULT hr = S_OK;

    if (pcbRead)
        pcbRead->QuadPart = 0;

    if (pcbWritten)
        pcbWritten->QuadPart = 0;

    //
    // I'd like to use a buffer size that takes about a second to copy 
    // for the sake of cancel opportunities, but IStream doesn't give
    // me useful info like the stream speed. 
    //

    const DWORD cbBuffer = 0x00010000;

    //
    // Alloc the buffer and begin the copy
    //
        
    BYTE * pBuf = (BYTE *) LocalAlloc(LPTR, cbBuffer);
    if (!pBuf)
        return E_OUTOFMEMORY;

    while (cb.QuadPart)
    {
        //
        // Cast is OK because we know sizeof(buf) fits in a ULONG
        //

        ULONG cbRead = (ULONG)min(cb.QuadPart, cbBuffer);
        hr = Read(pBuf, cbRead, &cbRead);

        if (pcbRead)
            pcbRead->QuadPart += cbRead;

        if (FAILED(hr) || (cbRead == 0))
            break;

        cb.QuadPart -= cbRead;

        hr = pstmTo->Write(pBuf, cbRead, &cbRead);

        if (pcbWritten)
            pcbWritten->QuadPart += cbRead;

        if (FAILED(hr) || (cbRead == 0))
            break;
    }
    LocalFree(pBuf);

    // ISSUE
    // 
    // This was here when I got here, but from the SDK I don't see
    // why we'd accept S_FALSE as "complete success"

    if (S_FALSE == hr)
        hr = S_OK;      

    return hr;
}

STDMETHODIMP CFileStream::Commit(DWORD grfCommitFlags)
{
    return InternalCommit(grfCommitFlags, TRUE);
}

HRESULT CFileStream::InternalCommit(DWORD grfCommitFlags, BOOL fSendChange)
{
    if (_fLastOpWrite)
    {
        if (_iBuffer > 0)
        {
            DWORD cbWrite;
            WriteFile(_hFile, _bBuffer, _iBuffer, &cbWrite, NULL);
            if (cbWrite != _iBuffer)
            {
                DebugMsg(DM_TRACE, TEXT("CFileStream::Commit() incomplete write %d"), GetLastError());
                return STG_E_MEDIUMFULL;
            }
            _iBuffer = 0;

            if (fSendChange)
            {
                SHChangeNotifyWrap(SHCNE_UPDATEITEM, SHCNF_PATHW, _szName, NULL);
            }
        }

        // Since we committed already, we don't need to commit again until the next write, so assume read
        _fLastOpWrite = FALSE;
    }

    return S_OK;
}

STDMETHODIMP CFileStream::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    if ( !pstatstg )
        return STG_E_INVALIDPOINTER;

    ZeroMemory(pstatstg, sizeof(STATSTG));  // per COM conventions

    HRESULT hr = E_FAIL;
    BY_HANDLE_FILE_INFORMATION bhfi;

    if ( GetFileInformationByHandle(_hFile, &bhfi) )
    {
        if (grfStatFlag & STATFLAG_NONAME)
            hr = S_OK;
        else
            hr = SHStrDupW(PathFindFileNameW(_szName), &pstatstg->pwcsName);

        if (SUCCEEDED(hr))
        {
            pstatstg->type = STGTY_STREAM;
            pstatstg->cbSize.HighPart = bhfi.nFileSizeHigh;
            pstatstg->cbSize.LowPart = bhfi.nFileSizeLow;
            pstatstg->mtime = bhfi.ftLastWriteTime;
            pstatstg->ctime = bhfi.ftCreationTime;
            pstatstg->atime = bhfi.ftLastAccessTime;
            pstatstg->grfMode = _grfMode;
            pstatstg->reserved = bhfi.dwFileAttributes;
        }
    }
    return hr;
}

STDMETHODIMP CFileStream::Clone(IStream **ppstm)
{
    return E_NOTIMPL;
}


// create an IStream from a Win32 file name.
// in:
//      pszFile     file name to open
//      grfMode     STGM_ flags
//

// We export a W version of this function
//
STDAPI SHCreateStreamOnFileW(LPCWSTR pszFile, DWORD grfMode, IStream **ppstm)
{
    *ppstm = NULL;

    // NOTE: these interpretations of the STGM bits are not done properly
    // but to maintain back compat we have to allow the invalid combinations
    // and not enforce the share bits right. use SHCreateStreamOnFileEx() to get
    // proper STGM bit support

    if (grfMode &
        ~(STGM_READ             |
          STGM_WRITE            |
          STGM_SHARE_DENY_NONE  |
          STGM_SHARE_DENY_READ  |
          STGM_SHARE_DENY_WRITE |
          STGM_SHARE_EXCLUSIVE  |
          STGM_READWRITE        |
          STGM_CREATE         ))
    {
        DebugMsg(DM_ERROR, TEXT("CreateSreamOnFile: Invalid STGM_ mode"));
        return E_INVALIDARG;
    }

    HANDLE hFile;
    BOOL fCreated = FALSE;
    if ( grfMode & STGM_CREATE)
    {
        // Need to get the file attributes of the file first, so
        // that CREATE_ALWAYS will succeed for HIDDEN and SYSTEM
        // attributes.
        DWORD dwAttrib = GetFileAttributesW(pszFile);
        if ((DWORD)-1 == dwAttrib )
        {
            // something went wrong, so set attributes to something
            // normal before we try to create the file...
            dwAttrib = 0;
            fCreated = TRUE;
        }

        // STGM_CREATE
        hFile = CreateFileW(pszFile, GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,
            dwAttrib, NULL);
    }
    else
    {
        DWORD dwDesiredAccess, dwShareMode, dwShareBits;

        // not STGM_CREATE
        if ( grfMode & STGM_WRITE )
        {
            dwDesiredAccess = GENERIC_WRITE;
        }
        else
        {
            dwDesiredAccess = GENERIC_READ;
        }
        if ( grfMode & STGM_READWRITE )
        {
            dwDesiredAccess |= (GENERIC_READ | GENERIC_WRITE);
        }
        dwShareBits = grfMode & (STGM_SHARE_EXCLUSIVE | 
                                 STGM_SHARE_DENY_WRITE | 
                                 STGM_SHARE_DENY_READ | 
                                 STGM_SHARE_DENY_NONE);
        switch( dwShareBits ) 
        {
        case STGM_SHARE_DENY_WRITE:
            dwShareMode = FILE_SHARE_READ;
            break;
        case STGM_SHARE_DENY_READ:
            dwShareMode = FILE_SHARE_WRITE;
            break;
        case STGM_SHARE_EXCLUSIVE:
            dwShareMode = 0;
            break;
        default:
            dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
            break;
        }
        hFile = CreateFileW(pszFile, dwDesiredAccess, dwShareMode, NULL, OPEN_EXISTING, 0, NULL);
    }

    HRESULT hr;
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if ((grfMode & STGM_CREATE) && fCreated)
        {
            SHChangeNotifyWrap(SHCNE_CREATE, SHCNF_PATHW, pszFile, NULL);
        }

        *ppstm = (IStream *)new CFileStream(hFile, grfMode, pszFile);
        if (*ppstm)
        {
            hr = S_OK;
        }
        else
        {
            CloseHandle(hFile);
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("CreateSreamOnFile: CreateFileW() failed %s"), pszFile);
        hr = ResultFromLastError();
    }
    return hr;
}

// We export an A version of this function
STDAPI SHCreateStreamOnFileA(LPCSTR pszFile, DWORD grfMode, IStream **ppstm)
{
    WCHAR szFile[MAX_PATH];

    SHAnsiToUnicode(pszFile, szFile, ARRAYSIZE(szFile));
    return SHCreateStreamOnFileW(szFile, grfMode, ppstm);
}

STDAPI ModeToCreateFileFlags(DWORD grfMode, BOOL fCreate, DWORD *pdwDesiredAccess, DWORD *pdwShareMode, DWORD *pdwCreationDisposition)
{
    HRESULT hr = S_OK;

    *pdwDesiredAccess = *pdwShareMode = *pdwCreationDisposition = 0;

    switch (grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE))
    {
    case STGM_READ:
        *pdwDesiredAccess |= GENERIC_READ;
        break;

    case STGM_WRITE:
        *pdwDesiredAccess |= GENERIC_WRITE;
        break;

    case STGM_READWRITE:
        *pdwDesiredAccess |= GENERIC_READ | GENERIC_WRITE;
        break;

    default:
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if (SUCCEEDED(hr))
    {
        switch (grfMode & (STGM_SHARE_DENY_NONE | STGM_SHARE_DENY_READ | STGM_SHARE_DENY_WRITE | STGM_SHARE_EXCLUSIVE))
        {
        case STGM_SHARE_DENY_READ:
            *pdwShareMode = FILE_SHARE_WRITE | FILE_SHARE_DELETE;
            break;

        case STGM_SHARE_DENY_WRITE:
            *pdwShareMode = FILE_SHARE_READ;
            break;

        case STGM_SHARE_EXCLUSIVE:
            *pdwShareMode = 0;
            break;

        case STGM_SHARE_DENY_NONE:
        default:
            // assume STGM_SHARE_DENY_NONE as per documentation
            *pdwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
        }

        if (SUCCEEDED(hr))
        {
            switch (grfMode & (STGM_CREATE | STGM_FAILIFTHERE))
            {
            case STGM_CREATE:
                *pdwCreationDisposition = CREATE_ALWAYS;
                break;

            case STGM_FAILIFTHERE:  // this is a 0 flag
                *pdwCreationDisposition = fCreate ? CREATE_NEW : OPEN_EXISTING;
                break;

            default:
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            }
        }
    }

    return hr;
}

// similar to SHCreateStreamOnFile() but
//  1) properly maps STGM bits into CreateFile() params
//  2) takes dwAttributes for the STGM_CREATE case so you can create the file
//     with known attributes

// NOTE: returns WIN32 errors from GetLastError through the HRESULT, NOT STG errors.
STDAPI SHCreateStreamOnFileEx(LPCWSTR pszFile, DWORD grfMode, DWORD dwAttributes, BOOL fCreate, IStream * pstmTemplate, IStream **ppstm)
{
    *ppstm = NULL;

    DWORD dwDesiredAccess, dwShareMode, dwCreationDisposition;
    HRESULT hr = ModeToCreateFileFlags(grfMode, fCreate, &dwDesiredAccess, &dwShareMode, &dwCreationDisposition);
    if (SUCCEEDED(hr))
    {
        HANDLE hFile = CreateFileW(pszFile, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwAttributes, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            DWORD dwErr = GetLastError();

            // for some reason CreateFile is dumb and doesn't perform to spec here (?)
            if ((dwErr == ERROR_ACCESS_DENIED) &&
                (dwCreationDisposition == CREATE_NEW) &&
                PathFileExistsW(pszFile))
            {
                dwErr = ERROR_ALREADY_EXISTS;
            }

            hr = HRESULT_FROM_WIN32(dwErr);
        }
        else
        {
            if ((CREATE_NEW == dwCreationDisposition) || (CREATE_ALWAYS == dwCreationDisposition))
            {
                SHChangeNotifyWrap(SHCNE_CREATE, SHCNF_PATHW, pszFile, NULL);
            }

            *ppstm = (IStream *)new CFileStream(hFile, grfMode, pszFile);
            if (*ppstm)
            {
                hr = S_OK;
            }
            else
            {
                CloseHandle(hFile);
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}


// maps win32 errors from SHCreateStreamOnFileEx into STG error codes, for
// use in IStorage/IStream implementations.
HRESULT MapWin32ErrorToSTG(HRESULT hrIn)
{
    HRESULT hr = hrIn;

    if (FAILED(hr))
    {
        // munge some of the failure cases back into the STG error values
        // that are expected.
        switch (hr)
        {
        case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
        case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
            hr = STG_E_FILENOTFOUND;
            break;

        case HRESULT_FROM_WIN32(ERROR_FILE_EXISTS):
        case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
            hr = STG_E_FILEALREADYEXISTS;
            break;

        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
            hr = STG_E_ACCESSDENIED;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\gcount.cpp ===
//
// Global counters
//
//

#include "priv.h"

//
// #defines
//
#ifdef DEBUG
#define GLOBAL_COUNTER_WAIT_TIMEOUT 30*1000  // on debug we set this to 30 seconds
#else
#define GLOBAL_COUNTER_WAIT_TIMEOUT 0        // on retail its zero so we test the objects state and return immedaeately
#endif

//
// Globals 
//
SECURITY_ATTRIBUTES g_sa;
SECURITY_DESCRIPTOR* g_psd = NULL;



//
// this function allocates the g_psd and fills in the g_sa
//
STDAPI_(BOOL) AllocGlobalSecurityAttributes()
{
    BOOL bRet;
    SHELL_USER_PERMISSION supEveryone;
    SHELL_USER_PERMISSION supSystem;
    SHELL_USER_PERMISSION supAdministrators;
    PSHELL_USER_PERMISSION apUserPerm[3] = {&supEveryone, &supAdministrators, &supSystem};

    //
    //  There are three kinds of null-type DACLs.
    //
    //  1. No DACL.  This means that we inherit the ambient DACL
    //     from our thread.
    //  2. Null DACL.  This means "full access to everyone".
    //  3. Empty DACL.  This means "deny all access to everyone".
    //
    //  NONE of these are correct for our needs. We used to use Null DACL's (2), 
    //  but the issue with these is that someone can change the ACL on the object
    //  locking us out. 
    // 
    //  So now we create a specific DACL with 3 ACE's in it:
    //
    //          ACE #1: Everyone        - GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE
    //          ACE #2: SYSTEM          - GENERIC_ALL (full control)
    //          ACE #3: Administrators  - GENERIC_ALL (full control)
    //

    // we want the everyone to have read, write, exec and sync only 
    supEveryone.susID = susEveryone;
    supEveryone.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supEveryone.dwAccessMask = (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE);
    supEveryone.fInherit = FALSE;
    supEveryone.dwInheritMask = 0;
    supEveryone.dwInheritAccessMask = 0;

    // we want the SYSTEM to have full control
    supSystem.susID = susSystem;
    supSystem.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supSystem.dwAccessMask = GENERIC_ALL;
    supSystem.fInherit = FALSE;
    supSystem.dwInheritMask = 0;
    supSystem.dwInheritAccessMask = 0;

    // we want the Administrators to have full control
    supAdministrators.susID = susAdministrators;
    supAdministrators.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supAdministrators.dwAccessMask = GENERIC_ALL;
    supAdministrators.fInherit = FALSE;
    supAdministrators.dwInheritMask = 0;
    supAdministrators.dwInheritAccessMask = 0;

    // allocate the global SECURITY_DESCRIPTOR
    g_psd = GetShellSecurityDescriptor(apUserPerm, ARRAYSIZE(apUserPerm));

    if (!g_psd)
    {
        TraceMsg(TF_WARNING, "InitGlobalSecurityAttributes: failed to create g_psd!");
        bRet = FALSE;
    }
    else
    {
        // we successfully alloced the g_psd, so set it into the g_sa
        // NOTE: we will free g_psd at process detach
        g_sa.nLength = sizeof(g_sa);
        g_sa.lpSecurityDescriptor = g_psd;
        g_sa.bInheritHandle = FALSE;

        bRet = TRUE;
    }

    return bRet;
}


//
// called at process detach to release our global g_psd
//
STDAPI_(void) FreeGlobalSecurityAttributes()
{
    if (g_psd)
    {
        ASSERT(g_sa.lpSecurityDescriptor == g_psd); // sanity check
        LocalFree(g_psd);
    }
}


//
// Helper function that clones an ACL
//
PACL CloneACL(const ACL* pAclSource)
{
    PACL pAclClone = (PACL)LocalAlloc(LPTR, pAclSource->AclSize);

    if (pAclClone)
    {
        CopyMemory((void*)pAclClone, (const void*)pAclSource, pAclSource->AclSize);
    }

    return pAclClone;
}


//
// This function fills in a SECURITY_ATTRIBUTES struct such that it will be full access to everyone.
// This is needed when multiple processes need access to the same named kernel objects.
//
// You should always pass (NULL, NULL, NULL) to this function for perf! (will return global security object)
//
// NOTE: for older callers who pass a non-null ppacl, must LocalFree it
//
STDAPI_(SECURITY_ATTRIBUTES*) CreateAllAccessSecurityAttributes(SECURITY_ATTRIBUTES* psa, SECURITY_DESCRIPTOR* psd, PACL* ppacl)
{
    static BOOL s_bCreatedGlobalSA = FALSE;

    // Win9x doesn't use dacls
    if (!g_bRunningOnNT)
    {
        return NULL;
    }

#ifdef DEBUG
    // only rip on whistler or greater since the old ie55/ie6 code was lame
    if (IsOS(OS_WHISTLERORGREATER))
    {
        // NOTE: (reinerf) - no shell caller should ever pass anything but NULL's to this api!
        RIPMSG(!(psa || psd || ppacl), "CreateAllAccessSecurityAttributes: ALL callers should pass (NULL, NULL, NULL) for params!");
    }
#endif

    // always set this to null, we return a refrence to g_psd which 
    // contains the ACL and we never want the user to free anything
    if (ppacl)
    {
        *ppacl = NULL;
    }

    if (!s_bCreatedGlobalSA)
    {
        // we have not inited g_sa, so do so now.
        ENTERCRITICAL;
        // check again within the critsec
        if (!s_bCreatedGlobalSA)
        {
            if (AllocGlobalSecurityAttributes())
            {
                s_bCreatedGlobalSA = TRUE;
            }
        }
        LEAVECRITICAL;

        if (!s_bCreatedGlobalSA)
        {
            // failed to create the global! doh!
            return NULL;
        }

        // if we got this far, this had better be created
        ASSERT(g_psd);
    }

    // check to see if an older caller passed in non-null params
    if (psa)
    {
        PACL pAcl = CloneACL(g_psd->Dacl);

        if (pAcl &&
            InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION) &&
            SetSecurityDescriptorDacl(psd, TRUE, pAcl, FALSE))
        {
            psa->nLength = sizeof(*psa);
            psa->lpSecurityDescriptor = psd;
            psa->bInheritHandle = FALSE;

            if (ppacl)
            {
                *ppacl = pAcl;
            }

            // NOTE: (reinerf) - we used to call LocalFree(pAcl) if the caller passed null for ppacl.
            // This is a bad thing to do since SetSecurityDescriptor sets a refrence to the ACL instead
            // of copying it. Better to leak it... :-(
        }
        else
        {
            return NULL;
        }

        return psa;
    }
    else
    {

        // for newer callers (who pass all NULL's), we just return a refrence to our global
        return &g_sa;
    }
}


//
// This lets the user pass an ANSI String as the name of the global counter, as well as an inital value
//
STDAPI_(HANDLE) SHGlobalCounterCreateNamedA(LPCSTR szName, LONG lInitialValue)
{
    HANDLE hSem;
    //
    //  Explicitly ANSI so it runs on Win95.
    //
    char szCounterName[MAX_PATH];    // "shell.szName"
    LPSECURITY_ATTRIBUTES psa;

    lstrcpyA(szCounterName, "shell.");
    StrCatBuffA(szCounterName, szName, ARRAYSIZE(szCounterName));

    psa = CreateAllAccessSecurityAttributes(NULL, NULL, NULL);
    hSem = CreateSemaphoreA(psa, lInitialValue, 0x7FFFFFFF, szCounterName);
    if (!hSem)
        hSem = OpenSemaphoreA(SEMAPHORE_MODIFY_STATE | SYNCHRONIZE, FALSE, szCounterName);

    return hSem;
}


//
// This lets the user pass an UNICODE String as the name of the global counter, as well as an inital value
//
STDAPI_(HANDLE) SHGlobalCounterCreateNamedW(LPCWSTR szName, LONG lInitialValue)
{
    CHAR szCounterName[MAX_PATH];

    SHUnicodeToAnsi(szName, szCounterName, ARRAYSIZE(szCounterName));

    return SHGlobalCounterCreateNamedA(szCounterName, lInitialValue);
}


//
// This lets the user pass a GUID. The name of the global counter will be "shell.{guid}",
// and its initial value will be zero.
//
STDAPI_(HANDLE) SHGlobalCounterCreate(REFGUID rguid)
{
    CHAR szGUIDString[GUIDSTR_MAX];

    SHStringFromGUIDA(rguid, szGUIDString, ARRAYSIZE(szGUIDString));

    return SHGlobalCounterCreateNamedA(szGUIDString, 0);
}


// returns current value of the global counter
// Note: The result is not thread-safe in the sense that if two threads
// look at the value at the same time, one of them might read the wrong
// value.
STDAPI_(long) SHGlobalCounterGetValue(HANDLE hCounter)
{ 
    long lPreviousValue = 0;
    DWORD dwRet;

    ReleaseSemaphore(hCounter, 1, &lPreviousValue); // poll and bump the count
    dwRet = WaitForSingleObject(hCounter, GLOBAL_COUNTER_WAIT_TIMEOUT); // reduce the count

    // this shouldnt happen since we just bumped up the count above
    ASSERT(dwRet != WAIT_TIMEOUT);
    
    return lPreviousValue;
}


// returns new value
// Note: this _is_ thread safe
STDAPI_(long) SHGlobalCounterIncrement(HANDLE hCounter)
{ 
    long lPreviousValue = 0;

    ReleaseSemaphore(hCounter, 1, &lPreviousValue); // bump the count
    return lPreviousValue + 1;
}

// returns new value
// Note: The result is not thread-safe in the sense that if two threads
// try to decrement the value at the same time, whacky stuff can happen.
STDAPI_(long) SHGlobalCounterDecrement(HANDLE hCounter)
{ 
    DWORD dwRet;
    long lCurrentValue = SHGlobalCounterGetValue(hCounter);

#ifdef DEBUG
    // extra sanity check
    if (lCurrentValue == 0)
    {
        ASSERTMSG(FALSE, "SHGlobalCounterDecrement called on a counter that was already equal to 0 !!");
        return 0;
    }
#endif

    dwRet = WaitForSingleObject(hCounter, GLOBAL_COUNTER_WAIT_TIMEOUT); // reduce the count

    ASSERT(dwRet != WAIT_TIMEOUT);

    return lCurrentValue - 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\fda.c ===
#include "priv.h"

//***   FDSA -- small/fast DSA routines
// DESCRIPTION
//  We attempt to behave as much like an array as possible (semantics
//  and performance and to some extent allocation).  In particular,
//  - indexing (FDSA_GetItemXxx) is done entirely inline; and...
//  - ... involves only 1 extra indirection vs. a true array; and...
//  - ... knows the data type so sizeof is a constant; and...
//  - ... does no range checks (except possibly in DEBUG versions).
//  - part of the FDSA is statically alloc'ed, so one can put critical
//  items in the static part to ensure that they'll be there even under
//  low memory conditions.
// NOTES
//  For now we only implement:
//      Initialize, Destroy, GetItemPtr, GetItemCount, InsertItem, AppendItem

// FEATURE eventually these come from comctl...
#define DABreak()   /*NOTHING*/
// ReAlloc and Free come from inc/heapaloc.h

//***   SDSA_PITEM -- get item the hard way
//
#define SDSA_PITEM(pfdsa, i) \
    ((void *)(((BYTE *)(pfdsa)->aItem) + ((i) * (pfdsa)->cbItem)))

//***   FDSA_Initialize -- initialize
//
BOOL WINAPI FDSA_Initialize(int cbItem, int cItemGrow,
    PFDSA pfdsa, void * aItemStatic, int cItemStatic)
{
    ASSERT(pfdsa != NULL);      // WARNING how handle?

    if (cItemGrow == 0)
        cItemGrow = 1;

    // for implementation simplicity, cItemStatic must be a multiple of
    // cItemGrow.  o.w. our 1st grow from static->dynamic is messy and
    // probably buggy.
    if (cItemStatic % cItemGrow != 0) {
        AssertMsg(0, TEXT("CItemStatic must be a multiple of cItemGrow"));
        return FALSE;
    }

    if (aItemStatic != NULL) {
        // since we're (eventually) in comctl, we can't assume caller's
        // buffer was 0'ed
        ZeroMemory(aItemStatic, cItemStatic * cbItem);
    }

    if (pfdsa) {
        pfdsa->cItem = 0;
        pfdsa->cItemAlloc = cItemStatic;
        pfdsa->aItem = aItemStatic;
        pfdsa->fAllocated = FALSE;

        pfdsa->cbItem = cbItem;
        ASSERT(pfdsa->cbItem == cbItem);        // bitfield overflow

        pfdsa->cItemGrow = cItemGrow;
        ASSERT(pfdsa->cItemGrow == cItemGrow);  // bitfield overflow
    }

    return TRUE;
}

BOOL WINAPI FDSA_Destroy(PFDSA pdsa)
{
    if (pdsa == NULL)       // allow NULL for low memory cases
        return TRUE;

    if (pdsa->fAllocated && pdsa->aItem && !LocalFree(pdsa->aItem))
        return FALSE;

    return TRUE;
}

void* _LocalReAlloc(void* p, UINT uBytes)
{
    if (uBytes) {
        if (p) {
            return LocalReAlloc(p, uBytes, LMEM_MOVEABLE | LMEM_ZEROINIT);
        } else {
            return LocalAlloc(LPTR, uBytes);
        }
    } else {
        if (p)
            LocalFree(p);
        return NULL;
    }
}

//***   FDSA_InsertItem -- insert an item
// ENTRY/EXIT
//  index   insertion point; index > count (e.g. DA_LAST) means append
// NOTES
//  param called 'pdsa' (vs. pfdsa) for easy diff'ing w/ DSA_InsertItem
int WINAPI FDSA_InsertItem(PFDSA pdsa, int index, void FAR* pitem)
{
    ASSERT(pitem);

    if (index < 0) {
        TraceMsg(DM_ERROR, "FDSA: InsertItem: Invalid index: %d", index);
        DABreak();
        return -1;
    }

    if (index > pdsa->cItem)
        index = pdsa->cItem;

    if (pdsa->cItem + 1 > pdsa->cItemAlloc) {
        void FAR* aItemNew = _LocalReAlloc(pdsa->fAllocated ? pdsa->aItem : NULL,
                (pdsa->cItemAlloc + pdsa->cItemGrow) * pdsa->cbItem);
        if (!aItemNew)
            return -1;

        if (!pdsa->fAllocated) {
            // when we go from static->dynamic, we need to copy
            pdsa->fAllocated = TRUE;
            hmemcpy(aItemNew, pdsa->aItem, pdsa->cItem * pdsa->cbItem);
        }

        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc += pdsa->cItemGrow;
    }

    if (index < pdsa->cItem) {
        hmemcpy(SDSA_PITEM(pdsa, index + 1), SDSA_PITEM(pdsa, index),
            (pdsa->cItem - index) * pdsa->cbItem);
    }
    pdsa->cItem++;
    hmemcpy(SDSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return index;
}


BOOL WINAPI FDSA_DeleteItem(PFDSA pdsa, int index)
{
    ASSERT(pdsa);

    if (index < 0 || index >= pdsa->cItem)
    {
        TraceMsg(TF_ERROR, "FDSA: DeleteItem: Invalid index: %d", index);
        DABreak();
        return FALSE;
    }

    if (index < pdsa->cItem - 1)
    {
        hmemcpy(SDSA_PITEM(pdsa, index), SDSA_PITEM(pdsa, index + 1),
            (pdsa->cItem - (index + 1)) * pdsa->cbItem);
    }
    pdsa->cItem--;

#if 0
    // this doesn't work yet for FDsA
    if (pdsa->cItemAlloc - pdsa->cItem > pdsa->cItemGrow)
    {
        void FAR* aItemNew = ReAlloc(pdsa->aItem,
                (pdsa->cItemAlloc - pdsa->cItemGrow) * pdsa->cbItem);

        ASSERT(aItemNew);
        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc -= pdsa->cItemGrow;
    }
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\httpfnc.cpp ===
#include "priv.h"
#pragma  hdrstop

#include "objidl.h"
#include "urlmon.h"
#include "exdisp.h"     // IWebBrowserApp
#include "shlobj.h"     // IShellBrowser
#include "inetreg.h"
#include <mlang.h>

// Internal helper functions
HRESULT wrap_CreateFormatEnumerator( UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc);
HRESULT wrap_RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc, DWORD reserved);          
STDAPI common_GetAcceptLanguages(CHAR *psz, LPDWORD pcch);

#define SETFMTETC(p, a) {(p)->cfFormat = (a); \
                         (p)->dwAspect = DVASPECT_CONTENT; \
                         (p)->lindex = -1; \
                         (p)->tymed = TYMED_ISTREAM; \
                         (p)->ptd = NULL;}

const SA_BSTRGUID s_sstrEFM = {
    38 * sizeof(WCHAR),
    L"{D0FCA420-D3F5-11CF-B211-00AA004AE837}"    
};


STDAPI CreateDefaultAcceptHeaders(VARIANT* pvar, IWebBrowserApp* pdie)
{
    IEnumFORMATETC* pEFM;
    HKEY hkey;
    HRESULT hr = S_OK;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Accepted Documents"),
            &hkey) == ERROR_SUCCESS)
    {
        DWORD iValue = 0;
        DWORD iValidEntries = 0;
        TCHAR szValueName[128];
        DWORD cchValueName = ARRAYSIZE(szValueName);
        DWORD dwType;

        // Count the types in the registry
        while (RegEnumValue(hkey, iValue++, szValueName, &cchValueName,
                            NULL, &dwType, NULL, NULL)==ERROR_SUCCESS)
        {
            // purpose is to increment iValue
            cchValueName = ARRAYSIZE(szValueName);
        }

        // Previous loop ends +1, so no need to add +1 for CF_NULL
        
        FORMATETC *prgfmtetc = (FORMATETC *)LocalAlloc(LPTR, iValue * sizeof(FORMATETC));
        if (prgfmtetc)
        {
            FORMATETC *pcurfmtetc = prgfmtetc;
            for (DWORD nValue=0; SUCCEEDED(hr) && (nValue < (iValue -1)); nValue++)
            {
                TCHAR szFormatName[128];
                DWORD cchFormatName = ARRAYSIZE(szFormatName);

                cchValueName = ARRAYSIZE(szValueName);
                if (RegEnumValue(hkey, nValue, szValueName, &cchValueName, NULL,
                                 &dwType, (LPBYTE) szFormatName, &cchFormatName)==ERROR_SUCCESS)
                {
                    pcurfmtetc->cfFormat = (CLIPFORMAT) RegisterClipboardFormat(szFormatName);
                    if (pcurfmtetc->cfFormat)
                    {
                        SETFMTETC (pcurfmtetc, pcurfmtetc->cfFormat);
                        pcurfmtetc++;   // move to next fmtetc
                        iValidEntries++;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                } // if RegEnum
            } // for nValue

            if (SUCCEEDED(hr))
            {
                // for the last pcurfmtetc, we fill in for CF_NULL
                // no need to do RegisterClipboardFormat("*/*")
                SETFMTETC(pcurfmtetc, CF_NULL);
                iValidEntries++;
    
                hr = wrap_CreateFormatEnumerator (iValidEntries, prgfmtetc, &pEFM);
                if (SUCCEEDED(hr))
                {
                    ASSERT(pvar->vt == VT_EMPTY);
                    pvar->vt = VT_UNKNOWN;
                    pvar->punkVal = (IUnknown *)pEFM;
                    hr = pdie->PutProperty((BSTR)s_sstrEFM.wsz, *pvar);
                    if (FAILED(hr))
                    {
                        pEFM->Release();  // if we failed to pass ownership on, free EFM
                        pvar->vt = VT_EMPTY;
                        pvar->punkVal = NULL;
                    }
                }
            }
    
            LocalFree (prgfmtetc);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        RegCloseKey(hkey);
    }
    else
    {
        DebugMsg(TF_ERROR, TEXT("RegOpenkey failed!"));
        hr = E_FAIL;
    }

    return hr;
}

STDAPI RegisterDefaultAcceptHeaders(IBindCtx* pbc, LPSHELLBROWSER psb)
{
    IEnumFORMATETC* pEFM;
    IWebBrowserApp* pdie;

    ASSERT(pbc);
    ASSERT(psb);
    HRESULT hres = IUnknown_QueryService(psb, IID_IWebBrowserApp, IID_IWebBrowserApp, (LPVOID*)&pdie);
    if (SUCCEEDED(hres))
    {
        VARIANT var;
        hres = pdie->GetProperty((BSTR)s_sstrEFM.wsz, &var);
        if (SUCCEEDED(hres))
        {
            if (var.vt == VT_EMPTY)
            {
#ifdef FULL_DEBUG
                DebugMsg(DM_TRACE, TEXT("RegisterDefaultAcceptHeaders var.vt == VT_EMPTY"));
#endif
                CreateDefaultAcceptHeaders(&var, pdie);
            }
            else if (var.vt == VT_UNKNOWN)
            {
#ifdef FULL_DEBUG
                DebugMsg(DM_TRACE, TEXT("RegisterDefaultAcceptHeaders var.vt == VT_UNKNOWN"));
#endif
                hres = var.punkVal->QueryInterface(IID_IEnumFORMATETC, (LPVOID*)&pEFM);
                if (SUCCEEDED(hres)) {
                    IEnumFORMATETC* pEFMClone = NULL;
                    hres = pEFM->Clone(&pEFMClone);
                    if (SUCCEEDED(hres)) {
#ifdef FULL_DEBUG
                        DebugMsg(DM_TRACE, TEXT("RegisterDefaultAcceptHeaders registering FormatEnum %x"), pEFMClone);
#endif
                        hres = wrap_RegisterFormatEnumerator(pbc, pEFMClone, 0);
                        pEFMClone->Release();
                    } else {
                        DebugMsg(TF_ERROR, TEXT("RegisterDefaultAcceptHeaders Clone failed %x"), hres);
                    }
                    pEFM->Release();
                }
            }
            else
            {
                DebugMsg(TF_ERROR, TEXT("GetProperty() returned illegal Variant Type: %x"), var.vt);
                DebugMsg(TF_ERROR, TEXT("RegisterDefaultAcceptHeaders not registering FormatEnum"));
            }

            VariantClear(&var);
        } else {
            DebugMsg(TF_ERROR, TEXT("RegisterDefaultAcceptHeaders pdie->GetProperty() failed %x"), hres);
        }

        pdie->Release();
    } else {
        DebugMsg(TF_ERROR, TEXT("RegisterDefaultAcceptHeaders QueryService(ISP) failed %x"), hres);
    }

    return hres;
} // RegisterDefaultAcceptHeaders

STDAPI GetAcceptLanguagesA(LPSTR pszLanguages, LPDWORD pcchLanguages)
{
    return common_GetAcceptLanguages(pszLanguages, pcchLanguages);
}  // GetAcceptLanguagesA

STDAPI GetAcceptLanguagesW(LPWSTR pwzLanguages, LPDWORD pcchLanguages)
{
    if (!pwzLanguages || !pcchLanguages || !*pcchLanguages)
        return E_FAIL;

    DWORD dwcchMaxOut = *pcchLanguages;

    LPSTR psz = (LPSTR) LocalAlloc (LPTR, dwcchMaxOut);
    if (!psz)
        return E_OUTOFMEMORY;

    HRESULT hr = common_GetAcceptLanguages(psz, &dwcchMaxOut);
    if (SUCCEEDED(hr))
    {
        *pcchLanguages = MultiByteToWideChar(CP_ACP, 0, psz, -1,
                             pwzLanguages, *pcchLanguages - 1);

        pwzLanguages[*pcchLanguages] = 0;
    }

    LocalFree(psz);
    return hr;
} // GetAcceptLanguagesW

STDAPI common_GetAcceptLanguages(CHAR *psz, LPDWORD pcch)
{
    HKEY hk;
    HRESULT hr = E_FAIL;

    if (!psz || !pcch || !*pcch)
        return hr;

    if ((RegOpenKey (HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, &hk) == ERROR_SUCCESS) && hk) 
    {
        DWORD dwType;

        if (RegQueryValueEx (hk, REGSTR_VAL_ACCEPT_LANGUAGE, NULL, &dwType, (UCHAR *)psz, pcch) != ERROR_SUCCESS) 
        {

            // When there is no AcceptLanguage key, we have to default
            DWORD LCID = GetUserDefaultLCID();            

            // Use MLang for RFC1766 language name            
            hr = LcidToRfc1766A(LCID, psz, *pcch);
            
            if (S_OK == hr)
                *pcch = lstrlenA(psz);
            else 
            {
                *pcch = 0;
                AssertMsg(FALSE, TEXT("We should add LCID 0x%lx to MLang RFC1766 table"), LCID);
            }
        } 
        else 
        {
            hr = S_OK;
            if (!*psz) 
            {
                // A NULL AcceptLanguage means send no A-L: header
                hr = S_FALSE;
            }
        }

        RegCloseKey (hk);
    } 

    return hr;
}  // w_GetAcceptLanguages
    

//
// Both of these functions will be called only once per browser session - the
// first time we create the FormatEnumerator.  After that, we will use the one
// we created, rather than needing to call these to allocate a new one.
//

HRESULT wrap_RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc, DWORD reserved)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hurl = LoadLibrary(TEXT("URLMON.DLL"));
    if (hurl) 
    {
        HRESULT (*pfnRFE)(LPBC pBC, IEnumFORMATETC * pEFetc, DWORD reserved);

        pfnRFE = (HRESULT (*)(LPBC, IEnumFORMATETC*, DWORD))GetProcAddress (hurl, "RegisterFormatEnumerator");
        if (pfnRFE) 
        {
            hr = pfnRFE(pBC, pEFetc, reserved);
        }

        FreeLibrary(hurl);
    }

    return hr;
}

HRESULT wrap_CreateFormatEnumerator(UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hurl = LoadLibrary(TEXT("URLMON.DLL"));
    if (hurl) 
    {
        HRESULT (*pfnCFE)(UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC **ppenumfmtetc);

        pfnCFE = (HRESULT (*)(UINT, FORMATETC*, IEnumFORMATETC **))GetProcAddress (hurl, "CreateFormatEnumerator");
        if (pfnCFE) 
        {
            hr = pfnCFE(cfmtetc, rgfmtetc, ppenumfmtetc);
        }

        FreeLibrary(hurl);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\itfwrap.cpp ===
//
// Wrapper functions for shell interfaces
//
//  Many ISVs mess up various IShellFolder methods, so we centralize the
//  workarounds so everybody wins.
//
//  Someday, IExtractIcon and IShellLink wrappers may also be added, should
//  the need arise.
//

#include "priv.h"
#include <shlobj.h>

//----------------------------------------------------------------------------
//
//  IShellFolder::GetDisplayNameOf was not very well documented.  Lots of
//  people don't realize that the SHGDN values are flags, so they use
//  equality tests instead of bit tests.  So whenever we add a new flag,
//  these people say "Huh?  I don't understand."  So we have to keep
//  retrying with fewer and fewer flags until finally they get something
//  they like.  SHGDN_FORPARSING has the opposite problem:  Some people
//  demand that the flag be set.

//
//  This array lists the things we try to do to get the uFlags into a state
//  that the app will eventually like.
//
//  We walk through the list and do this:
//
//      uFlags = (uFlags & AND) | OR
//
//  Most of the time, the entry will turn off a bit in the uFlags, but
//  SHGDN_FORPARSING is weird and it's a flag you actually want to turn on
//  instead of off.
//

typedef struct GDNCOMPAT {
    DWORD   dwAnd;
    DWORD   dwOr;
    DWORD   dwAllow;                    // flag to allow this rule to fire
} GDNCOMPAT;

#define GDNADDFLAG(f)   ~0, f           // Add a flag to uFlags
#define GDNDELFLAG(f)   ~f, 0           // Remove a flag from uFlags

#define ISHGDN2_CANREMOVEOTHERFLAGS 0x80000000

GDNCOMPAT c_gdnc[] = {
  { GDNDELFLAG(SHGDN_FOREDITING),       ISHGDN2_CANREMOVEOTHERFLAGS },  // Some apps don't like this flag
  { GDNDELFLAG(SHGDN_FORADDRESSBAR),    ISHGDN2_CANREMOVEOTHERFLAGS },  // Some apps don't like this flag
  { GDNADDFLAG(SHGDN_FORPARSING),       ISHGDN2_CANREMOVEOTHERFLAGS },  // Some apps require this flag
  { GDNDELFLAG(SHGDN_FORPARSING),       ISHGDN2_CANREMOVEFORPARSING },  // And others don't like it
  { GDNDELFLAG(SHGDN_INFOLDER),         ISHGDN2_CANREMOVEOTHERFLAGS },  // Desperation - remove this flag too
};

//
//  These are the return values we tend to get back when people see
//  flags they don't like.
//
BOOL __inline IsBogusHRESULT(HRESULT hres)
{
    return  hres == E_FAIL ||
            hres == E_INVALIDARG ||
            hres == E_NOTIMPL;
}

//
//  dwFlags2 controls how aggressively we try to find a working display name.
//
//  ISHGDN2_CANREMOVEFORPARSING
//      Normally, we do not turn off the SHGDN_FORPARSING flag because
//      if a caller asks for the parse name, it probably really wants the
//      parse name.  This flag indicates that we are allowed to turn off
//      SHGDN_FORPARSING if we think it'll help.
//

STDAPI IShellFolder_GetDisplayNameOf(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    DWORD uFlags,
    LPSTRRET lpName,
    DWORD dwFlags2)
{
    HRESULT hres;

    hres = psf->GetDisplayNameOf(pidl, uFlags, lpName);
    if (!IsBogusHRESULT(hres))
        return hres;

    int i;
    DWORD uFlagsOrig = uFlags;

    //
    //  If the caller didn't pass SHGDN_FORPARSING, then clearly it's
    //  safe to remove it.
    //
    if (!(uFlags & SHGDN_FORPARSING)) {
        dwFlags2 |= ISHGDN2_CANREMOVEFORPARSING;
    }

    // We can always remove other flags.
    dwFlags2 |= ISHGDN2_CANREMOVEOTHERFLAGS;

    for (i = 0; i < ARRAYSIZE(c_gdnc); i++)
    {
        if (c_gdnc[i].dwAllow & dwFlags2)
        {
            DWORD uFlagsNew = (uFlags & c_gdnc[i].dwAnd) | c_gdnc[i].dwOr;
            if (uFlagsNew != uFlags)
            {
                uFlags = uFlagsNew;
                hres = psf->GetDisplayNameOf(pidl, uFlags, lpName);
                if (!IsBogusHRESULT(hres))
                    return hres;
            }
        }
    }

    // By now, we should've removed all the flags, except perhaps for
    // SHGDN_FORPARSING.
    if (dwFlags2 & ISHGDN2_CANREMOVEFORPARSING) {
        ASSERT(uFlags == SHGDN_NORMAL);
    } else {
        ASSERT(uFlags == SHGDN_NORMAL || uFlags == SHGDN_FORPARSING);
    }

    return hres;
}

//----------------------------------------------------------------------------
//
//  The documentation on IShellFolder::ParseDisplayName wasn't clear that
//  pchEaten and pdwAttributes can be NULL, and some people dereference
//  them unconditionally.  So make sure it's safe to dereference them.
//
//  It is also popular to forget to set *ppidl=NULL on failure, so we null
//  it out here.
//
//  We request no attributes, so people who aren't buggy won't go out of
//  their way trying to retrieve expensive attributes.
//

STDAPI IShellFolder_ParseDisplayName(
    IShellFolder *psf,
    HWND hwnd,
    LPBC pbc,
    LPOLESTR pszDisplayName,
    ULONG *pchEaten,
    LPITEMIDLIST *ppidl,
    ULONG *pdwAttributes)
{
    ULONG cchEaten;
    ULONG dwAttributes = 0;

    if (pchEaten == NULL)
        pchEaten = &cchEaten;
    if (pdwAttributes == NULL)
        pdwAttributes = &dwAttributes;

    if (ppidl)
        *ppidl = NULL;

    return psf->ParseDisplayName(hwnd, pbc, pszDisplayName, pchEaten, ppidl, pdwAttributes);
}

STDAPI IShellFolder_CompareIDs(IShellFolder *psf, LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // We have new bits here...
    if (lParam & ~SHCIDS_COLUMNMASK)
    {
        IShellFolder2* psf2;
        if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
        {
            psf2->Release();
        }
        else
        {
            // But we can't send them to legacy IShellFolder implementations
            lParam &= SHCIDS_COLUMNMASK;
        }
    }

    return psf->CompareIDs(lParam, pidl1, pidl2);
}


//----------------------------------------------------------------------------
//
//  IShellFolder::EnumObjects
//
CLSID CLSID_ZipFolder =
{ 0xe88dcce0, 0xb7b3, 0x11d1, { 0xa9, 0xf0, 0x00, 0xaa, 0x00, 0x60, 0xfa, 0x31 } };

STDAPI IShellFolder_EnumObjects(
    IShellFolder *psf,
    HWND hwnd,
    DWORD grfFlags,
    IEnumIDList **ppenumIDList)
{
    if (hwnd == NULL || hwnd == GetDesktopWindow())
    {
        //  The first parameter to EnumObjects is supposed to be the window
        //  on which to parent UI, or NULL for no UI, or GetDesktopWindow()
        //  for "parentless UI".
        //
        //  Win98 Plus! Zip Folders takes the hwnd and uses it as the basis
        //  for a search for a rebar window, since they (for some bizarre
        //  reason) want to hide the address bar when an enumeration starts.
        //
        //  We used to pass NULL or GetDesktopWindow(), but this caused zip
        //  folders to start searching from the desktop, which means that
        //  it eventually finds the taskbar and tries to send it
        //  inter-process rebar messages, which causes the shell to fault.
        //
        //  When we discover we are about to pass NULL to Zip Folders,
        //  we change it to HWND_BOTTOM.  This is not a valid window handle,
        //  which causes Zip Folders' search to bail out quickly and it ends
        //  up not killing anyone.
        //

        CLSID clsid;
        if (SUCCEEDED(IUnknown_GetClassID(psf, &clsid)) &&
            IsEqualCLSID(clsid, CLSID_ZipFolder))
            hwnd = HWND_BOTTOM;
    }

    return psf->EnumObjects(hwnd, grfFlags, ppenumIDList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\inistr.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       inistr.cpp
//
//  Contents:   SHGet/SetIniStringW implementations, which save strings into
//              INI files in a manner that survives the round trip to disk.
//
//----------------------------------------------------------------------------

#include "priv.h"
#define _SHELL32_
#define _SHDOCVW_
#include "unicwrap.h"

#include <platform.h>
#include <mlang.h>

//
//  Do this in every wrapper function that has an output parameter.
//  It raises assertion failures on the main code path so that
//  the same assertions are raised on NT and 95.  The CStrOut class
//  doesn't like it when you say that an output buffer is NULL yet
//  has nonzero length.  Without this macro, the bug would go undetected
//  on NT and appear only on Win95.
//
#define VALIDATE_OUTBUF(s, cch) ASSERT((s) != NULL || (cch) == 0)

//----------------------------------------------------------------------------
//
//  The basic problem is that INI files are ANSI-only, so any UNICODE
//  string you put into it won't round-trip.
//
//  So the solution is to record UNICODE strings in UTF7.  Why UTF7?
//  Because we can't use UTF8, since XxxPrivateProfileStringW will try
//  to convert the 8-bit values to/from UNICODE and mess them up.  Since
//  some of the 8-bit values might not even be valid (e.g., a DBCS lead
//  byte followed by an illegal trail byte), we cannot assume that the
//  string will survive the ANSI -> UNICODE -> ANSI round-trip.
//
//  The UTF7 string is stored in a [Section.W] section, under the
//  same key name.  The original ANSI string is stored in a [Section.A]
//  section, again, with the same key name.
//
//  (We separate the A/W from the section name with a dot so it is less
//  likely that we will accidentally collide with other section names.
//
//  We store the original ANSI string twice so we can compare the two
//  and see if a downlevel app (e.g., IE4) has changed the [Section]
//  version.  If so, then we ignore the [Section.W] version since it's stale.
//
//  If the original string is already 7-bit clean, then no UTF7 string is
//  recorded.
//

BOOL
Is7BitClean(LPCWSTR pwsz)
{
    for ( ; *pwsz; pwsz++) {
        if ((UINT)*pwsz > 127)
            return FALSE;
    }
    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Yet another conversion class -- this one is for creating the
//  variants of a section name.
//
//  Note!  Since INI files are ASCII, section names are necessarily 7-bit
//  clean, so we can cheat a lot of stuff.
//

class CStrSectionX : public CConvertStrW
{
public:
    CStrSectionX(LPCWSTR pwszSection);
};

//
//  We append a dot an an A or W to the section name.
//
#define SECTION_SUFFIX_LEN  2

CStrSectionX::CStrSectionX(LPCWSTR pwszSection)
{
    ASSERT(_pwstr == NULL);
    if (pwszSection) {

        ASSERT(Is7BitClean(pwszSection));

        UINT cwchNeeded = lstrlenW(pwszSection) + SECTION_SUFFIX_LEN + 1;
        if (cwchNeeded > ARRAYSIZE(_awch)) {
            _pwstr = new WCHAR[cwchNeeded];
        } else {
            _pwstr = _awch;
        }

        if (_pwstr) {
            // Build the string initially with ".A" stuck on the end
            // It will later get changed to a ".W"
            lstrcpyW(_pwstr, pwszSection);
            lstrcatW(_pwstr, L".A");
        }
    }
}

//----------------------------------------------------------------------------
//
//  Mini-class for keeping track of UTF7 strings.  These are kept in ANSI
//  most of the time since that's what ConvertINetUnicodeToMultiByte uses.
//
//  The UTF7 shadow is prefixed by a checksum of the original string, which
//  we use on read-back to see if the shadow still corresponds to the
//  original string.
//

class CStrUTF7 : public CConvertStr
{
public:
    inline CStrUTF7() : CConvertStr(CP_ACP) { };
    void SetUnicode(LPCWSTR pwszValue);
};

//
//  Note that this can be slow since it happens only when we encounter
//  a non-ANSI character.
//
void CStrUTF7::SetUnicode(LPCWSTR pwszValue)
{
    int cwchLen = lstrlenW(pwszValue);
    HRESULT hres;
    DWORD dwMode;

    int cwchLenT = cwchLen;

    // Save room for terminating NULL.  We must convert the NULL separately
    // because UTF7 does not translate NULL to NULL.
    int cchNeeded = ARRAYSIZE(_ach) - 1;
    dwMode = 0;
    hres = ConvertINetUnicodeToMultiByte(&dwMode, CP_UTF7, pwszValue,
                                         &cwchLenT, _ach,
                                         &cchNeeded);
    if (SUCCEEDED(hres)) {
        ASSERT(cchNeeded + 1 <= ARRAYSIZE(_ach));
        _pstr = _ach;
    } else {
        _pstr = new CHAR[cchNeeded + 1];
        if (!_pstr)
            return;                 // No string - tough

        cwchLenT = cwchLen;
        dwMode = 0;
        hres = ConvertINetUnicodeToMultiByte(&dwMode, CP_UTF7, pwszValue,
                                    &cwchLenT, _pstr,
                                    &cchNeeded);
        if (FAILED(hres)) {         // Couldn't convert - tough
            Free();
            return;
        }
    }

    // Terminate explicitly since UTF7 doesn't.
    _pstr[cchNeeded] = '\0';
}

//
//  pwszSection  = section name into which to write pwszValue (UNICODE)
//  pwszSectionA = section name into which to write ANSI shadow
//  pwszKey      = key name for both pwszValue and strUTF7
//  pwszFileName = file name
//
//  pwszSectionA can be NULL if a low-memory condition was encountered.
//
//  strUTF7 can be NULL, meaning that the shadows should be deleted.
//
//  Write pwszSection first, followed by pwszSectionA, then pwszSectionW.
//  This ensures that the backwards-compatibility string comes first in
//  the file, in case there are apps that assume such.
//
//  pwszSectionW is computed from pwszSectionA by changing the last "A"
//  to a "W".  pwszSecionW gets the UTF7-encoded unicode string.
//  strUTF7 might be NULL, meaning that we should delete the shadow strings.
//
BOOL WritePrivateProfileStringMultiW(LPCWSTR pwszSection,  LPCWSTR pwszValue,
                                      LPWSTR pwszSectionA, CStrUTF7& strUTF7,
                                     LPCWSTR pwszKey,      LPCWSTR pwszFileName)
{
    BOOL fRc = WritePrivateProfileStringW(pwszSection, pwszKey, pwszValue, pwszFileName);

    if (pwszSectionA) {
        //
        //  Write the [Section.A] key, or delete it if there is no UTF7.
        //
        WritePrivateProfileStringW(pwszSectionA, pwszKey,
                                   strUTF7 ? pwszValue : NULL, pwszFileName);

        //
        //  Now change pwszSectionA to pwszSectionW so we can write out
        //  the UTF7 encoding.
        //
        pwszSectionA[lstrlenW(pwszSectionA) - 1] = TEXT('W');

        CStrInW strUTF7W(strUTF7);
        // This really writes [Section.W]
        WritePrivateProfileStringW(pwszSectionA, pwszKey, strUTF7W, pwszFileName);
    }

    return fRc;
}

BOOL WritePrivateProfileStringMultiA(LPCWSTR pwszSection,  LPCWSTR pwszValue,
                                      LPWSTR pwszSectionA, CStrUTF7& strUTF7,
                                     LPCWSTR pwszKey,      LPCWSTR pwszFileName)
{
    CStrIn strSection(pwszSection);
    CStrIn strSectionA(pwszSectionA);
    CStrIn strValue(pwszValue);
    CStrIn strKey(pwszKey);
    CPPFIn strFileName(pwszFileName); // PrivateProfile filename needs special class

    BOOL fRc = WritePrivateProfileStringA(strSection, strKey, strValue, strFileName);

    if ((LPSTR)strSectionA) {
        //
        //  Write the [Section.A] key, or delete it if there is no UTF7.
        //
        WritePrivateProfileStringA(strSectionA, strKey,
#if defined(UNIX) && !defined(ux10)
                                   strUTF7 ? (LPSTR)strValue : (LPSTR)NULL, strFileName);
#else
                                   strUTF7 ? strValue : NULL, strFileName);
#endif

        //
        //  Now change strSectionA to strSectionW so we can write out
        //  the UTF7 encoding.
        //
        strSectionA[lstrlenA(strSectionA) - 1] = 'W';

        // This really writes [Section.W]
        WritePrivateProfileStringA(strSectionA, strKey, strUTF7, strFileName);
    }

    return fRc;
}

BOOL WINAPI
SHSetIniStringW(LPCWSTR pwszSection, LPCWSTR pwszKey, LPCWSTR pwszValue, LPCWSTR pwszFileName)
{
    // We have no way of encoding these two, so they had better by 7-bit clean
    // We also do not support "delete entire section"
    AssertMsg(pwszSection != NULL,
              TEXT("SHSetIniStringW: Section name cannot be NULL; bug in caller"));
    AssertMsg(Is7BitClean(pwszSection),
              TEXT("SHSetIniStringW: Section name not 7-bit clean; bug in caller"));
    AssertMsg(pwszKey != NULL,
              TEXT("SHSetIniStringW: Key name cannot be NULL; bug in caller"));
    AssertMsg(!pwszKey     || Is7BitClean(pwszKey),
              TEXT("SHSetIniStringW: Key name not 7-bit clean; bug in caller"));

    CStrSectionX strSectionX(pwszSection);
    CStrUTF7 strUTF7;               // Assume no UTF7 needed.

    if (strSectionX && pwszKey && pwszValue && !Is7BitClean(pwszValue)) {
        //
        //  The value is not 7-bit clean.  Must create a UTF7 version.
        //
        strUTF7.SetUnicode(pwszValue);
    }

    if (g_bRunningOnNT)
        return WritePrivateProfileStringMultiW(pwszSection, pwszValue,
                                               strSectionX, strUTF7,
                                               pwszKey,     pwszFileName);
    else
        return WritePrivateProfileStringMultiA(pwszSection, pwszValue,
                                               strSectionX, strUTF7,
                                               pwszKey,     pwszFileName);
}

//
//  Keep calling GetPrivateProfileString with bigger and bigger buffers
//  until we get the entire string.  Start with MAX_PATH, since that's
//  usually plenty big enough.
//
//  The returned buffer must be freed with LocalFree, not delete[].
//
LPVOID GetEntirePrivateProfileStringAorW(
    LPCVOID pszSection,
    LPCVOID pszKey,
    LPCVOID pszFileName,
    BOOL    fUnicode)
{
    int    CharSize = fUnicode ? sizeof(WCHAR) : sizeof(CHAR);
    UINT   cchResult = MAX_PATH;
    LPVOID pszResult = LocalAlloc(LMEM_FIXED, cchResult * CharSize);
    LPVOID pszFree = pszResult;

    while (pszResult) {
        UINT cchRc;
        if (fUnicode)
            cchRc = GetPrivateProfileStringW((LPCWSTR)pszSection,
                                             (LPCWSTR)pszKey,
                                             L"",
                                             (LPWSTR)pszResult, cchResult,
                                             (LPCWSTR)pszFileName);
        else
            cchRc = GetPrivateProfileStringA((LPCSTR)pszSection,
                                             (LPCSTR)pszKey,
                                             "",
                                             (LPSTR)pszResult, cchResult,
                                             (LPCSTR)pszFileName);

        if (cchRc < cchResult - 1)
            return pszResult;

        // Buffer too small - iterate
        cchResult *= 2;
        LPVOID pszNew = LocalReAlloc(pszResult, cchResult * CharSize, LMEM_MOVEABLE);
        pszFree = pszResult;
        pszResult = pszNew;
    }

    //
    //  Memory allocation failed; free pszFree while we still can.
    //
    if (pszFree)
        LocalFree(pszFree);
    return NULL;
}

DWORD GetPrivateProfileStringMultiW(LPCWSTR pwszSection, LPCWSTR pwszKey,
                                    LPWSTR pwszSectionA,
                                    LPWSTR pwszReturnedString, DWORD cchSize,
                                    LPCWSTR pwszFileName)
{
    LPWSTR pwszValue  = NULL;
    LPWSTR pwszValueA = NULL;
    LPWSTR pwszUTF7 = NULL;
    DWORD dwRc;

    pwszValue  = (LPWSTR)GetEntirePrivateProfileStringAorW(
                              pwszSection, pwszKey,
                              pwszFileName, TRUE);
    if (pwszValue) {

        //
        //  If the value is an empty string, then don't waste your
        //  time trying to get the UNICODE version - the UNICODE version
        //  of the empty string is the empty string.
        //
        //  Otherwise, get the ANSI shadow hidden in [Section.A]
        //  and see if it matches.  If not, then the file was edited
        //  by a downlevel app and we should just use pwszValue after all.

        if (pwszValue[0] &&
            (pwszValueA = (LPWSTR)GetEntirePrivateProfileStringAorW(
                                      pwszSectionA, pwszKey,
                                      pwszFileName, TRUE)) != NULL &&
            lstrcmpW(pwszValue, pwszValueA) == 0) {

            // our shadow is still good - run with it
            // Change [Section.A] to [Section.W]
            pwszSectionA[lstrlenW(pwszSectionA) - 1] = TEXT('W');

            pwszUTF7 = (LPWSTR)GetEntirePrivateProfileStringAorW(
                                      pwszSectionA, pwszKey,
                                      pwszFileName, TRUE);

            CStrIn strUTF7(pwszUTF7);

            dwRc = 0;                   // Assume something goes wrong

            if (strUTF7) {
                dwRc = SHAnsiToUnicodeCP(CP_UTF7, strUTF7, pwszReturnedString, cchSize);
            }

            if (dwRc == 0) {
                // Problem converting to UTF7 - just use the ANSI version
                dwRc = SHUnicodeToUnicode(pwszValue, pwszReturnedString, cchSize);
            }

        } else {
            // String was empty or couldn't get [Section.A] shadow or
            // shadow doesn't match.  Just use the regular string.
            dwRc = SHUnicodeToUnicode(pwszValue, pwszReturnedString, cchSize);
        }

        // The SHXxxToYyy functions include the terminating zero,
        // which we want to exclude.
        if (dwRc > 0)
            dwRc--;

    } else {
        // Fatal error reading values from file; just use the boring API
        dwRc = GetPrivateProfileStringW(pwszSection,
                                        pwszKey,
                                        L"",
                                        pwszReturnedString, cchSize,
                                        pwszFileName);
    }

    if (pwszValue)
        LocalFree(pwszValue);
    if (pwszValueA)
        LocalFree(pwszValueA);
    if (pwszUTF7)
        LocalFree(pwszUTF7);

    return dwRc;
}

DWORD GetPrivateProfileStringMultiA(LPCWSTR pwszSection, LPCWSTR pwszKey,
                                    LPWSTR pwszSectionA,
                                    LPWSTR pwszReturnedString, DWORD cchSize,
                                    LPCWSTR pwszFileName)
{
    CStrIn strSection(pwszSection);
    CStrIn strSectionA(pwszSectionA);
    CStrIn strKey(pwszKey);
    CPPFIn strFileName(pwszFileName); // PrivateProfile filename needs special class

    LPSTR pszValue  = NULL;
    LPSTR pszValueA = NULL;
    LPSTR pszUTF7   = NULL;
    DWORD dwRc;

    if (strSectionA &&
        (pszValue  = (LPSTR)GetEntirePrivateProfileStringAorW(
                                 strSection, strKey,
                                 strFileName, FALSE)) != NULL) {

        //
        //  If the value is an empty string, then don't waste your
        //  time trying to get the UNICODE version - the UNICODE version
        //  of the empty string is the empty string.
        //
        //  Otherwise, get the ANSI shadow hidden in [Section.A]
        //  and see if it matches.  If not, then the file was edited
        //  by a downlevel app and we should just use pwszValue after all.
        if (pszValue[0] &&
            (pszValueA = (LPSTR)GetEntirePrivateProfileStringAorW(
                                     strSectionA, strKey,
                                     strFileName, FALSE)) != NULL &&
            lstrcmpA(pszValue, pszValueA) == 0) {

            // our shadow is still good - run with it
            // Change [Section.A] to [Section.W]

            strSectionA[lstrlenA(strSectionA) - 1] = 'W';

            pszUTF7 = (LPSTR)GetEntirePrivateProfileStringAorW(
                                       strSectionA, strKey,
                                       strFileName, FALSE);
            dwRc = 0;                   // Assume something goes wrong

            if (pszUTF7) {
                dwRc = SHAnsiToUnicodeCP(CP_UTF7, pszUTF7, pwszReturnedString, cchSize);
            }

            if (dwRc == 0) {
                // Problem converting to UTF7 - just use the ANSI version
                dwRc = SHAnsiToUnicode(pszValue, pwszReturnedString, cchSize);
            }

        } else {
            // String was empty or couldn't get [Section.A] shadow or
            // shadow doesn't match.  Just use the regular string.
            dwRc = SHAnsiToUnicode(pszValue, pwszReturnedString, cchSize);
        }

        // The SHXxxToYyy functions include the terminating zero,
        // which we want to exclude.
        if (dwRc > 0)
            dwRc--;

    } else {
        // Fatal error reading values from file; just use the boring API
        CStrOut strOut(pwszReturnedString, cchSize);
        dwRc = GetPrivateProfileStringA(strSection,
                                        strKey,
                                        "",
                                        strOut, cchSize,
                                        strFileName);
        strOut.ConvertIncludingNul();
    }

    if (pszValue)
        LocalFree(pszValue);
    if (pszValueA)
        LocalFree(pszValueA);
    if (pszUTF7)
        LocalFree(pszUTF7);


    return dwRc;
}

DWORD WINAPI SHGetIniStringW(LPCWSTR pwszSection, LPCWSTR pwszKey, LPWSTR pwszReturnedString, DWORD cchSize, LPCWSTR pwszFileName)
{
    VALIDATE_OUTBUF(pwszReturnedString, cchSize);

    // We have no way of encoding these two, so they had better by 7-bit clean
    // We also do not support "get all section names" or "get entire section".
    AssertMsg(pwszSection != NULL,
              TEXT("SHGetIniStringW: Section name cannot be NULL; bug in caller"));
    AssertMsg(Is7BitClean(pwszSection),
              TEXT("SHGetIniStringW: Section name not 7-bit clean; bug in caller"));
    AssertMsg(pwszKey != NULL,
              TEXT("SHGetIniStringW: Key name cannot be NULL; bug in caller"));
    AssertMsg(Is7BitClean(pwszKey),
              TEXT("SHGetIniStringW: Key name not 7-bit clean; bug in caller"));

    CStrSectionX strSectionX(pwszSection);

    if (g_bRunningOnNT)
        return GetPrivateProfileStringMultiW(pwszSection, pwszKey,
                                             strSectionX,
                                             pwszReturnedString, cchSize,
                                             pwszFileName);
    else
        return GetPrivateProfileStringMultiA(pwszSection, pwszKey,
                                             strSectionX,
                                             pwszReturnedString, cchSize,
                                             pwszFileName);
}

//+---------------------------------------------------------------------------
//
//  CreateURLFileContents
//
//  shdocvw.dll and url.dll need to create in-memory images
//  of URL files, so this helper function does all the grunky work so they
//  can remain insulated from the way we encode Unicode strings into INI files.
//  The resulting memory should be freed via GlobalFree().

//
//  Writes a string into the URL file.  If fWrite is FALSE, then
//  then just do the math and don't actually write anything.  This lets us
//  use one function to handle both the measurement pass and the rendering
//  pass.
//
LPSTR AddToURLFileContents(LPSTR pszFile, LPCSTR psz, BOOL fWrite)
{
    int cch = lstrlenA(psz);
    if (fWrite) {
        memcpy(pszFile, psz, cch);
    }
    pszFile += cch;
    return pszFile;
}

LPSTR AddURLFileSection(LPSTR pszFile, LPCSTR pszSuffix, LPCSTR pszUrl, BOOL fWrite)
{
    pszFile = AddToURLFileContents(pszFile, "[InternetShortcut", fWrite);
    pszFile = AddToURLFileContents(pszFile, pszSuffix, fWrite);
    pszFile = AddToURLFileContents(pszFile, "]\r\nURL=", fWrite);
    pszFile = AddToURLFileContents(pszFile, pszUrl, fWrite);
    pszFile = AddToURLFileContents(pszFile, "\r\n", fWrite);
    return pszFile;
}

//
//  The file consists of an [InternetShortcut] section, followed if
//  necessary by [InternetShortcut.A] and [InternetShortcut.W].
//
LPSTR AddURLFileContents(LPSTR pszFile, LPCSTR pszUrl, LPCSTR pszUTF7, BOOL fWrite)
{
    pszFile = AddURLFileSection(pszFile, "", pszUrl, fWrite);
    if (pszUTF7) {
        pszFile = AddURLFileSection(pszFile, ".A", pszUrl, fWrite);
        pszFile = AddURLFileSection(pszFile, ".W", pszUTF7, fWrite);
    }
    return pszFile;
}

//
//  Returns number of bytes in file contents (not including trailing NULL),
//  or an OLE error code.  If ppszOut is NULL, then no contents are returned.
//
HRESULT GenerateURLFileContents(LPCWSTR pwszUrl, LPCSTR pszUrl, LPSTR *ppszOut)
{
    HRESULT hr = 0;

    if (ppszOut)
        *ppszOut = NULL;

    if (pwszUrl && pszUrl) {
        CStrUTF7 strUTF7;               // Assume no UTF7 needed.
        if (!Is7BitClean(pwszUrl)) {
            //
            //  The value is not 7-bit clean.  Must create a UTF7 version.
            //
            strUTF7.SetUnicode(pwszUrl);
        }

        hr = PtrToUlong(AddURLFileContents(NULL, pszUrl, strUTF7, FALSE));
        ASSERT(SUCCEEDED(hr));

        if (ppszOut) {
            *ppszOut = (LPSTR)GlobalAlloc(GMEM_FIXED, hr + 1);
            if (*ppszOut) {
                LPSTR pszEnd = AddURLFileContents(*ppszOut, pszUrl, strUTF7, TRUE);
                *pszEnd = '\0';
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    //
    //  Double-check the value we return.
    //
    if (SUCCEEDED(hr) && ppszOut) {
        ASSERT(hr == lstrlenA(*ppszOut));
    }

    return hr;
}


HRESULT CreateURLFileContentsW(LPCWSTR pwszUrl, LPSTR *ppszOut)
{
    CStrIn strUrl(pwszUrl);
    return GenerateURLFileContents(pwszUrl, strUrl, ppszOut);
}

HRESULT CreateURLFileContentsA(LPCSTR pszUrl, LPSTR *ppszOut)
{
    CStrInW strUrl(pszUrl);
    return GenerateURLFileContents(strUrl, pszUrl, ppszOut);
}

DWORD SHGetIniStringUTF7W(LPCWSTR lpSection, LPCWSTR lpKey, LPWSTR lpBuf, DWORD nSize, LPCWSTR lpFile)
{
    if (*lpKey == CH_CANBEUNICODEW)
        return SHGetIniStringW(lpSection, lpKey+1, lpBuf, nSize, lpFile);
    else
        return GetPrivateProfileStringWrapW(lpSection, lpKey, L"", lpBuf, nSize, lpFile);
}

BOOL SHSetIniStringUTF7W(LPCWSTR lpSection, LPCWSTR lpKey, LPCWSTR lpString, LPCWSTR lpFile)
{
    if (*lpKey == CH_CANBEUNICODEW)
        return SHSetIniStringW(lpSection, lpKey+1, lpString, lpFile);
    else
        return WritePrivateProfileStringWrapW(lpSection, lpKey, lpString, lpFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\ids.h ===
#ifndef _IDS_H_
#define _IDS_H_
// IDs for common UI resources (note that these MUST BE decimal numbers)

#define IDI_SECURITY    1

#define IDS_HOUR    0x100
#define IDS_MIN     0x101
#define IDS_SEC     0x102

#define IDS_BYTES   0x103
#define IDS_ORDERKB 0x104
#define IDS_ORDERMB 0x105
#define IDS_ORDERGB 0x106
#define IDS_ORDERTB 0x107
#define IDS_ORDERPB 0x108
#define IDS_ORDEREB 0x109

#define IDS_LONGDATE_SEP    0x10a

#define IDS_SIDEBYSIDE 0x10F

// strings for GetRelativeDateFormat (note: sun-sat must be kept in order)
#define IDS_DAYSOFTHEWEEK               0x110
#define IDS_SUNDAY                      (IDS_DAYSOFTHEWEEK)
#define IDS_MONDAY                      (IDS_DAYSOFTHEWEEK+1)
#define IDS_TUESDAY                     (IDS_DAYSOFTHEWEEK+2)
#define IDS_WEDNESDAY                   (IDS_DAYSOFTHEWEEK+3)
#define IDS_THURSDAY                    (IDS_DAYSOFTHEWEEK+4)
#define IDS_FRIDAY                      (IDS_DAYSOFTHEWEEK+5)
#define IDS_SATURDAY                    (IDS_DAYSOFTHEWEEK+6)
#define IDS_TODAY                       0x117
#define IDS_YESTERDAY                   0x118

// strings for Zone stuff (security.cpp)
#define IDS_MIXED                       0x119
#define IDS_INTERNETSECURITY            0x11A

// strings for SHRestrictedMessageBox (util.cpp)
#define IDS_RESTRICTIONS                0x11B
#define IDS_RESTRICTIONSTITLE           0x11C
 
// Free spaces 0x11D thru 0x11F

#define IDS_DRIVENOTREADY               0x120
#define IDS_UNFORMATTED                 0x121
#define IDS_NOFMT                       0x122
#define IDS_NOSUCHDRIVE                 0x123
#define IDS_FILEERROR                   0x124
#define IDS_FILEERRORMOVE               0x124  // Same as IDS_FILEERROR because (IDS_FILEERROR + FO_MOVE) or FO_COPY, FO_DELETE, FO_RENAME
#define IDS_FILEERRORCOPY               0x125
#define IDS_FILEERRORDEL                0x126
#define IDS_FILEERRORREN                0x127
#define IDS_SECURITY                    0x128
#define IDS_TEMPLATENOTSECURE           0x129

// SHMessageBoxHelp "click help for more info" string
#define IDS_CLICKHELPFORINFO            0x130
#define DLG_NULL                        0x131

#define DLG_MESSAGEBOXCHECK     0x1200
#define IDC_MBC_TEXT            0x1201
#define IDC_MBC_CHECK           0x1202
#define IDC_MBC_ICON            0x1203

#define IDS_EXTTYPETEMPLATE     0x1300
#define IDS_FILETYPENAME        0x1301
#define IDS_FOLDERTYPENAME      0x1302


#endif // _IDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\menu.c ===
#include "priv.h"
#pragma  hdrstop


int GetMenuPosFromID(HMENU hmenu, UINT id)
{
    int iPos = -1;
    int cItems = GetMenuItemCount(hmenu);
    int i;

    for (i=0; i<cItems;i++)
    {
        MENUITEMINFO mii;
        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_ID;
        mii.wID = 0;
        if (GetMenuItemInfo(hmenu, i, TRUE, &mii))
        {
            if (mii.wID == id)
            {
                iPos = i;
                break;
            }
        }
    }

    return iPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\mime.cpp ===
//
// Mime stuff used by shell32/shdocvw/shdoc401
//
#include "priv.h"


#define TF_MIME 0

/*----------------------------------------------------------
Purpose: Generates the HKEY_CLASSES_ROOT subkey for a MIME
         type

Returns: 
Cond:    --
*/
STDAPI_(BOOL) GetMIMETypeSubKeyA(LPCSTR pcszMIMEType, LPSTR pszSubKeyBuf, UINT cchBuf)
{
    BOOL bResult;

    bResult = ((UINT)lstrlenA(TEXT("MIME\\Database\\Content Type\\%s")) +
               (UINT)lstrlenA(pcszMIMEType) < cchBuf);

    if (bResult)
        EVAL((UINT)wsprintfA(pszSubKeyBuf, TEXT("MIME\\Database\\Content Type\\%s"),
                             pcszMIMEType) < cchBuf);
    else
    {
        if (cchBuf > 0)
           *pszSubKeyBuf = '\0';

        TraceMsg(TF_WARNING, "GetMIMETypeSubKey(): Given sub key buffer of length %u is too short to hold sub key for MIME type %hs.",
                     cchBuf, pcszMIMEType);
    }

    ASSERT(! cchBuf ||
           (IS_VALID_STRING_PTRA(pszSubKeyBuf, -1) &&
            (UINT)lstrlenA(pszSubKeyBuf) < cchBuf));
    ASSERT(bResult ||
           ! cchBuf ||
           ! *pszSubKeyBuf);

    return(bResult);
}


STDAPI_(BOOL) GetMIMETypeSubKeyW(LPCWSTR pszMIMEType, LPWSTR pszBuf, UINT cchBuf)
{
    BOOL bRet;
    char szMIMEType[MAX_PATH];
    char sz[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pszMIMEType, -1));

    WideCharToMultiByte(CP_ACP, 0, pszMIMEType, -1, szMIMEType, SIZECHARS(szMIMEType), NULL, NULL);
    bRet = GetMIMETypeSubKeyA(szMIMEType, sz, SIZECHARS(sz));

    if (bRet)
    {
        ASSERT(cchBuf <= SIZECHARS(sz));
        MultiByteToWideChar(CP_ACP, 0, sz, -1, pszBuf, cchBuf);
    }
    return bRet;
}    


/*
** RegisterExtensionForMIMEType()
**
** Under HKEY_CLASSES_ROOT\MIME\Database\Content Type\mime/type, add
** Content Type = mime/type and Extension = .ext.
**
*/
STDAPI_(BOOL) RegisterExtensionForMIMETypeA(LPCSTR pcszExtension, LPCSTR pcszMIMEContentType)
{
    BOOL bResult;
    CHAR szMIMEContentTypeSubKey[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRA(pcszExtension, -1));
    ASSERT(IS_VALID_STRING_PTRA(pcszMIMEContentType, -1));

    ASSERT(IsValidExtensionA(pcszExtension));

    bResult = GetMIMETypeSubKeyA(pcszMIMEContentType, szMIMEContentTypeSubKey,
                                SIZECHARS(szMIMEContentTypeSubKey));

    if (bResult)
    {
        /* (+ 1) for null terminator. */
        bResult = (NO_ERROR == SHSetValueA(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey,
                                          "Extension", REG_SZ, pcszExtension,
                                          CbFromCchA(lstrlenA(pcszExtension) + 1)));
    }

    return(bResult);
}


STDAPI_(BOOL) RegisterExtensionForMIMETypeW(LPCWSTR pcszExtension, LPCWSTR pcszMIMEContentType)
{
    BOOL bResult;
    WCHAR szMIMEContentTypeSubKey[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pcszExtension, -1));
    ASSERT(IS_VALID_STRING_PTRW(pcszMIMEContentType, -1));

    ASSERT(IsValidExtensionW(pcszExtension));

    bResult = GetMIMETypeSubKeyW(pcszMIMEContentType, szMIMEContentTypeSubKey,
                                SIZECHARS(szMIMEContentTypeSubKey));

    if (bResult)
    {
        /* (+ 1) for null terminator. */
        bResult = (NO_ERROR == SHSetValueW(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey,
                                          TEXTW("Extension"), REG_SZ, pcszExtension,
                                          (lstrlenW(pcszExtension) + 1)*sizeof(WCHAR)));
    }

    return(bResult);
}


/*
** UnregisterExtensionForMIMEType()
**
** Deletes Extension under
** HKEY_CLASSES_ROOT\MIME\Database\Content Type\mime/type.  If no other values
** or sub keys are left, deletes
** HKEY_CLASSES_ROOT\MIME\Database\Content Type\mime/type.
**
** Side Effects:  May also delete MIME key.
*/
STDAPI_(BOOL) UnregisterExtensionForMIMETypeA(LPCSTR pcszMIMEContentType)
{
    BOOL bResult;
    CHAR szMIMEContentTypeSubKey[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRA(pcszMIMEContentType, -1));

    bResult = (GetMIMETypeSubKeyA(pcszMIMEContentType, szMIMEContentTypeSubKey,
                                 SIZECHARS(szMIMEContentTypeSubKey)) &&
               NO_ERROR == SHDeleteValueA(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey,
                                         "Extension") &&
               NO_ERROR == SHDeleteEmptyKeyA(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey));

    return(bResult);
}


STDAPI_(BOOL) UnregisterExtensionForMIMETypeW(LPCWSTR pcszMIMEContentType)
{
    BOOL bResult;
    WCHAR szMIMEContentTypeSubKey[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pcszMIMEContentType, -1));

    bResult = (GetMIMETypeSubKeyW(pcszMIMEContentType, szMIMEContentTypeSubKey,
                                 SIZECHARS(szMIMEContentTypeSubKey)) &&
               NO_ERROR == SHDeleteValueW(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey,
                                         TEXTW("Extension")) &&
               NO_ERROR == SHDeleteEmptyKeyW(HKEY_CLASSES_ROOT, szMIMEContentTypeSubKey));

    return(bResult);
}


/*
** UnregisterMIMETypeForExtension()
**
** Deletes Content Type under HKEY_CLASSES_ROOT\.ext.
**
** Side Effects:  none
*/
STDAPI_(BOOL) UnregisterMIMETypeForExtensionA(LPCSTR pcszExtension)
{
    ASSERT(IS_VALID_STRING_PTRA(pcszExtension, -1));
    ASSERT(IsValidExtensionA(pcszExtension));

    return NO_ERROR == SHDeleteValueA(HKEY_CLASSES_ROOT, pcszExtension, "Content Type");
}


STDAPI_(BOOL) UnregisterMIMETypeForExtensionW(LPCWSTR pcszExtension)
{
    ASSERT(IS_VALID_STRING_PTRW(pcszExtension, -1));
    ASSERT(IsValidExtensionW(pcszExtension));

    return NO_ERROR == SHDeleteValueW(HKEY_CLASSES_ROOT, pcszExtension, TEXTW("Content Type"));
}


/*
** RegisterMIMETypeForExtension()
**
** Under HKEY_CLASSES_ROOT\.ext, add Content Type = mime/type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
STDAPI_(BOOL) RegisterMIMETypeForExtensionA(LPCSTR pcszExtension, LPCSTR pcszMIMEContentType)
{
    ASSERT(IS_VALID_STRING_PTRA(pcszExtension, -1));
    ASSERT(IS_VALID_STRING_PTRA(pcszMIMEContentType, -1));

    ASSERT(IsValidExtensionA(pcszExtension));

    /* (+ 1) for null terminator. */
    return NO_ERROR == SHSetValueA(HKEY_CLASSES_ROOT, pcszExtension, "Content Type", 
                                  REG_SZ, pcszMIMEContentType,
                                  CbFromCchA(lstrlenA(pcszMIMEContentType) + 1));
}


STDAPI_(BOOL) RegisterMIMETypeForExtensionW(LPCWSTR pcszExtension, LPCWSTR pcszMIMEContentType)
{
    ASSERT(IS_VALID_STRING_PTRW(pcszExtension, -1));
    ASSERT(IS_VALID_STRING_PTRW(pcszMIMEContentType, -1));
    ASSERT(IsValidExtensionW(pcszExtension));

    /* (+ 1) for null terminator. */
    return NO_ERROR == SHSetValueW(HKEY_CLASSES_ROOT, pcszExtension, TEXTW("Content Type"), 
                                  REG_SZ, pcszMIMEContentType,
                                  (lstrlenW(pcszMIMEContentType) + 1) * sizeof(WCHAR));
}

/*
** GetMIMEValue()
**
** Retrieves the data for a value of a MIME type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
STDAPI_(BOOL) GetMIMEValueA(LPCSTR pcszMIMEType, LPCSTR pcszValue,
                              PDWORD pdwValueType, PBYTE pbyteValueBuf,
                              PDWORD pdwcbValueBufLen)
{
   BOOL bResult;
   CHAR szMIMETypeSubKey[MAX_PATH];

   ASSERT(IS_VALID_STRING_PTRA(pcszMIMEType, -1));
   ASSERT(! pcszValue ||
          IS_VALID_STRING_PTRA(pcszValue, -1));
   ASSERT(IS_VALID_WRITE_PTR(pdwValueType, DWORD));
   ASSERT(IS_VALID_WRITE_BUFFER(pbyteValueBuf, BYTE, *pdwcbValueBufLen));

   bResult = (GetMIMETypeSubKeyA(pcszMIMEType, szMIMETypeSubKey,SIZECHARS(szMIMETypeSubKey)) &&
              NO_ERROR == SHGetValueA(HKEY_CLASSES_ROOT, szMIMETypeSubKey,
                                      pcszValue, pdwValueType, pbyteValueBuf,
                                      pdwcbValueBufLen));

   return(bResult);
}

STDAPI_(BOOL) GetMIMEValueW(LPCWSTR pcszMIMEType, LPCWSTR pcszValue,
                              PDWORD pdwValueType, PBYTE pbyteValueBuf,
                              PDWORD pdwcbValueBufLen)
{
   BOOL bResult;
   WCHAR szMIMETypeSubKey[MAX_PATH];

   ASSERT(IS_VALID_STRING_PTRW(pcszMIMEType, -1));
   ASSERT(! pcszValue ||
          IS_VALID_STRING_PTRW(pcszValue, -1));
   ASSERT(IS_VALID_WRITE_PTR(pdwValueType, DWORD));
   ASSERT(IS_VALID_WRITE_BUFFER(pbyteValueBuf, BYTE, *pdwcbValueBufLen));

   bResult = (GetMIMETypeSubKeyW(pcszMIMEType, szMIMETypeSubKey,SIZECHARS(szMIMETypeSubKey)) &&
              NO_ERROR == SHGetValueW(HKEY_CLASSES_ROOT, szMIMETypeSubKey,
                                      pcszValue, pdwValueType, pbyteValueBuf,
                                      pdwcbValueBufLen));

   return(bResult);
}

/*
** GetMIMETypeStringValue()
**
** Retrieves the string for a registered MIME type's value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
STDAPI_(BOOL) GetMIMETypeStringValueA(LPCSTR pcszMIMEType, LPCSTR pcszValue,
                                         LPSTR pszBuf, UINT ucBufLen)
{
   BOOL bResult;
   DWORD dwValueType;
   DWORD dwcbLen = CbFromCchA(ucBufLen);

   /* GetMIMEValue() will verify parameters. */

   bResult = (GetMIMEValueA(pcszMIMEType, pcszValue, &dwValueType, (PBYTE)pszBuf, &dwcbLen) &&
              dwValueType == REG_SZ);

   if (! bResult)
   {
      if (ucBufLen > 0)
         *pszBuf = '\0';
   }

   ASSERT(! ucBufLen || IS_VALID_STRING_PTRA(pszBuf, -1));

   return(bResult);
}

STDAPI_(BOOL) GetMIMETypeStringValueW(LPCWSTR pcszMIMEType, LPCWSTR pcszValue,
                                         LPWSTR pszBuf, UINT ucBufLen)
{
   BOOL bResult;
   DWORD dwValueType;
   DWORD dwcbLen = CbFromCchW(ucBufLen);

   /* GetMIMEValue() will verify parameters. */

   bResult = (GetMIMEValueW(pcszMIMEType, pcszValue, &dwValueType, (PBYTE)pszBuf, &dwcbLen) &&
              dwValueType == REG_SZ);

   if (! bResult)
   {
      if (ucBufLen > 0)
         *pszBuf = '\0';
   }

   ASSERT(! ucBufLen || IS_VALID_STRING_PTRW(pszBuf, -1));

   return(bResult);
}


/*
** MIME_GetExtension()
**
** Determines the file name extension to be used when writing a file of a MIME
** type to the file system.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
STDAPI_(BOOL) MIME_GetExtensionA(LPCSTR pcszMIMEType, LPSTR pszExtensionBuf, UINT ucExtensionBufLen)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRING_PTRA(pcszMIMEType, -1));
   ASSERT(IS_VALID_WRITE_BUFFER(pszExtensionBuf, CHAR, ucExtensionBufLen));

   if (EVAL(ucExtensionBufLen > 2))
   {
      /* Leave room for possible leading period. */

      if (GetMIMETypeStringValueA(pcszMIMEType, "Extension", pszExtensionBuf + 1, ucExtensionBufLen - 1))
      {
         if (pszExtensionBuf[1])
         {
            /* Prepend period if necessary. */

            if (pszExtensionBuf[1] == TEXT('.'))
               /* (+ 1) for null terminator. */
               MoveMemory(pszExtensionBuf, pszExtensionBuf + 1,
                          CbFromCchA(lstrlenA(pszExtensionBuf + 1) + 1));
            else
               pszExtensionBuf[0] = TEXT('.');

            bResult = TRUE;
         }
      }
   }

   if (! bResult)
   {
      if (ucExtensionBufLen > 0)
         *pszExtensionBuf = '\0';
   }

   if (bResult)
      TraceMsgA(TF_MIME, "MIME_GetExtension(): Extension %s registered as default extension for MIME type %s.",
                 pszExtensionBuf, pcszMIMEType);

   ASSERT((bResult &&
           IsValidExtensionA(pszExtensionBuf)) ||
          (! bResult &&
           (! ucExtensionBufLen ||
            ! *pszExtensionBuf)));
   ASSERT(! ucExtensionBufLen ||
          (UINT)lstrlenA(pszExtensionBuf) < ucExtensionBufLen);

   return(bResult);
}


STDAPI_(BOOL) MIME_GetExtensionW(LPCWSTR pcszMIMEType, LPWSTR pszExtensionBuf, UINT ucExtensionBufLen)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRING_PTRW(pcszMIMEType, -1));
   ASSERT(IS_VALID_WRITE_BUFFER(pszExtensionBuf, CHAR, ucExtensionBufLen));

   if (EVAL(ucExtensionBufLen > 2))
   {
      /* Leave room for possible leading period. */

      if (GetMIMETypeStringValueW(pcszMIMEType, TEXTW("Extension"), pszExtensionBuf + 1, ucExtensionBufLen - 1))
      {
         if (pszExtensionBuf[1])
         {
            /* Prepend period if necessary. */

            if (pszExtensionBuf[1] == TEXT('.'))
               /* (+ 1) for null terminator. */
               MoveMemory(pszExtensionBuf, pszExtensionBuf + 1,
                          CbFromCchW(lstrlenW(pszExtensionBuf + 1) + 1));
            else
               pszExtensionBuf[0] = TEXT('.');

            bResult = TRUE;
         }
      }
   }

   if (! bResult)
   {
      if (ucExtensionBufLen > 0)
         *pszExtensionBuf = '\0';
   }

   if (bResult)
      TraceMsgW(TF_MIME, "MIME_GetExtension(): Extension %s registered as default extension for MIME type %s.",
                 pszExtensionBuf, pcszMIMEType);

   ASSERT((bResult &&
           IsValidExtensionW(pszExtensionBuf)) ||
          (! bResult &&
           (! ucExtensionBufLen ||
            ! *pszExtensionBuf)));
   ASSERT(! ucExtensionBufLen ||
          (UINT)lstrlenW(pszExtensionBuf) < ucExtensionBufLen);

   return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\mirror.c ===
/****************************** Module*Header *****************************\
* Module Name: mirror.c                                                    *
*                                                                          *
* This module contains all the Right-To-Left (RTL) Mirroring support       *
* routines used to Right-To-Left mirror an icon on the fly so that         *
* it would be displayed normal on a RTL mirrored localized OS. This is     *
* mainly a concern for 3rd party Apps.                                     *
*                                                                          *
*                                                                          *
* Created: 01-Feb-1998 8:41:18 pm                                          *
* Author: Samer Arafeh [samera]                                            *
*                                                                          *
* Copyright (c) 1998 Microsoft Corporation                                 *
\**************************************************************************/

#include "priv.h"




/***************************************************************************\
* MirrorIcon
*
* Mirror an Icon , given an Icon handle so that when these icons are displayed
* on a Mirrored DC, they end would be displayed normal.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
STDAPI_(BOOL) SHMirrorIcon(HICON* phiconSmall, HICON* phiconLarge)
{
    HDC      hdcScreen;
    HBITMAP  hbm, hbmMask, hbmOld,hbmOldMask;
    BITMAP   bm;
    HICON    hicon[2] = {NULL,NULL};
    HICON    hiconNew[2] = {NULL,NULL};
    ICONINFO ii ;
    int      i;

    if (!g_bMirroredOS)
    {
        return FALSE;
    }

    //
    // Synchronize access to global DCs now!
    // Allocate DCs if we didn't so far.
    //  
    ENTERCRITICAL;
    if (!g_hdc && !g_hdcMask)
    {
        g_hdc = CreateCompatibleDC(NULL);
        if (g_hdc)
        {
            g_hdcMask = CreateCompatibleDC(NULL);

            if( g_hdcMask )
            {
                SET_DC_RTL_MIRRORED(g_hdc);
                SET_DC_RTL_MIRRORED(g_hdcMask);
            }
            else
            {
                DeleteDC( g_hdc );
                g_hdc = NULL;
            }
        }
    }

    if (phiconSmall)
        hicon[0] = *phiconSmall;

    if (phiconLarge)
        hicon[1] = *phiconLarge;

    //
    // Acquire screen DC
    //
    hdcScreen = GetDC(NULL);

    if (g_hdc && g_hdcMask && hdcScreen) 
    {
        for( i=0 ; i<(sizeof(hicon)/sizeof(hicon[0])) ; i++ )
        {
            if( hicon[i] )
            {
                if( GetIconInfo(hicon[i], &ii) &&
                    GetObjectWrapW(ii.hbmColor, sizeof(bm), &bm))
                {

                    //
                    // I don't want these.
                    //
                    DeleteObject( ii.hbmMask );
                    DeleteObject( ii.hbmColor );
                    ii.hbmMask = ii.hbmColor = NULL;

                    hbm = CreateCompatibleBitmap(hdcScreen, bm.bmWidth, bm.bmHeight);
                    hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);
                    hbmOld = (HBITMAP)SelectObject(g_hdc, hbm);
                    hbmOldMask = (HBITMAP)SelectObject(g_hdcMask, hbmMask);
        
                    DrawIconEx(g_hdc, 0, 0, hicon[i], bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_IMAGE);

                    DrawIconEx(g_hdcMask, 0, 0, hicon[i], bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_MASK);

                    SelectObject(g_hdc, hbmOld);
                    SelectObject(g_hdcMask, hbmOldMask);

                    //
                    // create the new mirrored icon, and delete bmps
                    //
                    ii.hbmMask  = hbmMask;
                    ii.hbmColor = hbm;
                    hiconNew[i] = CreateIconIndirect(&ii);

                    DeleteObject(hbm);
                    DeleteObject(hbmMask);
                }
            }
        }
    }

    ReleaseDC(NULL, hdcScreen);

    //
    // Now we can reuse the global DCs
    //
    LEAVECRITICAL;

    //
    // Update icons if needed, and destroy old ones!
    //
    if (hicon[0] && hiconNew[0])
    {
        *phiconSmall = hiconNew[0];
        DestroyIcon(hicon[0]);
    }

    if (hicon[1] && hiconNew[1])
    {
        *phiconLarge = hiconNew[1];

        //
        // Don't delete twice
        //
        if (hicon[1] != hicon[0]) 
            DestroyIcon(hicon[1]);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\mlui.h ===
// registered window messages global variables, defined in mlui.cpp
extern UINT g_ML_GETTEXT,
            g_ML_GETTEXTLENGTH,
            g_ML_SETTEXT;

extern UINT g_ML_LB_ADDSTRING,
            g_ML_LB_FINDSTRING,
            g_ML_LB_FINDSTRINGEXACT,
            g_ML_LB_GETTEXT,
            g_ML_LB_GETTEXTLEN,
            g_ML_LB_INSERTSTRING,
            g_ML_LB_SELECTSTRING;

extern UINT g_ML_CB_ADDSTRING,
            g_ML_CB_FINDSTRING,
            g_ML_CB_FINDSTRINGEXACT,
            g_ML_CB_GETLBTEXT,
            g_ML_CB_GETLBTEXTLEN,
            g_ML_CB_INSERTSTRING,
            g_ML_CB_SELECTSTRING;


BOOL fDoMungeUI(HINSTANCE hinst);
INT_PTR MLDialogBoxIndirectParamI(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
INT_PTR MLDialogBoxParamI(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
HWND MLCreateDialogIndirectParamI(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
HWND MLCreateDialogParamI(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
BOOL MLIsEnabled(HWND hwnd);
int MLGetControlTextI(HWND hWnd, LPCWSTR lpString, int nMaxCount);
BOOL MLSetControlTextI(HWND hWnd, LPCWSTR lpString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\machinfo.cpp ===
//
// machinfo.cpp - SHGetMachineInfo and related functions
//
//

#include "priv.h"
#include <dbt.h>
#include <cfgmgr32.h>
#include <apithk.h>

#ifndef UNIX
#include <batclass.h>

const GUID GUID_DEVICE_BATTERY = { 0x72631e54L, 0x78A4, 0x11d0,
              { 0xbc, 0xf7, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a } };

#include <winsta.h>
#endif

//
//  Win95 does not decorate BroadcastSystemMessage, so we can't either.
//
#undef BroadcastSystemMessage

extern "C" {
WINUSERAPI long WINAPI
BroadcastSystemMessage(DWORD, LPDWORD, UINT, WPARAM, LPARAM);
};

/*****************************************************************************
 *
 *  DOCK STATE - Win95, Win98, and WinNT all do this differently (yuck)
 *
 *****************************************************************************/

C_ASSERT(GMID_NOTDOCKABLE == CM_HWPI_NOT_DOCKABLE);
C_ASSERT(GMID_UNDOCKED    == CM_HWPI_UNDOCKED);
C_ASSERT(GMID_DOCKED      == CM_HWPI_DOCKED);

#if defined(_X86_) && !defined(UNIX)

typedef struct CMHDR {
    LPVOID  pArgs;
    DWORD   dwService;
    DWORD   dwRet;
} CMHDR, *PCMHDR;

#define CONFIGMG_Get_Hardware_Profile_Info      0x00330052

//
//  GetDockedState95
//
DWORD GetDockedState95()
{
    struct GHWPI95 {                // Get_Hardware_Profile_Info parameter blk
        CMHDR   cmhdr;
        ULONG   ulIndex;
        PHWPROFILEINFO_A pHWProfileInfo;
        ULONG   ulFlags;
        HWPROFILEINFO_A HWProfileInfo;
    } *pghwpi;

    HANDLE hheap;
    DWORD Result = GMID_NOTDOCKABLE;    // assume the worst

#define HEAP_SHARED     0x04000000      /* put heap in shared memory--undoc'd */

    //
    //  Win95 Configmg requires the parameter block to reside in the shared
    //  heap since we're going to do a cross-process SendMessage.
    //

    hheap = HeapCreate(HEAP_SHARED, 1, 4096);
    if (hheap) {
        // Allocate parameter block in shared memory
        pghwpi = (struct GHWPI95 *)HeapAlloc(hheap, HEAP_ZERO_MEMORY,
                                             sizeof(*pghwpi));
        if (pghwpi) {
            DWORD dwRecipients = BSM_VXDS;

            pghwpi->cmhdr.dwRet     = 0;
            pghwpi->cmhdr.dwService = CONFIGMG_Get_Hardware_Profile_Info;
            pghwpi->cmhdr.pArgs     = &pghwpi->ulIndex;
            pghwpi->ulIndex         = 0xFFFFFFFF;
            pghwpi->pHWProfileInfo  = &pghwpi->HWProfileInfo;
            pghwpi->ulFlags         = 0;

            // "Call" the service

            BroadcastSystemMessage(0, &dwRecipients, WM_DEVICECHANGE,
                                   DBT_CONFIGMGAPI32, (LPARAM)pghwpi);

            if (pghwpi->cmhdr.dwRet == CR_SUCCESS) {

                Result = pghwpi->HWProfileInfo.HWPI_dwFlags;
            } else {
                TraceMsg(DM_WARNING, "GetDockedState95: CONFIGMG did not respond");
            }
        }

        HeapDestroy(hheap);
    } else {
        TraceMsg(DM_WARNING, "GetDockedState95: Unable to create shared heap");
    }
    return Result;
}


//
//  On Win98, use the 32-bit interface to configmg.
//

CONFIGRET __cdecl
CallConfigmg98(DWORD dwServiceNumber, ...)
{
    CONFIGRET cr;
    HANDLE hCM;

    hCM = CreateFileA("\\\\.\\CONFIGMG",
                      GENERIC_READ|GENERIC_WRITE,
                      FILE_SHARE_READ|FILE_SHARE_WRITE,
                      NULL, OPEN_EXISTING, 0, NULL);
    if (hCM != INVALID_HANDLE_VALUE) {
        DWORD dwRet;

        // Evil hack that works only on x86.  Fortunately, this code is
        // inside an #ifdef _X86_ block, so we're safe.
        LPVOID pvArg = 1 + &dwServiceNumber;

        if (DeviceIoControl(hCM, dwServiceNumber, &pvArg, sizeof(pvArg),
                            &cr, sizeof(cr), &dwRet, 0) &&
                            dwRet == sizeof(cr)) {
        } else {
            TraceMsg(DM_WARNING, "CallConfigmg98: CONFIGMG did not respond");
            cr = CR_FAILURE;
        }

        CloseHandle(hCM);
    } else {
        TraceMsg(DM_WARNING, "CallConfigmg98: Couldn't connect to CONFIGMG");
        cr = CR_FAILURE;
    }

    return cr;
}

DWORD GetDockedState98()
{
    CONFIGRET cr;
    DWORD Result = GMID_NOTDOCKABLE;    // assume the worst
    HWPROFILEINFO_A HWProfileInfo;

    cr = CallConfigmg98(
            0x80000000 + LOWORD(CONFIGMG_Get_Hardware_Profile_Info),
            -1,                     // ulIndex, -1 means "current profile"
            &HWProfileInfo,         // PHWPROFILEINFO
            0);                     // ulFlags

    if (cr == CR_SUCCESS) {
        Result = HWProfileInfo.HWPI_dwFlags;
    }

    return Result;
}

#endif

typedef BOOL (WINAPI *GETCURRENTHWPROFILEA)(LPHW_PROFILE_INFOA);
DWORD GetDockedStateNT()
{
    HW_PROFILE_INFOA hpi;
    GETCURRENTHWPROFILEA GetCurrentHwProfileA;
    DWORD Result = GMID_NOTDOCKABLE;    // assume the worst

    GetCurrentHwProfileA = (GETCURRENTHWPROFILEA)
                            GetProcAddress(GetModuleHandle("ADVAPI32"),
                            "GetCurrentHwProfileA");

    if (GetCurrentHwProfileA && GetCurrentHwProfileA(&hpi)) {
        Result = hpi.dwDockInfo & (DOCKINFO_UNDOCKED | DOCKINFO_DOCKED);

        // Wackiness: If the machine does not support docking, then
        // NT returns >both< flags set.  Go figure.
        if (Result == (DOCKINFO_UNDOCKED | DOCKINFO_DOCKED)) {
            Result = GMID_NOTDOCKABLE;
        }
    } else {
        TraceMsg(DM_WARNING, "GetDockedStateNT: GetCurrentHwProfile failed");
    }
    return Result;
}

#if defined(_X86_) && !defined(UNIX)

//
//  Platforms that support Win95/Win98 need to do version switching
//
DWORD GetDockedState()
{
    if (g_bRunningOnNT) {
        return GetDockedStateNT();
    } else if (g_bRunningOnMemphis) {
        return GetDockedState98();
    } else {
        return GetDockedState95();
    }
}

#else

//
//  Platforms that do not support Win95/Win98 can just call the NT version.
//
#define GetDockedState()            GetDockedStateNT()

#endif


#ifndef UNIX

/*****************************************************************************
 *
 *  BATTERY STATE - Once again, Win95 and Win98 and NT all do it differently
 *
 *****************************************************************************/

//
//  Values for SYSTEM_POWER_STATUS.ACLineStatus
//
#define SPSAC_OFFLINE       0
#define SPSAC_ONLINE        1

//
//  Values for SYSTEM_POWER_STATUS.BatteryFlag
//
#define SPSBF_NOBATTERY     128

//
//  So many ways to detect batteries, so little time...
//
DWORD GetBatteryState()
{
    //
    //  Since GMIB_HASBATTERY is cumulative (any battery turns it on)
    //  and GMIB_ONBATTERY is subtractive (any AC turns it off), the
    //  state you have to start in before you find a battery is
    //  GMIB_HASBATTERY off and GMIB_ONBATTERY on.
    //
    //  dwResult & GMIB_ONBATTERY means we have yet to find AC power.
    //  dwResult & GMIB_HASBATTERY means we have found a non-UPS battery.
    //
    DWORD dwResult = GMIB_ONBATTERY;

    //------------------------------------------------------------------
    //
    //  First try - IOCTL_BATTERY_QUERY_INFORMATION
    //
    //------------------------------------------------------------------
    //
    //  Windows 98 and Windows 2000 support IOCTL_BATTERY_QUERY_INFORMATION,
    //  which lets us enumerate the batteries and ask each one for information.
    //  Except that on Windows 98, we can enumerate only ACPI batteries.
    //  We still have to use VPOWERD to enumerate APM batteries.
    //  FEATURE -- deal with Win98 APM batteries

    HDEVINFO hdev = SetupDiGetClassDevs(&GUID_DEVICE_BATTERY, 0, 0,
                        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if (hdev != INVALID_HANDLE_VALUE) {
        SP_DEVICE_INTERFACE_DATA did;
        did.cbSize = sizeof(did);
        // Stop at 100 batteries so we don't go haywire
        for (int idev = 0; idev < 100; idev++) {
            // Pre-set the error code because our DLLLOAD wrapper doesn't
            // and Windows NT 4 supports SetupDiGetClassDevs but not
            // SetupDiEnumDeviceInterfaces (go figure).
            SetLastError(ERROR_NO_MORE_ITEMS);
            if (SetupDiEnumDeviceInterfaces(hdev, 0, &GUID_DEVICE_BATTERY, idev, &did)) {
                DWORD cbRequired = 0;

                /*
                 *  Ask for the required size then allocate it then fill it.
                 *
                 *  Sigh.  Windows NT and Windows 98 implement
                 *  SetupDiGetDeviceInterfaceDetail differently if you are
                 *  querying for the buffer size.
                 *
                 *  Windows 98 returns FALSE, and GetLastError() returns
                 *  ERROR_INSUFFICIENT_BUFFER.
                 *
                 *  Windows NT returns TRUE.
                 *
                 *  So we allow the cases either where the call succeeds or
                 *  the call fails with ERROR_INSUFFICIENT_BUFFER.
                 */

                if (SetupDiGetDeviceInterfaceDetail(hdev, &did, 0, 0, &cbRequired, 0) ||
                    GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                    PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;
                    pdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)LocalAlloc(LPTR, cbRequired);
                    if (pdidd) {
                        pdidd->cbSize = sizeof(*pdidd);
                        if (SetupDiGetDeviceInterfaceDetail(hdev, &did, pdidd, cbRequired, &cbRequired, 0)) {
                            /*
                             *  Finally enumerated a battery.  Ask it for information.
                             */
                            HANDLE hBattery = CreateFile(pdidd->DevicePath,
                                                         GENERIC_READ | GENERIC_WRITE,
                                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                         NULL, OPEN_EXISTING,
                                                         FILE_ATTRIBUTE_NORMAL, NULL);
                            if (hBattery != INVALID_HANDLE_VALUE) {
                                /*
                                 *  Now you have to ask the battery for its tag.
                                 */
                                BATTERY_QUERY_INFORMATION bqi;

                                DWORD dwWait = 0;
                                DWORD dwOut;
                                bqi.BatteryTag = 0;

                                if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_TAG,
                                                    &dwWait, sizeof(dwWait),
                                                    &bqi.BatteryTag, sizeof(bqi.BatteryTag),
                                                    &dwOut, NULL) && bqi.BatteryTag) {
                                    /*
                                     *  With the tag, you can query the battery info.
                                     */
                                    BATTERY_INFORMATION bi;
                                    bqi.InformationLevel = BatteryInformation;
                                    bqi.AtRate = 0;
                                    if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_INFORMATION,
                                                        &bqi, sizeof(bqi),
                                                        &bi,  sizeof(bi),
                                                        &dwOut, NULL)) {
                                        // Only system batteries count
                                        if (bi.Capabilities & BATTERY_SYSTEM_BATTERY)  {
                                            if (!(bi.Capabilities & BATTERY_IS_SHORT_TERM)) {
                                                dwResult |= GMIB_HASBATTERY;
                                            }

                                            /*
                                             *  And then query the battery status.
                                             */
                                            BATTERY_WAIT_STATUS bws;
                                            BATTERY_STATUS bs;
                                            ZeroMemory(&bws, sizeof(bws));
                                            bws.BatteryTag = bqi.BatteryTag;
                                            if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_STATUS,
                                                                &bws, sizeof(bws),
                                                                &bs,  sizeof(bs),
                                                                &dwOut, NULL)) {
                                                if (bs.PowerState & BATTERY_POWER_ON_LINE) {
                                                    dwResult &= ~GMIB_ONBATTERY;
                                                }
                                            }
                                        }
                                    }
                                }
                                CloseHandle(hBattery);
                            }
                        }
                        LocalFree(pdidd);
                    }
                }
            } else {
                // Enumeration failed - perhaps we're out of items
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
                    break;
            }
        }
        SetupDiDestroyDeviceInfoList(hdev);

    }

    //
    //  On Windows NT, SetupDi tells us everything there is to know.
    //  So once you get this far, you're finished.
    //
    if (g_bRunningOnNT) {
        goto finish;
    }

    //------------------------------------------------------------------
    //
    //  Second try - GetSystemPowerStatus
    //
    //------------------------------------------------------------------
    //
    //  On Windows 9x, GetSystemPowerStatus enumerates a disjoint set of
    //  batteries from SetupDi, so it's worth calling to find out.
    //

    SYSTEM_POWER_STATUS status;

    if (GetSystemPowerStatus(&status)) {
        //
        //  HACKHACK:   Some APM BIOS implementations set BatteryFlag = 0
        //              instead of 128 or 255 when they don't have a
        //              battery, so we have to check both.
        //
        if (status.BatteryFlag != 0 &&
            !(status.BatteryFlag & SPSBF_NOBATTERY)) {
            //
            // Found an APM battery.
            //
            dwResult |= GMIB_HASBATTERY;
        }

        if (status.ACLineStatus == SPSAC_ONLINE) {
            dwResult &= ~GMIB_ONBATTERY;
        }
    }

#ifdef TRY_NtPowerInformation // Hopefully the Third Try won't be necessary
    SYSTEM_POWER_CAPABILITIES caps;

    //------------------------------------------------------------------
    //
    //  Third try - NtPowerInformation
    //
    //------------------------------------------------------------------
    //
    //  NtPowerInformation is supported on Win98 and Windows 2000, but not
    //  Windows 95 or NT4.
    //
    if (SUCCEEDED(NtPowerInformation(SystemPowerCapabilities, NULL, 0,
                                     &caps, sizeof(caps)))) {

        if (caps.BatteriesAreShortTerm) {
            #error futz futz
        }

        if (caps.SystemBatteriesPresent && !fFoundUPS) {
            #error futz futz
        }

    }

#endif // TRY_NtPowerInformation

finish:
    //
    //  Final cleanup:  If we didn't find a battery, then presume that we
    //  are on AC power.
    //
    if (!(dwResult & GMIB_HASBATTERY))
        dwResult &= ~GMIB_ONBATTERY;

    return dwResult;
}

/*****************************************************************************
 *
 *  TERMINAL SERVER CLIENT
 *
 *  This is particularly gruesome because Terminal Server for NT4 SP3 goes
 *  to extraordinary lengths to prevent you from detecting it.  Even the
 *  semi-documented NtCurrentPeb()->SessionId trick doesn't work on NT4 SP3.
 *  So we have to go to the totally undocumented winsta.dll to find out.
 *
 *****************************************************************************/

BOOL g_fTSClient = -1;  // Tri-state, 0 = no, 1 = yes, -1 = don't know

BOOL IsTSClientNT4(void)
{
    BOOL fTS = FALSE;       // Assume not

    HINSTANCE hinstWinSta = LoadLibrary("winsta.dll");
    if (hinstWinSta) {
        PWINSTATIONQUERYINFORMATIONW WinStationQueryInformationW;
        WINSTATIONINFORMATIONW wi;
        WinStationQueryInformationW = (PWINSTATIONQUERYINFORMATIONW)
                    GetProcAddress(hinstWinSta, "WinStationQueryInformationW");
        if (WinStationQueryInformationW &&
            WinStationQueryInformationW(SERVERNAME_CURRENT, LOGONID_CURRENT, WinStationInformation, &wi, sizeof(wi), NULL) &&
            wi.LogonId != 0) {
            fTS = TRUE;
        }
        FreeLibrary(hinstWinSta);
    }

    return fTS;
}

BOOL IsTSClient(void)
{
    if (!g_bRunningOnNT) {
        // Windows 9x doesn't support Terminal Server
        return FALSE;
    } else if (g_bRunningOnNT5OrHigher) {
        // NT5 has a new system metric to detect this
        return GetSystemMetrics(SM_REMOTESESSION);
    } else {
        // NT4 is gross and evil.  This is slow, so cache the result.
        if (g_fTSClient < 0)
            g_fTSClient = IsTSClientNT4();
        return g_fTSClient;
    }
}

/*****************************************************************************
 *
 *  SHGetMachineInfo
 *
 *****************************************************************************/

//
//  SHGetMachineInfo
//
//  Given an index, returns some info about that index.  See shlwapi.w
//  for documentation on the flags available.
//
STDAPI_(DWORD_PTR) SHGetMachineInfo(UINT gmi)
{
    switch (gmi) {
    case GMI_DOCKSTATE:
        return GetDockedState();

    case GMI_BATTERYSTATE:
        return GetBatteryState();

    //
    //  It smell like a laptop if it has a battery or if it can be docked.
    //
    case GMI_LAPTOP:
        return (GetBatteryState() & GMIB_HASBATTERY) ||
               (GetDockedState() != GMID_NOTDOCKABLE);

    case GMI_TSCLIENT:
        return IsTSClient();
    }

    TraceMsg(DM_WARNING, "SHGetMachineInfo: Unknown info query %d", gmi);
    return 0;
}

#else

STDAPI_(DWORD_PTR) SHGetMachineInfo(UINT gmi)
{
    // IEUNIX : Stubbed out this api to resolve undefind symbol in linking.
    TraceMsg(DM_WARNING, "SHGetMachineInfo: Unknown info query %d", gmi);
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\helpmb.cpp ===
//
// SHMessageBoxHelp implementation
//
// History
//  01/14/00 dsheldon created
//

#include "priv.h"
#include "ids.h"
#include <htmlhelp.h>
#include "apithk.h"

HRESULTHELPMAPPING g_prghhmShellDefault[] =
{
    {HRESULT_FROM_WIN32(ERROR_NO_NETWORK),   "tshoot00.chm>windefault",      "w0networking.htm"      },
};

class CHelpMessageBox
{
public:
    CHelpMessageBox(HRESULTHELPMAPPING* prghhm, DWORD chhm);
    int DoHelpMessageBox(HWND hwndParent, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType, HRESULT hrErr);

private:
    int DisplayMessageBox(HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType);
    HRESULTHELPMAPPING* GetHResultHelpMapping(HRESULT hrErr, HRESULTHELPMAPPING* prghhm, DWORD chhm);
    
    static INT_PTR CALLBACK StaticDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Data
    HRESULTHELPMAPPING*   _prghhm;
    DWORD                 _chhm;

    HRESULTHELPMAPPING*   _phhmEntry;

    LPCWSTR                _pszText;
    LPCWSTR                _pszCaption;
    UINT                   _uType;
};


CHelpMessageBox::CHelpMessageBox(HRESULTHELPMAPPING* prghhm, DWORD chhm)
{
    // Initialize class members
    _phhmEntry = NULL;
    _prghhm = prghhm;
    _chhm = chhm;
}


int CHelpMessageBox::DisplayMessageBox(HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType)
{
    LPWSTR pszAllocString = NULL;

    if (NULL != _phhmEntry)
    {
        uType |= MB_HELP;

        // Need to add the "For more information, click help." string.
        WCHAR szMoreInfo[256];

        if (LoadStringW(HINST_THISDLL, IDS_CLICKHELPFORINFO, szMoreInfo, ARRAYSIZE(szMoreInfo)))
        {
            DWORD cchText = lstrlenW(pszText);

            // The 3 here are for '\n', '\n', '\0'
            DWORD cchBuffer = cchText + lstrlenW(szMoreInfo) + 3;

            pszAllocString = (LPWSTR) LocalAlloc(0, cchBuffer * sizeof (WCHAR));

            if (pszAllocString)
            {
                StrCpyW(pszAllocString, pszText);
                StrCpyW(pszAllocString + cchText, L"\n\n");
                StrCpyW(pszAllocString + cchText + 2, szMoreInfo);
            }
        }
    }
    else
    {
        // No help topic mapping for this error
        TraceMsg(TF_WARNING, "No help topic mapping for this error. Removing help button.");
        uType &= (~MB_HELP);
    }

    int iReturn = MessageBoxWrapW(hwnd, pszAllocString ? pszAllocString : pszText, pszCaption, uType);

    if (pszAllocString)
    {
        LocalFree(pszAllocString);
    }

    return iReturn;
}

HRESULTHELPMAPPING* CHelpMessageBox::GetHResultHelpMapping(HRESULT hrErr, HRESULTHELPMAPPING* prghhm, DWORD chhm)
{
    HRESULTHELPMAPPING* phhm = NULL;

    for (DWORD i = 0; i < chhm; i++)
    {
        if (prghhm[i].hr == hrErr)
        {
            phhm = &(prghhm[i]);
            break;
        }
    }    

    return phhm;
}

CHelpMessageBox::DoHelpMessageBox(HWND hwndParent, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType, HRESULT hrErr)
{
    int iReturn = 0;
    _pszText = pszText;
    _pszCaption = pszCaption;
    _uType = uType;

    // Find the index of the help topic matching the hresult
    // First search the mapping the user passed in, if present
    if (NULL != _prghhm)
    {
        _phhmEntry = GetHResultHelpMapping(hrErr, _prghhm, _chhm);
    }

    // If we didn't find a mapping in the caller's list, search the shell's global list
    if (NULL == _phhmEntry)
    {
        _phhmEntry = GetHResultHelpMapping(hrErr, g_prghhmShellDefault, ARRAYSIZE(g_prghhmShellDefault));
    }

    ULONG_PTR ul;
    HANDLE h = XP_CreateAndActivateContext(&ul);
    iReturn = (int) DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_NULL), hwndParent, StaticDlgProc, (LPARAM) this);
    XP_DeactivateAndDestroyContext(h, ul);

    return iReturn;
}

INT_PTR CHelpMessageBox::StaticDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHelpMessageBox* pthis = NULL;
    
    if (uMsg == WM_INITDIALOG)
    {
        pthis = (CHelpMessageBox*) lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pthis);
    }
    else
    {
        pthis = (CHelpMessageBox*) GetWindowLongPtr(hwnd, DWLP_USER);
    }

    if (NULL != pthis)
    {
        return pthis->DlgProc(hwnd, uMsg, wParam, lParam);
    }
 
    return 0;
}

INT_PTR CHelpMessageBox::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR iReturn = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Launch Messagebox
        {
            int i = DisplayMessageBox(hwnd, _pszText, _pszCaption, _uType);

            EndDialog(hwnd, i);
        }

        iReturn = TRUE;

        break;
    case WM_HELP:
        // Call the appropriate help topic
        ASSERT(_phhmEntry != NULL);

        HtmlHelpA(
            hwnd, 
            _phhmEntry->szHelpFile, 
            HH_DISPLAY_TOPIC,
            (DWORD_PTR) _phhmEntry->szHelpTopic);
        
        break;
    default:
        break;
    }

    return iReturn;
}

STDAPI_(int) SHMessageBoxHelpA(HWND hwnd, 
                               LPCSTR pszText, 
                               LPCSTR pszCaption, 
                               UINT uType,
                               HRESULT hrErr,
                               HRESULTHELPMAPPING* prghhm,
                               DWORD chhm)
{
    WCHAR szTextW[1024];
    WCHAR szCaptionW[256];

    CHelpMessageBox parent(prghhm, chhm);

    if (!SHAnsiToUnicode(pszText, szTextW, ARRAYSIZE(szTextW)))
    {
        *szTextW = 0;
    }

    if (!SHAnsiToUnicode(pszCaption, szCaptionW, ARRAYSIZE(szCaptionW)))
    {
        *szCaptionW = 0;
    }

    return parent.DoHelpMessageBox(hwnd, szTextW, szCaptionW, uType, hrErr);
}

STDAPI_(int) SHMessageBoxHelpW(HWND hwnd, 
                               LPCWSTR pszText, 
                               LPCWSTR pszCaption, 
                               UINT uType,
                               HRESULT hrErr,
                               HRESULTHELPMAPPING* prghhm,
                               DWORD chhm)
{
    CHelpMessageBox parent(prghhm, chhm);
    return parent.DoHelpMessageBox(hwnd, pszText, pszCaption, uType, hrErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\native.cpp ===
// Contains code that needs to be dual compiled, once for ansi and once for unicode
#include "priv.h"
#include <memt.h>

#ifdef _X86_
#include <w95wraps.h>
#endif

BOOL _PathAppend(LPCTSTR pszBase, LPCTSTR pszAppend, LPTSTR pszOut, DWORD cchOut)
{
    DWORD cchBase = lstrlen(pszBase);

    //  +1 is one for the whack
    if (cchOut > cchBase + lstrlen(pszAppend) + 1)
    {
        StrCpy(pszOut, pszBase);
        pszOut+=cchBase;
        *pszOut++ = TEXT('\\');
        StrCpy(pszOut, pszAppend);
        return TRUE;
    }
    return FALSE;
}

LWSTDAPI AssocMakeFileExtsToApplication(ASSOCMAKEF flags, LPCTSTR pszExt, LPCTSTR pszApplication)
{
    RIP(!IsOS(OS_WHISTLERORGREATER));
    DWORD err = ERROR_SUCCESS;
    WCHAR sz[MAX_PATH];
    SHTCharToUnicode(pszExt, sz, ARRAYSIZE(sz));
    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_FILEEXTS, sz, pszApplication != NULL);
    if (hk)
    {
        if (pszApplication)
        {
            err = SHSetValue(hk, NULL, TEXT("Application"),
                REG_SZ, pszApplication, CbFromCch(lstrlen(pszApplication) +1));
        }
        else  //  we should always clear
            err = SHDeleteValue(hk, NULL, TEXT("Application"));

        RegCloseKey(hk);
    }
    else
        err = GetLastError();

    return HRESULT_FROM_WIN32(err);
}

HRESULT _AllocValueString(HKEY hkey, LPCTSTR pszKey, LPCTSTR pszVal, LPTSTR *ppsz)
{
    DWORD cb, err;
    err = SHGetValue(hkey, pszKey, pszVal, NULL, NULL, &cb);

    ASSERT(ppsz);
    *ppsz = NULL;

    if (NOERROR == err)
    {
        LPTSTR psz = (LPTSTR) LocalAlloc(LPTR, cb);

        if (psz)
        {
            err = SHGetValue(hkey, pszKey, pszVal, NULL, (LPVOID)psz, &cb);

            if (NOERROR == err)
                *ppsz = psz;
            else
                LocalFree(psz);
        }
        else
            err = ERROR_OUTOFMEMORY;
    }

    return HRESULT_FROM_WIN32(err);
}


// <Swipped from the NT5 version of Shell32>
#define SZ_REGKEY_FILEASSOCIATION TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileAssociation")

LWSTDAPI_(void) PrettifyFileDescription(LPTSTR pszDesc, LPCTSTR pszCutList)
{
    LPTSTR pszCutListReg;

    if (!pszDesc || !*pszDesc)
        return;

    // get the Cut list from registry
    //  this is MULTI_SZ
    if (S_OK == _AllocValueString(HKEY_LOCAL_MACHINE, SZ_REGKEY_FILEASSOCIATION, TEXT("CutList"), &pszCutListReg))
    {
        pszCutList = pszCutListReg;
    }

    if (pszCutList)
    {

        // cut strings in cut list from file description
        for (LPCTSTR pszCut = pszCutList; *pszCut; pszCut = pszCut + lstrlen(pszCut) + 1)
        {
            LPTSTR pch = StrRStrI(pszDesc, NULL, pszCut);

            // cut the exact substring from the end of file description
            if (pch && !*(pch + lstrlen(pszCut)))
            {
                *pch = '\0';

                // remove trailing spaces
                for (--pch; (pch >= pszDesc) && (TEXT(' ') == *pch); pch--)
                    *pch = 0;

                break;
            }
        }

        if (pszCutListReg)
            LocalFree(pszCutListReg);
    }
}

/*
    <Swipped from the NT5 version of Shell32>

    GetFileDescription retrieves the friendly name from a file's verion rsource.
    The first language we try will be the first item in the
    "\VarFileInfo\Translations" section;  if there's nothing there,
    we try the one coded into the IDS_VN_FILEVERSIONKEY resource string.
    If we can't even load that, we just use English (040904E4).  We
    also try English with a null codepage (04090000) since many apps
    were stamped according to an old spec which specified this as
    the required language instead of 040904E4.

    If there is no FileDescription in version resource, return the file name.

    Parameters:
        LPCTSTR pszPath: full path of the file
        LPTSTR pszDesc: pointer to the buffer to receive friendly name. If NULL,
                        *pcchDesc will be set to the length of friendly name in
                        characters, including ending NULL, on successful return.
        UINT *pcchDesc: length of the buffer in characters. On successful return,
                        it contains number of characters copied to the buffer,
                        including ending NULL.

    Return:
        TRUE on success, and FALSE otherwise
*/
BOOL WINAPI SHGetFileDescription(LPCTSTR pszPath, LPCTSTR pszVersionKeyIn, LPCTSTR pszCutListIn, LPTSTR pszDesc, UINT *pcchDesc)
{
    UINT cchValue = 0;
    TCHAR szPath[MAX_PATH], *pszValue = NULL;
    DWORD dwAttribs;

    DWORD dwHandle;                 /* version subsystem handle */
    DWORD dwVersionSize;            /* size of the version data */
    LPTSTR lpVersionBuffer = NULL;  /* pointer to version data */
    TCHAR szVersionKey[60];         /* big enough for anything we need */

    struct _VERXLATE
    {
        WORD wLanguage;
        WORD wCodePage;
    } *lpXlate;                     /* ptr to translations data */

    ASSERT(pszPath && *pszPath && pcchDesc);

    if (!PathFileExistsAndAttributes(pszPath, &dwAttribs))
    {
        return FALSE;
    }

    // copy the path to the dest dir
    lstrcpyn(szPath, pszPath, ARRAYSIZE(szPath));

    if ((dwAttribs & FILE_ATTRIBUTE_DIRECTORY)  ||
        PathIsUNCServer(pszPath)                ||
        PathIsUNCServerShare(pszPath))
    {
        // bail in the \\server, \\server\share, and directory case or else GetFileVersionInfo() will try
        // to do a LoadLibraryEx() on the path (which will fail, but not before we seach the entire include
        // path which can take a long time)
        goto Exit;
    }


    dwVersionSize = GetFileVersionInfoSize(szPath, &dwHandle);
    if (dwVersionSize == 0L)
        goto Exit;                 /* no version info */

    lpVersionBuffer = (LPTSTR)LocalAlloc(LPTR, dwVersionSize);
    if (lpVersionBuffer == NULL)
        goto Exit;

    if (!GetFileVersionInfo(szPath, dwHandle, dwVersionSize, lpVersionBuffer))
        goto Exit;

    // Try same language as the caller
    if (pszVersionKeyIn)
    {
        lstrcpyn(szVersionKey, pszVersionKeyIn, ARRAYSIZE(szVersionKey));

        if (VerQueryValue(lpVersionBuffer, szVersionKey, (void **)&pszValue, &cchValue))
        {
            goto Exit;
        }
    }

    // Try first language this supports
    // Look for translations
    if (VerQueryValue(lpVersionBuffer, TEXT("\\VarFileInfo\\Translation"),
                      (void **)&lpXlate, &cchValue)
        && cchValue)
    {
        wnsprintf(szVersionKey, ARRAYSIZE(szVersionKey), TEXT("\\StringFileInfo\\%04X%04X\\FileDescription"),
                 lpXlate[0].wLanguage, lpXlate[0].wCodePage);
        if (VerQueryValue(lpVersionBuffer, szVersionKey, (void **)&pszValue, &cchValue))
            goto Exit;

    }

#ifdef UNICODE
    // try English, unicode code page
    lstrcpy(szVersionKey, TEXT("\\StringFileInfo\\040904B0\\FileDescription"));
    if (VerQueryValue(lpVersionBuffer, szVersionKey, (void **)&pszValue, &cchValue))
        goto Exit;
#endif

    // try English
    lstrcpy(szVersionKey, TEXT("\\StringFileInfo\\040904E4\\FileDescription"));
    if (VerQueryValue(lpVersionBuffer, szVersionKey, (void **)&pszValue, &cchValue))
        goto Exit;

    // try English, null codepage
    lstrcpy(szVersionKey, TEXT("\\StringFileInfo\\04090000\\FileDescription"));
    if (VerQueryValue(lpVersionBuffer, szVersionKey, (void **)&pszValue, &cchValue))
        goto Exit;

Exit:
    if (!pszValue || !*pszValue)
    {
        // Could not find FileVersion info in a reasonable format, return file name
        PathRemoveExtension(szPath);
        pszValue = PathFindFileName(szPath);
        cchValue = lstrlen(pszValue);
    }

    PrettifyFileDescription(pszValue, pszCutListIn);
    cchValue = lstrlen(pszValue) + 1;

    if (!pszDesc)   // only want to know the length of the friendly name
        *pcchDesc = cchValue;
    else
    {
        *pcchDesc = min(*pcchDesc, cchValue);
        lstrcpyn(pszDesc, pszValue, *pcchDesc);
    }

    if (lpVersionBuffer)
        LocalFree(lpVersionBuffer);

    return TRUE;
}

// Convert LPTSTR to LPSTR and return TRUE if the LPSTR can
// be converted back to LPTSTR without unacceptible data loss
//
BOOL DoesStringRoundTrip(LPCTSTR pwszIn, LPSTR pszOut, UINT cchOut)
{
#ifdef UNICODE
    // On NT5 we have to be more stringent since you can switch UI
    // languages on the fly, thereby breaking this constant codepage
    // assumption inherent in the downlevel implementations.
    //
    // we have to support the function being called with a null pszOut
    // just to determine if pwszIn will roundtrip
    //
    if (g_bRunningOnNT5OrHigher)
    {
        LPCTSTR pIn = pwszIn;
        LPSTR pOut = pszOut;
        UINT cch = cchOut;

        while (*pIn)
        {
            if (*pIn > ((TCHAR)127))
            {
                if (cchOut) // caller has provided a buffer
                {
#ifdef DEBUG
                    SHUnicodeToAnsiCP(CP_ACPNOVALIDATE, pwszIn, pszOut, cchOut);
#else                
                    SHUnicodeToAnsi(pwszIn, pszOut, cchOut);                                    
#endif
                }
                return FALSE;
            }

            if (cch) // we have a buffer and it still has space
            {
                *pOut++ = (char)*pIn;
                if (!--cch)
                {
                    break; // out buffer filled, leave.  
                }                                        
            }

            pIn++;
                        
        }

        // Null terminate the out buffer
        if (cch)
        {
            *pOut = '\0';
        }
        else if (cchOut)
        {
            *(pOut-1) = '\0';
        }

        // Everything was low ascii, no dbcs worries and it will always round-trip
        return TRUE;
    }
    else
    // but we probably don't want to change downlevel shell behavior
    // in this regard, so we keep that implementation:
    //
    {
        BOOL fRet = FALSE;
        WCHAR wszTemp[MAX_PATH];
        LPWSTR pwszTemp = wszTemp;
        UINT cchTemp = ARRAYSIZE(wszTemp);

        // We better have enough room for the buffer.
        if (ARRAYSIZE(wszTemp) < cchOut)
        {
            pwszTemp = (LPWSTR)LocalAlloc(LPTR, cchOut*sizeof(WCHAR));
            cchTemp = cchOut;
        }
        if (pwszTemp)
        {
#ifdef DEBUG
            SHUnicodeToAnsiCP(CP_ACPNOVALIDATE, pwszIn, pszOut, cchOut);
#else
            SHUnicodeToAnsi(pwszIn, pszOut, cchOut);
#endif
            SHAnsiToUnicode(pszOut, pwszTemp, cchTemp);
            fRet = StrCmpCW(pwszIn, pwszTemp) == 0;     // are they the same?

            if (pwszTemp != wszTemp)
            {
                LocalFree(pwszTemp);
            }
        }
        return fRet;
    }

#else

    StrCpyN(pszOut, pwszIn, cchOut);
    return TRUE;
#endif
}

DWORD _ExpandRegString(PTSTR pszData, DWORD cchData, DWORD *pcchSize)
{
    DWORD err = ERROR_OUTOFMEMORY;
    PTSTR psz = StrDup(pszData);
    if (psz)
    {
        //  now we will try to expand back into the target buffer
        //  NOTE we deliberately dont use SHExpandEnvironmentStrings
        //  since it will not give us the size we need
        //  we have to use 
#ifdef UNICODE        
        *pcchSize = ExpandEnvironmentStringsW(psz, pszData, cchData);
#else        
        *pcchSize = ExpandEnvironmentStringsA(psz, pszData, cchData);
#endif        
        
        if (*pcchSize > 0)
        {
            if (*pcchSize <=  cchData) 
            {
                err = NO_ERROR;
            }
            else
            {
                //  pcchSize returns the needed size
                err = ERROR_MORE_DATA;
            }
        }
        else
            err = GetLastError();

        LocalFree(psz);
    }
    
    return err;
}

                
DWORD _SizeExpandString(HKEY hk, PCTSTR pszValue, void *pvData, DWORD *pcbSize)
{
    DWORD err = ERROR_OUTOFMEMORY;
    //  *pcbSize is the size required by RegQueryValueEx
    // Find out the length of the expanded string
    // we have to call in and actually get the data to do this
    PTSTR psz;
    if (SUCCEEDED(SHLocalAlloc(*pcbSize + sizeof(TCHAR), &psz)))
    {
        err = RegQueryValueEx(hk, pszValue, NULL, NULL, (LPBYTE)psz, pcbSize);
        // ASSERT(err != ERROR_MORE_DATA);
        if (NO_ERROR == err)
        {
            TCHAR szBuff[1];
            // insure NULL termination with our extra char
            psz[*pcbSize/sizeof(TCHAR)] = 0;
#ifdef UNICODE        
            DWORD cbExpand = CbFromCchW(ExpandEnvironmentStringsW(psz, szBuff, ARRAYSIZE(szBuff)));
#else        
            DWORD cbExpand = CbFromCchA(ExpandEnvironmentStringsA(psz, szBuff, ARRAYSIZE(szBuff)));
#endif        
            if (cbExpand > *pcbSize)
                *pcbSize = cbExpand;
        }
        LocalFree(psz);

        //  if pvData is NULL then we return success (caller is sizing)
        //  if pvData is non-NULL we need to return ERROR_MORE_DATA
        if (err == NO_ERROR && pvData)
            err = ERROR_MORE_DATA;
    }
    return err;
}

#ifdef UNICODE
#define FixupRegString FixupRegStringW
#else
#define FixupRegString FixupRegStringA
#endif

STDAPI_(DWORD) FixupRegString(HKEY hk, PCTSTR pszValue, BOOL fExpand, DWORD err, void *pvData, DWORD *pcbData, DWORD *pcbSize)
{
    BOOL fNeedsSize = FALSE;
    if ((NO_ERROR == err && pvData))
    {
        PTSTR pszData = (PTSTR)pvData;
        DWORD cchSize = *pcbSize / sizeof(TCHAR);
        DWORD cchData = *pcbData / sizeof(TCHAR);

        // Note: on Win95, RegSetValueEx will always write the 
        // full string out, including the null terminator.  On NT,
        // it won't unless the right length was specified.  
        // Hence, we have the following check for termination
        
        //  FRINGE: if you get back exactly the size you asked for
        //  and its not NULL terminated, then we need to 
        //  treat it like ERROR_MORE_DATA
        //  if the value was empty, treat it like a non-terminated string
        if (!cchSize || pszData[cchSize - 1])
        {
            // this string was not NULL terminated
            if (cchData > cchSize)
            {
                //  NULL terminate just in case
                pszData[cchSize++] = 0;
            }
            else
            {
                ASSERT(cchData == cchSize);
                fNeedsSize = TRUE;
            }
        }

        if (!fNeedsSize)
        {
            //  this will expand if necessary and 
            //  if the expand overflows, return ERROR_MORE_DATA
            if (fExpand)
                err = _ExpandRegString(pszData, cchData, &cchSize);

            *pcbSize = CbFromCch(cchSize);
        }
    }
    else if (pcbData && (err == ERROR_MORE_DATA || (NO_ERROR == err && !pvData)))
    {
        //  we need to calculate if:
        //      1.  the RegQueryValueEx() says there is not enough room
        //      2.  the caller is requesting the size
        fNeedsSize = TRUE;
    }

    if (fNeedsSize )
    {
        if (fExpand)
        {
            err = _SizeExpandString(hk, pszValue, pvData, pcbSize);
        }
        else
        {
            pcbSize += sizeof(TCHAR);
            err = pvData ? ERROR_MORE_DATA : NO_ERROR;
        }
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\nullstm.cpp ===
#include "priv.h"
#include "nullstm.h"

#ifndef UNIX

// A static empty stream implementation, for back compat & no memory hit
//
// Macros copied from cfdefs.h
//
#define STDMETHODX(fn)      HRESULT STDMETHODCALLTYPE fn
#define STDMETHODX_(ret,fn) ret STDMETHODCALLTYPE fn
class CNullStream {
public:
    IStream *vtable;
    
    STDMETHODX (QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHODX_(ULONG, AddRef)();
    STDMETHODX_(ULONG, Release)();

    STDMETHODX (Read)(void *pv, ULONG cb, ULONG *pcbRead) { if (pcbRead) *pcbRead = 0; return E_NOTIMPL; }
    STDMETHODX (Write)(void const *pv, ULONG cb, ULONG *pcbWritten) { if (pcbWritten) *pcbWritten = 0; return E_NOTIMPL; }
    STDMETHODX (Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition) { plibNewPosition->HighPart = plibNewPosition->LowPart = 0; return E_NOTIMPL; }
    STDMETHODX (SetSize)(ULARGE_INTEGER libNewSize) { return E_NOTIMPL; }
    STDMETHODX (CopyTo)(IStream *, ULARGE_INTEGER, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten) { if (pcbRead) pcbRead->LowPart = pcbRead->HighPart = 0; if (pcbWritten) pcbWritten->LowPart = pcbWritten->HighPart = 0; return E_NOTIMPL; }
    STDMETHODX (Commit)(DWORD) { return E_NOTIMPL; }
    STDMETHODX (Revert)() { return E_NOTIMPL; }
    STDMETHODX (LockRegion)(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODX (UnlockRegion)(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODX (Stat)(STATSTG *, DWORD) { return E_NOTIMPL; }
    STDMETHODX (Clone)(IStream **ppstm) { *ppstm = NULL; return E_NOTIMPL; }
};

STDMETHODIMP CNullStream::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IStream) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj=this;
        // DllAddRef(); // if this dll supported CoCreateInstance
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}
STDMETHODIMP_(ULONG) CNullStream::AddRef()
{
    // DllAddRef(); // if this dll supported CoCreateInstance
    return 2;
}
STDMETHODIMP_(ULONG) CNullStream::Release()
{
    // DllRelease(); // if this dll supported CoCreateInstance
    return 1;
}

// We need the C vtable declaration, but this is .CPP.
// Simulate the vtable, swiped from objidl.h and touched up.
//
typedef struct IStreamVtbl
{
    HRESULT ( STDMETHODCALLTYPE CNullStream::*QueryInterface )(REFIID riid, void **ppvObject);
    ULONG ( STDMETHODCALLTYPE CNullStream::*AddRef )( );
    ULONG ( STDMETHODCALLTYPE CNullStream::*Release )( );
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Read )( 
        void *pv,
        ULONG cb,
        ULONG *pcbRead);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Write )( 
        const void *pv,
        ULONG cb,
        ULONG *pcbWritten);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Seek )( 
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *plibNewPosition);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*SetSize )( 
        ULARGE_INTEGER libNewSize);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*CopyTo )( 
        IStream *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Commit )( 
        DWORD grfCommitFlags);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Revert )( );
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*LockRegion )( 
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*UnlockRegion )( 
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Stat )( 
        STATSTG *pstatstg,
        DWORD grfStatFlag);
    
    HRESULT ( STDMETHODCALLTYPE CNullStream::*Clone )( 
        IStream **ppstm);
    
} IStreamVtbl;


IStream* SHConstNullStream()
{
    static const IStreamVtbl c_NullStream = {
        CNullStream::QueryInterface, 
        CNullStream::AddRef,
        CNullStream::Release,
        CNullStream::Read,
        CNullStream::Write,
        CNullStream::Seek,
        CNullStream::SetSize,
        CNullStream::CopyTo,
        CNullStream::Commit,
        CNullStream::Revert,
        CNullStream::LockRegion,
        CNullStream::UnlockRegion,
        CNullStream::Stat,
        CNullStream::Clone,
    };
    static const void * vtable = (void*)&c_NullStream;

    return (IStream*)&vtable;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\mlui.cpp ===
#include "priv.h"
#include <regapix.h>
#include <htmlhelp.h>
#include <shlwapi.h>
#include <wininet.h>    // INTERNET_MAX_URL_LENGTH
#include "mlui.h"
#include "unicwrap.h"
#include "thunk.h"

//
//  Do this in every wrapper function to make sure the wrapper
//  prototype matches the function it is intending to replace.
//
#define VALIDATE_PROTOTYPE(f) if (f##W == f##WrapW) 0
#define VALIDATE_PROTOTYPE_DELAYLOAD(fWrap, fDelay) if (fDelay##W == fWrap##WrapW) 0
#define VALIDATE_PROTOTYPE_NO_W(f) if (f## == f##Wrap) 0

//
//  Registry Key
//
const CHAR c_szInstall[] = "Software\\Microsoft\\Active Setup\\Installed Components\\{89820200-ECBD-11CF-8B85-00AA005B4383}";
const CHAR c_szLocale[] = "Locale";
const CHAR c_szOffice9[] = "Software\\Microsoft\\Office\\9.0\\Common\\LanguageResources";
const CHAR c_szOffice10[] = "Software\\Microsoft\\Shared";
const CHAR c_szUILanguage[] = "UILanguage";
const CHAR c_szOffice10UILanguage[] = "OfficeUILanguage";
const CHAR c_szInternational[] = "Software\\Microsoft\\Internet Explorer\\International";
const CHAR c_szResourceLocale[] = "ResourceLocale";
const WCHAR c_wszAppPaths[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\iexplore.exe";
const WCHAR c_wszMUI[] = L"mui";
const TCHAR s_szLangPackPath[]   = TEXT("Software\\Microsoft\\Internet Explorer");
const TCHAR s_szVersion[] = TEXT("LPKInstalled");
const WCHAR c_wszWebTemplate[] = L"\\Web\\%s";
const WCHAR c_wszMuiTemplate[] = L"\\Web\\mui\\%04x\\%s";
const CHAR c_szNT4ResourceLocale[] = ".DEFAULT\\Control Panel\\International";
const CHAR c_szWin9xResourceLocale[] = ".Default\\Control Panel\\desktop\\ResourceLocale";
const CHAR c_szCheckVersion[] = "CheckVersion";
//
//  ISO639 ID table
//
typedef struct tagISO639
{
    LPCSTR ISO639;
    LANGID LangID;
}   ISO639, *LPISO639;

const ISO639 c_ISO639[] =
{
    { "EN", 0x0409 },
    { "DE", 0x0407 },
    { "JA", 0x0411 },
    { "KO", 0x0412 },
    { "TW", 0x0404 },
    { "CN", 0x0804 },
    { "FR", 0x040C },
    { "ES", 0x0C0A },
    { "BR", 0x0416 },
    { "IT", 0x0410 },
    { "NL", 0x0413 },
    { "SV", 0x041D },
    { "DA", 0x0406 },
    { "FI", 0x040B },
    { "HU", 0x040E },
    { "NO", 0x0414 },
    { "EL", 0x0408 },
    { "PL", 0x0415 },
    { "RU", 0x0419 },
    { "CS", 0x0405 },
    { "PT", 0x0816 },
    { "TR", 0x041F },
    { "SK", 0x041B },
    { "SL", 0x0424 },
    { "AR", 0x0401 },
    { "HE", 0x040D }
};

// NOTE!  See warnings in subclass.c before futzing with the way we manage
// atoms.  Need to be careful to avoid a Win95 bug.
ATOM g_atmML;
#define c_szML  TEXT("shlwapi.ML")

LANGID GetInstallLanguage(void)
{
    static LANGID LangID = 0;

    if (0 == LangID)
    {
        if (g_bRunningOnNT5OrHigher)
        {
            static LANGID (CALLBACK* pfnGetSystemDefaultUILanguage)(void) = NULL;

            if (pfnGetSystemDefaultUILanguage == NULL)
            {
                HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

                if (hmod)
                    pfnGetSystemDefaultUILanguage = (LANGID (CALLBACK*)(void))GetProcAddress(hmod, "GetSystemDefaultUILanguage");
            }
            if (pfnGetSystemDefaultUILanguage)
                return pfnGetSystemDefaultUILanguage();
        }
        else
        {
            CHAR szISO639[3];
            DWORD cb;

            cb = sizeof(szISO639);
            if (ERROR_SUCCESS == SHGetValueA(HKEY_LOCAL_MACHINE, c_szInstall, c_szLocale, NULL, szISO639, &cb))
            {
                int i;

                for (i = 0; i < ARRAYSIZE(c_ISO639); i++)
                {
                    if (!StrCmpNIA(szISO639, c_ISO639[i].ISO639, ARRAYSIZE(szISO639)))
                    {
                        LangID = c_ISO639[i].LangID;
                        break;
                    }
                }
            }
        }
    }
    return LangID;
}

//
//  MLGetUILanguage(void)
//
LWSTDAPI_(LANGID) MLGetUILanguage(void)
{
    static LANGID LangID = 0;
    CHAR szLangID[8];

    if (0 == LangID)  // no cached LANGID
    {
        if (g_bRunningOnNT5OrHigher)
        {
            static LANGID (CALLBACK* pfnGetUserDefaultUILanguage)(void) = NULL;

            if (pfnGetUserDefaultUILanguage == NULL)
            {
                HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

                if (hmod)
                    pfnGetUserDefaultUILanguage = (LANGID (CALLBACK*)(void))GetProcAddress(hmod, "GetUserDefaultUILanguage");
            }
            if (pfnGetUserDefaultUILanguage)
                return pfnGetUserDefaultUILanguage();
        }
        else
        {
            DWORD   dw;
            
            // try the office 9 lang key (integer value)
            DWORD cb = sizeof(dw);
            if (ERROR_SUCCESS ==
                SHGetValue(HKEY_LOCAL_MACHINE, s_szLangPackPath, s_szVersion, NULL, &dw, &cb)
                && dw > 0) // magic number - christw tells me so
            {
                // Office Language Pack is installed
                cb = sizeof(dw);

                if (ERROR_SUCCESS == SHGetValueA(HKEY_CURRENT_USER, c_szOffice10, c_szOffice10UILanguage, NULL, &dw, &cb))
                {
                    LangID = (LANGID)dw;
                }
                else 
                {
                    cb = sizeof(dw);
                    if (ERROR_SUCCESS == SHGetValueA(HKEY_CURRENT_USER, c_szOffice9, c_szUILanguage, NULL, &dw, &cb))
                    {
                        LangID = (LANGID)dw;
                    }
                }
            }
            // try the IE5 lang key (string rep of hex value)
            if (LangID == 0)
            {
                cb = sizeof(szLangID) - 2;
                if (ERROR_SUCCESS == SHGetValueA(HKEY_CURRENT_USER, c_szInternational, c_szResourceLocale, NULL, szLangID + 2, &cb))
                {
                    // IE uses a string rep of the hex value
                    szLangID[0] = '0';
                    szLangID[1] = 'x';
                    StrToIntEx(szLangID, STIF_SUPPORT_HEX, (LPINT)&LangID);
                }
                else
                    LangID = GetInstallLanguage();
            }
        }
    }
    return LangID;
}

static const TCHAR s_szUrlMon[] = TEXT("urlmon.dll");
static const TCHAR s_szFncFaultInIEFeature[] = TEXT("FaultInIEFeature");
const CLSID CLSID_Satellite =  {0x85e57160,0x2c09,0x11d2,{0xb5,0x46,0x00,0xc0,0x4f,0xc3,0x24,0xa1}};

HRESULT 
_FaultInIEFeature(HWND hwnd, uCLSSPEC *pclsspec, QUERYCONTEXT *pQ, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    typedef HRESULT (WINAPI *PFNJIT)(
        HWND hwnd, 
        uCLSSPEC *pclsspec, 
        QUERYCONTEXT *pQ, 
        DWORD dwFlags);
    PFNJIT  pfnJIT = NULL;
    BOOL fDidLoadLib = FALSE;

    HINSTANCE hUrlMon = GetModuleHandle(s_szUrlMon);
    if (!hUrlMon)
    {
        hUrlMon = LoadLibrary(s_szUrlMon);
        fDidLoadLib = TRUE;
    }
    
    if (hUrlMon)
    {
        pfnJIT = (PFNJIT)GetProcAddress(hUrlMon, s_szFncFaultInIEFeature);
    }
    
    if (pfnJIT)
       hr = pfnJIT(hwnd, pclsspec, pQ, dwFlags);
       
    if (fDidLoadLib && hUrlMon)
        FreeLibrary(hUrlMon);

    return hr;
}

#ifdef LATER_IE5
HRESULT InstallIEFeature(HWND hWnd, LCID lcid, const CLSID *clsid)
{
   
    HRESULT     hr  = REGDB_E_CLASSNOTREG;
    uCLSSPEC    classpec;
    QUERYCONTEXT qc = {0};
        
    classpec.tyspec=TYSPEC_CLSID;
    classpec.tagged_union.clsid=*clsid;
    qc.Locale = lcid;

    hr = _FaultInIEFeature(hWnd, &classpec, &qc, FIEF_FLAG_FORCE_JITUI);

    if (hr != S_OK) {
        hr = REGDB_E_CLASSNOTREG;
    }
    return hr;
}
#endif

HRESULT GetMUIPathOfIEFileW(LPWSTR pszMUIFilePath, int cchMUIFilePath, LPCWSTR pcszFileName, LANGID lidUI)
{
    HRESULT hr = S_OK;
    
    ASSERT(pszMUIFilePath);
    ASSERT(pcszFileName);

    // deal with the case that pcszFileName has full path
    LPWSTR pchT = StrRChrW(pcszFileName, NULL, L'\\');
    if (pchT)
    {
        pcszFileName = pchT;
    }

    static WCHAR s_szMUIPath[MAX_PATH] = { L'\0' };
    static LANGID s_lidLast = 0;

    int cchPath;
    DWORD cb;

    // use cached string if possible
    if ( !s_szMUIPath[0] || s_lidLast != lidUI)
    {
        WCHAR szAppPath[MAXIMUM_VALUE_NAME_LENGTH];

        s_lidLast = lidUI;

        cb = sizeof(szAppPath);
        if (ERROR_SUCCESS == SHGetValueW(HKEY_LOCAL_MACHINE, c_wszAppPaths, NULL, NULL, szAppPath, &cb))
            PathRemoveFileSpecW(szAppPath);
        else
            szAppPath[0] = L'0';

        wnsprintfW(s_szMUIPath, cchMUIFilePath, L"%s\\%s\\%04x\\", szAppPath, c_wszMUI, lidUI );
    }
    StrCpyNW(pszMUIFilePath, s_szMUIPath, cchMUIFilePath);
    cchPath = lstrlenW(pszMUIFilePath);
    cchMUIFilePath -= cchPath;
    StrCpyNW(pszMUIFilePath+cchPath, pcszFileName, cchMUIFilePath);

    return hr;
}

HRESULT GetMUIPathOfIEFileA(LPSTR pszMUIFilePath, int cchMUIFilePath, LPCSTR pcszFileName, LANGID lidUI)
{
    WCHAR szMUIFilePath[MAX_PATH];
    WCHAR szFileName[MAX_PATH];
    HRESULT hr;

    SHAnsiToUnicode(pcszFileName, szFileName, ARRAYSIZE(szFileName));
    hr = GetMUIPathOfIEFileW(szMUIFilePath, cchMUIFilePath, szFileName, lidUI);
    if (SUCCEEDED(hr))
        SHUnicodeToAnsi(szMUIFilePath, pszMUIFilePath, cchMUIFilePath);

    return hr;
}

BOOL fDoMungeLangId(LANGID lidUI)
{
    LANGID lidInstall = GetInstallLanguage();
    BOOL fRet = FALSE;

    if (0x0409 != lidUI && lidUI != lidInstall) // US resource is always no need to munge
    {
        CHAR szUICP[8];
        static UINT uiACP = GetACP();

        GetLocaleInfoA(MAKELCID(lidUI, SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szUICP, ARRAYSIZE(szUICP));

        if (uiACP != (UINT) StrToIntA(szUICP))
            fRet = TRUE;
    }
    return fRet;
}

#define CP_THAI     874
#define CP_ARABIC   1256
#define CP_HEBREW   1255

LANGID GetNormalizedLangId(DWORD dwFlag)
{
    LANGID lidUI = 0;

    dwFlag &= ML_CROSSCODEPAGE_MASK;
    if (ML_SHELL_LANGUAGE == dwFlag)
    {
        if (g_bRunningOnNT5OrHigher)
        {
            static LANGID (CALLBACK* pfnGetUserDefaultUILanguage)(void) = NULL;

            if (pfnGetUserDefaultUILanguage == NULL)
            {
                HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

                if (hmod)
                    pfnGetUserDefaultUILanguage = (LANGID (CALLBACK*)(void))GetProcAddress(hmod, "GetUserDefaultUILanguage");
            }
            if (pfnGetUserDefaultUILanguage)
                lidUI = pfnGetUserDefaultUILanguage();
        }
        else
        {
            CHAR szLangID[12];
            DWORD cb, dwRet;

            cb = sizeof(szLangID) - 2;
            if (g_bRunningOnNT)
                dwRet = SHGetValueA(HKEY_USERS, c_szNT4ResourceLocale, c_szLocale, NULL, szLangID + 2, &cb);
            else
                dwRet = SHGetValueA(HKEY_USERS, c_szWin9xResourceLocale, NULL, NULL, szLangID + 2, &cb);

            if (ERROR_SUCCESS == dwRet)
            {
                // IE uses a string rep of the hex value
                szLangID[0] = '0';
                szLangID[1] = 'x';
                StrToIntEx(szLangID, STIF_SUPPORT_HEX, (LPINT)&lidUI);
            }
        }
    }
    else
    {
        UINT uiACP = GetACP();
        lidUI = MLGetUILanguage();

        // we don't support cross codepage PlugUI on MiddleEast platform
        if (!g_bRunningOnNT5OrHigher && (uiACP == CP_THAI || uiACP == CP_ARABIC || uiACP == CP_HEBREW))
            dwFlag = ML_NO_CROSSCODEPAGE;

        if ((ML_NO_CROSSCODEPAGE == dwFlag) || (!g_bRunningOnNT &&  (ML_CROSSCODEPAGE_NT == dwFlag)))
        {
            if (fDoMungeLangId(lidUI))
                lidUI = 0;
        }
    }
    return (lidUI)? lidUI: GetInstallLanguage();
}

//
//  MLLoadLibrary
//

HDPA g_hdpaPUI = NULL;

typedef struct tagPUIITEM
{
    HINSTANCE hinstRes;
    LANGID lidUI;
    BOOL fMunged;
} PUIITEM, *PPUIITEM;

EXTERN_C BOOL InitPUI(void)
{
    if (NULL == g_hdpaPUI)
    {
        ENTERCRITICAL;
        if (NULL == g_hdpaPUI)
            g_hdpaPUI = DPA_Create(4);
        LEAVECRITICAL;
    }
    return (g_hdpaPUI)? TRUE: FALSE;
}

int GetPUIITEM(HINSTANCE hinst)
{
    int i = 0, cItems = 0;

    ASSERTCRITICAL;

    if (InitPUI())
    {
        cItems = DPA_GetPtrCount(g_hdpaPUI);

        for (i = 0; i < cItems; i++)
        {
            PPUIITEM pItem = (PPUIITEM)DPA_FastGetPtr(g_hdpaPUI, i);

            if (pItem && pItem->hinstRes == hinst)
                break;
        }
    }
    return (i < cItems)? i: -1;
}

EXTERN_C void DeinitPUI(void)
{
    if (g_hdpaPUI)
    {
        ENTERCRITICAL;
        if (g_hdpaPUI)
        {
            int i, cItems = 0;
        
            cItems = DPA_GetPtrCount(g_hdpaPUI);

            // clean up if there is anything left
            for (i = 0; i < cItems; i++)
                LocalFree(DPA_FastGetPtr(g_hdpaPUI, i));

            DPA_DeleteAllPtrs(g_hdpaPUI);
            DPA_Destroy(g_hdpaPUI);
            g_hdpaPUI = NULL;
        }
        LEAVECRITICAL;
    }
}

LWSTDAPI MLSetMLHInstance(HINSTANCE hInst, LANGID lidUI)
{
    int i=-1;
    
    if (hInst)
    {
        PPUIITEM pItem = (PPUIITEM)LocalAlloc(LPTR, sizeof(PUIITEM));

        if (pItem)
        {
            // We might not need to put this if fMunged is FALSE
            pItem->hinstRes = hInst;
            pItem->lidUI = lidUI;
            pItem->fMunged = fDoMungeLangId(lidUI);
            if (InitPUI())
            {
                ENTERCRITICAL;
                i = DPA_AppendPtr(g_hdpaPUI, pItem);
                LEAVECRITICAL;
            }
            if (-1 == i)
                LocalFree(pItem);
        }
    }

    return (-1 == i) ? E_OUTOFMEMORY : S_OK;
}

LWSTDAPI MLClearMLHInstance(HINSTANCE hInst)
{
    int i;

    ENTERCRITICAL;
    i = GetPUIITEM(hInst);
    if (0 <= i)
    {
        LocalFree(DPA_FastGetPtr(g_hdpaPUI, i));
        DPA_DeletePtr(g_hdpaPUI, i);
    }
    LEAVECRITICAL;

    return S_OK;
}

LWSTDAPI
SHGetWebFolderFilePathW(LPCWSTR pszFileName, LPWSTR pszMUIPath, UINT cchMUIPath)
{
    HRESULT hr;
    UINT    cchWinPath;
    LANGID  lidUI;
    LANGID  lidInstall;
    LPWSTR  pszWrite;
    UINT    cchMaxWrite;
    BOOL    fPathChosen;

    RIP(IS_VALID_STRING_PTRW(pszFileName, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszMUIPath, WCHAR, cchMUIPath));

    hr = E_FAIL;
    fPathChosen = FALSE;

    //
    // build the path to the windows\web folder...
    //

    cchWinPath = SHGetSystemWindowsDirectoryW(pszMUIPath, cchMUIPath);
    if (cchWinPath > 0 &&
        pszMUIPath[cchWinPath-1] == L'\\')
    {
        // don't have two L'\\' in a row
        cchWinPath--;
    }

    lidUI = GetNormalizedLangId(ML_CROSSCODEPAGE);
    lidInstall = GetInstallLanguage();

    pszWrite = pszMUIPath+cchWinPath;
    cchMaxWrite = cchMUIPath-cchWinPath;

    if (lidUI != lidInstall)
    {
        //
        // add L"\\Web\\mui\\xxxx\\<filename>"
        // where xxxx is the langid specific folder name
        //

        wnsprintfW(pszWrite, cchMaxWrite, c_wszMuiTemplate, lidUI, pszFileName);

        if (PathFileExistsW(pszMUIPath))
        {
            fPathChosen = TRUE;
        }
    }

    if (!fPathChosen)
    {
        //
        // add L"\\Web\\<filename>"
        //

        wnsprintfW(pszWrite, cchMaxWrite, c_wszWebTemplate, pszFileName);

        if (PathFileExistsW(pszMUIPath))
        {
            fPathChosen = TRUE;
        }
    }

    if (fPathChosen)
    {
        hr = S_OK;
    }

    return hr;
}

LWSTDAPI
SHGetWebFolderFilePathA(LPCSTR pszFileName, LPSTR pszMUIPath, UINT cchMUIPath)
{
    RIP(IS_VALID_STRING_PTRA(pszFileName, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszMUIPath, CHAR, cchMUIPath));

    HRESULT     hr;
    CStrInW     strFN(pszFileName);
    CStrOutW    strMP(pszMUIPath, cchMUIPath);

    hr = SHGetWebFolderFilePathW(strFN, strMP, strMP.BufSize());

    return hr;
}

//  Given a string of form 5.00.2919.6300, this function gets the equivalent dword
//  representation of it.

#define NUM_VERSION_NUM 4
void ConvertVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
    WORD rwVer[NUM_VERSION_NUM];

    for(int i = 0; i < NUM_VERSION_NUM; i++)
        rwVer[i] = 0;

    for(i = 0; i < NUM_VERSION_NUM && pszVer; i++)
    {
        rwVer[i] = (WORD) StrToInt(pszVer);
        pszVer = StrChr(pszVer, TEXT('.'));
        if (pszVer)
            pszVer++;
    }

   *pdwVer = (rwVer[0]<< 16) + rwVer[1];
   *pdwBuild = (rwVer[2] << 16) + rwVer[3];

}

/*
    For SP's we don't update the MUI package. So in order for the golden MUI package to work
    with SP's, we now check if the MUI package is compatible with range of version numbers.
    Since we have different modules calling into this, and they have different version numbers,
    we read the version range from registry for a particular module.

    This Function takes the lower and upper version number of the MUI package. It gets the caller's
    info and reads the version range from registry. If the MUI package version lies in the version
    range specified in the registry, it returns TRUE.
*/


BOOL IsMUICompatible(DWORD dwMUIFileVersionMS, DWORD dwMUIFileVersionLS)
{
    TCHAR szVersionInfo[MAX_PATH];
    DWORD dwType, dwSize;
    TCHAR szProcess[MAX_PATH];

    dwSize = sizeof(szVersionInfo);

    //Get the caller process
    if(!GetModuleFileName(NULL, szProcess, MAX_PATH))
        return FALSE;

    //Get the file name from the path
    LPTSTR lpszFileName = PathFindFileName(szProcess);

    //Query the registry for version info. If the key doesn't exists or there is an 
    //error, return false.
    if(ERROR_SUCCESS != SHRegGetUSValueA(c_szInternational, lpszFileName, 
                        &dwType, (LPVOID)szVersionInfo, &dwSize, TRUE, NULL, 0))
    {
        return FALSE;
    }

    LPTSTR lpszLowerBound = szVersionInfo;

    LPTSTR lpszUpperBound = StrChr(szVersionInfo, TEXT('-'));
    if(!lpszUpperBound || !*(lpszUpperBound+1))
        return FALSE;
    
    *(lpszUpperBound++) = NULL;

    DWORD dwLBMS, dwLBLS, dwUBMS, dwUBLS;

    ConvertVersionStrToDwords(lpszLowerBound, &dwLBMS, &dwLBLS);
    ConvertVersionStrToDwords(lpszUpperBound, &dwUBMS, &dwUBLS);

    //check if MUI version is in the specified range.
    if( (dwMUIFileVersionMS < dwLBMS) ||
        (dwMUIFileVersionMS == dwLBMS && dwMUIFileVersionLS < dwLBLS) ||
        (dwMUIFileVersionMS > dwUBMS) ||
        (dwMUIFileVersionMS == dwUBMS && dwMUIFileVersionLS > dwUBLS) )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL CheckFileVersion(LPWSTR lpFile, LPWSTR lpFileMUI)
{
    DWORD dwSize, dwHandle, dwSizeMUI, dwHandleMUI;
    LPVOID lpVerInfo, lpVerInfoMUI;
    VS_FIXEDFILEINFO *pvsffi, *pvsffiMUI;
    BOOL fRet = FALSE;

    dwSize = GetFileVersionInfoSizeWrapW(lpFile, &dwHandle);
    dwSizeMUI = GetFileVersionInfoSizeWrapW(lpFileMUI, &dwHandleMUI);
    if (dwSize && dwSizeMUI)
    {
        if (lpVerInfo = LocalAlloc(LPTR, dwSize))
        {
            if (lpVerInfoMUI = LocalAlloc(LPTR, dwSizeMUI))
            {
                if (GetFileVersionInfoWrapW(lpFile, dwHandle, dwSize, lpVerInfo) &&
                    GetFileVersionInfoWrapW(lpFileMUI, dwHandleMUI, dwSizeMUI, lpVerInfoMUI))
                {
                    if (VerQueryValueWrapW(lpVerInfo, L"\\", (LPVOID *)&pvsffi, (PUINT)&dwSize) &&
                        VerQueryValueWrapW(lpVerInfoMUI, L"\\", (LPVOID *)&pvsffiMUI, (PUINT)&dwSizeMUI))
                    {
                        if ((pvsffi->dwFileVersionMS == pvsffiMUI->dwFileVersionMS &&
                            pvsffi->dwFileVersionLS == pvsffiMUI->dwFileVersionLS)||
                            IsMUICompatible(pvsffiMUI->dwFileVersionMS, pvsffiMUI->dwFileVersionLS))
                        {
                            fRet = TRUE;
                        }
                    }
                }
                LocalFree(lpVerInfoMUI);
            }
            LocalFree(lpVerInfo);
        }
    }
    return fRet;
}

LWSTDAPI_(HINSTANCE) MLLoadLibraryW(LPCWSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage)
{
    LANGID lidUI;
    WCHAR szPath[MAX_PATH], szMUIPath[MAX_PATH];
    LPCWSTR lpPath = NULL;
    HINSTANCE hInst;
    static BOOL fCheckVersion = SHRegGetBoolUSValueA(c_szInternational, c_szCheckVersion, TRUE, TRUE);;

    if (!lpLibFileName)
        return NULL;

    szPath[0] = szMUIPath[0] = NULL;
    lidUI = GetNormalizedLangId(dwCrossCodePage);

    if (hModule)
    {
        if (GetModuleFileNameWrapW(hModule, szPath, ARRAYSIZE(szPath)))
        {
            PathRemoveFileSpecW(szPath);
            PathAppendW(szPath, lpLibFileName);

            if (GetInstallLanguage() == lidUI)
                lpPath = szPath;
        }
    }

    if (!lpPath)
    {
        GetMUIPathOfIEFileW(szMUIPath, ARRAYSIZE(szMUIPath), lpLibFileName, lidUI);
        lpPath = szMUIPath;
    }

    // Check version between module and resource. If different, use default one.
    if (fCheckVersion && szPath[0] && szMUIPath[0] && !CheckFileVersion(szPath, szMUIPath))
    {
        lidUI = GetInstallLanguage();
        lpPath = szPath;
    }

    ASSERT(lpPath);
    
    // PERF: This should use PathFileExist first then load what exists
    //         failing in LoadLibrary is slow
    hInst = LoadLibraryWrapW(lpPath);

    if (NULL == hInst)
    {
#ifdef LATER_IE5
        HWND  hwnd = GetForegroundWindow();   
        HRESULT hr = InstallIEFeature(hwnd, MAKELCID(lidUI, SORT_DEFAULT), &CLSID_Satellite);
        if (hr == S_OK)
            hInst = LoadLibraryWrapW(lpPath);
#endif
        // All failed. Try to load default one lastly.
        if (!hInst && lpPath != szPath)
        {
            lidUI = GetInstallLanguage();
            hInst = LoadLibraryWrapW(szPath);
        }
    }

    if (NULL == hInst)
        hInst = LoadLibraryWrapW(lpLibFileName);

    // if we load any resource, save info into dpa table
    MLSetMLHInstance(hInst, lidUI);

    return hInst;
}

//
//  Wide-char wrapper for MLLoadLibraryA
//
LWSTDAPI_(HINSTANCE) MLLoadLibraryA(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage)
{
    WCHAR szLibFileName[MAX_PATH];

    SHAnsiToUnicode(lpLibFileName, szLibFileName, ARRAYSIZE(szLibFileName));

    return MLLoadLibraryW(szLibFileName, hModule, dwCrossCodePage);
}

LWSTDAPI_(BOOL) MLFreeLibrary(HMODULE hModule)
{
    MLClearMLHInstance(hModule);
    return FreeLibrary(hModule);
}

LWSTDAPI_(BOOL) MLIsMLHInstance(HINSTANCE hInst)
{
    int i;

    ENTERCRITICAL;
    i = GetPUIITEM(hInst);
    LEAVECRITICAL;

    return (0 <= i);
}


//
//  PlugUI DialogBox APIs
//

#include <pshpack2.h>
// DLGTEMPLATEEX is defined in shell\inc\ccstock.h
// What a DIALOGEX item header would look like
typedef struct
{
    DWORD helpID;
    DWORD dwExtendedStyle;
    DWORD style;
    WORD x;
    WORD y;
    WORD cx;
    WORD cy;
    DWORD id;
} DLGITEMTEMPLATEEX, *LPDLGITEMTEMPLATEEX;

#include <poppack.h> /* Resume normal packing */

// Skips string (or ID) and returns the next aligned WORD.
PBYTE SkipIDorString(LPBYTE pb)
{
    LPWORD pw = (LPWORD)pb;

    if (*pw == 0xFFFF)
        return (LPBYTE)(pw + 2);

    while (*pw++ != 0)
        ;

    return (LPBYTE)pw;
}

PBYTE SkipDialogHeader(LPCDLGTEMPLATE pdt)
{
    LPBYTE pb;
    BOOL fEx = FALSE;
    DWORD dwStyle;

    if (HIWORD(pdt->style) == 0xFFFF)
    {
        DLGTEMPLATEEX *pdtex = (DLGTEMPLATEEX*) pdt;

        fEx = TRUE;
        pb = (LPBYTE)((pdtex) + 1);
        dwStyle = pdtex->dwStyle;
    }
    else
    {
        pb = (LPBYTE)(pdt + 1);
        dwStyle = pdt->style;
    }

    // If there is a menu ordinal, add 4 bytes skip it. Otherwise it is a string or just a 0.
    pb = SkipIDorString(pb);

    // Skip window class and window text, adjust to next word boundary.
    pb = SkipIDorString(pb);    // class
    pb = SkipIDorString(pb);    // window text

    // Skip font type, size and name, adjust to next dword boundary.
    if (dwStyle & DS_SETFONT)
    {
        pb += fEx ? sizeof(DWORD) + sizeof(WORD): sizeof(WORD);
        pb = SkipIDorString(pb);
    }
    pb = (LPBYTE)(((ULONG_PTR)pb + 3) & ~3);    // DWORD align

    return pb;
}

// This gets called by thank produced stubs. It returns the size of a dialog template.
DWORD GetSizeOfDialogTemplate(LPCDLGTEMPLATE pdt)
{
    LPBYTE pb;
    BOOL fEx;
    UINT cItems; 
    DLGTEMPLATEEX *pdtex;

    if (HIWORD(pdt->style) == 0xFFFF)
    {
        pdtex = (DLGTEMPLATEEX *)pdt;
        fEx = TRUE;
        cItems = pdtex->cDlgItems;
    }
    else
    {
        fEx = FALSE;
        cItems = pdt->cdit;
    }

    // skip DLGTEMPLATE(EX) part
    pb = SkipDialogHeader(pdt);

    while (cItems--)
    {
        UINT cbCreateParams;

        pb += fEx ? sizeof(DLGITEMTEMPLATEEX) : sizeof(DLGITEMTEMPLATE);

        // Skip the dialog control class name.
        pb = SkipIDorString(pb);

        // Look at window text now.
        pb = SkipIDorString(pb);

        cbCreateParams = *((LPWORD)pb);

        // skip any CreateParams which include the generated size WORD.
        if (cbCreateParams)
            pb += cbCreateParams;

        pb += sizeof(WORD);

        // Point at the next dialog item. (DWORD aligned)
        pb = (LPBYTE)(((ULONG_PTR)pb + 3) & ~3);
    }
    // Return template size.
    return (DWORD)(pb - (LPBYTE)pdt);
}

void CopyIDorString(LPBYTE *ppbDest, LPBYTE *ppbSrc)
{
    if (*(LPWORD)(*ppbSrc) == 0xFFFF)
    {
        memcpy(*ppbDest, *ppbSrc, 4);
        *ppbSrc += 4;
        *ppbDest += 4;
        return;
    }

    while (*(LPWORD)(*ppbSrc) != 0)
    {
        memcpy(*ppbDest, *ppbSrc, 2);
        *ppbSrc += 2;
        *ppbDest += 2;
    }

    // copy 0
    memcpy(*ppbDest, *ppbSrc, 2);
    *ppbSrc += 2;
    *ppbDest += 2;

    return;
}

void StripIDorString(LPBYTE *ppbDest, LPBYTE *ppbSrc)
{
    *ppbSrc = SkipIDorString(*ppbSrc);
    *(LPWORD)(*ppbDest) = 0;
    *ppbDest += 2;

    return;
}

BOOL CheckID(LPBYTE pb, UINT c, BOOL fEx, int id, int max)
{
    int n = 0;

    if (0 > id)
        return FALSE;

    while (c--)
    {
        UINT cbCreateParams;
        LPDLGITEMTEMPLATE lpdit;
        LPDLGITEMTEMPLATEEX lpditex;
        int i;

        if (fEx)
        {
            lpditex = (LPDLGITEMTEMPLATEEX)pb;
            i = lpditex->id;
            pb += sizeof(DLGITEMTEMPLATEEX);
        }
        else
        {
            lpdit = (LPDLGITEMTEMPLATE)pb;
            i = lpdit->id;
            pb += sizeof(DLGITEMTEMPLATE);
        }

        if (i == id)
        {
            n++;
            if (n > max)
                return FALSE;
        }

        // Skip the dialog control class name.
        pb = SkipIDorString(pb);

        // Look at window text now.
        pb = SkipIDorString(pb);

        cbCreateParams = *((LPWORD)pb);

        // skip any CreateParams which include the generated size WORD.
        if (cbCreateParams)
            pb += cbCreateParams;

        pb += sizeof(WORD);

        // Point at the next dialog item. (DWORD aligned)
        pb = (LPBYTE)(((ULONG_PTR)pb + 3) & ~3);
    }

    return TRUE;
}

int GetUniqueID(LPBYTE pbSrc, UINT cSrc, LPBYTE pbDest, UINT cDest, BOOL fEx)
{
    // PERF: Need to be improved !!!
    while (1)
    {
        int id;

        for (id = 100; id < 0x7FFF; id++)
        {
            if (CheckID(pbSrc, cSrc, fEx, id, 0))
                if (CheckID(pbDest, cDest, fEx, id, 0))
                    return id;
        }
}   }


#define MAX_REG_WINMSG      0xFFFF      // max value returned from RegisterWindowMessageA()
#define MIN_REG_WINMSG      0xC000      // min value returned from RegisterWindowMessageA()

LRESULT StaticSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
LRESULT ButtonSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
LRESULT ListBoxSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
LRESULT ComboBoxSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

#define ML_SSC_MASK     0x0000001F      // Static control style bit check mask
#define ML_BSC_MASK     0x0000000F      // Button control style bit check mask
    
BOOL StaticStyleCheck(DWORD dwStyle);
BOOL ButtonStyleCheck(DWORD dwStyle);
BOOL ListBoxStyleCheck(DWORD dwStyle);
BOOL ComboBoxStyleCheck(DWORD dwStyle);


typedef BOOL (* STYLECHECKPROC)(DWORD);

typedef struct tagControl
{
    WORD wControl;
    LPCSTR szControl;
    SUBCLASSPROC SubclassProc;
    STYLECHECKPROC StyleCheckProc;
} CONTROL, *LPCONTROL;

const CONTROL c_CtrlTbl[] =
{
    { 0x0082L, "STATIC", StaticSubclassProc, StaticStyleCheck },
    { 0x0080L, "BUTTON", ButtonSubclassProc, ButtonStyleCheck },
    { 0x0083L, "LISTBOX", ListBoxSubclassProc, ListBoxStyleCheck },
    { 0x0085L, "COMBOBOX", ComboBoxSubclassProc, ComboBoxStyleCheck },
};

// registered window messages global variables, initial value is 0.
UINT g_ML_GETTEXT               = 0,
     g_ML_GETTEXTLENGTH         = 0,
     g_ML_SETTEXT               = 0;

UINT g_ML_LB_ADDSTRING          = 0,
     g_ML_LB_FINDSTRING         = 0,
     g_ML_LB_FINDSTRINGEXACT    = 0,
     g_ML_LB_GETTEXT            = 0,
     g_ML_LB_GETTEXTLEN         = 0,
     g_ML_LB_INSERTSTRING       = 0,
     g_ML_LB_SELECTSTRING       = 0;

UINT g_ML_CB_ADDSTRING          = 0,
     g_ML_CB_FINDSTRING         = 0,
     g_ML_CB_FINDSTRINGEXACT    = 0,
     g_ML_CB_GETLBTEXT          = 0,
     g_ML_CB_GETLBTEXTLEN       = 0,
     g_ML_CB_INSERTSTRING       = 0,
     g_ML_CB_SELECTSTRING       = 0;


int DoMungeControl(LPBYTE pb, DWORD dwStyle)
{
    int i = ARRAYSIZE(c_CtrlTbl);

    ASSERT(!g_bRunningOnNT5OrHigher);

    if (*(LPWORD)pb == 0xFFFF)
    {
        for (i = 0; i < ARRAYSIZE(c_CtrlTbl); i++)
        {
            if (*(LPWSTR)(pb + 2) == c_CtrlTbl[i].wControl)
                return (c_CtrlTbl[i].StyleCheckProc(dwStyle)) ? i : ARRAYSIZE(c_CtrlTbl);
        }
    }
    return i;
}

typedef struct tagCItem
{
    DWORD   dwStyle;
    RECT    rc;
    LPWSTR  lpwz;
    int     nBuf;
} CITEM, *LPCITEM;

void PutSpaceString(HWND hwnd, LPCITEM lpCItem)
{
    HDC hdc;
    HFONT hfont;
    int nSpace;
    SIZE sizSpace, sizString;

    hdc = GetDC(hwnd);
    hfont = (HFONT)SelectObject(hdc, GetWindowFont(hwnd));
    if (GetTextExtentPointFLW(hdc, L" ", 1, &sizSpace))
    {
        if (GetTextExtentPointFLW(hdc, lpCItem->lpwz, lstrlenW(lpCItem->lpwz), &sizString))
        {
            nSpace = (sizString.cx + sizSpace.cx - 1) / sizSpace.cx;
            // Build space string and pass it to original WndProc
            if (IsWindowUnicode(hwnd))
            {
                LPWSTR lpSpaceW;

                lpSpaceW = (LPWSTR)LocalAlloc(LPTR, (nSpace + 1) * sizeof(WCHAR));
                if (lpSpaceW)
                {
                    int i;

                    for (i = 0; i < nSpace; i++)
                        lpSpaceW[i] = L' ';
                    lpSpaceW[nSpace] = 0;
                    DefSubclassProc(hwnd, WM_SETTEXT, 0, (LPARAM)lpSpaceW);
                    LocalFree(lpSpaceW);
                }
            }
            else
            {
                LPSTR lpSpace;

                lpSpace = (LPSTR)LocalAlloc(LPTR, (nSpace + 1) * sizeof(CHAR));
                if (lpSpace)
                {
                    int i;

                    for (i = 0; i < nSpace; i++)
                        lpSpace[i] = ' ';
                    lpSpace[nSpace] = 0;
                    DefSubclassProc(hwnd, WM_SETTEXT, 0, (LPARAM)lpSpace);
                    LocalFree(lpSpace);
                }
            }
        }
    }
    if (hfont)
        SelectObject(hdc, hfont);
    ReleaseDC(hwnd, hdc);
}

LRESULT ControlSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    LPCITEM lpCItem = (LPCITEM)dwRefData;

    ASSERT(g_ML_GETTEXT);
    ASSERT(g_ML_SETTEXT);

    switch (uMsg)
    {
        case WM_GETTEXT:
        {
            if (lpCItem->lpwz && lParam)
            {
                if (IsWindowUnicode(hwnd))
                {
                    StrCpyNW((LPWSTR)lParam, lpCItem->lpwz, (int)wParam);
                    return min((int)wParam, lstrlenW(lpCItem->lpwz));
                }
                else
                {
                    return WideCharToMultiByte(CP_ACP, 0, lpCItem->lpwz, -1, (LPSTR)lParam, (int)wParam, NULL, NULL);
                }
            }

            return 0;
        }

        case WM_GETTEXTLENGTH:
        {
            if (IsWindowUnicode(hwnd))
            {
                if (lpCItem->lpwz)
                    return lstrlenW(lpCItem->lpwz);
                else
                    return 0;
            }
            else
            {
                return WideCharToMultiByte(CP_ACP, 0, lpCItem->lpwz, -1, NULL, 0, NULL, NULL);
            }
        }

        case WM_SETTEXT:
        {
            if (lParam)
            {
                if (IsWindowUnicode(hwnd))
                    return SendMessage(hwnd, g_ML_SETTEXT, 0, lParam);
                else
                {
                    int nStr = lstrlenA((LPSTR)lParam);

                    LPWSTR lpTmp = (LPWSTR)LocalAlloc(LPTR, (nStr + 1) * sizeof(WCHAR));

                    if (lpTmp)
                    {
                        MultiByteToWideChar(CP_ACP, 0, (LPSTR)lParam, -1, lpTmp, nStr + 1);
                        SendMessage(hwnd, g_ML_SETTEXT, 0, (LPARAM)lpTmp);
                        LocalFree(lpTmp);
                        return TRUE;
                    }
                }
            }
            return FALSE;
        }

        default:
        {
            // ML_GETTEXT:
            if (uMsg == g_ML_GETTEXT)
            {
                if (lpCItem->lpwz && lParam)
                {
                    StrCpyNW((LPWSTR)lParam, lpCItem->lpwz, (int)wParam);
                    return min((int)wParam, lstrlenW(lpCItem->lpwz));
                }

                return 0;
            }

            // ML_GETTEXTLENGTH:
            if (uMsg == g_ML_GETTEXTLENGTH)
            {
                if (lpCItem->lpwz)
                    return lstrlenW(lpCItem->lpwz);
                else
                    return 0;
            }

            // ML_SETTEXT:
            if (uMsg == g_ML_SETTEXT)
            {
                if (lParam)
                {
                    int nStr = lstrlenW((LPWSTR)lParam);

                    if (nStr >= lpCItem->nBuf)
                    {
                        LPWSTR lpTmp = (LPWSTR)LocalAlloc(LPTR, (nStr + 1) * sizeof(WCHAR));

                        if (lpTmp)
                        {
                            if (lpCItem->lpwz)
                                LocalFree(lpCItem->lpwz);
                            lpCItem->lpwz = lpTmp;
                            lpCItem->nBuf = nStr + 1;
                        }
                    }
                    if (lpCItem->lpwz)
                    {
                        InvalidateRect(hwnd, NULL, TRUE);
                        StrCpyNW(lpCItem->lpwz, (LPWSTR)lParam, lpCItem->nBuf);
                        PutSpaceString(hwnd, lpCItem);
                        return TRUE;
                    }
                }

                return FALSE;
            }

        }

    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

void DrawControlString(HDC hdc, LPRECT lprc, LPCITEM lpCItem, UINT uFormat, BOOL fDisabled)
{
    int iTxt, iBk;

    iBk = SetBkMode(hdc, TRANSPARENT);
    if (fDisabled)
    {
        RECT rcOffset = *lprc;

        iTxt = SetTextColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
        OffsetRect(&rcOffset, 1, 1);
        DrawTextFLW(hdc, lpCItem->lpwz, lstrlenW(lpCItem->lpwz), &rcOffset, uFormat);
        SetTextColor(hdc, GetSysColor(COLOR_BTNSHADOW));
    }
    else
    {
        iTxt = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    }
    DrawTextFLW(hdc, lpCItem->lpwz, lstrlenW(lpCItem->lpwz), lprc, uFormat);
    SetTextColor(hdc, iTxt);
    SetBkMode(hdc, iBk);
}

void AdjustTextPosition(HDC hdc, BYTE bStyle, BYTE bState, UINT uFormat, LPRECT lprc)
{
    static int s_cxEdge = GetSystemMetrics(SM_CXEDGE);
    static int s_cxFrame = GetSystemMetrics(SM_CXFRAME);
    static int s_cxBorder = GetSystemMetrics(SM_CXBORDER);
    static int s_cyBorder = GetSystemMetrics(SM_CYBORDER);
    static int s_cxMenuCheck = GetSystemMetrics(SM_CXMENUCHECK);

    switch (bStyle)
    {
        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
            if (!(bState & BST_PUSHED))
            {
                lprc->top -= s_cyBorder;
                lprc->bottom -= s_cyBorder;
            }
            break;

        case BS_CHECKBOX:
        case BS_AUTOCHECKBOX:
        case BS_RADIOBUTTON:
        case BS_AUTORADIOBUTTON:
        case BS_3STATE:
        case BS_AUTO3STATE:
            lprc->left += s_cxMenuCheck + s_cxFrame + s_cxBorder + s_cxEdge;
            break;

        case BS_GROUPBOX:
            lprc->left += s_cxMenuCheck / 2 + s_cxBorder + s_cxEdge;
            break;
    }

    if (uFormat & DT_VCENTER)
    {
        SIZE size;
        LONG cyGap;

        if (GetTextExtentPointFLW(hdc, L" ", 1, &size))
        {
            cyGap = (lprc->bottom - lprc->top - size.cy + 1) / 2;
            lprc->top += cyGap;
            lprc->bottom += cyGap;
        }
    }
    else
    {
        lprc->top += s_cyBorder;
        lprc->bottom += s_cyBorder;
    }
}

BOOL ButtonStyleCheck(DWORD dwStyle)
{
    switch (dwStyle & ML_BSC_MASK)
    {
        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
        case BS_CHECKBOX:
        case BS_AUTOCHECKBOX:
        case BS_RADIOBUTTON:
        case BS_AUTORADIOBUTTON:
        case BS_3STATE:
        case BS_AUTO3STATE:
        case BS_GROUPBOX:
        case BS_OWNERDRAW:
        {
            static BOOL fRegMsgOK = FALSE;

            if (FALSE == fRegMsgOK)
            {
                if (g_ML_GETTEXT && g_ML_SETTEXT)
                {
                    // messages been registered
                    fRegMsgOK = TRUE;
                }
                else
                {
                    // register window messages
                    fRegMsgOK = (BOOL)(g_ML_GETTEXT = RegisterWindowMessageA("ML_GETTEXT")) &&
                                (BOOL)(g_ML_SETTEXT = RegisterWindowMessageA("ML_SETTEXT"));
                }
            }

            return fRegMsgOK;
        }
    }

    return FALSE;
}

LRESULT ButtonSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    LPCITEM lpCItem = (LPCITEM)dwRefData;
    BYTE bStyle = (BYTE)(lpCItem->dwStyle & ML_BSC_MASK);

    switch (uMsg)
    {
        case WM_DESTROY:
        {
            if (hwnd)
            {
                // Must remove by atom - Win95 compat
                RemoveProp(hwnd, MAKEINTATOM(g_atmML));
                RemoveWindowSubclass(hwnd, ButtonSubclassProc,  0);
            }
            if (lpCItem->lpwz)
            {
                LocalFree(lpCItem->lpwz);
                lpCItem->lpwz = NULL;
                lpCItem->nBuf = 0;
            }
            LocalFree(lpCItem);
            break;
        }

        case WM_GETTEXT:
        case WM_SETTEXT:
            return ControlSubclassProc(hwnd, uMsg, wParam, lParam, uIdSubclass, dwRefData);

        case BM_SETSTATE:
        {
            if (bStyle != BS_PUSHBUTTON && bStyle != BS_DEFPUSHBUTTON)
                break;

            // fall thru ...
        }

        case WM_ENABLE:
        case WM_PAINT:
        {
            UINT uFormat;
            BOOL fDoPaint = TRUE;

            switch (bStyle)
            {
                case BS_PUSHBUTTON:
                case BS_DEFPUSHBUTTON:
                    uFormat = DT_CENTER | DT_VCENTER;
                    break;

                case BS_CHECKBOX:
                case BS_AUTOCHECKBOX:
                case BS_RADIOBUTTON:
                case BS_AUTORADIOBUTTON:
                case BS_3STATE:
                case BS_AUTO3STATE:
                case BS_GROUPBOX:
                    uFormat = DT_LEFT | DT_WORDBREAK;
                    break;

                default:
                    fDoPaint = FALSE;
            }

            if (fDoPaint && lpCItem->lpwz)
            {
                HDC hdc;
                HFONT hfont;
                RECT rc;
                BYTE bState;

                DefSubclassProc(hwnd, uMsg, wParam, lParam);

                bState = (BYTE)SendMessage(hwnd, BM_GETSTATE, 0, 0L);

                hdc = GetDC(hwnd);
                hfont = (HFONT)SelectObject(hdc, GetWindowFont(hwnd));
                CopyRect(&rc, &lpCItem->rc);
                AdjustTextPosition(hdc, bStyle, bState, uFormat, &rc);
                DrawControlString(hdc, &rc, lpCItem, uFormat, GetWindowLong(hwnd, GWL_STYLE) & WS_DISABLED);
                if (hfont)
                    SelectObject(hdc, hfont);
                ReleaseDC(hwnd, hdc);
                return FALSE;
            }
            break;
        }

        default:
        {
            // non-registered window message
            if ((uMsg < MIN_REG_WINMSG) || (uMsg > MAX_REG_WINMSG))
                break;   // fall through default process

            // ML_GETTEXT:
            // ML_SETTEXT:
            if ((uMsg == g_ML_GETTEXT) || (uMsg == g_ML_SETTEXT))
                return ControlSubclassProc(hwnd, uMsg, wParam, lParam, uIdSubclass, dwRefData);

        }   // switch-default

    }   // switch

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}


BOOL StaticStyleCheck(DWORD dwStyle)
{
    switch (dwStyle & ML_SSC_MASK)
    {
        case SS_LEFT:
        case SS_CENTER:
        case SS_RIGHT:
        case SS_SIMPLE:
        case SS_LEFTNOWORDWRAP:
        case SS_OWNERDRAW:
        {
            static BOOL fRegMsgOK = FALSE;

            if (FALSE == fRegMsgOK)
            {
                if (g_ML_GETTEXT && g_ML_SETTEXT)
                {
                    // messages been registered
                    fRegMsgOK = TRUE;
                }
                else
                {
                    // register window messages
                    fRegMsgOK = (BOOL)(g_ML_GETTEXT = RegisterWindowMessageA("ML_GETTEXT")) &&
                                (BOOL)(g_ML_SETTEXT = RegisterWindowMessageA("ML_SETTEXT"));
                }
            }

            return fRegMsgOK;
        }
    }

    return FALSE;
}

LRESULT StaticSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    LPCITEM lpCItem = (LPCITEM)dwRefData;

    switch (uMsg)
    {
        case WM_DESTROY:
        {
            if (hwnd)
            {
                // Must remove by atom - Win95 compat
                RemoveProp(hwnd, MAKEINTATOM(g_atmML));
                RemoveWindowSubclass(hwnd, StaticSubclassProc,  0);
            }
            if (lpCItem->lpwz)
            {
                LocalFree(lpCItem->lpwz);
                lpCItem->lpwz = NULL;
                lpCItem->nBuf = 0;
            }
            LocalFree(lpCItem);
            break;
        }

        case WM_GETTEXT:
        case WM_SETTEXT:
            return ControlSubclassProc(hwnd, uMsg, wParam, lParam, uIdSubclass, dwRefData);

        case WM_PAINT:
        {
            UINT uFormat;
            BOOL fDoPaint = TRUE;

            switch (lpCItem->dwStyle & ML_SSC_MASK)
            {
                case SS_LEFT:
                    uFormat = DT_LEFT | DT_WORDBREAK;
                    break;

                case SS_CENTER:
                    uFormat = DT_CENTER | DT_WORDBREAK;
                    break;

                case SS_RIGHT:
                    uFormat = DT_RIGHT | DT_WORDBREAK;
                    break;

                case SS_SIMPLE:
                case SS_LEFTNOWORDWRAP:
                    uFormat = DT_LEFT;
                    break;

                default:
                    fDoPaint = FALSE;
            }

            if (fDoPaint && lpCItem->lpwz)
            {
                HDC hdc;
                PAINTSTRUCT ps;
                HFONT hfont;

                hdc = BeginPaint(hwnd, &ps);
                hfont = (HFONT)SelectObject(hdc, GetWindowFont(hwnd));
                DrawControlString(hdc, &lpCItem->rc, lpCItem, uFormat, GetWindowLong(hwnd, GWL_STYLE) & WS_DISABLED);
                if (hfont)
                    SelectObject(hdc, hfont);
                EndPaint(hwnd, &ps);
            }
            break;
        }

        default:
        {
            // non-registered window message
            if ((uMsg < MIN_REG_WINMSG) || (uMsg > MAX_REG_WINMSG))
                break;   // fall through default process

            // ML_GETTEXT:
            // ML_SETTEXT:
            if ((uMsg == g_ML_GETTEXT) || (uMsg == g_ML_SETTEXT))
                return ControlSubclassProc(hwnd, uMsg, wParam, lParam, uIdSubclass, dwRefData);

        }   // switch-default

    }   // switch

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}


//--------------------------------------------------------------------------
// Subclass of ListBox, ComboBox controls
//--------------------------------------------------------------------------
//
// To enable the subclassed control with capability to process unicode
// string as well as font linking.
//
// Implementation:
//      these subclassing procedures will allocate memory to store the
//      unicode string and then convert unicode string pointer into
//      "pointer string," like:
//          0x004b5c30 --> "4b5c30"
//      and then store this pointer string as regular string (unicode or
//      ANSI, depends on the window system) into the control.
//
//--------------------------------------------------------------------------
#define MAX_BUFFER_BYTE         1024            // bytes
#define MAX_WINCLASS_NAME       32              // bytes

#define LB_WINCLASS_NAME        "ListBox"       // window class name of ListBox control
#define CB_WINCLASS_NAME        "ComboBox"      // window class name of ComboBox control
#define CB_SUBWINCLASS_LB_NAME  "ComboLBox"     // window class name of ListBox control inside ComboBox
#define CB_SUBWINCLASS_ED_NAME  "Edit"          // window class name of Edit control

#define ML_CB_SUBWIN            TEXT("Shlwapi.ML.CB.SubWinHnd")
#define ML_LB_NTBUG             TEXT("Shlwapi.ML.LB.NTBug")

#define LB_SUB_PROC             ListBoxSubclassProc

#define VK_A                    0x41        // virtual keyboard value, 'A', cAsE iNsEnSiTiVe
#define VK_Z                    0x5A        // virtual keyboard value, 'Z', cAsE iNsEnSiTiVe
#define VK_0                    0x30        // virtual keyboard value, '0'
#define VK_9                    0x39        // virtual keyboard value, '9'

typedef struct
{
    HWND hwndLBSubWin;
} MLCBSUBWINHND, *LPMLCBSUBWINHND;


//--- LB & CB common routines ---
LRESULT MLLBCBDefSubClassProcWrap(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (!IsWindowUnicode(hWnd))
    {
        if ((uMsg == LB_GETTEXT) || (uMsg == CB_GETLBTEXT))
        {
            // buffer size 256 is big enough for this
            CStrOut cStr((LPWSTR)lParam, 256);

            return DefSubclassProc(hWnd, uMsg, wParam, (LPARAM)((LPSTR)cStr));
        }

        if ((uMsg == LB_INSERTSTRING) || (uMsg == CB_INSERTSTRING))
        {
            CStrIn cStr((LPWSTR)lParam);

            return DefSubclassProc(hWnd, uMsg, wParam, (LPARAM)((LPSTR)cStr));
        }
    }
    
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}


BOOL MLLBCBGetWStrPtr(HWND hWnd, INT_PTR iIndex, LPWSTR* lppwszStr)
{
    WCHAR szWPtr[sizeof(LPVOID) * 2 + 2 + 1] = {0};
    CHAR szWinClass[MAX_WINCLASS_NAME];
    BOOL fContinue = FALSE;

    // initial the destination pointer to NULL...
    (*lppwszStr) = NULL;

    GetClassNameA(hWnd, szWinClass, ARRAYSIZE(szWinClass));
    if (((0 == lstrcmpiA(szWinClass, LB_WINCLASS_NAME)) || (0 == lstrcmpiA(szWinClass, CB_SUBWINCLASS_LB_NAME))) &&
        (LB_ERR != MLLBCBDefSubClassProcWrap(hWnd, LB_GETTEXT, (WPARAM)iIndex, (LPARAM)(szWPtr + 2))))
            fContinue = TRUE;

    if ((!fContinue) && (0 == lstrcmpiA(szWinClass, CB_WINCLASS_NAME)) &&
        (CB_ERR != MLLBCBDefSubClassProcWrap(hWnd, CB_GETLBTEXT, (WPARAM)iIndex, (LPARAM)(szWPtr + 2))))
            fContinue = TRUE;

    if (!fContinue)
        return FALSE;   // Invalid WinClass name or fail to get the item.

    if (lstrlenW(szWPtr + 2))
    {
        szWPtr[0] = L'0';
        szWPtr[1] = L'x';
        StrToIntExW(szWPtr, STIF_SUPPORT_HEX, (LPINT)lppwszStr);
        ASSERT(*lppwszStr);   // to warn some conversion failure case (not ALL).
    }
    else
        return FALSE;   // for caution: impossible case of zero length

    return TRUE;
}


BOOL MLLBCBDoDeleteItem(HWND hWnd, INT_PTR iIndex)
{
    LPWSTR lpwszStr;

    // get the string pointer...
    if (!MLLBCBGetWStrPtr(hWnd, iIndex, &lpwszStr))
        return FALSE;

    // free the unicode string allocated by subclassing routine.
    // the "pointer string" stored inside LB/CB will be deleted/freed
    // in the subsequence default process call in the calling routine.
    if (lpwszStr)
        LocalFree(lpwszStr);
    else
        return FALSE;   // for caution: NULL pointer

    return TRUE;
}


INT_PTR MLLBCBAddInsertString(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam, INT_PTR iCnt, DWORD dwStyle, BOOL fIsLB)
{
    INT_PTR iIndex;
    LPWSTR lpwszInStr = NULL;
    WCHAR szWPtr[sizeof(LPVOID) * 2 + 1] = {0};

    ASSERT(uiMsg);

    if (!lParam)
        return (fIsLB ? LB_ERR : CB_ERR);

    // initial wide string pointer holder and copy input string...
    lpwszInStr = (LPWSTR)LocalAlloc(LPTR, ((lstrlenW((LPCWSTR)lParam) + 1) * sizeof(WCHAR)));
    if (!lpwszInStr)
        return (fIsLB ? LB_ERRSPACE : CB_ERRSPACE);
    else
        StrCpyW(lpwszInStr, (LPCWSTR)lParam);

    // convert unicode string pointer into "pointer string"...
    wnsprintfW(szWPtr, ARRAYSIZE(szWPtr), L"%lx", lpwszInStr);

    if (uiMsg == (fIsLB ? g_ML_LB_INSERTSTRING : g_ML_CB_INSERTSTRING))
        iIndex = (INT_PTR)wParam;
    else
    {
        // find the proper place to add
        if ((iCnt == 0) || (!(dwStyle & (fIsLB ? LBS_SORT : CBS_SORT))))
            iIndex = iCnt;
        else
        {
            int iLP;

            for (iLP = 0; iLP < iCnt; iLP++)
            {
                LPWSTR lpwszStrTmp;

                // get the string pointer...
                if (!MLLBCBGetWStrPtr(hWnd, iLP, &lpwszStrTmp))
                    return (fIsLB ? LB_ERR : CB_ERR);

                if (lpwszStrTmp)
                {
                    if (StrCmpW(lpwszInStr, lpwszStrTmp) <= 0)
                        break;
                }
                else
                    return (fIsLB ? LB_ERR : CB_ERR);
            }

            iIndex = iLP;
        }
    }

    // do adding...
    return (INT_PTR)MLLBCBDefSubClassProcWrap(hWnd, (fIsLB ? LB_INSERTSTRING : CB_INSERTSTRING),
                                            (WPARAM)iIndex, (LPARAM)szWPtr);
}


int MLLBCBGetLBTextNLength(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam, INT_PTR iCnt, BOOL fIsLB)
{
    LPWSTR lpwszStr;
    INT_PTR iIndex = (INT_PTR)wParam;

    ASSERT(uiMsg);

    // get the string pointer...
    if ((iIndex >= iCnt) || (!MLLBCBGetWStrPtr(hWnd, iIndex, &lpwszStr)))
        return (fIsLB ? LB_ERR : CB_ERR);

    if (lpwszStr)
    {
        if (uiMsg == (fIsLB ? g_ML_LB_GETTEXT : g_ML_CB_GETLBTEXT))
        {
            if (lParam)
                StrCpyW((LPWSTR)lParam, lpwszStr);
            else
                return (fIsLB ? LB_ERR : CB_ERR);   // for caution: return string buffer is NULL
        }

        return lstrlenW(lpwszStr);
    }
    else
        return (fIsLB ? LB_ERR : CB_ERR);   // for caution: NULL pointer
}


INT_PTR MLLBCBFindStringNExact(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam, INT_PTR iCnt, BOOL fIsLB)
{
    INT_PTR iStartIdx = (INT_PTR)wParam;

    ASSERT(uiMsg);

    if (iStartIdx >= iCnt)
        return (fIsLB ? LB_ERR : CB_ERR);

    if (iStartIdx == -1)
        iStartIdx = 0;

    if (lParam)
    {
        for (int iLP = 0; iLP < iCnt; iLP++)
        {
            LPWSTR lpwszStr;
            INT_PTR iIndex = (iStartIdx + iLP) % iCnt;

            // get the string pointer...
            if (!MLLBCBGetWStrPtr(hWnd, iIndex, &lpwszStr))
                return (fIsLB ? LB_ERR : CB_ERR);

            if (lpwszStr)
            {
                if (uiMsg == (fIsLB ? g_ML_LB_FINDSTRING : g_ML_CB_FINDSTRING))
                {
                    if (lpwszStr == StrStrIW(lpwszStr, (LPCWSTR)lParam))
                        return iIndex;
                }
                else
                {
                    if (0 == StrCmpIW(lpwszStr, (LPCWSTR)lParam))
                        return iIndex;
                }
            }
        }

        return (fIsLB ? LB_ERR : CB_ERR);   // can not find the subject
    }
    else
        return (fIsLB ? LB_ERR : CB_ERR);   // for caution
}
//--- LB & CB common routines ---

//--- ListBox -------------------------------------------------
BOOL ListBoxStyleCheck(DWORD dwStyle)
{
    // HasStrings   0   0   1   1
    // OwnerDraw    0   1   0   1
    // SubClassing  Y   N   Y   Y
    //              ^
    //              LBS_HASSTRINGS is a default setting if not OwnerDraw.
    if ((!(dwStyle & LBS_HASSTRINGS)) &&
        (dwStyle & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)))
        return FALSE;

    static BOOL fRegMsgOK = FALSE;

    if (FALSE == fRegMsgOK)
    {
        // register window message(s)
        fRegMsgOK = (BOOL)(g_ML_LB_ADDSTRING        = RegisterWindowMessageA("ML_LB_ADDSTRING"))       &&
                    (BOOL)(g_ML_LB_FINDSTRING       = RegisterWindowMessageA("ML_LB_FINDSTRING"))      &&
                    (BOOL)(g_ML_LB_FINDSTRINGEXACT  = RegisterWindowMessageA("ML_LB_FINDSTRINGEXACT")) &&
                    (BOOL)(g_ML_LB_GETTEXT          = RegisterWindowMessageA("ML_LB_GETTEXT"))         &&
                    (BOOL)(g_ML_LB_GETTEXTLEN       = RegisterWindowMessageA("ML_LB_GETTEXTLEN"))      &&
                    (BOOL)(g_ML_LB_INSERTSTRING     = RegisterWindowMessageA("ML_LB_INSERTSTRING"))    &&
                    (BOOL)(g_ML_LB_SELECTSTRING     = RegisterWindowMessageA("ML_LB_SELECTSTRING"));
    }

    return fRegMsgOK;
}


BOOL MLIsLBFromCB(HWND hWnd)
{
    // decide if this is sub win, LB inside CB.
    CHAR szWinClass[MAX_WINCLASS_NAME];

    GetClassNameA(hWnd, szWinClass, ARRAYSIZE(szWinClass));

    return (BOOL)(0 == lstrcmpiA(szWinClass, CB_SUBWINCLASS_LB_NAME));
}


LRESULT ListBoxSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
    BOOL fOwnerDraw = (BOOL)(dwStyle & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE));

    ASSERT(uMsg);   // if happened, most possible cause is non-registered message

    // get the item count...
    INT_PTR iLBCnt = DefSubclassProc(hwnd, LB_GETCOUNT, (WPARAM)0L, (LPARAM)0L);

    switch (uMsg)
    {
        case WM_DESTROY:
        {
            if (hwnd)
            {
                // delete any "item" if remained and this LB is not from CB
                if (!MLIsLBFromCB(hwnd))
                    SendMessage(hwnd, LB_RESETCONTENT, wParam, lParam);

                RemoveProp(hwnd, ML_LB_NTBUG);
                // Must remove by atom - Win95 compat
                RemoveProp(hwnd, MAKEINTATOM(g_atmML));
                RemoveWindowSubclass(hwnd, ListBoxSubclassProc,  0);
            }

            LocalFree(((LPCITEM)dwRefData));

            break;   // fall through default process
        }

        case LB_DELETESTRING:
        {
            INT_PTR iIndex = (INT_PTR)wParam;
            
            if ((iIndex >= iLBCnt) || MLIsLBFromCB(hwnd))
                break;   // fall through default process

            if (MLLBCBDoDeleteItem(hwnd, iIndex))
            {
                // for taking care NT bug: not adjusting item count before send LB_RESETCONTENT message
                if (g_bRunningOnNT && (iLBCnt == 1))
                    SetProp(hwnd, ML_LB_NTBUG, (HANDLE)(1L));

                break;   // fall through default process
            }
            else
                return LB_ERR;
        }

        case LB_RESETCONTENT:
        {
            if ((iLBCnt > 0) && (!MLIsLBFromCB(hwnd)))
            {
                // for taking care NT bug: not adjusting item count before send LB_RESETCONTENT message
                if (g_bRunningOnNT && (iLBCnt == 1) && ((HANDLE)(1L) == GetProp(hwnd, ML_LB_NTBUG)))
                {
                    // reset the flag first
                    SetProp(hwnd, ML_LB_NTBUG, (HANDLE)(0L));

                    break;   // fall through default process
                }

                for (INT_PTR iLP = 0; iLP < iLBCnt; iLP++)
                    MLLBCBDoDeleteItem(hwnd, iLP);
            }

            break;   // fall through default process
        }

        case WM_MOUSEMOVE:
        {
            RECT rcListBox;

            // don't need to take care drawing if OwnerDraw...
            if (fOwnerDraw)
                break;      // fall through default process

            // decide if this is sub win, LB inside CB.
            BOOL fIsCB_LB = MLIsLBFromCB(hwnd);

            GetClientRect(hwnd, &rcListBox);
            int iXPos = LOWORD(lParam) | ((LOWORD(lParam) & (WORD)(0x8000)) ? (int)(0xFFFF0000) : (int)(0));
            int iYPos = HIWORD(lParam) | ((HIWORD(lParam) & (WORD)(0x8000)) ? (int)(0xFFFF0000) : (int)(0));
            if ((wParam & MK_LBUTTON) ||
                (fIsCB_LB && (iXPos < rcListBox.right) && (iYPos < rcListBox.bottom) &&
                             (iXPos >= rcListBox.left) && (iYPos >= rcListBox.top))
               )
            {
                RECT rcRePaint;
                INT_PTR iPrevSel, iCurSel;
                LRESULT fPrevStat, fCurStat;
                BOOL fRePaint = FALSE;

                int iItemHeight = (int)DefSubclassProc(hwnd, LB_GETITEMHEIGHT, (WPARAM)0L, (LPARAM)0L);
                iPrevSel = iCurSel 
                         = DefSubclassProc(
                                hwnd, 
                                ((dwStyle & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) ? LB_GETCARETINDEX : LB_GETCURSEL),
                                (WPARAM)0L, (LPARAM)0L
                           );
                fPrevStat = DefSubclassProc(hwnd, LB_GETSEL, (WPARAM)iPrevSel, (LPARAM)0L);
                if (iPrevSel == LB_ERR)
                    iPrevSel = DefSubclassProc(hwnd, LB_GETTOPINDEX, (WPARAM)0L, (LPARAM)0L);

                if (LB_ERR != DefSubclassProc(hwnd, LB_GETITEMRECT, (WPARAM)iPrevSel, (LPARAM)&rcRePaint))
                {
                    if ((max(0, iYPos) < rcRePaint.top) || ((!fIsCB_LB) && (iYPos >= (rcListBox.bottom - 1))))
                    {
                        rcRePaint.top -= iItemHeight;
                        fRePaint = TRUE;
                    }

                    if ((!fRePaint) &&
                        ((min((rcListBox.bottom - 1), iYPos) >= rcRePaint.bottom) || ((!fIsCB_LB) && (iYPos < 0))))
                    {
                        rcRePaint.bottom += iItemHeight;
                        rcRePaint.bottom = min(rcRePaint.bottom, rcListBox.bottom);
                        fRePaint = TRUE;
                    }

                    if (fRePaint)
                    {
                        LRESULT lrRtVal = DefSubclassProc(hwnd, uMsg, wParam, lParam);

                        // check if new selection is more than one item away (for LB inside CB only)...
                        if (fIsCB_LB)
                        {
                            iCurSel = DefSubclassProc(hwnd, LB_GETCURSEL, (WPARAM)0L, (LPARAM)0L);
                            if (((iCurSel > iPrevSel) ? (iCurSel - iPrevSel) : (iPrevSel - iCurSel)) > 1)
                            {
                                RECT rcCurSel;

                                DefSubclassProc(hwnd, LB_GETITEMRECT, (WPARAM)iCurSel, (LPARAM)&rcCurSel);
                                rcRePaint.top = min(rcRePaint.top, rcCurSel.top);
                                rcRePaint.bottom = max(rcRePaint.bottom, rcCurSel.bottom);
                            }
                        }

                        InvalidateRect(hwnd, &rcRePaint, FALSE);
                        return lrRtVal;
                    }
                    else if ((fIsCB_LB) && (wParam & MK_LBUTTON))
                    {
                        LRESULT lrRtVal = DefSubclassProc(hwnd, uMsg, wParam, lParam);
                        if (iCurSel == LB_ERR)
                            iCurSel = DefSubclassProc( hwnd, LB_GETCURSEL, (WPARAM)0L, (LPARAM)0L);
                        fCurStat = DefSubclassProc(hwnd, LB_GETSEL, (WPARAM)iCurSel, (LPARAM)0L);

                        if (fPrevStat != fCurStat)
                        {
                            DefSubclassProc(hwnd, LB_GETITEMRECT, (WPARAM)iCurSel, (LPARAM)&rcRePaint);
                            InvalidateRect(hwnd, &rcRePaint, FALSE);
                        }

                        return lrRtVal;
                    }
                }
            }

            break;      // fall through default process
        }

        case WM_LBUTTONDOWN:
        case WM_KEYDOWN:
        {
            // don't need to take care drawing if OwnerDraw...
            if (fOwnerDraw)
                break;      // fall through default process

            RECT rcListBox;
            BOOL fPaint = TRUE;

            GetClientRect(hwnd, &rcListBox);

            if (uMsg == WM_KEYDOWN)
            {
                // WM_KEYDOWN
                INT_PTR iCaretIdx, iTopIdx, iBottomIdx;
                int iItemHeight;

                iCaretIdx = DefSubclassProc(hwnd, LB_GETCARETINDEX, (WPARAM)0L, (LPARAM)0L);
                iTopIdx = DefSubclassProc(hwnd, LB_GETTOPINDEX, (WPARAM)0L, (LPARAM)0L);

                switch (wParam)
                {
                    case VK_UP:
                    case VK_LEFT:
                    case VK_PRIOR:
                    case VK_HOME:
                    {
                        if ((iTopIdx == 0) && (iCaretIdx == 0) &&
                            (0 < DefSubclassProc(hwnd, LB_GETSEL, (WPARAM)0L, (LPARAM)0L)))
                            fPaint = FALSE;

                        break;
                    }

                    case VK_DOWN:
                    case VK_RIGHT:
                    case VK_NEXT:
                    case VK_END:
                    {
                        iItemHeight = (int)DefSubclassProc(hwnd, LB_GETITEMHEIGHT, (WPARAM)0L, (LPARAM)0L);

                        if (LB_ERR != iItemHeight && 0 != iItemHeight)
                        {
                            iBottomIdx = iTopIdx + min(iLBCnt, ((rcListBox.bottom - rcListBox.top) / iItemHeight)) - 1;

                            iLBCnt--;
                            if ((iBottomIdx == iLBCnt) && (iCaretIdx == iLBCnt) &&
                                (0 < DefSubclassProc(hwnd, LB_GETSEL, (WPARAM)iLBCnt, (LPARAM)0L)))
                                fPaint = FALSE;
                        }

                        break;
                    }

                    default:
                        if ((!InRange((int)wParam, VK_A, VK_Z)) && (!InRange((int)wParam, VK_0, VK_9)))
                            fPaint = FALSE;
                }
            }
            // always paint if it is WM_LBBUTTONDOWN

            if (fPaint)
            {
                LRESULT lrRtVal = DefSubclassProc(hwnd, uMsg, wParam, lParam);
                InvalidateRect(hwnd, &rcListBox, FALSE);
                UpdateWindow(hwnd);
                return lrRtVal;
            }

            break;      // fall through default process
        }

        case WM_LBUTTONUP:
        {
            // don't need to take care drawing if OwnerDraw...
            if (fOwnerDraw)
                break;      // fall through default process

            // For cooperate with window's 'behavior':
            //      Window's LB routine only updates the selection status at mouse button up.
            //      This only affects to multiple select LB.
            if (dwStyle & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL))
            {
                INT_PTR iAnchorIdx, iCaretIdx;
                RECT rcAnchor = {0, 0, 0, 0};
                RECT rcCaret  = {0, 0, 0, 0};
                RECT rcClient, rcUpdate;

                GetClientRect(hwnd, &rcClient);
                iAnchorIdx = DefSubclassProc(hwnd, LB_GETANCHORINDEX, (WPARAM)0L, (LPARAM)0L);
                DefSubclassProc(hwnd, LB_GETITEMRECT, (WPARAM)iAnchorIdx, (LPARAM)&rcAnchor);
                iCaretIdx = DefSubclassProc(hwnd, LB_GETCARETINDEX, (WPARAM)0L, (LPARAM)0L);

                LRESULT lrRtVal;

                if (LB_ERR != DefSubclassProc(hwnd, LB_GETITEMRECT, (WPARAM)iCaretIdx, (LPARAM)&rcCaret))
                {
                    rcUpdate.left = rcClient.left;  rcUpdate.right = rcClient.right;
                    rcUpdate.top    = max(rcClient.top, min(rcAnchor.top, rcCaret.top));
                    rcUpdate.bottom = min(rcClient.bottom, max(rcAnchor.bottom, rcCaret.bottom));

                    lrRtVal = DefSubclassProc(hwnd, uMsg, wParam, lParam);
                    InvalidateRect(hwnd, &rcUpdate, FALSE);
                    UpdateWindow(hwnd);
                }
                else
                {
                    lrRtVal = DefSubclassProc(hwnd, uMsg, wParam, lParam);
                }

                return lrRtVal;
            }

            break;      // fall through default process
        }

        case LB_SETSEL:
        case LB_SETCURSEL:
        {
            INT_PTR iPrevSel, iCurSel, iPrevTopIdx, iCurTopIdx;
            RECT rcPrevSel, rcCurSel, rcUpdate;
            UINT uiSelMsg;

            // don't need to take care drawing if OwnerDraw...
            if (fOwnerDraw)
                break;      // fall through default process

            // TODO: ??? single or multiple selection LB ???
            if (uMsg == LB_SETSEL)
            {
                // multiple selection LB
                iCurSel = (INT_PTR)lParam;
                uiSelMsg = LB_GETCARETINDEX;
            }
            else // LB_SETCURSEL
            {
                // single selection LB
                iCurSel = (INT_PTR)wParam;
                uiSelMsg = LB_GETCURSEL;
            }

            if ((iCurSel < 0) || (iCurSel >= iLBCnt))
                break;      // out of range, fall through default process

            // get the prev. selection info.
            iPrevTopIdx = DefSubclassProc(hwnd, LB_GETTOPINDEX, (WPARAM)0L, (LPARAM)0L);
            iPrevSel = DefSubclassProc(hwnd, uiSelMsg, (WPARAM)0L, (LPARAM)0L);
            if (iPrevSel != LB_ERR)   // item is currently selected.
                DefSubclassProc(hwnd, LB_GETITEMRECT, (WPARAM)iPrevSel, (LPARAM)&rcPrevSel);

            // let the system do the work...
            DefSubclassProc(hwnd, uMsg, wParam, lParam);

            // get the current selection info.
            iCurTopIdx = DefSubclassProc(hwnd, LB_GETTOPINDEX, (WPARAM)0L, (LPARAM)0L);
            DefSubclassProc(hwnd, LB_GETITEMRECT, (WPARAM)iCurSel, (LPARAM)&rcCurSel);

            // adjust the update range
            if (iCurTopIdx != iPrevTopIdx)
            {
                GetClientRect(hwnd, &rcUpdate);
            }
            else
            {
                CopyRect(&rcUpdate, &rcCurSel);

                if (iPrevSel != LB_ERR)
                {
                    rcUpdate.top = min(rcPrevSel.top, rcCurSel.top);
                    rcUpdate.bottom = max(rcPrevSel.bottom, rcCurSel.bottom);
                }
                else
                {
                    rcUpdate.top = rcCurSel.top;
                    rcUpdate.bottom = rcCurSel.bottom;
                }
            }

            // do the update...
            InvalidateRect(hwnd, &rcUpdate, FALSE);
            UpdateWindow(hwnd);

            return 0;   // message has been processed
        }

        case WM_KILLFOCUS:
        case WM_SETFOCUS:
        case WM_ENABLE:
        {
            RECT  rcItem = {0, 0, 0, 0};
            RECT* prcRePaint = &rcItem;

            if (uMsg != WM_ENABLE)
            {
                INT_PTR iCurSel;

                if (LB_ERR == (iCurSel = DefSubclassProc(hwnd, LB_GETCURSEL, (WPARAM)0L, (LPARAM)0L)))
                    break;   // fall through default process
                else
                    if (LB_ERR == DefSubclassProc(hwnd, LB_GETITEMRECT, (WPARAM)iCurSel, (LPARAM)&rcItem))
                        prcRePaint = NULL;
            }
            else
                prcRePaint = NULL;   // paint whole client area

            LRESULT lrRtVal = DefSubclassProc(hwnd, uMsg, wParam, lParam);
            InvalidateRect(hwnd, prcRePaint, FALSE);
            UpdateWindow(hwnd);

            return lrRtVal;
        }

        case WM_PRINTCLIENT:
        case WM_PAINT:
        {
            // don't need to take care drawing if OwnerDraw...
            if ((iLBCnt == 0) || (fOwnerDraw))
                break;   // nothing to draw, fall through default process

            HDC hdcDC;
            PAINTSTRUCT psCtrl;
            HFONT hfontFontSav;
            RECT rcItemRC;
            int iBgModeSav, iItemHeight;
            COLORREF clrTxtSav, clrBkSav, clrHiTxt, clrHiBk;
            UINT uiFormat;
            BOOL fDisabled = (BOOL)(dwStyle & WS_DISABLED),
                 fPrtClient = (BOOL)(uMsg == WM_PRINTCLIENT),
                 fHighLighted;

            // get system info
            if (fPrtClient)
            {
                hdcDC = psCtrl.hdc = (HDC)wParam;
                GetClientRect(hwnd, &(psCtrl.rcPaint));
            }
            else
                hdcDC = BeginPaint(hwnd, &psCtrl);
            hfontFontSav = (HFONT)SelectObject(hdcDC, GetWindowFont(hwnd));
            iBgModeSav = SetBkMode(hdcDC, TRANSPARENT);
            if (fDisabled)   // ListBox is disabled
            {
                clrTxtSav = SetTextColor(hdcDC, GetSysColor(COLOR_GRAYTEXT));
                clrBkSav = SetBkColor(hdcDC, GetSysColor(COLOR_BTNFACE));
            }
            else
            {
                clrHiTxt   = GetSysColor(COLOR_HIGHLIGHTTEXT);
                clrHiBk    = GetSysColor(COLOR_HIGHLIGHT);
            }

            // get item info
            iItemHeight = (int)DefSubclassProc(hwnd, LB_GETITEMHEIGHT, (WPARAM)0L, (LPARAM)0L);
            if (LB_ERR != iItemHeight && 0 != iItemHeight)
            {
                // process the format of the text
                //TODO: process the text format
                uiFormat = DT_LEFT | DT_VCENTER;

                INT_PTR iFocusIdx = DefSubclassProc(hwnd, LB_GETCARETINDEX, (WPARAM)0L, (LPARAM)0L);

                // find the first item has to be painted
                INT_PTR iTopIdx = DefSubclassProc(hwnd, LB_GETTOPINDEX, (WPARAM)0L, (LPARAM)0L);
                // if the paint area does not start from top
                if (psCtrl.rcPaint.top != 0)
                    iTopIdx += (psCtrl.rcPaint.top - 0) / iItemHeight;

                // decide the number of items to be painted
                int iPaintHeight = psCtrl.rcPaint.bottom - psCtrl.rcPaint.top;
                int iNumItems = iPaintHeight / iItemHeight;
                // if there is space (more than 1 pt) left at bottom or paint start in the middle of an item
                if (((iPaintHeight % iItemHeight) > 0) || (((psCtrl.rcPaint.top - 0) % iItemHeight) > 0))
                    iNumItems++;
                
                for (INT_PTR iLP = iTopIdx;
                     iLP < min(iLBCnt, (iTopIdx + iNumItems));
                     iLP++)
                {
                    RECT rcTempRC;

                    // get item info
                    LPWSTR lpwszStr = NULL;

                    if (!MLLBCBGetWStrPtr(hwnd, iLP, &lpwszStr))
                        goto BailOut;   // message processed but failed.

                    DefSubclassProc(hwnd, LB_GETITEMRECT, (WPARAM)iLP, (LPARAM)&rcItemRC);

                    // adjust drawing area if we have to draw part of an item
                    rcItemRC.bottom = min(rcItemRC.bottom, psCtrl.rcPaint.bottom);

                    // decide the text color...
                    fHighLighted = (BOOL)(DefSubclassProc(hwnd, LB_GETSEL, (WPARAM)iLP, (LPARAM)0L) > 0);
                    if ((!fDisabled) && (fHighLighted))
                    {
                        clrTxtSav   = SetTextColor(hdcDC, clrHiTxt);
                        clrBkSav    = SetBkColor(hdcDC, clrHiBk);
                    }

                    // draw the string...
                    CopyRect(&rcTempRC, &rcItemRC);
                    rcTempRC.left += 2; rcTempRC.right -= 2;
                    ExtTextOut(hdcDC, 0, 0, ETO_OPAQUE, &rcItemRC, TEXT(""), 0, NULL);   // fill the background
                    DrawTextFLW(hdcDC, lpwszStr, lstrlenW(lpwszStr), &rcTempRC, uiFormat);

                    // restore the text color
                    if ((!fDisabled) && (fHighLighted))
                    {
                        SetTextColor(hdcDC, clrTxtSav);
                        SetBkColor(hdcDC, clrBkSav);
                    }

                    // put focus rectangle if ListBox is active
                    if (rcItemRC.top < psCtrl.rcPaint.top)
                        rcItemRC.top = psCtrl.rcPaint.top - 1;

                    // TODO: should not draw focus rect within Begin-End paint.
                    if ((!fDisabled) && (iLP == iFocusIdx) && ((hwnd == GetFocus()) || MLIsLBFromCB(hwnd)))
                        DrawFocusRect(hdcDC, &rcItemRC);
                }
            }

BailOut:
            // restore system info
            if (fDisabled)
            {
                SetTextColor(hdcDC, clrTxtSav);
                SetBkColor(hdcDC, clrBkSav);
            }
            SetBkMode(hdcDC, iBgModeSav);
            if (hfontFontSav)
                SelectObject(hdcDC, hfontFontSav);
            if (!fPrtClient)
                EndPaint(hwnd, &psCtrl);

            return 0;   // message has been processed
        }

        case LB_ADDSTRING:
        case LB_FINDSTRING:
        case LB_FINDSTRINGEXACT:
        case LB_GETTEXT:
        case LB_GETTEXTLEN:
        case LB_INSERTSTRING:
        case LB_SELECTSTRING:
        {
            // take care for the OS can handle unicode, but msg not get thunk (like NT4).
            if (MLIsEnabled(hwnd))
            {
                UINT uiMsgTx;

                switch (uMsg)
                {
                    case LB_ADDSTRING:
                        uiMsgTx = g_ML_LB_ADDSTRING;
                        break;
                    case LB_FINDSTRING:
                        uiMsgTx = g_ML_LB_FINDSTRING;
                        break;
                    case LB_FINDSTRINGEXACT:
                        uiMsgTx = g_ML_LB_FINDSTRINGEXACT;
                        break;
                    case LB_GETTEXT:
                        uiMsgTx = g_ML_LB_GETTEXT;
                        break;
                    case LB_GETTEXTLEN:
                        uiMsgTx = g_ML_LB_GETTEXTLEN;
                        break;
                    case LB_INSERTSTRING:
                        uiMsgTx = g_ML_LB_INSERTSTRING;
                        break;
                    case LB_SELECTSTRING:
                        uiMsgTx = g_ML_LB_SELECTSTRING;
                        break;

                    default:
                        ASSERT(0);
                }

                return SendMessage(hwnd, uiMsgTx, wParam, lParam);
            }

            break;   // should not happen, fall through default process
        }

        default:
        {
            // non-registered window message
            if ((uMsg < MIN_REG_WINMSG) || (uMsg > MAX_REG_WINMSG))
                break;   // fall through default process

            // ML_LB_ADDSTRING:
            // ML_LB_INSERTSTRING:
            if ((uMsg == g_ML_LB_ADDSTRING) || (uMsg == g_ML_LB_INSERTSTRING))
            {
                if (!lParam)
                    break;   // fall through default process

                if (MLIsLBFromCB(hwnd))
                    return DefSubclassProc(hwnd, ((uMsg == g_ML_LB_ADDSTRING) ? LB_ADDSTRING : LB_INSERTSTRING),
                                           wParam, lParam);
                else
                    return (LRESULT)MLLBCBAddInsertString(hwnd, uMsg, wParam, lParam, iLBCnt, dwStyle, TRUE);
            }

            // ML_LB_GETTEXT:
            // ML_LB_GETTEXTLEN:
            if ((uMsg == g_ML_LB_GETTEXT) || (uMsg == g_ML_LB_GETTEXTLEN))
            {
                if (((INT_PTR)wParam >= iLBCnt) || ((uMsg == g_ML_LB_GETTEXT) && (!lParam)))
                    break;   // fall through default process

                if (MLIsLBFromCB(hwnd))
                    return DefSubclassProc(hwnd, ((uMsg == g_ML_LB_GETTEXT) ? LB_GETTEXT : LB_GETTEXTLEN),
                                           wParam, lParam);
                else
                    return (LRESULT)MLLBCBGetLBTextNLength(hwnd, uMsg, wParam, lParam, iLBCnt, TRUE);
            }

            // ML_LB_FINDSTRING:
            // ML_LB_FINDSTRINGEXACT:
            if ((uMsg == g_ML_LB_FINDSTRING) || (uMsg == g_ML_LB_FINDSTRINGEXACT))
            {
                if ((!lParam) || ((INT_PTR)wParam >= iLBCnt))
                    break;   // fall through default process

                return (LRESULT)MLLBCBFindStringNExact(hwnd, uMsg, wParam, lParam, iLBCnt, TRUE);
            }

            // ML_LB_SELECTSTRING:
            if (uMsg == g_ML_LB_SELECTSTRING)
            {
                INT_PTR iIndex = SendMessage(hwnd, g_ML_LB_FINDSTRING, wParam, lParam);

                if (iIndex >= 0)
                {
                    if (dwStyle & LBS_EXTENDEDSEL)
                        SendMessage(hwnd, LB_SETSEL, (WPARAM)TRUE, (LPARAM)iIndex);
                    else
                        SendMessage(hwnd, LB_SETCURSEL, (WPARAM)iIndex, (LPARAM)0L);
                }

                return (LRESULT)iIndex;
            }

        }   // switch-default

    }   // switch

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}
//--- ListBox -------------------------------------------------


//--- ComboBox -------------------------------------------------
BOOL ComboBoxStyleCheck(DWORD dwStyle)
{
    // HasStrings   0   0   1   1
    // OwnerDraw    0   1   0   1
    // SubClassing  Y   N   Y   N
    //              ^
    //              CBS_HASSTRINGS is a default setting if not OwnerDraw.

    switch (LOBYTE(dwStyle) & 0x0F)
    {
        case CBS_DROPDOWN:
        case CBS_DROPDOWNLIST:
        {
            if (dwStyle & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))
                return FALSE;

            static BOOL fRegMsgOK = FALSE;

            if (FALSE == fRegMsgOK)
            {
                // register window message(s)
                fRegMsgOK = (BOOL)(g_ML_GETTEXT             = RegisterWindowMessageA("ML_GETTEXT"))            &&
                            (BOOL)(g_ML_GETTEXTLENGTH       = RegisterWindowMessageA("ML_GETTEXTLENGTH"))      &&
                            (BOOL)(g_ML_SETTEXT             = RegisterWindowMessageA("ML_SETTEXT"))            &&
                            (BOOL)(g_ML_CB_ADDSTRING        = RegisterWindowMessageA("ML_CB_ADDSTRING"))       &&
                            (BOOL)(g_ML_CB_FINDSTRING       = RegisterWindowMessageA("ML_CB_FINDSTRING"))      &&
                            (BOOL)(g_ML_CB_FINDSTRINGEXACT  = RegisterWindowMessageA("ML_CB_FINDSTRINGEXACT")) &&
                            (BOOL)(g_ML_CB_GETLBTEXT        = RegisterWindowMessageA("ML_CB_GETLBTEXT"))       &&
                            (BOOL)(g_ML_CB_GETLBTEXTLEN     = RegisterWindowMessageA("ML_CB_GETLBTEXTLEN"))    &&
                            (BOOL)(g_ML_CB_INSERTSTRING     = RegisterWindowMessageA("ML_CB_INSERTSTRING"))    &&
                            (BOOL)(g_ML_CB_SELECTSTRING     = RegisterWindowMessageA("ML_CB_SELECTSTRING"));
            }

            return fRegMsgOK;
        }

        case CBS_SIMPLE:
            //TODO: implement this style of CB
        default:
            return FALSE;
    }
}


void MLCBReDrawSelection(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static int g_iSM_CXEDGE     = GetSystemMetrics(SM_CXEDGE),
               g_iSM_CYEDGE     = GetSystemMetrics(SM_CYEDGE),
               g_iSM_CXVSCROLL  = GetSystemMetrics(SM_CXVSCROLL);
    RECT rcRePaint;

    // adjust repaint area...
    GetClientRect(hWnd, &rcRePaint);
    rcRePaint.left += g_iSM_CXEDGE;   rcRePaint.right -= (g_iSM_CXEDGE + g_iSM_CXVSCROLL);
    rcRePaint.top += g_iSM_CYEDGE;    rcRePaint.bottom -= g_iSM_CYEDGE;

    // default process...(must!!)
    DefSubclassProc(hWnd, uMsg, wParam, lParam);

    // repaint the area...
    InvalidateRect(hWnd, &rcRePaint, FALSE);
    UpdateWindow(hWnd);

    return;
}


LRESULT ComboBoxSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
    BOOL fSimpleCB      = ((LOBYTE(dwStyle) & 0x0F) == CBS_SIMPLE),         // == 1L
         fDropDnCB      = ((LOBYTE(dwStyle) & 0x0F) == CBS_DROPDOWN),       // == 2L
         fDropDnListCB  = ((LOBYTE(dwStyle) & 0x0F) == CBS_DROPDOWNLIST);   // == 3L

    ASSERT(uMsg);   // if happened, most possible cause is non-registered message

    // get the item count first
    INT_PTR iCBCnt = DefSubclassProc(hwnd, CB_GETCOUNT, (WPARAM)0L, (LPARAM)0L);

    switch (uMsg)
    {
        case WM_DESTROY:
        {
            if (hwnd)
            {
                //    delete any "item" if remained
                SendMessage(hwnd, CB_RESETCONTENT, wParam, lParam);

                LPMLCBSUBWINHND lpmlcbsubwin = (LPMLCBSUBWINHND)RemoveProp(hwnd, ML_CB_SUBWIN);
                if (lpmlcbsubwin)
                    LocalFree(lpmlcbsubwin);

                // Must remove by atom - Win95 compat
                RemoveProp(hwnd, MAKEINTATOM(g_atmML));
                RemoveWindowSubclass(hwnd, ComboBoxSubclassProc,  0);
            }

            LocalFree(((LPCITEM)dwRefData));

            break;   // fall through default process
        }

        case CB_DELETESTRING:
        {
            INT_PTR iIndex = (INT_PTR)wParam;
         
            if ((iIndex >= iCBCnt) || (MLLBCBDoDeleteItem(hwnd, iIndex)))
                break;   // fall through default process
            else
                return CB_ERR;   // deletion failed
        }

        case CB_RESETCONTENT:
        {
            if (iCBCnt > 0)
            {
                for (INT_PTR iLP = 0; iLP < iCBCnt; iLP++)
                    MLLBCBDoDeleteItem(hwnd, iLP);
            }

            break;   // fall through default process
        }

        case WM_GETTEXT:
        case WM_GETTEXTLENGTH:
        {
            BOOL fGetText = (BOOL)(uMsg == WM_GETTEXT);
         
            if (fGetText && (!lParam))
                return CB_ERR;

            if (IsWindowUnicode(hwnd))
            {
                return SendMessage(hwnd, (fGetText ? g_ML_GETTEXT : g_ML_GETTEXTLENGTH), wParam, lParam);
            }
            else
            {
                // get the string out
                LPWSTR lpwszTemp = (LPWSTR)LocalAlloc(LPTR, MAX_BUFFER_BYTE);
                if (!lpwszTemp)
                    return CB_ERRSPACE;

                if (CB_ERR == SendMessage(hwnd, g_ML_GETTEXT, wParam, (LPARAM)lpwszTemp))
                    return CB_ERR;

                int iStrLenA = WideCharToMultiByte(CP_ACP, 0, lpwszTemp, -1, NULL, 0, NULL, NULL);

                if (fGetText)
                {
                    if (lParam)
                    {
                        WideCharToMultiByte(CP_ACP, 0, lpwszTemp, -1, (LPSTR)lParam, iStrLenA, NULL, NULL);
                        ((LPSTR)lParam)[iStrLenA] = 0;   // ending the string
                    }
                    else
                        return CB_ERR;
                }

                LocalFree(lpwszTemp);

                return iStrLenA;
            }
        }

        case WM_SETTEXT:
        {
            if (fDropDnListCB)
                return CB_ERR;

#ifdef LATER_IE5
            // convert ANSI string to unicode string
            if (lParam)
            {
                // get child (edit ctl) window handler
                HWND hwndEdit = GetWindow(hwnd, GW_CHILD);
                if ((hwndEdit) && (fSimpleCB))
                    hwndEdit = GetWindow(hwndEdit, GW_HWNDNEXT);
                if (!hwndEdit)
                    return CB_ERR;

  #ifdef DEBUG
                CHAR szWinClass[MAX_WINCLASS_NAME];

                GetClassNameA(hwndEdit, szWinClass, ARRAYSIZE(szWinClass));
                ASSERT(0 == lstrcmpiA(szWinClass, CB_SUBWINCLASS_ED_NAME));
  #endif

                if (MLIsEnabled(hwndEdit))
                {
                    int iStrLen = lstrlenA((LPSTR)lParam) + 1;
                    LPWSTR lpwszTemp = (LPWSTR)LocalAlloc(LPTR, (iStrLen * sizeof(WCHAR)));
                    if (!lpwszTemp)
                        return CB_ERRSPACE;

                    MultiByteToWideChar(CP_ACP, 0, (LPSTR)lParam, -1, lpwszTemp, iStrLen);
                    INT_PTR iRtVal = SendMessage(hwnd, g_ML_SETTEXT, wParam, (LPARAM)lpwszTemp);
                    LocalFree(lpwszTemp);

                    return (iRtVal == CB_ERR) ? CB_ERR : TRUE;
                }
                else
                    return SendMessage(hwndEdit, WM_SETTEXT, (WPARAM)0L, lParam);
            }
            else
                return CB_ERR;
#else
            break;   // fall through default process
#endif
        }

        case WM_PRINTCLIENT:
        case WM_PAINT:
        {
            static int g_iSM_CXEDGE     = GetSystemMetrics(SM_CXEDGE),
                       g_iSM_CYEDGE     = GetSystemMetrics(SM_CYEDGE),
                       g_iSM_CXVSCROLL  = GetSystemMetrics(SM_CXVSCROLL);

            HDC hdcDC;
            HFONT hfontFontSav;
            RECT rcComboBox, rcUpdate, rcBgDraw;
            int iBgModeSav;
            INT_PTR iCurSel = CB_ERR * 100;   // set to an invalid value
            COLORREF clrTxtSav, clrBkSav, clrHiTxt, clrHiBk;
            UINT uiFormat;
            BOOL fUpdateRect, fFocused, fPedDropped,
                 fPrtClient = (BOOL)(uMsg == WM_PRINTCLIENT),
                 fDisabled = (dwStyle & WS_DISABLED);

            GetClientRect(hwnd, &rcComboBox);
            rcBgDraw.left = rcComboBox.left + g_iSM_CXEDGE;
            rcBgDraw.right = rcComboBox.right - g_iSM_CXEDGE - g_iSM_CXVSCROLL;
            rcBgDraw.top = rcComboBox.top + g_iSM_CYEDGE;
            rcBgDraw.bottom = rcComboBox.bottom - g_iSM_CYEDGE;
            fUpdateRect = GetUpdateRect(hwnd, &rcUpdate, FALSE);
            // chk if we need to draw anything...
            if ((rcUpdate.left >= rcBgDraw.right) || (!fUpdateRect) ||
                (iCBCnt == 0))
                break;   // fall through the default process

            if (!(EqualRect(&rcUpdate, &rcBgDraw)))
                DefSubclassProc(hwnd, uMsg, wParam, lParam);
            ValidateRect(hwnd, &rcUpdate);

            // adjust the drawing area...
            RECT rcTxtDraw;
            int iItemHeight, iOffset;

            CopyRect(&rcTxtDraw, &rcBgDraw);
            rcTxtDraw.left += g_iSM_CXEDGE;    rcTxtDraw.right -= g_iSM_CXEDGE;
            iItemHeight = (int)DefSubclassProc(hwnd, CB_GETITEMHEIGHT, (WPARAM)-1L, (LPARAM)0L);   // item height in selected area
            iOffset = max(((rcTxtDraw.bottom - rcTxtDraw.top - iItemHeight) / 2), 0);
            rcTxtDraw.top += iOffset;   rcTxtDraw.bottom -= iOffset;

            // process the format of the text...
            // TODO: process the text format
            uiFormat = DT_LEFT | DT_VCENTER;

            // get item info...
            LPWSTR lpwszStr = NULL;

            iCurSel = DefSubclassProc(hwnd, CB_GETCURSEL, (WPARAM)0L, (LPARAM)0L);
            if ((iCurSel == CB_ERR) || (!MLLBCBGetWStrPtr(hwnd, iCurSel, &lpwszStr)))
                return 1;   // message not processed

            // get system info...
            if (fPrtClient)
                hdcDC = (HDC)wParam;
            else
                hdcDC = GetDC(hwnd);
            hfontFontSav = (HFONT)SelectObject(hdcDC, GetWindowFont(hwnd));
            iBgModeSav = SetBkMode(hdcDC, TRANSPARENT);
            fFocused = (BOOL)(hwnd == GetFocus());
            fPedDropped = (BOOL)DefSubclassProc(hwnd, CB_GETDROPPEDSTATE, (WPARAM)0L, (LPARAM)0L);
            if (fDisabled)   // ComboBox is disabled
            {
                clrTxtSav = SetTextColor(hdcDC, GetSysColor(COLOR_GRAYTEXT));
                clrBkSav = SetBkColor(hdcDC, GetSysColor(COLOR_BTNFACE));
            }
            else
            {
                clrHiTxt   = GetSysColor(COLOR_HIGHLIGHTTEXT);
                clrHiBk    = GetSysColor(COLOR_HIGHLIGHT);
            }

            // decide the drawing color...
            if ((!fDisabled) && (fFocused) && (!fPedDropped))
            {
                clrTxtSav   = SetTextColor(hdcDC, clrHiTxt);
                clrBkSav    = SetBkColor(hdcDC, clrHiBk);
            }

            // draw the string & background...
            ExtTextOut(hdcDC, 0, 0, ETO_OPAQUE, &rcBgDraw, TEXT(""), 0, NULL);   // fill the background
            DrawTextFLW(hdcDC, lpwszStr, lstrlenW(lpwszStr), &rcTxtDraw, uiFormat);

            // restore the text color...
            if ((!fDisabled) && (fFocused) && (!fPedDropped))
            {
                SetTextColor(hdcDC, clrTxtSav);
                SetBkColor(hdcDC, clrBkSav);

                // draw the focus rect...
                DrawFocusRect(hdcDC, &rcBgDraw);
            }

            // restore system info...
            if (fDisabled)
            {
                SetTextColor(hdcDC, clrTxtSav);
                SetBkColor(hdcDC, clrBkSav);
            }
            SetBkMode(hdcDC, iBgModeSav);
            if (hfontFontSav)
                SelectObject(hdcDC, hfontFontSav);
            if (!fPrtClient)
                ReleaseDC(hwnd, hdcDC);

            return 0;   // message has been processed
        }

        case WM_ENABLE:
        case WM_SETFOCUS:
        case WM_KILLFOCUS:
        {
            MLCBReDrawSelection(hwnd, uMsg, wParam, lParam);

            return 0;
        }

        case WM_CTLCOLORLISTBOX:
        {
            HWND hwndLB = (HWND)lParam;

            LPMLCBSUBWINHND lpmlcbsubwin = (LPMLCBSUBWINHND)GetProp(hwnd, ML_CB_SUBWIN);
            if ((!lpmlcbsubwin) || (!IsWindow(lpmlcbsubwin->hwndLBSubWin)) || (hwndLB != lpmlcbsubwin->hwndLBSubWin))
            {
                // subclassing this LB...
                LPCITEM lpLBCItem = (LPCITEM)LocalAlloc(LPTR, sizeof(CITEM));
                if ((lpLBCItem) && (ListBoxStyleCheck(dwStyle = GetWindowLong(hwndLB, GWL_STYLE))))
                {
                    lpLBCItem->dwStyle = dwStyle;
                    GetClientRect(hwndLB, &(lpLBCItem->rc));
                    SetWindowSubclass(hwndLB, LB_SUB_PROC, 0, (DWORD_PTR)lpLBCItem);
                    // Must add by name - Win95 compat
                    SetProp(hwndLB, c_szML, (HANDLE)1);

                    // add prop. value into win prop...
                    if (!lpmlcbsubwin)
                        lpmlcbsubwin = (LPMLCBSUBWINHND)LocalAlloc(LPTR, sizeof(MLCBSUBWINHND));

                    if (lpmlcbsubwin)
                    {
                        lpmlcbsubwin->hwndLBSubWin = hwndLB;
                        SetProp(hwnd, ML_CB_SUBWIN, (HANDLE)lpmlcbsubwin);
                    }
                }
            }

            break;   // fall through default process
        }

        case WM_COMMAND:
        {
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                case CBN_SETFOCUS:
                case CBN_SELENDOK:
                case CBN_SELENDCANCEL:
                {
                    if (fDropDnListCB)
                    {
                        MLCBReDrawSelection(hwnd, uMsg, wParam, lParam);

                        return 0;
                    }

                    break;   // fall through default process
                }

                default:
                    break;   // fall through default process
            }

            break;   // fall through default process
        }

        case CB_SETCURSEL:
        {
            if (fDropDnListCB)
            {
                MLCBReDrawSelection(hwnd, uMsg, wParam, lParam);

                return 0;
            }

            break;   // fall through default process

        }

        case CB_ADDSTRING:
        case CB_FINDSTRING:
        case CB_FINDSTRINGEXACT:
        case CB_GETLBTEXT:
        case CB_GETLBTEXTLEN:
        case CB_INSERTSTRING:
        case CB_SELECTSTRING:
        {
            // take care for the OS can handle unicode, but msg not get thunk (like NT4).
            if (MLIsEnabled(hwnd))
            {
                UINT uiMsgTx;

                switch (uMsg)
                {
                    case CB_ADDSTRING:
                        uiMsgTx = g_ML_CB_ADDSTRING;
                        break;
                    case CB_FINDSTRING:
                        uiMsgTx = g_ML_CB_FINDSTRING;
                        break;
                    case CB_FINDSTRINGEXACT:
                        uiMsgTx = g_ML_CB_FINDSTRINGEXACT;
                        break;
                    case CB_GETLBTEXT:
                        uiMsgTx = g_ML_CB_GETLBTEXT;
                        break;
                    case CB_GETLBTEXTLEN:
                        uiMsgTx = g_ML_CB_GETLBTEXTLEN;
                        break;
                    case CB_INSERTSTRING:
                        uiMsgTx = g_ML_CB_INSERTSTRING;
                        break;
                    case CB_SELECTSTRING:
                        uiMsgTx = g_ML_CB_SELECTSTRING;
                        break;

                    default:
                        ASSERT(0);
                }

                return SendMessage(hwnd, uiMsgTx, wParam, lParam);
            }

            break;   // should not happen, fall through default process
        }

        default:
        {
            // non-registered window message
            if ((uMsg < MIN_REG_WINMSG) || (uMsg > MAX_REG_WINMSG))
                break;   // fall through default process

            // ML_CB_ADDSTRING:
            // ML_CB_INSERTSTRING:
            if ((uMsg == g_ML_CB_ADDSTRING) || (uMsg == g_ML_CB_INSERTSTRING))
            {
                if (!lParam)
                    break;   // fall through default process

                return (LRESULT)MLLBCBAddInsertString(hwnd, uMsg, wParam, lParam, iCBCnt, dwStyle, FALSE);
            }

            // ML_CB_GETLBTEXT:
            // ML_CB_GETLBTEXTLEN:
            if ((uMsg == g_ML_CB_GETLBTEXT) || (uMsg == g_ML_CB_GETLBTEXTLEN))
            {
                if (((INT_PTR)wParam >= iCBCnt) || ((uMsg == g_ML_CB_GETLBTEXT) && (!lParam)))
                    break;   // fall through default process

                return (LRESULT)MLLBCBGetLBTextNLength(hwnd, uMsg, wParam, lParam, iCBCnt, FALSE);
            }

            // ML_GETTEXT:
            // ML_GETTEXTLENGTH:
            if ((uMsg == g_ML_GETTEXT) || (uMsg == g_ML_GETTEXTLENGTH))
            {
                UINT uiTextMax = (UINT)wParam;
                LPWSTR lpwszText = (LPWSTR)lParam;
         
                if ((uMsg == g_ML_GETTEXT) && (!lpwszText))
                    break;   // fall through default process

                if (fDropDnCB)
                {
                    // dropdow list w/Edit Ctl
                    // TODO: not implement yet
                    break;   // fall through default process
                }
                else
                {
                    // DropDownList CB
                    INT_PTR iCurSel = DefSubclassProc(hwnd, CB_GETCURSEL, (WPARAM)0L, (LPARAM)0L);
                    if (iCurSel == CB_ERR)
                    {
                        // no text show up yet
                        if (uMsg == g_ML_GETTEXT)
                            lpwszText[0] = 0;
                 
                        return 0;
                    }
                    else
                    {
                        UINT uiBuffLen = (UINT)SendMessage(hwnd, g_ML_CB_GETLBTEXTLEN, (WPARAM)iCurSel, (LPARAM)0L);

                        if (uMsg == g_ML_GETTEXT)
                        {
                            LPWSTR lpwszTemp = (LPWSTR)LocalAlloc(LPTR, ((uiBuffLen + 1) * sizeof(WCHAR)));
                            if (!lpwszTemp)
                                return CB_ERRSPACE;

                            SendMessage(hwnd, g_ML_CB_GETLBTEXT, (WPARAM)iCurSel, (LPARAM)lpwszTemp);
                            StrCpyNW(lpwszText, lpwszTemp, min(uiTextMax, (uiBuffLen + 1)));
                            LocalFree(lpwszTemp);
                        }

                        return uiBuffLen;
                    }
                }
            }

            // ML_SETTEXT:
            if (uMsg == g_ML_SETTEXT)
            {
                LPWSTR lpwszText = (LPWSTR)lParam;

                if ((fDropDnListCB) || (!lpwszText) || wParam)
                    break;   // fall through default process

#ifdef LATER_IE5
                // get child (edit ctl) window handler
                HWND hwndEdit = GetWindow(hwnd, GW_CHILD);
                if ((hwndEdit) && (fSimpleCB))
                    hwndEdit = GetWindow(hwndEdit, GW_HWNDNEXT);
                if (!hwndEdit)
                    return CB_ERR;

  #ifdef DEBUG
                CHAR szWinClass[MAX_WINCLASS_NAME];

                GetClassNameA(hwndEdit, szWinClass, ARRAYSIZE(szWinClass));
                ASSERT(0 == lstrcmpiA(szWinClass, CB_SUBWINCLASS_ED_NAME));
  #endif

                if (MLIsEnabled(hwndEdit))
                    return SendMessage(hwndEdit, g_ML_SETTEXT, (WPARAM)0L, (LPARAM)lpwszText);
                else
                    return CB_ERR;
#else
                break;   // fall through default process
#endif
            }

            // ML_CB_FINDSTRING:
            // ML_CB_FINDSTRINGEXACT:
            if ((uMsg == g_ML_CB_FINDSTRING) || (uMsg == g_ML_CB_FINDSTRINGEXACT))
            {
                if ((!lParam) || ((INT_PTR)wParam >= iCBCnt))
                    break;   // fall through default process

                return (LRESULT)MLLBCBFindStringNExact(hwnd, uMsg, wParam, lParam, iCBCnt, FALSE);
            }

            // ML_CB_SELECTSTRING:
            if (uMsg == g_ML_CB_SELECTSTRING)
            {
                INT_PTR iIndex = SendMessage(hwnd, g_ML_CB_FINDSTRING, wParam, lParam);
                if (iIndex >= 0)
                    SendMessage(hwnd, CB_SETCURSEL, (WPARAM)iIndex, (LPARAM)0L);

                return iIndex;
            }

        }   // switch-default

    }   // switch

    // default procedure
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}
//--- ComboBox -------------------------------------------------


BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam)
{
    int i;
    CHAR szClass[32];

    GetClassNameA(hwnd, szClass, ARRAYSIZE(szClass));
    for (i = 0; i < ARRAYSIZE(c_CtrlTbl); i++)
    {
        DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);

        if (!lstrcmpiA(szClass, c_CtrlTbl[i].szControl) && c_CtrlTbl[i].StyleCheckProc(dwStyle)
            && GetParent(hwnd) == (HWND)lParam)
        {
            LPCITEM lpCItem = (LPCITEM)LocalAlloc(LPTR, sizeof(CITEM));

            if (lpCItem)
            {
                lpCItem->dwStyle = dwStyle;
                GetClientRect(hwnd, &lpCItem->rc);
                SetWindowSubclass(hwnd, c_CtrlTbl[i].SubclassProc, 0, (DWORD_PTR)lpCItem);
                // Must add by name - Win95 compat
                SetProp(hwnd, c_szML, (HANDLE)1);

                // NOTE: need to ML_SETTEXT the original strings, otherwise the get
                // lost when user converts to ansi while init the dialog.  Not a problem
                // on nt because nt uses createwindoww.  On nt, we could GetWindowTextW
                // and do a ML_SETTEXT.  Fortunately our caller does this for us, it seems.
            }
            break;
        }
    }
    return TRUE;
}

void SetDlgControlText(HWND hDlg, LPDLGTEMPLATE pdtNew, LPCDLGTEMPLATE pdtOrg)
{
    LPBYTE pbNew, pbOrg;
    BOOL fEx;
    UINT cItems; 

    if (HIWORD(pdtNew->style) == 0xFFFF)
    {
        DLGTEMPLATEEX *pdtex = (DLGTEMPLATEEX *)pdtNew;
        fEx = TRUE;
        cItems = pdtex->cDlgItems;
    }
    else
    {
        fEx = FALSE;
        cItems = pdtNew->cdit;
    }

    // skip DLGTEMPLATE(EX) part
    pbNew = SkipDialogHeader(pdtNew);
    pbOrg = SkipDialogHeader(pdtOrg);

    while (cItems--)
    {
        int i;
        UINT cbCreateParams;
        LPDLGITEMTEMPLATE lpdit;
        LPDLGITEMTEMPLATEEX lpditex;
        DWORD dwStyle;

        if (fEx)
        {
            lpditex = (LPDLGITEMTEMPLATEEX)pbNew;
            dwStyle = lpditex->style;
            pbNew += sizeof(DLGITEMTEMPLATEEX);
            pbOrg += sizeof(DLGITEMTEMPLATEEX);
        }
        else
        {
            lpdit = (LPDLGITEMTEMPLATE)pbNew;
            dwStyle = lpdit->style;
            pbNew += sizeof(DLGITEMTEMPLATE);
            pbOrg += sizeof(DLGITEMTEMPLATE);
        }

        i = DoMungeControl(pbOrg, dwStyle);

        // Skip the dialog control class name.
        pbNew = SkipIDorString(pbNew);
        pbOrg = SkipIDorString(pbOrg);

        if (i < ARRAYSIZE(c_CtrlTbl))
        {
            int id = (fEx)? lpditex->id: lpdit->id;

            MLSetControlTextI(GetDlgItem(hDlg, id), (LPWSTR)pbOrg);
        }

        // Look at window text now.
        pbNew = SkipIDorString(pbNew);
        pbOrg = SkipIDorString(pbOrg);

        cbCreateParams = *((LPWORD)pbNew);
        // skip any CreateParams which include the generated size WORD.
        if (cbCreateParams)
        {
            pbNew += cbCreateParams;
            pbOrg += cbCreateParams;
        }
        pbNew += sizeof(WORD);
        pbOrg += sizeof(WORD);

        // Point at the next dialog item. (DWORD aligned)
        pbNew = (LPBYTE)(((ULONG_PTR)pbNew + 3) & ~3);
        pbOrg = (LPBYTE)(((ULONG_PTR)pbOrg + 3) & ~3);
    }

    return;
}

typedef struct tagFontFace
{
    BOOL fBitCmp;
    LPCWSTR lpEnglish;
    LPCWSTR lpNative;
} FONTFACE, *LPFONTFACE;

//
// Because StrCmpIW(lstrcmpiW) converts unicode string to ansi depends on user locale
// on Win9x platform, we can't compare two different locale's unicode string properly.
// This is why we use small private helper function to compare limited DBCS font facename
//
BOOL CompareFontFaceW(LPCWSTR lpwz1, LPCWSTR lpwz2, BOOL fBitCmp)
{
    BOOL fRet;  // Return FALSE if strings are same, otherwise return TRUE

    if (g_bRunningOnNT)
        return StrCmpIW(lpwz1, lpwz2);

    if (fBitCmp)
    {
        int iLen1, iLen2;

        fRet = TRUE;
        iLen1 = lstrlenW(lpwz1);
        iLen2 = lstrlenW(lpwz2);
        if (iLen1 == iLen2)
        {
            int i;

            for (i = 0; i < iLen1; i++)
            {
                if (lpwz1[i] != lpwz2[i])
                    break;
            }

            if (i >= iLen1)
                fRet = FALSE;
        }
    }
    else
        fRet = StrCmpIW(lpwz1, lpwz2);

    return fRet;
}

void ReplaceFontFace(LPBYTE *ppbDest, LPBYTE *ppbSrc)
{
    static FONTFACE s_FontTbl[] = 
    {
        {   FALSE, L"MS Gothic", L"MS UI Gothic"                                   },
        {   TRUE,  L"MS Gothic", L"\xff2d\xff33 \xff30\x30b4\x30b7\x30c3\x30af"    },
        {   TRUE,  L"GulimChe",  L"\xad74\xb9bc"                                   },
        {   TRUE,  L"MS Song",   L"\x5b8b\x4f53"                                   },
        {   TRUE,  L"MingLiU",   L"\x65b0\x7d30\x660e\x9ad4"                       }
    };
    int i;

    for (i = 0; i < ARRAYSIZE(s_FontTbl); i++)
    {
        if (!CompareFontFaceW((LPWSTR)*ppbSrc, s_FontTbl[i].lpNative, s_FontTbl[i].fBitCmp))
        {
            // Do replacement
            StrCpyW((LPWSTR)*ppbDest, s_FontTbl[i].lpEnglish);
            *ppbSrc += (lstrlenW((LPWSTR)*ppbSrc) + 1) * sizeof(WCHAR);
            *ppbDest += (lstrlenW(s_FontTbl[i].lpEnglish) + 1) * sizeof(WCHAR);
            break;
        }
    }
    
    if (i >= ARRAYSIZE(s_FontTbl))
        CopyIDorString(ppbDest, ppbSrc);

    return;
}

LPDLGTEMPLATE MungeDialogTemplate(LPCDLGTEMPLATE pdtSrc)
{
    DWORD dwSize;
    LPDLGTEMPLATE pdtDest;

    dwSize = GetSizeOfDialogTemplate(pdtSrc);
    if (pdtDest = (LPDLGTEMPLATE)LocalAlloc(LPTR, dwSize * 2))
    {
        LPBYTE pbSrc = (LPBYTE)pdtSrc, pbDest = (LPBYTE)pdtDest;
        LPBYTE pbItemSrc, pbItemDest;
        UINT cItemsSrc, cItems; 
        LPDLGTEMPLATEEX pdtex;
        BOOL fEx;

        if (HIWORD(pdtSrc->style) == 0xFFFF)
        {
            pdtex = (DLGTEMPLATEEX *)pdtSrc;
            fEx = TRUE;
            cItems = pdtex->cDlgItems;
            memcpy(pdtDest, pdtSrc, sizeof(DLGTEMPLATEEX));
            pbSrc = (LPBYTE)(((LPDLGTEMPLATEEX)pdtSrc) + 1);
            pbDest = (LPBYTE)(((LPDLGTEMPLATEEX)pdtDest) + 1);
        }
        else
        {
            fEx = FALSE;
            cItems = pdtSrc->cdit;
            memcpy(pdtDest, pdtSrc, sizeof(DLGTEMPLATE));
            pbSrc = (LPBYTE)(pdtSrc + 1);
            pbDest = (LPBYTE)(pdtDest + 1);
        }

        CopyIDorString(&pbDest, &pbSrc);    // menu
        CopyIDorString(&pbDest, &pbSrc);    // class
        StripIDorString(&pbDest, &pbSrc);   // window text

        // font type, size and name
        if ((fEx ? pdtex->dwStyle : pdtSrc->style) & DS_SETFONT)
        {
            if (fEx)
            {
                memcpy(pbDest, pbSrc, sizeof(DWORD) + sizeof(WORD));


                pbSrc += sizeof(DWORD) + sizeof(WORD);
                pbDest += sizeof(DWORD) + sizeof(WORD);
            }
            else
            {
                memcpy(pbDest, pbSrc, sizeof(WORD));
                pbSrc += sizeof(WORD);
                pbDest += sizeof(WORD);
            }
            ReplaceFontFace(&pbDest, &pbSrc);
        }

        pbSrc = (LPBYTE)(((ULONG_PTR)pbSrc + 3) & ~3);      // DWORD align
        pbDest = (LPBYTE)(((ULONG_PTR)pbDest + 3) & ~3);    // DWORD align

        // keep items information
        cItemsSrc = cItems;
        pbItemSrc = pbSrc;
        pbItemDest = pbDest;

        while (cItems--)
        {
            int i;
            UINT cbCreateParams;
            LPDLGITEMTEMPLATE lpditSrc, lpditDest;
            LPDLGITEMTEMPLATEEX lpditexSrc, lpditexDest;
            DWORD dwStyle;

            if (fEx)
            {
                lpditexSrc = (LPDLGITEMTEMPLATEEX)pbSrc;
                lpditexDest = (LPDLGITEMTEMPLATEEX)pbDest;

                memcpy(pbDest, pbSrc, sizeof(DLGITEMTEMPLATEEX));
                dwStyle = lpditexSrc->style;

                pbSrc += sizeof(DLGITEMTEMPLATEEX);
                pbDest += sizeof(DLGITEMTEMPLATEEX);
            }
            else
            {
                lpditSrc = (LPDLGITEMTEMPLATE)pbSrc;
                lpditDest = (LPDLGITEMTEMPLATE)pbDest;

                memcpy(pbDest, pbSrc, sizeof(DLGITEMTEMPLATE));
                dwStyle = lpditSrc->style;

                pbSrc += sizeof(DLGITEMTEMPLATE);
                pbDest += sizeof(DLGITEMTEMPLATE);
            }

            i = DoMungeControl(pbSrc, dwStyle);

            CopyIDorString(&pbDest, &pbSrc);

            if (i < ARRAYSIZE(c_CtrlTbl))
            {
                int id = (fEx)? lpditexDest->id: lpditDest->id;

                if (!CheckID(pbItemSrc, cItemsSrc, fEx, id, 1))
                    id = GetUniqueID(pbItemSrc, cItemsSrc, pbItemDest, cItemsSrc - cItems, fEx);
                if (fEx)
                    lpditexDest->id = id;
                else
                    lpditDest->id = (USHORT)id;
                StripIDorString(&pbDest, &pbSrc);
            }
            else
                CopyIDorString(&pbDest, &pbSrc);

            cbCreateParams = *((LPWORD)pbSrc);

            // copy any CreateParams which include the generated size WORD.
            if (cbCreateParams)
            {
                memcpy(pbDest, pbSrc, cbCreateParams);
                pbSrc += cbCreateParams;
                pbDest += cbCreateParams;
            }
            pbSrc += sizeof(WORD);
            pbDest += sizeof(WORD);

            // Point at the next dialog item. (DWORD aligned)
            pbSrc = (LPBYTE)(((ULONG_PTR)pbSrc + 3) & ~3);      // DWORD align
            pbDest = (LPBYTE)(((ULONG_PTR)pbDest + 3) & ~3);    // DWORD align
        }
    }
    return pdtDest;
}

// BEGIN Remove these soon
LWSTDAPI_(BOOL) EndDialogWrap(HWND hDlg, INT_PTR nResult)
{
    VALIDATE_PROTOTYPE_NO_W(EndDialog);

    return EndDialog(hDlg, nResult);
}
// END Remove these soon

BOOL fDoMungeUI(HINSTANCE hinst)
{
    LANGID lidUI = MLGetUILanguage();
    BOOL fMunged = FALSE;

    // We don't do our plugui on NT5...
    if (!g_bRunningOnNT5OrHigher)
    {
        // We don't need to munge if UI language is same as install language - perf.
        if (lidUI && lidUI != GetInstallLanguage())
        {
            ENTERCRITICAL;
            int i = GetPUIITEM(hinst);

            if (0 <= i)
            {
                PPUIITEM pItem = (PPUIITEM)DPA_FastGetPtr(g_hdpaPUI, i);
                if (pItem)
                    fMunged = pItem->fMunged;
            }
            LEAVECRITICAL;
        }
    }
    return fMunged;
}

typedef struct tagMLDLGPROCPARAM
{
    LPARAM dwInitParam;
    LPDLGTEMPLATE lpNewTemplate;
    LPCDLGTEMPLATE lpOrgTemplate;
    DLGPROC DlgProc;
} MLDLGPROCPARAM, *LPMLDLGPROCPARAM;

BOOL_PTR MLDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            LPMLDLGPROCPARAM lpDlgProcParam = (LPMLDLGPROCPARAM)lParam;

            // Bump the refcount on the global atom just to make sure
            if (g_atmML == 0) {
                g_atmML = GlobalAddAtom(c_szML);
            }

            // subclass control windows
            EnumChildWindows(hwnd, EnumChildProc, (LPARAM)hwnd);
            SetDlgControlText(hwnd, lpDlgProcParam->lpNewTemplate, lpDlgProcParam->lpOrgTemplate);
            if (g_bRunningOnNT)
                SetWindowLongPtrW(hwnd, DWLP_DLGPROC, (LPARAM)lpDlgProcParam->DlgProc);
            else
                SetWindowLongPtrA(hwnd, DWLP_DLGPROC, (LPARAM)lpDlgProcParam->DlgProc);
            return SendMessageWrapW(hwnd, uMsg, wParam, lpDlgProcParam->dwInitParam);
        }
    }
    return FALSE;
}

#undef DialogBoxIndirectParamW

INT_PTR MLDialogBoxIndirectParamI(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    LPDLGTEMPLATE p;
    INT_PTR iRet = -1;
    
    ASSERT(fDoMungeUI(hInstance));

    if (p = MungeDialogTemplate(lpTemplate))
    {
        MLDLGPROCPARAM MLDlgProcParam;

        MLDlgProcParam.dwInitParam = dwInitParam;
        MLDlgProcParam.lpNewTemplate = p;
        MLDlgProcParam.lpOrgTemplate = lpTemplate;
        MLDlgProcParam.DlgProc = lpDialogFunc;

        if (g_bRunningOnNT)
            iRet = DialogBoxIndirectParamW(hInstance, p, hwndParent, MLDialogProc, (LPARAM)&MLDlgProcParam);
        else
            iRet = DialogBoxIndirectParamA(hInstance, p, hwndParent, MLDialogProc, (LPARAM)&MLDlgProcParam);
        LocalFree(p);
    }
    return iRet;
}

INT_PTR MLDialogBoxParamI(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    HRSRC hrsr;
    HGLOBAL h;
    LPDLGTEMPLATE p;
    INT_PTR iRet = -1;

    if (hrsr = FindResourceWrapW(hInstance, lpTemplateName, (LPCWSTR)RT_DIALOG))
    {
        if (h = LoadResource(hInstance, hrsr))
        {
            if (p = (LPDLGTEMPLATE)LockResource(h))
                iRet = MLDialogBoxIndirectParamI(hInstance, p, hwndParent, lpDialogFunc, dwInitParam);
        }
    }
    return iRet;
}

#undef CreateDialogIndirectParamW

HWND MLCreateDialogIndirectParamI(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    LPDLGTEMPLATE p;
    HWND hwndRet = NULL;

    ASSERT(fDoMungeUI(hInstance));

    if (p = MungeDialogTemplate(lpTemplate))
    {
        MLDLGPROCPARAM MLDlgProcParam;

        MLDlgProcParam.dwInitParam = dwInitParam;
        MLDlgProcParam.lpNewTemplate = p;
        MLDlgProcParam.lpOrgTemplate = lpTemplate;
        MLDlgProcParam.DlgProc = lpDialogFunc;

        if (g_bRunningOnNT)
            hwndRet = CreateDialogIndirectParamW(hInstance, p, hwndParent, MLDialogProc, (LPARAM)&MLDlgProcParam);
        else
            hwndRet = CreateDialogIndirectParamA(hInstance, p, hwndParent, MLDialogProc, (LPARAM)&MLDlgProcParam);
        LocalFree(p);
    }
    return hwndRet;
}

HWND MLCreateDialogParamI(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    HRSRC hrsr;
    HGLOBAL h;
    LPDLGTEMPLATE p;
    HWND hwndRet = NULL;

    if (hrsr = FindResourceWrapW(hInstance, lpTemplateName, (LPCWSTR)RT_DIALOG))
    {
        if (h = LoadResource(hInstance, hrsr))
        {
            if (p = (LPDLGTEMPLATE)LockResource(h))
                hwndRet = MLCreateDialogIndirectParamI(hInstance, p, hwndParent, lpDialogFunc, dwInitParam);
        }
    }
    return hwndRet;
}

BOOL MLIsEnabled(HWND hwnd)
{
#ifndef UNIX
    if (hwnd && g_atmML)
        return (BOOL)PtrToLong(GetProp(hwnd, MAKEINTATOM(g_atmML)));
#endif
    return FALSE;
}

int MLGetControlTextI(HWND hWnd, LPCWSTR lpString, int nMaxCount)
{
    ASSERT(MLIsEnabled(hWnd));
    ASSERT(g_ML_GETTEXT);

    if (lpString && nMaxCount > 0)
    {
        return (int)SendMessage(hWnd, g_ML_GETTEXT, nMaxCount, (LPARAM)lpString);
    }
    else
        return 0;
}

BOOL MLSetControlTextI(HWND hWnd, LPCWSTR lpString)
{
    ASSERT(MLIsEnabled(hWnd));
    ASSERT(g_ML_SETTEXT);

    if (lpString)
    {
        return (BOOL)SendMessage(hWnd, g_ML_SETTEXT, 0, (LPARAM)lpString);
    }
    else
        return FALSE;
}

#define MAXRCSTRING 514

// this will check to see if lpcstr is a resource id or not.  if it
// is, it will return a LPSTR containing the loaded resource.
// the caller must LocalFree this lpstr.  if pszText IS a string, it
// will return pszText
//
// returns:
//      pszText if it is already a string
//      or
//      LocalAlloced() memory to be freed with LocalFree
//      if pszRet != pszText free pszRet

LPWSTR ResourceCStrToStr(HINSTANCE hInst, LPCWSTR pszText)
{
    WCHAR szTemp[MAXRCSTRING];
    LPWSTR pszRet = NULL;

    if (!IS_INTRESOURCE(pszText))
        return (LPWSTR)pszText;

    if (LOWORD((DWORD_PTR)pszText) && LoadStringWrapW(hInst, LOWORD((DWORD_PTR)pszText), szTemp, ARRAYSIZE(szTemp)))
    {
        pszRet = (LPWSTR)LocalAlloc(LPTR, (lstrlenW(szTemp) + 1) * SIZEOF(WCHAR));
        if (pszRet)
            StrCpyW(pszRet, szTemp);
    }
    return pszRet;
}

LPWSTR _ConstructMessageString(HINSTANCE hInst, LPCWSTR pszMsg, va_list *ArgList)
{
    LPWSTR pszRet;
    LPWSTR pszRes = ResourceCStrToStr(hInst, pszMsg);
    if (!pszRes)
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: Failed to load string template"));
        return NULL;
    }

    if (!FormatMessageWrapW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                       pszRes, 0, 0, (LPWSTR)&pszRet, 0, ArgList))
    {
        DebugMsg(DM_ERROR, TEXT("_ConstructMessageString: FormatMessage failed %d"),GetLastError());
        DebugMsg(DM_ERROR, TEXT("                         pszRes = %s"), pszRes );
        DebugMsg(DM_ERROR, !IS_INTRESOURCE(pszMsg) ? 
            TEXT("                         pszMsg = %s") : 
            TEXT("                         pszMsg = 0x%x"), pszMsg );
        pszRet = NULL;
    }


    if (pszRes != pszMsg)
        LocalFree(pszRes);

    return pszRet;      // free with LocalFree()
}

LWSTDAPIV_(int) ShellMessageBoxWrapW(HINSTANCE hInst, HWND hWnd, LPCWSTR pszMsg, LPCWSTR pszTitle, UINT fuStyle, ...)
{
    LPWSTR pszText;
    int result;
    WCHAR szBuffer[80];
    va_list ArgList;

    // BUG 95214
#ifdef DEBUG
    IUnknown* punk = NULL;
    if (SUCCEEDED(SHGetThreadRef(&punk)) && punk)
    {
        ASSERTMSG(hWnd != NULL, TEXT("shlwapi\\mlui.cpp : ShellMessageBoxWrapW - Caller should either be not under a browser or should have a parent hwnd"));
        punk->Release();
    }
#endif

    if (!IS_INTRESOURCE(pszTitle))
    {
        // do nothing
    }
    else if (LoadStringWrapW(hInst, LOWORD((DWORD_PTR)pszTitle), szBuffer, ARRAYSIZE(szBuffer)))
    {
        // Allow this to be a resource ID or NULL to specifiy the parent's title
        pszTitle = szBuffer;
    }
    else if (hWnd)
    {
        // The caller didn't give us a Title, so let's use the Window Text.

        // Grab the title of the parent
        GetWindowTextWrapW(hWnd, szBuffer, ARRAYSIZE(szBuffer));

        // HACKHACK YUCK!!!!
        // Is the window the Desktop window?
        if (!StrCmpW(szBuffer, L"Program Manager"))
        {
            // Yes, so we now have two problems,
            // 1. The title should be "Desktop" and not "Program Manager", and
            // 2. Only the desktop thread can call this or it will hang the desktop
            //    window.

            // Is the window Prop valid?
            if (GetWindowThreadProcessId(hWnd, 0) == GetCurrentThreadId())
            {
                // Yes, so let's get it...

                // Problem #1, load a localized version of "Desktop"
                pszTitle = (LPCWSTR) GetProp(hWnd, TEXT("pszDesktopTitleW"));

                if (!pszTitle)
                {
                    // Oops, this must have been some app with "Program Manager" as the title.
                    pszTitle = szBuffer;
                }
            }
            else
            {
                // No, so we hit problem 2...

                // Problem #2, Someone is going to
                //             hang the desktop window by using it as the parent
                //             of a dialog that belongs to a thread other than
                //             the desktop thread.
                RIPMSG(0, "****************ERROR********** The caller is going to hang the desktop window by putting a modal dlg on it.");
            }
        }
        else
            pszTitle = szBuffer;
    }
    else
    {
        pszTitle = L"";
    }

    va_start(ArgList, fuStyle);
    pszText = _ConstructMessageString(hInst, pszMsg, &ArgList);
    va_end(ArgList);

    if (pszText)
    {
        result = MessageBoxWrapW(hWnd, pszText, pszTitle, fuStyle | MB_SETFOREGROUND);
        LocalFree(pszText);
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("smb: Not enough memory to put up dialog."));
        result = -1;    // memory failure
    }

    return result;
}

HRESULT GetFilePathFromLangId (LPCSTR pszFile, LPSTR pszOut, int cchOut, DWORD dwFlag)
{
    HRESULT hr = S_OK;
    char szMUIPath[MAX_PATH];
    LPCSTR lpPath;
    LANGID lidUI;
    
    if (pszFile)
    {
        // FEATURE: should support '>' format but not now
        if (*pszFile == '>') return E_FAIL;

        lidUI = GetNormalizedLangId(dwFlag);
        if (0 == lidUI || GetInstallLanguage() == lidUI)
            lpPath = pszFile;
        else
        {
            GetMUIPathOfIEFileA(szMUIPath, ARRAYSIZE(szMUIPath), pszFile, lidUI);
            lpPath = (LPCSTR)szMUIPath;
        }
        lstrcpyn(pszOut, lpPath, min(MAX_PATH, cchOut));
    }
    else
        hr = E_FAIL;

    return hr;
}

// 
// MLHtmlHelp / MLWinHelp
//
// Function: load a help file corresponding to the current UI lang setting 
//           from \mui\<Lang ID>
//
//
#ifndef UNIX
HWND MLHtmlHelpA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage)
{

    CHAR szPath[MAX_PATH];
    HRESULT hr = E_FAIL;
    HWND hwnd = NULL;

    // FEATURE: 1) At this moment we only support the cases that pszFile points to 
    //         a fully qualified file path, like when uCommand == HH_DISPLAY_TOPIC
    //         or uCommand == HH_DISPLAY_TEXT_POPUP. 
    //         2) We should support '>' format to deal with secondary window
    //         3) we may need to thunk file names within HH_WINTYPE structures?
    //
    if (uCommand == HH_DISPLAY_TOPIC || uCommand == HH_DISPLAY_TEXT_POPUP)
    {
        hr = GetFilePathFromLangId(pszFile, szPath, ARRAYSIZE(szPath), dwCrossCodePage);
        if (hr == S_OK)
            hwnd = HtmlHelp(hwndCaller, szPath, uCommand, dwData); 
    }

    // if there was any failure in getting ML path of help file
    // we call the help engine with original file path.
    if (hr != S_OK)
    {
        hwnd = HtmlHelp(hwndCaller, pszFile, uCommand, dwData); 
    }
    return hwnd;
}
#endif

BOOL MLWinHelpA(HWND hwndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData)
{

    CHAR szPath[MAX_PATH];
    BOOL fret;

    HRESULT hr = GetFilePathFromLangId(lpszHelp, szPath, ARRAYSIZE(szPath), ML_NO_CROSSCODEPAGE);
    if (hr == S_OK)
    {
        fret = WinHelp(hwndCaller, szPath, uCommand, dwData);
    }
    else
        fret = WinHelp(hwndCaller, lpszHelp, uCommand, dwData);

    return fret;
}

#ifndef UNIX
HWND MLHtmlHelpW(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage)
{
    HRESULT hr = E_FAIL;
    HWND hwnd = NULL;

    // FEATURE: 1) At this moment we only support the cases that pszFile points to 
    //         a fully qualified file path, like when uCommand == HH_DISPLAY_TOPIC
    //         or uCommand == HH_DISPLAY_TEXT_POPUP. 
    //         2) We should support '>' format to deal with secondary window
    //         3) we may need to thunk file names within HH_WINTYPE structures?
    //
    if (uCommand == HH_DISPLAY_TOPIC || uCommand == HH_DISPLAY_TEXT_POPUP)
    {
        CHAR szFileName[MAX_PATH];
        LPCSTR pszFileParam = NULL;

        if (pszFile)
        {
            SHUnicodeToAnsi(pszFile, szFileName, ARRAYSIZE(szFileName));
            pszFileParam = szFileName;
        }

        hr = GetFilePathFromLangId(pszFileParam, szFileName, ARRAYSIZE(szFileName), dwCrossCodePage);
        if (hr == S_OK)
        {
            ASSERT(NULL != pszFileParam);   // GetFilePathFromLangId returns E_FAIL with NULL input
            
            WCHAR wszFileName[MAX_PATH];

            SHAnsiToUnicode(szFileName, wszFileName, ARRAYSIZE(wszFileName));
            hwnd = HtmlHelpW(hwndCaller, wszFileName, uCommand, dwData); 
        }
    }

    // if there was any failure in getting ML path of help file
    // we call the help engine with original file path.
    if (hr != S_OK)
    {
        hwnd = HtmlHelpW(hwndCaller, pszFile, uCommand, dwData); 
    }
    return hwnd;
}
#endif


BOOL MLWinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, DWORD_PTR dwData)
{
    CHAR szFileName[MAX_PATH];
    LPCSTR pszHelpParam = NULL;

    if (lpszHelp && SHUnicodeToAnsi(lpszHelp, szFileName, ARRAYSIZE(szFileName)))
    {
        pszHelpParam = szFileName;
    }
    return  MLWinHelpA(hWndMain, pszHelpParam, uCommand, dwData);
}

//
//  Font link wrappers
//
int DrawTextFLW(HDC hdc, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat)
{
    typedef int (* PFNDRAWTEXT)(HDC, LPCWSTR, int, LPRECT, UINT);
    static PFNDRAWTEXT pfnDrawTextW = NULL;

    if (NULL == pfnDrawTextW)
    {
        HMODULE hComctl32 = LoadLibrary("comctl32.dll");

        if (hComctl32)
            pfnDrawTextW = (PFNDRAWTEXT)GetProcAddress(hComctl32, (LPCSTR)415);
    }

    if (pfnDrawTextW)
        return pfnDrawTextW(hdc, lpString, nCount, lpRect, uFormat);

    return 0;
}

int DrawTextExFLW(HDC hdc, LPWSTR pwzText, int cchText, LPRECT lprc, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams)
{
    typedef int (* PFNDRAWTEXTEX)(HDC, LPWSTR, int, LPRECT, UINT, LPDRAWTEXTPARAMS);
    static PFNDRAWTEXTEX pfnDrawTextExW = NULL;

    if (NULL == pfnDrawTextExW)
    {
        HMODULE hComctl32 = LoadLibrary("comctl32.dll");

        if (hComctl32)
            pfnDrawTextExW = (PFNDRAWTEXTEX)GetProcAddress(hComctl32, (LPCSTR)416);
    }

    if (pfnDrawTextExW)
        return pfnDrawTextExW(hdc, pwzText, cchText, lprc, dwDTFormat, lpDTParams);

    return 0;
}

BOOL GetTextExtentPointFLW(HDC hdc, LPCWSTR lpString, int nCount, LPSIZE lpSize)
{
    typedef BOOL (* PFNGETTEXTEXTENTPOINT)(HDC, LPCWSTR, int, LPSIZE);
    static PFNGETTEXTEXTENTPOINT pfnGetTextExtentPointW = NULL;

    if (NULL == pfnGetTextExtentPointW)
    {
        HMODULE hComctl32 = LoadLibrary("comctl32.dll");

        if (hComctl32)
            pfnGetTextExtentPointW = (PFNGETTEXTEXTENTPOINT)GetProcAddress(hComctl32, (LPCSTR)419);
    }

    if (pfnGetTextExtentPointW)
        return pfnGetTextExtentPointW(hdc, lpString, nCount, lpSize);

    return FALSE;
}

int ExtTextOutFLW(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect, LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp)
{
    typedef int (* PFNEXTTEXTOUT)(HDC, int, int, UINT, CONST RECT*, LPCWSTR, UINT, CONST INT*);
    static PFNEXTTEXTOUT pfnExtTextOutW = NULL;

    if (NULL == pfnExtTextOutW)
    {
        HMODULE hComctl32 = LoadLibrary("comctl32.dll");

        if (hComctl32)
            pfnExtTextOutW = (PFNEXTTEXTOUT)GetProcAddress(hComctl32, (LPCSTR)417);
    }

    if (pfnExtTextOutW)
        return pfnExtTextOutW(hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp);

    return 0;
}

const WCHAR c_szResPrefix[] = L"res://";

LWSTDAPI
MLBuildResURLW(LPCWSTR  pszLibFile,
               HMODULE  hModule,
               DWORD    dwCrossCodePage,
               LPCWSTR  pszResName,
               LPWSTR   pszResUrlOut,
               int      cchResUrlOut)
{
    HRESULT hr;
    LPWSTR  pszWrite;
    int     cchBufRemaining;
    int     cchWrite;

    RIP(IS_VALID_STRING_PTRW(pszLibFile, -1));
    RIP(hModule != INVALID_HANDLE_VALUE);
    RIP(hModule != NULL);
    RIP(IS_VALID_STRING_PTRW(pszResName, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszResUrlOut, WCHAR, cchResUrlOut));

    hr = E_INVALIDARG;

    if (pszLibFile != NULL &&
        hModule != NULL &&
        hModule != INVALID_HANDLE_VALUE &&
        (dwCrossCodePage == ML_CROSSCODEPAGE || dwCrossCodePage == ML_NO_CROSSCODEPAGE) &&
        pszResName != NULL &&
        pszResUrlOut != NULL)
    {
        hr = E_FAIL;

        pszWrite = pszResUrlOut;
        cchBufRemaining = cchResUrlOut;

        // write in the res protocol prefix
        cchWrite = lstrlenW(c_szResPrefix);
        if (cchBufRemaining >= cchWrite+1)
        {
            HINSTANCE   hinstLocRes;

            StrCpyNW(pszWrite, c_szResPrefix, cchBufRemaining);
            pszWrite += cchWrite;
            cchBufRemaining -= cchWrite;

            // figure out the module path
            // unfortunately the module path might only exist
            // after necessary components are JIT'd, and
            // we don't know whether a JIT is necessary unless
            // certain LoadLibrary's have failed.
            hinstLocRes = MLLoadLibraryW(pszLibFile, hModule, dwCrossCodePage);
            if (hinstLocRes != NULL)
            {
                BOOL    fGotModulePath;
                WCHAR   szLocResPath[MAX_PATH];

                fGotModulePath = GetModuleFileNameWrapW(hinstLocRes, szLocResPath, ARRAYSIZE(szLocResPath));

                MLFreeLibrary(hinstLocRes);

                if (fGotModulePath)
                {
                    // copy in the module path
                    cchWrite = lstrlenW(szLocResPath);
                    if (cchBufRemaining >= cchWrite+1)
                    {
                        StrCpyNW(pszWrite, szLocResPath, cchBufRemaining);
                        pszWrite += cchWrite;
                        cchBufRemaining -= cchWrite;

                        // write the next L'/' and the resource name
                        cchWrite = 1 + lstrlenW(pszResName);
                        if (cchBufRemaining >= cchWrite+1)
                        {
                            *(pszWrite++) = L'/';
                            cchBufRemaining--;
                            StrCpyNW(pszWrite, pszResName, cchBufRemaining);

                            ASSERT(pszWrite[lstrlenW(pszResName)] == '\0');

                            hr = S_OK;
                        }
                    }
                }
            }
        }

        if (FAILED(hr))
        {
            pszResUrlOut[0] = L'\0';
        }
    }

    return hr;
}

LWSTDAPI
MLBuildResURLA(LPCSTR    pszLibFile,
               HMODULE  hModule,
               DWORD    dwCrossCodePage,
               LPCSTR   pszResName,
               LPSTR   pszResUrlOut,
               int      cchResUrlOut)
{
    HRESULT hr;

    RIP(IS_VALID_STRING_PTR(pszLibFile, -1));
    RIP(hModule != INVALID_HANDLE_VALUE);
    RIP(hModule != NULL);
    RIP(IS_VALID_STRING_PTRA(pszResName, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszResUrlOut, CHAR, cchResUrlOut));

    CStrInW     strLF(pszLibFile);
    CStrInW     strRN(pszResName);
    CStrOutW    strRUO(pszResUrlOut, cchResUrlOut);

    hr = MLBuildResURLW(strLF, hModule, dwCrossCodePage, strRN, strRUO, strRUO.BufSize());

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\nullstm.h ===
#ifndef UNIX
IStream* SHConstNullStream();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\palette.c ===
/***************************************************************************
 *  palette.c
 *
 *  Common halftone palette used by shell.   
 *
 ***************************************************************************/

#include "priv.h"
#include "palette.h"

#ifdef UNIX
#include <mainwin.h>
#endif /* UNIX */

BYTE * g_pbWinNTCMAP = NULL;

// This function behaves the same as CreateHalftone palette:
//      hdc == NULL         always return full palette
//      hdc palettized      return full palette
//      hdc not palettized  return default palette (VGA colors)

HPALETTE SHCreateShellPalette(HDC hdc)
{
    HPALETTE        hpalHalftone;
    LOGPAL256       lp;
    BOOL            fGetSystemColors = FALSE;
    
    // We would like to use CreateHalftonePalette() always but they
    // differ significantly between NT and Win95.  Win95's is very
    // close to Netscape's; NT's is significantly different (color
    // cube cut differently) and it is not an identity palette.
    //
    // So, we will use CreateHalftonePalette() on Win95 and on NT
    // we will use a custom palette containing the same colors in
    // Win95's halftone palette ordered so that the color flash
    // will be minimized when switching between NT's halftone palette
    // and our palette.
    //
    // On NT 5 and later the halftone palette matches Win95's so the
    // custom palette will only be used on machines running NT 4 or below.
    // However, we still need to patch in the system colors on NT 5.

#ifdef UNIX
    if (MwIsInitLite())
       return NULL;
#endif /* UNIX */

    if (!g_bRunningOnNT || g_bRunningOnNT5OrHigher)
    {
        hpalHalftone = CreateHalftonePalette(hdc);

        if (g_bRunningOnNT5OrHigher && hpalHalftone)
        {
            lp.wCnt = (WORD)GetPaletteEntries(hpalHalftone, 0, 256, lp.ape);
            lp.wVer = 0x0300;
            fGetSystemColors = TRUE;
            DeleteObject(hpalHalftone);
        }
    }
    else if (hdc == NULL || (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE))
    {
        memcpy(&lp, &g_lpHalftone, sizeof(g_lpHalftone));
        fGetSystemColors = TRUE;
    }
    else
        hpalHalftone = GetStockObject(DEFAULT_PALETTE);

    if (fGetSystemColors)
    {
        HDC hdcScreen = hdc;

        if (hdcScreen == NULL)
            hdcScreen = CreateCompatibleDC(NULL);
#ifndef UNIX
        if (hdcScreen)
        {
            GetSystemPaletteEntries(hdcScreen, 0, 10, lp.ape);
            GetSystemPaletteEntries(hdcScreen, 246, 10, lp.ape + 246);
        }
#endif
        hpalHalftone = CreatePalette((LOGPALETTE *)&lp);
        
        if (hdc == NULL && hdcScreen)
            DeleteDC(hdcScreen);
    }

    return hpalHalftone;
}

static const BYTE *GetInverseCMAP()
{
    const BYTE * abWin95ToNT;

    if (!g_bRunningOnNT)
    {
        return g_abWin95CMAP;
    }

    abWin95ToNT = (g_bRunningOnNT5OrHigher ? g_abWin95ToNT5 : g_abWin95ToNT4);

    if (g_pbWinNTCMAP == NULL)
    {
        BYTE * pbMap = LocalAlloc(LPTR, 32768);
        if (pbMap)
        {
            int i;
            BYTE * pbDst = pbMap;
            const BYTE * pbSrc = g_abWin95CMAP;
            for (i = 0; i < 32768; ++i)
            {
                *pbDst++ = abWin95ToNT[*pbSrc++];
            }
            if (SHInterlockedCompareExchange((void **)&g_pbWinNTCMAP, pbMap, NULL))
            {
                LocalFree(pbMap);   // race, get rid of dupe copy
            }
        }
    }
    return g_pbWinNTCMAP;
}

HRESULT SHGetInverseCMAP(BYTE *pbMap, ULONG cbMap)
{
    const BYTE *pbSrc;

    if (pbMap == NULL)
        return E_POINTER;
        
    if (cbMap != 32768 && cbMap != sizeof(BYTE *))
        return E_INVALIDARG;

    pbSrc = GetInverseCMAP();

    if (pbSrc == NULL)
        return E_OUTOFMEMORY;

    if (cbMap == sizeof(BYTE *))
    {
        *(const BYTE **)pbMap = pbSrc;
    }
    else
    {
        memcpy(pbMap, pbSrc, 32768);
    }

    return(S_OK);
}


void TermPalette()
{
    if (g_pbWinNTCMAP)
        LocalFree(g_pbWinNTCMAP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

#ifdef STRICT
#undef STRICT
#endif
#define STRICT


/* disable "non-standard extension" warnings in our code
 */
#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif

#include <w4warn.h>
/*
 *   Level 4 warnings to be turned on.
 *   Do not disable any more level 4 warnings.
 */
#pragma warning(disable:4706) /* assignment within conditional expression                              */
#pragma warning(disable:4127) /* conditional expression is constant                                    */
#pragma warning(disable:4245) /* 'initializing' : conversion from 'int' to 'DWORD', signed/unsigned    */
                              /*    mismatch                                                           */
#pragma warning(disable:4189) /* local variable is initialized but not referenced                      */
#pragma warning(disable:4057) /* 'LPSTR ' differs in indirection to slightly different base types from */
                              /*   'LPBYTE '                                                           */
#pragma warning(disable:4701) /* local variable 'clrBkSav' may be used without having been initialized */
#pragma warning(disable:4310) /* cast truncates constant value                                         */
#pragma warning(disable:4702) /* unreachable code                                                      */
#pragma warning(disable:4206) /* nonstandard extension used : translation unit is empty                */
#pragma warning(disable:4267) /* '=' : conversion from 'size_t' to 'int', possible loss of data        */
#pragma warning(disable:4328) /* 'BOOL StrToIntExA(const LPCSTR,DWORD,int *__ptr64 )' : indirection    */
                              /*   alignment of formal parameter 3 (4) is greater than the actual      */
                              /*   argument alignment (2)                                              */
#pragma warning(disable:4509) /* nonstandard extension used: 'IOWorkerThread' uses SEH and 'info'      */
                              /*   has destructor                                                      */


#ifdef WIN32
#define _SHLWAPI_
#define _SHLWAPI_THUNK_
#define _OLE32_                     // we delay-load OLE
#define _OLEAUT32_                  // we delay-load OLEAUT32
#define _INC_OLE
#define CONST_VTABLE
#endif

#define _COMCTL32_                  // for DECLSPEC_IMPORT
#define _NTSYSTEM_                  // for DECLSPEC_IMPORT ntdll
#define _SETUPAPI_                  // for DECLSPEC_IMPORT setupapi

#define CC_INTERNAL

// Conditional for apithk.c
#ifndef _WIN32_WINDOWS
#define _WIN32_WINDOWS      0x0400
#endif

#ifndef WINVER
#define WINVER              0x0400
#endif

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>               // to get IStream for image.c
#include <port32.h>
#define DISALLOW_Assert
#include <debug.h>
#include <winerror.h>
#include <winnlsp.h>
#include <docobj.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <ccstock.h>
#include <crtfree.h>
#include <regstr.h>
#include <vdate.h>
#include <setupapi.h>


// A "fake" variants for use on the stack - usable for [in] parameters only!!!
typedef struct _SA_BSTRGUID {
    UINT  cb;
    WCHAR wsz[39];
} SA_BSTRGUID;
#define InitFakeBSTR(pSA_BSTR, guid) SHStringFromGUIDW((guid), (pSA_BSTR)->wsz, ARRAYSIZE((pSA_BSTR)->wsz)), (pSA_BSTR)->cb = (38*sizeof(WCHAR))


#ifdef TRY_NtPowerInformation
//
//  We would like to include <ntpoapi.h>, but ntpoapi.h redefines things
//  in a manner incompatible with <winnt.h>...  It also relies on <nt.h>,
//  which also redefines things in a manner incompatible with <winnt.h>.
//  So we have to fake its brains out.  Yuck.
//
typedef LONG NTSTATUS;
#undef ES_SYSTEM_REQUIRED
#undef ES_DISPLAY_REQUIRED
#undef ES_USER_PRESENT
#undef ES_CONTINUOUS
#define LT_DONT_CARE        NTPOAPI_LT_DONT_CARE
#define LT_LOWEST_LATENCY   NTPOAPI_LT_LOWEST_LATENCY
#define LATENCY_TIME        NTPOAPI_LATENCY_TIME
#if defined(_M_IX86)
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif

#include <ntpoapi.h>
#endif

// ---------------------------------------------------------------------------
//
// Local includes
//

#include "thunk.h"


//
// Wrappers so our Unicode calls work on Win95
//

#define lstrcmpW            StrCmpW
#define lstrcmpiW           StrCmpIW
#define lstrcatW            StrCatW
#define lstrcpyW            StrCpyW
#define lstrcpynW           StrCpyNW

#define CharLowerW          CharLowerWrapW
#define CharNextW           CharNextWrapW
#define CharPrevW           CharPrevWrapW

//
// This is a very important piece of performance hack for non-DBCS codepage.
//
#ifdef UNICODE
// NB - These are already macros in Win32 land.
#ifdef WIN32
#undef AnsiNext
#undef AnsiPrev
#endif

#define AnsiNext(x) ((x)+1)
#define AnsiPrev(y,x) ((x)-1)
#define IsDBCSLeadByte(x) ((x), FALSE)
#endif // DBCS

#define CH_PREFIX TEXT('&')

//
// Trace/dump/break flags specific to shell32.
//   (Standard flags defined in debug.h)
//

// Trace flags
#define TF_IDLIST           0x00000010      // IDList stuff
#define TF_PATH             0x00000020      // path stuff
#define TF_URL              0x00000040      // URL stuff
#define TF_REGINST          0x00000080      // REGINST stuff
#define TF_RIFUNC           0x00000100      // REGINST func tracing
#define TF_REGQINST         0x00000200      // RegQueryInstall tracing
#define TF_DBLIST           0x00000400      // SHDataBlockList tracing

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

// -1 means use CP_ACP, but do *not* verify
// kind of a hack, but it's DEBUG and leaves 99% of callers unchanged
#define CP_ACPNOVALIDATE    ((UINT)-1)

//
// Global variables
//
EXTERN_C HINSTANCE g_hinst;

#define HINST_THISDLL   g_hinst


EXTERN_C BOOL g_bRunningOnNT;
EXTERN_C BOOL g_bRunningOnNT5OrHigher;
EXTERN_C BOOL g_bRunningOnMemphis;

// Icon mirroring
EXTERN_C HDC g_hdc;
EXTERN_C HDC g_hdcMask;
EXTERN_C BOOL g_bMirroredOS;
EXTERN_C DWORD g_tlsThreadRef;
EXTERN_C DWORD g_tlsOtherThreadsRef;


EXTERN_C int DrawTextFLW(HDC hdc, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat);
EXTERN_C int DrawTextExFLW(HDC hdc, LPWSTR pwzText, int cchText, LPRECT lprc, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams);
EXTERN_C BOOL GetTextExtentPointFLW(HDC hdc, LPCWSTR lpString, int nCount, LPSIZE lpSize);
EXTERN_C int ExtTextOutFLW(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect, LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp);

#undef ExpandEnvironmentStrings
#define ExpandEnvironmentStrings #error "Use SHExpandEnvironmentStrings instead"

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\palette.h ===
#include <platform.h>

typedef struct
{
    WORD            wVer;
    WORD            wCnt;
    PALETTEENTRY    ape[256];
} LOGPAL256;

const LOGPAL256 g_lpHalftone =
{
    0x0300, 256,
    {
        PALETTE_ENTRY( 0x00, 0x00, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x80, 0x00, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x00, 0x80, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x80, 0x80, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x00, 0x00, 0x80, 0x00 ),
        PALETTE_ENTRY( 0x80, 0x00, 0x80, 0x00 ),
        PALETTE_ENTRY( 0x00, 0x80, 0x80, 0x00 ),
        PALETTE_ENTRY( 0xC0, 0xC0, 0xC0, 0x00 ),
        PALETTE_ENTRY( 0xC0, 0xDC, 0xC0, 0x00 ),
        PALETTE_ENTRY( 0xA6, 0xCA, 0xF0, 0x00 ),
        PALETTE_ENTRY( 0x99, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xEF, 0xD6, 0xC6, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xAD, 0xA9, 0x90, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x00, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xFF, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0x33, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x00, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0x66, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x00, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0x99, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x00, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0xCC, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xA5, 0x00, 0x21, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xD6, 0x00, 0x93, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x50, 0x50, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x33, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x33, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x33, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x33, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x33, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x66, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x99, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x00, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xCC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0xFF, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0xFF, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0xFF, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xFF, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0x7C, 0x80, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x04, 0x04, 0x04, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x08, 0x08, 0x08, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x0C, 0x0C, 0x0C, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x11, 0x11, 0x11, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x16, 0x16, 0x16, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x1C, 0x1C, 0x1C, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x22, 0x22, 0x22, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x29, 0x29, 0x29, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x39, 0x39, 0x39, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x42, 0x42, 0x42, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x4D, 0x4D, 0x4D, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x55, 0x55, 0x55, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x5F, 0x5F, 0x5F, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x77, 0x77, 0x77, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x86, 0x86, 0x86, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x96, 0x96, 0x96, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xB2, 0xB2, 0xB2, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCB, 0xCB, 0xCB, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xD7, 0xD7, 0xD7, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xDD, 0xDD, 0xDD, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xE3, 0xE3, 0xE3, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xEA, 0xEA, 0xEA, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xF1, 0xF1, 0xF1, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xF8, 0xF8, 0xF8, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xE7, 0xE7, 0xD6, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0xEC, 0xFF, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x33, 0x00, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x66, 0x00, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0x99, 0x00, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xCC, 0x00, 0x00, PC_NOCOLLAPSE ),
        PALETTE_ENTRY( 0xFF, 0xFB, 0xF0, 0x00 ),
        PALETTE_ENTRY( 0xA0, 0xA0, 0xA4, 0x00 ),
        PALETTE_ENTRY( 0x80, 0x80, 0x80, 0x00 ),
        PALETTE_ENTRY( 0xFF, 0x00, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x00, 0xFF, 0x00, 0x00 ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0x00, 0x00 ),
        PALETTE_ENTRY( 0x00, 0x00, 0xFF, 0x00 ),
        PALETTE_ENTRY( 0xFF, 0x00, 0xFF, 0x00 ),
        PALETTE_ENTRY( 0x00, 0xFF, 0xFF, 0x00 ),
        PALETTE_ENTRY( 0xFF, 0xFF, 0xFF, 0x00 ),
    }
};

const BYTE g_abWin95CMAP[32768] = {
  0, 11, 11, 12, 60, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 11, 11, 12, 13, 60, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 11, 12, 13, 13, 14, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 12, 13, 13, 14, 14, 66, 66, 66, 66, 66,101,101,101,101,101,  4,  4,166,166,
166,166,166,199,199,199,199,199,199,199,252,252,252,
 33, 33, 14, 14, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,252,252,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,199,252,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,199,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,199,205,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,205,205,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,  6,  6,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,  6,  6,  6,  6,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 72, 72, 72, 72, 72, 72,107,107,107,  6,  6,  6,  6,  6,  6,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 78, 78, 78, 78, 78, 78,112,112,112,  6,  6,  6,  6,  6,  6,
129,129,129,178,178,178,178,178,178,178,211,211,211,
  2,  2,  2, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,  6,  6,  6,  6,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,  6,  6,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
250,250,250,250, 84, 84, 84, 84, 84,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250,250, 84, 84, 84,123,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250,250,250, 90,123,123,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
 11, 11, 12, 13, 60, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 11, 12, 13, 13, 14, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 12, 13, 13, 14, 14, 15, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 13, 13, 14, 14, 15, 15, 66, 66, 66, 66,101,101,101,101,101,  4,  4,166,166,
166,166,166,199,199,199,199,199,199,199,252,252,252,
 33, 14, 14, 15, 15, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,252,252,
 33, 33, 15, 15, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,200,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,200,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,200,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,199,205,205,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,  6,  6,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,  6,  6,  6,  6,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 72, 72, 72, 72, 72, 72,107,107,107,  6,  6,  6,  6,  6,  6,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 78, 78, 78, 78, 78, 78,112,112,112,  6,  6,  6,  6,  6,  6,
129,129,129,178,178,178,178,178,178,178,211,211,211,
  2,  2,  2, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,  6,  6,  6,  6,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,  6,  6,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
250,250,250,250, 84, 84, 84, 84, 84,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250,250, 90, 90, 90,123,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250,250, 90, 90, 90,123,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
 11, 12, 13, 13, 14, 60, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 12, 13, 13, 14, 14, 15, 60, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 13, 13, 14, 14, 15, 15, 15, 60, 60, 60, 95, 95, 95, 95,  4,  4,  4,  4,133,
133,133,133,161,161,161,161,161,161,161,252,252,252,
 13, 14, 14, 15, 15, 15, 16, 16, 66, 66,101,101,101,101,101,  4,  4,166,166,
166,166,166,199,199,199,199,199,199,199,252,252,252,
 14, 14, 15, 15, 15, 16, 16, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,200,200,200,
 33, 15, 15, 15, 16, 16, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,200,200,200,
 33, 33, 15, 16, 16, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,200,200,200,
 33, 33, 33, 16, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,200,200,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,200,200,200,
 33, 33, 33, 66, 66, 66, 66, 66, 66, 66,101,101,101,101,101,101,166,166,166,
166,166,166,199,199,199,199,199,199,199,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,107,138,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
 39, 39, 39, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,107,  6,  6,138,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2, 72, 72, 72, 72, 72, 72, 72,107,107,107,107,  6,  6,  6,  6,138,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 72, 72, 72, 72, 72, 72,107,107,107,  6,  6,  6,  6,  6,  6,
138,138,138,172,172,172,172,172,172,172,205,205,205,
  2,  2,  2,  2, 78, 78, 78, 78, 78, 78,112,112,112,  6,  6,  6,  6,  6,  6,
129,129,129,178,178,178,178,178,178,178,211,211,211,
  2,  2,  2, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,  6,  6,  6,  6,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,  6,  6,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 45, 45, 45, 78, 78, 78, 78, 78, 78, 78,112,112,112,112,112,112,129,129,129,
129,129,129,178,178,178,178,178,178,178,211,211,211,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
 51, 51, 51, 84, 84, 84, 84, 84, 84, 84,118,118,118,118,118,118,149,149,149,
149,149,149,184,184,184,184,184,184,184,217,217,217,
250,250,250,250, 90, 90, 90, 90, 90,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250, 90, 90, 90, 90, 90,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
250,250,250,250, 90, 90, 90, 90, 90,123,123,123,123,123,123,123,155,155,155,
155,155,155,190,190,190,190,190,190,190,254,254,254,
 12, 13, 13, 14, 14, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96,  4,  4,162,162,
162,162,162,196,196,196,196,196,196,196,252,252,252,
 13, 13, 14, 14, 15, 15, 61, 61, 61, 61, 96, 96, 96, 96, 96,  4,  4,162,162,
162,162,162,196,196,196,196,196,196,196,252,252,252,
 13, 14, 14, 15, 15, 15, 16, 16, 61, 61, 96, 96, 96, 96, 96,  4,  4,162,162,
162,162,162,196,196,196,196,196,196,196,252,252,252,
 14, 14, 15, 15, 15, 16, 16, 17, 17, 17,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 14, 15, 15, 15, 16, 16, 17, 17, 17, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 15, 15, 16, 16, 17, 17, 17, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 16, 17, 17, 17, 67, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 17, 17, 17, 67, 67, 67, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,  6,  6,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
  2,  2,  2, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,  6,  6,  6,  6,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
  2,  2,  2, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,  6,  6,  6,  6,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,  6,  6,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
250,250,250, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
250,250,250, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
250,250,250, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 14, 14, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,252,252,
 29, 14, 14, 15, 15, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,252,252,
 14, 14, 15, 15, 15, 16, 16, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,200,200,200,
 14, 15, 15, 15, 16, 16, 17, 17, 17, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 15, 15, 16, 16, 17, 17, 17, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 16, 17, 17, 17, 67, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 17, 17, 17, 67, 67, 67, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
250,250, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
250,250, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,196,252,
 29, 29, 15, 15, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,200,200,
 29, 15, 15, 15, 16, 16, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,200,200,200,
 34, 15, 15, 16, 16, 17, 17, 17, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 16, 17, 17, 17, 67, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 17, 17, 17, 67, 67, 67, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 21, 21, 21, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 20,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 52, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
250, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,196,200,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,200,200,
 29, 29, 15, 16, 16, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,200,200,200,
 34, 34, 16, 16, 17, 17, 17, 67, 67, 67,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 16, 17, 17, 17, 67, 67, 67, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 21, 21, 21, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 21, 21, 21, 20, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 73, 73, 20, 20,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 52, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,196,197,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,200,200,
 29, 29, 29, 16, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,200,200,200,
 34, 34, 16, 17, 17, 17, 67, 67, 67, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 21, 21, 21, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 21, 21, 21, 20, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 21, 21, 20, 20, 20, 20, 19, 19,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 73, 20, 20, 19, 19,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 19,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 52, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 57, 90, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,197,197,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,196,197,197,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,200,200,200,
 34, 34, 34, 17, 17, 67, 67, 67, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 21, 21, 21, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 21, 21, 21, 20, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 21, 21, 20, 20, 20, 20, 19, 19,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 21, 20, 20, 20, 20, 19, 19, 19, 18, 18,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 73, 20, 20, 19, 19, 19, 18, 18,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 19, 19, 18, 18,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 18, 18,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 18,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 73,108,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 57, 57, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 57, 57, 90, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,197,197,197,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,197,197,197,
 29, 29, 29, 61, 61, 61, 61, 61, 61, 61, 96, 96, 96, 96, 96, 96,162,162,162,
162,162,162,196,196,196,196,196,196,196,197,197,197,
 34, 34, 34, 17, 67, 67, 67, 21, 21, 21,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 67, 21, 21, 21, 20,102,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 67, 21, 21, 21, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 67, 21, 21, 21, 20, 20, 20, 20,102,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 21, 21, 20, 20, 20, 20, 19, 19,102,102,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 21, 20, 20, 20, 20, 19, 19, 19, 18, 18,102,102,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 34, 34, 34, 21, 20, 20, 20, 20, 19, 19, 19, 18, 18, 18, 18,234,134,134,134,
134,134,134,167,167,167,167,167,167,167,200,200,200,
 40, 40, 40, 73, 73, 20, 20, 19, 19, 19, 18, 18, 18, 18,234,234,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 19, 19, 18, 18, 18, 18,234,234,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 18, 18, 18, 18,234,234,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 18, 18, 18,234,234,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73, 18,234,234,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 40, 40, 40, 73, 73, 73, 73, 73, 73,234,234,108,108,108,108,108,139,139,139,
139,139,139,173,173,173,173,173,173,173,206,206,206,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 46, 46, 46, 79, 79, 79, 79, 79, 79, 79,113,113,113,113,113,113,144,144,144,
144,144,144,179,179,179,179,179,179,179,212,212,212,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 52, 52, 52, 85, 85, 85, 85, 85, 85, 85,119,119,119,119,119,119,150,150,150,
150,150,150,185,185,185,185,185,185,185,218,218,218,
 57, 57, 57, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 57, 57, 57, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 57, 57, 57, 90, 90, 90, 90, 90, 90, 90,124,124,124,124,124,124,156,156,156,
156,156,156,191,191,191,191,191,191,191,223,223,223,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 20,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 20, 20,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 20, 20, 19, 19,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 20, 20, 19, 19, 19, 18, 18,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 20, 20, 19, 19, 19, 18, 18, 18, 18,234,234,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 19, 19, 18, 18, 18, 18,234,234,234,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 18, 18, 18, 18,234,234,234,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 18, 18, 18,234,234,234,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 18,234,234,234,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,234,109,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 19,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 19, 19, 18, 18,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 19, 19, 18, 18, 18, 18,234,234,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 74, 18, 18, 18, 18,234,234,234,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 18, 18, 18,234,234,234,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 18,234,234,234,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,234,109,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,109,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,235,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97, 97,135,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 18, 18,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 18, 18, 18, 18,234,234,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 74, 18, 18, 18,234,234,234,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 18,234,234,234,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,234,109,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,109,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,235,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,235,235,235,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97,  5,  5,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97,  5,  5,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 30, 30, 30, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97, 97,  5,  5,135,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 18,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 18, 18, 18,234,234,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 18,234,234,234,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,234,109,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,109,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,235,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3, 74, 74, 74, 74, 74, 74, 74,109,109,235,235,235,235,235,248,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3, 80, 80, 80, 80, 80, 80, 80,114,114,114,235,235,235,248,248,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,248,248,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
  1,  1,  1, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97,  5,  5,  5,  5,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
  1,  1,  1, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97,  5,  5,  5,  5,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
  1,  1,  1, 62, 62, 62, 62, 62, 62, 62, 97, 97, 97, 97,  5,  5,  5,  5,135,
135,135,135,163,163,163,163,163,163,163,197,197,197,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,  5,  5,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 18,234,234,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,234,109,109,109,109,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,109,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,235,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3, 74, 74, 74, 74, 74, 74, 74,109,109,235,235,235,235,235,248,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3,  3, 74, 74, 74, 74, 74, 74,109,235,235,235,235,235,248,248,248,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3,  3, 80, 80, 80, 80, 80, 80,114,114,235,235,235,248,248,248,236,
145,145,145,180,180,180,180,180,180,180,213,213,213,
  3,  3,  3, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,248,248,248,236,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,248,236,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
  1,  1,  1,  1, 62, 62, 62, 62, 62, 62, 97, 97, 97,  5,  5,  5,  5,  5,  5,
135,135,135,163,163,163,163,163,163,163,197,197,197,
  1,  1,  1,  1, 62, 62, 62, 62, 62, 62, 97, 97, 97,  5,  5,  5,  5,  5,  5,
135,135,135,163,163,163,163,163,163,163,197,197,197,
  1,  1,  1,  1, 62, 62, 62, 62, 62, 62, 97, 97, 97,  5,  5,  5,  5,  5,  5,
135,135,135,163,163,163,163,163,163,163,197,197,197,
  1,  1,  1, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,  5,  5,  5,  5,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68, 68,103,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 35, 35, 35, 68, 68, 68, 68, 68, 68,234,234,103,103,103,103,103,140,140,140,
140,140,140,168,168,168,168,168,168,168,201,201,201,
 41, 41, 41, 74, 74, 74, 74, 74, 74,234,234,109,109,109,109,235,174,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,109,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
 41, 41, 41, 74, 74, 74, 74, 74, 74, 74,109,109,109,235,235,235,235,174,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3, 74, 74, 74, 74, 74, 74, 74,109,109,235,235,235,235,235,248,174,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3,  3, 74, 74, 74, 74, 74, 74,109,235,235,235,235,235,248,248,248,
174,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3,  3, 74, 74, 74, 74, 74, 74,235,235,235,235,235,248,248,248,236,
236,174,174,207,207,207,207,207,207,207,230,230,230,
  3,  3,  3,  3, 80, 80, 80, 80, 80, 80,114,235,235,235,248,248,248,236,236,
236,236,145,180,180,180,180,180,180,180,213,213,213,
  3,  3,  3,  3, 80, 80, 80, 80, 80, 80,114,114,114,248,248,248,236,236,236,
236,145,145,180,180,180,180,180,180,180,213,213,213,
  3,  3,  3, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,248,236,236,236,236,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,236,236,236,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,236,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 47, 47, 47, 80, 80, 80, 80, 80, 80, 80,114,114,114,114,114,114,145,145,145,
145,145,145,180,180,180,180,180,180,180,213,213,213,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 53, 53, 53, 86, 86, 86, 86, 86, 86, 86,151,151,151,151,151,151,157,157,157,
157,157,157,186,186,186,186,186,186,186,219,219,219,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
 57, 57, 57, 91, 91, 91, 91, 91, 91, 91,228,228,228,228,228,228,192,192,192,
192,192,192,224,224,224,224,224,224,224,232,232,232,
  1,  1,  1,  1, 63, 63, 63, 63, 63, 63, 98, 98, 98,  5,  5,  5,  5,  5,  5,
131,131,131,164,164,164,164,164,164,164,198,198,198,
  1,  1,  1,  1, 63, 63, 63, 63, 63, 63, 98, 98, 98,  5,  5,  5,  5,  5,  5,
131,131,131,164,164,164,164,164,164,164,198,198,198,
  1,  1,  1,  1, 63, 63, 63, 63, 63, 63, 98, 98, 98,  5,  5,  5,  5,  5,  5,
131,131,131,164,164,164,164,164,164,164,198,198,198,
  1,  1,  1, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,  5,  5,  5,  5,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,235,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,235,235,235,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3, 75, 75, 75, 75, 75, 75, 75,110,110,110,235,235,235,248,248,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3,  3, 75, 75, 75, 75, 75, 75,110,110,235,235,235,248,248,248,236,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3,  3, 75, 75, 75, 75, 75, 75,110,235,235,235,248,248,248,236,236,
236,236,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3,  3, 81, 81, 81, 81, 81, 81,115,115,235,248,248,248,236,236,236,
236,237,237,181,181,181,181,181,181,181,214,214,214,
  3,  3,  3,  3, 81, 81, 81, 81, 81, 81,115,115,115,248,248,236,236,236,236,
237,237,237,181,181,181,181,181,181,181,214,214,214,
  3,  3,  3, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,236,236,236,236,237,
237,237,237,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,236,237,237,
237,237,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,237,237,237,
237,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
  1,  1,  1,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98,  5,  5,  5,  5,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
  1,  1,  1,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98,  5,  5,  5,  5,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
  1,  1,  1,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98,  5,  5,  5,  5,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,  5,  5,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,248,248,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,248,248,248,236,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3,  3, 75, 75, 75, 75, 75, 75,110,110,110,248,248,248,236,236,236,
236,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3,  3, 81, 81, 81, 81, 81, 81,115,115,115,248,248,236,236,236,236,
237,237,237,181,181,181,181,181,181,181,214,214,214,
  3,  3,  3, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,236,236,236,236,237,
237,237,237,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,236,237,237,
237,237,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,237,237,237,
237,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,146,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 31, 31, 31,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98,  5,  5,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31, 31,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98,  5,  5,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31, 31,233, 63, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98,  5,  5,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,248,236,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,248,236,236,236,236,
141,141,141,175,175,175,175,175,175,175,208,208,208,
  3,  3,  3, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,236,236,236,236,237,
237,237,237,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,236,237,237,
237,237,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,237,237,237,
237,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,146,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115, 28,146,146,
146,146,146,239,181,181,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120, 28, 28,152,
152,152,239,239,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 31, 31,233,233,233, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31,233,233,233, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31,233,233,233, 63, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 36, 36, 36,233, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,236,236,236,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,236,237,237,
237,237,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,237,237,237,
237,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,146,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115, 28,146,146,
146,146,146,239,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28, 28,
146,146,239,239,239,181,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120, 28, 28, 28, 28, 
28,239,239,239,239,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,239,239,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 31, 31,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31, 31,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 36, 36,233,233,233, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,236,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,236,237,237,237,
237,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,146,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115, 28, 28,146,
146,146,146,239,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28, 28, 
28,146,239,239,239,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28, 28, 
28,239,239,239,239,181,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120, 28, 28, 28, 28, 
28,239,239,239,239,239,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120, 28, 28, 28,152,
152,239,239,239,239,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,239,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,187,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,  8,187,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,  8,  8,187,187,187,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 31,233,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31,233,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 31,233,233,233,233,233, 63, 63, 63, 63, 98, 98, 98, 98, 98, 98,131,131,131,
131,131,131,164,164,164,164,164,164,164,198,198,198,
 36, 36,233,233,233, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 36, 36, 36, 69, 69, 69, 69, 69, 69, 69,104,104,104,104,104,104,130,130,130,
130,130,130,169,169,169,169,169,169,169,202,202,202,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 42, 42, 42, 75, 75, 75, 75, 75, 75, 75,110,110,110,110,110,110,141,141,141,
141,141,141,175,175,175,175,175,175,175,208,208,208,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,237,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115,115,237,237,146,
146,146,146,181,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28,146,
146,146,146,239,181,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28, 28, 
28,146,239,239,239,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115,115, 28, 28, 28, 28, 
28, 28,239,239,239,181,181,181,181,181,214,214,214,
 48, 48, 48, 81, 81, 81, 81, 81, 81, 81,115,115,115,115, 28, 28, 28, 28, 28, 
28,239,239,239,239,239,181,181,181,181,214,214,214,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120, 28, 28, 28, 28, 28, 
28,239,239,239,239,239,  7,  7,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120, 28, 28, 28, 28, 
28,239,239,239,239,  7,  7,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,239,239,  7,  7,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,  7,  7,187,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,152,  8,  8,  8,187,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,  8,  8,  8,  8,  8,187,187,187,220,220,220,
 54, 54, 54, 87, 87, 87, 87, 87, 87, 87,120,120,120,120,120,120,152,152,152,
152,152,  8,  8,  8,  8,  8,  8,187,187,220,220,220,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,  8,  8,  8,  8,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 58, 58, 58, 92, 92, 92, 92, 92, 92, 92,125,125,125,125,125,125,158,158,158,
158,158,158,193,193,193,193,193,193,193,225,225,225,
 32,233,233,233,233,233, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32,233,233,233,233,233, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32,233,233,233,233,233, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 37, 37,233,233,233,233, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116, 28, 28,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116, 28, 28, 28, 28,
147,147,239,239,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116, 28, 28, 28, 28, 
28, 28,239,239,239,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116, 28, 28, 28, 28, 28, 
28,239,239,239,239,239,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116, 28, 28, 28, 28, 28, 
28,239,239,239,239,239,  7,  7,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121, 28, 28, 28, 28, 28, 
28,239,239,239,239,  7,  7,  7,  7,  7,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121, 28, 28, 28, 28, 
28,239,239,239,  7,  7,  7,  7,  7,238,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121, 28, 28,153,
153,239,239,  7,  7,  7,  7,  7,238,238,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,  7,238,238,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,  8,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,  8,  8,  8,  8,  8,  8,  8,  8,188, 25, 25, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,  8,  8,  8,  8,  8,  8,  8,  8, 25, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,  8,  8,  8,  8,  8,  8,  8, 25, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,  8,  8,  8,194,194,194,194, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194,226,226,226,
 32, 32, 32,233, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32,233, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32,233, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116, 28, 28,147,
147,147,239,239,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116, 28, 28, 28, 28,
147,239,239,239,239,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116, 28, 28, 28, 28, 
28,239,239,239,239,  7,  7,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121, 28, 28, 28, 28, 
28,239,239,239,  7,  7,  7,  7,  7,238,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121, 28, 28, 28,153,
153,239,239,  7,  7,  7,  7,  7,238,238,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,  7,238,238,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,238,238,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,188,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,  8,188,240, 25, 25, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,  8,  8,  8,  8,  8,  8,  8,  8, 25, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,  8,  8,  8,  8,  8,  8,194, 25, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,  8,  8,194,194,194,194,194, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194,226,226,226,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99,132,132,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,239,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116, 28, 28,147,
147,147,239,239,  7,  7,182,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121, 28, 28, 28,153,
153,239,239,  7,  7,  7,  7,  7,238,238,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,  7,238,238,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,238,238,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,  7,238,238,188,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,188,188,188,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,188,240,240, 25, 25, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,  8,240,240, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,  8,  8,  8,  8,  8,194,194, 25, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,  8,194,194,194,194,194,194, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194,226,226,226,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99, 24, 24,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99, 24, 24,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 99, 24, 24,132,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,  7,  7,182,182,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,  7,238,238,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,238,238,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,  7,238,238,188,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,238,238,188,188,188,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  8,  8,188,188,188,240,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,188,240,240,240,241, 25, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,  8,240,240,241, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,  8,  8,  8,194,194,241,241, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194,226,226,226,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24,
132,132,132,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105, 24,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,  7,182,182,182,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  7,  7,  7,  7,238,238,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,  7,238,238,188,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,238,238,188,188,188,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,238,238,188,188,188,240,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  8,188,188,188,240,240,240,241,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  8,  8,188,240,240,240,241,241, 25, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,  8,  8,  8,  8,240,240,241,241,242, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,  8,  8,194,194,241,241,242,242, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,242, 25, 25, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,194,226,226,226,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24,132,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24,132,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105, 24, 24,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 23,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,  7,238,238,188,188,188,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7,238,238,188,188,188,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,238,238,188,188,188,240,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26,188,188,188,240,240,240,241,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26, 26, 26,240,240,240,241,241,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26, 26, 26,240,240,241,241,242,242, 25,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26, 26, 27, 27,241,241,242,242,243, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159, 26, 27, 27, 27, 27,242,242,243,243, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194, 27, 27,243,243,243, 25,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194,194,194,194,243,243,226,226,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24, 24,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24, 24,165,165,165,165,165,165,165,128,128,128,
 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 99, 99, 99, 99, 99, 24, 24, 24, 24, 
24, 24, 24,165,165,165,165,165,165,165,128,128,128,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105, 24, 24, 24, 24, 
24,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 70,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 70, 23,105,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 70, 23, 23, 23,105,105,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 37, 37, 37, 70, 70, 70, 70, 23, 23, 23, 23, 23, 23,105,105,105,136,136,136,
136,136,136,170,170,170,170,170,170,170,203,203,203,
 43, 43, 43, 76, 76, 76, 76, 76, 23, 23, 23, 23,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 23, 23,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 23,111,111,111,111,111,111,142,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111,111, 22, 22,142,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111, 22, 22, 22, 22,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 43, 43, 43, 76, 76, 76, 76, 76, 76, 76,111,111,111,111, 22, 22, 22, 22,142,
142,142,142,176,176,176,176,176,176,176,209,209,209,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116, 22, 22, 22, 22,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116, 22, 22,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 49, 49, 49, 82, 82, 82, 82, 82, 82, 82,116,116,116,116,116,116,147,147,147,
147,147,147,182,182,182,182,182,182,182,215,215,215,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153,  7, 26,238,188,188,188,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26, 26, 26,188,188,240,240,221,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153,153, 26, 26, 26, 26,240,240,240,241,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153, 26, 26, 26, 26, 26,240,240,241,241,221,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153, 26, 26, 26, 26, 26,240,241,241,242,242,221,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153, 26, 26, 26, 26, 26,241,241,242,242,243,243,
 55, 55, 55, 88, 88, 88, 88, 88, 88, 88,121,121,121,121,121,121,153,153,153,
153,153, 26, 26, 26, 26, 27, 27,242,242,243,243,243,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159, 26, 26, 26, 27, 27, 27, 27,243,243,243,244,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194, 27, 27, 27, 27, 27,243,243,244,244,
 59, 59, 59, 93, 93, 93, 93, 93, 93, 93,126,126,126,126,126,126,159,159,159,
159,159,159,194,194,194, 27, 27, 27,243,244,244,244,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100, 24,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100, 24,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100, 24,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 23,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 23, 23, 23, 23,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 23, 23, 23, 23, 23, 23,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23, 23,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 23,227,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227,227, 22, 22,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227, 22, 22, 22, 22,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227, 22, 22, 22, 22, 22, 22,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117, 22, 22, 22, 22, 22, 22,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117, 22, 22,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26, 26,189,189,241,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26, 26, 26,241,241,242,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154, 26, 26, 26, 26, 26, 26,241,242,242,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154, 26, 26, 26, 26, 26, 27,242,242,243,243,243,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154, 26, 26, 26, 26, 27, 27, 27,243,243,243,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160, 26, 26, 27, 27, 27, 27,243,243,244,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195, 27, 27, 27, 27,243,244,244,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195, 27,244,244,244,245,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 23,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 23, 23, 23, 23,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 23, 23, 23, 23, 23, 23,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23, 23,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 23,227,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227,227, 22, 22,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227, 22, 22, 22, 22,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227, 22, 22, 22, 22, 22, 22,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117, 22, 22, 22, 22, 22, 22,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117, 22, 22,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26, 26, 26,189,242,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154, 26, 26, 26, 26, 26, 26, 27,243,243,243,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154, 26, 26, 26, 26, 26, 27, 27,243,243,244,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160, 26, 26, 26, 27, 27, 27,243,244,244,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195, 27,244,244,244,245,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195,195,244,244,245,245,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
249,249,249, 65, 65, 65, 65, 65, 65, 65,100,100,100,100,100,100,137,137,137,
137,137,137,127,127,127,127,127,127,127,253,253,253,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 71,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 71, 23,106,106,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 71, 23, 23, 23, 23,106,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 38, 38, 38, 71, 71, 71, 71, 23, 23, 23, 23, 23, 23,106,106,106,143,143,143,
143,143,143,171,171,171,171,171,171,171,204,204,204,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23, 23,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 23, 23, 23,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 23,227,227,227,227,227,227,177,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227,227, 22, 22,177,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227,227, 22, 22, 22, 22,177,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 44, 44, 44, 77, 77, 77, 77, 77, 77, 77,227,227,227, 22, 22, 22, 22, 22, 22,
177,177,177,210,210,210,210,210,210,210,231,231,231,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117, 22, 22, 22, 22, 22, 22,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117, 22, 22,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 50, 50, 50, 83, 83, 83, 83, 83, 83, 83,117,117,117,117,117,117,148,148,148,
148,148,148,183,183,183,183,183,183,183,216,216,216,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154,189,189,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26,189,189,189,189,189,222,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26, 26,189,189,243,243,222,222,
 56, 56, 56, 89, 89, 89, 89, 89, 89, 89,122,122,122,122,122,122,154,154,154,
154,154,154, 26, 26, 26, 26, 27, 27,243,244,244,244,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195, 27,244,244,244,245,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195,195,244,244,245,245,
251,251,251, 94, 94, 94, 94, 94, 94, 94,229,229,229,229,229,229,160,160,160,
160,160,160,195,195,195,195,195,195,244,245,245,255,
};

const BYTE g_abWin95ToNT4[256] ={
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,216,217,218,219,220,221,
222,223,227,226,225,224,215,186,182,241, 31,240, 32,242,243,244,
245, 66,187, 36, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
 22, 23, 24, 25, 26, 27, 28, 29, 30, 33, 34, 35, 37, 38, 39, 40,
 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
 57, 58, 59, 60, 61, 62, 63, 64, 65, 67, 68, 69, 70, 71, 72, 73,
 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
 91, 92, 93, 94, 95, 96, 97, 98,100,101,102,103,104,106,107,150,
185,127,118,112,113,109,116,111,119,114,121,122,117,124,125,120,
128,129,130,131,132,133,134, 99,136,137,138,139,140,135,142,143,
144,145,110,147,148,149,115,152,153,154,155,156,157,158,123,160,
161,126,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
141,178,179,180,146,183,184,151,188,189,190,191,192,193,194,159,
196,197,162,199,200,201,202,203,204,205,206,207,208,209,210,211,
177,213,214, 90,105,108,195,198,212,181,228,229,230,231,233,232,
234,235,236,237,238,239,246,247,248,249,250,251,252,253,254,255,
};

const BYTE g_abWin95ToNT5[256] ={
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  0, 14, 14, 14, 15,
 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 11, 30, 31,
 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 10, 12, 62, 63,
 64, 65, 13, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
 96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\ole2dup.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: ole2dup.c
//
//  This file contains all the duplicated code from OLE 2.0 DLLs to avoid
// any link to their DLLs from the shell. If we decided to have links to
// them, we need to delete these files.
//
// History:
//  04-16-97 AndyP      moved parts to shlwapi (from shell32)
//  12-29-92 SatoNa     Created.
//
//---------------------------------------------------------------------------

#include "priv.h"

//
// SHStringFromGUIDA
//
// converts GUID into (...) form without leading identifier; returns
// amount of data copied to lpsz if successful; 0 if buffer too small.
//

// An endian-dependant map of what bytes go where in the GUID
// text representation.
//
// Do NOT use the TEXT() macro in GuidMap... they're intended to be bytes
//

static const BYTE c_rgbGuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                     8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const CHAR c_szDigitsA[] = "0123456789ABCDEF";
static const WCHAR c_szDigitsW[] = TEXTW("0123456789ABCDEF");

STDAPI_(int) 
SHStringFromGUIDA(
    UNALIGNED REFGUID rguid, 
    LPSTR   psz, 
    int     cchMax)
{
    int i;
    const BYTE * pBytes = (const BYTE *) rguid;

    if (cchMax < GUIDSTR_MAX)
        return 0;

#ifdef BIG_ENDIAN
    // This is the slow, but portable version
    wnsprintf(psz, cchMax,"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            rguid->Data1, rguid->Data2, rguid->Data3,
            rguid->Data4[0], rguid->Data4[1],
            rguid->Data4[2], rguid->Data4[3],
            rguid->Data4[4], rguid->Data4[5],
            rguid->Data4[6], rguid->Data4[7]);
#else
    // The following algorithm is faster than the wsprintf.
    *psz++ = '{';

    for (i = 0; i < SIZEOF(c_rgbGuidMap); i++)
    {
        if (c_rgbGuidMap[i] == '-')      // don't TEXT() this line
        {
            *psz++ = '-';
        }
        else
        {
            // Convert a byte-value into a character representation
            *psz++ = c_szDigitsA[ (pBytes[c_rgbGuidMap[i]] & 0xF0) >> 4 ];
            *psz++ = c_szDigitsA[ (pBytes[c_rgbGuidMap[i]] & 0x0F) ];
        }
    }
    *psz++ = '}';
    *psz   = '\0';
#endif /* !BIG_ENDIAN */

    return GUIDSTR_MAX;
}


STDAPI_(int) 
SHStringFromGUIDW(
    UNALIGNED REFGUID rguid, 
    LPWSTR  psz, 
    int     cchMax)
{
    int i;
    const BYTE * pBytes = (const BYTE *) rguid;

    if (cchMax < GUIDSTR_MAX)
        return 0;

#ifdef BIG_ENDIAN
    // This is the slow, but portable version
    wnsprintfW(psz, cchMax, L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            rguid->Data1, rguid->Data2, rguid->Data3,
            rguid->Data4[0], rguid->Data4[1],
            rguid->Data4[2], rguid->Data4[3],
            rguid->Data4[4], rguid->Data4[5],
            rguid->Data4[6], rguid->Data4[7]);
#else
    // The following algorithm is faster than the wsprintf.
    *psz++ = TEXTW('{');

    for (i = 0; i < SIZEOF(c_rgbGuidMap); i++)
    {
        if (c_rgbGuidMap[i] == '-')      // don't TEXT() this line
        {
            *psz++ = TEXTW('-');
        }
        else
        {
            // Convert a byte-value into a character representation
            *psz++ = c_szDigitsW[ (pBytes[c_rgbGuidMap[i]] & 0xF0) >> 4 ];
            *psz++ = c_szDigitsW[ (pBytes[c_rgbGuidMap[i]] & 0x0F) ];
        }
    }
    *psz++ = TEXTW('}');
    *psz   = TEXTW('\0');
#endif /* !BIG_ENDIAN */

    return GUIDSTR_MAX;
}

// this makes sure the DLL for the given clsid stays in memory
// this is needed because we violate COM rules and hold apparment objects
// across the lifetime of appartment threads. these objects really need
// to be free threaded (we have always treated them as such)
//
//  Look in the registry and pull out the name of the DLL who owns
//  the CLSID.  We must pull the DLL name as unicode in case the
//  DLL name contains unicode characters.
//
STDAPI_(HINSTANCE) SHPinDllOfCLSID(const CLSID *pclsid)
{
    HKEY hk;
    DWORD dwSize;
    HINSTANCE hinst = NULL;
    TCHAR szClass[GUIDSTR_MAX + 64];    // CLSID\{...}\InProcServer32
    WCHAR szDllPath[MAX_PATH];

    lstrcpy(szClass, TEXT("CLSID\\"));
    SHStringFromGUID(pclsid, szClass+6, GUIDSTR_MAX); // 6 = strlen("CLSID\\")
    lstrcat(szClass, TEXT("\\InProcServer32"));

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szClass, 0, KEY_QUERY_VALUE, &hk)
                == ERROR_SUCCESS) {

        // Explicitly read as unicode.  SHQueryValueEx handles REG_EXPAND_SZ
        dwSize = SIZEOF(szDllPath);
        if (SHQueryValueExW(hk, 0, 0, 0, szDllPath, &dwSize) == ERROR_SUCCESS) {
            hinst = LoadLibraryExWrapW(szDllPath, NULL, 0);
        }

        RegCloseKey(hk);
    }

    return hinst;
}

// scan psz for a number of hex digits (at most 8); update psz, return
// value in Value; check for chDelim; return TRUE for success.
BOOL HexStringToDword(LPCTSTR * ppsz, DWORD * lpValue, int cDigits, TCHAR chDelim)
{
    int ich;
    LPCTSTR psz = *ppsz;
    DWORD Value = 0;
    BOOL fRet = TRUE;

    for (ich = 0; ich < cDigits; ich++)
    {
        TCHAR ch = psz[ich];
        if (InRange(ch, TEXT('0'), TEXT('9')))
        {
            Value = (Value << 4) + ch - TEXT('0');
        }
        else if ( InRange( (ch |= (TEXT('a')-TEXT('A'))), TEXT('a'), TEXT('f')) )
        {
            Value = (Value << 4) + ch - TEXT('a') + 10;
        }
        else
            return(FALSE);
    }

    if (chDelim)
    {
        fRet = (psz[ich++] == chDelim);
    }

    *lpValue = Value;
    *ppsz = psz+ich;

    return fRet;
}

// parse above format; return TRUE if succesful; always writes over *pguid.
STDAPI_(BOOL) GUIDFromString(LPCTSTR psz, GUID *pguid)
{
    DWORD dw;
    if (*psz++ != TEXT('{') /*}*/ )
        return FALSE;

    if (!HexStringToDword(&psz, &pguid->Data1, SIZEOF(DWORD)*2, TEXT('-')))
        return FALSE;

    if (!HexStringToDword(&psz, &dw, SIZEOF(WORD)*2, TEXT('-')))
        return FALSE;

    pguid->Data2 = (WORD)dw;

    if (!HexStringToDword(&psz, &dw, SIZEOF(WORD)*2, TEXT('-')))
        return FALSE;

    pguid->Data3 = (WORD)dw;

    if (!HexStringToDword(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, SIZEOF(BYTE)*2, TEXT('-')))
        return FALSE;

    pguid->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[6] = (BYTE)dw;
    if (!HexStringToDword(&psz, &dw, SIZEOF(BYTE)*2, /*(*/ TEXT('}')))
        return FALSE;

    pguid->Data4[7] = (BYTE)dw;

    return TRUE;
}

#ifdef UNICODE

LWSTDAPI_(BOOL) GUIDFromStringA(LPCSTR psz, GUID *pguid)
{
    TCHAR sz[GUIDSTR_MAX];

    SHAnsiToTChar(psz, sz, SIZECHARS(sz));
    return GUIDFromString(sz, pguid);
}

#else

LWSTDAPI_(BOOL) GUIDFromStringW(LPCWSTR psz, GUID *pguid)
{
    TCHAR sz[GUIDSTR_MAX];

    SHUnicodeToAnsi(psz, sz, SIZECHARS(sz));
    return GUIDFromString(sz, pguid);
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\privpath.h ===
#ifndef _PRIVPATH_H_
#define _PRIVPATH_H_

//
// #define all private path functions here so we dont get redefinition
// warnings when linking pathw.obj and patha.obj, who both have these
// functions.
//
#ifdef UNICODE
#define CaseConvertPathExceptDBCS CaseConvertPathExceptDBCSW
#define AnsiLowerNoDBCS AnsiLowerNoDBCSW
#define AnsiUpperNoDBCS AnsiUpperNoDBCSW
#define AnsiLowerBuffNoDBCS AnsiLowerBuffNoDBCSW
#define AnsiUpperBuffNoDBCS AnsiUpperBuffNoDBCSW
#define NextPath NextPathW
#define IsOtherDir IsOtherDirW
#define StrSlash StrSlashW
#define GetPCEnd GetPCEndW
#define PCStart PCStartW
#define NearRootFixups NearRootFixupsW
#define UnExpandEnvironmentString UnExpandEnvironmentStringW
#define IsSystemSpecialCase IsSystemSpecialCaseW
#define CharLowerBuffNoDBCS CharLowerBuffNoDBCSW
#define CharUpperBuffNoDBCS CharUpperBuffNoDBCSW
#define PathMatchSingleSpec PathMatchSingleSpecW
#else
#define CaseConvertPathExceptDBCS CaseConvertPathExceptDBCSA
#define AnsiLowerNoDBCS AnsiLowerNoDBCSA
#define AnsiUpperNoDBCS AnsiUpperNoDBCSA
#define AnsiLowerBuffNoDBCS AnsiLowerBuffNoDBCSA
#define AnsiUpperBuffNoDBCS AnsiUpperBuffNoDBCSA
#define NextPath NextPathA
#define IsOtherDir IsOtherDirA
#define StrSlash StrSlashA
#define GetPCEnd GetPCEndA
#define PCStart PCStartA
#define NearRootFixups NearRootFixupsA
#define UnExpandEnvironmentString UnExpandEnvironmentStringA
#define IsSystemSpecialCase IsSystemSpecialCaseA
#define CharLowerBuffNoDBCS CharLowerBuffNoDBCSA
#define CharUpperBuffNoDBCS CharUpperBuffNoDBCSA
#define PathMatchSingleSpec PathMatchSingleSpecA
#endif // UNICODE


#endif // _PRIVPATH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\propbag.cpp ===
#include "priv.h"
#include "varutil.h"

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"

#define MAX_PROPERTY_SIZE       2048

//  simple inline base class.
class CBasePropertyBag : public IPropertyBag, IPropertyBag2
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
    {
        static const QITAB qit[] = {
            QITABENT(CBasePropertyBag, IPropertyBag),
            QITABENT(CBasePropertyBag, IPropertyBag2),
            { 0 },
        };
        return QISearch(this, qit, riid, ppv);
    }
        
    STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&_cRef);
    }

    STDMETHODIMP_(ULONG) Release()
    {
        if (InterlockedDecrement(&_cRef))
            return _cRef;

        delete this;
        return 0;
    }

    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) PURE;
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar) PURE;

    // IPropertyBag2 (note, does not derive from IPropertyBag)
    STDMETHODIMP Read(ULONG cProperties,  PROPBAG2 *pPropBag, IErrorLog *pErrLog, VARIANT *pvarValue, HRESULT *phrError);
    STDMETHODIMP Write(ULONG cProperties, PROPBAG2 *pPropBag, VARIANT *pvarValue);
    STDMETHODIMP CountProperties(ULONG *pcProperties);
    STDMETHODIMP GetPropertyInfo(ULONG iProperty, ULONG cProperties, PROPBAG2 *pPropBag, ULONG *pcProperties);
    STDMETHODIMP LoadObject(LPCOLESTR pstrName, DWORD dwHint, IUnknown *pUnkObject, IErrorLog *pErrLog);

protected:  //  methods
    CBasePropertyBag() {}       //  DONT DELETE ME
    CBasePropertyBag(DWORD grfMode) :
        _cRef(1), _grfMode(grfMode) {}

    virtual ~CBasePropertyBag() {}  //  DONT DELETE ME
    HRESULT _CanRead(void) 
        { return STGM_WRITE != (_grfMode & (STGM_WRITE | STGM_READWRITE)) ? S_OK : E_ACCESSDENIED;}

    HRESULT _CanWrite(void) 
        { return (_grfMode & (STGM_WRITE | STGM_READWRITE)) ? S_OK : E_ACCESSDENIED;}

protected:  //  members
    LONG _cRef;
    DWORD _grfMode;
};

STDMETHODIMP CBasePropertyBag::Read(ULONG cProperties, PROPBAG2 *pPropBag, IErrorLog *pErrLog, VARIANT *pvarValue, HRESULT *phrError)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBasePropertyBag::Write(ULONG cProperties, PROPBAG2 *pPropBag, VARIANT *pvarValue)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBasePropertyBag::CountProperties(ULONG *pcProperties)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBasePropertyBag::GetPropertyInfo(ULONG iProperty, ULONG cProperties, PROPBAG2 *pPropBag, ULONG *pcProperties)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBasePropertyBag::LoadObject(LPCOLESTR pstrName, DWORD dwHint, IUnknown *pUnkObject, IErrorLog *pErrLog)
{
    return E_NOTIMPL;
}


//
// Ini file property bag implementation
//

class CIniPropertyBag : public CBasePropertyBag
{

public:
    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

protected:  //  methods
    CIniPropertyBag(DWORD grfMode) : CBasePropertyBag(grfMode) {}
    virtual ~CIniPropertyBag();
    HRESULT _Init(LPCWSTR pszFile, LPCWSTR pszSection);
    HRESULT _GetSectionAndName(LPCWSTR pszProp, LPWSTR pszSection, UINT cchSec, LPWSTR pszName, UINT cchName);

protected:  //  members
    LPWSTR _pszFile;
    LPWSTR _pszSection;

friend HRESULT SHCreatePropertyBagOnProfileSection(LPCWSTR pszFile, LPCWSTR pszSection, DWORD grfMode, REFIID riid, void **ppv);
};

CIniPropertyBag::~CIniPropertyBag()
{
    LocalFree(_pszFile);        // accepts NULL
    LocalFree(_pszSection);     // accepts NULL
}

HRESULT CIniPropertyBag::_Init(LPCWSTR pszFile, LPCWSTR pszSection)
{
    HRESULT hr = E_OUTOFMEMORY;

    _pszFile = StrDupW(pszFile);
    if (_pszFile)
    {
        if (pszSection)
        {
            _pszSection = StrDupW(pszSection);
            if (_pszSection)
                hr = S_OK;
        }
        else
        {
            hr = S_OK;
        }
    }

    return hr;
}

// support the <section name>.<prop name> scheme

HRESULT CIniPropertyBag::_GetSectionAndName(LPCWSTR pszProp, 
                                            LPWSTR pszSection, UINT cchSec, 
                                            LPWSTR pszName, UINT cchName)
{
    HRESULT hr;
    LPCWSTR pszSlash = StrChrW(pszProp, L'\\');
    if (pszSlash)
    {
        StrCpyNW(pszSection, pszProp, min((UINT)(pszSlash - pszProp) + 1, cchSec));
        StrCpyNW(pszName, pszSlash + 1, cchName);
        hr = S_OK;
    }
    else if (_pszSection)
    {
        StrCpyNW(pszSection, _pszSection, cchSec);
        StrCpyNW(pszName, pszProp, cchName);
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

// only supports strings.  use VariantChangeType() to suppor others

HRESULT CIniPropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pvar, IErrorLog *pErrorLog)
{
    VARTYPE vtDesired = pvar->vt;

    VariantInit(pvar);

    HRESULT hr = _CanRead();
    if (SUCCEEDED(hr))
    {
        WCHAR szSec[64], szName[64];
        hr = _GetSectionAndName(pszPropName, szSec, ARRAYSIZE(szSec), szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
        {
            WCHAR sz[MAX_PROPERTY_SIZE];
            if (SHGetIniStringUTF7W(szSec, szName, sz, ARRAYSIZE(sz), _pszFile))
            {
                pvar->bstrVal = SysAllocString(sz);
                if (pvar->bstrVal)
                {
                    pvar->vt = VT_BSTR;

                    hr = VariantChangeTypeForRead(pvar, vtDesired);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    return hr;
}


// only writes as strings to the INI file, we use VariantChangeType() to morp the types.

HRESULT CIniPropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pvar)
{
    HRESULT hr = _CanWrite();
    if (SUCCEEDED(hr))
    {
        LPCWSTR psz = pvar->vt == VT_EMPTY ? NULL : pvar->bstrVal;
        VARIANT var = { 0 };
            
        if ((pvar->vt != VT_EMPTY) && (pvar->vt != VT_BSTR))
        {
            hr = VariantChangeType(&var, pvar, 0, VT_BSTR);
            if (SUCCEEDED(hr))
                psz = var.bstrVal;                           
        }

        if (SUCCEEDED(hr))
        {
            WCHAR szSec[64], szName[64];
            hr = _GetSectionAndName(pszPropName, szSec, ARRAYSIZE(szSec), szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                if (!SHSetIniStringUTF7W(szSec, szName, psz, _pszFile))
                {
                    hr = E_FAIL;
                }
                else
                {
                    SHChangeNotifyWrap(SHCNE_UPDATEITEM, SHCNF_PATHW, _pszFile, NULL);
                }
            }
        }

        VariantClear(&var);
    }
    return hr;
}

HRESULT SHCreatePropertyBagOnProfileSection(LPCWSTR pszFile, LPCWSTR pszSection, DWORD grfMode, REFIID riid, void **ppv)
{
    if (grfMode & STGM_CREATE)
    {
        //  we need to touch this file first
        HANDLE h = CreateFileW(pszFile, 0, FILE_SHARE_DELETE, NULL, CREATE_NEW, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, NULL);
        if (INVALID_HANDLE_VALUE != h)
        {
            WCHAR szFolder[MAX_PATH];
            StrCpyNW(szFolder, pszFile, ARRAYSIZE(szFolder));
            if (PathRemoveFileSpecW(szFolder))
            {
                PathMakeSystemFolderW(szFolder);
            }
            CloseHandle(h);
        }
    }

    if (PathFileExistsAndAttributesW(pszFile, NULL))
    {
        CIniPropertyBag *pbag = new CIniPropertyBag(grfMode);
        if (pbag)
        {
            HRESULT hr = pbag->_Init(pszFile, pszSection);
            if (SUCCEEDED(hr))
                hr = pbag->QueryInterface(riid, ppv);
            pbag->Release();

            return hr;
        }
    }

    *ppv = NULL;
    return E_OUTOFMEMORY;
}


//
// Registry property bag implementation
//

class CRegPropertyBag : public CBasePropertyBag
{
public:
    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

protected:  //  methods
    CRegPropertyBag(DWORD grfMode);
    virtual ~CRegPropertyBag();
    HRESULT _Init(HKEY hk, LPCWSTR pszSubKey);
    friend HRESULT SHCreatePropertyBagOnRegKey(HKEY hk, LPCWSTR pszSubKey, DWORD grfMode, REFIID riid, void **ppv);

private:
    HRESULT _ReadDword(LPCOLESTR pszPropName, VARIANT *pvar);
    HRESULT _ReadString(LPCOLESTR pszPropName, VARIANT *pvar, DWORD cb);
    HRESULT _ReadStream(VARIANT* pvar, BYTE* pBuff, DWORD cb);
    HRESULT _ReadBinary(LPCOLESTR pszPropName, VARIANT* pvar, VARTYPE vt, DWORD cb);
    HRESULT _GetStreamSize(IStream* pstm, DWORD* pcb);
    HRESULT _CopyStreamIntoBuff(IStream* pstm, BYTE* pBuff, DWORD cb);
    HRESULT _WriteStream(LPCOLESTR pszPropName, IStream* pstm);

protected:  //  members
    HKEY  _hk;

friend HRESULT SHCreatePropertyBagOnRegKey(HKEY hk, LPCWSTR pszSubKey, DWORD grfMode, REFIID riid, void **ppv);
};

CRegPropertyBag::CRegPropertyBag(DWORD grfMode) : CBasePropertyBag(grfMode)
{
    ASSERT(NULL == _hk);
}

CRegPropertyBag::~CRegPropertyBag()
{
    if (_hk)
        RegCloseKey(_hk);
}

HRESULT CRegPropertyBag::_Init(HKEY hk, LPCWSTR pszSubKey)
{
    DWORD err;
    REGSAM sam = 0;

    if (SUCCEEDED(_CanRead()))
        sam |= KEY_READ;

    if (SUCCEEDED(_CanWrite()))
        sam |= KEY_WRITE;

    if (_grfMode & STGM_CREATE)
        err = RegCreateKeyExWrapW(hk, pszSubKey, 0, NULL, 0, sam, NULL, &_hk, NULL);
    else
        err = RegOpenKeyExWrapW(hk, pszSubKey, 0, sam, &_hk);

    return HRESULT_FROM_WIN32(err);
}

HRESULT CRegPropertyBag::_ReadDword(LPCOLESTR pszPropName, VARIANT *pvar)
{
    HRESULT hr;

    DWORD   dwType;
    DWORD   cb  = sizeof(pvar->lVal);

    if (NOERROR == SHGetValueW(_hk, NULL, pszPropName, &dwType, &pvar->lVal, &cb))
    {
        ASSERT(REG_DWORD == dwType);
        pvar->vt = VT_UI4;
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CRegPropertyBag::_ReadString(LPCOLESTR pszPropName, VARIANT *pvar, DWORD cb)
{
    HRESULT hr;

    DWORD   dwType;
    pvar->bstrVal = SysAllocStringByteLen(NULL, cb);

    if (pvar->bstrVal)
    {
        pvar->vt = VT_BSTR;

        if (NOERROR == SHGetValueW(_hk, NULL, pszPropName, &dwType, pvar->bstrVal, &cb))
        {
            hr = S_OK;
        }
        else
        {
            VariantClear(pvar);
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CRegPropertyBag::_ReadStream(VARIANT* pvar, BYTE* pBuff, DWORD cb)
{
    HRESULT hr;

    pvar->punkVal = SHCreateMemStream(pBuff, cb);

    if (pvar->punkVal)
    {
        pvar->vt = VT_UNKNOWN;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CRegPropertyBag::_ReadBinary(LPCOLESTR pszPropName, VARIANT* pvar, VARTYPE vt, DWORD cb)
{
    HRESULT hr;

    switch(vt)
    {
    case VT_UNKNOWN:
        hr = E_FAIL;
        if (EVAL(cb >= sizeof(GUID)))
        {
            BYTE* pBuff = static_cast<BYTE*>(LocalAlloc(LPTR, cb));
            if (pBuff)
            {
                DWORD dwType;
                if (NOERROR == SHGetValueW(_hk, NULL, pszPropName, &dwType, pBuff, &cb))
                {
                    GUID* pguid = (GUID*)pBuff;

                    if (IsEqualGUID(GUID_NULL, *pguid))
                    {
                        // it's our non-cocreatable IStream implementation
                        hr = _ReadStream(pvar, pBuff + sizeof(GUID), cb - sizeof(GUID));
                    }
                    else
                    {
                        ASSERTMSG(FALSE, "We don't support writing other types of objects yet.");
                    }
                }

                LocalFree(pBuff);
            }
        }
        break;

    default:
        hr = E_FAIL;
        break;
    }

    return hr;
}

HRESULT CRegPropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pvar, IErrorLog *pErrorLog)
{
    HRESULT hr = _CanRead();

    if (SUCCEEDED(hr))
    {
        VARTYPE vtDesired = pvar->vt;
        VariantInit(pvar);

        DWORD dwType;
        DWORD cb;

        if (NOERROR == SHGetValueW(_hk, NULL, pszPropName, &dwType, NULL, &cb))
        {
            switch(dwType)
            {
                case REG_DWORD:
                    hr = _ReadDword(pszPropName, pvar);
                    break;

                case REG_SZ:
                    hr = _ReadString(pszPropName, pvar, cb);
                    break;

                case REG_BINARY:
                    hr = _ReadBinary(pszPropName, pvar, vtDesired, cb);
                    break;

                default:
                    hr = E_FAIL;
                    break;
            }

            if (SUCCEEDED(hr))
            {
                hr = VariantChangeTypeForRead(pvar, vtDesired);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (FAILED(hr))
        VariantInit(pvar);

    return hr;
}

HRESULT CRegPropertyBag::_GetStreamSize(IStream* pstm, DWORD* pcb)
{
    HRESULT hr;

    *pcb = 0;

    ULARGE_INTEGER uli;
    hr = IStream_Size(pstm, &uli);

    if (SUCCEEDED(hr))
    {
        if (0 == uli.HighPart)
        {
            *pcb = uli.LowPart;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

HRESULT CRegPropertyBag::_CopyStreamIntoBuff(IStream* pstm, BYTE* pBuff, DWORD cb)
{
    HRESULT hr;

    hr = IStream_Reset(pstm);

    if (SUCCEEDED(hr))
    {
        hr = IStream_Read(pstm, pBuff, cb);
    }

    return hr;
}

HRESULT CRegPropertyBag::_WriteStream(LPCOLESTR pszPropName, IStream* pstm)
{
    HRESULT hr;
    
    DWORD cb;

    hr = _GetStreamSize(pstm, &cb);

    if (SUCCEEDED(hr) && cb)
    {
        BYTE* pBuff = static_cast<BYTE*>(LocalAlloc(LPTR, cb + sizeof(GUID)));

        if (pBuff)
        {
            // we're using a NULL GUID to mean our own IStream implementation
            hr = _CopyStreamIntoBuff(pstm, pBuff + sizeof(GUID), cb);

            if (SUCCEEDED(hr))
            {
                if (NOERROR != SHSetValueW(_hk, NULL, pszPropName, REG_BINARY, pBuff, cb + sizeof(GUID)))
                {
                    hr = E_FAIL;
                }
            }

            LocalFree(pBuff);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CRegPropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pvar)
{
    HRESULT hr = _CanWrite();
    if (SUCCEEDED(hr))
    {
        VARIANT var = { 0 };

        switch(pvar->vt)
        {
            case VT_EMPTY:
                SHDeleteValueW(_hk, NULL, pszPropName);
                break;

            case VT_I1:
            case VT_I2:
            case VT_I4:
            case VT_INT:
            case VT_UI1:
            case VT_UI2:
            case VT_UI4:
            case VT_UINT:
            case VT_BOOL:
                hr = VariantChangeType(&var, pvar, 0, VT_UI4);
                if (SUCCEEDED(hr))
                {
                    if (NOERROR != SHSetValueW(_hk, NULL, pszPropName, REG_DWORD, &var.lVal, sizeof(var.lVal)))
                    {
                        hr = E_FAIL;
                    }
                }
                break;

            case VT_UNKNOWN:
                IStream* pstm;
                hr = pvar->punkVal->QueryInterface(IID_PPV_ARG(IStream, &pstm));
                if (SUCCEEDED(hr))
                {
                    hr = _WriteStream(pszPropName, pstm);
                    pstm->Release();
                }
                else
                {
                    TraceMsg(TF_WARNING, "CRegPropertyBag::Write: Someone is trying to write an object we don't know how to save");
                }
                break;

            default:
                hr = VariantChangeType(&var, pvar, 0, VT_BSTR);
                if (SUCCEEDED(hr))
                {
                    if (NOERROR != SHSetValueW(_hk, NULL, pszPropName, REG_SZ, var.bstrVal, CbFromCchW(lstrlenW(var.bstrVal) + 1)))
                    {
                        hr = E_FAIL;
                    }
                    VariantClear(&var);
                }
                break;
        }
    }
    return hr;
}

HRESULT SHCreatePropertyBagOnRegKey(HKEY hk, LPCWSTR pszSubKey, DWORD grfMode, REFIID riid, void **ppv)
{
    HRESULT hr;
    CRegPropertyBag *pbag = new CRegPropertyBag(grfMode);
    if (pbag)
    {
        hr = pbag->_Init(hk, pszSubKey);

        if (SUCCEEDED(hr))
            hr = pbag->QueryInterface(riid, ppv);

        pbag->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



//
// Memory property bag implementation
//

typedef struct
{
    LPWSTR pszPropName;
    VARIANT variant;
} PBAGENTRY, * LPPBAGENTRY;

class CMemPropertyBag : public CBasePropertyBag
{
public:
    // IPropertyBag
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pVar);

protected:  // methods
    CMemPropertyBag(DWORD grfMode) : CBasePropertyBag(grfMode) {}
    ~CMemPropertyBag();
    HRESULT _Find(LPCOLESTR pszPropName, PBAGENTRY **pppbe, BOOL fCreate);

    friend HRESULT SHCreatePropertyBagOnMemory(DWORD grfMode, REFIID riid, void **ppv);

protected:  // members
    HDSA _hdsaProperties;
};

INT _FreePropBagCB(LPVOID pData, LPVOID lParam)
{
    LPPBAGENTRY ppbe = (LPPBAGENTRY)pData;
    Str_SetPtrW(&ppbe->pszPropName, NULL);
    VariantClear(&ppbe->variant);
    return 1;
}

CMemPropertyBag::~CMemPropertyBag()
{
    if (_hdsaProperties)
        DSA_DestroyCallback(_hdsaProperties, _FreePropBagCB, NULL);
}

//
// manange the list of propeties in the property bag
//

HRESULT CMemPropertyBag::_Find(LPCOLESTR pszPropName, PBAGENTRY **pppbe, BOOL fCreate)
{   
    int i;
    PBAGENTRY pbe = { 0 };

    *pppbe = NULL;

    // look up the property in the DSA
    // PERF: change to a DPA and sort accordingly for better perf (daviddv 110798)

    for ( i = 0 ; _hdsaProperties && (i < DSA_GetItemCount(_hdsaProperties)) ; i++ )
    {
        LPPBAGENTRY ppbe = (LPPBAGENTRY)DSA_GetItemPtr(_hdsaProperties, i);
        if ( !StrCmpIW(pszPropName, ppbe->pszPropName) )
        {
            *pppbe = ppbe;
            return S_OK;
        }
    }

    // no entry found, should we create one?

    if ( !fCreate )
        return E_FAIL;

    // yes, so lets check to see if we have a DSA yet.

    if ( !_hdsaProperties )
        _hdsaProperties = DSA_Create(SIZEOF(PBAGENTRY), 4);
    if ( !_hdsaProperties )
        return E_OUTOFMEMORY;

    // we have the DSA so lets fill the record we want to put into it

    if ( !Str_SetPtrW(&pbe.pszPropName, pszPropName) )
        return E_OUTOFMEMORY;

    VariantInit(&pbe.variant);

    // append it to the DSA we are using

    i = DSA_AppendItem(_hdsaProperties, &pbe);
    if ( -1 == i )
    {
        Str_SetPtrW(&pbe.pszPropName, NULL);
        return E_OUTOFMEMORY;
    }
    
    *pppbe = (LPPBAGENTRY)DSA_GetItemPtr(_hdsaProperties, i);

    return S_OK;
}


//
// IPropertyBag methods
//

STDMETHODIMP CMemPropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pv, IErrorLog *pErrorLog)
{
    VARTYPE vtDesired = pv->vt;

    VariantInit(pv);

    HRESULT hr = _CanRead();
    if (SUCCEEDED(hr))
    {
        hr = (pszPropName && pv) ? S_OK : E_INVALIDARG;

        if (SUCCEEDED(hr))
        {
            LPPBAGENTRY ppbe;
            hr = _Find(pszPropName, &ppbe, FALSE);
            if (SUCCEEDED(hr))
            {
                hr = VariantCopy(pv, &ppbe->variant);
                if (SUCCEEDED(hr))
                    hr = VariantChangeTypeForRead(pv, vtDesired);
            }
        }
    }
    
    return hr;
}

STDMETHODIMP CMemPropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pv)
{
    HRESULT hr = _CanWrite();
    if (SUCCEEDED(hr))
    {
        hr = (pszPropName && pv) ? S_OK : E_INVALIDARG;
        if (SUCCEEDED(hr))
        {
            LPPBAGENTRY ppbe;
            hr = _Find(pszPropName, &ppbe, TRUE);
            if (SUCCEEDED(hr))
            {
                hr = VariantCopy(&ppbe->variant, pv);
            }
        }
    }

    return hr;
}


//
// Exported function for creating a IPropertyBag (or variant of) object.
//

STDAPI SHCreatePropertyBagOnMemory(DWORD grfMode, REFIID riid, void **ppv)
{
    CMemPropertyBag *ppb = new CMemPropertyBag(grfMode);
    if (ppb)
    {    
        HRESULT hres = ppb->QueryInterface(riid, ppv);
        ppb->Release();

        return hres;
    }
    *ppv = NULL;
    return E_OUTOFMEMORY;
}



//
// Property bag helper functions
//

STDAPI SHPropertyBag_ReadType(IPropertyBag *ppb, LPCWSTR pszPropName, VARIANT *pv, VARTYPE vt)
{
    VariantInit(pv);
    pv->vt = vt;

    HRESULT hr = ppb->Read(pszPropName, pv, NULL);
    if (SUCCEEDED(hr))
    {
        if (vt != pv->vt && vt != VT_EMPTY)
        {
            TraceMsg(TF_WARNING, "SHPropertyBag_ReadType found an IPropertyBag that did not return the correct data!");
        }

        // Our IPropertyBag implementations have been buggy in the past, cover up for them
        hr = VariantChangeTypeForRead(pv, vt);
    }
    else
    {
        // don't break the caller by returning a bogus VARIANT struct
        VariantInit(pv);
    }

    return hr;
}

STDAPI SHPropertyBag_ReadBSTR(IPropertyBag *ppb, LPCWSTR pszPropName, BSTR* pbstr)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadBSTR caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadBSTR caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(pbstr, *pbstr), "SHPropertyBag_ReadBSTR caller passed bad pbstr");

    HRESULT hr;

    if (ppb && pszPropName && pbstr)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_BSTR);
        if (SUCCEEDED(hr))
            *pbstr = va.bstrVal;
        else
            *pbstr = NULL;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadStr(IPropertyBag* ppb, LPCWSTR pszPropName, LPWSTR psz, int cch)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadStr caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadStr caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_BUFFER(psz, *psz, cch), "SHPropertyBag_ReadStr caller passed bad psz and cch");

    HRESULT hr;

    if (ppb && pszPropName && psz)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_BSTR);
        if (SUCCEEDED(hr))
        {
            StrCpyNW(psz, va.bstrVal, cch);
            VariantClear(&va);
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }          

    return hr;
}

STDAPI SHPropertyBag_WriteStr(IPropertyBag* ppb, LPCWSTR pszPropName, LPCWSTR psz)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteStr caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteStr caller passed bad pszPropName");
    RIPMSG(NULL == psz || IS_VALID_STRING_PTRW(psz, -1), "SHPropertyBag_WriteStr caller passed bad psz");

    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.bstrVal = SysAllocString(psz);

        if (va.bstrVal)
        {
            va.vt = VT_BSTR;
            hr = ppb->Write(pszPropName, &va);
            SysFreeString(va.bstrVal);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadInt(IPropertyBag* ppb, LPCWSTR pszPropName, int* piResult)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadInt caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadInt caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(piResult, *piResult), "SHPropertyBag_ReadInt caller passed bad piResult");

    HRESULT hr;

    if (ppb && pszPropName && piResult)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_I4);
        if (SUCCEEDED(hr))
        {
            *piResult = va.ulVal;
            // VT_I4 has nothing to VariantClear
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteInt(IPropertyBag* ppb, LPCWSTR pszPropName, int i)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteInt caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteInt caller passed bad pszPropName");

    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_I4;
        va.lVal = i;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadSHORT(IPropertyBag* ppb, LPCWSTR pszPropName, SHORT* psh)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadSHORT caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadSHORT caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(psh, *psh), "SHPropertyBag_ReadSHORT caller passed bad psh");

    HRESULT hr;

    if (ppb && pszPropName && psh)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_UI2);
        if (SUCCEEDED(hr))
        {
            *psh = va.iVal;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteSHORT(IPropertyBag* ppb, LPCWSTR pszPropName, SHORT sh)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteSHORT caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteSHORT caller passed bad pszPropName");
 
    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_UI2;
        va.iVal = sh;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadLONG(IPropertyBag* ppb, LPCWSTR pszPropName, LONG* pl)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadLONG caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadLONG caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(pl, *pl), "SHPropertyBag_ReadLONG caller passed bad pl");

    HRESULT hr;

    if (ppb && pszPropName && pl)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_I4);
        if (SUCCEEDED(hr))
        {
            *pl = va.ulVal;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteLONG(IPropertyBag* ppb, LPCWSTR pszPropName, LONG l)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteLONG caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteLONG caller passed bad pszPropName");

    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_I4;
        va.lVal = l;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadDWORD(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD* pdw)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadDWORD caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadDWORD caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(pdw, *pdw), "SHPropertyBag_ReadInt caller passed bad pdw");

    HRESULT hr;

    if (ppb && pszPropName && pdw)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_UI4);
        if (SUCCEEDED(hr))
        {
            *pdw = va.ulVal;
            // VT_UI4 has nothing to VariantClear
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteDWORD(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD dw)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteDWORD caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteDWORD caller passed bad pszPropName");
 
    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_UI4;
        va.ulVal = dw;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

// This shipped on Whistler Beta 1.  It's exported by ordinal.
STDAPI_(BOOL) SHPropertyBag_ReadBOOLOld(IPropertyBag *ppb, LPCWSTR pwzPropName, BOOL fResult)
{
    VARIANT va;
    HRESULT hr = SHPropertyBag_ReadType(ppb, pwzPropName, &va, VT_BOOL);
    if (SUCCEEDED(hr))
    {
        fResult = (va.boolVal == VARIANT_TRUE);
        // VT_BOOL has nothing to VariantClear
    }
    return fResult;
}


STDAPI SHPropertyBag_ReadBOOL(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL* pfResult)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadBOOL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadBOOL caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(pfResult, *pfResult), "SHPropertyBag_ReadBOOL caller passed bad pfResult");

    HRESULT hr;

    if (ppb && pszPropName && pfResult)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_BOOL);
        if (SUCCEEDED(hr))
        {
            *pfResult = (va.boolVal == VARIANT_TRUE);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteBOOL(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL fValue)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteBOOL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteBOOL caller passed bad pszPropName");

    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_BOOL;
        va.boolVal = fValue ? VARIANT_TRUE : VARIANT_FALSE;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadGUID(IPropertyBag* ppb, LPCWSTR pszPropName, GUID* pguid)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadGUID caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadGUID caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(pguid, *pguid), "SHPropertyBag_ReadGUID caller passed bad pguid");

    HRESULT hr;

    if (ppb && pszPropName && pguid)
    {
        VARIANT var;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &var, VT_EMPTY);
        if (SUCCEEDED(hr))
        {
            if (var.vt == (VT_ARRAY | VT_UI1)) // some code has been writing GUIDs as array's of bytes
            {
                hr = VariantToGUID(&var, pguid) ? S_OK : E_FAIL;
            }
            else if (var.vt == VT_BSTR)
            {
                hr = GUIDFromStringW(var.bstrVal, pguid) ? S_OK : E_FAIL;
            }
            VariantClear(&var);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
 
STDAPI SHPropertyBag_WriteGUID(IPropertyBag *ppb, LPCWSTR pszPropName, const GUID *pguid)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteGUID caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteGUID caller passed bad pszPropName");
    RIPMSG(IS_VALID_READ_PTR(pguid, *pguid), "SHPropertyBag_WriteGUID caller passed bad pguid");

    HRESULT hr;

    if (ppb && pszPropName && pguid)
    {
        WCHAR sz[64];
        SHStringFromGUIDW(*pguid, sz, ARRAYSIZE(sz));
        hr = SHPropertyBag_WriteStr(ppb, pszPropName, sz);            // assumes null terminator
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadPOINTL(IPropertyBag* ppb, LPCWSTR pszPropName, POINTL* ppt)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadPOINTL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadPOINTL caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(ppt, *ppt), "SHPropertyBag_ReadPOINTL caller passed bad ppt");

    HRESULT hr;

    if (ppb && pszPropName && ppt)
    {
        WCHAR szProp[MAX_PATH];
        RIP(lstrlenW(pszPropName) < ARRAYSIZE(szProp) - 2);
        StrCpyNW(szProp, pszPropName, ARRAYSIZE(szProp));
        UINT cch = lstrlenW(szProp);

        if (ARRAYSIZE(szProp) - cch >= 3)
        {
            StrCpyNW(szProp + cch, L".x", ARRAYSIZE(szProp) - cch);        
            hr = SHPropertyBag_ReadLONG(ppb, szProp, &ppt->x);

            if (SUCCEEDED(hr))
            {
                StrCpyNW(szProp + cch, L".y", ARRAYSIZE(szProp) - cch);
                hr = SHPropertyBag_ReadLONG(ppb, szProp, &ppt->y);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WritePOINTL(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTL* ppt)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WritePOINTL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WritePOINTL caller passed bad pszPropName");
    RIPMSG(IS_VALID_READ_PTR(ppt, *ppt), "SHPropertyBag_WritePOINTL caller passed bad ppt");

    HRESULT hr;

    if (ppb && pszPropName && ppt)
    {
        WCHAR szProp[MAX_PATH];
        RIP(lstrlenW(pszPropName) < ARRAYSIZE(szProp) - 2);
        StrCpyNW(szProp, pszPropName, ARRAYSIZE(szProp));
        UINT cch = lstrlenW(szProp);

        if (ARRAYSIZE(szProp) - cch >= 3)
        {
            StrCpyNW(szProp + cch, L".x", ARRAYSIZE(szProp) - cch);        
            hr = SHPropertyBag_WriteLONG(ppb, szProp, ppt->x);

            if (SUCCEEDED(hr))
            {
                StrCpyNW(szProp + cch, L".y", ARRAYSIZE(szProp) - cch);
                hr = SHPropertyBag_WriteLONG(ppb, szProp, ppt->y);

                if (FAILED(hr))
                {
                    StrCpyNW(szProp + cch, L".x", ARRAYSIZE(szProp) - cch);        
                    hr = SHPropertyBag_Delete(ppb, szProp);
                }                    
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadPOINTS(IPropertyBag* ppb, LPCWSTR pszPropName, POINTS* ppt)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadPOINTS caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadPOINTS caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(ppt, *ppt), "SHPropertyBag_ReadPOINTS caller passed bad ppt");

    HRESULT hr;

    if (ppb && pszPropName && ppt)
    {
        POINTL ptL;
        hr = SHPropertyBag_ReadPOINTL(ppb, pszPropName, &ptL);

        if (SUCCEEDED(hr))
        {
            ppt->x = static_cast<SHORT>(ptL.x);
            ppt->y = static_cast<SHORT>(ptL.y);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WritePOINTS(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTS* ppt)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WritePOINTS caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WritePOINTS caller passed bad pszPropName");
    RIPMSG(IS_VALID_READ_PTR(ppt, *ppt), "SHPropertyBag_WritePOINTS caller passed bad ppt");

    HRESULT hr;

    if (ppb && pszPropName && ppt)
    {
        POINTL ptL;
        ptL.x = ppt->x;
        ptL.y = ppt->y;

        hr = SHPropertyBag_WritePOINTL(ppb, pszPropName, &ptL);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadRECTL(IPropertyBag* ppb, LPCWSTR pszPropName, RECTL* prc)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_ReadRECTL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_ReadRECTL caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(prc, *prc), "SHPropertyBag_ReadRECTL caller passed bad prc");

    HRESULT hr;

    if (ppb && pszPropName && prc)
    {
        WCHAR szProp[MAX_PATH];
        RIP(lstrlenW(pszPropName) < ARRAYSIZE(szProp) - 7);
        StrCpyNW(szProp, pszPropName, ARRAYSIZE(szProp));
        UINT cch = lstrlenW(szProp);

        if (ARRAYSIZE(szProp) - cch >= 8)
        {
            StrCpyNW(szProp + cch, L".left", ARRAYSIZE(szProp) - cch);        
            hr = SHPropertyBag_ReadLONG(ppb, szProp, &prc->left);

            if (SUCCEEDED(hr))
            {
                StrCpyNW(szProp + cch, L".top", ARRAYSIZE(szProp) - cch);
                hr = SHPropertyBag_ReadLONG(ppb, szProp, &prc->top);

                if (SUCCEEDED(hr))
                {
                    StrCpyNW(szProp + cch, L".right", ARRAYSIZE(szProp) - cch);
                    hr = SHPropertyBag_ReadLONG(ppb, szProp, &prc->right);

                    if (SUCCEEDED(hr))
                    {
                        StrCpyNW(szProp + cch, L".bottom", ARRAYSIZE(szProp) - cch);
                        hr = SHPropertyBag_ReadLONG(ppb, szProp, &prc->bottom);
                    }
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteRECTL(IPropertyBag* ppb, LPCWSTR pszPropName, const RECTL* prc)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_WriteRECTL caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_WriteRECTL caller passed bad pszPropName");
    RIPMSG(IS_VALID_READ_PTR(prc, *prc), "SHPropertyBag_WriteRECTL caller passed bad prc");

    HRESULT hr;

    if (ppb && pszPropName && prc)
    {
        WCHAR szProp[MAX_PATH];
        RIP(lstrlenW(pszPropName) < ARRAYSIZE(szProp) - 7);
        StrCpyNW(szProp, pszPropName, ARRAYSIZE(szProp));
        UINT cch = lstrlenW(szProp);

        if (ARRAYSIZE(szProp) - cch >= 8)
        {
            StrCpyNW(szProp + cch, L".left", ARRAYSIZE(szProp) - cch);        
            hr = SHPropertyBag_WriteLONG(ppb, szProp, prc->left);

            if (SUCCEEDED(hr))
            {
                StrCpyNW(szProp + cch, L".top", ARRAYSIZE(szProp) - cch);
                hr = SHPropertyBag_WriteLONG(ppb, szProp, prc->top);

                if (SUCCEEDED(hr))
                {
                    StrCpyNW(szProp + cch, L".right", ARRAYSIZE(szProp) - cch);
                    hr = SHPropertyBag_WriteLONG(ppb, szProp, prc->right);

                    if (SUCCEEDED(hr))
                    {
                        StrCpyNW(szProp + cch, L".bottom", ARRAYSIZE(szProp) - cch);
                        hr = SHPropertyBag_WriteLONG(ppb, szProp, prc->bottom);

                        if (FAILED(hr))
                        {
                            StrCpyNW(szProp + cch, L".right", ARRAYSIZE(szProp) - cch);
                            hr = SHPropertyBag_Delete(ppb, szProp);
                        }
                    }

                    if (FAILED(hr))
                    {
                        StrCpyNW(szProp + cch, L".top", ARRAYSIZE(szProp) - cch);
                        hr = SHPropertyBag_Delete(ppb, szProp);
                    }
                }

                if (FAILED(hr))
                {
                    StrCpyNW(szProp + cch, L".left", ARRAYSIZE(szProp) - cch);        
                    hr = SHPropertyBag_Delete(ppb, szProp);
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_ReadStream(IPropertyBag* ppb, LPCWSTR pszPropName, IStream** ppstm)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_GetSTREAM caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_GetSTREAM caller passed bad pszPropName");
    RIPMSG(IS_VALID_WRITE_PTR(ppstm, *ppstm), "SHPropertyBag_GetSTREAM caller passed bad ppstm");

    HRESULT hr;

    if (ppb && pszPropName && ppstm)
    {
        VARIANT va;
        hr = SHPropertyBag_ReadType(ppb, pszPropName, &va, VT_UNKNOWN);

        if (SUCCEEDED(hr))
        {
            hr = va.punkVal->QueryInterface(IID_PPV_ARG(IStream, ppstm));
            va.punkVal->Release();
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDAPI SHPropertyBag_WriteStream(IPropertyBag* ppb, LPCWSTR pszPropName, IStream* pstm)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_GetSTREAM caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_GetSTREAM caller passed bad pszPropName");
    RIPMSG(NULL != pstm, "SHPropertyBag_GetSTREAM caller passed bad pstm");

    HRESULT hr;

    if (ppb && pszPropName && pstm)
    {
        VARIANT va;
        va.vt = VT_UNKNOWN;
        va.punkVal = pstm;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDAPI SHPropertyBag_Delete(IPropertyBag* ppb, LPCWSTR pszPropName)
{
    RIPMSG(NULL != ppb, "SHPropertyBag_GetSTREAM caller passed bad ppb");
    RIPMSG(IS_VALID_STRING_PTRW(pszPropName, -1), "SHPropertyBag_GetSTREAM caller passed bad pszPropName");

    HRESULT hr;

    if (ppb && pszPropName)
    {
        VARIANT va;
        va.vt = VT_EMPTY;
        hr = ppb->Write(pszPropName, &va);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


class CDesktopUpgradePropertyBag : public CBasePropertyBag
{
public:
    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

protected: 
    CDesktopUpgradePropertyBag() : CBasePropertyBag(STGM_READ) {}
    ~CDesktopUpgradePropertyBag() {}
    friend HRESULT SHGetDesktopUpgradePropertyBag(REFIID riid, void** ppv);

private:
    HRESULT _ReadFlags(VARIANT* pVar);
    HRESULT _ReadItemPositions(VARIANT* pVar);
    IStream* _GetOldDesktopViewStream(void);
    IStream* _NewStreamFromOld(IStream* pstmOld);
    BOOL _AlreadyUpgraded(HKEY hk);
    void _MarkAsUpgraded(HKEY hk);
};

HRESULT CDesktopUpgradePropertyBag::_ReadFlags(VARIANT* pVar)
{
    HRESULT hr;

    FOLDERSETTINGS fs;
    DWORD cb = sizeof(fs);

    if (NOERROR == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\DeskView"),
                              TEXT("Settings"), NULL, (BYTE *)&fs, &cb)                   &&
        cb >= sizeof(fs))
    {
        pVar->uintVal = fs.fFlags | FWF_DESKTOP | FWF_NOCLIENTEDGE;
        pVar->vt = VT_UINT;
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

typedef struct
{
    WORD  wSig;
    BYTE  bDontCare[12];
    WORD  cbPosOffset;
}OLDVS_STREAMHEADER;

#define OLDVS_STREAMHEADERSIG  28  // sizeof(WIN95HEADER)

IStream* CDesktopUpgradePropertyBag::_NewStreamFromOld(IStream* pstmOld)
{
    IStream* pstmNew = NULL;

    OLDVS_STREAMHEADER ovssh;

    if (SUCCEEDED(IStream_Read(pstmOld, &ovssh, sizeof(ovssh))) && OLDVS_STREAMHEADERSIG == ovssh.wSig)
    {
        LARGE_INTEGER liPos;
        liPos.QuadPart = ovssh.cbPosOffset - sizeof(ovssh);

        if (SUCCEEDED(pstmOld->Seek(liPos, STREAM_SEEK_CUR, NULL)))
        {
            ULARGE_INTEGER uliSize;

            if (SUCCEEDED(IStream_Size(pstmOld, &uliSize)))
            {
                pstmNew = SHCreateMemStream(NULL, 0);

                if (pstmNew)
                {
                    uliSize.QuadPart -= ovssh.cbPosOffset;

                    if (SUCCEEDED(pstmOld->CopyTo(pstmNew, uliSize, NULL, NULL)))
                    {
                        IStream_Reset(pstmNew);
                    }
                    else
                    {
                        pstmNew->Release();
                        pstmNew = NULL;
                    }
                }
            }
        }
    }

    return pstmNew;
}

BOOL CDesktopUpgradePropertyBag::_AlreadyUpgraded(HKEY hk)
{
    DWORD dwUpgrade;
    DWORD cbUpgrade = sizeof(dwUpgrade);
    DWORD dwType;    

    return (ERROR_SUCCESS == SHGetValueW(hk, NULL, L"Upgrade", &dwType, &dwUpgrade, &cbUpgrade));
}

void CDesktopUpgradePropertyBag::_MarkAsUpgraded(HKEY hk)
{
    DWORD dwVal = 1;
    SHSetValueW(hk, NULL, L"Upgrade", REG_DWORD, &dwVal, sizeof(dwVal));
}


IStream* CDesktopUpgradePropertyBag::_GetOldDesktopViewStream()
{
    IStream* pstmRet = NULL;

    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, L"Streams\\Desktop", FALSE);
    if (hk)
    {
        if (!_AlreadyUpgraded(hk))
        {
            pstmRet = SHOpenRegStream2W(hk, NULL, L"ViewView2", STGM_READ);

            if (NULL != pstmRet)
            {
                ULARGE_INTEGER uliSize;
                if (SUCCEEDED(IStream_Size(pstmRet, &uliSize)) && 0 == uliSize.QuadPart)
                {
                    pstmRet->Release();
                    pstmRet = NULL;
                }                   
            }

            if (NULL == pstmRet)
                pstmRet = SHOpenRegStream2W(hk, NULL, L"ViewView", STGM_READ);

            _MarkAsUpgraded(hk);
        }
        RegCloseKey(hk);        
    }

    return pstmRet;
}

HRESULT CDesktopUpgradePropertyBag::_ReadItemPositions(VARIANT* pVar)
{
    HRESULT hr = E_FAIL;

    IStream* pstmOld = _GetOldDesktopViewStream();
    if (pstmOld)
    {
        IStream* pstmNew = _NewStreamFromOld(pstmOld);
        if (pstmNew)
        {
            pVar->punkVal = pstmNew;
            pVar->vt      = VT_UNKNOWN;
            hr = S_OK;
        }

        pstmOld->Release();
    }

    return hr;
}


HRESULT CDesktopUpgradePropertyBag::Read(LPCOLESTR pszPropName, VARIANT* pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    VARTYPE vtDesired = pVar->vt;

    if (0 == StrCmpW(VS_PROPSTR_FFLAGS, pszPropName))
    {
        hr = _ReadFlags(pVar); 
    }
    else if (0 == StrCmpNW(VS_PROPSTR_ITEMPOS, pszPropName, ARRAYSIZE(VS_PROPSTR_ITEMPOS) - 1))
    {
        hr = _ReadItemPositions(pVar);
    }
    else
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        hr = VariantChangeTypeForRead(pVar, vtDesired);
    }
    else
    {
        VariantInit(pVar);
    }

    return hr;
}

HRESULT CDesktopUpgradePropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pVar)
{
    return E_NOTIMPL;
}


HRESULT SHGetDesktopUpgradePropertyBag(REFIID riid, void** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    CDesktopUpgradePropertyBag* pbag = new CDesktopUpgradePropertyBag();

    if (pbag)
    {
        hr = pbag->QueryInterface(riid, ppv);
        pbag->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}




class CViewStatePropertyBag : public CBasePropertyBag
{
public:
    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

protected: 
    CViewStatePropertyBag(void);
    virtual ~CViewStatePropertyBag();
    HRESULT _Init(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags);
    BOOL    _IsSameBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags);
    friend HRESULT SHGetViewStatePropertyBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, REFIID riid, void** ppv);
    friend HRESULT GetCachedViewStatePropertyBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, REFIID riid, void** ppv);

private:
    HRESULT _CreateBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, DWORD grfMode, REFIID riid, void** ppv);
    HRESULT _CreateUpgradeBag(REFIID riid, void** ppv);

    BOOL    _CanAccessPidlBag(void);
    BOOL    _EnsurePidlBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadPidlBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _CanAccessUpgradeBag(void);
    BOOL    _EnsureUpgradeBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadUpgradeBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _CanAccessInheritBag(void);
    BOOL    _EnsureInheritBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadInheritBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _CanAccessUserDefaultsBag(void);
    BOOL    _EnsureUserDefaultsBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadUserDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _CanAccessFolderDefaultsBag(void);
    BOOL    _EnsureFolderDefaultsBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadFolderDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _CanAccessGlobalDefaultsBag(void);
    BOOL    _EnsureGlobalDefaultsBag(DWORD grfMode, REFIID riid);
    HRESULT _ReadGlobalDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    BOOL    _EnsureReadBag(DWORD grfMode, REFIID riid);    
    BOOL    _EnsureWriteBag(DWORD grfMode, REFIID riid);    
    HRESULT _GetRegKey(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, DWORD grfMode, HKEY hk, LPWSTR pszKey, UINT cch);
    DWORD   _GetMRUSize(HKEY hk);
    HRESULT _GetMRUSlots(LPCITEMIDLIST pidl, DWORD grfMode, HKEY hk, DWORD adwSlot[], DWORD dwcSlots, DWORD* pdwFetched);
    HRESULT _GetMRUSlot(LPCITEMIDLIST pidl, DWORD grfMode, HKEY hk, DWORD* pdwSlot);
    HKEY    _GetHKey(DWORD dwFlags);
    void    _ResetTryAgainFlag();
    HRESULT _FindNearestInheritBag(REFIID riid, void** ppv);
    void    _PruneMRUTree(void);
    BOOL    _IsSamePidl(LPCITEMIDLIST pidl);
    BOOL    _IsSystemFolder(void);

private:
    LPITEMIDLIST  _pidl;
    LPWSTR        _pszBagName;
    DWORD         _dwFlags;
    IPropertyBag* _ppbPidl;
    IPropertyBag* _ppbUpgrade;
    IPropertyBag* _ppbInherit;
    IPropertyBag* _ppbUserDefaults;
    IPropertyBag* _ppbFolderDefaults;
    IPropertyBag* _ppbGlobalDefaults;
    IPropertyBag* _ppbRead;
    IPropertyBag* _ppbWrite;

    BOOL          _fTriedPidlBag;
    BOOL          _fTriedUpgradeBag;
    BOOL          _fTriedInheritBag;
    BOOL          _fTriedUserDefaultsBag;
    BOOL          _fTriedFolderDefaultsBag;
    BOOL          _fTriedGlobalDefaultsBag;
    BOOL          _fTriedReadBag;
    BOOL          _fTriedWriteBag;
};

CViewStatePropertyBag::CViewStatePropertyBag() : CBasePropertyBag(STGM_READ)
{
    ASSERT(NULL == _pidl);
    ASSERT(NULL == _pszBagName);
    ASSERT(   0 == _dwFlags);
    ASSERT(NULL == _ppbPidl);
    ASSERT(NULL == _ppbUpgrade);
    ASSERT(NULL == _ppbInherit);
    ASSERT(NULL == _ppbUserDefaults);
    ASSERT(NULL == _ppbFolderDefaults);
    ASSERT(NULL == _ppbGlobalDefaults);
    ASSERT(NULL == _ppbRead);
    ASSERT(NULL == _ppbWrite);
}

CViewStatePropertyBag::~CViewStatePropertyBag()
{
    if (_pidl)
        ILFree(_pidl);

    if (_pszBagName)
        LocalFree(_pszBagName);

    if (_ppbPidl)
        _ppbPidl->Release();

    if (_ppbUpgrade)
        _ppbUpgrade->Release();

    if (_ppbInherit)
        _ppbInherit->Release();

    if (_ppbUserDefaults)
        _ppbUserDefaults->Release();

    if (_ppbFolderDefaults)
        _ppbFolderDefaults->Release();

    if (_ppbGlobalDefaults)
        _ppbGlobalDefaults->Release();

    if (_ppbRead)
        _ppbRead->Release();

    if (_ppbWrite)
        _ppbWrite->Release();
}

HKEY CViewStatePropertyBag::_GetHKey(DWORD dwFlags)
{
    HKEY hkRet;

    if ((dwFlags & SHGVSPB_PERUSER) || (dwFlags & SHGVSPB_INHERIT))
    {
        if (!(_dwFlags & SHGVSPB_ROAM) || !(dwFlags & SHGVSPB_PERFOLDER))
        {
            hkRet = SHGetShellKey(SHELLKEY_HKCU_SHELLNOROAM, NULL, TRUE);
        }
        else
        {
            hkRet = SHGetShellKey(SHELLKEY_HKCU_SHELL, NULL, TRUE);
        }
    }
    else
    {
        hkRet = SHGetShellKey(SHELLKEY_HKLM_SHELL, NULL, TRUE);
    }

    return hkRet;
}

DWORD CViewStatePropertyBag::_GetMRUSize(HKEY hk)
{
    DWORD dwMRUSize;
    DWORD dwSize = sizeof(dwMRUSize);

    if (NOERROR != SHGetValueW(hk, NULL, L"BagMRU Size", NULL, &dwMRUSize, &dwSize))
    {
        dwMRUSize = 400; // default size.
    }

    return dwMRUSize;
}

HRESULT CViewStatePropertyBag::_GetMRUSlots(LPCITEMIDLIST pidl, DWORD grfMode, HKEY hk, DWORD adwSlots[], DWORD cSlots, DWORD* pdwFetched)
{
    HRESULT hr;

    IMruPidlList *pmru;
    hr = CoCreateInstance(CLSID_MruPidlList, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMruPidlList, &pmru));

    if (SUCCEEDED(hr))
    {
        hr = pmru->InitList(_GetMRUSize(hk), hk, L"BagMRU");

        if (SUCCEEDED(hr))
        {
            hr = pmru->QueryPidl(pidl, cSlots, adwSlots, pdwFetched);

            if (S_OK == hr || (grfMode & (STGM_WRITE | STGM_READWRITE)))
            {
                hr = pmru->UsePidl(pidl, &adwSlots[0]);
            }
            else if (1 == cSlots) // return S_FALSE for cSlots > 1 if parent slots exist.
            {
                hr = E_FAIL;
            }
        }

        pmru->Release();
    }

    return hr;
}

HRESULT CViewStatePropertyBag::_GetMRUSlot(LPCITEMIDLIST pidl, DWORD grfMode, HKEY hk, DWORD* pdwSlot)
{
    DWORD dwFetched;

    return _GetMRUSlots(pidl, grfMode, hk, pdwSlot, 1, &dwFetched);
}

HRESULT CViewStatePropertyBag::_GetRegKey(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, DWORD grfMode, HKEY hk, LPWSTR pszKey, UINT cch)
{
    HRESULT hr = S_OK;

    if ((dwFlags & SHGVSPB_PERFOLDER) || (dwFlags & SHGVSPB_INHERIT))
    {
        DWORD dwSlot;
        hr = _GetMRUSlot(pidl, grfMode, hk, &dwSlot);

        if (SUCCEEDED(hr))
        {
            if (!(dwFlags & SHGVSPB_INHERIT))
            {
                wnsprintfW(pszKey, cch, L"Bags\\%d\\%s", dwSlot, pszBagName);
            }
            else
            {
                wnsprintfW(pszKey, cch, L"Bags\\%d\\%s\\Inherit", dwSlot, pszBagName);
            }
        }
    }
    else
    {
        wnsprintfW(pszKey, cch, L"Bags\\AllFolders\\%s", pszBagName);
    }

    return hr;
}

HRESULT CViewStatePropertyBag::_Init(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (pidl)
    {
        _pidl = ILClone(pidl);
    }

    _pszBagName = StrDupW(pszBagName);

    if (_pszBagName)
    {
        _dwFlags = dwFlags;
        hr = S_OK;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_IsSamePidl(LPCITEMIDLIST pidl)
{
    return (((pidl == NULL) && (_pidl == NULL)) ||
            ((pidl != NULL) && (_pidl != NULL) && ILIsEqual(pidl, _pidl)));
}
BOOL CViewStatePropertyBag::_IsSameBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags)
{
    return dwFlags == _dwFlags && 0 == StrCmpW(pszBagName, _pszBagName) && _IsSamePidl(pidl);
}

HRESULT CViewStatePropertyBag::_CreateBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, DWORD grfMode, REFIID riid, void** ppv)
{
    HRESULT hr;

    DWORD grfMode2 = grfMode | ((grfMode & (STGM_WRITE | STGM_READWRITE)) ? STGM_CREATE : 0);

    if (!(dwFlags & SHGVSPB_ALLUSERS) || !(dwFlags & SHGVSPB_PERFOLDER))
    {
        HKEY hk = _GetHKey(dwFlags);

        if (hk)
        {
            WCHAR szRegSubKey[64];
            hr = _GetRegKey(pidl, pszBagName, dwFlags, grfMode2, hk, szRegSubKey, ARRAYSIZE(szRegSubKey));

            if (SUCCEEDED(hr))
            {            
                hr = SHCreatePropertyBagOnRegKey(hk, szRegSubKey, grfMode2, riid, ppv);
            }

            RegCloseKey(hk);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        IBindCtx* pbctx;
        hr = BindCtx_CreateWithMode(grfMode2, &pbctx);

        if (SUCCEEDED(hr))
        {
            // can't use - causes link problems.
            // hr = SHBindToObjectEx(NULL, _pidl, pbctx, riid, ppv); 

            IShellFolder* psf;
            hr = SHGetDesktopFolder(&psf);

            if (SUCCEEDED(hr))
            {
                hr = psf->BindToObject(_pidl, pbctx, riid, ppv);

                if (SUCCEEDED(hr) && NULL == *ppv)
                    hr = E_FAIL;

                psf->Release();
            }

            pbctx->Release();
        }
    }

    return hr;
}

HRESULT CViewStatePropertyBag::_CreateUpgradeBag(REFIID riid, void** ppv)
{
    return SHGetDesktopUpgradePropertyBag(riid, ppv);
}

BOOL CViewStatePropertyBag::_CanAccessPidlBag()
{
    return (_dwFlags & SHGVSPB_PERUSER) && (_dwFlags & SHGVSPB_PERFOLDER);
}

BOOL CViewStatePropertyBag::_EnsurePidlBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbPidl && !_fTriedPidlBag && _CanAccessPidlBag())
    {
        _fTriedPidlBag = TRUE;
        _CreateBag(_pidl, _pszBagName, (SHGVSPB_PERUSER | SHGVSPB_PERFOLDER), grfMode, riid, (void**)&_ppbPidl);
    }

    return NULL != _ppbPidl;
}

HRESULT CViewStatePropertyBag::_ReadPidlBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsurePidlBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbPidl->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_CanAccessUpgradeBag()
{
    // only upgrade desktop for now.

    return 0 == StrCmpW(_pszBagName, VS_BAGSTR_DESKTOP);
}

BOOL CViewStatePropertyBag::_EnsureUpgradeBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbUpgrade && !_fTriedUpgradeBag && _CanAccessUpgradeBag())
    {
        _fTriedUpgradeBag = TRUE;

        _CreateUpgradeBag(riid, (void**)&_ppbUpgrade);
    }

    return NULL != _ppbUpgrade;
}

HRESULT CViewStatePropertyBag::_ReadUpgradeBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsureUpgradeBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbUpgrade->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CViewStatePropertyBag::_FindNearestInheritBag(REFIID riid, void** ppv)
{
    HRESULT hr = E_FAIL;

    *ppv = NULL;

    HKEY hk = _GetHKey(SHGVSPB_INHERIT);
    if (hk)
    {
        DWORD aParentSlots[64];
        DWORD dwFetched;

        if (SUCCEEDED(_GetMRUSlots(_pidl, STGM_READ, hk, aParentSlots, ARRAYSIZE(aParentSlots), &dwFetched)))
        {
            for (DWORD i = 0; i < dwFetched && FAILED(hr); i++)
            {
                WCHAR szRegSubKey[64];
                wnsprintfW(szRegSubKey, ARRAYSIZE(szRegSubKey), L"Bags\\%d\\%s\\Inherit", aParentSlots[i], _pszBagName);

                hr = SHCreatePropertyBagOnRegKey(hk, szRegSubKey, STGM_READ, riid, ppv);
            }
        }

        RegCloseKey(hk);
    }

    return hr;
}


BOOL CViewStatePropertyBag::_CanAccessInheritBag()
{
    return _CanAccessPidlBag() || (_dwFlags & SHGVSPB_INHERIT);
}

BOOL CViewStatePropertyBag::_EnsureInheritBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbInherit && !_fTriedInheritBag && _CanAccessInheritBag())
    {
        _fTriedInheritBag = TRUE;
        _FindNearestInheritBag(riid, (void**)&_ppbInherit);
    }

    return NULL != _ppbInherit;
}

HRESULT CViewStatePropertyBag::_ReadInheritBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsureInheritBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbInherit->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_CanAccessUserDefaultsBag()
{
    return _CanAccessPidlBag() || ((_dwFlags & SHGVSPB_PERUSER) && (_dwFlags & SHGVSPB_ALLFOLDERS));
}

BOOL CViewStatePropertyBag::_EnsureUserDefaultsBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbUserDefaults && !_fTriedUserDefaultsBag && _CanAccessUserDefaultsBag())
    {
        _fTriedUserDefaultsBag = TRUE;
        _CreateBag(NULL, _pszBagName, SHGVSPB_PERUSER | SHGVSPB_ALLFOLDERS, grfMode, riid, (void**)&_ppbUserDefaults);
    }

    return NULL != _ppbUserDefaults;
}

HRESULT CViewStatePropertyBag::_ReadUserDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsureUserDefaultsBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbUserDefaults->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_CanAccessFolderDefaultsBag()
{
    return _CanAccessUserDefaultsBag() || ((_dwFlags & SHGVSPB_ALLUSERS) && (_dwFlags & SHGVSPB_PERFOLDER));
}

BOOL CViewStatePropertyBag::_IsSystemFolder()
{
    BOOL fRet = FALSE;
    LPCITEMIDLIST pidlLast;
    IShellFolder* psf;
    if (SUCCEEDED(SHBindToParent(_pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast)))
    {
        WIN32_FIND_DATAW fd;
        if (SUCCEEDED(SHGetDataFromIDListW(psf, pidlLast, SHGDFIL_FINDDATA, &fd, sizeof(fd))))
        {
            fRet = PathIsSystemFolder(NULL, fd.dwFileAttributes);
        }

        psf->Release();
    }
    
    return fRet;
}

BOOL CViewStatePropertyBag::_EnsureFolderDefaultsBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbFolderDefaults && !_fTriedFolderDefaultsBag && _CanAccessFolderDefaultsBag())
    {
        _fTriedFolderDefaultsBag = TRUE;

        // PERF: Use the desktop.ini only if the folder is a system folder.
        if (_IsSystemFolder())
        {
            _CreateBag(_pidl, _pszBagName, SHGVSPB_ALLUSERS | SHGVSPB_PERFOLDER, grfMode, riid, (void**)&_ppbFolderDefaults);
        }
    }

    return NULL != _ppbFolderDefaults;
}

HRESULT CViewStatePropertyBag::_ReadFolderDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsureFolderDefaultsBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbFolderDefaults->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_CanAccessGlobalDefaultsBag()
{
    return _CanAccessFolderDefaultsBag() || ((_dwFlags & SHGVSPB_ALLUSERS) && (_dwFlags & SHGVSPB_ALLFOLDERS));
}

BOOL CViewStatePropertyBag::_EnsureGlobalDefaultsBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbGlobalDefaults && !_fTriedGlobalDefaultsBag && _CanAccessGlobalDefaultsBag())
    {
        _fTriedGlobalDefaultsBag = TRUE;
        _CreateBag(NULL, _pszBagName, SHGVSPB_ALLUSERS | SHGVSPB_ALLFOLDERS, grfMode, riid, (void**)&_ppbGlobalDefaults);
    }

    return NULL != _ppbGlobalDefaults;
}

HRESULT CViewStatePropertyBag::_ReadGlobalDefaultsBag(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if (_EnsureGlobalDefaultsBag(STGM_READ, IID_IPropertyBag))
    {
        hr = _ppbGlobalDefaults->Read(pszPropName, pVar, pErrorLog);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

BOOL CViewStatePropertyBag::_EnsureReadBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbRead && !_fTriedReadBag)
    {
        _fTriedReadBag = TRUE;
        _CreateBag(_pidl, _pszBagName, _dwFlags, grfMode, riid, (void**)&_ppbRead);
    }

    return NULL != _ppbRead;
}

HRESULT CViewStatePropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr;

    if ((_dwFlags & SHGVSPB_NOAUTODEFAULTS) || (_dwFlags & SHGVSPB_INHERIT))
    {
        if (_EnsureReadBag(STGM_READ, IID_IPropertyBag))
        {
            hr = _ppbRead->Read(pszPropName, pVar, pErrorLog);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = _ReadPidlBag(pszPropName, pVar, pErrorLog); // per user per folder

        if (FAILED(hr))
        {
            hr = _ReadInheritBag(pszPropName, pVar, pErrorLog);

            if (FAILED(hr))
            {
                hr = _ReadUpgradeBag(pszPropName, pVar, pErrorLog); // (legacy per user per folder)

                if (FAILED(hr))
                {
                    hr = _ReadUserDefaultsBag(pszPropName, pVar, pErrorLog); // per user all folders

                    if (FAILED(hr))
                    {
                        hr = _ReadFolderDefaultsBag(pszPropName, pVar, pErrorLog); // per folder all users

                        if (FAILED(hr))
                        {
                            hr = _ReadGlobalDefaultsBag(pszPropName, pVar, pErrorLog); // all folders all users
                        }
                    }
                }
            }
        }
    }

    return hr;
}

void CViewStatePropertyBag::_PruneMRUTree()
{
    HKEY hk = _GetHKey(SHGVSPB_INHERIT);

    if (hk)
    {
        IMruPidlList *pmru;
        HRESULT hr = CoCreateInstance(CLSID_MruPidlList, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMruPidlList, &pmru));

        if (SUCCEEDED(hr))
        {
            hr = pmru->InitList(200, hk, L"BagMRU");

            if (SUCCEEDED(hr))
            {
                pmru->PruneKids(_pidl);
            }

            pmru->Release();
        }

        RegCloseKey(hk);
    }
}

void CViewStatePropertyBag::_ResetTryAgainFlag()
{
    if (_dwFlags & SHGVSPB_NOAUTODEFAULTS)
    {
        _fTriedReadBag = FALSE;      
    }
    else
    {
        if ((_dwFlags & SHGVSPB_PERUSER) && (_dwFlags & SHGVSPB_PERFOLDER))
        {
            _fTriedPidlBag = FALSE;
        }
        else if (_dwFlags & SHGVSPB_INHERIT)
        {
            _fTriedInheritBag = FALSE;
        }
        else if ((_dwFlags & SHGVSPB_PERUSER) && (_dwFlags & SHGVSPB_ALLFOLDERS))
        {
            _fTriedUserDefaultsBag = FALSE;
        }
        else if ((_dwFlags & SHGVSPB_ALLUSERS) && (_dwFlags & SHGVSPB_PERFOLDER))
        {
            _fTriedFolderDefaultsBag = FALSE;
        }
        else if ((_dwFlags & SHGVSPB_ALLUSERS) && (_dwFlags & SHGVSPB_ALLFOLDERS))
        {
            _fTriedGlobalDefaultsBag = FALSE;
        }
    }
}

BOOL CViewStatePropertyBag::_EnsureWriteBag(DWORD grfMode, REFIID riid)
{
    if (!_ppbWrite && !_fTriedWriteBag)
    {
        _fTriedWriteBag = TRUE;
        _CreateBag(_pidl, _pszBagName, _dwFlags, grfMode, riid, (void**)&_ppbWrite);
        if (_ppbWrite)
        {
            _ResetTryAgainFlag();

            if (SHGVSPB_INHERIT & _dwFlags)
            {
                _PruneMRUTree();
            }
        }
    }

    return NULL != _ppbWrite;
}

HRESULT CViewStatePropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pVar)
{
    HRESULT hr;

    if (_EnsureWriteBag(STGM_WRITE, IID_IPropertyBag))
    {
        hr = _ppbWrite->Write(pszPropName, pVar);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


#ifdef DEBUG

void IS_VALID_SHGVSPB_PARAMS(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, REFIID riid, void** ppv)
{
    RIP((NULL == pidl && (dwFlags & SHGVSPB_ALLFOLDERS)) || (IsValidPIDL(pidl) && ((SHGVSPB_PERFOLDER & dwFlags) || (SHGVSPB_INHERIT & dwFlags))));
    RIP(pszBagName);
    RIP(SHGVSPB_PERUSER == (dwFlags & (SHGVSPB_PERUSER | SHGVSPB_ALLUSERS | SHGVSPB_INHERIT)) || SHGVSPB_ALLUSERS == (dwFlags & (SHGVSPB_PERUSER | SHGVSPB_ALLUSERS | SHGVSPB_INHERIT)) || SHGVSPB_INHERIT == (dwFlags & (SHGVSPB_PERUSER | SHGVSPB_ALLUSERS | SHGVSPB_INHERIT)));
    RIP(SHGVSPB_PERFOLDER  == (dwFlags & (SHGVSPB_PERFOLDER | SHGVSPB_ALLFOLDERS | SHGVSPB_INHERIT)) || SHGVSPB_ALLFOLDERS == (dwFlags & (SHGVSPB_PERFOLDER | SHGVSPB_ALLFOLDERS | SHGVSPB_INHERIT)) || SHGVSPB_INHERIT == (dwFlags & (SHGVSPB_PERFOLDER | SHGVSPB_ALLFOLDERS | SHGVSPB_INHERIT)));
    RIP(riid == IID_IPropertyBag || riid == IID_IUnknown);
    RIP(NULL != ppv);
}

#else

#define IS_VALID_SHGVSPB_PARAMS(a, b, c, d, e)

#endif

// Cache the last bag accessed. 
CViewStatePropertyBag* g_pCachedBag = NULL;

EXTERN_C void FreeViewStatePropertyBagCache()
{
    ENTERCRITICAL;
    {
        if (g_pCachedBag)
        {
            g_pCachedBag->Release();
            g_pCachedBag = NULL;
        }
    }
    LEAVECRITICAL;
}

BOOL SHIsRemovableDrive(LPCITEMIDLIST pidl)
{
    BOOL fRet = FALSE;
    LPCITEMIDLIST pidlLast;
    IShellFolder* psf;
    if (SUCCEEDED(SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast)))
    {
        STRRET str;
        if (SUCCEEDED(psf->GetDisplayNameOf(pidlLast, SHGDN_FORPARSING, &str)))
        {
            WCHAR szPath[MAX_PATH];
            if (SUCCEEDED(StrRetToBufW(&str, pidlLast, szPath, ARRAYSIZE(szPath))))
            {
                int iDrive = PathGetDriveNumberW(szPath);
                if (iDrive != -1)
                {
                    int iDriveType = RealDriveType(iDrive, FALSE);

                    fRet = (DRIVE_REMOVABLE == iDriveType || DRIVE_CDROM == iDriveType);
                }
            }
        }

        psf->Release();
    }
    
    return fRet;
}

STDAPI SHGetViewStatePropertyBag(LPCITEMIDLIST pidl, LPCWSTR pszBagName, DWORD dwFlags, REFIID riid, void** ppv)
{
    IS_VALID_SHGVSPB_PARAMS(pidl, pszBagName, dwFlags, riid, ppv);

    HRESULT hr;

    *ppv = NULL;

    ENTERCRITICAL;
    {
        if (g_pCachedBag && g_pCachedBag->_IsSameBag(pidl, pszBagName, dwFlags))
        {
            hr = S_OK;
        }
        else
        {
            if (!SHIsRemovableDrive(pidl))
            {
                CViewStatePropertyBag* pBag = new CViewStatePropertyBag();

                if (pBag)
                {
                    hr = pBag->_Init(pidl, pszBagName, dwFlags);

                    if (SUCCEEDED(hr))
                    {
                        if (g_pCachedBag)
                            g_pCachedBag->Release();

                        g_pCachedBag = pBag;
                    }
                    else
                    {
                        pBag->Release();
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_FAIL;  // don't save property bags for removable drives.
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = g_pCachedBag->QueryInterface(riid, ppv);
        }
    }
    LEAVECRITICAL;

    return hr;
}

ULONG SHGetPerScreenResName(WCHAR* pszRes, ULONG cch, DWORD dwVersion)
{
    RIPMSG(IS_VALID_WRITE_BUFFER(pszRes, *pszRes, cch), "SHGetPerScreenResName caller passed bad pszRes or cch");

    ULONG uRet;

    if (0 == dwVersion)
    {
        HDC hdc = GetDC(NULL);
        int x = GetDeviceCaps(hdc, HORZRES);
        int y = GetDeviceCaps(hdc, VERTRES);
        ReleaseDC(NULL, hdc);

        int n = GetSystemMetrics(SM_CMONITORS);

        int cchLen = wnsprintfW(pszRes, cch, L"%dx%d(%d)", x, y, n);    

        uRet =  (cchLen > 0) ? cchLen : 0;
    }
    else
    {
        uRet = 0;
    }

    return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\path.c ===
#include "priv.h"
#include "privpath.h"

#if defined(UNICODE) && defined(_X86_)
// we need unicode wrappers in pathw.c only
#include <w95wraps.h>
#endif

#ifdef UNIX
#include <mainwin.h>
#include "unixstuff.h"
#endif

#define CH_WHACK TEXT(FILENAME_SEPARATOR)

#include <platform.h>


// Warning this define is in NTDEF.H but not winnt.h...
#ifdef UNICODE
typedef WCHAR TUCHAR;
#else
typedef unsigned char TUCHAR;
#endif

#ifdef UNICODE // {
//***   FAST_CharNext -- fast CharNext for path operations
// DESCRIPTION
//  when we're just stepping thru chars in a path, a simple '++' is fine.
#define FAST_CharNext(p)    (DBNotNULL(p) + 1)

#ifdef DEBUG
LPWSTR WINAPI
DBNotNULL(LPCWSTR lpszCurrent)
{
    ASSERT(*lpszCurrent);
    return (LPWSTR) lpszCurrent;
}
#else
#define DBNotNULL(p)    (p)
#endif

#else // }{
#define FAST_CharNext(p)    CharNext(p)
#endif // }

static const TCHAR c_szPATH[] = TEXT("PATH");
static const TCHAR c_szEllipses[] = TEXT("...");

//
// Inline function to check for a double-backslash at the
// beginning of a string
//

#ifndef UNIX
static __inline BOOL DBL_BSLASH(LPCTSTR psz)
#else
__inline BOOL DBL_BSLASH(LPCTSTR psz)
#endif
{
    return (psz[0] == TEXT('\\') && psz[1] == TEXT('\\'));
}


#ifdef DBCS

// NOTE:
// LCMAP_IGNOREDBCS is a private bit has been redefined to
// 0x80000000 in NT5 source tree becuase it conflicts with
// another public bit.
// To make this code work with the OLD platforms, namely
// Win95 and OSRs. We have to define this flag.

#define LCMAP_IGNOREDBCS_WIN95 0x01000000

//
// This is supposed to work only with Path string.
//
int CaseConvertPathExceptDBCS(LPTSTR pszPath, int cch, BOOL fUpper)
{
    TCHAR szTemp[MAX_PATH];
    int   cchUse;
    DWORD fdwMap = (fUpper? LCMAP_UPPERCASE:LCMAP_LOWERCASE);

    // APPCOMPAT !!! (ccteng)
    // Do we need to check for Memphis? Is Memphis shipping a
    // kernel compiled with new headers?

    // LCMAP_IGNOREDBCS is ignored on NT.
    // And also this flag has been redefined in NT5 headers to
    // resolve a conflict which broke the backward compatibility.
    // So we only set the old flag when it's NOT running on NT.

    if (!g_bRunningOnNT)
    {
        fdwMap |= LCMAP_IGNOREDBCS_WIN95;
    }

    cchUse = (cch == 0)? lstrlen(pszPath): cch;

    // LCMapString cannot deal with src/dst in the same address.
    //
    if (pszPath)
    {
        lstrcpy(szTemp,pszPath);
        return LCMapString(LOCALE_SYSTEM_DEFAULT,fdwMap, szTemp, cchUse, pszPath, cchUse);
    }
    return 0;
}

STDAPI_(LPTSTR) CharLowerNoDBCS(LPTSTR psz)
{
    if(CaseConvertPathExceptDBCS(psz, 0, FALSE))
    {
        return psz;
    }
    return NULL;
}

STDAPI_(LPTSTR) CharUpperNoDBCS(LPTSTR psz)
{
    if(CaseConvertPathExceptDBCS(psz, 0, TRUE))
    {
        return psz;
    }
    return NULL;
}

UINT CharLowerBuffNoDBCS(LPTSTR lpsz, UINT cb)
{
    return (UINT)CaseConvertPathExceptDBCS(lpsz, cb, FALSE);
}

UINT CharUpperBuffNoDBCS(LPTSTR lpsz, UINT cb)
{
    return (UINT)CaseConvertPathExceptDBCS(lpsz, cb, TRUE);
}
#endif // DBCS


// FEATURE, we should validate the sizes of all path buffers by filling them
// with MAX_PATH fill bytes.


/*----------------------------------------------------------
Purpose: converts a file path to make it look a bit better if
         it is all upper case characters.

Returns:
*/
STDAPI_(BOOL)
PathMakePretty(LPTSTR lpPath)
{
    LPTSTR lp;

    RIPMSG(lpPath && IS_VALID_STRING_PTR(lpPath, -1), "PathMakePretty: caller passed bad lpPath");

    if (!lpPath)
    {
        return FALSE;
    }

    // REVIEW: INTL need to deal with lower case chars in (>127) range?

    // check for all uppercase
    for (lp = lpPath; *lp; lp = FAST_CharNext(lp))
    {
        if ((*lp >= TEXT('a')) && (*lp <= TEXT('z')) || IsDBCSLeadByte(*lp))
        {
            // this is a LFN or DBCS, dont mess with it
            return FALSE;
        }
    }

#ifdef DBCS
    // In order to be compatible with the file system, we cannot
    // case convert DBCS Roman characters.
    //
    CharLowerNoDBCS(lpPath);
    CharUpperBuffNoDBCS(lpPath, 1);
#else
    CharLower(lpPath);
    CharUpperBuff(lpPath, 1);
#endif

    return TRUE;        // did the conversion
}

// returns a pointer to the arguments in a cmd type path or pointer to
// NULL if no args exist
//
// "foo.exe bar.txt"    -> "bar.txt"
// "foo.exe"            -> ""
//
// Spaces in filenames must be quoted.
// " "A long name.txt" bar.txt " -> "bar.txt"

STDAPI_(LPTSTR)
PathGetArgs(LPCTSTR pszPath)
{
    RIPMSG(!pszPath || IS_VALID_STRING_PTR(pszPath, -1), "PathGetArgs: caller passed bad pszPath");

    if (pszPath)
    {
        BOOL fInQuotes = FALSE;

        while (*pszPath)
        {
            if (*pszPath == TEXT('"'))
            {
                fInQuotes = !fInQuotes;
            }
            else if (!fInQuotes && *pszPath == TEXT(' '))
            {
                return (LPTSTR)pszPath+1;
            }

            pszPath = FAST_CharNext(pszPath);
        }
    }

    return (LPTSTR)pszPath;
}


/*----------------------------------------------------------
Purpose: Remove arguments from pszPath.

Returns: --
Cond:    --
*/
STDAPI_(void)
PathRemoveArgs(LPTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathRemoveArgs: caller passed bad pszPath");

    if (pszPath)
    {
        LPTSTR pArgs = PathGetArgs(pszPath);
    
        if (*pArgs)
        {
            // clobber the ' '
            *(pArgs - 1) = TEXT('\0');
        }
        else
        {
            // Handle trailing space
            pArgs = CharPrev(pszPath, pArgs);

            if (*pArgs == TEXT(' '))
            {
                *pArgs = TEXT('\0');
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Determines if a file exists.  This is fast.

Returns: TRUE if it exists

  ***********************************************************************************************
  !!NOTE!!
  If you want to see if a UNC server, or UNC server\share exists (eg "\\pyrex" or "\\banyan\iptd"),
  then you have to call PathFileExistsAndAttributes, as this function will fail on the UNC server
  and server\share case!
  ***********************************************************************************************

*/
STDAPI_(BOOL)
PathFileExists(LPCTSTR pszPath)
{
    BOOL fResult = FALSE;

    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathFileExists: caller passed bad pszPath");

#ifdef DEBUG
    if (PathIsUNCServer(pszPath) || PathIsUNCServerShare(pszPath))
    {
        TraceMsg(TF_WARNING, "PathFileExists: called with a UNC server or server-share, use PathFileExistsAndAttributes for correct results in this case!!");
    }
#endif

    if (pszPath)
    {
        DWORD dwErrMode;

        dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        fResult = (BOOL)(GetFileAttributes(pszPath) != (DWORD)-1);

        SetErrorMode(dwErrMode);
    }

    return fResult;
}


/*----------------------------------------------------------
Purpose: Determines if a file exists, and returns the attributes
         of the file.

Returns: TRUE if it exists. If the function is able to get the file attributes and the
         caller passed a pdwAttributes, it will fill them in, else it will fill in -1.

  *******************************************************************************************************
  !!NOTE!!
  If you want to fail on UNC servers (eg "\\pyrex") or UNC server\shares (eg "\\banyan\iptd") then you
  should call PathFileExists and not this api!
  *******************************************************************************************************

*/
STDAPI_(BOOL) PathFileExistsAndAttributes(LPCTSTR pszPath, OPTIONAL DWORD* pdwAttributes)
{
    DWORD dwAttribs;
    BOOL fResult = FALSE;

    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathFileExistsAndAttributes: caller passed bad pszPath");

    if (pdwAttributes)
    {
        *pdwAttributes = (DWORD)-1;
    }
        
    if (pszPath)
    {
        DWORD dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        dwAttribs = GetFileAttributes(pszPath);

        if (pdwAttributes)
        {
            *pdwAttributes = dwAttribs;
        }

        if (dwAttribs == (DWORD)-1)
        {
            if (PathIsUNCServer(pszPath) || PathIsUNCServerShare(pszPath))
            {
                NETRESOURCE nr;
                LPTSTR lpSystem;
                DWORD dwRet;
                DWORD dwSize;
                TCHAR Buffer[256];

                nr.dwScope = RESOURCE_GLOBALNET;
                nr.dwType = RESOURCETYPE_ANY;
                nr.dwDisplayType = 0;
                nr.lpLocalName = NULL;
                nr.lpRemoteName = (LPTSTR)pszPath;
                nr.lpProvider = NULL;
                nr.lpComment = NULL;
                dwSize = SIZEOF(Buffer);
    
                // the net api's might at least tell us if this exists or not in the \\server or \\server\share cases
                // even if GetFileAttributes() failed
                dwRet = WNetGetResourceInformation(&nr, Buffer, &dwSize, &lpSystem);

                fResult = (dwRet == WN_SUCCESS || dwRet == WN_MORE_DATA);
            }
        }
        else
        {
            // GetFileAttributes succeeded!
            fResult = TRUE;
        }

        SetErrorMode(dwErrMode);
    }

    return fResult;
}


static const TCHAR c_szDotPif[] = TEXT(".pif");
static const TCHAR c_szDotCom[] = TEXT(".com");
static const TCHAR c_szDotBat[] = TEXT(".bat");
static const TCHAR c_szDotCmd[] = TEXT(".cmd");
static const TCHAR c_szDotLnk[] = TEXT(".lnk");
static const TCHAR c_szDotExe[] = TEXT(".exe");
static const TCHAR c_szNone[] = TEXT("");
// NB Look for .pif's first so that bound OS/2 apps (exe's)
// can have their dos stubs run via a pif.
//
// The COMMAND.COM search order is COM then EXE then BAT.  Windows 3.x
// matched this search order.  We need to search in the same order.

//  *** WARNING *** The order of the PFOPEX_ flags must be identical to the order
//  of the c_aDefExtList array.  PathFileExistsDefExt relies on it.
static const LPCTSTR c_aDefExtList[] = {
    c_szDotPif,
    c_szDotCom,
    c_szDotExe,
    c_szDotBat,
    c_szDotLnk,
    c_szDotCmd,
    c_szNone
};
#define IEXT_NONE (ARRAYSIZE(c_aDefExtList) - 1)
//  *** END OF WARNING ***

static UINT _FindInDefExts(LPCTSTR pszExt, UINT fExt)
{
    UINT iExt = 0;
    for (; iExt < ARRAYSIZE(c_aDefExtList); iExt++, fExt >>= 1) 
    {
        //  let NONE match up even tho there is 
        //  no bit for it.  that way find folders
        //  without a trailing dot correctly
        if (fExt & 1 || (iExt == IEXT_NONE)) 
        {
            if (0 == StrCmpI(pszExt, c_aDefExtList[iExt]))
                break;
        }
    }
    return iExt;
}

static BOOL _ApplyDefaultExts(LPTSTR pszPath, UINT fExt, DWORD *pdwAttribs)
{
    UINT cchPath = lstrlen(pszPath);
    //  Bail if not enough space for 4 more chars
    if (cchPath + ARRAYSIZE(c_szDotPif) < MAX_PATH) 
    {
        LPTSTR pszPathEnd = pszPath + cchPath;
        UINT cchFileSpecEnd = (UINT)(pszPathEnd - PathFindFileName(pszPath));
        DWORD dwAttribs = (DWORD) -1;
        // init to outside bounds
        UINT iExtBest = ARRAYSIZE(c_aDefExtList);  
        WIN32_FIND_DATA wfd = {0};
        //  set it up for the find
        lstrcpy(pszPathEnd, TEXT(".*"));
        {
            HANDLE h = FindFirstFile(pszPath, &wfd);
            if (h != INVALID_HANDLE_VALUE)
            {
                do 
                {
                    //  use cchFileSpecEnd, instead of PathFindExtension(),
                    //  so that if there is foo.bat and foo.bar.exe
                    //  we dont incorrectly return foo.exe.
                    //  this way we always compare apples to apples.
                    UINT iExt = _FindInDefExts((wfd.cFileName + cchFileSpecEnd), fExt);
                    if (iExt < iExtBest)
                    {
                        iExtBest = iExt;
                        dwAttribs = wfd.dwFileAttributes;
                    }

                } while (FindNextFile(h, &wfd));
                FindClose(h);
            }
        }

        if (iExtBest < ARRAYSIZE(c_aDefExtList))
        {
            //  copy the best extension into out param
            lstrcpy(pszPathEnd, c_aDefExtList[iExtBest]);
            if (pdwAttribs)
                *pdwAttribs = dwAttribs;
            return TRUE;
        }
        else
            *pszPathEnd = 0;   // Get rid of any extension
    }
    return FALSE;
}

//------------------------------------------------------------------
// Return TRUE if a file exists (by attribute check) after
// applying a default extensions (if req).
STDAPI_(BOOL) PathFileExistsDefExtAndAttributes(LPTSTR pszPath, UINT fExt, DWORD *pdwAttribs)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathFileExistsDefExt: caller passed bad pszPath");

    if (fExt)
    {
        RIPMSG(!pszPath || !IS_VALID_STRING_PTR(pszPath, -1) || // avoid RIP when above RIP would have caught it
               IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathFileExistsDefExt: caller passed bad pszPath");
        DEBUGWhackPathString(pszPath, MAX_PATH);
    }

    if (pdwAttribs)
        *pdwAttribs = (DWORD) -1;

    if (pszPath)
    {
        // Try default extensions?
        if (fExt && (!*PathFindExtension(pszPath) || !(PFOPEX_OPTIONAL & fExt)))
        {
            return _ApplyDefaultExts(pszPath, fExt, pdwAttribs);
        }
        else
        {
            return PathFileExistsAndAttributes(pszPath, pdwAttribs);
        }
    }
    return FALSE;
}

//------------------------------------------------------------------
// Return TRUE if a file exists (by attribute check) after
// applying a default extensions (if req).
STDAPI_(BOOL) PathFileExistsDefExt(LPTSTR pszPath, UINT fExt)
{
    // No sense sticking an extension on a server or share...
    if (PathIsUNCServer(pszPath) || PathIsUNCServerShare(pszPath))
    {
        return FALSE;
    }
    else return PathFileExistsDefExtAndAttributes(pszPath, fExt, NULL);
}


// walk through a path type string (semicolon seperated list of names)
// this deals with spaces and other bad things in the path
//
// call with initial pointer, then continue to call with the
// result pointer until it returns NULL
//
// input: "C:\FOO;C:\BAR;"
//
// in:
//      lpPath      starting point of path string "C:\foo;c:\dos;c:\bar"
//      cchPath     size of szPath
//
// out:
//      szPath      buffer with path piece
//
// returns:
//      pointer to next piece to be used, NULL if done
//
//
// FEATURE, we should write some test cases specifically for this code
//
STDAPI_(LPCTSTR) NextPath(LPCTSTR lpPath, LPTSTR szPath, int cchPath)
{
    LPCTSTR lpEnd;

    if (!lpPath)
        return NULL;

    // skip any leading ; in the path...
    while (*lpPath == TEXT(';'))
    {
        lpPath++;
    }

    // See if we got to the end
    if (*lpPath == 0)
    {
        // Yep
        return NULL;
    }

    lpEnd = StrChr(lpPath, TEXT(';'));

    if (!lpEnd)
    {
        lpEnd = lpPath + lstrlen(lpPath);
    }

    lstrcpyn(szPath, lpPath, min((DWORD)cchPath, (DWORD)(lpEnd - lpPath + 1)));

    szPath[lpEnd-lpPath] = TEXT('\0');

    PathRemoveBlanks(szPath);

    if (szPath[0])
    {
        if (*lpEnd == TEXT(';'))
        {
            // next path string (maybe NULL)
            return lpEnd + 1;
        }
        else
        {
            // pointer to NULL
            return lpEnd;
        }
    }
    else 
    {
        return NULL;
    }
}


// check to see if a dir is on the other dir list
// use this to avoid looking in the same directory twice (don't make the same dos call)

BOOL IsOtherDir(LPCTSTR pszPath, LPCTSTR *ppszOtherDirs)
{
    for (;*ppszOtherDirs; ppszOtherDirs++)
    {
        if (lstrcmpi(pszPath, *ppszOtherDirs) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}

//----------------------------------------------------------------------------
// fully qualify a path by walking the path and optionally other dirs
//
// in:
//      ppszOtherDirs a list of LPCTSTRs to other paths to look
//      at first, NULL terminated.
//
//  fExt
//      PFOPEX_ flags specifying what to look for (exe, com, bat, lnk, pif)
//
// in/out
//      pszFile     non qualified path, returned fully qualified
//                      if found (return was TRUE), otherwise unaltered
//                      (return FALSE);
//
// returns:
//      TRUE        the file was found on and qualified
//      FALSE       the file was not found
//
STDAPI_(BOOL) PathFindOnPathEx(LPTSTR pszFile, LPCTSTR* ppszOtherDirs, UINT fExt)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szFullPath[256];       // Default size for buffer
    LPTSTR pszEnv = NULL;        // Use if greater than default
    LPCTSTR lpPath;
    int i;

    RIPMSG(pszFile && IS_VALID_STRING_PTR(pszFile, -1) && IS_VALID_WRITE_BUFFER(pszFile, TCHAR, MAX_PATH), "PathFindOnPathEx: caller passed bad pszFile");
    DEBUGWhackPathString(pszFile, MAX_PATH);

    if (!pszFile) // REVIEW: do we need to check !*pszFile too?
        return FALSE;

    // REVIEW, we may want to just return TRUE here but for
    // now assume only file specs are allowed

    if (!PathIsFileSpec(pszFile))
        return FALSE;

    // first check list of other dirs

    for (i = 0; ppszOtherDirs && ppszOtherDirs[i] && *ppszOtherDirs[i]; i++)
    {
        PathCombine(szPath, ppszOtherDirs[i], pszFile);
        if (PathFileExistsDefExt(szPath, fExt))
        {
            lstrcpy(pszFile, szPath);
            return TRUE;
        }
    }

    // Look in system dir (system for Win95, system32 for NT)
    //  - this should probably be optional.
    GetSystemDirectory(szPath, ARRAYSIZE(szPath));
    if (!PathAppend(szPath, pszFile))
        return FALSE;

    if (PathFileExistsDefExt(szPath, fExt))
    {
        lstrcpy(pszFile, szPath);
        return TRUE;
    }

    if (g_bRunningOnNT)
    {

#ifdef WX86
        // Look in WX86 system  directory (WindDir\Sys32x86)
        if (g_bRunningOnNT5OrHigher)
        {
            NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = TRUE;
            GetSystemDirectory(szPath, ARRAYSIZE(szPath));
            NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;

            if (!PathAppend(szPath, pszFile))
                return FALSE;

            if (PathFileExistsDefExt(szPath, fExt))
            {
                lstrcpy(pszFile, szPath);
                return TRUE;
            }
        }
#endif

        // Look in WOW directory (\nt\system instead of \nt\system32)
        GetWindowsDirectory(szPath, ARRAYSIZE(szPath));

        if (!PathAppend(szPath,TEXT("System")))
            return FALSE;
        if (!PathAppend(szPath, pszFile))
            return FALSE;

        if (PathFileExistsDefExt(szPath, fExt))
        {
            lstrcpy(pszFile, szPath);
            return TRUE;
        }
    }

#ifdef UNIX
    // AR: Varma: IEUNIX: Look in user windows dir - this should probably be optional.
    MwGetUserWindowsDirectory(szPath, ARRAYSIZE(szPath));
    if (!PathAppend(szPath, pszFile))
        return FALSE;

    if (PathFileExistsDefExt(szPath, fExt))
    {
        lstrcpy(pszFile, szPath);
        return TRUE;
    }
#endif

    // Look in windows dir - this should probably be optional.
    GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
    if (!PathAppend(szPath, pszFile))
        return FALSE;

    if (PathFileExistsDefExt(szPath, fExt))
    {
        lstrcpy(pszFile, szPath);
        return TRUE;
    }

    // Look along the path.
    i = GetEnvironmentVariable(c_szPATH, szFullPath, ARRAYSIZE(szFullPath));
    if (i >= ARRAYSIZE(szFullPath))
    {
        pszEnv = (LPTSTR)LocalAlloc(LPTR, i*SIZEOF(TCHAR)); // no need for +1, i includes it
        if (pszEnv == NULL)
            return FALSE;

        GetEnvironmentVariable(c_szPATH, pszEnv, i);

        lpPath = pszEnv;
    }
    else
    {
        if (i == 0)
            return FALSE;

        lpPath = szFullPath;
    }

    while (NULL != (lpPath = NextPath(lpPath, szPath, ARRAYSIZE(szPath))))
    {
        if (!ppszOtherDirs || !IsOtherDir(szPath, ppszOtherDirs))
        {
            PathAppend(szPath, pszFile);
            if (PathFileExistsDefExt(szPath, fExt))
            {
                lstrcpy(pszFile, szPath);
                if (pszEnv)
                    LocalFree((HLOCAL)pszEnv);
                return TRUE;
            }
        }
    }

    if (pszEnv)
        LocalFree((HLOCAL)pszEnv);

    return FALSE;
}


/*----------------------------------------------------------
Purpose: Find the given file on the path.

Returns:
Cond:    --
*/
STDAPI_(BOOL) PathFindOnPath(LPTSTR pszFile, LPCTSTR* ppszOtherDirs)
{
    return PathFindOnPathEx(pszFile, ppszOtherDirs, PFOPEX_NONE);
}


// returns a pointer to the extension of a file.
//
// in:
//      qualified or unqualfied file name
//
// returns:
//      pointer to the extension of this file.  if there is no extension
//      as in "foo" we return a pointer to the NULL at the end
//      of the file
//
//      foo.txt     ==> ".txt"
//      foo         ==> ""
//      foo.        ==> "."
//
STDAPI_(LPTSTR) PathFindExtension(LPCTSTR pszPath)
{
    LPCTSTR pszDot = NULL;

    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathFindExtension: caller passed bad pszPath");

    if (pszPath)
    {
        for (; *pszPath; pszPath = FAST_CharNext(pszPath))
        {
            switch (*pszPath)
            {
                case TEXT('.'):
                    pszDot = pszPath;   // remember the last dot
                    break;

                case CH_WHACK:
                case TEXT(' '):         // extensions can't have spaces
                    pszDot = NULL;      // forget last dot, it was in a directory
                    break;
            }
        }
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension) (cast->non const)
    return pszDot ? (LPTSTR)pszDot : (LPTSTR)pszPath;
}


//
// Find if a given pathname contains any one of the suffixes in a given array of suffixes
//
// in:
//      pszPath     A filename with or without a path.
//
//      apszSuffix   An array of suffixes that we are looking for.
//
// returns:
//      pointer to the suffix in pszPath, if it exists.
//      NULL is returned if the given path does not end with the given suffix.
//
//  NOTE:  This does a CASE SENSITIVE comparison!!! So, the suffix will have to match exactly.
//
STDAPI_(LPCTSTR) PathFindSuffixArray(LPCTSTR pszPath, const LPCTSTR* apszSuffix, int iArraySize)
{
    RIPMSG((iArraySize>=0 && (pszPath && IS_VALID_STRING_PTR(pszPath, -1) && apszSuffix)), "PathFindSuffixArray: caller passed bad parameters");

    if (pszPath && apszSuffix)
    {
        int     iLenSuffix;
        int     iLenPath   = lstrlen(pszPath);
        LPCTSTR pszTail;
        int     i;

        for(i = 0; i< iArraySize; i++)
        {
            iLenSuffix = lstrlen(apszSuffix[i]);
            if(iLenPath < iLenSuffix)
                continue;

            // Let's get to a pointer to the tail piece which is the same length as the suffix
            // we are looking for.
            pszTail = (LPCTSTR)(pszPath+iLenPath-iLenSuffix);

#ifndef UNICODE
            {
                LPCSTR  pszTemp = pszTail;
            
                // In the ANSI world, pszTemp could be in the middle of a DBCS character.
                // So, move pszTemp such that it points to the begining of a valid character Lead char.
                while(pszTemp > pszPath)
                {
                    pszTemp--;
                    if(!IsDBCSLeadByte(*pszTemp))
                    {
                        // Since pszTemp is pointing to the FIRST trail Byte, the next byte must be a
                        // valid character. Move pszTemp to point to a valid character.
                        pszTemp++;
                        break;
                    }
                }

                // Everything between pszTemp and pszTail is nothing but lead characters. So, see if they 
                // are Odd or Even number of them.
                if(((int)(pszTail - pszTemp)&1) && (pszTail > pszPath))
                {
                    // There are odd number of lead bytes. That means that pszTail is definitely in the
                    // middle of a DBCS character. Move it to such that it points to a valid char.
                    pszTail--;
                }
            }
#endif

            if(!lstrcmp(pszTail, apszSuffix[i]))
                return pszTail;
        }
    }

    //Given suffix is not found in the array!
    return NULL;
}


// add .exe to a file name (if no extension was already there)
//
// in:
//      pszExtension    extension to tag on, if NULL .exe is assumed
//                      (".bat", ".txt", etc)
//
// in/out:
//      pszPath     path string to modify
//
//
// returns:
//      TRUE    added .exe (there was no extension to begin with)
//      FALSE   didn't change the name (it already had an extension)

STDAPI_(BOOL) PathAddExtension(LPTSTR pszPath, LPCTSTR pszExtension)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1) && IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathAddExtension: caller passed bad pszPath");
    RIPMSG(!pszExtension || IS_VALID_STRING_PTR(pszExtension, -1), "PathAddExtension: caller passed bad pszExtension");
    DEBUGWhackPathString(pszPath, MAX_PATH);

    if (pszPath)
    {
        if (*PathFindExtension(pszPath) == 0 && ((lstrlen(pszPath) + lstrlen(pszExtension ? pszExtension : c_szDotExe)) < MAX_PATH))
        {
            if (pszExtension == NULL)
                pszExtension = c_szDotExe;
            lstrcat(pszPath, pszExtension);
            return TRUE;
        }
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Remove the extension from pszPath, if one exists.

Returns: --
Cond:    --
*/
STDAPI_(void) PathRemoveExtension(LPTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathRemoveExtension: caller passed bad pszPath");

    if (pszPath)
    {
        LPTSTR pExt = PathFindExtension(pszPath);
        if (*pExt)
        {
            ASSERT(*pExt == TEXT('.'));
            *pExt = 0;    // null out the "."
        }
    }
}


/*----------------------------------------------------------
Purpose: Renames the extension

Returns: FALSE if not enough room
Cond:    --
*/
STDAPI_(BOOL) PathRenameExtension(LPTSTR  pszPath, LPCTSTR pszExt)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1) && IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathRenameExtension: caller passed bad pszPath");
    RIPMSG(pszExt && IS_VALID_STRING_PTR(pszExt, -1), "PathRenameExtension: caller passed bad pszExt");
    DEBUGWhackPathString(pszPath, MAX_PATH);

    if (pszPath && pszExt)
    {
        LPTSTR pExt = PathFindExtension(pszPath);  // Rets ptr to end of str if none
        if (pExt - pszPath + lstrlen(pszExt) > MAX_PATH - 1)
        {
            return FALSE;
        }
        lstrcpy(pExt, pszExt);
        return TRUE;
    }
    return FALSE;
}


// find the next slash or null terminator
LPCTSTR StrSlash(LPCTSTR psz)
{
    for (; *psz && *psz != CH_WHACK; psz = FAST_CharNext(psz));

    return psz;
}


//
// in:
//      pszFile1 -- fully qualified path name to file #1.
//      pszFile2 -- fully qualified path name to file #2.
//
// out:
//      pszPath  -- pointer to a string buffer (may be NULL)
//
// returns:
//      length of output buffer not including the NULL
//
// examples:
//      c:\win\desktop\foo.txt
//      c:\win\tray\bar.txt
//      -> c:\win
//
//      c:\                                ;
//      c:\                                ;
//      -> c:\  NOTE, includes slash
//
// Returns:
//      Length of the common prefix string usually does NOT include
//      trailing slash, BUT for roots it does.
//
STDAPI_(int) PathCommonPrefix(LPCTSTR pszFile1, LPCTSTR pszFile2, LPTSTR  pszPath)
{
    RIPMSG(pszFile1 && IS_VALID_STRING_PTR(pszFile1, -1), "PathCommonPrefix: caller passed bad pszFile1");
    RIPMSG(pszFile2 && IS_VALID_STRING_PTR(pszFile2, -1), "PathCommonPrefix: caller passed bad pszFile2");
    RIPMSG(!pszPath || IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathCommonPrefix: caller passed bad pszPath");

    if (pszFile1 && pszFile2)
    {
        LPCTSTR psz1, psz2, pszNext1, pszNext2, pszCommon;
        int cch;

        pszCommon = NULL;
        if (pszPath)
            *pszPath = TEXT('\0');

        psz1 = pszFile1;
        psz2 = pszFile2;

        // special cases for UNC, don't allow "\\" to be a common prefix

        if (DBL_BSLASH(pszFile1))
        {
            if (!DBL_BSLASH(pszFile2))
                return 0;

            psz1 = pszFile1 + 2;
        }
        if (DBL_BSLASH(pszFile2))
        {
            if (!DBL_BSLASH(pszFile1))
                return 0;

            psz2 = pszFile2 + 2;
        }

        while (1)
        {
            if (!(*psz1 != CH_WHACK && *psz2 != CH_WHACK))
                TraceMsg(TF_WARNING, "PathCommonPrefix: caller passed in ill-formed or non-qualified path");

            pszNext1 = StrSlash(psz1);
            pszNext2 = StrSlash(psz2);

            cch = (int) (pszNext1 - psz1);

            if (cch != (pszNext2 - psz2))
                break;      // lengths of segments not equal

            if (StrIntlEqNI(psz1, psz2, cch))
                pszCommon = pszNext1;
            else
                break;

            ASSERT(*pszNext1 == TEXT('\0') || *pszNext1 == CH_WHACK);
            ASSERT(*pszNext2 == TEXT('\0') || *pszNext2 == CH_WHACK);

            if (*pszNext1 == TEXT('\0'))
                break;

            psz1 = pszNext1 + 1;

            if (*pszNext2 == TEXT('\0'))
                break;

            psz2 = pszNext2 + 1;
        }

        if (pszCommon)
        {
            cch = (int) (pszCommon - pszFile1);

            // special case the root to include the slash
            if (cch == 2)
            {
                ASSERT(pszFile1[1] == TEXT(':'));
                cch++;
            }
        }
        else
            cch = 0;

        if (pszPath)
        {
            CopyMemory(pszPath, pszFile1, cch * SIZEOF(TCHAR));
            pszPath[cch] = TEXT('\0');
        }

        return cch;
    }

    return 0;
}


/*----------------------------------------------------------
Purpose: Returns TRUE if pszPrefix is the full prefix of pszPath.

Returns:
Cond:    --
*/
STDAPI_(BOOL) PathIsPrefix(IN LPCTSTR  pszPrefix, IN LPCTSTR  pszPath)
{
    RIPMSG(pszPrefix && IS_VALID_STRING_PTR(pszPrefix, -1), "PathIsPrefix: caller passed bad pszPrefix");
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsPrefix: caller passed bad pszPath");

    if (pszPrefix && pszPath)
    {
        int cch = PathCommonPrefix(pszPath, pszPrefix, NULL);

        return (lstrlen(pszPrefix) == cch);
    }
    return FALSE;
}


static const TCHAR c_szDot[] = TEXT(".");
static const TCHAR c_szDotDot[] = TEXT("..");

#ifdef UNIX
static const TCHAR c_szDotDotSlash[] = TEXT("../");
#else
static const TCHAR c_szDotDotSlash[] = TEXT("..\\");
#endif


// in:
//      pszFrom         base path, including filespec!
//      pszTo           path to be relative to pszFrom
// out:
//      relative path to construct pszTo from the base path of pszFrom
//
//      c:\a\b\FileA
//      c:\a\x\y\FileB
//      -> ..\x\y\FileB
//
STDAPI_(BOOL) PathRelativePathTo(LPTSTR pszPath, LPCTSTR pszFrom, DWORD dwAttrFrom, LPCTSTR pszTo, DWORD dwAttrTo)
{
#ifdef DEBUG
    TCHAR szFromCopy[MAX_PATH];
    TCHAR szToCopy[MAX_PATH];

    RIPMSG(pszPath && IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathRelativePathTo: caller passed bad pszPath");
    RIPMSG(pszFrom && IS_VALID_STRING_PTR(pszFrom, -1), "PathRelativePathTo: caller passed bad pszFrom");
    RIPMSG(pszTo && IS_VALID_STRING_PTR(pszTo, -1), "PathRelativePathTo: caller passed bad pszTo");

    // we make copies of the pszFrom and pszTo buffers in case one of the strings they are passing is a pointer
    // inside pszPath buffer. If this were the case, it would be trampled when we call DEBUGWhackPathBuffer().
    if (pszFrom)
    {
        lstrcpyn(szFromCopy, pszFrom, ARRAYSIZE(szFromCopy));
        pszFrom = szFromCopy;
    }
    
    if (pszTo)
    {
        lstrcpyn(szToCopy, pszTo, ARRAYSIZE(szToCopy));
        pszTo = szToCopy;
    }
#endif DEBUG


    if (pszPath && pszFrom && pszTo)
    {
        TCHAR szFrom[MAX_PATH], szTo[MAX_PATH];
        LPTSTR psz;
        UINT cchCommon;

        DEBUGWhackPathBuffer(pszPath, MAX_PATH);

        *pszPath = 0;       // assume none

        lstrcpyn(szFrom, pszFrom, ARRAYSIZE(szFrom));
        lstrcpyn(szTo, pszTo, ARRAYSIZE(szTo));

        if (!(dwAttrFrom & FILE_ATTRIBUTE_DIRECTORY))
            PathRemoveFileSpec(szFrom);

        if (!(dwAttrTo & FILE_ATTRIBUTE_DIRECTORY))
            PathRemoveFileSpec(szTo);

        cchCommon = PathCommonPrefix(szFrom, szTo, NULL);
        if (cchCommon == 0)
            return FALSE;

        psz = szFrom + cchCommon;

        if (*psz)
        {
            // build ..\.. part of the path
            if (*psz == CH_WHACK)
                psz++;              // skip slash
            while (*psz)
            {
                psz = PathFindNextComponent(psz);
                // WARNING: in a degenerate case where each path component
                // is 1 character (less than "..\") we can overflow pszPath
                lstrcat(pszPath, *psz ? c_szDotDotSlash : c_szDotDot);
            }
        }
        else
        {
            lstrcpy(pszPath, c_szDot);
        }
        if (pszTo[cchCommon])
        {
            // deal with root case
            if (pszTo[cchCommon] != CH_WHACK)
                cchCommon--;

            if ((lstrlen(pszPath) + lstrlen(pszTo + cchCommon)) >= MAX_PATH)
            {
                TraceMsg(TF_ERROR, "PathRelativePathTo: path won't fit in buffer");
                *pszPath = 0;
                return FALSE;
            }

            ASSERT(pszTo[cchCommon] == CH_WHACK);
            lstrcat(pszPath, pszTo + cchCommon);
        }

        ASSERT(PathIsRelative(pszPath));
        ASSERT(lstrlen(pszPath) < MAX_PATH);

        return TRUE;
    }

    return FALSE;
}


/*----------------------------------------------------------
Purpose: Build a root path name given a drive number.

Returns: pszRoot
*/
STDAPI_(LPTSTR) PathBuildRoot(LPTSTR pszRoot, int iDrive)
{
    RIPMSG(pszRoot && IS_VALID_WRITE_BUFFER(pszRoot, TCHAR, 4), "PathBuildRoot: caller passed bad pszRoot");
    RIPMSG(iDrive >= 0 && iDrive < 26, "PathBuildRoot: caller passed bad iDrive");

    if (pszRoot && iDrive >= 0 && iDrive < 26)
    {
#ifndef UNIX
        pszRoot[0] = (TCHAR)iDrive + (TCHAR)TEXT('A');
        pszRoot[1] = TEXT(':');
        pszRoot[2] = TEXT('\\');
        pszRoot[3] = 0;
#else
        pszRoot[0] = CH_WHACK;
        pszRoot[1] = 0;
#endif
    }

    return pszRoot;
}


// Strips leading and trailing blanks from a string.
// Alters the memory where the string sits.
//
// in:
//  lpszString  string to strip
//
// out:
//  lpszString  string sans leading/trailing blanks
//
STDAPI_(void) PathRemoveBlanks(LPTSTR lpszString)
{
    RIPMSG(lpszString && IS_VALID_STRING_PTR(lpszString, -1), "PathRemoveBlanks: caller passed bad lpszString");

    if (lpszString)
    {
        LPTSTR lpszPosn = lpszString;

        /* strip leading blanks */
        while (*lpszPosn == TEXT(' '))
        {
            lpszPosn++;
        }

        if (lpszPosn != lpszString)
        {
            lstrcpy(lpszString, lpszPosn);
        }

        /* strip trailing blanks */

        // Find the last non-space
        // Note that AnsiPrev is cheap is non-DBCS, but very expensive otherwise
        for (lpszPosn=lpszString; *lpszString; lpszString=FAST_CharNext(lpszString))
        {
            if (*lpszString != TEXT(' '))
            {
                lpszPosn = lpszString;
            }
        }

        // Note AnsiNext is a macro for non-DBCS, so it will not stop at NULL
        if (*lpszPosn)
        {
            *FAST_CharNext(lpszPosn) = TEXT('\0');
        }
    }
}


// Removes a trailing backslash from a path
//
// in:
//  lpszPath    (A:\, C:\foo\, etc)
//
// out:
//  lpszPath    (A:\, C:\foo, etc)
//
// returns:
//  ponter to NULL that replaced the backslash
//  or the pointer to the last character if it isn't a backslash.
//
STDAPI_(LPTSTR) PathRemoveBackslash(LPTSTR lpszPath)
{
    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1), "PathRemoveBackslash: caller passed bad lpszPath");

    if (lpszPath)
    {
        int len = lstrlen(lpszPath)-1;
        if (IsDBCSLeadByte(*CharPrev(lpszPath,lpszPath+len+1)))
            len--;

        if (!PathIsRoot(lpszPath) && lpszPath[len] == CH_WHACK)
            lpszPath[len] = TEXT('\0');

        return lpszPath + len;
    }
    return NULL;
}


//
// Return a pointer to the end of the next path componenent in the string.
// ie return a pointer to the next backslash or terminating NULL.
//
LPCTSTR GetPCEnd(LPCTSTR lpszStart)
{
    LPCTSTR lpszEnd;

    lpszEnd = StrChr(lpszStart, CH_WHACK);
    if (!lpszEnd)
    {
        lpszEnd = lpszStart + lstrlen(lpszStart);
    }

    return lpszEnd;
}


//
// Given a pointer to the end of a path component, return a pointer to
// its begining.
// ie return a pointer to the previous backslash (or start of the string).
//
LPCTSTR PCStart(LPCTSTR lpszStart, LPCTSTR lpszEnd)
{
    LPCTSTR lpszBegin = StrRChr(lpszStart, lpszEnd, CH_WHACK);
    if (!lpszBegin)
    {
        lpszBegin = lpszStart;
    }
    return lpszBegin;
}


//
// Fix up a few special cases so that things roughly make sense.
//
void NearRootFixups(LPTSTR lpszPath, BOOL fUNC)
{
    // Check for empty path.
    if (lpszPath[0] == TEXT('\0'))
    {
        // Fix up.
        lpszPath[0] = CH_WHACK;
        lpszPath[1] = TEXT('\0');
    }
    // Check for missing slash.
    if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == TEXT(':') && lpszPath[2] == TEXT('\0'))
    {
        // Fix up.
        lpszPath[2] = TEXT('\\');
        lpszPath[3] = TEXT('\0');
    }
    // Check for UNC root.
    if (fUNC && lpszPath[0] == TEXT('\\') && lpszPath[1] == TEXT('\0'))
    {
        // Fix up.
        //lpszPath[0] = TEXT('\\'); // already checked in if guard
        lpszPath[1] = TEXT('\\');
        lpszPath[2] = TEXT('\0');
    }
}


/*----------------------------------------------------------
Purpose: Canonicalize a path.

Returns:
Cond:    --
*/
STDAPI_(BOOL) PathCanonicalize(LPTSTR lpszDst, LPCTSTR lpszSrc)
{
    LPCTSTR lpchSrc;
    LPCTSTR lpchPCEnd;      // Pointer to end of path component.
    LPTSTR lpchDst;
    BOOL fUNC;
    int cchPC;

    RIPMSG(lpszDst && IS_VALID_WRITE_BUFFER(lpszDst, TCHAR, MAX_PATH), "PathCanonicalize: caller passed bad lpszDst");
    RIPMSG(lpszSrc && IS_VALID_STRING_PTR(lpszSrc, -1), "PathCanonicalize: caller passed bad lpszSrc");
    RIPMSG(lpszDst != lpszSrc, "PathCanonicalize: caller passed the same buffer for lpszDst and lpszSrc");

    if (!lpszDst || !lpszSrc)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DEBUGWhackPathBuffer(lpszDst, MAX_PATH);
    *lpszDst = TEXT('\0');
    
    fUNC = PathIsUNC(lpszSrc);    // Check for UNCness.

    // Init.
    lpchSrc = lpszSrc;
    lpchDst = lpszDst;

    while (*lpchSrc)
    {
        // REVIEW: this should just return the count
        lpchPCEnd = GetPCEnd(lpchSrc);
        cchPC = (int) (lpchPCEnd - lpchSrc)+1;

        if (cchPC == 1 && *lpchSrc == CH_WHACK)                                      // Check for slashes.
        {
            // Just copy them.
            *lpchDst = CH_WHACK;
            lpchDst++;
            lpchSrc++;
        }
        else if (cchPC == 2 && *lpchSrc == TEXT('.'))                                // Check for dots.
        {
            // Skip it...
            // Are we at the end?
            if (*(lpchSrc+1) == TEXT('\0'))
            {
                lpchSrc++;

                // remove the last slash we copied (if we've copied one), but don't make a mal-formed root
                if ((lpchDst > lpszDst) && !PathIsRoot(lpszDst))
                    lpchDst--;
            }
            else
            {
                lpchSrc += 2;
            }
        }
        else if (cchPC == 3 && *lpchSrc == TEXT('.') && *(lpchSrc + 1) == TEXT('.')) // Check for dot dot.
        {
            // make sure we aren't already at the root
            if (!PathIsRoot(lpszDst))
            {
                // Go up... Remove the previous path component.
                lpchDst = (LPTSTR)PCStart(lpszDst, lpchDst - 1);
            }
            else
            {
                // When we can't back up, skip the trailing backslash
                // so we don't copy one again. (C:\..\FOO would otherwise
                // turn into C:\\FOO).
                if (*(lpchSrc + 2) == CH_WHACK)
                {
                    lpchSrc++;
                }
            }

            // skip ".."
            lpchSrc += 2;       
        }
        else                                                                        // Everything else
        {
            // Just copy it.
            lstrcpyn(lpchDst, lpchSrc, cchPC);
            lpchDst += cchPC - 1;
            lpchSrc += cchPC - 1;
        }

        // Keep everything nice and tidy.
        *lpchDst = TEXT('\0');
    }

    // Check for weirdo root directory stuff.
    NearRootFixups(lpszDst, fUNC);

    return TRUE;
}


// Modifies:
//      pszRoot
//
// Returns:
//      TRUE if a drive root was found
//      FALSE otherwise
//
STDAPI_(BOOL) PathStripToRoot(LPTSTR pszRoot)
{
    RIPMSG(pszRoot && IS_VALID_STRING_PTR(pszRoot, -1), "PathStripToRoot: caller passed bad pszRoot");

    if (pszRoot)
    {
        while (!PathIsRoot(pszRoot))
        {
            if (!PathRemoveFileSpec(pszRoot))
            {
                // If we didn't strip anything off,
                // must be current drive
                return FALSE;
            }
        }
        return TRUE;
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Concatenate lpszDir and lpszFile into a properly formed
         path and canonicalize any relative path pieces.

         lpszDest and lpszFile can be the same buffer
         lpszDest and lpszDir can be the same buffer

Returns: pointer to lpszDest
*/
STDAPI_(LPTSTR) PathCombine(LPTSTR lpszDest, LPCTSTR lpszDir, LPCTSTR lpszFile)
{
#ifdef DEBUG
    TCHAR szDirCopy[MAX_PATH];
    TCHAR szFileCopy[MAX_PATH];

    RIPMSG(lpszDest && IS_VALID_WRITE_BUFFER(lpszDest, TCHAR, MAX_PATH), "PathCombine: caller passed bad lpszDest");
    RIPMSG(!lpszDir || IS_VALID_STRING_PTR(lpszDir, -1), "PathCombine: caller passed bad lpszDir");
    RIPMSG(!lpszFile || IS_VALID_STRING_PTR(lpszFile, -1), "PathCombine: caller passed bad lpszFile");
    RIPMSG(lpszDir || lpszFile, "PathCombine: caller neglected to pass lpszDir or lpszFile");

    // we make copies of all the lpszDir and lpszFile buffers in case one of the strings they are passing is a pointer
    // inside lpszDest buffer. If this were the case, it would be trampled when we call DEBUGWhackPathBuffer().
    if (lpszDir)
    {
        lstrcpyn(szDirCopy, lpszDir, ARRAYSIZE(szDirCopy));
        lpszDir = szDirCopy;
    }
    
    if (lpszFile)
    {
        lstrcpyn(szFileCopy, lpszFile, ARRAYSIZE(szFileCopy));
        lpszFile = szFileCopy;
    }

    // lpszDest could be lpszDir, so be careful which one we call
    if (lpszDest != lpszDir && lpszDest != lpszFile)
        DEBUGWhackPathBuffer(lpszDest, MAX_PATH);
    else if (lpszDest)
        DEBUGWhackPathString(lpszDest, MAX_PATH);
#endif DEBUG


    if (lpszDest)
    {
        TCHAR szTemp[MAX_PATH];
        LPTSTR pszT;

        *szTemp = TEXT('\0');

        if (lpszDir && *lpszDir)
        {
            if (!lpszFile || *lpszFile==TEXT('\0'))
            {
                lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));       // lpszFile is empty
            }
            else if (PathIsRelative(lpszFile))
            {
                lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));
                pszT = PathAddBackslash(szTemp);
                if (pszT)
                {
                    int iRemaining = (int)(ARRAYSIZE(szTemp) - (pszT - szTemp));

                    if (lstrlen(lpszFile) < iRemaining)
                    {
                        lstrcpyn(pszT, lpszFile, iRemaining);
                    }
                    else
                    {
                        *szTemp = TEXT('\0');
                    }
                }
                else
                {
                    *szTemp = TEXT('\0');
                }
            }
            else if (*lpszFile == CH_WHACK && !PathIsUNC(lpszFile))
            {
                lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));
                // FEATURE: Note that we do not check that an actual root is returned;
                // it is assumed that we are given valid parameters
                PathStripToRoot(szTemp);

                pszT = PathAddBackslash(szTemp);
                if (pszT)
                {
                    // Skip the backslash when copying
                    // Note: We don't support strings longer than 4GB, but that's
                    // okay because we already barf at MAX_PATH
                    lstrcpyn(pszT, lpszFile+1, (int)(ARRAYSIZE(szTemp) - (pszT - szTemp)));
                }
                else
                {
                    *szTemp = TEXT('\0');
                }
            }
            else
            {
                lstrcpyn(szTemp, lpszFile, ARRAYSIZE(szTemp));     // already fully qualified file part
            }
        }
        else if (lpszFile && *lpszFile)
        {
            lstrcpyn(szTemp, lpszFile, ARRAYSIZE(szTemp));     // no dir just use file.
        }

        //
        // if szTemp has something in it we succeeded.  Also if szTemp is empty and
        // the input strings are empty we succeed and PathCanonicalize() will
        // return "\"
        // 
        if (*szTemp || ((lpszDir || lpszFile) && !((lpszDir && *lpszDir) || (lpszFile && *lpszFile))))
        {
            PathCanonicalize(lpszDest, szTemp); // this deals with .. and . stuff
                                                // returns "\" on empty szTemp
        }
        else
        {
            *lpszDest = TEXT('\0');   // set output buffer to empty string.
            lpszDest  = NULL;         // return failure.
        }
    }

    return lpszDest;
}


/*----------------------------------------------------------
Purpose: Appends a filename to a path.  Checks the \ problem first
          (which is why one can't just use lstrcat())
         Also don't append a \ to : so we can have drive-relative paths...
         this last bit is no longer appropriate since we qualify first!

Returns:
*/
STDAPI_(BOOL) PathAppend(LPTSTR pszPath, LPCTSTR pszMore)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1) && IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH), "PathAppend: caller passed bad pszPath");
    RIPMSG(pszMore && IS_VALID_STRING_PTR(pszMore, -1), "PathAppend: caller passed bad pszMore");
    // PathCombine will do this for us: DEBUGWhackPathString(pszPath, MAX_PATH);

    if (pszPath && pszMore)
    {
        // Skip any initial terminators on input, unless it is a UNC path in wich case we will 
        // treat it as a full path
        if (!PathIsUNC(pszMore))
        {
            while (*pszMore == CH_WHACK)
            {
#ifndef UNICODE
                pszMore = FAST_CharNext(pszMore);
#else
                pszMore++;
#endif
            }
        }

        return PathCombine(pszPath, pszPath, pszMore) ? TRUE : FALSE;
    }
    
    return FALSE;
}


// rips the last part of the path off including the backslash
//      C:\foo      -> C:\
//      C:\foo\bar  -> C:\foo
//      C:\foo\     -> C:\foo
//      \\x\y\x     -> \\x\y
//      \\x\y       -> \\x
//      \\x         -> \\ (Just the double slash!)
//      \foo        -> \  (Just the slash!)
//
// in/out:
//      pFile   fully qualified path name
// returns:
//      TRUE    we stripped something
//      FALSE   didn't strip anything (root directory case)
//
STDAPI_(BOOL) PathRemoveFileSpec(LPTSTR pFile)
{
    RIPMSG(pFile && IS_VALID_STRING_PTR(pFile, -1), "PathRemoveFileSpec: caller passed bad pFile");

    if (pFile)
    {
        LPTSTR pT;
        LPTSTR pT2 = pFile;

        for (pT = pT2; *pT2; pT2 = FAST_CharNext(pT2))
        {
            if (*pT2 == CH_WHACK)
            {
                pT = pT2;             // last "\" found, (we will strip here)
            }
            else if (*pT2 == TEXT(':'))     // skip ":\" so we don't
            {
                if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\"
                {
                    pT2++;
                }
                pT = pT2 + 1;
            }
        }

        if (*pT == 0)
        {
            // didn't strip anything
            return FALSE;
        }
        else if (((pT == pFile) && (*pT == CH_WHACK)) ||                        //  is it the "\foo" case?
                 ((pT == pFile+1) && (*pT == CH_WHACK && *pFile == CH_WHACK)))  //  or the "\\bar" case?
        {
            // Is it just a '\'?
            if (*(pT+1) != TEXT('\0'))
            {
                // Nope.
                *(pT+1) = TEXT('\0');
                return TRUE;        // stripped something
            }
            else
            {
                // Yep.
                return FALSE;
            }
        }
        else
        {
            *pT = 0;
            return TRUE;    // stripped something
        }
    }
    return  FALSE;
}



// add a backslash to a qualified path
//
// in:
//  lpszPath    path (A:, C:\foo, etc)
//
// out:
//  lpszPath    A:\, C:\foo\    ;
//
// returns:
//  pointer to the NULL that terminates the path
//
STDAPI_(LPTSTR) PathAddBackslash(LPTSTR lpszPath)
{
    LPTSTR lpszRet = NULL;

    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1), "PathAddBackslash: caller passed bad lpszPath");

    if (lpszPath)
    {
        int    ichPath = lstrlen(lpszPath);
        LPTSTR lpszEnd = lpszPath + ichPath;

        if (ichPath)
        {

            // Get the end of the source directory
            switch(*CharPrev(lpszPath, lpszEnd))
            {
                case CH_WHACK:
                    break;

                default:
                    // try to keep us from tromping over MAX_PATH in size.
                    // if we find these cases, return NULL.  Note: We need to
                    // check those places that call us to handle their GP fault
                    // if they try to use the NULL!
                    if (ichPath >= (MAX_PATH - 2)) // -2 because ichPath doesn't include NULL, and we're adding a CH_WHACK.
                    {
                        TraceMsg(TF_WARNING, "PathAddBackslash: caller passed in lpszPath > MAX_PATH, can't append whack");
                        return(NULL);
                    }

                    *lpszEnd++ = CH_WHACK;
                    *lpszEnd = TEXT('\0');
            }
        }

        lpszRet = lpszEnd;
    }

    return lpszRet;
}


// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo
//
STDAPI_(LPTSTR) PathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT = pPath;
    
    RIPMSG(pPath && IS_VALID_STRING_PTR(pPath, -1), "PathFindFileName: caller passed bad pPath");

    if (pPath)
    {
        for ( ; *pPath; pPath = FAST_CharNext(pPath))
        {
            if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':') || pPath[0] == TEXT('/'))
                && pPath[1] &&  pPath[1] != TEXT('\\')  &&   pPath[1] != TEXT('/'))
                pT = pPath + 1;
        }
    }

    return (LPTSTR)pT;   // const -> non const
}


// determine if a path is just a filespec (contains no path parts)
//
// REVIEW: we may want to count the # of elements, and make sure
// there are no illegal chars, but that is probably another routing
// PathIsValid()
//
// in:
//      lpszPath    path to look at
// returns:
//      TRUE        no ":" or "\" chars in this path
//      FALSE       there are path chars in there
//
//
STDAPI_(BOOL) PathIsFileSpec(LPCTSTR lpszPath)
{
    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1), "PathIsFileSpec: caller passed bad lpszPath");

    if (lpszPath)
    {
        for (; *lpszPath; lpszPath = FAST_CharNext(lpszPath))
        {
            if (*lpszPath == CH_WHACK || *lpszPath == TEXT(':'))
                return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}


//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path.
//
// TRUE
//      "\\foo\bar"
//      "\\foo"         <- careful
//      "\\"
// FALSE
//      "\foo"
//      "foo"
//      "c:\foo"
//
//
STDAPI_(BOOL) PathIsUNC(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsUNC: caller passed bad pszPath");

    if (pszPath)
    {
        return DBL_BSLASH(pszPath);
    }
    return FALSE;
}


//---------------------------------------------------------------------------
// Returns TRUE if the given string is a path that is on a mounted network drive    
//
// Cond:    Calls SHELL32's IsNetDrive function
//
STDAPI_(BOOL) PathIsNetworkPath(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsNetworkPath: caller passed bad pszPath");

    if (pszPath)
    {
        return DBL_BSLASH(pszPath) || IsNetDrive(PathGetDriveNumber(pszPath));
    }

    return FALSE;
}


//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path to a server only (no share name).
//
// TRUE
//      "\\foo"         <- careful
//      "\\"
// FALSE
//      "\\foo\bar"
//      "\foo"
//      "foo"
//      "c:\foo"
//
STDAPI_(BOOL) PathIsUNCServer(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsUNCServer: caller passed bad pszPath");

    if (pszPath)
    {
        if (DBL_BSLASH(pszPath))
        {
            int i = 0;
            LPTSTR szTmp;

            for (szTmp = (LPTSTR)pszPath; szTmp && *szTmp; szTmp = FAST_CharNext(szTmp) )
            {
                if (*szTmp==TEXT('\\'))
                {
                    i++;
                }
            }

            return (i == 2);
        }
    }

    return FALSE;
}


//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path to a server\share only.
//
// TRUE
//      "\\foo\bar"         <- careful
// FALSE
//      "\\foo\bar\bar"
//      "\foo"
//      "foo"
//      "c:\foo"
//
STDAPI_(BOOL) PathIsUNCServerShare(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsUNCServerShare: caller passed bad pszPath");

    if (pszPath)
    {
        if (DBL_BSLASH(pszPath))
        {
            int i = 0;
            LPTSTR szTmp;

            for (szTmp = (LPTSTR)pszPath; szTmp && *szTmp; szTmp = FAST_CharNext(szTmp) )
            {
                if (*szTmp==TEXT('\\'))
                {
                    i++;
                }
            }

            return (i == 3);
        }
    }
    return FALSE;
}


//---------------------------------------------------------------------------
// Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has
// a drive letter, otherwise returns -1.
//
//
STDAPI_(int) PathGetDriveNumber(LPCTSTR lpsz)
{
    RIPMSG(lpsz && IS_VALID_STRING_PTR(lpsz, -1), "PathGetDriveNumber: caller passed bad lpsz");

    if (lpsz)
    {
        if (!IsDBCSLeadByte(lpsz[0]) && lpsz[1] == TEXT(':'))
        {
            if (lpsz[0] >= TEXT('a') && lpsz[0] <= TEXT('z'))
            {
                return (lpsz[0] - TEXT('a'));
            }
            else if (lpsz[0] >= TEXT('A') && lpsz[0] <= TEXT('Z'))
            {
                return (lpsz[0] - TEXT('A'));
            }
        }
    }

    return -1;
}


//---------------------------------------------------------------------------
// Return TRUE if the path isn't absoulte.
//
// TRUE
//      "foo.exe"
//      ".\foo.exe"
//      "..\boo\foo.exe"
//
// FALSE
//      "\foo"
//      "c:bar"     <- be careful
//      "c:\bar"
//      "\\foo\bar"
//
STDAPI_(BOOL) PathIsRelative(LPCTSTR lpszPath)
{
    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1), "PathIsRelative: caller passed bad lpszPath");

    if (!lpszPath || *lpszPath == 0)
    {
        // The NULL path is assumed relative
        return TRUE;
    }

    if (lpszPath[0] == CH_WHACK)
    {
        // Does it begin with a slash ?
        return FALSE;
    }
    else if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == TEXT(':'))
    {
        // Does it begin with a drive and a colon ?
        return FALSE;
    }
    else
    {
        // Probably relative.
        return TRUE;
    }
}


// remove the path part from a fully qualified spec
//
// c:\foo\bar   -> bar
// c:\foo       -> foo
// c:\          -> c:\ and the like
//
STDAPI_(void) PathStripPath(LPTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathStripPath: caller passed bad pszPath");

    if (pszPath)
    {
        LPTSTR pszName = PathFindFileName(pszPath);

        if (pszName != pszPath)
        {
            lstrcpy(pszPath, pszName);
        }
    }
}

// replaces forward slashes with backslashes
// NOTE: the "AndColon" part is not implemented

STDAPI_(void) FixSlashesAndColon(LPTSTR pszPath)
{
    // walk the entire path string, keep track of last
    // char in the path
    for (; *pszPath; pszPath = FAST_CharNext(pszPath))
    {
#ifdef UNIX
        if (*pszPath == TEXT('\\'))
#else
        if (*pszPath == TEXT('/'))
#endif
        {
            *pszPath = CH_WHACK;
        }
    }
}


#ifdef DEBUG
BOOL IsFullPath(LPCTSTR pcszPath)
{
    BOOL bResult = FALSE;
    TCHAR rgchFullPath[MAX_PATH];

    if (IS_VALID_STRING_PTR(pcszPath, -1) && EVAL(lstrlen(pcszPath) < MAX_PATH))
    {
        DWORD dwPathLen;
        LPTSTR pszFileName;

        dwPathLen = GetFullPathName(pcszPath, SIZECHARS(rgchFullPath),
                                    rgchFullPath, &pszFileName);

        if (EVAL(dwPathLen > 0) &&
            EVAL(dwPathLen < SIZECHARS(rgchFullPath)))
            bResult = EVAL(! lstrcmpi(pcszPath, rgchFullPath));
    }

    return(bResult);
}
#endif // DEBUG


/*----------------------------------------------------------
Purpose: Fully qualify a path and search for it.

Returns: TRUE if the path is qualified
         FALSE if not

Cond:    --
*/
STDAPI_(BOOL) PathSearchAndQualify(LPCTSTR pcszPath, LPTSTR pszFullyQualifiedPath, UINT cchFullyQualifiedPath)
{
    BOOL bRet = FALSE;

    RIPMSG(pcszPath && IS_VALID_STRING_PTR(pcszPath, -1), "PathSearchAndQualify: caller passed bad pcszPath");
    RIPMSG(IS_VALID_WRITE_BUFFER(pszFullyQualifiedPath, TCHAR, cchFullyQualifiedPath), "PathSearchAndQualify: caller passed bad pszFullyQualifiedPath");
    DEBUGWhackPathBuffer(pszFullyQualifiedPath, cchFullyQualifiedPath);

    if (pcszPath && ((cchFullyQualifiedPath == 0) || pszFullyQualifiedPath))
    {
        LPTSTR pszFileName;
        
        /* Any path separators? */
        if (!StrPBrk(pcszPath, TEXT(":/\\")))
        {
            /* No.  Search for file. */
            bRet = (SearchPath(NULL, pcszPath, NULL, cchFullyQualifiedPath, pszFullyQualifiedPath, &pszFileName) > 0);
        }

        if (!bRet && (GetFullPathName(pcszPath, cchFullyQualifiedPath, pszFullyQualifiedPath, &pszFileName) > 0))
        {
            bRet = TRUE;
        }

        if ( !bRet )
        {
            if (cchFullyQualifiedPath > 0)
            {
                *pszFullyQualifiedPath = '\0';
            }
        }
        
        ASSERT((bRet && IsFullPath(pszFullyQualifiedPath)) ||
               (!bRet && (!cchFullyQualifiedPath || !*pszFullyQualifiedPath)));
    }

    return bRet;
}


// check if a path is a root
//
// returns:
//  TRUE 
//      "\" "X:\" "\\" "\\foo" "\\foo\bar"
//
//  FALSE for others including "\\foo\bar\" (!)
//
STDAPI_(BOOL) PathIsRoot(LPCTSTR pPath)
{
    RIPMSG(pPath && IS_VALID_STRING_PTR(pPath, -1), "PathIsRoot: caller passed bad pPath");
    
    if (!pPath || !*pPath)
    {
        return FALSE;
    }
    
    if (!IsDBCSLeadByte(*pPath))
    {
        if (!lstrcmpi(pPath + 1, TEXT(":\\")))
        {
            return TRUE;    // "X:\" case
        }
    }
    
    if ((*pPath == CH_WHACK) && (*(pPath + 1) == 0))
    {
        return TRUE;    // "/" or "\" case
    }
    
    if (DBL_BSLASH(pPath))      // smells like UNC name
    {
        LPCTSTR p;
        int cBackslashes = 0;
        
        for (p = pPath + 2; *p; p = FAST_CharNext(p))
        {
            if (*p == TEXT('\\')) 
            {
                //
                //  return FALSE for "\\server\share\dir"
                //  so just check if there is more than one slash
                //
                //  "\\server\" without a share name causes
                //  problems for WNet APIs.  we should return
                //  FALSE for this as well
                //
                if ((++cBackslashes > 1) || !*(p+1))
                    return FALSE;   
            }
        }
        // end of string with only 1 more backslash
        // must be a bare UNC, which looks like a root dir
        return TRUE;
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Determines if pszPath is a directory.  "C:\" is
         considered a directory too.

Returns: TRUE if it is
*/
STDAPI_(BOOL) PathIsDirectory(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsDirectory: caller passed bad pszPath");

    if (pszPath)
    {
        if (PathIsUNCServer(pszPath))
        {
            return FALSE;
        }
        else if (PathIsUNCServerShare(pszPath))
        {
            union {
                NETRESOURCE nr;
                TCHAR buf[512];
            } nrb;

            LPTSTR lpSystem;
            DWORD dwRet;
            DWORD dwSize = SIZEOF(nrb);

            nrb.nr.dwScope = RESOURCE_GLOBALNET;
            nrb.nr.dwType = RESOURCETYPE_ANY;
            nrb.nr.dwDisplayType = 0;
            nrb.nr.lpLocalName = NULL;
            nrb.nr.lpRemoteName = (LPTSTR)pszPath;
            nrb.nr.lpProvider = NULL;
            nrb.nr.lpComment = NULL;

            dwRet = WNetGetResourceInformation(&nrb.nr, &nrb, &dwSize, &lpSystem);

            if (dwRet != WN_SUCCESS)
                goto TryGetFileAttrib;

            if (nrb.nr.dwDisplayType == RESOURCEDISPLAYTYPE_GENERIC)
                goto TryGetFileAttrib;

            if ((nrb.nr.dwDisplayType == RESOURCEDISPLAYTYPE_SHARE) &&
                ((nrb.nr.dwType == RESOURCETYPE_ANY) ||
                 (nrb.nr.dwType == RESOURCETYPE_DISK)))
            {
                return TRUE;
            }
        }
        else
        {
            DWORD dwAttribs;
TryGetFileAttrib:

            dwAttribs = GetFileAttributes(pszPath);
            if (dwAttribs != (DWORD)-1)
                return (BOOL)(dwAttribs & FILE_ATTRIBUTE_DIRECTORY);
        }
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Determines if pszPath is a directory.  "C:\" is
         considered a directory too.

Returns: TRUE if it is, FALSE if it is not a directory or there is
         at least one file other than "." or ".."
*/
STDAPI_(BOOL) PathIsDirectoryEmpty(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsDirectoryEmpty: caller passed bad pszPath");

    if (pszPath)
    {
        TCHAR szDirStarDotStar[MAX_PATH];
        HANDLE hDir;
        WIN32_FIND_DATA wfd;

        if (!PathIsDirectory(pszPath))
        {
            // its not even an directory, so it dosent fall into the
            // category of "empty" directory
            return FALSE;
        }

        lstrcpy(szDirStarDotStar, pszPath);
        PathAddBackslash(szDirStarDotStar);
        StrCatBuff(szDirStarDotStar, TEXT("*.*"), ARRAYSIZE(szDirStarDotStar));

        hDir = FindFirstFile(szDirStarDotStar, &wfd);

        if (INVALID_HANDLE_VALUE == hDir)
        {
            // we cant see into it, so assume some stuff is there
            return FALSE;
        }

        while (PathIsDotOrDotDot(wfd.cFileName))
        {
            if (!FindNextFile(hDir, &wfd))
            {
                // failed and all we found was "." and "..", so I guess
                // the directory is empty
                FindClose(hDir);
                return TRUE;
            }

        }

        // If we made it out of the loop, it means we found a file that 
        // wasen't "." or ".." Therefore, directory is NOT empty
        FindClose(hDir);
    }
    return FALSE;
}


#ifndef UNICODE
// light weight logic for charprev that is not painful for sbcs
BOOL IsTrailByte(LPCTSTR pszSt, LPCTSTR pszCur)
{
    LPCTSTR psz = pszCur;


    // if the given pointer is at the top of string, at least it's not a trail byte.
    if (psz <= pszSt) return FALSE;

    while (psz > pszSt)
    {
        psz--;
        if (!IsDBCSLeadByte(*psz))
        {
            // This is either a trail byte of double byte char
            // or a single byte character we've first seen.
            // Thus, the next pointer must be at either of a leadbyte
            // or pszCur itself.
            psz++;
            break;
        }
    }

    // Now psz can point to:
    //     1) a leadbyte of double byte character.
    //     2) pszSt
    //     3) pszCur
    //
    // if psz == pszSt, psz should point to a valid double byte char.
    //                  because we didn't hit the above if statement.
    //
    // if psz == pszCur, the *(pszCur-1) was non lead byte so pszCur can't
    //                   be a trail byte.
    //
    // Thus, we can see pszCur as trail byte pointer if the distance from
    // psz is not DBCS boundary that is 2.
    //
    return (BOOL) ((pszCur-psz) & 1);
}
#endif

// modify lpszPath in place so it fits within dx space (using the
// current font).  the base (file name) of the path is the minimal
// thing that will be left prepended with ellipses
//
// examples:
//      c:\foo\bar\bletch.txt -> c:\foo...\bletch.txt   -> TRUE
//      c:\foo\bar\bletch.txt -> c:...\bletch.txt       -> TRUE
//      c:\foo\bar\bletch.txt -> ...\bletch.txt         -> FALSE
//      relative-path         -> relative-...           -> TRUE
//
// in:
//      hDC         used to get font metrics
//      lpszPath    path to modify (in place)
//      dx          width in pixels
//
// returns:
//      TRUE    path was compacted to fit in dx
//      FALSE   base part didn't fit, the base part of the path was
//              bigger than dx
//
STDAPI_(BOOL) PathCompactPath(HDC hDC, LPTSTR lpszPath, UINT dx)
{
    BOOL bRet = TRUE;

    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1) && IS_VALID_WRITE_BUFFER(lpszPath, TCHAR, MAX_PATH), "PathCompactPath: caller passed bad lpszPath");
    DEBUGWhackPathString(lpszPath, MAX_PATH);

    if (lpszPath)
    {
        int           len;
        UINT          dxFixed, dxEllipses;
        LPTSTR        lpEnd;          /* end of the unfixed string */
        LPTSTR        lpFixed;        /* start of text that we always display */
        BOOL          bEllipsesIn;
        SIZE sz;
        TCHAR szTemp[MAX_PATH];
        HDC hdcGet = NULL;

        if (!hDC)
            hDC = hdcGet = GetDC(NULL);

        /* Does it already fit? */

        GetTextExtentPoint(hDC, lpszPath, lstrlen(lpszPath), &sz);
        if ((UINT)sz.cx <= dx)
        {
            goto Exit;
        }

        lpFixed = PathFindFileName(lpszPath);
        if (lpFixed != lpszPath)
        {
            lpFixed = CharPrev(lpszPath, lpFixed);  // point at the slash
        }

        /* Save this guy to prevent overlap. */
        lstrcpyn(szTemp, lpFixed, ARRAYSIZE(szTemp));

        lpEnd = lpFixed;
        bEllipsesIn = FALSE;

        GetTextExtentPoint(hDC, lpFixed, lstrlen(lpFixed), &sz);
        dxFixed = sz.cx;

        GetTextExtentPoint(hDC, c_szEllipses, 3, &sz);
        dxEllipses = sz.cx;

        // PERF: GetTextExtentEx() or something should let us do this without looping

        if (lpFixed == lpszPath)
        {
            // if we're just doing a file name, just tack on the ellipses at the end
            lpszPath = lpszPath + lstrlen(lpszPath);

            if ((3 + lpszPath - lpFixed) >= MAX_PATH)
            {
                lpszPath = lpFixed + MAX_PATH - 4;
            }

            while (TRUE) 
            {
#ifndef UNICODE
                if (IsTrailByte(lpFixed, lpszPath))
                    lpszPath--;
#endif
                lstrcpy(lpszPath, c_szEllipses);
                // Note: We don't support strings longer than 4GB, but that's
                // okay because we already barf at MAX_PATH
                GetTextExtentPoint(hDC, lpFixed, (int)(3 + lpszPath - lpFixed), &sz);

                if (sz.cx <= (int)dx)
                    break;
                
                lpszPath--;
            }

        }
        else
        {
            // Note that we need to avoid calling GetTextExtentPoint with a
            // length of zero (because Win95 allegedly crashes under conditions
            // yet to be determined precisely), but lpEnd is guaranteed
            // to be greater than lpszPath to start.
            //
            // raymondc - I'm guessing that some crappy display driver has
            // patched GetTextExtent and messed up their "optimized" version.
            do
            {
                // Note: We don't support strings longer than 4GB, but that's
                // okay because we already barf at MAX_PATH
                GetTextExtentPoint(hDC, lpszPath, (int)(lpEnd - lpszPath), &sz);

                len = dxFixed + sz.cx;

                if (bEllipsesIn)
                    len += dxEllipses;

                if (len <= (int)dx)
                    break;


                // Step back a character.
                lpEnd = CharPrev(lpszPath, lpEnd);
                
                if (!bEllipsesIn)
                {
                    // if this is the first
                    // truncation, go ahead and truncate by 3 (lstrlen of c_szEllipses);
                    // so that we don't just go back one, then write 3 and overwrite the buffer
                    lpEnd = CharPrev(lpszPath, lpEnd);
                    lpEnd = CharPrev(lpszPath, lpEnd);
                }

                bEllipsesIn = TRUE;

            } while (lpEnd > lpszPath);

            // Things didn't fit. Note that we'll still overflow here because the
            // filename is larger than the available space. We should probably trim
            // the file name, but I'm just trying to prevent a crash, not actually
            // make this work.
            if (lpEnd <= lpszPath)
            {
                lstrcpy(lpszPath, c_szEllipses);
                StrCatBuff(lpszPath, szTemp, MAX_PATH);
                bRet = FALSE;
                goto Exit;
            }

            if (bEllipsesIn)
            {
                lstrcpy(lpEnd, c_szEllipses);
                lstrcat(lpEnd, szTemp);
            }
        }
        Exit:
        if (hdcGet)
            ReleaseDC(NULL, hdcGet);
    }
    
    return bRet;
}

#define LEN_MID_ELLIPSES        4
#define LEN_END_ELLIPSES        3
#define MIN_CCHMAX              LEN_MID_ELLIPSES + LEN_END_ELLIPSES

// PathCompactPathEx
// Output:
//          "."
//          ".."
//          "..."
//          "...\"
//          "...\."
//          "...\.."
//          "...\..."
//          "...\Truncated filename..."
//          "...\whole filename"
//          "Truncated path\...\whole filename"
//          "Whole path\whole filename"
// The '/' might be used instead of a '\' if the original string used it
// If there is no path, but only a file name that does not fit, the output is:
//          "truncated filename..."
//
STDAPI_(BOOL) PathCompactPathEx(LPTSTR pszOut, LPCTSTR pszSrc, UINT cchMax, DWORD dwFlags)
{
    RIPMSG(pszSrc && IS_VALID_STRING_PTR(pszSrc, -1), "PathCompactPathEx: caller passed bad pszSrc");
    RIPMSG(pszOut && IS_VALID_WRITE_BUFFER(pszOut, TCHAR, cchMax), "PathCompactPathEx: caller passed bad pszOut");
    RIPMSG(!dwFlags, "PathCompactPathEx: caller passed non-ZERO dwFlags");
    DEBUGWhackPathBuffer(pszOut, cchMax);

    if (pszSrc)
    {
        TCHAR * pszFileName, *pszWalk;
        UINT uiFNLen = 0;
        int cchToCopy = 0, n;
        TCHAR chSlash = TEXT('0');

        ZeroMemory(pszOut, cchMax * sizeof(TCHAR));

        if ((UINT)lstrlen(pszSrc)+1 < cchMax)
        {
            lstrcpy(pszOut, pszSrc);
            ASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Determine what we use as a slash - a / or a \ (default \)
        pszWalk = (TCHAR*)pszSrc;
        chSlash = TEXT('\\');

        // Scan the entire string as we want the path separator closest to the end
        // eg. "file://\\Themesrv\desktop\desktop.htm"
        while(*pszWalk)
        {
            if ((*pszWalk == TEXT('/')) || (*pszWalk == TEXT('\\')))
                chSlash = *pszWalk;

            pszWalk = FAST_CharNext(pszWalk);
        }

        pszFileName = PathFindFileName(pszSrc);
        uiFNLen = lstrlen(pszFileName);

        // if the whole string is a file name
        if(pszFileName == pszSrc && cchMax > LEN_END_ELLIPSES)
        {
            lstrcpyn(pszOut, pszSrc, cchMax - LEN_END_ELLIPSES);
#ifndef UNICODE
            if (IsTrailByte(pszSrc, pszSrc+cchMax-LEN_END_ELLIPSES-1))
            {
                *(pszOut+cchMax-LEN_END_ELLIPSES-2) = TEXT('\0');
            }
#endif
            lstrcat(pszOut, TEXT("..."));
            ASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Handle all the cases where we just use ellipses ie '.' to '.../...'
        if ((cchMax < MIN_CCHMAX))
        {
            for (n = 0; n < (int)cchMax-1; n++)
            {
                if ((n+1) == LEN_MID_ELLIPSES)
                {
                    pszOut[n] = chSlash;
                }
                else
                {
                    pszOut[n] = TEXT('.');
                }
            }

            ASSERT(0==cchMax || pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Ok, how much of the path can we copy ? Buffer - (Lenght of MID_ELLIPSES + Len_Filename)
        cchToCopy = cchMax - (LEN_MID_ELLIPSES + uiFNLen);
        
        if (cchToCopy < 0)
            cchToCopy = 0;

#ifndef UNICODE
        if (cchToCopy > 0 && IsTrailByte(pszSrc, pszSrc+cchToCopy))
            cchToCopy--;
#endif

        lstrcpyn(pszOut, pszSrc, cchToCopy);

        // Now throw in the ".../" or "...\"
        lstrcat(pszOut, TEXT(".../"));
        pszOut[lstrlen(pszOut) - 1] = chSlash;

        //Finally the filename and ellipses if necessary
        if (cchMax > (LEN_MID_ELLIPSES + uiFNLen))
        {
            lstrcat(pszOut, pszFileName);
        }
        else
        {
            cchToCopy = cchMax - LEN_MID_ELLIPSES - LEN_END_ELLIPSES;
#ifndef UNICODE
            if (cchToCopy >0 && IsTrailByte(pszFileName, pszFileName+cchToCopy))
            {
                cchToCopy--;
            }
#endif
            lstrcpyn(pszOut + LEN_MID_ELLIPSES, pszFileName, cchToCopy);
            lstrcat(pszOut, TEXT("..."));
        }

        ASSERT(pszOut[cchMax-1] == TEXT('\0'));
        return TRUE;
    }
    return FALSE;
}


// fill a control with a path, using PathCompactPath() to crunch the
// path to fit.
//
// in:
//      hDlg    dialog box or parent window
//      id      child id to put the path in
//      pszPath path to put in
//
STDAPI_(void) PathSetDlgItemPath(HWND hDlg, int id, LPCTSTR pszPath)
{
    RECT rc;
    HDC hdc;
    HFONT hFont;
    TCHAR szPath[MAX_PATH + 1];  // can have one extra char
    HWND hwnd;

    hwnd = GetDlgItem(hDlg, id);
    
    if (!hwnd)
        return;

    szPath[0] = 0;

    if (pszPath)
        lstrcpyn(szPath, pszPath, ARRAYSIZE(szPath));

    GetClientRect(hwnd, &rc);

    hdc = GetDC(hDlg);
    hFont = (HANDLE)SendMessage(hwnd, WM_GETFONT, 0, 0L);
    
    if (NULL != (hFont = SelectObject(hdc, hFont)))
    {
        PathCompactPath(hdc, szPath, (UINT)rc.right);
        SelectObject(hdc, hFont);
    }
    
    ReleaseDC(hDlg, hdc);
    SetWindowText(hwnd, szPath);
}


/*----------------------------------------------------------
Purpose: If a path is contained in quotes then remove them.

Returns: --
Cond:    --
*/
STDAPI_(void) PathUnquoteSpaces(LPTSTR lpsz)
{
    RIPMSG(lpsz && IS_VALID_STRING_PTR(lpsz, -1), "PathUnquoteSpaces: caller passed bad lpsz");

    if (lpsz)
    {
        int cch;

        cch = lstrlen(lpsz);

        // Are the first and last chars quotes?
        // (It is safe to go straight to the last character because
        // the quotation mark is not a valid DBCS trail byte.)
        if (lpsz[0] == TEXT('"') && lpsz[cch-1] == TEXT('"'))
        {
            // Yep, remove them.
            lpsz[cch-1] = TEXT('\0');
            hmemcpy(lpsz, lpsz+1, (cch-1) * SIZEOF(TCHAR));
        }
    }
}


//----------------------------------------------------------------------------
// If a path contains spaces then put quotes around the whole thing.
//
STDAPI_(void)PathQuoteSpaces(LPTSTR lpsz)
{
    RIPMSG(lpsz && IS_VALID_STRING_PTR(lpsz, -1) && IS_VALID_WRITE_BUFFER(lpsz, TCHAR, MAX_PATH), "PathQuoteSpaces: caller passed bad lpsz");
    DEBUGWhackPathString(lpsz, MAX_PATH);

    if (lpsz)
    {
        int cch;

        if (StrChr(lpsz, TEXT(' ')))
        {
            // NB - Use hmemcpy coz it supports overlapps.
            cch = lstrlen(lpsz)+1;

            if (cch+1 < MAX_PATH)
            {
                hmemcpy(lpsz+1, lpsz, cch * SIZEOF(TCHAR));
                lpsz[0] = TEXT('"');
                lpsz[cch] = TEXT('"');
                lpsz[cch+1] = TEXT('\0');
            }
        }
    }
}


//---------------------------------------------------------------------------
// Given a pointer to a point in a path - return a ptr the start of the
// next path component. Path components are delimted by slashes or the
// null at the end.
// There's special handling for UNC names.
// This returns NULL if you pass in a pointer to a NULL ie if you're about
// to go off the end of the  path.
//
STDAPI_(LPTSTR) PathFindNextComponent(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathFindNextComponent: caller passed bad pszPath");

    if (pszPath)
    {
        LPTSTR pszLastSlash;

        // Are we at the end of a path.
        if (!*pszPath)
        {
            // Yep, quit.
            return NULL;
        }
        // Find the next slash.
        // REVIEW UNDONE - can slashes be quoted?
        pszLastSlash = StrChr(pszPath, TEXT('\\'));
        // Is there a slash?
#ifdef UNIX
        if (!pszLastSlash && !(pszLastSlash = StrChr(pszPath, CH_WHACK)))
#else
        if (!pszLastSlash)
#endif
        {
            // No - Return a ptr to the NULL.
            return (LPTSTR)pszPath + lstrlen(pszPath);
        }
        else
        {
            // Is it a UNC style name?
            if (*(pszLastSlash + 1) == TEXT('\\'))
            {
                // Yep, skip over the second slash.
                return pszLastSlash + 2;
            }
            else
            {
                // Nope. just skip over one slash.
                return pszLastSlash + 1;
            }
        }
    }

    return NULL;
}

// helper for PathMatchSpec.
// originally PathMatchSpec had this logic embedded in it and it recursively called itself.
// only problem is the recursion picked up all the extra specs, so for example
// PathMatchSpec("foo....txt", "*.txt;*.a;*.b;*.c;*.d;*.e;*.f;*.g") called itself too much
// and wound up being O(N^3).
// in fact this logic doesnt match strings efficiently, but we shipped it so leave it be.
// just test one spec at a time and its all good.
// pszSpec is a pointer within the pszSpec passed to PathMatchSpec so we terminate at ';' in addition to '\0'.
BOOL PathMatchSingleSpec(LPCTSTR pszFileParam, LPCTSTR pszSpec)
{
    LPCTSTR pszFile = pszFileParam;

    // Strip leading spaces from each spec.  This is mainly for commdlg
    // support;  the standard format that apps pass in for multiple specs
    // is something like "*.bmp; *.dib; *.pcx" for nicer presentation to
    // the user.
    while (*pszSpec == TEXT(' '))
        pszSpec++;

    while (*pszFile && *pszSpec && *pszSpec != TEXT(';'))
    {
        switch (*pszSpec)
        {
        case TEXT('?'):
            pszFile = FAST_CharNext(pszFile);
            pszSpec++;      // NLS: We know that this is a SBCS
            break;

        case TEXT('*'):

            // We found a * so see if this is the end of our file spec
            // or we have *.* as the end of spec, in which case we
            // can return true.
            //
            if (*(pszSpec + 1) == 0 || *(pszSpec + 1) == TEXT(';'))   // "*" matches everything
                return TRUE;


            // Increment to the next character in the list
            pszSpec = FAST_CharNext(pszSpec);

            // If the next character is a . then short circuit the
            // recursion for performance reasons
            if (*pszSpec == TEXT('.'))
            {
                pszSpec++;  // Get beyond the .

                // Now see if this is the *.* case
                if ((*pszSpec == TEXT('*')) &&
                        ((*(pszSpec+1) == TEXT('\0')) || (*(pszSpec+1) == TEXT(';'))))
                    return TRUE;

                // find the extension (or end in the file name)
                while (*pszFile)
                {
                    // If the next char is a dot we try to match the
                    // part on down else we just increment to next item
                    if (*pszFile == TEXT('.'))
                    {
                        pszFile++;

                        if (PathMatchSingleSpec(pszFile, pszSpec))
                            return TRUE;

                    }
                    else
                        pszFile = FAST_CharNext(pszFile);
                }

                return FALSE;   // No item found so go to next pattern
            }
            else
            {
                // Not simply looking for extension, so recurse through
                // each of the characters until we find a match or the
                // end of the file name
                while (*pszFile)
                {
                    // recurse on our self to see if we have a match
                    if (PathMatchSingleSpec(pszFile, pszSpec))
                        return TRUE;
                    pszFile = FAST_CharNext(pszFile);
                }

                return FALSE;   // No item found so go to next pattern
            }

        default:
            if (CharUpper((LPTSTR)(ULONG_PTR)(TUCHAR)*pszSpec) ==
                     CharUpper((LPTSTR)(ULONG_PTR)(TUCHAR)*pszFile))
            {
                if (IsDBCSLeadByte(*pszSpec))
                {
#ifdef  DBCS
                    // Because AnsiUpper(CharUpper) just return 0
                    // for broken DBCS char passing case, above if state
                    // always true with DBCS char so that we should check
                    // first byte of DBCS char here again.
                    if (*pszFile != *pszSpec)
                        return FALSE;
#endif
                    pszFile++;
                    pszSpec++;
                    if (*pszFile != *pszSpec)
                        return FALSE;
                }
                pszFile++;
                pszSpec++;
            }
            else
            {
                return FALSE;
            }
        }
    }

    // If we made it to the end of both strings, we have a match...
    //
    if (!*pszFile)
    {
        if ((!*pszSpec || *pszSpec == TEXT(';')))
            return TRUE;

        // Also special case if things like foo should match foo*
        // as well as foo*; for foo*.* or foo*.*;
        if ( (*pszSpec == TEXT('*')) &&
            ( (*(pszSpec+1) == TEXT('\0')) || (*(pszSpec+1) == TEXT(';')) ||
                ((*(pszSpec+1) == TEXT('.')) &&  (*(pszSpec+2) == TEXT('*')) &&
                    ((*(pszSpec+3) == TEXT('\0')) || (*(pszSpec+3) == TEXT(';'))))))

                return TRUE;
    }
    return FALSE;
}

//
// Match a DOS wild card spec against a dos file name
// Both strings must be ANSI.
//
STDAPI_(BOOL) PathMatchSpec(LPCTSTR pszFileParam, LPCTSTR pszSpec)
{
    RIPMSG(pszSpec && IS_VALID_STRING_PTR(pszSpec, -1), "PathMathSpec: caller passed bad pszSpec");
    RIPMSG(pszFileParam && IS_VALID_STRING_PTR(pszFileParam, -1), "PathMathSpec: caller passed bad pszFileParam");

    if (pszSpec && pszFileParam)
    {
        // Special case empty string, "*", and "*.*"...
        //
        if (*pszSpec == 0)
        {
            return TRUE;
        }

#ifdef UNICODE
        if (!g_bRunningOnNT)
        {
            // To costly to do UpperChar per character...
            char szFileParam[MAX_PATH];
            char szSpec[MAX_PATH];

            WideCharToMultiByte(CP_ACP, 0, pszFileParam, -1, szFileParam, ARRAYSIZE(szFileParam), NULL, NULL);
            WideCharToMultiByte(CP_ACP, 0, pszSpec, -1, szSpec, ARRAYSIZE(szSpec), NULL, NULL);
            return PathMatchSpecA(szFileParam, szSpec);
        }
#endif

        // loop over the spec, break off at ';', and call our helper for each.
        do
        {
            if (PathMatchSingleSpec(pszFileParam, pszSpec))
                return TRUE;

            // Skip to the end of the path spec...
            while (*pszSpec && *pszSpec != TEXT(';'))
                pszSpec = FAST_CharNext(pszSpec);

        // If we have more specs, keep looping...
        } while (*pszSpec++ == TEXT(';'));
    }

    return FALSE;
}


/*----------------------------------------------------------
Purpose: Returns a pointer to the beginning of the subpath
         that follows the root (drive letter or UNC server/share).

Returns:
Cond:    --
*/
STDAPI_(LPTSTR) PathSkipRoot(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathSkipRoot: caller passed bad pszPath");

    if (pszPath)
    {
        if (DBL_BSLASH(pszPath))
        {
            pszPath = StrChr(pszPath+2, TEXT('\\'));
            if (pszPath)
            {
                pszPath = StrChr(pszPath+1, TEXT('\\'));
                if (pszPath)
                {
                    ++pszPath;
                }
            }
        }
        else if (!IsDBCSLeadByte(pszPath[0]) && pszPath[1]==TEXT(':') && pszPath[2]==TEXT('\\'))
        {
            pszPath += 3;
        }
#ifdef UNIX
        else if (!IsDBCSLeadByte(pszPath[0]) && pszPath[0]==CH_WHACK)
        {
            pszPath++;
        }
#endif
        else
        {
            pszPath = NULL;
        }
    }

    return (LPTSTR)pszPath;
}


// see if two paths have the same root component
//
STDAPI_(BOOL) PathIsSameRoot(LPCTSTR pszPath1, LPCTSTR pszPath2)
{
    RIPMSG(pszPath1 && IS_VALID_STRING_PTR(pszPath1, -1), "PathIsSameRoot: caller passed bad pszPath1");
    RIPMSG(pszPath2 && IS_VALID_STRING_PTR(pszPath2, -1), "PathIsSameRoot: caller passed bad pszPath2");

    if (pszPath1 && pszPath2)
    {
        LPTSTR pszAfterRoot = PathSkipRoot(pszPath1);
        int nLen = PathCommonPrefix(pszPath1, pszPath2, NULL);

        // Add 1 to account for the '\\'
        return pszAfterRoot && (pszAfterRoot - pszPath1) <= (nLen + 1);
    }
    return FALSE;
}

#define IsDigit(c) ((c) >= TEXT('0') && c <= TEXT('9'))

/*----------------------------------------------------------
Purpose: Takes a location string ("shell32.dll,3") and parses
         it into a file-component and an icon index.

Returns: icon index
Cond:    --
*/
STDAPI_(int) PathParseIconLocation(IN OUT LPTSTR pszIconFile)
{
    int iIndex = 0;

    RIPMSG(pszIconFile && IS_VALID_STRING_PTR(pszIconFile, -1), "PathParseIconLocation: caller passed bad pszIconFile");
    
    if (pszIconFile)
    {
        LPTSTR pszComma, pszEnd;

        // look for the last comma in the string
        pszEnd = pszIconFile + lstrlen(pszIconFile);
        pszComma = StrRChr(pszIconFile, pszEnd, TEXT(','));
        
        if (pszComma && *pszComma)
        {
            LPTSTR pszComma2 = pszComma + 1;
            BOOL fIsDigit = FALSE;

            // Sometimes we get something like: "C:\path, comma\path\file.ico"
            // where the ',' is in the path and does not indicates that an icon index follows
            while (*pszComma2)
            {
                if ((TEXT(' ') == *pszComma2) || (TEXT('-') == *pszComma2))
                {
                    ++pszComma2;
                }
                else
                {
                    if (IsDigit(*pszComma2))
                    {
                        fIsDigit = TRUE;
                    }
                    break;
                }
            }

            if (fIsDigit)
            {
                *pszComma++ = 0;            // terminate the icon file name.
                iIndex = StrToInt(pszComma);
            }
        }

        PathUnquoteSpaces(pszIconFile);
        PathRemoveBlanks(pszIconFile);
    }
    return iIndex;
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the given path is of a URL format.
         See http://www.w3.org for a complete description of
         the URL format.

         A complete URL looks like:
            <URL:http://www.microsoft.com/software/index.html>

         But generally URLs don't have the leading "URL:" and
         the wrapping angle brackets.  So this function only
         tests for the following format:

            http://www.microsoft.com/software

         It does not check if the path points to an existing
         site, only if is in a legal URL format.

Returns: TRUE if URL format
         FALSE if not
Cond:    --
*/
STDAPI_(BOOL) PathIsURL(IN LPCTSTR pszPath)
{
    PARSEDURL pu;

    if (!pszPath)
        return FALSE;

    RIPMSG(IS_VALID_STRING_PTR(pszPath, -1), "PathIsURL: caller passed bad pszPath");

    pu.cbSize = SIZEOF(pu);
    return SUCCEEDED(ParseURL(pszPath, &pu));
}


/****************************************************\
    FUNCTION: PathIsContentType

    PARAMETERS:
        pszPath - File Name to check.
        pszContentType - Content Type to look for.

    DESCRIPTION:
        Is the file (pszPath) of the content type
    specified (pszContentType)?.
\****************************************************/
#define SZ_VALUE_CONTENTTYPE      TEXT("Content Type")

BOOL PathIsContentType(LPCTSTR pszPath, LPCTSTR pszContentType)
{
    BOOL fDoesMatch = FALSE;

    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathIsContentType: caller passed bad pszPath");
    RIPMSG(pszContentType && IS_VALID_STRING_PTR(pszContentType, -1), "PathIsContentType: caller passed bad pszContentType");

    if (pszPath)
    {
        LPTSTR pszExtension = PathFindExtension(pszPath);

        if (pszExtension && pszExtension[0])
        {
            TCHAR szRegData[MAX_PATH];
            DWORD dwDataSize = ARRAYSIZE(szRegData);
            
            if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_CONTENTTYPE, pszExtension, NULL, szRegData, &dwDataSize)))
            {
                fDoesMatch = (0 == lstrcmpi(szRegData, pszContentType));
            }
        }
    }

    return fDoesMatch;
}


/*----------------------------------------------------------
Purpose: Returns the character type (GCT_)

  FEATURE (reinerf) - this API is not very good, use PathIsValidChar() instead, its more customizable
                     
*/
UINT PathGetCharType(TUCHAR ch)
{
    switch (ch)
    {
        case TEXT('|'):
        case TEXT('>'):
        case TEXT('<'):
        case TEXT('"'):
        case TEXT('/'):
            return GCT_INVALID;

        case TEXT('?'):
        case TEXT('*'):
            return GCT_WILD;

        case TEXT('\\'):      // path separator
        case TEXT(':'):       // drive colon
            return GCT_SEPARATOR;

        case TEXT(';'):
        case TEXT(','):
        case TEXT(' '):
            return GCT_LFNCHAR;     // actually valid in short names
                                    // but we want to avoid this
        default:
            if (ch > TEXT(' '))
            {
                return GCT_SHORTCHAR | GCT_LFNCHAR;
            }
            else
            {
                // control character
                return GCT_INVALID;
            }
    }
}


/*----------------------------------------------------------
Purpose: returns if a character is a valid path character given
         the flags that you pass in (PIVC_XXX). Some basic flags are given below:

         PIVC_ALLOW_QUESTIONMARK        treat '?' as valid
         PIVC_ALLOW_STAR                treat '*' as valid
         PIVC_ALLOW_DOT                 treat '.' as valid
         PIVC_ALLOW_SLASH               treat '\\' as valid
         PIVC_ALLOW_COLON               treat ':' as valid
         PIVC_ALLOW_SEMICOLON           treat ';' as valid
         PIVC_ALLOW_COMMA               treat ',' as valid
         PIVC_ALLOW_SPACE               treat ' ' as valid
         PIVC_ALLOW_NONALPAHABETIC      treat non-alphabetic extenede chars as valid
         PIVC_ALLOW_QUOTE               treat '"' as valid

         if you pass 0, then only alphabetic characters are valid. there are also basic
         conglomerations of the above flags:

         PIVC_ALLOW_FULLPATH, PIVC_ALLOW_WILDCARD, PIVC_ALLOW_LFN, ...
         

Returns: TRUE if the character is a valid path character given the dwFlags constraints
         FALSE if this does not qualify as a valid path character given the dwFlags constraints
Cond:    --
*/
STDAPI_(BOOL) PathIsValidChar(TUCHAR ch, DWORD dwFlags)
{
    switch (ch)
    {
        case TEXT('|'):
        case TEXT('>'):
        case TEXT('<'):
        case TEXT('/'):
            return FALSE;   // these are allways illegal in a path
            break;

        case TEXT('?'):
            return dwFlags & PIVC_ALLOW_QUESTIONMARK;
            break;

        case TEXT('*'):
            return dwFlags & PIVC_ALLOW_STAR;
            break;

        case TEXT('.'):
            return dwFlags & PIVC_ALLOW_DOT;
            break;

        case TEXT('\\'):
            return dwFlags & PIVC_ALLOW_SLASH;
            break;

        case TEXT(':'):
            return dwFlags & PIVC_ALLOW_COLON;
            break;

        case TEXT(';'):
            return dwFlags & PIVC_ALLOW_SEMICOLON;
            break;

        case TEXT(','):
            return dwFlags & PIVC_ALLOW_COMMA;
            break;

        case TEXT(' '):
            return dwFlags & PIVC_ALLOW_SPACE;
            break;

        case TEXT('"'):
            return dwFlags & PIVC_ALLOW_QUOTE;
            break;

        default:
            if (InRange(ch, TEXT('a'), TEXT('z')) ||
                InRange(ch, TEXT('A'), TEXT('Z')))
            {
                // we have an alphabetic character, 
                // this is always valid
                return TRUE;
            }
            else if (ch < TEXT(' '))
            {
                // we have a control sequence, 
                // this is allways illegal
                return FALSE;
            }
            else
            {
                // we have an non-alphabetic extenede character
                return dwFlags & PIVC_ALLOW_NONALPAHABETIC;
            }
            break;
    }
}


BOOL IsSystemSpecialCase(LPCTSTR pszPath)
{
    static TCHAR *g_pszWin = NULL, *g_pszSys = NULL;

    if (g_pszWin == NULL)
    {
        TCHAR szTemp[MAX_PATH];
        UINT cch = GetWindowsDirectory(szTemp, ARRAYSIZE(szTemp));

        if (cch && cch < ARRAYSIZE(szTemp))
            g_pszWin = StrDup(szTemp);
    }

    if (g_pszSys == NULL)
    {
        TCHAR szTemp[MAX_PATH];
        UINT cch = GetSystemDirectory(szTemp, ARRAYSIZE(szTemp));

        if (cch && cch < ARRAYSIZE(szTemp))
            g_pszSys = StrDup(szTemp);
    }

    return (g_pszWin && (lstrcmpi(g_pszWin, pszPath) == 0)) ||
           (g_pszSys && (lstrcmpi(g_pszSys, pszPath) == 0));
}


/*----------------------------------------------------------
Purpose: Mark a folder to be a shell folder by stamping
         either FILE_ATTRIBUTES_READONLY or FILE_ATTRIBUTE_SYSTEM
         into it's attributes.  Which flag is used is based
         on the presence/absense of a registry switch

         NOTE: we also mark the contained desktop.ini +s +h if it exists
*/
BOOL PathMakeSystemFolder(LPCTSTR pszPath)
{
    BOOL fRet = FALSE;
        
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathMakeSystemFolder: caller passed bad pszPath");

    if (pszPath && *pszPath)
    {
        TCHAR szTemp[MAX_PATH];

        if (IsSystemSpecialCase(pszPath))
        {
            fRet = TRUE;
        }
        else
        {
            DWORD dwAttrb, dwAttrbSet = FILE_ATTRIBUTE_READONLY;

            if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_EXPLORER, 
                TEXT("UseSystemForSystemFolders"), NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                dwAttrbSet = FILE_ATTRIBUTE_SYSTEM;
            }

            dwAttrb = GetFileAttributes(pszPath);
            if ((dwAttrb != (DWORD)-1) && (dwAttrb & FILE_ATTRIBUTE_DIRECTORY))
            {
                dwAttrb &= ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
                dwAttrb |= dwAttrbSet;

                fRet = SetFileAttributes(pszPath, dwAttrb);
            }

            if (fRet)
            {
                FILETIME ftCurrent;
                HANDLE h;

                // People typically call this API after writing a desktop.ini in the
                // folder.  Doing this often changes the thumbnail of the folder.
                // But on FAT systems, this doesn't update the Modified time of the
                // folder like it does for NTFS.  So manually do that now:
                //
                GetSystemTimeAsFileTime(&ftCurrent);
                // woohoo yay for private flags
                // 0x100 lets us open a directory in write access
                h = CreateFile(pszPath, GENERIC_READ | 0x100,
                                   FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
                                   OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
                if (h != INVALID_HANDLE_VALUE)
                {
                    SetFileTime(h, NULL, NULL, &ftCurrent);
                    CloseHandle(h);
                }

                SHChangeNotifyWrap(SHCNE_UPDATEITEM, SHCNF_PATH, pszPath, NULL);
            }
        }

        // we also set the contained desktop.ini file to be (+h +s), if it exists
        if (PathCombine(szTemp, pszPath, TEXT("desktop.ini")))
        {
            // we explicitly do not OR in the attribs, because we want to reset the
            // readonly bit since writeprivateprofilestring fails on reaonly files.
            SetFileAttributes(szTemp, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        }
    }

    return fRet;
}

/*----------------------------------------------------------
Purpose: Unmark a folder so it is no longer a system folder.
         (remove either FILE_ATTRIBUTES_READONLY or FILE_ATTRIBUTE_SYSTEM
         attribute).
*/
BOOL PathUnmakeSystemFolder(LPCTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathUnmakeSystemFolder: caller passed bad pszPath");

    if (pszPath && *pszPath)
    {
        DWORD dwAttrb = GetFileAttributes( pszPath );

        if ((dwAttrb != (DWORD)-1) && (dwAttrb & FILE_ATTRIBUTE_DIRECTORY))
        {
            dwAttrb &= ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);

            return SetFileAttributes(pszPath, dwAttrb);
        }
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: checks whether given path is a system (shell) folder.
         if path is NULL, then use the attributes passed in
         instead of reading them off the disk.

*/
BOOL PathIsSystemFolder(LPCTSTR pszPath, DWORD dwAttrb)
{
    if (pszPath && *pszPath)
        dwAttrb = GetFileAttributes(pszPath);

    if ((dwAttrb != (DWORD)-1) && (dwAttrb & FILE_ATTRIBUTE_DIRECTORY))
    {
        if (dwAttrb & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
        {
            return TRUE;
        }
    }
    return FALSE;
}



LPCTSTR PathSkipLeadingSlashes(LPCTSTR pszURL)
{
    LPCTSTR pszURLStart = pszURL;

    RIPMSG(pszURL && IS_VALID_STRING_PTR(pszURL, -1), "PathSkipLeadingSlashes: caller passed bad pszURL");
    if (pszURL)
    {
        // Skip two leading slashes.

        if (pszURL[0] == TEXT('/') && pszURL[1] == TEXT('/'))
            pszURLStart += 2;

        ASSERT(IS_VALID_STRING_PTR(pszURL, -1) &&
               IsStringContained(pszURL, pszURLStart));
    }
    
    return pszURLStart;
}


//
// returns:
//      TRUE    given filespec is long (> 8.3 form)
//      FALSE   filespec is short
//
STDAPI_(BOOL) PathIsLFNFileSpec(LPCTSTR pszName)
{
    RIPMSG(pszName && IS_VALID_STRING_PTR(pszName, -1), "PathIsLFNFileSpec: caller passed bad pszName");

    if (pszName)
    {
        BOOL bSeenDot = FALSE;
        int iCount = 1; 
        
        while (*pszName)
        {
            if (bSeenDot)
            {
                if (iCount > 3)
                {
                    // found a long name
                    return TRUE;
                }
            }

            if (*pszName == TEXT(' '))
            {
                // Short names dont have blanks in them.
                return TRUE;
            }

            if (*pszName == TEXT('.'))
            {
                if (bSeenDot)
                {
                    // short names can only have one '.'
                    return TRUE;
                }

                bSeenDot = TRUE;
                iCount = 0; // don't include the '.'
            }
            else if (iCount > 8)
            {
                // long name
                return TRUE;
            }

            if (IsDBCSLeadByte(*pszName))
            {
                pszName += 2;
                iCount += 2;
            }
            else
            {
                pszName++;
                iCount++;
            }
        }
    }

    return FALSE;       // short name
}


/*----------------------------------------------------------
Purpose: Removes regexp \[[0-9]*\] from base name of file  
         that is typically added by the wininet cache.
*/

#ifndef UNIX
#define DECORATION_OPENING_CHAR TEXT('[')
#define DECORATION_CLOSING_CHAR TEXT(']')
#else
#define DECORATION_OPENING_CHAR TEXT('(')
#define DECORATION_CLOSING_CHAR TEXT(')')
#endif /* UNIX */

STDAPI_(void) PathUndecorate(LPTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathUndecorate: caller passed bad pszPath");

    if (pszPath)
    {
        LPTSTR pszExt, pszScan;
        DWORD cchMove;
        
        // First, skip over the extension, if any.
        pszExt = PathFindExtension(pszPath);
        ASSERT(pszExt >= pszPath); // points to null at end if no ext

        // Whoa, a completely empty path
        if (pszExt <= pszPath)
            return;

        // Scan backwards from just before the "."
        pszScan = pszExt - 1;

        // Check for closing bracket.
        if (*pszScan-- != DECORATION_CLOSING_CHAR)
            return;
        if (pszScan <= pszPath) // it was a 1-char filename ")"
            return;
#ifndef UNICODE
        if (IsTrailByte(pszPath, pszScan+1))    // Oops, that ")" was the 2nd byte of a DBCS char
            return;
#endif

        // Skip over digits.
        while (pszScan > pszPath && IsDigit(*pszScan))
            pszScan--;
#ifndef UNICODE
        if (IsTrailByte(pszPath, pszScan+1))   // Oops, that last number was the 2nd byte of a DBCS char
            return;
#endif

        // Check for opening bracket
        if (*pszScan != DECORATION_OPENING_CHAR)
            return;
        if (pszScan <= pszPath) // it was all decoration (we don't want to go to an empty filename)
            return;
#ifndef UNICODE
        if (IsTrailByte(pszPath, pszScan))  // Oops, that "(" was the 2nd byte of a DBCS char
            return;
#endif
        // Make sure we're not looking at the end of the path (we don't want to go to an empty filename)
        if (*(pszScan-1) == FILENAME_SEPARATOR
#ifndef UNICODE
            // make sure that slash isn't the 2nd byte of a DBCS char
            && ((pszScan-1) == pszPath || !IsTrailByte(pszPath, pszScan-1))
#endif
           )
        {
            return;
        }
        
        // Got a decoration.  Cut it out of the string.
        cchMove = lstrlen(pszExt) + 1;
        memmove(pszScan, pszExt, cchMove * sizeof(TCHAR));
    }
}

//  If the given environment variable exists as the first part of the path,
//  then the environment variable is inserted into the output buffer.
//
//  Returns TRUE if pszResult is filled in.
//
//  Example:  Input  -- C:\WINNT\SYSTEM32\FOO.TXT -and- lpEnvVar = %SYSTEMROOT%
//            Output -- %SYSTEMROOT%\SYSTEM32\FOO.TXT
//

#ifdef  UNICODE
#define UnExpandEnvironmentStringForUser    UnExpandEnvironmentStringForUserW
#else
#define UnExpandEnvironmentStringForUser    UnExpandEnvironmentStringForUserA
#endif

BOOL UnExpandEnvironmentStringForUser(HANDLE hToken, LPCTSTR pszPath, LPCTSTR pszEnvVar, LPTSTR pszResult, UINT cbResult)
{
    TCHAR szEnvVar[MAX_PATH];
    DWORD dwEnvVar = SHExpandEnvironmentStringsForUser(hToken, pszEnvVar, szEnvVar, ARRAYSIZE(szEnvVar));
    if (dwEnvVar)
    {
        dwEnvVar--; // don't count the NULL

        if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar, dwEnvVar, pszPath, dwEnvVar) == 2)
        {
            if (lstrlen(pszPath) - (int)dwEnvVar + lstrlen(pszEnvVar) < (int)cbResult)
            {
                lstrcpy(pszResult, pszEnvVar);
                lstrcat(pszResult, pszPath + dwEnvVar);
                return TRUE;
            }
        }
    }
    return FALSE;
}

STDAPI_(BOOL) PathUnExpandEnvStringsForUser(HANDLE hToken, LPCTSTR pszPath, LPTSTR pszBuf, UINT cchBuf)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "PathUnExpandEnvStrings: caller passed bad pszPath");
    RIPMSG(pszBuf && IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, cchBuf), "PathUnExpandEnvStrings: caller passed bad pszBuf");
    DEBUGWhackPathBuffer(pszBuf, cchBuf);

    // Bail out if we're not in NT (nothing to do if those environment variables
    // aren't defined).
    //
    if (g_bRunningOnNT && pszPath && pszBuf)
    {

        // 99/05/28 #346950 vtan: WARNING!!! Be careful about the order of comparison
        // here. The longer paths (supersets of other possible paths) MUST be compared
        // first. For example (default case):
        //      %APPDATA%       =   x:\Documents And Settings\user\Application Data
        //      %USERPROFILE%   =   x:\Documents And Settings\user
        // If %USERPROFILE% is matched first then %APPDATA% will never be matched.

        // Added %APPDATA% to support Darwin installation into that folder and the
        // setting of the link icon location.
        // Also note that %APPDATA% and %USERPROFILE% are user relative and depend on
        // the context in which this function is invoked. Normally it is within the
        // currently logged on user's context but Darwin installs from msiexec.exe which
        // is launched from SYSTEM. Unless the process' environment block is correctly
        // modified the current user information is incorrect. In this case it is up
        // to the process to impersonate a user on a thread. We get the impersonated
        // user information from the hToken passed to us.

        return (UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%APPDATA%"), pszBuf, cchBuf)           ||
                UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%USERPROFILE%"), pszBuf, cchBuf)       ||
                UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%ALLUSERSPROFILE%"), pszBuf, cchBuf)   ||
                UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%ProgramFiles%"), pszBuf, cchBuf)      ||
                UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%SystemRoot%"), pszBuf, cchBuf)        ||
                UnExpandEnvironmentStringForUser(hToken, pszPath, TEXT("%SystemDrive%"), pszBuf, cchBuf));
    }
    else
    {
        // Zero out the string if there's room.
        if (pszBuf && (cchBuf > 0))
            *pszBuf = TEXT('\0');
        return FALSE;
    }
}

STDAPI_(BOOL) PathUnExpandEnvStrings(LPCTSTR pszPath, LPTSTR pszBuf, UINT cchBuf)

{
    return(PathUnExpandEnvStringsForUser(NULL, pszPath, pszBuf, cchBuf));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\qistub.cpp ===
// this version of qistub is for retail only.
// if clients (e.g. shell32) want debug version
// they staticaly link to it (and the local version
// overwrites this one

#include "priv.h"

#ifdef  DEBUG
// warning Warning WARNING!!!
// priv.h's PCH has been built DEBUG, and now we're #undef'ing it.
// so various macros are still 'on'.  this leads to inconsistencies
// in ../lib/qistub.cpp.  i've hacked around this for the 1 known
// pblm case in ../lib/qistub.cpp (DBEXEC).
//
// (and we can't just move the #undef up above priv.h, it will still
// be ignored because the PCH already exists).
//
// i'm 99% sure that the reason we don't want DEBUG on here is to avoid
// having any static data in shlwapi.  that's an old restriction (though
// still a perf issue) (but not for DEBUG...), so for DEBUG we can probably
// just remove this entire hack.  i haven't tested that theory yet though
// so for now we'll continue to live w/ it.
#undef  DEBUG
#endif

#include "..\inc\qistub.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\reg.c ===
#include "priv.h"
#include <regapix.h>

#ifdef _X86_
#include <w95wraps.h>
#endif

// These private helper functions below call ANSI versions of the 
// registry functions so they will run on Win95.



STDAPI_(DWORD)
RegData_AtoW(
    IN    LPCVOID pvData,
    IN    DWORD   dwSize,
    IN    DWORD   dwType,
    /*INOUT*/ LPDWORD pcbData
)
{
    DWORD dwRet = NO_ERROR;

    if (REG_SZ == dwType || REG_EXPAND_SZ == dwType || REG_MULTI_SZ == dwType)
    {
        DWORD cbData = pcbData ? *pcbData : -1;
        if (pvData)
        {
            // Allocate a temporary buffer to work with
            int cch = MultiByteToWideChar(CP_ACP, 0, (LPSTR)pvData, cbData, NULL, 0);
            LPWSTR pwszT = (LPWSTR)LocalAlloc(LPTR, CbFromCchW(cch));

            if (!pwszT)
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
            else
            {
                if (CbFromCchW(cch) > dwSize)
                    dwRet = ERROR_MORE_DATA;
                else
                {
                    // Convert it to the temporary buffer
                    MultiByteToWideChar(CP_ACP, 0, (LPSTR)pvData, cbData, pwszT, cch);

                    // Copy it back to the output buffer
                    // pwszT can be REG_MULTI_SZ, so we can't use StrCpyW
                    memcpy((LPVOID)pvData, (LPVOID)pwszT, CbFromCchW(cch));
                }
                LocalFree(pwszT);
            }

            // If string data, make room for unicode 
            if (pcbData)
            {
                (*pcbData) = cch * sizeof(WCHAR);
            }
        }
        else if (pcbData)
        {
            // We don't have the data so guess (actual value may be less)
            // Does this need to be exact?  For now this seem sufficient. (Stevepro)
            (*pcbData) *= sizeof(WCHAR);
        }
    }
    return dwRet;
}


/*----------------------------------------------------------
Purpose: Helper function to delete a key that has no subkeys and
         no values.  Otherwise does nothing.  Mimics what RegDeleteKey
         does on NT.

Returns:
Cond:    --
*/
DWORD
DeleteEmptyKey(
    IN  HKEY    hkey,
    IN  LPCSTR  pszSubKey)
{
    DWORD dwRet;
    HKEY hkeyNew;

    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_READ | KEY_SET_VALUE, 
                          &hkeyNew);
    if (NO_ERROR == dwRet)
    {
        DWORD ckeys;
        DWORD cvalues;

        // Are there any subkeys or values?

        dwRet = RegQueryInfoKey(hkeyNew, NULL, NULL, NULL, &ckeys,
                                NULL, NULL, &cvalues, NULL, NULL,
                                NULL, NULL);
        if (NO_ERROR == dwRet &&
            0 == cvalues && 0 == ckeys)
        {
            // No; delete the subkey
            dwRet = RegDeleteKeyA(hkey, pszSubKey);
        }
        else
        {
            dwRet = ERROR_DIR_NOT_EMPTY;
        }
        RegCloseKey(hkeyNew);
    }
    return dwRet;
}


/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

Returns: 
Cond:    --
*/
DWORD
DeleteKeyRecursively(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, MAXIMUM_ALLOWED, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKeyA(hkSubKey, NULL, NULL, NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKeyA(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        if (pszSubKey)
        {
            dwRet = RegDeleteKeyA(hkey, pszSubKey);
        }
        else
        {
            //  we want to delete all the values by hand
            cchSubKeyName = ARRAYSIZE(szSubKeyName);
            while (ERROR_SUCCESS == RegEnumValueA(hkey, 0, szSubKeyName, &cchSubKeyName, NULL, NULL, NULL, NULL))
            {
                //  avoid looping infinitely when we cant delete the value
                if (RegDeleteValueA(hkey, szSubKeyName))
                    break;
                    
                cchSubKeyName = ARRAYSIZE(szSubKeyName);
            }
        }
    }

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Gets a registry value.  This opens and closes the
         key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
SHGetValueA(
    IN  HKEY    hkey,
    IN  LPCSTR  pszSubKey,          OPTIONAL
    IN  LPCSTR  pszValue,           OPTIONAL
    OUT LPDWORD pdwType,            OPTIONAL
    OUT LPVOID  pvData,             OPTIONAL
    OUT LPDWORD pcbData)            OPTIONAL
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    HKEY hkClose = NULL;

    if (pvData)
    {
        RIPMSG(pcbData != NULL, "SHGetValueA: caller passed pvData output buffer but not size of buffer (pcbData)!");
    }

    if (pszSubKey && *pszSubKey)
    {
        dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_QUERY_VALUE, &hkClose);
        hkey = hkClose;
        ASSERT(NO_ERROR == dwRet || !hkey);
    }
        
    if (hkey)
    {
        dwRet = SHQueryValueExA(hkey, pszValue, NULL, pdwType, pvData, 
                                 pcbData);

        if (hkClose)
            RegCloseKey(hkClose);
    }
    else if (pcbData)
        *pcbData = 0;

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Gets a registry value.  This opens and closes the
         key in which the value resides.  

         On Win95, this function thunks and calls the ansi
         version.  On NT, this function calls the unicode
         registry APIs.

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
SHGetValueW(
    IN  HKEY    hkey,
    IN  LPCWSTR pwszSubKey,         OPTIONAL
    IN  LPCWSTR pwszValue,          OPTIONAL
    OUT LPDWORD pdwType,            OPTIONAL
    OUT LPVOID  pvData,             OPTIONAL
    OUT LPDWORD pcbData)            OPTIONAL
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;

    if (pvData)
    {
        RIPMSG(pcbData != NULL, "SHGetValueW: caller passed pvData output buffer but not size of buffer (pcbData)!");
    }

    if (g_bRunningOnNT)
    {
        HKEY hkClose = NULL;

        if (pwszSubKey && *pwszSubKey)
        {
            dwRet = RegOpenKeyExW(hkey, pwszSubKey, 0, KEY_QUERY_VALUE, &hkClose);
            hkey = hkClose;
            ASSERT(NO_ERROR == dwRet || !hkey);

        }
            
        if (hkey)
        {
            dwRet = SHQueryValueExW(hkey, pwszValue, NULL, pdwType, pvData, 
                                     pcbData);
            if (hkClose)
                RegCloseKey(hkClose);
        }
        else if (pcbData)
            *pcbData = 0;
    }
    else
    {
        CHAR szSubKey[MAX_PATH];
        CHAR szValue[MAX_PATH];
        LPSTR pszSubKey = NULL;
        LPSTR pszValue = NULL;
        DWORD dwType;
        DWORD cbSizeSav = 0;

        // Thunk the values
        if (pwszSubKey)
        {
            WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, szSubKey, SIZECHARS(szSubKey), NULL, NULL);
            pszSubKey = szSubKey;    
        }
        
        if (pwszValue)
        {
            WideCharToMultiByte(CP_ACP, 0, pwszValue, -1, szValue, SIZECHARS(szValue), NULL, NULL);
            pszValue = szValue;
        }

        if (pcbData)
            cbSizeSav = *pcbData;       // Save this size for later

        dwRet = SHGetValueA(hkey, pszSubKey, pszValue, &dwType, pvData, pcbData);

        if (pdwType)
            *pdwType = dwType;

        if (NO_ERROR == dwRet)
        {
            dwRet = RegData_AtoW(pvData, cbSizeSav, dwType, pcbData);   // Thunk data from ANSI->UNICODE if needed.
        }
    }
    return dwRet;
}


/*----------------------------------------------------------
Purpose: Sets a registry value.  This opens and closes the
         key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
SHSetValueA(
    IN  HKEY    hkey,
    IN OPTIONAL LPCSTR  pszSubKey,
    IN  LPCSTR  pszValue,
    IN  DWORD   dwType,
    IN  LPCVOID pvData,
    IN  DWORD   cbData)
{
    DWORD dwRet = NO_ERROR;
    HKEY hkeyNew;
    DWORD dwDisp;

    if (pszSubKey && pszSubKey[0])
        dwRet = RegCreateKeyExA(hkey, pszSubKey, 0, "", 0, KEY_SET_VALUE, NULL, &hkeyNew, &dwDisp);
    else
        hkeyNew = hkey;

    if (NO_ERROR == dwRet)
    {
        dwRet = RegSetValueExA(hkeyNew, pszValue, 0, dwType, pvData, cbData);

        if (hkeyNew != hkey)
            RegCloseKey(hkeyNew);
    }
    return dwRet;
}


/*----------------------------------------------------------
Purpose: Sets a registry value.  This opens and closes the
         key in which the value resides.  

         On Win95, this function thunks and calls the ansi
         version.  On NT, this function calls the unicode
         registry APIs directly.

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
SHSetValueW(
    IN  HKEY    hkey,
    IN OPTIONAL LPCWSTR pwszSubKey,
    IN  LPCWSTR pwszValue,
    IN  DWORD   dwType,
    IN  LPCVOID pvData,
    IN  DWORD   cbData)
{
    DWORD dwRet = NO_ERROR;
    HKEY hkeyNew;
    DWORD dwDisp;

    if (pwszSubKey && pwszSubKey[0])
    {
        if (g_bRunningOnNT)
        {
            dwRet = RegCreateKeyExW(hkey, pwszSubKey, 0, TEXTW(""), 0, KEY_SET_VALUE, 
                                    NULL, &hkeyNew, &dwDisp);
        }
        else
        {
            CHAR szSubKey[MAX_PATH];
            LPSTR pszSubKey = NULL;

            if (pwszSubKey)
            {
                WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, szSubKey, SIZECHARS(szSubKey), NULL, NULL);
                pszSubKey = szSubKey;    
            }
        
            dwRet = RegCreateKeyExA(hkey, pszSubKey, 0, "", REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, 
                                    NULL, &hkeyNew, &dwDisp);
        }
    }
    else
        hkeyNew = hkey;

    if (NO_ERROR == dwRet)
    {
        // RegSetValueExW is not supported on Win95 but we have a thunking function.
        dwRet = RegSetValueExW(hkeyNew, pwszValue, 0, dwType, pvData, cbData);

        if (hkeyNew != hkey)
            RegCloseKey(hkeyNew);
    }

    return dwRet;

}


/*----------------------------------------------------------
Purpose: Deletes a registry value.  This opens and closes the
         key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
SHDeleteValueA(
    IN  HKEY    hkey,
    IN  LPCSTR  pszSubKey,
    IN  LPCSTR  pszValue)
{
    DWORD dwRet;
    HKEY hkeyNew;

    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_SET_VALUE, &hkeyNew);
    if (NO_ERROR == dwRet)
    {
        dwRet = RegDeleteValueA(hkeyNew, pszValue);
        RegCloseKey(hkeyNew);
    }
    return dwRet;
}


/*----------------------------------------------------------
Purpose: Deletes a registry value.  This opens and closes the
         key in which the value resides.  

         On Win95, this function thunks and calls the ansi
         version.  On NT, this function calls the unicode
         registry APIs directly.

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
SHDeleteValueW(
    IN  HKEY    hkey,
    IN  LPCWSTR pwszSubKey,
    IN  LPCWSTR pwszValue)
{
    DWORD dwRet;
    HKEY hkeyNew;

    if (g_bRunningOnNT)
    {
        dwRet = RegOpenKeyExW(hkey, pwszSubKey, 0, KEY_SET_VALUE, &hkeyNew);
        if (NO_ERROR == dwRet)
        {
            dwRet = RegDeleteValueW(hkeyNew, pwszValue);
            RegCloseKey(hkeyNew);
        }
    }
    else
    {
        CHAR szSubKey[MAX_PATH];
        CHAR szValue[MAX_PATH];
        LPSTR pszSubKey = NULL;
        LPSTR pszValue = NULL;

        if (pwszSubKey)
        {
            WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, szSubKey, SIZECHARS(szSubKey), NULL, NULL);
            pszSubKey = szSubKey;    
        }
        
        if (pwszValue)
        {
            WideCharToMultiByte(CP_ACP, 0, pwszValue, -1, szValue, SIZECHARS(szValue), NULL, NULL);
            pszValue = szValue;
        }

        dwRet = SHDeleteValueA(hkey, pszSubKey, pszValue);
    }

    return dwRet;
}

// purpose: recursively copy subkeys and values of hkeySrc\pszSrcSubKey to hkeyDest
// e.g. hkeyExplorer = HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\
//      SHCopyKey(HKEY_CURRENT_USER, "Software\\Classes\\", hkeyExplorer, 0)
// results in
//      ...\\CurrentVersion\\Explorer\\
//                                     Appid
//                                     CLSID\\
//                                            {xxxx yyyyy ...}
//                                     Interface
//                                     ...
// TO DO: currently we are not copying the ACL's but in the future we should do that
// upon request that's what fReserved is for
// NOTE that there is no hkeyDest, pszDestSubKey pair like src one, because in case
// pszDestSubKey did not exist we would have to create it and deal with Class name
// which would just clober the parameter list
STDAPI_(DWORD) SHCopyKeyA(HKEY hkeySrc, LPCSTR pszSrcSubKey, HKEY hkeyDest, DWORD fReserved)
{
    HKEY hkeyFrom;
    DWORD dwRet;
    
    if (pszSrcSubKey)
        dwRet = RegOpenKeyExA(hkeySrc, pszSrcSubKey, 0, MAXIMUM_ALLOWED, &hkeyFrom);
    else if (hkeySrc)    
    {
        dwRet = ERROR_SUCCESS;
        hkeyFrom = hkeySrc;
    }
    else
        dwRet = ERROR_INVALID_PARAMETER;

    if (dwRet == ERROR_SUCCESS)
    {
        DWORD dwIndex;
        DWORD cchValueSize;
        DWORD cchClassSize;
        DWORD dwType;
        CHAR  szValue[MAX_PATH]; //NOTE:szValue is also used to store subkey name when enumerating keys
        CHAR  szClass[MAX_PATH];
                
        cchValueSize = ARRAYSIZE(szValue);
        cchClassSize = ARRAYSIZE(szClass);
        for (dwIndex=0; 
             dwRet == ERROR_SUCCESS && (dwRet = RegEnumKeyExA(hkeyFrom, dwIndex, szValue, &cchValueSize, NULL, szClass, &cchClassSize, NULL)) == ERROR_SUCCESS; 
             dwIndex++, cchValueSize = ARRAYSIZE(szValue), cchClassSize = ARRAYSIZE(szClass))
        {
            HKEY  hkeyTo;
            DWORD dwDisp;

            // create new key
            dwRet = RegCreateKeyExA(hkeyDest, szValue, 0, szClass, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hkeyTo, &dwDisp);
            if (dwRet != ERROR_SUCCESS)
                break;

            dwRet = SHCopyKeyA(hkeyFrom, szValue, hkeyTo, fReserved); //if not error_success we break out
            RegCloseKey(hkeyTo);
        }

        // copied all the sub keys, now copy all the values
        if (dwRet == ERROR_NO_MORE_ITEMS)
        {
            DWORD  cb, cbBufferSize;
            LPBYTE lpbyBuffer;
            
            // get the max value size
            dwRet = RegQueryInfoKey(hkeyFrom, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &cb, NULL, NULL);
            if (dwRet == ERROR_SUCCESS)
            {
                // allocate buffer
                cb++; // add 1 just in case of a string
                lpbyBuffer = (LPBYTE)LocalAlloc(LPTR, cb);
                if (lpbyBuffer)
                    cbBufferSize = cb;
                else
                    dwRet = ERROR_OUTOFMEMORY;
                    
                cchValueSize = ARRAYSIZE(szValue);
                for (dwIndex=0;
                     dwRet == ERROR_SUCCESS && (dwRet = RegEnumValueA(hkeyFrom, dwIndex, szValue, &cchValueSize, NULL, &dwType, lpbyBuffer, &cb)) == ERROR_SUCCESS;
                     dwIndex++, cchValueSize = ARRAYSIZE(szValue), cb = cbBufferSize)
                {
                    // cb has the size of the value so use it rather than cbBufferSize which is just max size
                    dwRet = RegSetValueExA(hkeyDest, szValue, 0, dwType, lpbyBuffer, cb);
                    if (dwRet != ERROR_SUCCESS)
                        break;
                }

                if (lpbyBuffer != NULL)
                    LocalFree(lpbyBuffer);
            }
        }
    
        if (dwRet == ERROR_NO_MORE_ITEMS)
            dwRet = ERROR_SUCCESS;

        if (pszSrcSubKey)
            RegCloseKey(hkeyFrom);
    }

    return dwRet;
}

STDAPI_(DWORD) SHCopyKeyW(HKEY hkeySrc, LPCWSTR pwszSrcSubKey, HKEY hkeyDest, DWORD fReserved)
{
    CHAR sz[MAX_PATH];
    if (pwszSrcSubKey)
        WideCharToMultiByte(CP_ACP, 0, pwszSrcSubKey, -1, sz, SIZECHARS(sz), NULL, NULL);
    return SHCopyKeyA(hkeySrc, pwszSrcSubKey ? sz : NULL, hkeyDest, fReserved);
}


/*----------------------------------------------------------
Purpose: Delete a key only if there are no subkeys or values.
         It comes close to mimicking the behavior of RegDeleteKey 
         as it works on NT, except the NT version ignores values.

*/
STDAPI_(DWORD)
SHDeleteEmptyKeyA(
    IN  HKEY    hkey,
    IN  LPCSTR  pszSubKey)
{
    return DeleteEmptyKey(hkey, pszSubKey);
}


/*----------------------------------------------------------
Purpose: Delete a key only if there are no subkeys or values.
         It comes close to mimicking the behavior of RegDeleteKey 
         as it works on NT, except the NT version ignores values.

*/
STDAPI_(DWORD)
SHDeleteEmptyKeyW(
    IN  HKEY    hkey,
    IN  LPCWSTR pwszSubKey)
{
    CHAR sz[MAX_PATH];

    WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, sz, SIZECHARS(sz), NULL, NULL);
    return DeleteEmptyKey(hkey, sz);
}


/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
SHDeleteKeyA(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    DWORD dwRet;

    if (g_bRunningOnNT || !pszSubKey)
    {
        dwRet = DeleteKeyRecursively(hkey, pszSubKey);
    }
    else
    {
        // On Win95, RegDeleteKey does what we want
        dwRet = RegDeleteKeyA(hkey, pszSubKey);
    }

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
SHDeleteKeyW(
    IN HKEY    hkey, 
    IN LPCWSTR pwszSubKey)
{
    DWORD dwRet;
    CHAR sz[MAX_PATH];

    WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, sz, SIZECHARS(sz), NULL, NULL);

    if (g_bRunningOnNT)
    {
        dwRet = DeleteKeyRecursively(hkey, sz);
    }
    else
    {
        // On Win95, RegDeleteKey does what we want
        dwRet = RegDeleteKeyA(hkey, sz);
    }

    return dwRet;
}

STDAPI_(DWORD) FixupRegStringA(HKEY hk, PCSTR pszValue, BOOL fExpand, DWORD err, void *pvData, DWORD *pcbData, DWORD *pcbSize);
STDAPI_(DWORD) FixupRegStringW(HKEY hk, PCWSTR pszValue, BOOL fExpand, DWORD err, void *pvData, DWORD *pcbData, DWORD *pcbSize);

/*----------------------------------------------------------
Purpose: Behaves just like RegQueryValueEx, except if the
         data type is REG_EXPAND_SZ, then this goes ahead
         and expands out the string.  *pdwType will always
         be massaged to REG_SZ if this happens.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
SHQueryValueExA(
    IN     HKEY    hkey,
    IN     LPCSTR  pszValue,
    IN     LPDWORD lpReserved,
    OUT    LPDWORD pdwType,
    OUT    LPVOID  pvData,
    IN OUT LPDWORD pcbData)
{
    DWORD dwRet;
    DWORD cbSize = 0;
    DWORD dwType = REG_NONE;
    DWORD cbOriginal = 0;

    if (pvData)
    {
        RIPMSG(pcbData != NULL, "SHQueryValuegExW: caller passed pvData output buffer but not size of buffer (pcbData)!");
    }

    // Trying to get back data

    if (pcbData)
    {
        cbOriginal = cbSize = *pcbData;     // Size of output buffer
    }   
    dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, &dwType,
                             pvData, &cbSize);

    // Normally, we'd be done with this.  But do some extra work
    // if this is an expandable string (something that has system
    // variables in it), or if we need to pad the buffer.
    if (REG_SZ == dwType || REG_EXPAND_SZ == dwType)
    {
        dwRet = FixupRegStringA(hkey, pszValue, REG_EXPAND_SZ == dwType, dwRet, pvData, pcbData, &cbSize);
        // Massage dwType so that callers always see REG_SZ
        dwType = REG_SZ;
    }

    if (pdwType)
        *pdwType = dwType;

    if (pcbData)
        *pcbData = cbSize;

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Behaves just like RegQueryValueEx, except if the
         data type is REG_EXPAND_SZ, then this goes ahead
         and expands out the string.  *pdwType will always
         be massaged to REG_SZ if this happens.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
SHQueryValueExW(
    IN     HKEY    hkey,
    IN     LPCWSTR pwszValue,
    IN     LPDWORD lpReserved,
    OUT    LPDWORD pdwType,
    OUT    LPVOID  pvData,
    IN OUT LPDWORD pcbData)
{
    DWORD dwRet;
    DWORD cbSize = 0;
    DWORD dwType = REG_NONE;

    if (pvData)
    {
        RIPMSG(pcbData != NULL, "SHQueryValueExW: caller passed pvData output buffer but not size of buffer (pcbData)!");
    }

    if ( !g_bRunningOnNT )
    {
        CHAR szValue[MAX_PATH];
        LPSTR pszValue = NULL;
        DWORD dwOriginalSize = 0;

        if (pvData && pcbData)
            dwOriginalSize = *pcbData;

        if (pwszValue)
        {
            WideCharToMultiByte(CP_ACP, 0, pwszValue, -1, szValue, SIZECHARS(szValue), NULL, NULL);
            pszValue = szValue;
        }

        if (!pdwType)
            pdwType = &dwType;

        dwRet = SHQueryValueExA(hkey, pszValue, lpReserved, pdwType, pvData, pcbData);

        if (NO_ERROR == dwRet)
            dwRet = RegData_AtoW(pvData, dwOriginalSize, *pdwType, pcbData);   // Thunk data from ANSI->UNICODE if needed.
    }
    else
    {
        // Running on NT
        // Trying to get back data

        if (pvData && pcbData)
        {
            cbSize = *pcbData;
        }
            
        dwRet = RegQueryValueExW(hkey, pwszValue, lpReserved, &dwType,
                                 pvData, &cbSize);

        // Normally, we'd be done with this.  But do some extra work
        // if this is an expandable string (something that has system
        // variables in it), or if we need to pad the buffer.

        if (REG_SZ == dwType || REG_EXPAND_SZ == dwType)
        {
            dwRet = FixupRegStringW(hkey, pwszValue, REG_EXPAND_SZ == dwType, dwRet, pvData, pcbData, &cbSize);
            // Massage dwType so that callers always see REG_SZ
            dwType = REG_SZ;
        }

        if (pdwType)
            *pdwType = dwType;

        if (pcbData)
            *pcbData = cbSize;
    }

    return dwRet;
}

/*----------------------------------------------------------
Purpose: Behaves just like RegEnumKeyExA, except it does not let
         you look at the class and timestamp of the sub-key. Written
         to provide equivalent for SHEnumKeyExW which is useful on
         Win95.

Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHEnumKeyExA
(
    IN HKEY         hkey,
    IN DWORD        dwIndex,        
    OUT LPSTR       pszName,
    IN OUT LPDWORD  pcchName
)
{
    return RegEnumKeyExA(hkey, dwIndex, pszName, pcchName, NULL, NULL, NULL, NULL);
}          
        
/*----------------------------------------------------------
Purpose: Behaves just like RegEnumKeyExW, except it does not let
         you look at the class and timestamp of the sub-key. 
         Wide char version supported under Win95.

Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHEnumKeyExW
(
    IN HKEY         hkey,
    IN DWORD        dwIndex,        
    OUT LPWSTR      pszName,
    IN OUT LPDWORD  pcchName
)
{
    LONG lRet = NO_ERROR;

    if ( !g_bRunningOnNT )
    {
        // We are reading in sub-key names. regapix.h suggests MAXIMUM_SUB_KEY_LENGTH = 256, 
        // so MAX_PATH should be enough. Is this the official limit.
        CHAR sz[MAX_PATH];  
        DWORD dwSize = sizeof(sz);

        lRet = RegEnumKeyExA(hkey, dwIndex, sz, &dwSize, NULL, NULL, NULL, NULL);
        if (NO_ERROR != lRet)
        {
            ASSERT(ERROR_MORE_DATA != lRet);
        }
        else 
        {
            int cch = MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0);

            if (NULL == pcchName)
            {
                lRet = ERROR_INVALID_PARAMETER;
            }
            else if (NULL == pszName || *pcchName < (DWORD)cch )
            {
                *pcchName = cch;
                lRet = (NULL == pszName) ? ERROR_SUCCESS : ERROR_MORE_DATA ;
            }
            else 
            {
                // Not supposed to include null terminator in count if successful.
                *pcchName = cch - 1;
                MultiByteToWideChar(CP_ACP, 0, sz, -1, pszName, cch);
                ASSERT(NO_ERROR == lRet);
            } 
        }
        
    }
    else
    {
        lRet = RegEnumKeyExW(hkey, dwIndex, pszName, pcchName, NULL, NULL, NULL, NULL);
    }    
    
    return lRet;
}        

/*----------------------------------------------------------
Purpose: Behaves just like RegEnumValueA. Written to provide 
         equivalent for SHEnumKeyExW which is useful on Win95.
         Environment vars in a string are NOT expanded. 

Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHEnumValueA
(
    IN HKEY         hkey,
    IN DWORD        dwIndex,        
    OUT LPSTR       pszValueName,   OPTIONAL
    IN OUT LPDWORD  pcchValueName,   OPTIONAL
    OUT LPDWORD     pdwType,        OPTIONAL
    OUT LPVOID      pvData,         OPTIONAL
    IN OUT LPDWORD  pcbData         OPTIONAL
)
{
    return RegEnumValueA(hkey, dwIndex, pszValueName, pcchValueName, NULL, pdwType, pvData, pcbData);
}


/*----------------------------------------------------------
Purpose: Behaves just like RegEnumValueW. Wide char version
         works on Win95.
         Environment vars in a string are NOT expanded. 
Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHEnumValueW
(
    IN HKEY         hkey,
    IN DWORD        dwIndex,        
    OUT LPWSTR      pszValueName,   OPTIONAL       
    IN OUT LPDWORD  pcchValueName,  OPTIONAL
    OUT LPDWORD     pdwType,        OPTIONAL
    OUT LPVOID      pvData,         OPTIONAL
    IN OUT LPDWORD  pcbData         OPTIONAL
)
{
    LONG lRet;

    if ( !g_bRunningOnNT )
    {
        CHAR sz[MAX_PATH]; // This should be sufficient to read the value name.
        DWORD dwSize = sizeof(sz);
        DWORD dwType;
        DWORD cbSizeSav = 0;

        if (pcbData)
            cbSizeSav = *pcbData;

        lRet = RegEnumValueA(hkey, dwIndex, sz, &dwSize, NULL, &dwType, pvData, pcbData); 

        if (pdwType)
            *pdwType = dwType;

        if (NO_ERROR == lRet)
        {
            // Convert the ValueName to unicode.

            if (pcchValueName)
            {
                int cch = MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0);

                if (NULL == pszValueName || *pcchValueName < (DWORD)cch )
                {
                    *pcchValueName = cch;
                    lRet = (NULL == pszValueName) ? ERROR_SUCCESS : ERROR_MORE_DATA ;
                }
                else 
                {
                    // Not supposed to include null terminator in count if returning
                    // back name succesfully. 
                    *pcchValueName = cch - 1;
                    // cch should be sufficient
                    MultiByteToWideChar(CP_ACP, 0, sz, -1, pszValueName, cch);
                }

            }

            // Next convert the data to unicode if it is a string. 
            if ((NOERROR == lRet) && pcbData)
                lRet = RegData_AtoW(pvData, cbSizeSav, dwType, pcbData);
        }
    }
    else
    {
        lRet = RegEnumValueW(hkey, dwIndex, pszValueName, pcchValueName, NULL, pdwType, pvData, pcbData);
    }
    
    return lRet;                                    
}

/*----------------------------------------------------------
Purpose: Behaves just like RegQueryInfoKeyA. Written to provide
         equivalent for W version. 
Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHQueryInfoKeyA
(
    IN  HKEY        hkey,
    OUT LPDWORD     pcSubKeys,             OPTIONAL
    OUT LPDWORD     pcchMaxSubKeyLen,      OPTIONAL
    OUT LPDWORD     pcValues,              OPTIONAL
    OUT LPDWORD     pcchMaxValueNameLen    OPTIONAL
)
{
    return RegQueryInfoKeyA(hkey, NULL, NULL, NULL, pcSubKeys, pcchMaxSubKeyLen, 
                    NULL, pcValues, pcchMaxValueNameLen, NULL, NULL, NULL);
}                     


/*----------------------------------------------------------
Purpose: Behaves just like RegQueryInfoKeyW. Works on Win95.
Returns: 
Cond:    --
*/

STDAPI_(LONG)
SHQueryInfoKeyW
(
    IN  HKEY        hkey,
    OUT LPDWORD     pcSubKeys,             OPTIONAL
    OUT LPDWORD     pcchMaxSubKeyLen,       OPTIONAL
    OUT LPDWORD     pcValues,              OPTIONAL
    OUT LPDWORD     pcchMaxValueNameLen     OPTIONAL
)
{
    LONG lRet;

    if (!g_bRunningOnNT)
    {
        lRet = RegQueryInfoKeyA(hkey, NULL, NULL, NULL, pcSubKeys, pcchMaxSubKeyLen,
                    NULL, pcValues, pcchMaxValueNameLen, NULL, NULL, NULL);

        if (NO_ERROR == lRet)                
        {
            // *pcchMaxSubKeyLen has the number of single byte chars reqd for the
            // KeyName. We return back the same value which is an upper limit on 
            // the number of Unicode characters needed. We will ask for more
            // Unicode chars than required if the string has DBCS characters.
            // Without knowing the actual string this is the best guess we can take.       
        }
    }
    else
    {
        lRet = RegQueryInfoKeyW(hkey, NULL, NULL, NULL, pcSubKeys, pcchMaxSubKeyLen, 
                        NULL, pcValues, pcchMaxValueNameLen, NULL, NULL, NULL);
    }

    return lRet;
}


/*----------------------------------------------------------*\
        USER SPECIFC SETTINGS

  DESCRIPTION:
    These functions will be used to query User Specific settings
    correctly.  The installer needs to populate HKLM
    with User specific settings, because that's the only part
    of the registry that is shared between all users.  Code will
    then read values from HKCU, and if that's empty, it
    will look in HKLM.  The only exception is that if
    TRUE is passed in for the fIgnore parameter, then the HKLM version
    will be used instead of HKCU.  This is the way that an admin can
    specify that they doesn't want users to be able to use their
    User Specific values (HKCU).
\*----------------------------------------------------------*/

typedef struct tagUSKEY
{
    HKEY    hkeyCurrentUser;
    HKEY    hkeyCurrentUserRelative;
    HKEY    hkeyLocalMachine;
    HKEY    hkeyLocalMachineRelative;
    CHAR    szSubPath[MAXIMUM_SUB_KEY_LENGTH];
    REGSAM  samDesired;
} USKEY;

typedef USKEY * PUSKEY;
typedef PUSKEY * PPUSKEY;

#define IS_HUSKEY_VALID(pUSKey)    (((pUSKey) && IS_VALID_WRITE_PTR((pUSKey), USKEY) && ((pUSKey)->hkeyCurrentUser || (pUSKey)->hkeyLocalMachine)))


// Private Helper Function
// Bring the out of date key up to date.
LONG PrivFullOpen(PUSKEY pUSKey)
{
    LONG       lRet         = ERROR_SUCCESS;
    HKEY       *phkey       = NULL;
    HKEY       *phkeyRel    = NULL;

    ASSERT(IS_HUSKEY_VALID(pUSKey));        // Will always be true, but assert against maintainence mistakes

    if (!pUSKey->hkeyCurrentUser)           // Do we need to open HKCU?
    {
        phkey = &(pUSKey->hkeyCurrentUser);
        phkeyRel = &(pUSKey->hkeyCurrentUserRelative);
    }
    if (!pUSKey->hkeyLocalMachine)          // Do we need to open HKLM?
    {
        phkey = &(pUSKey->hkeyLocalMachine);
        phkeyRel = &(pUSKey->hkeyLocalMachineRelative);
    }

    if ((phkeyRel) && (*phkeyRel))
    {
        ASSERT(phkey);        // Will always be true, but assert against maintainence mistakes

        lRet = RegOpenKeyExA(*phkeyRel, pUSKey->szSubPath, 0, pUSKey->samDesired, phkey);

        // If we need to bring the out of date key, up to date, we need to free the old one.
        if ((HKEY_CURRENT_USER != *phkeyRel) && (HKEY_LOCAL_MACHINE != *phkeyRel))
            RegCloseKey(*phkeyRel);
        *phkeyRel = NULL;
        pUSKey->szSubPath[0] = '\0';
    }
    return lRet;
}



// Private Helper Function
// Bring the out of date key up to date.
LONG PrivFullCreate(PUSKEY pUSKey)
{
    LONG       lRet         = ERROR_SUCCESS;
    HKEY       *phkey       = NULL;
    HKEY       *phkeyRel    = NULL;

    ASSERT(IS_HUSKEY_VALID(pUSKey));        // Will always be true, but assert against maintainence mistakes

    if (!pUSKey->hkeyCurrentUser)           // Do we need to open HKCU?
    {
        phkey = &(pUSKey->hkeyCurrentUser);
        phkeyRel = &(pUSKey->hkeyCurrentUserRelative);
    }
    if (!pUSKey->hkeyLocalMachine)          // Do we need to open HKLM?
    {
        phkey = &(pUSKey->hkeyLocalMachine);
        phkeyRel = &(pUSKey->hkeyLocalMachineRelative);
    }

    if ((phkeyRel) && (*phkeyRel))
    {
        ASSERT(phkey);        // Will always be true, but assert against maintainence mistakes

        lRet = RegCreateKeyExA(*phkeyRel, pUSKey->szSubPath, 0, NULL, REG_OPTION_NON_VOLATILE, pUSKey->samDesired, NULL, phkey, NULL);

        // If we need to bring the out of date key, up to date, we need to free the old one.
        if ((HKEY_CURRENT_USER != *phkeyRel) && (HKEY_LOCAL_MACHINE != *phkeyRel))
            RegCloseKey(*phkeyRel);
        *phkeyRel = NULL;
        pUSKey->szSubPath[0] = '\0';
    }
    return lRet;
}


// Private Helper Function
// Create one of the keys (Called for both HKLM and HKCU)
LONG PrivCreateKey(LPHKEY lphkey, LPHKEY lphkeyRelative, LPCSTR lpSubPath, REGSAM samDesired)
{
    LONG    lRet = ERROR_SUCCESS;

    if (*lphkeyRelative)
    {
        lRet = RegCreateKeyExA(*lphkeyRelative, lpSubPath, 0, NULL, REG_OPTION_NON_VOLATILE, samDesired, NULL, lphkey, NULL);
        *lphkeyRelative = NULL;
    }
    else
    {
        // If the relative key == NULL, then we don't have enough of the path to
        // create this key.
        return(ERROR_INVALID_PARAMETER);
    }
    return(lRet);
}



// Private Helper Function
// Query for the specific value.
LONG PrivRegQueryValue(
    IN  PUSKEY          pUSKey,
    IN  HKEY            *phkey,
    IN  LPCWSTR         pwzValue,           // May have been an ANSI String type case.  Use fWideChar to determine if so.
    IN  BOOL            fWideChar,
    OUT LPDWORD         pdwType,            OPTIONAL
    OUT LPVOID          pvData,             OPTIONAL
    OUT LPDWORD         pcbData)            OPTIONAL
{
    LONG       lRet       = ERROR_SUCCESS;

    ASSERT(IS_HUSKEY_VALID(pUSKey));        // Will always be true, but assert against maintainence mistakes

    // It may be necessary to open the key
    if (NULL == *phkey)
        lRet = PrivFullOpen(pUSKey);

    if ((ERROR_SUCCESS == lRet) && (*phkey))
    {
        if (fWideChar)
            lRet = SHQueryValueExW(*phkey, pwzValue, NULL, pdwType, pvData, pcbData);
        else
            lRet = SHQueryValueExA(*phkey, (LPCSTR)pwzValue, NULL, pdwType, pvData, pcbData);
    }
    else
        lRet = ERROR_INVALID_PARAMETER;

    return lRet;
}




// Private Helper Function
// Query for the specific value.
LONG PrivRegWriteValue(
    IN  PUSKEY          pUSKey,
    IN  HKEY            *phkey,
    IN  LPCWSTR         pwzValue,           // May have been an ANSI String type case.  Use fWideChar to determine if so.
    IN  BOOL            bWideChar,
    IN  BOOL            bForceWrite,
    IN  DWORD           dwType,             OPTIONAL
    IN  LPCVOID         pvData,             OPTIONAL
    IN  DWORD           cbData)             OPTIONAL
{
    LONG       lRet       = ERROR_SUCCESS;

    ASSERT(IS_HUSKEY_VALID(pUSKey));        // Will always be true, but assert against maintainence mistakes

    // It may be necessary to open the key
    if (NULL == *phkey)
        lRet = PrivFullCreate(pUSKey);

    // Check if the caller only want's to write value if it's empty
    if (!bForceWrite)
    {   // Yes we need to check before we write.

        if (bWideChar)
            bForceWrite = !(ERROR_SUCCESS == SHQueryValueExW(*phkey, pwzValue, NULL, NULL, NULL, NULL));
        else
            bForceWrite = !(ERROR_SUCCESS == SHQueryValueExA(*phkey, (LPCSTR)pwzValue, NULL, NULL, NULL, NULL));
    }

    if ((ERROR_SUCCESS == lRet) && (*phkey) && bForceWrite)
    {
        if (bWideChar)
            // RegSetValueExW is not supported on Win95 but we have a thunking function.
            lRet = RegSetValueExW(*phkey, pwzValue, 0, dwType, pvData, cbData);
        else
            lRet = RegSetValueExA(*phkey, (LPCSTR)pwzValue, 0, dwType, pvData, cbData);
    }

    return lRet;
}

// Private helper function
// Enum sub-keys of a key.
LONG PrivRegEnumKey(
    IN      PUSKEY          pUSKey,
    IN      HKEY            *phkey,
    IN      DWORD           dwIndex,
    IN      LPWSTR          pwzName,           // May have been an ANSI String type case.  Use fWideChar to determine if so.
    IN      BOOL            fWideChar,
    IN OUT  LPDWORD         pcchName
)
{
    LONG lRet       = ERROR_SUCCESS;

    ASSERT(IS_HUSKEY_VALID(pUSKey));    

    // It may be necessary to open the key
    if (NULL == *phkey)
        lRet = PrivFullOpen(pUSKey);

    if ((ERROR_SUCCESS == lRet) && (*phkey))
    {
        if (fWideChar)
            lRet = SHEnumKeyExW(*phkey, dwIndex, pwzName, pcchName);
        else
            lRet = SHEnumKeyExA(*phkey, dwIndex, (LPSTR)pwzName, pcchName);
    }
    else
        lRet = ERROR_INVALID_PARAMETER;

    return lRet;
}


// Private helper function
// Enum values of a key.
LONG PrivRegEnumValue(
    IN      PUSKEY          pUSKey,
    IN      HKEY            *phkey,
    IN      DWORD           dwIndex,
    IN      LPWSTR          pwzValueName,       // May have been an ANSI String type case.  Use fWideChar to determine if so.
    IN      BOOL            fWideChar,
    IN OUT  LPDWORD         pcchValueName,
    OUT     LPDWORD         pdwType,            OPTIONAL
    OUT     LPVOID          pvData,             OPTIONAL
    IN OUT  LPDWORD         pcbData             OPTIONAL
)
{
    LONG lRet       = ERROR_SUCCESS;

    ASSERT(IS_HUSKEY_VALID(pUSKey));    

    // It may be necessary to open the key
    if (NULL == *phkey)
        lRet = PrivFullOpen(pUSKey);

    if ((ERROR_SUCCESS == lRet) && (*phkey))
    {
        if (fWideChar)
            lRet = SHEnumValueW(*phkey, dwIndex, pwzValueName, pcchValueName, pdwType, pvData, pcbData);
        else
            lRet = SHEnumValueA(*phkey, dwIndex, (LPSTR)pwzValueName, pcchValueName, pdwType, pvData, pcbData);
    }
    else
        lRet = ERROR_INVALID_PARAMETER;

    return lRet;
}

// Query the Key information.
LONG PrivRegQueryInfoKey(
    IN  PUSKEY      pUSKey,
    IN  HKEY        *phkey,
    IN  BOOL        fWideChar,
    OUT LPDWORD     pcSubKeys,             OPTIONAL
    OUT LPDWORD     pcchMaxSubKeyLen,      OPTIONAL
    OUT LPDWORD     pcValues,              OPTIONAL
    OUT LPDWORD     pcchMaxValueNameLen    OPTIONAL
)
{
    LONG lRet       = ERROR_SUCCESS;

    ASSERT(IS_HUSKEY_VALID(pUSKey));

    if (NULL == *phkey)
        lRet = PrivFullOpen(pUSKey);

    if ((ERROR_SUCCESS == lRet) && (*phkey))
    {
        if (fWideChar)
            lRet = SHQueryInfoKeyW(*phkey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
        else
            lRet = SHQueryInfoKeyA(*phkey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
    }
    else
        lRet = ERROR_INVALID_PARAMETER;

    return lRet;
}

/*----------------------------------------------------------
Purpose: Create or open a user specifc registry key (HUSKEY).  

Description: This function will:
    1. Allocate a new USKEY structure.
    2. Initialize the structure.
    3. Create/Open HKLM if that flag is set.
    4. Create/Open HKCU if that flag is set.

    Note that there is no difference between FORCE and
    don't force in the dwFlags parameter.

    The hUSKeyRelative parameter should have also been opened by
    a call to SHRegCreateUSKey.  If SHRegOpenUSKey was called,
    it could have returned ERROR_SUCCESS but still be invalid
    for calling this function.  This will occur if: 1) the parameter
    fIgnoreHKCU was FALSE, 2) it was a relative open, 3) the
    HKCU branch could not be opened because it didn't exist, and
    4) HKLM opened successfully.  This situation renders the
    HUSKEY valid for reading but not writing.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegCreateUSKeyA(
    IN  LPCSTR          pszPath,         
    IN  REGSAM          samDesired,	// security access mask 
    IN  HUSKEY          hUSKeyRelative,	       OPTIONAL
    OUT PHUSKEY         phUSKey,
    IN  DWORD           dwFlags)     // Indicates whether to create/open HKCU, HKLM, or both
{
    PUSKEY      pUSKeyRelative      = (PUSKEY) hUSKeyRelative;
    PPUSKEY     ppUSKey             = (PPUSKEY) phUSKey;
    PUSKEY      pUSKey;
    LONG        lRet                = ERROR_SUCCESS;
    CHAR        szTempPath[MAXIMUM_SUB_KEY_LENGTH]  = "\0";
    LPCSTR      lpszHKLMPath        = szTempPath;
    LPCSTR      lpszHKCUPath        = szTempPath;

    ASSERT(ppUSKey);
    // The following are invalid parameters...
    // 1. ppUSKey cannot be NULL
    // 2. If this is a relative open, pUSKeyRelative needs to be a valid HUSKEY.
    // 3. The user needs to have specified one of the following: SHREGSET_HKCU, SHREGSET_FORCE_HKCU, SHREGSET_HKLM, SHREGSET_FORCE_HKLM.
    if ((!ppUSKey) ||                                                   // 1.
        (pUSKeyRelative && FALSE == IS_HUSKEY_VALID(pUSKeyRelative)) || // 2.
        !(dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU  | SHREGSET_HKLM | SHREGSET_FORCE_HKLM))) // 3.
    {
        return ERROR_INVALID_PARAMETER;
    }

    // The temp path will be used when bringing the keys
    // up todate that was out of date in the Relative key.
    if (pUSKeyRelative)
    {
        lstrcpyA(szTempPath, pUSKeyRelative->szSubPath);
        
        PathAddBackslashA(szTempPath);
    }

    StrNCatA(szTempPath, pszPath, ARRAYSIZE(szTempPath) - lstrlenA(szTempPath) - 1);

    /////  1. Allocate a new USKEY structure.
    pUSKey = *ppUSKey = (PUSKEY)LocalAlloc(LPTR, sizeof(USKEY));
    if (!pUSKey)
        return ERROR_NOT_ENOUGH_MEMORY;

    /////  2. Initialize the structure.
    if (!pUSKeyRelative)
    {
        // Init a new (non-relative) open.
        pUSKey->hkeyLocalMachineRelative    = HKEY_LOCAL_MACHINE;
        pUSKey->hkeyCurrentUserRelative     = HKEY_CURRENT_USER;
    }
    else
    {
        // Init a new (relative) open.
        *pUSKey = *pUSKeyRelative;

        if (pUSKey->hkeyLocalMachine)
        {
            pUSKey->hkeyLocalMachineRelative = pUSKey->hkeyLocalMachine;
            pUSKey->hkeyLocalMachine = NULL;
            lpszHKLMPath = pszPath;

            // This key is up to date in the Relative Key.  If the
            // user doesn't want it to be up todate in the new key,
            // we don't need the path from the Relative key.
            if (!(dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM)))
                *(pUSKey->szSubPath) = '\0';
        }
        // We need to copy the key if:
        // 1. It will not be created in this call, and
        // 2. The relative key is not HKEY_LOCAL_MACHINE.
        if (!(dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM)) &&
            (pUSKey->hkeyLocalMachineRelative != HKEY_LOCAL_MACHINE))
        {
            // Make a duplicate of this key.
            lRet = RegOpenKeyExA(pUSKey->hkeyLocalMachineRelative, NULL, 0, pUSKey->samDesired, &(pUSKey->hkeyLocalMachineRelative));
        }

        if (pUSKey->hkeyCurrentUser)
        {
            pUSKey->hkeyCurrentUserRelative = pUSKey->hkeyCurrentUser;
            pUSKey->hkeyCurrentUser = NULL;
            lpszHKCUPath = pszPath;

            // This key is up to date in the Relative Key.  If the
            // user doesn't want it to be up todate in the new key,
            // we don't need the path from the Relative key.
            if (!(dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU)))
                *(pUSKey->szSubPath) = '\0';
        }
        // We need to copy the key if:
        // 1. It will not be created in this call, and
        // 2. The relative key is not HKEY_CURRENT_USER.
        if (!(dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU)) &&
            (pUSKey->hkeyCurrentUserRelative != HKEY_CURRENT_USER))
        {
            // Make a duplicate of this key.
            lRet = RegOpenKeyExA(pUSKey->hkeyCurrentUserRelative, NULL, 0, pUSKey->samDesired, &(pUSKey->hkeyCurrentUserRelative));
        }
    }
    pUSKey->samDesired = samDesired;


    /////  3. Create/Open HKLM if that flag is set or fill in the structure as appropriate.
    if ((ERROR_SUCCESS == lRet) && (dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM)))
        lRet = PrivCreateKey(&(pUSKey->hkeyLocalMachine), &(pUSKey->hkeyLocalMachineRelative), lpszHKLMPath, pUSKey->samDesired);

    /////  4. Create/Open HKCU if that flag is set or fill in the structure as appropriate.
    if ((ERROR_SUCCESS == lRet) && (dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU)))
        lRet = PrivCreateKey(&(pUSKey->hkeyCurrentUser), &(pUSKey->hkeyCurrentUserRelative), lpszHKCUPath, pUSKey->samDesired);

    if ((dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU)) &&
        (dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM))) 
    {
        // The caller wanted both to be opened.
        *(pUSKey->szSubPath) = '\0';       // Both paths are open so Delta Path is empty.
    }
    else
    {
        // One of the paths is not open so set the Delta Path in case it needs to be opened later.
        if (*(pUSKey->szSubPath))
            PathAddBackslashA(pUSKey->szSubPath);

        StrNCatA(pUSKey->szSubPath, pszPath, ARRAYSIZE(pUSKey->szSubPath) - lstrlenA(pUSKey->szSubPath) - 1);
    }

    // Free the memory if we are not successful.
    if (ERROR_SUCCESS != lRet)
    {
        if (pUSKey->hkeyCurrentUser)
            RegCloseKey(pUSKey->hkeyCurrentUser);
        if (pUSKey->hkeyCurrentUserRelative && pUSKey->hkeyCurrentUserRelative != HKEY_CURRENT_USER)
            RegCloseKey(pUSKey->hkeyCurrentUserRelative);
        if (pUSKey->hkeyLocalMachine)
            RegCloseKey(pUSKey->hkeyLocalMachine);
        if (pUSKey->hkeyLocalMachineRelative && pUSKey->hkeyLocalMachineRelative != HKEY_LOCAL_MACHINE)
            RegCloseKey(pUSKey->hkeyLocalMachineRelative);
        LocalFree((HLOCAL)pUSKey);
        *ppUSKey = NULL;
    }

    return lRet;
}







/*----------------------------------------------------------
Purpose: Create or open a user specifc registry key (HUSKEY).  

Description: This function will:
    1. Allocate a new USKEY structure.
    2. Initialize the structure.
    3. Create/Open HKLM if that flag is set.
    4. Create/Open HKCU if that flag is set.

    Note that there is no difference between FORCE and
    don't force in the dwFlags parameter.

    The hUSKeyRelative parameter should have also been opened by
    a call to SHRegCreateUSKey.  If SHRegOpenUSKey was called,
    it could have returned ERROR_SUCCESS but still be invalid
    for calling this function.  This will occur if: 1) the parameter
    fIgnoreHKCU was FALSE, 2) it was a relative open, 3) the
    HKCU branch could not be opened because it didn't exist, and
    4) HKLM opened successfully.  This situation renders the
    HUSKEY valid for reading but not writing.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegCreateUSKeyW(
    IN  LPCWSTR         pwzPath,
    IN  REGSAM          samDesired,	// security access mask 
    IN  HUSKEY          hUSKeyRelative,	       OPTIONAL
    OUT PHUSKEY         phUSKey,
    IN  DWORD           dwFlags)     // Indicates whether to create/open HKCU, HKLM, or both
{
    CHAR   szNewPath[MAXIMUM_SUB_KEY_LENGTH];

    // Thunk Path to Wide chars.
    if (FALSE == WideCharToMultiByte(CP_ACP, 0, pwzPath, -1, szNewPath, sizeof(szNewPath), NULL, 0))
        return GetLastError();

    return SHRegCreateUSKeyA(szNewPath, samDesired, hUSKeyRelative, phUSKey, dwFlags);
}



/*----------------------------------------------------------
Purpose: Open a user specifc registry key (HUSKEY).  

Description: This function will:
    1. Allocate a new USKEY structure.
    2. Initialize the structure.
    3. Determine which key (HKLM or HKCU) will be the one brought up to date.
    4. Open the key that is going to be brought up to date.

    If #4 Succeeded:
    5a. Copy the handle of the out of date key, so it can be opened later if needed.

    If #4 Failed:
    5b. The other key will now be the one brought up to date, as long as it is HKLM.
    6b. Tag the out of date as INVALID. (Key == NULL; RelKey == NULL)

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegOpenUSKeyA(
    IN  LPCSTR          pszPath,         
    IN  REGSAM          samDesired,	// security access mask 
    IN  HUSKEY          hUSKeyRelative,	       OPTIONAL
    OUT PHUSKEY         phUSKey,     
    IN  BOOL            fIgnoreHKCU)           
{
    PUSKEY      pUSKeyRelative      = (PUSKEY) hUSKeyRelative;
    PPUSKEY     ppUSKey             = (PPUSKEY) phUSKey;
    PUSKEY      pUSKey;
    LONG        lRet               = ERROR_SUCCESS;
    HKEY        * phkeyMaster;
    HKEY        * phkeyRelMaster;
    HKEY        * phkeyOld;
    HKEY        * phkeyRelOld;

    ASSERT(ppUSKey);

    // The following are invalid parameters...
    // 1. ppUSKey cannot be NULL
    // 2. If this is a relative open, pUSKeyRelative needs to be a valid HUSKEY.
    if ((!ppUSKey) ||                                                   // 1.
        (pUSKeyRelative && FALSE == IS_HUSKEY_VALID(pUSKeyRelative)))   // 2.
    {
        return ERROR_INVALID_PARAMETER;
    }


    /////  1. Allocate a new USKEY structure.
    pUSKey = *ppUSKey = (PUSKEY)LocalAlloc(LPTR, sizeof(USKEY));
    if (!pUSKey)
        return ERROR_NOT_ENOUGH_MEMORY;

    /////  2. Initialize the structure.
    if (!pUSKeyRelative)
    {
        // Init a new (non-relative) open.
        pUSKey->hkeyLocalMachineRelative    = HKEY_LOCAL_MACHINE;
        pUSKey->hkeyCurrentUserRelative     = HKEY_CURRENT_USER;
    }
    else
    {
        // Init a new (relative) open.
        *pUSKey = *pUSKeyRelative;
    }
    pUSKey->samDesired = samDesired;


    /////  3. Determine which key (HKLM or HKCU) will be the one brought up to date.
    // The HUSKY struct will contain 4 HKEYs. HKCU, HKCU Relative, HKLM, and HKLM Relative.
    // For efficiency, only one key will be up to date (HKCU or HKLM).  The one that
    // is out of date will be NULL to indicate out of date.  The relative key for the
    // out of date key, will be the last opened key.  The string will be the delta between
    // the last open key and the current open level.

    // We will determine which key will be the new valid key (Master).
    if (FALSE == fIgnoreHKCU)
    {
        phkeyMaster     = &(pUSKey->hkeyCurrentUser);
        phkeyRelMaster  = &(pUSKey->hkeyCurrentUserRelative);
        phkeyOld        = &(pUSKey->hkeyLocalMachine);
        phkeyRelOld     = &(pUSKey->hkeyLocalMachineRelative);
    }
    else
    {
        phkeyMaster     = &(pUSKey->hkeyLocalMachine);
        phkeyRelMaster  = &(pUSKey->hkeyLocalMachineRelative);
        phkeyOld        = &(pUSKey->hkeyCurrentUser);
        phkeyRelOld     = &(pUSKey->hkeyCurrentUserRelative);
    }

    // Add the new Path to the Total path.
    if ('\0' != *(pUSKey->szSubPath)) 
        PathAddBackslashA(pUSKey->szSubPath);  // Add separator \ if reqd. 

    StrNCatA(pUSKey->szSubPath, pszPath, ARRAYSIZE(pUSKey->szSubPath) - lstrlenA(pUSKey->szSubPath) - 1);

    /////  4. Open the key that is going to be brought up to date.
    if (*phkeyMaster)
    {
        // Masterkey is already up to date, so just do the relative open and add the string to szSubPath
        // It's safe to write write (*phkeyMaster) because it will be freed by the HUSKEY used for the
        // relative open.
        lRet = RegOpenKeyExA(*phkeyMaster, pszPath, 0, pUSKey->samDesired, phkeyMaster);
    }
    else
    {

        // Open Masterkey with the full path (pUSKey->szSubPath + pszPath)
        if (*phkeyRelMaster)
            lRet = RegOpenKeyExA(*phkeyRelMaster, pUSKey->szSubPath, 0, pUSKey->samDesired, phkeyMaster);
        else
            lRet = ERROR_FILE_NOT_FOUND;

        lstrcpyA(pUSKey->szSubPath, pszPath);
        *phkeyRelMaster = NULL;
    }

    /////  Did #4 Succeeded?
    if (ERROR_FILE_NOT_FOUND == lRet)
    {
        /////  #4 Failed, Now we can try to open HKLM if the previous attempt was to open HKCU.
        if (!fIgnoreHKCU)
        {
            if (*phkeyRelOld)       // Can HKLM be opened?
            {
                ASSERT(*phkeyOld == NULL);       // *phkeyOld should never have a value if *phkeyRelOld does.

                /////  5b. The other key will now be the one brought up to date, as long as it is HKLM.
                lRet = RegOpenKeyExA(*phkeyRelOld, pUSKey->szSubPath, 0, pUSKey->samDesired, phkeyOld);
                *phkeyRelOld = NULL;
            }
            else if (*phkeyOld)       // Can HKLM be opened?
            {
                /////  5b. Attempt to bring the other key up to date.
                lRet = RegOpenKeyExA(*phkeyOld, pUSKey->szSubPath, 0, pUSKey->samDesired, phkeyOld);
            }
        }
        else
        {
            *phkeyOld = NULL;            // Tag this as INVALID
            *phkeyRelOld = NULL;         // Tag this as INVALID
        }

        /////  6b. Tag the out of date as INVALID. (Key == NULL; RelKey == NULL)
        *phkeyMaster = NULL;            // Tag this as INVALID
        *phkeyRelMaster = NULL;         // Tag this as INVALID
    }
    else
    {
        /////  #4 Succeeded:
        /////  5a. Does the out of date key need to be copied?
        if (*phkeyOld)
        {
            // Copy the handle of the out of date key, so it can be opened later if needed.
            // We can be assured that any NON-Relative HKEY will not be HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER
            ASSERT(*phkeyOld != HKEY_LOCAL_MACHINE && *phkeyOld != HKEY_CURRENT_USER);       // But let's assert anyway.

            RegOpenKeyExA(*phkeyOld, NULL, 0, pUSKey->samDesired, phkeyOld);
        }
        else
        {
            if ((*phkeyRelOld) && (*phkeyRelOld != HKEY_LOCAL_MACHINE) && (*phkeyRelOld != HKEY_CURRENT_USER))
            {
                // Copy the handle of the out of date key, so it can be opened later if needed.
                lRet = RegOpenKeyExA(*phkeyRelOld, NULL, 0, pUSKey->samDesired, phkeyRelOld);
            }
        }

        if (*phkeyOld)
        {
            *phkeyRelOld = *phkeyOld;
            *phkeyOld = NULL;        // Mark this key as being out of date.
        }
    }

    // Free the memory if we are not successful.
    if (ERROR_SUCCESS != lRet)
    {
        pUSKey->hkeyCurrentUser     = NULL;     // Mark invalid.
        pUSKey->hkeyLocalMachine    = NULL;
        LocalFree((HLOCAL)pUSKey);
        *ppUSKey = NULL;
    }

    return lRet;
}







/*----------------------------------------------------------
Purpose: Open a user specifc registry key (HUSKEY).  

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegOpenUSKeyW(
    IN  LPCWSTR         pwzPath,         
    IN  REGSAM          samDesired,	// security access mask 
    IN  HUSKEY          hUSKeyRelative,	       OPTIONAL
    OUT PHUSKEY         phUSKey,     
    IN  BOOL            fIgnoreHKCU)           
{
    CHAR   szNewPath[MAXIMUM_SUB_KEY_LENGTH];

    // Thunk Path to Wide chars.
    if (FALSE == WideCharToMultiByte(CP_ACP, 0, pwzPath, -1, szNewPath, sizeof(szNewPath), NULL, 0))
        return GetLastError();

    return SHRegOpenUSKeyA(szNewPath, samDesired, hUSKeyRelative, phUSKey, fIgnoreHKCU);
}



/*----------------------------------------------------------
Purpose: Query a user specific registry entry for it's value.  
         This will NOT
         open and close the keys in which the value resides. 
         The caller needs to do this and it should be done
         when several keys will be queried for a perf increase.
         Callers that only call this once, will probably want
         to call SHGetUSValue().

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegQueryUSValueA(
    IN  HUSKEY          hUSKey,
    IN  LPCSTR          pszValue,           
    OUT LPDWORD         pdwType,            OPTIONAL
    OUT LPVOID          pvData,             OPTIONAL
    OUT LPDWORD         pcbData,            OPTIONAL
    IN  BOOL            fIgnoreHKCU,
    IN  LPVOID          pvDefaultData,      OPTIONAL
    IN  DWORD           dwDefaultDataSize)  OPTIONAL
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_SUCCESS;
    DWORD       dwSize      = (pcbData ? *pcbData : 0);
    DWORD       dwType      = (pdwType ? *pdwType : 0); // callers responsibility to set pdwType to the type of pvDefaultData (if they care)

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (!fIgnoreHKCU)
    {
        lRet = PrivRegQueryValue(pUSKey, &(pUSKey->hkeyCurrentUser), (LPWSTR)pszValue, 
                                    FALSE, pdwType, pvData, pcbData);
    }
    if (fIgnoreHKCU || ERROR_SUCCESS != lRet)
    {
        if (pcbData)
            *pcbData = dwSize;  // We may need to reset if previous open failed.

        lRet = PrivRegQueryValue(pUSKey, &(pUSKey->hkeyLocalMachine), (LPWSTR)pszValue, 
                                    FALSE, pdwType, pvData, pcbData);
    }

    // if fail, use default value.
    if ((ERROR_SUCCESS != lRet) && (pvDefaultData) && (dwDefaultDataSize) && 
        (pvData) && (dwSize >= dwDefaultDataSize))
    {
        MoveMemory(pvData, pvDefaultData, dwDefaultDataSize);
        if (pcbData)
        {
            *pcbData = dwDefaultDataSize;
        }
        if (pdwType)
        {
            *pdwType = dwType;
        }
        lRet = ERROR_SUCCESS;       // Call will now use a default value.
    }

    return lRet;
}



/*----------------------------------------------------------
Purpose: Query a user specific registry entry for it's value.    
         This will NOT
         open and close the keys in which the value resides. 
         The caller needs to do this and it should be done
         when several keys will be queried for a perf increase.
         Callers that only call this once, will probably want
         to call SHGetUSValue().

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegQueryUSValueW(
    IN  HUSKEY          hUSKey,
    IN  LPCWSTR         pwzValue,           
    OUT LPDWORD         pdwType,            OPTIONAL
    OUT LPVOID          pvData,             OPTIONAL
    OUT LPDWORD         pcbData,            OPTIONAL
    IN  BOOL            fIgnoreHKCU,
    IN  LPVOID          pvDefaultData,      OPTIONAL
    IN  DWORD           dwDefaultDataSize)  OPTIONAL
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet;
    DWORD       dwSize      = (pcbData ? *pcbData : 0);
    DWORD       dwType      = (pdwType ? *pdwType : 0); // callers responsibility to set pdwType to the type of pvDefaultData (if they care)


    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (!fIgnoreHKCU)
    {
        lRet = PrivRegQueryValue(pUSKey, &(pUSKey->hkeyCurrentUser), pwzValue, 
                                    TRUE, pdwType, pvData, pcbData);
    }
    if (fIgnoreHKCU || ERROR_SUCCESS != lRet)
    {
        if (pcbData)
            *pcbData = dwSize;  // We may need to reset if previous open failed.
        lRet = PrivRegQueryValue(pUSKey, &(pUSKey->hkeyLocalMachine), pwzValue, 
                                    TRUE, pdwType, pvData, pcbData);
    }

    // if fail, use default value.
    if ((ERROR_SUCCESS != lRet) && (pvDefaultData) && (dwDefaultDataSize) && 
        (pvData) && (dwSize >= dwDefaultDataSize))
    {
        MoveMemory(pvData, pvDefaultData, dwDefaultDataSize);
        if (pcbData)
        {
            *pcbData = dwDefaultDataSize;
        }
        if (pdwType)
        {
            *pdwType = dwType;
        }
     
        lRet = ERROR_SUCCESS;       // Call will now use a default value.
    }

    return lRet;
}






/*----------------------------------------------------------
Purpose: Write a user specific registry entry.  

Parameters:
  hUSKey - Needs to have been open with KEY_SET_VALUE permissions.
           KEY_QUERY_VALUE also needs to have been used if this is
           not a force write.
  pszValue - Registry Key value to write to.
  dwType - Type for the new registry key.
  pvData - Pointer to data to store
  cbData - Size of data to store.  
  dwFlags - Flags to determine if the registry entry should be written to
            HKLM, HKCU, or both.  Also determines if these are force or
            non-force writes. (non-force means it will only write the value
            if it's empty)  Using FORCE is faster than non-force.

Decription:
    This function will write the value to the
    registry in either the HKLM or HKCU branches depending
    on the flags set in the dwFlags parameter.
    
Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegWriteUSValueA(
    IN  HUSKEY          hUSKey,
    IN  LPCSTR          pszValue,           
    IN  DWORD           dwType,
    IN  LPCVOID         pvData,
    IN  DWORD           cbData,
    IN  DWORD           dwFlags)
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_SUCCESS;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    // Assert if: 1) This is not a force open, and 2) they key was not
    // opened with KEY_QUERY_VALUE permissions.
    if (!(dwFlags & (SHREGSET_FORCE_HKCU|SHREGSET_FORCE_HKLM)) && !(pUSKey->samDesired & KEY_QUERY_VALUE))
    {
        ASSERT(NULL);   // ERROR_INVALID_PARAMETER
        return(ERROR_INVALID_PARAMETER);
    }

    if (dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU))
    {
        lRet = PrivRegWriteValue(pUSKey, &(pUSKey->hkeyCurrentUser), (LPWSTR)pszValue, 
            FALSE, dwFlags & SHREGSET_FORCE_HKCU, dwType, pvData, cbData);
    }
    if ((dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM)) && (ERROR_SUCCESS == lRet))
    {
        lRet = PrivRegWriteValue(pUSKey, &(pUSKey->hkeyLocalMachine), (LPWSTR)pszValue, 
            FALSE, dwFlags & SHREGSET_FORCE_HKLM, dwType, pvData, cbData);
    }

    return lRet;
}



/*----------------------------------------------------------
Purpose: Write a user specific registry entry.  

Parameters:
  hUSKey - Needs to have been open with KEY_SET_VALUE permissions.
           KEY_QUERY_VALUE also needs to have been used if this is
           not a force write.
  pszValue - Registry Key value to write to.
  dwType - Type for the new registry key.
  pvData - Pointer to data to store
  cbData - Size of data to store.  
  dwFlags - Flags to determine if the registry entry should be written to
            HKLM, HKCU, or both.  Also determines if these are force or
            non-force writes. (non-force means it will only write the value
            if it's empty)  Using FORCE is faster than non-force.

Decription:
    This function will write the value to the
    registry in either the HKLM or HKCU branches depending
    on the flags set in the dwFlags parameter.
    
Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegWriteUSValueW(
    IN  HUSKEY          hUSKey,
    IN  LPCWSTR         pwzValue,           
    IN  DWORD           dwType,
    IN  LPCVOID         pvData,
    IN  DWORD           cbData,
    IN  DWORD           dwFlags)
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_SUCCESS;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    // Assert if: 1) This is not a force open, and 2) they key was not
    // opened with access permissions.
    if (!(dwFlags & (SHREGSET_FORCE_HKCU|SHREGSET_FORCE_HKLM)) && !(pUSKey->samDesired & KEY_QUERY_VALUE))
    {
        ASSERT(NULL);   // ERROR_INVALID_PARAMETER
        return(ERROR_INVALID_PARAMETER);
    }

    if (dwFlags & (SHREGSET_HKCU | SHREGSET_FORCE_HKCU))
    {
        lRet = PrivRegWriteValue(pUSKey, &(pUSKey->hkeyCurrentUser), (LPWSTR)pwzValue, 
                                    TRUE, dwFlags & SHREGSET_FORCE_HKCU, dwType, pvData, cbData);
    }
    if (dwFlags & (SHREGSET_HKLM | SHREGSET_FORCE_HKLM))
    {
        lRet = PrivRegWriteValue(pUSKey, &(pUSKey->hkeyLocalMachine), (LPWSTR)pwzValue, 
                                    TRUE, dwFlags & SHREGSET_FORCE_HKLM, dwType, pvData, cbData);
    }

    return lRet;
}





/*----------------------------------------------------------
Purpose: Deletes a registry value.  This will delete HKLM,
         HKCU, or both depending on the hkey parameter. 

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegDeleteUSValueA(
    IN  HUSKEY          hUSKey,
    IN  LPCSTR          pszValue,           
    IN  SHREGDEL_FLAGS  delRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGDEL_DEFAULT == delRegFlags)        // Delete whatever keys are open
    {
        if (!pUSKey->hkeyCurrentUser)  // Attempt to open HKCU if not currently open
            lRet = PrivFullOpen(pUSKey);

        if (pUSKey->hkeyCurrentUser)
            delRegFlags = SHREGDEL_HKCU;
        else
        {
            // We prefer to delete HKCU, but we got here, so we will delete HKLM
            // if it is open.
            if (pUSKey->hkeyLocalMachine)
                delRegFlags = SHREGDEL_HKLM;
        }
    }

    if (IsFlagSet(delRegFlags, SHREGDEL_HKCU))        // Check if the call wants to delete the HKLM value.
    {
        if (!pUSKey->hkeyCurrentUser)
            PrivFullOpen(pUSKey);
        if (pUSKey->hkeyCurrentUser)
        {
            lRet = RegDeleteValueA(pUSKey->hkeyCurrentUser, pszValue);
            if (ERROR_FILE_NOT_FOUND == lRet)
                delRegFlags = SHREGDEL_HKLM;        // Delete the HKLM value if the HKCU value wasn't found.
        }
    }

    if (IsFlagSet(delRegFlags, SHREGDEL_HKLM))        // Check if the call wants to delete the HKLM value.
    {
        if (!pUSKey->hkeyLocalMachine)
            PrivFullOpen(pUSKey);
        if (pUSKey->hkeyLocalMachine)
            lRet = RegDeleteValueA(pUSKey->hkeyLocalMachine, pszValue);
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Deletes a registry value.  This will delete HKLM,
         HKCU, or both depending on the hkey parameter. 

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegDeleteUSValueW(
    IN  HUSKEY          hUSKey,
    IN  LPCWSTR         pwzValue,           
    IN  SHREGDEL_FLAGS  delRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    CHAR   szNewPath[MAXIMUM_VALUE_NAME_LENGTH];

    // Thunk Path to Wide chars.
    if (FALSE == WideCharToMultiByte(CP_ACP, 0, pwzValue, -1, szNewPath, sizeof(szNewPath), NULL, 0))
        return GetLastError();

    return SHRegDeleteUSValueA(hUSKey, szNewPath, delRegFlags);
}


/*----------------------------------------------------------
Purpose: Deletes a registry sub-key if empty.  This will delete HKLM,
         HKCU, or both depending on the delRegFlags parameter. 

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegDeleteEmptyUSKeyA(
    IN  HUSKEY          hUSKey,
    IN  LPCSTR          pszSubKey,           
    IN  SHREGDEL_FLAGS  delRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGDEL_DEFAULT == delRegFlags)        // Delete whatever keys are open
    {
        if (!pUSKey->hkeyCurrentUser)  // Attempt to open HKCU if not currently open
            lRet = PrivFullOpen(pUSKey);

        if (pUSKey->hkeyCurrentUser)
            delRegFlags = SHREGDEL_HKCU;
        else
        {
            // We prefer to delete HKCU, but we got here, so we will delete HKLM
            // if it is open.
            if (pUSKey->hkeyLocalMachine)
                delRegFlags = SHREGDEL_HKLM;
        }
    }

    if (IsFlagSet(delRegFlags, SHREGDEL_HKCU))        // Check if the call wants to delete the HKLM key.
    {
        if (!pUSKey->hkeyCurrentUser)
            PrivFullOpen(pUSKey);
        if (pUSKey->hkeyCurrentUser)
        {
            lRet = SHDeleteEmptyKeyA(pUSKey->hkeyCurrentUser, pszSubKey);
            if (ERROR_FILE_NOT_FOUND == lRet)
                delRegFlags = SHREGDEL_HKLM;        // Delete the HKLM key if the HKCU key wasn't found.
        }
    }

    if (IsFlagSet(delRegFlags, SHREGDEL_HKLM))        // Check if the call wants to delete the HKLM key.
    {
        if (!pUSKey->hkeyLocalMachine)
            PrivFullOpen(pUSKey);
        if (pUSKey->hkeyLocalMachine)
            lRet = SHDeleteEmptyKeyA(pUSKey->hkeyLocalMachine, pszSubKey);
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Deletes a registry key if empty.  This will delete HKLM,
         HKCU, or both depending on the delRegFlags parameter. 

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegDeleteEmptyUSKeyW(
    IN  HUSKEY          hUSKey,
    IN  LPCWSTR         pwzSubKey,           
    IN  SHREGDEL_FLAGS  delRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    CHAR   szNewPath[MAXIMUM_SUB_KEY_LENGTH];

    // Thunk Path to Wide chars.
    if (FALSE == WideCharToMultiByte(CP_ACP, 0, pwzSubKey, -1, szNewPath, sizeof(szNewPath), NULL, 0))
        return GetLastError();

    return SHRegDeleteEmptyUSKeyA(hUSKey, szNewPath, delRegFlags);
}


/*----------------------------------------------------------
Purpose: Enumerates sub-keys under a given HUSKEY.
         
         SHREGENUM_FLAGS specifies how to do the enumeration.
         SHREGENUM_DEFAULT - Will look in HKCU followed by HKLM if not found.
         SHREGENUM_HKCU - Enumerates HKCU only.
         SHREGENUM_HKLM = Enumerates HKLM only.
         SHREGENUM_BOTH - This is supposed to do a union of the HKLM and HKCU subkeys. 

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegEnumUSKeyA(
    IN  HUSKEY          hUSKey,
    IN  DWORD           dwIndex,
    OUT LPSTR           pszName,
    IN  LPDWORD         pcchName,           
    IN  SHREGENUM_FLAGS enumRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegEnumKey(pUSKey, &(pUSKey->hkeyCurrentUser), dwIndex,
                                (LPWSTR)pszName, FALSE, pcchName);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet) && (ERROR_NO_MORE_ITEMS != lRet))))
    {
        lRet = PrivRegEnumKey(pUSKey, &(pUSKey->hkeyLocalMachine), dwIndex,
                                (LPWSTR)pszName, FALSE, pcchName);
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Enumerates sub-keys under a given HUSKEY.
         
         SHREGENUM_FLAGS specifies how to do the enumeration.
         SHREGENUM_DEFAULT - Will look in HKCU followed by HKLM if not found.
         SHREGENUM_HKCU - Enumerates HKCU only.
         SHREGENUM_HKLM = Enumerates HKLM only.
         SHREGENUM_BOTH - This is supposed to do a union of the HKLM and HKCU subkeys. 

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegEnumUSKeyW(
    IN  HUSKEY          hUSKey,
    IN  DWORD           dwIndex,
    OUT LPWSTR          pszName,
    IN  LPDWORD         pcchName,           
    IN  SHREGENUM_FLAGS enumRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegEnumKey(pUSKey, &(pUSKey->hkeyCurrentUser), dwIndex,
                                pszName, TRUE, pcchName);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet) && (ERROR_NO_MORE_ITEMS != lRet))))
    {
        lRet = PrivRegEnumKey(pUSKey, &(pUSKey->hkeyLocalMachine), dwIndex,
                                pszName, TRUE, pcchName);
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Enumerates Values under a given HUSKEY.
         
         SHREGENUM_FLAGS specifies how to do the enumeration.
         SHREGENUM_DEFAULT - Will look in HKCU followed by HKLM if not found.
         SHREGENUM_HKCU - Enumerates HKCU only.
         SHREGENUM_HKLM = Enumerates HKLM only.
         SHREGENUM_BOTH - This is supposed to do a union of the HKLM and HKCU subkeys. 

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegEnumUSValueA(
    IN  HUSKEY          hUSKey,
    IN  DWORD           dwIndex,
    OUT LPSTR           pszValueName,       
    IN  LPDWORD         pcchValueNameLen,
    OUT LPDWORD         pdwType,            OPTIONAL
    OUT LPVOID          pvData,             OPTIONAL
    OUT LPDWORD         pcbData,            OPTIONAL
    IN  SHREGENUM_FLAGS enumRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegEnumValue(pUSKey, &(pUSKey->hkeyCurrentUser), dwIndex,
                                (LPWSTR)pszValueName, FALSE, pcchValueNameLen, pdwType, pvData, pcbData);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet) && (ERROR_NO_MORE_ITEMS != lRet))))
    {
        lRet = PrivRegEnumValue(pUSKey, &(pUSKey->hkeyLocalMachine), dwIndex,
                                (LPWSTR)pszValueName, FALSE, pcchValueNameLen, pdwType, pvData, pcbData);
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Enumerates Values under a given HUSKEY.
         
         SHREGENUM_FLAGS specifies how to do the enumeration.
         SHREGENUM_DEFAULT - Will look in HKCU followed by HKLM if not found.
         SHREGENUM_HKCU - Enumerates HKCU only.
         SHREGENUM_HKLM = Enumerates HKLM only.
         SHREGENUM_BOTH - This is supposed to do a union of the HKLM and HKCU subkeys. 

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegEnumUSValueW(
    IN  HUSKEY          hUSKey,
    IN  DWORD           dwIndex,
    OUT LPWSTR          pszValueName,       
    IN  LPDWORD         pcchValueNameLen,   
    OUT LPDWORD         pdwType,            OPTIONAL
    OUT LPVOID          pvData,             OPTIONAL
    OUT LPDWORD         pcbData,            OPTIONAL
    IN  SHREGENUM_FLAGS enumRegFlags)               // (HKLM, HKCU, or (HKLM | HKCU))
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegEnumValue(pUSKey, &(pUSKey->hkeyCurrentUser), dwIndex,
                                pszValueName, TRUE, pcchValueNameLen, pdwType, pvData, pcbData);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet) && (ERROR_NO_MORE_ITEMS != lRet))))
    {
        lRet = PrivRegEnumValue(pUSKey, &(pUSKey->hkeyLocalMachine), dwIndex,
                                pszValueName, TRUE, pcchValueNameLen, pdwType, pvData, pcbData);
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Gets Info about a HUSKEY.
         Re-uses same flags as enumeration functions. 
         Look at SHRegEnumKeyExA for an explanation of the flags.

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegQueryInfoUSKeyA
(
    IN  HUSKEY              hUSKey,
    OUT LPDWORD             pcSubKeys,             OPTIONAL
    OUT LPDWORD             pcchMaxSubKeyLen,      OPTIONAL
    OUT LPDWORD             pcValues,              OPTIONAL
    OUT LPDWORD             pcchMaxValueNameLen,   OPTIONAL
    IN SHREGENUM_FLAGS      enumRegFlags
)
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegQueryInfoKey(pUSKey, &(pUSKey->hkeyCurrentUser), FALSE,
                                pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet))))
    {
        lRet = PrivRegQueryInfoKey(pUSKey, &(pUSKey->hkeyLocalMachine), FALSE,
                                pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Gets Info about a HUSKEY.
         Re-uses same flags as enumeration functions. 
         Look at SHRegEnumKeyExA for an explanation of the flags.

Returns: LONG containing success or error code.
Cond:    --
*/

STDAPI_(LONG)
SHRegQueryInfoUSKeyW
(
    IN  HUSKEY              hUSKey,
    OUT LPDWORD             pcSubKeys,             OPTIONAL
    OUT LPDWORD             pcchMaxSubKeyLen,      OPTIONAL
    OUT LPDWORD             pcValues,              OPTIONAL
    OUT LPDWORD             pcchMaxValueNameLen,    OPTIONAL
    IN SHREGENUM_FLAGS      enumRegFlags
)
{
    PUSKEY      pUSKey      = (PUSKEY) hUSKey;
    LONG        lRet        = ERROR_INVALID_PARAMETER;

    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (SHREGENUM_BOTH == enumRegFlags)             
    {
        // This is not supported yet. 
        ASSERT(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    if (SHREGENUM_HKCU != enumRegFlags && SHREGENUM_HKLM != enumRegFlags && SHREGENUM_DEFAULT != enumRegFlags)
    {
        // check your arguments.
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    // Default is to try HKCU first.
    if (SHREGENUM_HKCU == enumRegFlags || SHREGENUM_DEFAULT == enumRegFlags)
    {
        lRet = PrivRegQueryInfoKey(pUSKey, &(pUSKey->hkeyCurrentUser), TRUE,
                                pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
    }

    if ((SHREGENUM_HKLM == enumRegFlags) || 
        ((SHREGENUM_DEFAULT == enumRegFlags) && ((ERROR_SUCCESS != lRet) && (ERROR_MORE_DATA != lRet))))
    {
        lRet = PrivRegQueryInfoKey(pUSKey, &(pUSKey->hkeyLocalMachine), TRUE,
                                pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen);
    }

    return lRet;
}

/*----------------------------------------------------------
Purpose: Closes a HUSKEY (Handle to a User Specifc registry key).  

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegCloseUSKey(
    OUT HUSKEY  hUSKey)	
{
    PUSKEY  pUSKey = (PUSKEY) hUSKey;
    LONG    lRet   = ERROR_SUCCESS;

    ASSERT(pUSKey);
    if (FALSE == IS_HUSKEY_VALID(pUSKey))
        return ERROR_INVALID_PARAMETER;

    if (pUSKey->hkeyLocalMachine)
    {
        lRet = RegCloseKey(pUSKey->hkeyLocalMachine);
        pUSKey->hkeyLocalMachine = NULL;             // Used to indicate that it's invalid.
    }
    if (pUSKey->hkeyLocalMachineRelative && HKEY_LOCAL_MACHINE != pUSKey->hkeyLocalMachineRelative)
    {
        lRet = RegCloseKey(pUSKey->hkeyLocalMachineRelative);
    }

    if (pUSKey->hkeyCurrentUser)
    {
        lRet = RegCloseKey(pUSKey->hkeyCurrentUser);
        pUSKey->hkeyCurrentUser = NULL;             // Used to indicate that it's invalid.
    }
    if (pUSKey->hkeyCurrentUserRelative && HKEY_CURRENT_USER != pUSKey->hkeyCurrentUserRelative)
    {
        lRet = RegCloseKey(pUSKey->hkeyCurrentUserRelative);
    }

    LocalFree((HLOCAL)pUSKey);
    return lRet;
}



/*----------------------------------------------------------
Purpose: Gets a registry value that is User Specifc.  
         This opens and closes the key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and then call SHRegQueryUSValue
         rather than using this function repeatedly.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegGetUSValueA(
    IN  LPCSTR  pszSubKey,          
    IN  LPCSTR  pszValue,           
    OUT LPDWORD pdwType,            OPTIONAL
    OUT LPVOID  pvData,             OPTIONAL
    OUT LPDWORD pcbData,            OPTIONAL
    IN  BOOL    fIgnoreHKCU,
    IN  LPVOID  pvDefaultData,      OPTIONAL
    IN  DWORD   dwDefaultDataSize)
{
    LONG    lRet;
    HUSKEY  hUSkeys;
    DWORD   dwInitialSize = (pcbData ? *pcbData : 0);
    DWORD   dwType        = (pdwType ? *pdwType : 0); // callers responsibility to set pdwType to the type of pvDefaultData (if they care)


    lRet = SHRegOpenUSKeyA(pszSubKey, KEY_QUERY_VALUE, NULL, &hUSkeys, fIgnoreHKCU);
    if (ERROR_SUCCESS == lRet)
    {
        lRet = SHRegQueryUSValueA(hUSkeys, pszValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize);
        SHRegCloseUSKey(hUSkeys);
    }
    
    if (ERROR_SUCCESS != lRet)
    {
        // if fail on open OR on query, use default value as long as dwDefaultDataSize isn't 0. (So we return the error)
        if ((pvDefaultData) && (dwDefaultDataSize) && (pvData) && (dwInitialSize >= dwDefaultDataSize))
        {
            MoveMemory(pvData, pvDefaultData, dwDefaultDataSize);
            if (pcbData)
            {
                *pcbData = dwDefaultDataSize;
            }
            if (pdwType)
            {
                *pdwType = dwType;
            }

            lRet = ERROR_SUCCESS;       // Call will now use a default value.
        }
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Gets a registry value that is User Specifc.  
         This opens and closes the key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and then call SHRegQueryUSValue
         rather than using this function repeatedly.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegGetUSValueW(
    IN  LPCWSTR pwzSubKey,          
    IN  LPCWSTR pwzValue,           
    OUT LPDWORD pdwType,            OPTIONAL
    OUT LPVOID  pvData,             OPTIONAL
    OUT LPDWORD pcbData,            OPTIONAL
    IN  BOOL    fIgnoreHKCU,
    IN  LPVOID  pvDefaultData,      OPTIONAL
    IN  DWORD   dwDefaultDataSize)
{
    LONG    lRet;
    HUSKEY  hUSkeys;
    DWORD   dwInitialSize = (pcbData ? *pcbData : 0);
    DWORD   dwType = (pdwType ? *pdwType : 0);  // callers responsibility to set pdwType to the type of pvDefaultData (if they care)

    lRet = SHRegOpenUSKeyW(pwzSubKey, KEY_QUERY_VALUE, NULL, &hUSkeys, fIgnoreHKCU);
    if (ERROR_SUCCESS == lRet)
    {
        lRet = SHRegQueryUSValueW(hUSkeys, pwzValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize);
        SHRegCloseUSKey(hUSkeys);
    }
		
    if (ERROR_SUCCESS != lRet)
    {
        // if fail on open OR on query, use default value as long as dwDefaultDataSize isn't 0. (So we return the error)
        if ((pvDefaultData) && (dwDefaultDataSize) && (pvData) && (dwInitialSize >= dwDefaultDataSize))
        {
            // if fail, use default value.
            MoveMemory(pvData, pvDefaultData, dwDefaultDataSize);
            if (pcbData)
            {
                *pcbData = dwDefaultDataSize;
            }
            if (pdwType)
            {
                *pdwType = dwType;
            }
            lRet = ERROR_SUCCESS;       // Call will now use a default value.
        }
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Sets a registry value that is User Specifc.  
         This opens and closes the key in which the value resides.  

         Perf:  if your code involves setting a series
         of values in the same key, it is better to open
         the key once and then call SHRegWriteUSValue
         rather than using this function repeatedly.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegSetUSValueA(
    IN  LPCSTR          pszSubKey,          
    IN  LPCSTR          pszValue,           
    IN  DWORD           dwType,
    IN  LPCVOID         pvData,         OPTIONAL
    IN  DWORD           cbData,         OPTIONAL
    IN  DWORD           dwFlags)        OPTIONAL
{
    LONG    lRet;
    HUSKEY  hUSkeys;

    lRet = SHRegCreateUSKeyA(pszSubKey, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hUSkeys, dwFlags);
    if (ERROR_SUCCESS == lRet)
    {
        lRet = SHRegWriteUSValueA(hUSkeys, pszValue, dwType, pvData, cbData, dwFlags);
        SHRegCloseUSKey(hUSkeys);
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Sets a registry value that is User Specifc.  
         This opens and closes the key in which the value resides.  

         Perf:  if your code involves setting a series
         of values in the same key, it is better to open
         the key once and then call SHRegWriteUSValue
         rather than using this function repeatedly.

Returns: LONG containing success or error code.
Cond:    --
*/
STDAPI_(LONG)
SHRegSetUSValueW(
    IN  LPCWSTR         pwzSubKey,          
    IN  LPCWSTR         pwzValue,           
    IN  DWORD           dwType,         OPTIONAL
    IN  LPCVOID         pvData,         OPTIONAL
    IN  DWORD           cbData,         OPTIONAL
    IN  DWORD           dwFlags)        OPTIONAL
{
    LONG    lRet;
    HUSKEY  hUSkeys;

    lRet = SHRegCreateUSKeyW(pwzSubKey, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hUSkeys, dwFlags);
    if (ERROR_SUCCESS == lRet)
    {
        lRet = SHRegWriteUSValueW(hUSkeys, pwzValue, dwType, pvData, cbData, dwFlags);
        SHRegCloseUSKey(hUSkeys);
    }

    return lRet;
}




/*----------------------------------------------------------
Purpose: Gets a BOOL Setting from the registry.  The default
         parameter will be used if it's not found in the registry.  

Cond:    --
*/
#define BOOLSETTING_BOOL_TRUE1W   L"YES"
#define BOOLSETTING_BOOL_TRUE1A   "YES"
#define BOOLSETTING_BOOL_TRUE2W   L"TRUE"
#define BOOLSETTING_BOOL_TRUE2A   "TRUE"
#define BOOLSETTING_BOOL_FALSE1W  L"NO"
#define BOOLSETTING_BOOL_FALSE1A  "NO"
#define BOOLSETTING_BOOL_FALSE2W  L"FALSE"
#define BOOLSETTING_BOOL_FALSE2A  "FALSE"
#define BOOLSETTING_BOOL_1W       L"1"
#define BOOLSETTING_BOOL_1A       "1"
#define BOOLSETTING_BOOL_0W       L"0"
#define BOOLSETTING_BOOL_0A       "0"

STDAPI_(BOOL)
SHRegGetBoolUSValueW(
    IN  LPCWSTR         pwzSubKey,          
    IN  LPCWSTR         pwzValue,           
    IN  BOOL            fIgnoreHKCU,
    IN  BOOL            fDefault)
{
    LONG lRet;
    WCHAR szData[MAX_PATH];
    DWORD dwType = REG_SZ;  //because the default value we pass in is a string.
    DWORD dwSize = sizeof(szData);
    LPCWSTR pszDefault = fDefault ? BOOLSETTING_BOOL_TRUE1W : BOOLSETTING_BOOL_FALSE1W;
    DWORD dwDefaultSize = fDefault ? sizeof(BOOLSETTING_BOOL_TRUE1W) : sizeof(BOOLSETTING_BOOL_FALSE1W); // sizeof() includes terminating NULL

    lRet = SHRegGetUSValueW(pwzSubKey, pwzValue, &dwType, (LPVOID) szData, &dwSize, fIgnoreHKCU, (LPVOID) pszDefault, dwDefaultSize);
    if (ERROR_SUCCESS == lRet)
    {
        if (dwType == REG_BINARY || dwType == REG_DWORD)
        {
            fDefault = (*((DWORD*)szData) != 0);
        }
        else
        {
            if ((0 == lstrcmpiW(BOOLSETTING_BOOL_TRUE1W, szData)) || 
                (0 == lstrcmpiW(BOOLSETTING_BOOL_TRUE2W, szData)) ||
                (0 == lstrcmpiW(BOOLSETTING_BOOL_1W, szData)))
            {
                fDefault = TRUE;        // We read TRUE from the registry.
            }
            else if ((0 == lstrcmpiW(BOOLSETTING_BOOL_FALSE1W, szData)) || 
                (0 == lstrcmpiW(BOOLSETTING_BOOL_FALSE2W, szData)) ||
                (0 == lstrcmpiW(BOOLSETTING_BOOL_0W, szData)))
            {
                fDefault = FALSE;        // We read TRUE from the registry.
            }

        }
    }

    return fDefault;
}




/*----------------------------------------------------------
Purpose: Gets a BOOL Setting from the registry.  The default
         parameter will be used if it's not found in the registry.  

Cond:    --
*/

STDAPI_(BOOL)
SHRegGetBoolUSValueA(
    IN  LPCSTR          pszSubKey,          
    IN  LPCSTR          pszValue,           
    IN  BOOL            fIgnoreHKCU,
    IN  BOOL            fDefault)
{
    LONG lRet;
    CHAR szData[MAX_PATH];
    DWORD dwType = REG_SZ;  //because the default value we pass in is a string.
    DWORD dwSize = sizeof(szData);
    LPCSTR pszDefault = fDefault ? BOOLSETTING_BOOL_TRUE1A : BOOLSETTING_BOOL_FALSE1A;
    DWORD dwDefaultSize = (fDefault ? sizeof(BOOLSETTING_BOOL_TRUE1A) : sizeof(BOOLSETTING_BOOL_FALSE1A)) + sizeof(CHAR);

    lRet = SHRegGetUSValueA(pszSubKey, pszValue, &dwType, (LPVOID) szData, &dwSize, fIgnoreHKCU, (LPVOID) pszDefault, dwDefaultSize);
    if (ERROR_SUCCESS == lRet)
    {
        if (dwType == REG_BINARY || dwType == REG_DWORD)
        {
            fDefault = (*((DWORD*)szData) != 0);
        }
        else
        {
            if ((0 == lstrcmpiA(BOOLSETTING_BOOL_TRUE1A, szData)) || 
                (0 == lstrcmpiA(BOOLSETTING_BOOL_TRUE2A, szData)) ||
                (0 == lstrcmpiA(BOOLSETTING_BOOL_1A, szData)))
            {
                fDefault = TRUE;        // We read TRUE from the registry.
            }
            else if ((0 == lstrcmpiA(BOOLSETTING_BOOL_FALSE1A, szData)) || 
                (0 == lstrcmpiA(BOOLSETTING_BOOL_FALSE2A, szData)) ||
                (0 == lstrcmpiA(BOOLSETTING_BOOL_0A, szData)) )
            {
                fDefault = FALSE;        // We read TRUE from the registry.
            }
        }
    }

    return fDefault;
}

STDAPI_(DWORD)
SHGetValueGoodBootA(HKEY hkeyParent, LPCSTR pcszSubKey,
                                   LPCSTR pcszValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen)
{
    if (GetSystemMetrics(SM_CLEANBOOT))
        return ERROR_GEN_FAILURE;

    return SHGetValueA(hkeyParent, pcszSubKey, pcszValue, pdwValueType, pbyteBuf, pdwcbBufLen);
}

STDAPI_(DWORD)
SHGetValueGoodBootW(HKEY hkeyParent, LPCWSTR pcwzSubKey,
                                   LPCWSTR pcwzValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen)
{
    if (GetSystemMetrics(SM_CLEANBOOT))
        return ERROR_GEN_FAILURE;

    return SHGetValueW(hkeyParent, pcwzSubKey, pcwzValue, pdwValueType, pbyteBuf, pdwcbBufLen);
}


/*----------------------------------------------------------
Purpose: Given a CLSID open and return that key from HKCR, or
         the user local version.

Cond:    --
*/

LWSTDAPI SHRegGetCLSIDKeyW(UNALIGNED REFGUID rguid, LPCWSTR pszSubKey, BOOL fUserSpecific, BOOL fCreate, HKEY *phkey)
{
    HKEY    hkeyRef;
    WCHAR   szThisCLSID[GUIDSTR_MAX];
    WCHAR   szPath[GUIDSTR_MAX+MAX_PATH+1];   // room for clsid + extra
    ULONG   err;

    SHStringFromGUIDW(rguid, szThisCLSID, ARRAYSIZE(szThisCLSID));

    if (fUserSpecific)
    {
        hkeyRef = HKEY_CURRENT_USER;
        if (g_bRunningOnNT)
        {
            StrCpyW(szPath, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CLSID\\");
        }
        else
        {
            //
            // On 9x we have to keep using the old location because Plus
            // relies on that location.  (Plus changes the DefaultIcon
            // subkey to get custom regitem icons.)
            //
            StrCpyW(szPath, L"Software\\Classes\\CLSID\\");
        }
    }
    else
    {
        hkeyRef = HKEY_CLASSES_ROOT;
        StrCpyW(szPath, L"CLSID");
        StrCatW(szPath, L"\\");
    }
    
    StrCatW(szPath, szThisCLSID);
    
    if (pszSubKey)
    {
        StrCatW(szPath, L"\\");
        StrCatBuffW(szPath, pszSubKey, ARRAYSIZE(szPath));
    }

    if (fCreate)
    {
        err = RegCreateKeyW(hkeyRef, szPath, phkey);
    }
    else
    {
        err = RegOpenKeyExW(hkeyRef, szPath, 0, MAXIMUM_ALLOWED, phkey);
    }

    return HRESULT_FROM_WIN32(err);
}


LWSTDAPI SHRegGetCLSIDKeyA(UNALIGNED REFGUID rguid, LPCSTR pszSubKey, BOOL fUserSpecific, BOOL fCreate, HKEY *phkey)
{
    HKEY   hkeyRef;
    CHAR   szThisCLSID[GUIDSTR_MAX];
    CHAR   szPath[GUIDSTR_MAX+MAX_PATH+1];   // room for clsid + extra
    ULONG  err;

    SHStringFromGUIDA(rguid, szThisCLSID, ARRAYSIZE(szThisCLSID));

    if (fUserSpecific)
    {
        hkeyRef = HKEY_CURRENT_USER;
        if (g_bRunningOnNT)
        {
            StrCpyA(szPath, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CLSID\\");
        }
        else
        {
            //
            // On 9x we have to keep using the old location because Plus
            // relies on that location.  (Plus changes the DefaultIcon
            // subkey to get custom regitem icons.)
            //
            StrCpyA(szPath, "Software\\Classes\\CLSID\\");
        }
    }
    else
    {
        hkeyRef = HKEY_CLASSES_ROOT;
        StrCpyA(szPath, "CLSID\\");
    }
    StrCatA(szPath, szThisCLSID);
    if (pszSubKey)
    {
        StrCatA(szPath, "\\");
        StrCatBuffA(szPath, pszSubKey, ARRAYSIZE(szPath));
    }

    if (fCreate)
        err = RegCreateKeyA(hkeyRef, szPath, phkey);
    else
        err = RegOpenKeyExA(hkeyRef, szPath, 0, MAXIMUM_ALLOWED, phkey);
    return HRESULT_FROM_WIN32(err);
}

/*----------------------------------------------------------
Purpose: Duplicate an hkey if an object wants to keep one open

//***   Reg_DupKey -- duplicate registry key (upping refcnt)
// NOTES
//  REARCHITECT gotta fix this logic (now that i understand how bogus it is).
//
//  what we're trying to do is dup the handle.  sounds easy.  it isn't.
// here's the deal.
//  1- RegOpenKeyEx(hkey, NULL, ..., &hkey2) is spec'ed as giving back the
//  same handle.  on win95 it ups the refcnt (good!).
//  2- but on winNT there is no refcnt associated w/ it.  so it gives back
//  the same handle but now *any* close will make *all* of the 'pseudo-dup'ed
//  handles invalid.
//  3- (on winNT) if we add MAXIMUM_ALLOWED, we're asking for a new SAM.
//  but the SAM is associated w/ the handle, so the only (or rather, closest)
//  way to do that is to give a new handle.  (presumably this only works
//  if we're not dup'ing a handle that's already MAXIMUM_ALLOWED).
//  4- (on winNT) but wait!  if we open HKEY_CURRENT_USER, we *always* get
//  back 0x80000001 (or somesuch).  but closes on that are ignored, so all
//  works.
//
//  so what we probably should do is:
//  - win95: just do #1, w/ default security.  win95 will give us the same
//  handle w/ an *upped* refcnt and we'll be fine.
//  - winNT: do a DuplicateHandle.  this will correctly give us a *new*
//  handle and we'll be fine.
//
*/
HKEY SHRegDuplicateHKey(HKEY hkey)
{
    HKEY hkeyDup = NULL; // in case incoming hkey is invalid

    // NULL returns key to same place and ups refcnt
    RegOpenKeyExA(hkey, NULL, 0, MAXIMUM_ALLOWED, &hkeyDup);

    // This is a bogus assert on Win95, since they have reference counting on these hkeys...
    if (g_bRunningOnNT)
    {
         ASSERT(hkeyDup != hkey ||
                hkey == HKEY_CURRENT_USER ||
                hkey == HKEY_CLASSES_ROOT ||
                hkey == HKEY_LOCAL_MACHINE);
    }

    return hkeyDup;
}

/*----------------------------------------------------------
Purpose: Read a string value from the registry and convert it
         to an integer.

*/
LWSTDAPI_(int) SHRegGetIntW(HKEY hk, LPCWSTR szKey, int nDefault)
{
    DWORD cb;
    WCHAR ach[20];

    if (hk == NULL)
        return nDefault;

    ach[0] = 0;
    cb = sizeof(ach);
    SHQueryValueExW(hk, szKey, NULL, NULL, (LPBYTE)ach, &cb);

    if (ach[0] >= L'0' && ach[0] <= L'9')
        return StrToIntW(ach);
    else
        return nDefault;
}



//  Stores a file path in the registry but looks for a match with
//  certain environment variables first. This is a FIXED list.

//  Parameters:

//             hKey - an open HKEY or registry root key
//      pszSubKey - subkey in registry or NULL/zero length string
//       pszValue - value name in registry
//        pszPath - Win32 file path to write
//          dwFlags - unused / future expansion

//  Return value:
//      Returns Win32 error code from ADVAPI32.DLL function calls.

//
//  Match        %USERPROFILE% - x:\WINNT\Profiles\<user>
//                             - x:\Documents And Settings\<user>
//          %ALLUSERSPROFILES% - x:\WINNT\Profiles\<user>
//                             - x:\Documents And Settings\<user>
//              %ProgramFiles% - x:\Program Files
//                %SystemRoot% - x:\WINNT
//
//  %ALLUSERSPROFILE% and %ProgramFiles% are dubious and can be
//  removed.
//
//  WARNING: DO NOT CHANGE THE MATCH ORDER OF %USERPROFILE% AND
//  %SystemRoot%
//
//  If %SystemRoot% is matched first then %USERPROFILE% will
//  NEVER be matched if inside x:\WINNT\ 
//
DWORD SHRegSetPathW (HKEY hKey, LPCWSTR pszSubKey, LPCWSTR pszValue, LPCWSTR pszPath, DWORD dwFlags)
{
    DWORD dwType;
    PCWSTR pszData;
    WCHAR  szTemp[MAX_PATH];
    if (PathUnExpandEnvStringsW(pszPath, szTemp, ARRAYSIZE(szTemp)))
    {
        dwType = REG_EXPAND_SZ;
        pszData = szTemp;
    }
    else
    {
        dwType = REG_SZ;
        pszData = pszPath;
    }
    
    return SHSetValueW(hKey, pszSubKey, pszValue, dwType, pszData, (lstrlenW(pszData) + 1) * sizeof(pszData[0]));
}

DWORD SHRegSetPathA(HKEY hKey, LPCSTR pszSubKey, LPCSTR pszValue, LPCSTR pszPath, DWORD dwFlags)
{
    DWORD dwType;
    PCSTR pszData;
    CHAR  szTemp[MAX_PATH];
    if (PathUnExpandEnvStringsA(pszPath, szTemp, ARRAYSIZE(szTemp)))
    {
        dwType = REG_EXPAND_SZ;
        pszData = szTemp;
    }
    else
    {
        dwType = REG_SZ;
        pszData = pszPath;
    }
    
    return SHSetValueA(hKey, pszSubKey, pszValue, dwType, pszData, (lstrlenA(pszData) + 1) * sizeof(pszData[0]));
}

//  RegGetPath: Unicode implementation of function.
//  Returns an expanded file path from the registry.

//  Parameters:

//             hKey - an open HKEY or registry root key
//      pszSubKey - subkey in registry or NULL/zero length string
//       pszValue - value name in registry
//         pwszPath - string to place path in (assumed size of MAX_PATH chars)
//          dwFlags - unused / future expansion

//  Return value:
//      Returns Win32 error code from ADVAPI32.DLL function calls.

DWORD   SHRegGetPathA (HKEY hKey, LPCSTR pszSubKey, LPCSTR pszValue, LPSTR pszPath, DWORD dwFlags)
{
    DWORD cb = MAX_PATH * sizeof(pszPath[0]);
    return SHGetValueA(hKey, pszSubKey, pszValue, NULL, pszPath, &cb);
}

DWORD   SHRegGetPathW (HKEY hKey, LPCWSTR pszSubKey, LPCWSTR pszValue, LPWSTR pszPath, DWORD dwFlags)
{
    DWORD cb = MAX_PATH * sizeof(pszPath[0]);
    return SHGetValueW(hKey, pszSubKey, pszValue, NULL, pszPath, &cb);
}

BOOL Reg_GetCommand(HKEY hkey, LPCWSTR pszKey, LPCWSTR pszValue, LPWSTR pszCommand)
{
    WCHAR szKey[1024];
    LONG cbSize = sizeof(szKey);
    int iLen;

    ASSERT(pszKey);

    StrCpyNW(szKey, pszKey, ARRAYSIZE(szKey));
    iLen = lstrlenW(szKey);
    pszCommand[0] = 0;

    // a trailing backslash means no value key
    if (szKey[iLen-1] == L'\\' ||
        (pszValue && !pszValue[0])) {

        if (!pszValue)
            szKey[iLen-1] = 0;

        RegQueryValueW(hkey, szKey, pszCommand, &cbSize);

    } else {

        if (!pszValue)
            pszValue = PathFindFileNameW(szKey);

        ASSERT(pszValue);
        if (!pszValue)
            return FALSE;

        PathRemoveFileSpecW(szKey);
        SHGetValueGoodBootW(hkey, szKey, pszValue, NULL, (LPBYTE)pszCommand, (DWORD*)&cbSize);
    }

    if (pszCommand[0]) {
        LPWSTR pszNextKey;

        // see if it's a registry spec
        if (!StrCmpNIW(pszCommand, L"HKCU:", 5)) {
            hkey = HKEY_CURRENT_USER;
            pszNextKey = pszCommand + 5;

        } else if (!StrCmpNIW(pszCommand, L"HKLM:", 5)) {
            hkey = HKEY_LOCAL_MACHINE;
            pszNextKey = pszCommand + 5;

        } else if (!StrCmpNIW(pszCommand, L"HKCR:", 5)) {
            hkey = HKEY_CLASSES_ROOT;
            pszNextKey = pszCommand + 5;
        } else {

            return (BOOL)pszCommand[0];
        }

        StrCpyNW(szKey, pszNextKey, ARRAYSIZE(szKey));
        return (Reg_GetCommand(hkey, szKey, NULL, pszCommand));
    }

    return (BOOL)pszCommand[0];
}

#define FillExecInfo(_info, _hwnd, _verb, _file, _params, _dir, _show) \
        (_info).hwnd            = _hwnd;        \
        (_info).lpVerb          = _verb;        \
        (_info).lpFile          = _file;        \
        (_info).lpParameters    = _params;      \
        (_info).lpDirectory     = _dir;         \
        (_info).nShow           = _show;        \
        (_info).fMask           = 0;            \
        (_info).cbSize          = sizeof(SHELLEXECUTEINFOW);

HRESULT RunRegCommand(HWND hwnd, HKEY hkey, LPCWSTR pszKey)
{
    HRESULT hr = E_FAIL;


    WCHAR szCommand[1024];
    if (Reg_GetCommand(hkey, pszKey, L"", szCommand)) 
    {
        LPWSTR pszArgs;
        SHELLEXECUTEINFOW ExecInfo;
        WCHAR szExpCommand[1024];

        SHExpandEnvironmentStringsW(szCommand, szExpCommand, ARRAYSIZE(szExpCommand));

        // Long filenames _should_ be surrounded by quote marks. However, some aren't.
        // This causes problems because the registry entry might be of the form 
        // (c:\program files\Windows Messaging\[...]) instead of 
        // ("c:\program files\Windows Messaging\[...]"). Compare this with 
        // a reg value with (rundll32 C:\progra~1\etc)
        // We end up parsing attempting to run C:\program, which of course doesn't exist.

        // This is a hack for the benefit OSR2, which turns szExpCommand
        // into a null string, rather than letting it be, if it can't be shortened.
        GetShortPathNameW(szExpCommand, szExpCommand, ARRAYSIZE(szExpCommand));
        if ((*szExpCommand==L'\0') && (*szCommand!=L'\0'))
        {
            SHExpandEnvironmentStringsW(szCommand, szExpCommand, ARRAYSIZE(szExpCommand));
        }
        pszArgs = PathGetArgsW(szExpCommand);
        PathRemoveArgsW(szExpCommand);
        PathUnquoteSpacesW(szExpCommand);
        FillExecInfo(ExecInfo, hwnd, NULL, szExpCommand, pszArgs, NULL, SW_SHOWNORMAL);
        if (IsOS(OS_WHISTLERORGREATER))
        {
            ExecInfo.fMask |= SEE_MASK_FLAG_LOG_USAGE;
        }
        hr = ShellExecuteExWrapW(&ExecInfo) ? S_OK : E_FAIL;
    }

    return hr;
}

// NOTE!  RunIndirectRegCommand logs the action as user-initiated!

HRESULT RunIndirectRegCommand(HWND hwnd, HKEY hkey, LPCWSTR pszKey, LPCWSTR pszVerb)
{
    HRESULT hr = E_FAIL;
    WCHAR szDefApp[80];
    LONG cbSize = sizeof(szDefApp);

    if (RegQueryValueW(hkey, pszKey, szDefApp, &cbSize) == ERROR_SUCCESS) 
    {
        WCHAR szFullKey[256];

        // tack on shell\%verb%\command
        wnsprintfW(szFullKey, ARRAYSIZE(szFullKey), L"%s\\%s\\shell\\%s\\command", pszKey, szDefApp, pszVerb);
        hr = RunRegCommand(hwnd, hkey, szFullKey);
    }

    return hr;
}

HRESULT SHRunIndirectRegClientCommand(HWND hwnd, LPCWSTR pszClient)
{
    WCHAR szKey[80];

    wnsprintfW(szKey, ARRAYSIZE(szKey), L"Software\\Clients\\%s", pszClient);
    return RunIndirectRegCommand(hwnd, HKEY_LOCAL_MACHINE, szKey, L"Open");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\regw.cpp ===
#include "priv.h"
#include "unicwrap.h"

/*****************************************************************************\
    FUNCTION: SHLoadRegUIString

    DESCRIPTION:
        loads the data from the value given the hkey and
        pszValue. if the data is of the form:

        @[path\]<dllname>,-<strId>

        the string with id <strId> from <dllname> will be
        loaded. if not explicit path is provided then the
        dll will be chosen according to pluggable UI
        specifications, if possible.

        if the value's data doesn't yield a successful
        string load, then the data itself is returned

    NOTE:
        These strings are always loaded with cross codepage support.

    WARNING:
        This function can end up calling LoadLibrary and FreeLibrary.
        Therefore, you must not call SHLoadRegUIString during process
        attach or process detach.

    PARAMETERS:
        hkey        - hkey of where to look for pszValue
        pszValue    - value with text string or indirector (see above) to use
        pszOutBuf   - buffer in which to return the data or indirected string
        cchOutBuf   - size of pszOutBuf
\*****************************************************************************/

LANGID GetNormalizedLangId(DWORD dwFlag);

STDAPI
SHLoadRegUIStringW(HKEY     hkey,
                   LPCWSTR  pszValue,
                   LPWSTR   pszOutBuf,
                   UINT     cchOutBuf)
{
    HRESULT hr;

    RIP(hkey != NULL);
    RIP(hkey != INVALID_HANDLE_VALUE);
    RIP(NULL == pszValue || IS_VALID_STRING_PTRW(pszValue, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszOutBuf, WCHAR, cchOutBuf));

    DEBUGWhackPathBufferW(pszOutBuf, cchOutBuf);

    // Lots of people (regfldr.cpp, for example)
    // assume they'll get back an empty string on failure,
    // so let's give the public what it wants
    if (cchOutBuf)
        pszOutBuf[0] = 0;

    hr = E_INVALIDARG;

    if (hkey != INVALID_HANDLE_VALUE &&
        hkey != NULL &&
        pszOutBuf != NULL)
    {
        DWORD   cb;
        DWORD   dwRet;
        WCHAR * pszValueDataBuf;

        hr = E_FAIL;

        // first try to get the indirected text which will
        // point to a string id in a dll somewhere... this
        // allows plugUI enabled registry UI strings

        pszValueDataBuf = pszOutBuf;
        cb = CbFromCchW(cchOutBuf);

        dwRet = SHQueryValueExW(hkey, pszValue, NULL, NULL, (LPBYTE)pszValueDataBuf, &cb);
        if (dwRet == ERROR_SUCCESS || dwRet == ERROR_MORE_DATA)
        {
            BOOL fAlloc;

            fAlloc = (dwRet == ERROR_MORE_DATA);

            // if we didn't have space, this is where we correct the problem.
            // we create a buffer big enough, load the data, and leave
            // ourselves with pszValueDataBuf pointing at a valid buffer
            // containing valid data, exactly what we hoped for in the
            // SHQueryValueExW above

            if (fAlloc)
            {
                pszValueDataBuf = new WCHAR[(cb+1)/2];
                
                if (pszValueDataBuf != NULL)
                {
                    // try to load again... overwriting dwRet on purpose
                    // because we only need to know whether we successfully filled
                    // the buffer at some point (whether then or now)
                    
                    dwRet = SHQueryValueExW(hkey, pszValue, NULL, NULL, (LPBYTE)pszValueDataBuf, &cb);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }                
            }

            // proceed if we succesfully loaded something via one of the
            // two SHQueryValueExW calls.
            // we should have the data we want in a buffer pointed
            // to by pszValueDataBuf.
            
            if (dwRet == ERROR_SUCCESS)
            {
                hr = SHLoadIndirectString(pszValueDataBuf, pszOutBuf, cchOutBuf, NULL);
            }

            if (fAlloc && pszValueDataBuf != NULL)
            {
                delete [] pszValueDataBuf;
            }
        }
    }

    return hr;
}

STDAPI
SHLoadRegUIStringA(HKEY     hkey,
                   LPCSTR   pszValue,
                   LPSTR    pszOutBuf,
                   UINT     cchOutBuf)
{
    HRESULT     hr;

    RIP(hkey != NULL);
    RIP(hkey != INVALID_HANDLE_VALUE);
    RIP(IS_VALID_STRING_PTRA(pszValue, -1));
    RIP(IS_VALID_WRITE_BUFFER(pszOutBuf, char, cchOutBuf));

    CStrInW     strV(pszValue);
    CStrOutW    strOut(pszOutBuf, cchOutBuf);

    hr = SHLoadRegUIStringW(hkey, strV, strOut, strOut.BufSize());

    return hr;
}

HRESULT _LoadDllString(LPCWSTR pszSource, LPWSTR pszOutBuf, UINT cchOutBuf)
{
    HRESULT hr = E_FAIL;
    WCHAR * szParseBuf;
    int     nStrId;

    UINT cchSource = lstrlenW(pszSource)+1;

    szParseBuf = new WCHAR[cchSource];
    if (szParseBuf != NULL)
    {
        StrCpyW(szParseBuf, pszSource);

        // see if this is a special string reference.
        // such strings take the form [path\]dllname.dll,-123
        // where 123 is the id of the string resource
        // note that reference by index is not permitted

        nStrId = PathParseIconLocationW(szParseBuf);
        nStrId *= -1;

        if (nStrId > 0)
        {
            LPWSTR      pszDllName;
            HINSTANCE   hinst;
            BOOL        fUsedMLLoadLibrary = FALSE;

            pszDllName = PathFindFileNameW(szParseBuf);
            ASSERT(pszDllName >= szParseBuf);

            // try loading the dll with MLLoadLibrary, but
            // only if an explicit path was not provided.
            // we assume an explicit path means that
            // the caller knows precisely which dll is needed
            // use MLLoadLibrary first, otherwise we'll miss
            // out chance to have plugUI behavior

            hinst = NULL;
            if (pszDllName == szParseBuf)
            {
                if (StrStrI(pszDllName, L"LC.DLL"))
                {
                    // note: using HINST_THISDLL (below) is sort of a hack because that's
                    // techinically supposed to be the *parent* dll's hinstance...
                    // however we get called from lots of places and therefore
                    // don't know the parent dll, and the hinst for browseui.dll
                    // is good enough since all the hinst is really used for is to
                    // find the path to check if the install language is the
                    // currently selected UI language. this will usually be
                    // something like "\winnt\system32"

                    hinst = MLLoadLibraryW(pszDllName, HINST_THISDLL, ML_CROSSCODEPAGE);
                    fUsedMLLoadLibrary = (hinst != NULL);
                }
                else
                    hinst = LoadLibraryExWrapW(pszDllName, NULL, LOAD_LIBRARY_AS_DATAFILE);
            }

            if (!hinst)
            {
                // our last chance to load something is if a full
                // path was provided... if there's a full path it
                // will start at the beginning of the szParseBuf buffer

                if (pszDllName > szParseBuf)
                {
                    // don't bother if the file isn't there
                    // failling in LoadLibrary is slow
                    if (PathFileExistsW(szParseBuf))
                    {
                        hinst = LoadLibraryExWrapW(szParseBuf, NULL, LOAD_LIBRARY_AS_DATAFILE);
                    }
                }
            }

            if (hinst)
            {
                // dll found, so load the string
                if (LoadStringWrapW(hinst, nStrId, pszOutBuf, cchOutBuf))
                {
                    hr = S_OK;
                }
                else
                {
                    TraceMsg(TF_WARNING,
                             "SHLoadRegUIString(): Failure loading string %d from module %ws for valid load request %ws.",
                             nStrId,
                             szParseBuf,
                             pszSource);
                }

                if (fUsedMLLoadLibrary)
                {
                    MLFreeLibrary(hinst);
                }
                else
                {
                    FreeLibrary(hinst);
                }
            }
        }

        delete [] szParseBuf;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

inline BOOL _CanCacheMUI()
{
    if (!g_bRunningOnNT)
        return (GetNormalizedLangId(ML_CROSSCODEPAGE_NT) == MLGetUILanguage());
    return TRUE;
}

// Note: pszSource and pszOutBuf may be the same buffer
LWSTDAPI SHLoadIndirectString(LPCWSTR pszSource, LPWSTR pszOutBuf, UINT cchOutBuf, void **ppvReserved)
{
    HRESULT hr = E_FAIL;

    RIP(IS_VALID_WRITE_BUFFER(pszOutBuf, WCHAR, cchOutBuf));
    RIP(!ppvReserved);

    if (pszSource[0] == L'@') // "@dllname,-id" or "@dllname,-id?lid,string"
    {
        LPWSTR pszResource = StrDupW(pszSource);
        if (pszResource)
        {
            LANGID lidUI =0;
            //  the LidString is there to support our old caching model.
            //  the new caching model doesnt require any work for the caller
            LPWSTR pszLidString = StrChrW(pszResource+1, L'?');
            DWORD cchResource = lstrlen(pszResource);

            //  used to use '@' as the second delimiter as well.
            //  but it has collisions with filesystem paths.
            if (!pszLidString)
                pszLidString = StrChrW(pszResource+1, L'@');
                
            if (pszLidString)
            {
                cchResource = (DWORD)(pszLidString - pszResource);
                // NULL terminate the dll,id just in case we need to actually load
                pszResource[cchResource] = 0;
            }

            DWORD cb = CbFromCchW(cchOutBuf);
            hr = SKGetValue(SHELLKEY_HKCULM_MUICACHE, NULL, pszResource, NULL, pszOutBuf, &cb);
            
            if (FAILED(hr))
            {
                WCHAR wszDllId[MAX_PATH + 1 + 6]; // path + comma + -65536
                SHExpandEnvironmentStringsW(pszResource+1, wszDllId, ARRAYSIZE(wszDllId));
                hr = _LoadDllString(wszDllId, pszOutBuf, cchOutBuf);

                // Might as well write the new string out so we don't have to load the DLL next time through
                // but we don't write cross codepage string on Win9x
                if (SUCCEEDED(hr) && _CanCacheMUI())
                {
                    SKSetValue(SHELLKEY_HKCULM_MUICACHE, NULL, pszResource, REG_SZ, pszOutBuf, CbFromCchW(lstrlenW(pszOutBuf)+1));
                }
            }
            LocalFree(pszResource);

        }
        else
            hr = E_OUTOFMEMORY;

        if (FAILED(hr))
        {
            if (cchOutBuf)
                pszOutBuf[0] = L'\0'; // can't hand out an "@shell32.dll,-525" string
        }
    }
    else
    {
        if (pszOutBuf != pszSource)
            StrCpyN(pszOutBuf, pszSource, cchOutBuf);

        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\shared.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1995
//
// File: shared.c
//
// History:
//  06-07-95 BobDay     Created.
//
// This file contains a set of routines for the management of shared memory.
//
//---------------------------------------------------------------------------
#include "priv.h"
#pragma  hdrstop

//---------------------------------------------------------------------------
// SHAllocShared  - Allocates a handle (in a given process) to a copy of a
//                  memory block in this process.
// SHFreeShared   - Releases the handle (and the copy of the memory block)
//
// SHLockShared   - Maps a handle (from a given process) into a memory block
//                  in this process.  Has the option of transfering the handle
//                  to this process, thereby deleting it from the given process
// SHUnlockShared - Opposite of SHLockShared, unmaps the memory block
//---------------------------------------------------------------------------
HANDLE SHMapHandle(HANDLE hData, DWORD dwSource, DWORD dwDest, DWORD dwDesiredAccess, DWORD dwFlags)
{
    HANDLE hMap = NULL;
    HANDLE hSource;

    // Under certain (valid) circumstances it is possible for DDE to
    // use :0:pid as the shared memory handle, which we should ignore.
    if (hData != NULL)
    {

        if (dwSource == GetCurrentProcessId())
            hSource = GetCurrentProcess();
        else
            hSource = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwSource);

        if (hSource)
        {
            HANDLE hDest;
            if (dwDest == GetCurrentProcessId())
                hDest = GetCurrentProcess();
            else
                hDest = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwDest);

            if (hDest)
            {
                if (!DuplicateHandle(hSource, hData, hDest, &hMap,
                        dwDesiredAccess, FALSE, dwFlags | DUPLICATE_SAME_ACCESS))
                {
                    //  may change the value...
                    hMap = NULL;
                }

                CloseHandle(hDest);
            }

            CloseHandle(hSource);
        }
    }

    return hMap;
}

void _FillHeader(SHMAPHEADER *pmh, DWORD dwSize, DWORD dwSrcId, DWORD dwDstId, void *pvData)
{
    pmh->dwSize = dwSize;
    pmh->dwSig = MAPHEAD_SIG;
    pmh->dwSrcId = dwSrcId;
    pmh->dwDstId = dwDstId;
    
    if (pvData)
        memcpy((pmh + 1), pvData, dwSize);
}    

HANDLE _AllocShared(DWORD dwSize, DWORD dwSrcId, DWORD dwDstId, void *pvData, void **ppvLock)
{
    HANDLE hShared = NULL;
   //
    // Make a filemapping handle with this data in it.
    //
    HANDLE hData = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0,
                               dwSize + sizeof(SHMAPHEADER),NULL);
    if (hData)
    {
        SHMAPHEADER *pmh = MapViewOfFile(hData, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);

        if (pmh)
        {
            _FillHeader(pmh, dwSize, dwSrcId, dwDstId, pvData);
                
            hShared = SHMapHandle(hData, dwSrcId, dwDstId, FILE_MAP_ALL_ACCESS, DUPLICATE_SAME_ACCESS);

            if (hShared && ppvLock)
                *ppvLock = (pmh+1);
            else
                UnmapViewOfFile(pmh);
        }
    
        CloseHandle(hData);
    }

    return hShared;
}

#if SHAREDLOCAL
HANDLE _AllocLocal(DWORD dwSize, DWORD dwSrcId, void *pvData, void **ppvLock)
{
    SHMAPHEADER *pmh = LocalAlloc(LPTR, dwSize + sizeof(SHMAPHEADER));
    if (pmh)
    {
        _FillHeader(pmh, dwSize, dwSrcId, dwSrcId, pvData);
            
        if (ppvLock)
            *ppvLock = (pmh+1);
    }

    return pmh;
}


LWSTDAPI_(HANDLE) SHAllocSharedEx(DWORD dwSize, DWORD dwDstId, void *pvData, void **ppvLock)
{
    DWORD dwSrcId = GetCurrentProcessId();
 
    if (fAllowLocal && dwDstId == dwSrcId)
    {
        return _AllocLocal(dwSize, dwSrcId, pvData, ppvLock);
    }
    else
    {
        return _AllocShared(dwSize, dwSrcId, dwDstId, pvData, ppvLock);
    }
}       
#endif 

HANDLE SHAllocShared(void *pvData, DWORD dwSize, DWORD dwOtherProcId)
{
    return _AllocShared(dwSize, GetCurrentProcessId(), dwOtherProcId, pvData, NULL);
}

LWSTDAPI_(void *) SHLockSharedEx(HANDLE hData, DWORD dwOtherProcId, BOOL fWrite)
{
    HANDLE hMapped = SHMapHandle(hData, dwOtherProcId, GetCurrentProcessId(), FILE_MAP_ALL_ACCESS,0);

    if (hMapped)
    {
        //
        // Now map that new process specific handle and close it
        //
        DWORD dwAccess = fWrite ? FILE_MAP_WRITE | FILE_MAP_READ : FILE_MAP_READ;
        SHMAPHEADER *pmh = (SHMAPHEADER *) MapViewOfFile(hMapped, dwAccess, 0, 0, 0);

        CloseHandle(hMapped);

        if (pmh)
        {
            ASSERT(pmh->dwSig == MAPHEAD_SIG);
            return (void *)(pmh+1);
        }
    }
    return NULL;
}

LWSTDAPI_(void *) SHLockShared(HANDLE hData, DWORD dwOtherProcId)
{
    return SHLockSharedEx(hData, dwOtherProcId, TRUE);
}

LWSTDAPI_(BOOL) SHUnlockShared(void *pvData)
{
    SHMAPHEADER *pmh = ((SHMAPHEADER *)pvData) - 1;

    // Only assert on Whistler or higher, on downlevel machines SHUnlockShared would sometimes be called
    //   without this header (the return value from SHAllocShared, for example) and we would fault.
    ASSERT(!IsOS(OS_WHISTLERORGREATER) || pmh->dwSig == MAPHEAD_SIG);
    
    //
    // Now just unmap the view of the file
    //
    return UnmapViewOfFile(pmh);
}

BOOL SHFreeShared(HANDLE hData, DWORD dwOtherProcId)
{
    if (hData)
    {
        //
        // The below call closes the original handle in whatever process it
        // came from.
        //
        HANDLE hMapped = SHMapHandle(hData, dwOtherProcId, GetCurrentProcessId(),
                                FILE_MAP_ALL_ACCESS, DUPLICATE_CLOSE_SOURCE);

        //
        // Now free up the local handle
        //
        return CloseHandle(hMapped);
    }
    else
    {
        return TRUE; // vacuous success, closing a NULL handle
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\shellacl.c ===
#include "priv.h"
#pragma  hdrstop


//---------------------------------------------------------------------------
//  GetUserToken - Gets the current process's user token and returns
//                        it. It can later be free'd with LocalFree.
//
//  REARCHITECT (reinerf) - stolen from shell32\securent.c, we should consolidate
//                     the code somewhere and export it 
//---------------------------------------------------------------------------
PTOKEN_USER GetUserToken(HANDLE hUser)
{
    PTOKEN_USER pUser;
    DWORD dwSize = 64;
    HANDLE hToClose = NULL;

    if (hUser == NULL)
    {
        OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hUser);
        hToClose = hUser;
    }

    pUser = (PTOKEN_USER)LocalAlloc(LPTR, dwSize);
    if (pUser)
    {
        DWORD dwNewSize;
        BOOL fOk = GetTokenInformation(hUser, TokenUser, pUser, dwSize, &dwNewSize);
        if (!fOk && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
        {
            LocalFree((HLOCAL)pUser);

            pUser = (PTOKEN_USER)LocalAlloc(LPTR, dwNewSize);
            if (pUser)
            {
                fOk = GetTokenInformation(hUser, TokenUser, pUser, dwNewSize, &dwNewSize);
            }
        }
        if (!fOk)
        {
            LocalFree((HLOCAL)pUser);
            pUser = NULL;
        }
    }

    if (hToClose)
    {
        CloseHandle(hToClose);
    }

    return pUser;
}

//
// checks to see if the SHELL_USER_SID is all zeros (flag which means we should really use the users current sid)
//
__inline BOOL IsCurrentUserShellSID(PSHELL_USER_SID psusID)
{
    SID_IDENTIFIER_AUTHORITY sidNULL = {0};

    if ((psusID->dwUserGroupID == 0)    &&
        (psusID->dwUserID == 0)         &&
        memcmp(&psusID->sidAuthority, &sidNULL, sizeof(SID_IDENTIFIER_AUTHORITY)) == 0)
    {
        return TRUE;
    }

    return FALSE;
}


//
// Sets the specified ACE in the ACL to have dwAccessMask permissions.
//
__inline BOOL MakeACEInheritable(PACL pAcl, int iIndex, DWORD dwAccessMask)
{
    ACE_HEADER* pAceHeader;

    if (GetAce(pAcl, iIndex, (LPVOID*)&pAceHeader))
    {
        pAceHeader->AceFlags |= dwAccessMask;
        return TRUE;
    }

    return FALSE;
}


//
// Helper function to generate a SECURITY_DESCRIPTOR with the specified rights
// 
// OUT: psd - A pointer to a uninitialized SECURITY_DESCRIPTOR struct to be inited and filled in
//            in by this function
//
// IN:  PSHELL_USER_PERMISSION  - An array of PSHELL_USER_PERMISSION pointers that specify what access to grant
//      cUserPerm               - The count of PSHELL_USER_PERMISSION pointers in the array above
// 
//
STDAPI_(SECURITY_DESCRIPTOR*) GetShellSecurityDescriptor(PSHELL_USER_PERMISSION* apUserPerm, int cUserPerm)
{
    BOOL fSuccess = TRUE;   // assume success
    SECURITY_DESCRIPTOR* pSD = NULL;
    PSID* apSids = NULL;
    int cAces = cUserPerm;  // one ACE for each entry to start with
    int iAceIndex = 0;      // helps us keep count of how many ACE's we have added (count as we go)
    PTOKEN_USER pUserToken = NULL;
    DWORD cbSidLength = 0;
    DWORD cbAcl;
    PACL pAcl;
    int i;

    ASSERT(!IsBadReadPtr(apUserPerm, sizeof(PSHELL_USER_PERMISSION) * cUserPerm));

    // healthy parameter checking
    if (!apUserPerm || cUserPerm <= 0)
    {
        return NULL;
    }

    // first find out how many additional ACE's we are going to need
    // because of inheritance
    for (i = 0; i < cUserPerm; i++)
    {
        if (apUserPerm[i]->fInherit)
        {
            cAces++;
        }

        // also check to see if any of these are using susCurrentUser, in which case
        // we want to get the users token now so we have it already
        if ((pUserToken == NULL) && IsCurrentUserShellSID(&apUserPerm[i]->susID))
        {
            pUserToken = GetUserToken(NULL);
            if (!pUserToken)    
            {
                DWORD dwLastError = GetLastError();
                TraceMsg(TF_WARNING, "Failed to get the users token.  Error = %d", dwLastError);
                fSuccess = FALSE;
                goto cleanup;
            }
        }
    }

    // alloc the array to hold all the SID's
    apSids = (PSID*)LocalAlloc(LPTR, cUserPerm * sizeof(PSID));
    
    if (!apSids)
    {
        DWORD dwLastError = GetLastError();
        TraceMsg(TF_WARNING, "Failed allocate memory for %i SID's.  Error = %d", cUserPerm, dwLastError);
        fSuccess = FALSE;
        goto cleanup;
    }

    // initialize the SID's
    for (i = 0; i < cUserPerm; i++)
    {
        DWORD cbSid;

        // check for the special case of susCurrentUser
        if (IsCurrentUserShellSID(&apUserPerm[i]->susID))
        {
            ASSERT(pUserToken);
            apSids[i] = pUserToken->User.Sid;
        }
        else
        {
            SID_IDENTIFIER_AUTHORITY sidAuthority = apUserPerm[i]->susID.sidAuthority;

            if (!AllocateAndInitializeSid(&sidAuthority,
                                          (BYTE)(apUserPerm[i]->susID.dwUserID ? 2 : 1),    // if dwUserID is nonzero, then there are two SubAuthorities
                                          apUserPerm[i]->susID.dwUserGroupID,
                                          apUserPerm[i]->susID.dwUserID,
                                          0, 0, 0, 0, 0, 0, &apSids[i]))
            {
                DWORD dwLastError = GetLastError();
                TraceMsg(TF_WARNING, "AllocateAndInitializeSid: Failed to initialze SID.  Error = %d", cUserPerm, dwLastError);
                fSuccess = FALSE;
                goto cleanup;
            }
        }

        // add up all the SID lengths for an easy ACL size computation later...
        cbSid = GetLengthSid(apSids[i]);

        cbSidLength += cbSid;
        
        if (apUserPerm[i]->fInherit)
        {
            // if we have an inherit ACE as well, we need to add in the size of the SID again
            cbSidLength += cbSid;
        }

    }

    // calculate the size of the ACL we will be building (note: used sizeof(ACCESS_ALLOWED_ACE) b/c all ACE's are the same
    // size (excepting wacko object ACE's which we dont deal with). 
    //
    // this makes the size computation easy, since the size of the ACL will be the size of all the ACE's + the size of the SID's.
    cbAcl = SIZEOF(ACL) + (cAces * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))) + cbSidLength;

    // HACKHACK (reinerf)
    //
    // we allocate enough space for the SECURITY_DESCRIPTOR and the ACL together and pass them both back to the
    // caller to free. we need to to this since the SECURITY_DESCRIPTOR contains a pointer to the ACL
    pSD = (SECURITY_DESCRIPTOR*)LocalAlloc(LPTR, SIZEOF(SECURITY_DESCRIPTOR) + cbAcl);

    if (!pSD)
    {
        DWORD dwLastError = GetLastError();
        TraceMsg(TF_WARNING, "Failed to allocate space for the SECURITY_DESCRIPTOR and the ACL.  Error = %d", dwLastError);
        fSuccess = FALSE;
        goto cleanup;
    }

    // set the address of the ACL to right after the SECURITY_DESCRIPTOR in the 
    // block of memory we just allocated
    pAcl = (PACL)(pSD + 1);
    
    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION))
    {
        DWORD dwLastError = GetLastError();
        TraceMsg(TF_WARNING, "InitializeAcl: Failed to init the ACL.  Error = %d", dwLastError);
        fSuccess = FALSE;
        goto cleanup;
    }

    for (i = 0; i < cUserPerm; i++)
    {
        BOOL bRet;

        // add the ACE's to the ACL
        if (apUserPerm[i]->dwAccessType == ACCESS_ALLOWED_ACE_TYPE)
        {
            bRet = AddAccessAllowedAce(pAcl, ACL_REVISION, apUserPerm[i]->dwAccessMask, apSids[i]);
        }
        else
        {
            bRet = AddAccessDeniedAce(pAcl, ACL_REVISION, apUserPerm[i]->dwAccessMask, apSids[i]);
        }

        if (!bRet)
        {
            DWORD dwLastError = GetLastError();
            TraceMsg(TF_WARNING, "AddAccessAllowed/DeniedAce: Failed to add SID.  Error = %d", dwLastError);
            fSuccess = FALSE;
            goto cleanup;
        }

        // sucessfully added an ace
        iAceIndex++;

        ASSERT(iAceIndex <= cAces);

        // if its an inherit ACL, also add another ACE for the inheritance part
        if (apUserPerm[i]->fInherit)
        {
            // add the ACE's to the ACL
            if (apUserPerm[i]->dwAccessType == ACCESS_ALLOWED_ACE_TYPE)
            {
                bRet = AddAccessAllowedAce(pAcl, ACL_REVISION, apUserPerm[i]->dwInheritAccessMask, apSids[i]);
            }
            else
            {
                bRet = AddAccessDeniedAce(pAcl, ACL_REVISION, apUserPerm[i]->dwInheritAccessMask, apSids[i]);
            }

            if (!bRet)
            {
                DWORD dwLastError = GetLastError();
                TraceMsg(TF_WARNING, "AddAccessAllowed/DeniedAce: Failed to add SID.  Error = %d", dwLastError);
                fSuccess = FALSE;
                goto cleanup;
            }

            if (!MakeACEInheritable(pAcl, iAceIndex, apUserPerm[i]->dwInheritMask))
            {
                DWORD dwLastError = GetLastError();
                TraceMsg(TF_WARNING, "MakeACEInheritable: Failed to add SID.  Error = %d", dwLastError);
                fSuccess = FALSE;
                goto cleanup;
            }

            // sucessfully added another ace
            iAceIndex++;
 
            ASSERT(iAceIndex <= cAces);
        }
    }

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        DWORD dwLastError = GetLastError();
        TraceMsg(TF_WARNING, "InitializeSecurityDescriptor: Failed to init the descriptor.  Error = %d", dwLastError);
        fSuccess = FALSE;
        goto cleanup;
    }

    if (!SetSecurityDescriptorDacl(pSD, TRUE, pAcl, FALSE))
    {
        DWORD dwLastError = GetLastError();
        TraceMsg(TF_WARNING, "SetSecurityDescriptorDacl: Failed to set the DACL.  Error = %d", dwLastError);
        fSuccess = FALSE;
        goto cleanup;
    }

cleanup:
    if (apSids)
    {
        for (i = 0; i < cUserPerm; i++)
        {
            if (apSids[i])
            {
                // if this is one of the ones we allocated (eg not the users sid), free it
                if (!pUserToken || (apSids[i] != pUserToken->User.Sid))
                {
                    FreeSid(apSids[i]);
                }
            }
        }

        LocalFree(apSids);
    }

    if (pUserToken)
        LocalFree(pUserToken);

    if (!fSuccess && pSD)
    {
        LocalFree(pSD);
        pSD = NULL;
    }

    return pSD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shlwapi\regsrc.cpp ===
#include "priv.h"

#include <enumt.h>
#include <memt.h>
#include "assoc.h"

class CRegistrySource : public IQuerySource, public IObjectWithRegistryKey
{
    
public:  //  methods
    CRegistrySource() : _cRef(1), _hk(NULL) {}
    ~CRegistrySource() { if (_hk) RegCloseKey(_hk); }
    HRESULT Init(HKEY hk, PCWSTR pszSub, BOOL fCreate);
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID